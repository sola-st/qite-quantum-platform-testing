# Generated by Grammarinator 23.7

import itertools

from math import inf
from grammarinator.runtime import *


class QiskitGenerator(Generator):

    def EOF(self, parent=None):
        pass
    EOF.min_depth = 0

    def program(self, parent=None):
        with RuleContext(self, UnparserRule(name='program', parent=parent)) as current:
            UnlexerRule(src='from', parent=current)
            UnlexerRule(src='qiskit', parent=current)
            UnlexerRule(src='import', parent=current)
            UnlexerRule(src='QuantumCircuit,', parent=current)
            UnlexerRule(src='Aer,', parent=current)
            UnlexerRule(src='transpile,', parent=current)
            UnlexerRule(src='assemble,', parent=current)
            UnlexerRule(src='execute', parent=current)
            self.NEWLINE(parent=current)
            self.NEWLINE(parent=current)
            self.circuit_declaration(parent=current)
            self.circuit_body(parent=current)
            self.run_execution(parent=current)
            return current
    program.min_depth = 2

    def circuit_declaration(self, parent=None):
        with RuleContext(self, UnparserRule(name='circuit_declaration', parent=parent)) as current:
            UnlexerRule(src='# Define the circuit', parent=current)
            self.NEWLINE(parent=current)
            UnlexerRule(src='qc =', parent=current)
            UnlexerRule(src='QuantumCircuit(', parent=current)
            self.INT(parent=current)
            UnlexerRule(src=',', parent=current)
            self.INT(parent=current)
            UnlexerRule(src=')', parent=current)
            self.NEWLINE(parent=current)
            return current
    circuit_declaration.min_depth = 1

    def circuit_body(self, parent=None):
        with RuleContext(self, UnparserRule(name='circuit_body', parent=parent)) as current:
            if self._max_depth >= 2:
                for _ in self._model.quantify(current, 0, min=0, max=inf):
                    self.gate_application(parent=current)
            if self._max_depth >= 2:
                for _ in self._model.quantify(current, 1, min=0, max=inf):
                    self.measurement(parent=current)
            return current
    circuit_body.min_depth = 0

    def gate_application(self, parent=None):
        with RuleContext(self, UnparserRule(name='gate_application', parent=parent)) as current:
            UnlexerRule(src='qc.', parent=current)
            self.gate(parent=current)
            UnlexerRule(src='(', parent=current)
            self.INT(parent=current)
            if self._max_depth >= 1:
                for _ in self._model.quantify(current, 0, min=0, max=1):
                    UnlexerRule(src=',', parent=current)
                    self.INT(parent=current)
            UnlexerRule(src=')', parent=current)
            self.NEWLINE(parent=current)
            return current
    gate_application.min_depth = 1

    def gate(self, parent=None):
        with RuleContext(self, UnparserRule(name='gate', parent=parent)) as current:
            with AlternationContext(self, [0, 0, 0], [1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                UnlexerRule(src=['h', 'cx', 'x'][choice0], parent=current)
            return current
    gate.min_depth = 0

    def measurement(self, parent=None):
        with RuleContext(self, UnparserRule(name='measurement', parent=parent)) as current:
            UnlexerRule(src='qc.measure(', parent=current)
            self.INT(parent=current)
            UnlexerRule(src=',', parent=current)
            self.INT(parent=current)
            UnlexerRule(src=')', parent=current)
            self.NEWLINE(parent=current)
            return current
    measurement.min_depth = 1

    def run_execution(self, parent=None):
        with RuleContext(self, UnparserRule(name='run_execution', parent=parent)) as current:
            self.NEWLINE(parent=current)
            UnlexerRule(src='# Execute the circuit', parent=current)
            self.NEWLINE(parent=current)
            UnlexerRule(src='backend =', parent=current)
            UnlexerRule(src='Aer.get_backend(', parent=current)
            UnlexerRule(src='qasm_simulator', parent=current)
            UnlexerRule(src=')', parent=current)
            self.NEWLINE(parent=current)
            UnlexerRule(src='shots =', parent=current)
            self.INT(parent=current)
            self.NEWLINE(parent=current)
            UnlexerRule(src='job =', parent=current)
            UnlexerRule(src='execute(qc,', parent=current)
            UnlexerRule(src='backend,', parent=current)
            UnlexerRule(src='shots=shots)', parent=current)
            self.NEWLINE(parent=current)
            UnlexerRule(src='result =', parent=current)
            UnlexerRule(src='job.result()', parent=current)
            self.NEWLINE(parent=current)
            UnlexerRule(src='counts =', parent=current)
            UnlexerRule(src='result.get_counts(qc)', parent=current)
            self.NEWLINE(parent=current)
            UnlexerRule(src='print(counts)', parent=current)
            self.NEWLINE(parent=current)
            return current
    run_execution.min_depth = 1

    def NEWLINE(self, parent=None):
        with RuleContext(self, UnlexerRule(name='NEWLINE', parent=parent)) as current:
            if self._max_depth >= 0:
                for _ in self._model.quantify(current, 0, min=0, max=1):
                    UnlexerRule(src='\r', parent=current)
            UnlexerRule(src='\n', parent=current)
            return current
    NEWLINE.min_depth = 0

    def INT(self, parent=None):
        with RuleContext(self, UnlexerRule(name='INT', parent=parent)) as current:
            if self._max_depth >= 0:
                for _ in self._model.quantify(current, 0, min=1, max=inf):
                    UnlexerRule(
                        src=self._model.charset(
                            current, 0, self._charsets[1]),
                        parent=current)
            return current
    INT.min_depth = 0

    _default_rule = program

    _charsets = {
        0: list(itertools.chain.from_iterable([range(32, 127)])),
        1: list(itertools.chain.from_iterable([range(48, 58)])),
    }
