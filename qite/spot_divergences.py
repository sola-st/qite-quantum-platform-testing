"""

1. **Setup the CLI with Click:**
   - Use Click to handle command-line arguments for `input_folder`, `comparison_folder`, and `metadata_folder`.

2. **File Handling:**
   - Iterate over `.qasm` files in the `input_folder`, ignoring subdirectories.
   - Group files by the first 7 digits of their filenames.
   - Sort each group based on the numeric value of the prefix.
   - Print a warning for files not matching the naming pattern.

3. **ComparatorPicker Class:**
   - Implement a base class `ComparatorPicker` with a method `pick(group: List[str], n_comparison: int = 5) -> List[Tuple[str, str]]`.
   - Implement two subclasses:
     - `MostDifferentQASMsComparatorPicker`: Returns pairs with the highest difference in terms of lines in the QASM, sorted in descending order.
     - `RandomComparatorPicker`: Samples `n` pairs of QASM files randomly.

4. **QCEC Verification:**
   - For each pair generated by the comparator, run the QCEC verification using the

qcec.verify

 method.
   - Store the results in the `comparison_folder` with a log of the input QASMs and their provenance.

5. **Metadata Handling:**
   - Access the metadata for each QASM file from the `metadata_folder`.
   - Implement a scalable loop to retrieve metadata for QASM files containing `_qite_`, up to 10 levels deep.

6. **Logging and Error Handling:**
   - Implement robust logging for all operations, including info, debug, and error levels.
   - Handle errors gracefully, ensuring the script continues processing other files if an error occurs.


# Style
- use subfunctions appropriately
- each function has at maximum 7 lines of code of content, break them to smaller functions otherwise
- avoid function with a single line which is a function call
- always use named arguments when calling a function
    (except for standard library functions)
- keep the style consistent to pep8 (max 80 char)
- to print the logs it uses the console from Rich library
- make sure to have docstring for each subfunction and keep it brief to the point
(also avoid comments on top of the functions)
- it uses pathlib every time that paths are checked, created or composed.
- use type annotations with typing List, Dict, Any, Tuple, Optional as appropriate
- make sure that any output folder exists before storing file in it, otherwise create it.

Convert the function above into a click v8 interface in Python.
- map all the arguments to a corresponding option (in click) which is required
- add all the default values of the arguments as default of the click options
- use only underscores
- add a main with the command
- add the required imports
Make sure to add a function and call that function only in the main cli command.
The goal is to be able to import that function also from other files.


"""
import os
import click
from mqt import qcec
import json
import random
import logging
from pathlib import Path
from typing import List, Tuple, Optional

logging.basicConfig(level=logging.INFO)


class ComparatorPicker:
    def pick(self, group: List[str],
             n_comparison: int = 5) -> List[Tuple[str, str]]:
        raise NotImplementedError


class MostDifferentQASMsComparatorPicker(ComparatorPicker):
    def pick(self, group: List[str],
             n_comparison: int = 5) -> List[Tuple[str, str]]:
        group.sort(
            key=lambda x: len(Path(x).read_text().splitlines()),
            reverse=True)
        return [(group[i], group[j]) for i in range(len(group))
                for j in range(i+1, len(group))][:n_comparison]


class RandomComparatorPicker(ComparatorPicker):
    def pick(self, group: List[str],
             n_comparison: int = 5) -> List[Tuple[str, str]]:
        return random.sample([(group[i], group[j])
                              for i in range(len(group))
                              for j in range(i + 1, len(group))],
                             n_comparison)


def get_metadata(file_path: str, metadata_folder: str) -> List[dict]:
    metadata_list = []
    for _ in range(10):
        if "_qite_" not in file_path:
            break
        metadata_path = Path(
            metadata_folder) / Path(file_path).with_suffix('.json').name
        if not metadata_path.exists():
            break
        with metadata_path.open('r') as f:
            metadata = json.load(f)
            metadata_list.append(metadata)
            file_path = metadata.get("input_qasm", "")
    return metadata_list


def process_files(input_folder: str, comparison_folder: str,
                  metadata_folder: str):
    input_path = Path(input_folder)
    comparison_path = Path(comparison_folder)
    metadata_path = Path(metadata_folder)

    if not comparison_path.exists():
        logging.info(f"Creating comparison folder at {comparison_path}")
        comparison_path.mkdir(parents=True)

    logging.info(f"Reading QASM files from {input_path}")
    qasm_files = [
        f for f in input_path.iterdir()
        if f.suffix == '.qasm' and f.is_file()]
    groups = {}
    for file in qasm_files:
        prefix = file.stem[:7]
        if not prefix.isdigit():
            logging.warning(
                f"File {file} does not match the naming pattern and will be "
                "ignored.")
            continue
        if prefix not in groups:
            groups[prefix] = []
        groups[prefix].append(str(file))

    for prefix, group in groups.items():
        logging.info(f"Processing group with prefix {prefix}")
        group.sort(key=lambda x: int(Path(x).stem[:7]))
        comparator = MostDifferentQASMsComparatorPicker()
        pairs = comparator.pick(group)

        for path_qasm_a, path_qasm_b in pairs:
            logging.info(f"Comparing {path_qasm_a} and {path_qasm_b}")
            try:
                result = qcec.verify(
                    str(path_qasm_a),
                    str(path_qasm_b),
                    transform_dynamic_circuit=True)
                equivalence = str(result.equivalence)
            except Exception as e:
                logging.error(f"Error during QCEC verification: {e}")
                equivalence = f"error: {e}"

            metadata_a = get_metadata(path_qasm_a, metadata_folder)
            metadata_b = get_metadata(path_qasm_b, metadata_folder)

            log_entry = {
                "qasms": [
                    {"filename": Path(path_qasm_a).name,
                     "provenance": metadata_a[0].get(
                        "platform", "generator")
                     if metadata_a else "generator",
                     "provenance_tree": metadata_a},
                    {"filename": Path(path_qasm_b).name,
                     "provenance": metadata_b[0].get(
                        "platform", "generator")
                     if metadata_b else "generator",
                     "provenance_tree": metadata_b}],
                "equivalence": equivalence}

            output_path = comparison_path / \
                f"{Path(path_qasm_a).stem}_vs_{Path(path_qasm_b).stem}.json"
            logging.info(f"Writing comparison result to {output_path}")
            with output_path.open('w') as f:
                json.dump(log_entry, f, indent=4)


@click.command()
@click.option('--input_folder', required=True, type=click.Path(
    exists=True, file_okay=False, dir_okay=True))
@click.option('--comparison_folder', required=True, type=click.Path(
    file_okay=False, dir_okay=True))
@click.option('--metadata_folder', required=True, type=click.Path(
    exists=True, file_okay=False, dir_okay=True))
def main(input_folder: str, comparison_folder: str, metadata_folder: str):
    logging.info("Starting the process")
    process_files(input_folder, comparison_folder, metadata_folder)
    logging.info("Process completed")


if __name__ == '__main__':
    main()

# Example usage:
# python -m spot_divergences --input_folder /path/to/input_folder --comparison_folder /path/to/comparison_folder --metadata_folder /path/to/metadata_folder
