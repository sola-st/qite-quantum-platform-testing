## Folder: 1.0
### File: 5079_IntegerComparator_num_ancilla_qubits-bd1cff3366c345ae.yaml
---
upgrade_circuits:
  - |
    The property ``IntegerComparator.num_ancilla_qubits`` is removed, which was
    deprecated in Qiskit 0.23 (released in 2020-10). Its functionality is fully covered
    by :attr:`.IntegerComparator.num_ancilla`.


## Folder: 1.0
### File: Update_backend_model_up_conversion_logic-75ecc2030a9fe6b1.yaml
---
upgrade_providers:
  - |
    Changed default value of two arguments (:code:`add_delay` and :code:`filter_faulty`) in
    the :func:`.convert_to_target` function.
    This conversion function now adds delay instructions and removes faulty instructions by default.
fixes:
  - |
    Fixed the return of improper measurement schedules when only a subset of qubits was requested.
    Previously, a measurement schedule for all qubits would be returned.


## Folder: 1.0
### File: __qiskit_version__11305-bcf134513641462b.yaml
---
upgrade_misc:
  - |
    The variable ``qiskit.__qiskit_version__`` is removed as it was deprecated since 
    Qiskit 0.44 (released in 2023-07).
    Instead, you should use ``qiskit.__version__``. The other packages listed in the
    former ``qiskit.__qiskit_version__`` have their own ``__version__`` module level dunder,
    as standard in PEP 8.


## Folder: 1.0
### File: add-annotated-arg-to-control-d9a188fe66f037ad.yaml
---
features_circuits:
  - |
    Added a new argument, ``annotated``, to the methods :meth:`.QuantumCircuit.control`, :meth:`.Gate.control`
    and ``.control()`` methods of :class:`.Gate` subclasses (such as :class:`.UnitaryGate` or :class:`.SwapGate`)
    to optionally return an :class:`.AnnotatedOperation`.
    The default value of ``annotated`` is ``False`` and corresponds to the pre-existing behavior of the method,
    for example::

        SwapGate().control(1, annotated=False)

    returns a :class:`.CSwapGate` while::

        SwapGate().control(2, annotated=False)

    returns a ``ControlledGate``. When ``annotated=True``, the methods return an object of
    type :class:`~.AnnotatedOperation` instead, avoiding the eager construction of the controlled gate's definition.



## Folder: 1.0
### File: add-annotated-arg-to-inverse-2e577f33793c06b1.yaml
---
features_circuits:
  - |
    Added a new argument, ``annotated``, to the methods :meth:`.QuantumCircuit.inverse`, :meth:`.circuit.Instruction.inverse`
    and ``.inverse()`` methods of :class:`~qiskit.circuit.Instruction` subclasses (such as :class:`.SwapGate` or :class:`.SGate`) 
    to optionally return an :class:`.AnnotatedOperation`. 
    The default value of ``annotated`` is ``False`` and corresponds to the pre-existing behavior of the method. 
    Furthermore, for standard gates with an explicitly defined ``inverse`` method,
    the argument ``annotated`` has no effect, for example, both::

        SwapGate().inverse(annotated=False)
        SwapGate().inverse(annotated=True)

    return a :class:`.SwapGate`, and both::

        SGate().inverse(annotated=False)
        SGate().inverse(annotated=True)

    return an :class:`.SdgGate`. The difference manifests for custom instructions without an explicitly defined
    inverse. With ``annotated=False``, the method returns a fresh instruction with the recursively inverted definition,
    just as before. While ``annotated=True`` returns an :class:`.AnnotatedOperation` that represents the instruction
    modified with the :class:`.InverseModifier`.


## Folder: 1.0
### File: add-annotated-to-drawers-8bcc3a069dd981ad.yaml
---
fixes:
  - |
    Fixed an issue in the ``text`` circuit drawer when displaying operations
    that were not :class:`.circuit.instruction.Instruction` class. These operations
    would cause the drawer to fail. Examples were :class:`.Clifford` and
    :class:`.AnnotatedOperation`.

features_visualization:
  - |
    The ``text`` and ``mpl`` outputs for the :meth:`.QuantumCircuit.draw` and
    :func:`.circuit_drawer` circuit drawer functions will now display detailed
    information for operations of :class:`.AnnotatedOperation`. If the
    :attr:`.AnnotatedOperation.modifiers` contains a :class:`.ControlModifier`,
    the operation will be displayed the same way as controlled gates. If
    the :class:`.InverseModifier` or :class:`.PowerModifier` is used,
    these will be indicated with the base operation name. For example:

    .. plot::
       :include-source:

       from qiskit.circuit import (
           AnnotatedOperation,
           ControlModifier,
           PowerModifier,
           InverseModifier,
           QuantumCircuit
       )
       from qiskit.circuit.library import SGate

       annotated_op = AnnotatedOperation(SGate(), [PowerModifier(3.4), ControlModifier(3), InverseModifier()])
       qc = QuantumCircuit(4)
       qc.append(annotated_op, range(4))
       qc.draw("mpl")


## Folder: 1.0
### File: add-commutation-library-88b7ff65b3d35f9a.yaml
---
features_circuits:
  - |
    Added a commutation library to the :class:`.CommutationChecker`. This library stores all the
    commutation relations of unparameterizable standard gates into a dictionary that allows
    for efficient lookup at runtime. This speeds up the execution of the :class:`.CommutationChecker`
    class and, by extension, the :class:`.CommutationAnalysis` transpiler pass, as instead of
    computing whether two unparameterizable standard gates commute it just has to look it up
    from the library.

    Additionally, the :class:`.CommutationChecker` was refactored and now has an upper limit
    set on the number of cached commutation relations that are not in the commutation library.
    This addressed: `#8020 <https://github.com/Qiskit/qiskit/issues/8020>`__ and
    `#7101 <https://github.com/Qiskit/qiskit/issues/7101>`__


## Folder: 1.0
### File: add-filter-op-nodes-aa024a0f1058e4b7.yaml
---
features_transpiler:
  - |
    Added a new transpiler pass :class:`.FilterOpNodes` which is used to filter
    :class:`.DAGOpNode`\s in a :class:`.DAGCircuit`.
  - |
    Added a new keyword argument, ``label``, to the constructor on the
    :class:`.BarrierBeforeFinalMeasurements` transpiler pass. If specified the
    inserted barrier will be assigned the specified label. This also prevents
    the inserted barrier from being merged with any other pre-existing
    adjacent barriers.
other:
  - |
    The preset pass managers used by :func:`.transpile` and returned with
    :class:`.generate_preset_pass_manager` will no longer insert barriers
    before final measurements in the output circuits.


## Folder: 1.0
### File: add-generic-fake-backend-c1434e0c5c413935.yaml
---
features_providers:
  - |
    Added a new class, :class:`.GenericBackendV2`, to the :mod:`qiskit.providers.fake_provider`
    module. This class is configurable, and builds a :class:`~.BackendV2` backend instance that can
    be run locally (in the spirit of fake backends). Users can configure the number of qubits, basis gates,
    coupling map, ability to run dynamic circuits (control flow instructions), instruction calibrations and
    measurement timestep of the backend without having to deal with manual target construction.
    Qubit and gate properties (duration, error) are generated by randomly sampling from default ranges. 
    The seed for this
    random generation can be fixed to ensure the reproducibility of the backend output.
    It's important to note that this backend only supports gates in the standard
    library. If you need a more flexible backend, there is always the option to directly instantiate a
    :class:`.Target` object to use for transpilation.

    Example usage 1::

      from qiskit import QuantumCircuit, transpile
      from qiskit.providers.fake_provider import GenericBackendV2

      # Create a simple circuit
      circuit = QuantumCircuit(3)
      circuit.h(0)
      circuit.cx(0,1)
      circuit.cx(0,2)
      circuit.measure_all()
      circuit.draw('mpl')

      # Define backend with 3 qubits
      backend = GenericBackendV2(num_qubits=3)

      # Transpile and run
      transpiled_circuit = transpile(circuit, backend)
      result = backend.run(transpiled_circuit).result()

    Example usage 2::

      from qiskit import QuantumCircuit, ClassicalRegister, transpile
      from qiskit.providers.fake_provider import GenericBackendV2

      # Create a circuit with classical control
      creg = ClassicalRegister(19)
      qc = QuantumCircuit(25)
      qc.add_register(creg)
      qc.h(0)
      for i in range(18):
          qc.cx(0, i + 1)
      for i in range(18):
          qc.measure(i, creg[i])
      with qc.if_test((creg, 0)):
          qc.ecr(20, 21)

      # Define backend with custom basis gates and control flow instructions
      backend = GenericBackendV2(
          num_qubits=25,
          basis_gates=["ecr", "id", "rz", "sx", "x"],
          control_flow=True,
        )

      #Transpile
      transpiled_qc = transpile(qc, backend)

    .. note::

        The noise properties generated by these class do not mimic any concrete quantum device, and should
        not be used to measure any concrete behaviors. They are "reasonable defaults" that can be used to
        test backend-interfacing functionality not tied specific noise values of real quantum systems.
        For a more accurate simulation of existing devices, you can manually build a noise model from the
        real backend using the functionality offered in :mod:`qiskit_aer`.


## Folder: 1.0
### File: add-generic-v1-fake-backends-f08694b03585833a.yaml
---
features_providers:
  - |
    The :mod:`qiskit.providers.fake_provider` module now includes a series of generic fake backends
    following the :class:`.BackendV1` interface. They have been introduced as an alternative to the
    snapshot-based fake backends exposed in the deprecated ``FakeProvider``
    (``FakeVigo``, ``FakeTokyo``, etc). The list of new fake backends includes:

      * Backends without pulse capabilities:

        * :class:`.Fake5QV1`
        * :class:`.Fake20QV1`

      * Backends with pulse capabilities:

        * :class:`.Fake7QPulseV1`
        * :class:`.Fake27QPulseV1`
        * :class:`.Fake127QPulseV1`

    They can be imported following the pattern: ``from qiskit.providers.fake_provider import Fake5QV1``.
    More details on the backend properties can be found on each backend's API documentation.


## Folder: 1.0
### File: add-invalid-layout-error-d0d64086748d4b54.yaml
---
features_transpiler:
  - |
    Added a new exception class: :class:`.InvalidLayoutError`. This is a :class:`.TranspilerError`
    subclass which is raised when a user provided layout is invalid (mismatched size, duplicate
    qubits, etc).

fixes:
  - |
    Fixed an issue with the :class:`.SetLayout` transpiler pass where an invalid integer list input
    that contained duplicate entries which would result in an invalid :class:`.Layout` being
    generated and subsequent transpiler passes would fail with a cryptic error. This is now caught
    when :meth:`.SetLayout.run` is called an :class:`.InvalidLayoutError` error will be raised
    indicating there are duplicate entries in the integer list.


## Folder: 1.0
### File: add-num-processes-kwarg-to-transpiler-3cb7f3457b54a535.yaml
---
features_transpiler:
  - |
    Added a new keyword argument, ``num_processes``, to :func:`.transpile` and
    the :meth:`.PassManager.run` method. This allows for overriding both
    ``QISKIT_NUM_PROCS`` and the ``num_processes`` field in user configuration files
    on a per-transpile basis. For example::

        from qiskit import transpile, QuantumCircuit

        qc = QuantumCircuit(2)
        qc.h(0)
        qc.cx(0, 1)
        qc.measure_all()

        transpile([qc]*10, basis_gates=['u', 'cz'], num_processes=2)

    will run the transpile over the 10 input circuits using only 2 processes
    and will override the system default, environment variable, or user
    configuration file for that :func:`.transpile` call.


## Folder: 1.0
### File: add-optimize-annotated-pass-89ca1823e7109f81.yaml
---
features_transpiler:
  - |
    Added a new transpiler pass, :class:`.OptimizeAnnotated`, that optimizes annotated
    operations on a quantum circuit.

    Consider the following example::

      from qiskit.circuit import QuantumCircuit
      from qiskit.circuit.annotated_operation import (
          AnnotatedOperation,
          InverseModifier,
          ControlModifier,
      )
      from qiskit.circuit.library import CXGate, SwapGate
      from qiskit.transpiler.passes import OptimizeAnnotated

      # Create a quantum circuit with multiple annotated gates
      gate1 = AnnotatedOperation(
          SwapGate(),
          [InverseModifier(), ControlModifier(2), InverseModifier(), ControlModifier(1)],
      )
      gate2 = AnnotatedOperation(
          SwapGate(),
          [InverseModifier(), InverseModifier()]
      )
      gate3 = AnnotatedOperation(
          AnnotatedOperation(CXGate(), ControlModifier(2)),
          ControlModifier(1)
      )
      qc = QuantumCircuit(6)
      qc.append(gate1, [3, 2, 4, 0, 5])
      qc.append(gate2, [1, 5])
      qc.append(gate3, [5, 4, 3, 2, 1])

      # Optimize the circuit using OptimizeAnnotated transpiler pass
      qc_optimized = OptimizeAnnotated()(qc)

      # This is how the optimized circuit should look like
      gate1_expected = AnnotatedOperation(SwapGate(), ControlModifier(3))
      gate2_expected = SwapGate()
      gate3_expected = AnnotatedOperation(CXGate(), ControlModifier(3))
      qc_expected = QuantumCircuit(6)
      qc_expected.append(gate1_expected, [3, 2, 4, 0, 5])
      qc_expected.append(gate2_expected, [1, 5])
      qc_expected.append(gate3_expected, [5, 4, 3, 2, 1])

      assert qc_optimized == qc_expected

    In the case of ``gate1``, the modifiers of the annotated swap gate are brought
    into the canonical form: the two :class:`.InverseModifier`\s cancel out, and the two
    :class:`.ControlModifier`\s are combined. In the case of ``gate2``, all the modifiers
    get removed and the annotated operation is replaced by its base operation.
    In the case of ``gate3``, multiple layers of annotations are combined into one.

    The constructor of the :class:`.OptimizeAnnotated` pass accepts optional
    arguments ``target``, ``equivalence_library``,  ``basis_gates`` and ``recurse``.
    When ``recurse`` is ``True`` (the default value) and when either ``target``
    or ``basis_gates`` are specified, the pass recursively descends into the gate's
    ``definition`` circuits, with the exception of gates that are already supported
    by the target or that belong to the equivalence library. On the other hand, when
    neither ``target`` nor ``basis_gates`` are specified,
    or when ``recurse`` is set to ``False``,
    the pass synthesizes only the "top-level" annotated operations, i.e. does not
    recursively descend into the ``definition`` circuits. This behavior is consistent
    with that of the :class:`.HighLevelSynthesis` transpiler pass, which needs to be called
    in order to "unroll" the annotated operations into 1-qubit and 2-qubits gates.


## Folder: 1.0
### File: add-parameter-pow-ff5f8d10813f5733.yaml
---
features_circuits:
  - |
    :class:`~qiskit.circuit.ParameterExpression` (and thus also
    :class:`~qiskit.circuit.Parameter`) now support powering: :code:`x**y`
    where :code:`x` and :code:`y` can be any combination of
    :class:`~qiskit.circuit.ParameterExpression` and number types.


## Folder: 1.0
### File: add-qpy-loading-depr-warning-8628b23ca63c3eb5.yaml
---
features_qpy:
  - |
    Added a new warning class, :exc:`~.QPYLoadingDeprecatedFeatureWarning`, to the QPY module.
    This class allows for deprecation warnings to surface even if the deprecated feature
    is accessed at a variable point in the call stack, as is the case for many QPY loading functions that
    are called recursively.


## Folder: 1.0
### File: add-qpy-version-flag-6bb1756e671fde55.yaml
---
features_qpy:
  - |
    Added a new flag, ``version``, to the :func:`.qpy.dump` function. This allows
    :func:`.qpy.dump` to optionally take an integer value for the :ref:`qpy_format`
    version to emit. This is useful if you need to generate a QPY
    file that will be loaded by an older version of Qiskit. However, the
    supported versions to emit are limited, only versions between the latest
    QPY version (which is the default), and the compatibility QPY version
    which is :ref:`qpy_version_10` (which was introduced in Qiskit 0.45.0) can
    be used. The compatibility version will remain fixed for the entire
    1.x.y major version release series. This does not change the backwards
    compatibility guarantees of the QPY format when calling :func:`.qpy.load`,
    it just enables users to emit an older version of QPY to maintain
    compatibility and interoperability between the 0.x and 1.x release series.


## Folder: 1.0
### File: add-synth-circuit-from-stabilizer-list-4cf9cfa01bbc7ddf.yaml
---
features_synthesis:
  - |
    Added a :func:`qiskit.synthesis.synth_circuit_from_stabilizers` function that
    returns a circuit that outputs the state stabilized by a series of given stabilizers.
features_quantum_info:
  - |
    Added a :meth:`qiskit.quantum_info.StabilizerState.from_stabilizer_list` method
    that generates a stabilizer state from a list of stabilizers::

        from qiskit.quantum_info import StabilizerState

        stabilizer_list = ["ZXX", "-XYX", "+ZYY"]
        stab = StabilizerState.from_stabilizer_list(stabilizer_list)


## Folder: 1.0
### File: add-token-swapper-synthesis-plugin-4ed5009f5f21519d.yaml
---
upgrade:
  - |
    Qiskit 1.0 now requires version 0.14.0 of ``rustworkx``. The minimum
    version requirement was raised to support the new ``token_swapper``
    :class:`.PermutationGate` synthesis plugin for :class:`.HighLevelSynthesisPlugin`.
features_transpiler:
  - |
    Added a new :class:`.HighLevelSynthesisPlugin` for :class:`.PermutationGate`
    objects based on Qiskit's token swapper algorithm. To use this plugin,
    specify ``token_swapper`` when defining high-level-synthesis config.

    This synthesis plugin is able to run before or after the layout is set.
    When synthesis succeeds, the plugin outputs a quantum circuit consisting only of
    swap gates. When synthesis does not succeed, the plugin outputs ``None``.

    The following code illustrates how the new plugin can be run::

        from qiskit.circuit import QuantumCircuit
        from qiskit.circuit.library import PermutationGate
        from qiskit.transpiler import PassManager, CouplingMap
        from qiskit.transpiler.passes.synthesis.high_level_synthesis import HighLevelSynthesis, HLSConfig

        # This creates a circuit with a permutation gate.
        qc = QuantumCircuit(8)
        perm_gate = PermutationGate([0, 1, 4, 3, 2])
        qc.append(perm_gate, [3, 4, 5, 6, 7])

        # This defines the coupling map.
        coupling_map = CouplingMap.from_ring(8)

        # This high-level-synthesis config specifies that we want to use
        # the "token_swapper" plugin for synthesizing permutation gates,
        # with the option to use 10 trials.
        synthesis_config = HLSConfig(permutation=[("token_swapper", {"trials": 10})])

        # This creates the pass manager that runs high-level-synthesis on our circuit.
        # The option use_qubit_indices=True indicates that synthesis is run after the layout is set,
        # and hence should preserve the specified coupling map.
        pm = PassManager(
            HighLevelSynthesis(
                synthesis_config, coupling_map=coupling_map, target=None, use_qubit_indices=True
            )
        )

        qc_transpiled = pm.run(qc)


## Folder: 1.0
### File: allow-none-layout-for-sparse_pauli_op-212470d5b5b307a0.yaml
---
features_quantum_info:
  - |
    The function :meth:`~.SparsePauliOp.apply_layout` from :class:`.SparsePauliOp` now allows for the
    layout argument to also be ``None``. That is, the method can now also be used for circuits where no transpilation/routing
    took place (for example when transpiling for a simulator).


## Folder: 1.0
### File: aqc-faster-default-8d47c88fefd1b6f6.yaml
---
features_synthesis:
  - |
    The AQC unitary synthesis plugin method now uses a faster objective function
    evaluation by default, which results in substantial improvement in synthesis time.


## Folder: 1.0
### File: assign-by-name-305f2bbf89099174.yaml
---
features_circuits:
  - |
    :meth:`.QuantumCircuit.assign_parameters` now accepts string keys in the mapping form of input.
    These names are used to look up the corresponding :class:`.Parameter` instance using
    :meth:`~.QuantumCircuit.get_parameter`.  This lets you do::

      from qiskit.circuit import QuantumCircuit, Parameter

      a = Parameter("a")
      qc = QuantumCircuit(1)
      qc.rx(a, 0)

      qc.assign_parameters({"a": 1}) == qc.assign_parameters({a: 1})


## Folder: 1.0
### File: bit-interning-35da0aaa76aa7fc5.yaml
---
upgrade_circuits:
  - |
    To support a more compact in-memory representation, the
    :class:`.QuantumCircuit` class is now limited to supporting
    a maximum of ``2^32 (=4,294,967,296)`` qubits and clbits,
    for each of these two bit types (the limit is not combined).
    The number of unique sequences of indices used in
    :attr:`.CircuitInstruction.qubits` and
    :attr:`.CircuitInstruction.clbits` is also limited to ``2^32``
    for instructions added to a single circuit.
features_circuits:
  - |
    The :class:`.QuantumCircuit` class now internally performs interning for
    the ``qubits`` and ``clbits`` of the :class:`.CircuitInstruction`
    instances that it stores, resulting in a potentially significant
    reduction in memory footprint, especially for large circuits.


## Folder: 1.0
### File: bump-msrv-f1449061b057cac5.yaml
---
upgrade:
  - |
    The minimum supported Rust version for building Qiskit from source is now
    1.70. This has been raised from the previous minimum supported Rust
    version of 1.64 in the Qiskit 0.45.x and 0.46.0 release series.


## Folder: 1.0
### File: circuit-get-parameter-d33c08925b5c7d72.yaml
---
features_circuits:
  - |
    :class:`.QuantumCircuit` has two new methods, :meth:`~.QuantumCircuit.get_parameter` and
    :meth:`~.QuantumCircuit.has_parameter`, which respectively retrieve a :class:`.Parameter`
    instance used in the circuit by name, and return a boolean of whether a parameter with a
    matching name (or the exact instance given) are used in the circuit.


## Folder: 1.0
### File: commutative-inv-cancellation-uptophase-028525d21b199cef.yaml
---
features_transpiler:
  - |
    Added two new arguments, ``matrix_based`` and ``max_qubits``, to the
    constructor of the :class:`.CommutativeInverseCancellation` transpiler pass.
    When ``matrix_based`` is ``True``, the pass uses matrix representations to
    check whether two operations are the inverse of each other. This makes the
    checks more powerful, and in addition allows for cancelling pairs of operations
    that are inverse up to a phase, while updating the global phase of the circuit
    accordingly. This generally leads to more reductions at the expense of increased
    runtime. The argument ``max_qubits`` limits the number of qubits in matrix-based
    commutativity and inverse checks. For example::

        import numpy as np
        from qiskit.circuit import QuantumCircuit
        from qiskit.transpiler import PassManager
        from qiskit.transpiler.passes import CommutativeInverseCancellation

        circuit = QuantumCircuit(1)
        circuit.rz(np.pi / 4, 0)
        circuit.p(-np.pi / 4, 0)

        passmanager = PassManager(CommutativeInverseCancellation(matrix_based=True))
        new_circuit = passmanager.run(circuit)

    The pass is able to cancel the ``RZ`` and ``P`` gates, while adjusting the circuit's global
    phase to :math:`\frac{15 \pi}{8}`.


## Folder: 1.0
### File: dep-estimator-paulilist-ef2bb2865b66f012.yaml
---
upgrade_quantum_info:
  - |
    Using a :class:`~.PauliList` as an observable
    when calling
    :meth:`.Estimator.run` is not further supported. Users should instead explicitly convert the argument
    using ``SparsePauliOp(pauli_list)`` first (see :class:`~.SparsePauliOp`).


## Folder: 1.0
### File: deprecate-circuit-qasm-e5bbad027388e3f2.yaml
---
upgrade_circuits:
  - |
    Removed the ``Instruction.qasm`` method, which was deprecated in Qiskit 0.45.0.
    Use :func:`qiskit.qasm2.dump` with a complete :class:`.QuantumCircuit` instead.


## Folder: 1.0
### File: deprecate-pulse-instruction-call-52dca0dd26e1c768.yaml
---
upgrade_pulse:
  - |
    Removed the deprecated class ``qiskit.pulse.instructions.Call``
    No alternative pulse instruction is provided.


## Folder: 1.0
### File: deprecate-qinfo-synthesis-23abd8c34fc0f52e.yaml
---
upgrade_synthesis:
  - |
    The following deprecated functions previously in :mod:`qiskit.quantum_info`
    have been removed. These functions were marked as deprecated in the
    Qiskit 0.40.0 release in 2023-01.

      * ``decompose_clifford``: you should use the
        :func:`.qiskit.synthesis.synth_clifford_full` function instead.
      * ``decompose_cnotdihedral``: you should use the
        :func:`.qiskit.synthesis.synth_cnotdihedral_full` function instead.



## Folder: 1.0
### File: deprecate_aquire_alignment-28f64480ed838328.yaml
---
upgrade_transpiler:
  - |
    The deprecated method ``Target.aquire_alignment`` has been removed. It was marked as deprecated in
    Qiskit 0.43 (released 2023-05). The method
    :meth:`.Target.acquire_alignment` should be used instead.


## Folder: 1.0
### File: deprecate_clifford_indexing-5e3500301a696bdc.yaml
---
upgrade_quantum_info:
  - |
    Removed the deprecated ``__getitem__``/``__setitem__`` magic methods of 
    :class:`.Clifford`.
    The methods were deprecated since Qiskit 0.44, released in 2023-07.
    Instead, index or iterate through the :attr:`.Clifford.tableau` attribute.


## Folder: 1.0
### File: deprecation-passmanager-0.25-95eb9b45b517370a.yaml
---
upgrade_transpiler:
  - |
    Removed deprecated function ``qiskit.transpiler.preset_passmanagers.common.get_vf2_call_limit``.
    Instead, use :func:`.get_vf2_limits`.


## Folder: 1.0
### File: expr-hashable-var-types-7cf2aaa00b201ae6.yaml
---
features_circuits:
  - |
    Classical types (subclasses of :class:`~classical.types.Type`) and variables (:class:`~.expr.Var`)
    are now hashable.


## Folder: 1.0
### File: expr-var-standalone-2c1116583a2be9fd.yaml
---
features_circuits:
  - |
    :class:`~.expr.Var` nodes now have a :attr:`.Var.standalone` property to quickly query whether
    they are new-style memory-owning variables, or whether they wrap old-style classical memory in
    the form of a :class:`.Clbit` or :class:`.ClassicalRegister`.


## Folder: 1.0
### File: fast-sparse-pauli-operator-b41cacf11e8c4e0e.yaml
---
features_quantum_info:
  - |
    :meth:`.SparsePauliOp.from_operator` now uses an implementation of the
    "tensorized Pauli decomposition algorithm" presented in
    `Hatznko, Binkowski and Gupta (2023) <https://arxiv.org/abs/2310.13421>`__.  The method is now
    several orders of magnitude faster; for example, it is possible to decompose a random
    10-qubit operator in around 250ms on a consumer Macbook Pro (Intel i7, 2020).


## Folder: 1.0
### File: fix-annotated-qpy-6503362c79f29838.yaml
---
fixes:
  - |
    QPY (using :func:`.qpy.dump` and :func:`.qpy.load`) will now correctly serialize
    and deserialize quantum circuits with annotated operations
    (:class:`.AnnotatedOperation`).


## Folder: 1.0
### File: fix-aqc-optimizer-typehint-34b54c6278d23f79.yaml
---
fixes:
  - |
    The use of the (deprecated) ``Optimizer`` class on :class:`~.AQC` did not have a
    non-deprecated alternative path, which should have been introduced in
    the original ``qiskit-algorithms`` deprecation PR
    `#10406 <https://github.com/Qiskit/qiskit/pull/10406>`_.
    It now accepts a callable that implements the :class:`~.Minimizer` protocol,
    as explicitly stated in the deprecation warning. The callable can look like the
    following example:

      .. code-block:: python

          from functools import partial
          from scipy.optimize import minimize
          from qiskit.synthesis.unitary.aqc import AQC

          optimizer = partial(minimize, args=(), method="L-BFGS-B", options={"maxiter": 200})
          aqc = AQC(optimizer=optimizer)


## Folder: 1.0
### File: fix-barrier-arg-list-check-ff69f37ede6bdf6c.yaml
---
fixes:
  - |
    Fixed an issue with the :class:`.Barrier` class. When adding a
    :class:`.Barrier` instance to a :class:`.QuantumCircuit` with the
    :meth:`.QuantumCircuit.append` method, previously there was no validation
    that the size of the barrier matched the qargs specified.


## Folder: 1.0
### File: fix-block-collapser-cregs-6c2d2dc6931d7bad.yaml
---
fixes:
  - |
    The :class:`.BlockCollapser` transpiler pass will now correctly handle circuits that contain
    more than one condition on the same classical register.


## Folder: 1.0
### File: fix-blueprint-circuit-_append-b4d6c9c41db860f5.yaml
---
fixes:
  - |
    :class:`.BlueprintCircuit` subclasses will now behave correctly when the semi-public method
    :meth:`.QuantumCircuit._append` is used with the blueprint in an unbuilt state, *i.e.* the
    circuit will be built before attempting the append.


## Folder: 1.0
### File: fix-blueprintcircuit-phase-7102043cf2e47e33.yaml
---
fixes:
  - |
    Calling :meth:`~.QuantumCircuit.copy` or :meth:`~.QuantumCircuit.copy_empty_like` on a
    :class:`.BlueprintCircuit` will now correctly propagate the
    :attr:`~.QuantumCircuit.global_phase` to the copy.  Previously, the global phase would always be zero after the copy.


## Folder: 1.0
### File: fix-circuit-barrier-c696eabae1dcc6c2.yaml
---
fixes:
  - |
    :meth:`.QuantumCircuit.barrier` will now generate correct output when given a :class:`set` as
    one of its inputs.  Previously, it would append an invalid operation onto the circuit, though in
    practice this usually would not cause observable problems.
    Fixed `#11208 <https://github.com/Qiskit/qiskit/issues/11208>`__.


## Folder: 1.0
### File: fix-circuit-compose-duplicate-59de6c1c51f58e54.yaml
---
fixes:
  - |
    :meth:`.QuantumCircuit.compose` will now correctly raise a :exc:`.CircuitError` when there are
    duplicates in the ``qubits`` or ``clbits`` arguments.


## Folder: 1.0
### File: fix-clifford-qpy-2ffc8308c888e7e0.yaml
---
fixes:
  - |
    QPY (using :func:`.qpy.dump` and :func:`.qpy.load`) will now correctly serialize
    and deserialize quantum circuits with Clifford operators
    (:class:`~qiskit.quantum_info.Clifford`).


## Folder: 1.0
### File: fix-default-case-empty-0076264db04d6c7a.yaml
---
fixes:
  - |
    Fixed an issue in the ``mpl`` circuit drawer where the text would print beyond
    the end of the box for a :class:`.SwitchCaseOp` if the default case was empty.


## Folder: 1.0
### File: fix-delay-broadcast-e8762b01dfd7e94f.yaml
---
fixes:
  - |
    The qubit-argument broadcasting of :meth:`.QuantumCircuit.delay` now correctly produces
    individual :class:`~.circuit.Delay` instructions for each qubit, as intended.  Previously, when
    given certain iterables (such as :class:`set`\ s), it would instead silently produce an invalid
    circuit that might fail in unusual locations.


## Folder: 1.0
### File: fix-error-message-qpy-version-cf0763da22ce2224.yaml
---
fixes:
  - |
    Fixed an issue with :func:`.qpy.load` when attempting to load a QPY format
    version that is not supported by this version of Qiskit. It will now display
    a descriptive error message. Previously, it would raise an internal error
    because of the incompatibility between the formats, which was difficult to
    debug. If the QPY format version is not supported, that indicates the Qiskit
    version will need to be upgraded to read the QPY payload.


## Folder: 1.0
### File: fix-instruction-condition-bits-17694f98628b30ad.yaml
---
fixes:
  - |
    The property :attr:`.Instruction.condition_bits` will now correctly handle runtime classical
    expressions (:mod:`qiskit.circuit.classical`).


## Folder: 1.0
### File: fix-leaking-split-barrier-7c143d6b13b96ced.yaml
---
fixes:
  - |
    Fixed an issue when using :func:`.transpile` or running a preset pass
    manager (such as generated by :func:`.generate_preset_pass_manager`) when
    targeting a backend that has disjoint connectivity adding extra barriers
    to the output :class:`.QuantumCircuit`. In some cases several
    single qubit :class:`.Barrier` directives would be included in the output
    circuit right before any final measurements in the circuit. This was
    internal state generated by the internal processing for disjoint
    connectivity that was incorrectly being added into the output circuit.
    Fixed `#11649 <https://github.com/Qiskit/qiskit/issues/11649>`__


## Folder: 1.0
### File: fix-missing-pulse-lib-c370f5b9393d0df6.yaml
---
fixes:
  - |
    Fixed an error when a user tries to load calibration
    data of a gate from a :class:`.Target` in a particular situation.
    This occurs when the backend reports only partial calibration data, for
    example referencing a waveform pulse in a command definition but not
    including that waveform pulse in the pulse library. In this situation, the
    Qiskit pulse object could not be built, resulting in a failure to build the pulse
    schedule for the calibration. Now when calibration data is incomplete
    the :class:`.Target` treats it as equivalent to no calibration being reported
    at all and does not raise an exception.


## Folder: 1.0
### File: fix-operator-power-bd9a00b4e6700d2e.yaml
---
fixes:
  - |
    The :meth:`.Operator.power` method now works with floating-point exponents,
    matching the documented description.


## Folder: 1.0
### File: fix-optimize-1q-sim-407b88e45e6062b6.yaml
---
fixes:
  - |
    Fixed an issue with the :class:`.Optimize1qGatesDecomposition` transpiler
    pass where it would potentially resynthesize a single ideal (meaning the
    error rate is ``0.0``) gate which was present in the :class:`.Target`. This
    is now fixed so the pass :class:`.Optimize1qGatesDecomposition` will defer
    to the circuit's gate if the error rate (which includes number of gates)
    are the same.
    Fixed `#10568 <https://github.com/Qiskit/qiskit/issues/10568>`__.


## Folder: 1.0
### File: fix-optimize-swap-before-measure-67e8896da2215d49.yaml
---
fixes:
  - |
    Fixed an issue with the :class:`~.OptimizeSwapBeforeMeasure` pass where
    it would incorrectly optimize circuits involving swap and measure
    instructions.  For example::

        from qiskit import QuantumCircuit
        from qiskit.transpiler.passes import OptimizeSwapBeforeMeasure
        pass_ = OptimizeSwapBeforeMeasure()
        qc = QuantumCircuit(2, 1)
        qc.swap(0, 1)
        qc.measure(0, 0)
        qc.measure(0, 0)
        print(qc.draw())
        print(pass_(qc).draw())

    would previously print::

                  ┌─┐┌─┐
          q_0: ─X─┤M├┤M├
                │ └╥┘└╥┘
          q_1: ─X──╫──╫─
                   ║  ║
          c: 1/════╩══╩═
                   0  0
               ┌─┐
          q_0: ┤M├───
               └╥┘┌─┐
          q_1: ─╫─┤M├
                ║ └╥┘
          c: 1/═╩══╩═
                0  0

    and now the second circuit is correctly optimized to::

          q_0: ──────
               ┌─┐┌─┐
          q_1: ┤M├┤M├
               └╥┘└╥┘
          c: 1/═╩══╩═
                0  0


## Folder: 1.0
### File: fix-param-global-phase-31547267f6124552.yaml
---
fixes:
  - |
    Fixed compatibility of :class:`.DynamicalDecoupling` and
    :class:`.PadDynamicalDecoupling` with circuits that have a parameterized
    global phase.
    Fixed `#10569 <https://github.com/Qiskit/qiskit/issues/10569>`__.


## Folder: 1.0
### File: fix-parameterized-self-inverse-7cb2d68b273640f8.yaml
---
fixes:
  - |
    Fixed an issue with the :class:`~.InverseCancellation` pass where it would
    incorrectly cancel gates passed in as self-inverses with a parameter
    value, if a run of gates had a different parameter value. For example::

        from math import pi

        from qiskit.circuit.library import RZGate
        from qiskit.circuit import QuantumCircuit
        from qiskit.transpiler.passes import InverseCancellation

        inverse_pass = InverseCancellation([RZGate(0)])

        qc = QuantumCircuit(1)
        qc.rz(0, 0)
        qc.rz(pi, 0)
        qc.rz(0, 0)

        inverse_pass(qc)

    would previously have incorrectly cancelled two of the rz gates.


## Folder: 1.0
### File: fix-plot-state-city-viz-2963c83bcf3d3347.yaml
---
fixes:
  - |
    Adjusted zoom, font size, and margins of :func:`.plot_state_city` to fit the plot better for more figure
    sizes.
  - |
    Corrected the Z-ordering behavior of bars and the zero-amplitude plane in :func:`.plot_state_city`.
  - |
    Corrected display of negative real value bars in :func:`.plot_state_city`.


## Folder: 1.0
### File: fix-pulse-channel-hash-549a8fb5d8738c4d.yaml
---
fixes:
  - |
    Fixed the :func:`hash` of Qiskit Pulse ``Channel`` objects (such as :class:`.DriveChannel`) in
    cases where the channel was transferred from one Python process to another that used a different
    hash seed.


## Folder: 1.0
### File: fix-qasm2-deepcopy-conditioned-gate-2fa75fee622c1fc0.yaml
---
fixes:
  - |
    Conditioned custom gates imported from OpenQASM 2 will now correctly retain their conditions
    when pickled and deep-copied.  Previously, any conditional custom gate (defined by a ``gate``
    statement in an OpenQASM 2 file) would lose its condition when copied or pickled.


## Folder: 1.0
### File: fix-qpy-custom-gates-name-conflict-5c4c7df3484f04e0.yaml
---
upgrade_qpy:
  - |
    The latest format version of QPY is now :ref:`qpy_version_11` and this
    is what is emitted by default when running :func:`.qpy.dump`.
fixes:
  - |
    Fixed an issue with the QPY serialization when a :class:`.QuantumCircuit`
    contained multiple custom instructions instances that have the same
    :attr:`~.Instruction.name` attribute. In QPY format versions before
    :ref:`qpy_version_11` the QPY payload did not differentiate between
    these instances and would only serialize the properties of the first
    instance in a circuit. This could potentially cause an incorrect
    deserialization if the other properties of the custom instruction were
    different but the names were the same. This has been fixed in
    QPY :ref:`qpy_version_11` so that each instance of a custom instruction
    is serialized individually and there will no longer be a potential
    conflict with overlapping names.
    Fixes `#8941 <https://github.com/Qiskit/qiskit/issues/8941>`__.


## Folder: 1.0
### File: fix-qpy-statepreparation-retrieval-1feea5eb74db7f1e.yaml
fixes:
  - |
    Fixed QPY deserialization of the :class:`.StatePreparation` and :class:`.Initialize` circuit
    instructions with string and integer parameters (as opposed to an explicit statevector, which
    was already working).  Fixed `#11158 <https://github.com/Qiskit/qiskit/issues/11158>`__.


## Folder: 1.0
### File: fix-qpy-use-symengine-bool-like-d17550057a58abf2.yaml
---
fixes:
  - |
    Fixed an issue with the :func:`.qpy.dump` function where, when the
    ``use_symengine`` flag was set to a truthy object that evaluated to
    ``True`` but was not actually the boolean ``True``, the generated QPY
    payload would be corrupt. For example, if you set ``use_symengine`` to
    :obj:`.HAS_SYMENGINE`, this object evaluates to ``True`` when cast as a bool,
    but isn't actually ``True``.


## Folder: 1.0
### File: fix-qreg-visualization-after-layout-42d3e643b923d8bc.yaml
---
fixes:
  - |
    Fixed a bug in :class:`~.SabreLayout` where it would fail to add the layout
    register information to the property set. This affected circuit visualization, as
    ``circuit.draw()`` after transpilation with certain optimization levels would show
    the full ``Qubit[register]`` label rather than the expected register name
    (e.g. ``q0``).


## Folder: 1.0
### File: fix-schedule-qpy-use-symengine-05ae1dfab73e3ff8.yaml
---
fixes:
  - |
    Fixed an issue with :func:`.qpy.dump` which would cause the function to
    potentially ignore the value of ``use_symengine`` when serializing a
    :class:`.ScheduleBlock` object.


## Folder: 1.0
### File: fix-stabilizerstate-repr-908c830028b1f868.yaml
---
fixes:
  - |
    Fix a bug in the :class:`.StabilizerState` string representation.


## Folder: 1.0
### File: fix-unitary-equal-eb828aca3aaa5e73.yaml
---
fixes:
  - |
    Previously two objects of type :class:`~.UnitaryGate` class were considered equal
    even when they had different global phases. This could lead to transpiler
    passes not maintaining the global phase and, in theory, to incorrect optimizations.
    This commit changes the :meth:`~.UnitaryGate.__eq__` method not to ignore the global
    phases in the comparison.


## Folder: 1.0
### File: fix-v2-conversion-with-defective-backend-6d9cebe55b06b797.yaml
---
fixes:
  - |
    A bug where :func:`.convert_to_target` and :class:`.BackendV2Converter` raised an unexpected
    error was solved. The bug occurred when the backend to convert included calibrations
    for a gate that didn't have a definition in the backend properties.
    Such gate is now broadcast to all qubits as an ideal error-free instruction,
    even when calibrations for a finite set of qubits are reported.
upgrade_providers:
  - |
    The :class:`.BackendProperties` and :class:`.PulseDefaults` model objects used by the
    :class:`.FakeOpenPulse2Q`  have been updated to be internally consistent and add missing
    instructions. If you were relying on the previous model objects as a compilation target you can
    use the backend with Qiskit 0.46 and export a :class:`.QuantumCircuit` generated with
    :func:`.transpile` and serialize it using :class:`.qpy.dump` to access it in this release.


## Folder: 1.0
### File: fix_11143-d32a262538873a9d.yaml
upgrade_visualization:
  - |
    The functions ``qiskit.visualization.state_visualization.num_to_latex_ket`` and
    ``qiskit.visualization.state_visualization.numbers_to_latex_terms`` have been removed, as they
    were removed in Qiskit 0.40 (released in 2023-01). For similar functionality, see Sympy's
    ``nsimplify`` and ``latex`` functions.


## Folder: 1.0
### File: fix_11536-c87d192a133b3dc3.yaml
---
fixes:
  - |
    Fixed an issue with the :func:`.circuit_drawer` function and
    :meth:`.QuantumCircuit.draw` method when loading a matplotlib style
    via the user configuration file.


## Folder: 1.0
### File: fixes_10744-83e5f33f5db74a22.yaml
---
upgrade_circuits:
  - |
    The properties ``Bit.register`` and ``Bit.index`` are removed. They were deprecated in
    Qiskit 0.25 (released in 2021-04). The qubits and bits now live only in the context of
    a :class:`.QuantumCircuit`. The alternative to the properties is
    to use :meth:`.QuantumCircuit.find_bit` to find all the containing
    registers within a circuit and the index of the bit within the
    circuit.


## Folder: 1.0
### File: high-level-synthesis-plugin-list-beff523921c4c4eb.yaml
---
features_transpiler:
  - |
    Added a new function, :func:`.high_level_synthesis_plugin_names`, that can be
    used to get the list of installed high level synthesis plugins for a given
    operation name.


## Folder: 1.0
### File: instructiondurations-subclass-from-backend-1240cb924f386816.yaml
---
fixes:
  - |
    :meth:`.InstructionDurations.from_backend` now returns an instance of any subclass 
    of :class:`.InstructionDurations` instead of the base class. 


## Folder: 1.0
### File: iqp-default-1.0-d9335e866ac8fdbc.yaml
---
upgrade_visualization:
  - |
    The default style for the circuit visualization using Matplotlib has been
    changed to ``"iqp"``, matching the IBM Quantum Platform.
  - |
    The deprecated module ``qiskit.visualization.qcstyle`` has been removed.
    This module has been marked as deprecated since Qiskit 0.39.0. Instead you
    should use the :mod:`qiskit.visualization.circuit.qcstyle`.


## Folder: 1.0
### File: lazy-testers-warn-on-import-errors-95a9bdaacc9c3d2b.yaml
---
features_misc:
  - |
    Added a new warning base class, :exc:`.QiskitWarning`.  While Qiskit will continue to use
    built-in Python warnings (such as :exc:`DeprecationWarning`) when those are most appropriate,
    for cases that are more specific to Qiskit, the warnings will be subclasses of :exc:`.QiskitWarning`.
  - |
    The optional-functionality testers (:mod:`qiskit.utils.optionals`) will now distinguish an
    optional dependency that was completely not found (a normal situation) with one that was found,
    but triggered errors during its import.  In the latter case, they will now issue an
    :exc:`.OptionalDependencyImportWarning` telling you what happened, since it might indicate a
    failed installation or an incompatible version.


## Folder: 1.0
### File: move-synthesis-plugin-error-61e3683bf5a0c225.yaml
---
fixes:
  - |
    The :class:`.UnitarySynthesis` transpiler pass will now generate an error on initialization when
    a nonexistent synthesis plugin is specified, rather than waiting until runtime to raise.  Fixed
    `#11355 <https://github.com/Qiskit/qiskit/issues/11355>`__.


## Folder: 1.0
### File: new-exception-too-wide-3231c1df15952445.yaml
---
features_transpiler:
  - |
    Added a new exception class :exc:`.CircuitToWideForTarget` which
    subclasses :exc:`.TranspilerError`. It's used in places where a
    :exc:`.TranspilerError` was previously raised when the error was that
    the number of circuit qubits was larger than the target backend's qubits.
    The new class enables more differentiating between this error condition and
    other :exc:`.TranspilerError`\s.


## Folder: 1.0
### File: overlap-circuit-barriers-63b9b1be9c1da100.yaml
---
fixes:
  - |
    Fixed a bug which caused :class:`~qiskit.circuit.library.UnitaryOverlap` to error upon initialization if given an input circuit containing a barrier.


## Folder: 1.0
### File: parameter-uuid-60dd46a739afabce.yaml
---
features_circuits:
  - |
    A :attr:`~qiskit.circuit.Parameter.uuid` property was added to the
    :class:`qiskit.circuit.Parameter` class. In advanced use cases,
    this property can be used for creating
    :class:`qiskit.circuit.Parameter` instances that compare equal to
    each other.


## Folder: 1.0
### File: parameterexpression.numeric-958d365dadabfb81.yaml
---
features_circuits:
  - |
    Added a new method, :meth:`.ParameterExpression.numeric`, which converts a fully bound
    parameter expression into the most restrictive built-in Python numeric type that accurately
    describes the result of the symbolic evaluation.  For example, a symbolic integer will become an
    :class:`int`, while a symbolic real number will become a :class:`float` and a complex number
    will become a :class:`complex`.  This method includes several workarounds for peculiarities of
    the evaluation contexts of ``symengine``, which can sometimes lead to spurious results when
    calling :class:`complex` or :class:`float` on an expression directly.


## Folder: 1.0
### File: platform-support-f7f693aaf5dec044.yaml
---
upgrade:
  - |
    The ``symengine`` library is now a hard requirement for all platforms.
    Previously, ``symengine`` was required only on platforms that had
    pre-compiled packages available and ``sympy`` would be used as a fallback
    if it wasn't installed. These split requirements were resulting in increased
    complexity, as it was necessary to determine which libraries were installed
    to debug an issue. Requiring ``symengine`` for all systems greatly decreases
    the complexity and optimizes Qiskit for higher performance. However,
    users on i686 Linux, 32 bit Windows, and s390x Linux (the platforms without
    precompiled packages on PyPI) will need to build Symengine from source.
  - |
    Support for 32 bit platforms, i686 Linux and 32 bit Windows, on
    Python < 3.10 has been downgraded from Tier 2 to Tier 3, as documented in
    the `platform support page <https://docs.quantum.ibm.com/guides/install-qiskit#operating-system-support>`_. This is a consequence of making
    ``symengine`` required for all users, as there is a lack of pre-compiled packages
    available for these platforms, so users will need to build Symengine from
    source.
  - |
    For macOS users, the minimum version of macOS is now 10.12. Previously, the
    precompiled binary wheel packages for macOS x86_64 were published with
    support for >=10.9. However, because of changes in the
    `support policy <https://blog.rust-lang.org/2023/09/25/Increasing-Apple-Version-Requirements.html>`__
    for the Rust programming language the minimum version needed to raised
    to macOS 10.12. If you're using Qiskit on macOS 10.9 you can probably
    build Qiskit from source while the Qiskit MSRV (minimum supported Rust
    version) is < 1.74, but the precompiled binaries published to PyPI will
    only be compatible with macOS >= 10.12.


## Folder: 1.0
### File: preset-pass-manager-approximation-degree-503198b1974adf79.yaml
---
upgrade_transpiler:
  - |
    The implicit use of ``approximation_degree!=1.0`` by default in the
    :func:`~.generate_preset_pass_manager` function has been
    disabled.  The previous default could cause undue and unexpected approximations, especially in
    workloads involving Trotterization or similar runs of operations that are close, but decidedly
    not equal, to the identity.

    This change brings the inner pass-manager generation defaults in line with :func:`.transpile`,
    which was always the intention.  See `#8595 <https://github.com/Qiskit/qiskit/pull/8595>`__ for
    more detail.


## Folder: 1.0
### File: preset-passmanager-coupling-map-89e588e4260cb214.yaml
---
features_transpiler:
  - |
    Enhanced the :func:`.generate_preset_pass_manager` function to allow users to
    provide a coupling map as a legacy-format list. Previously, users were required
    to provide a :class:`.CouplingMap` object.


## Folder: 1.0
### File: primitives-v2-df871c0c6ac0b94a.yaml
---
features_primitives:
  - |
    Version 2 of the primitives is introduced via a new base class for both the sampler and the
    estimator, along with new types for their inputs and outputs. The emphasis of this new
    version is on performing vectorized calls to the primitive ``run()`` methods, so that sweeps
    over parameter value sets and observables can be efficiently specified. See
    :class:`~.StatevectorSampler` and :class:`~.StatevectorEstimator` for reference implementations
    of the V2 primitives.

    Moreover, the estimator has gained a ``precision`` argument in the :meth:`~.BaseEstimatorV2.run`
    method that specifies the targeted precision of the expectation value estimates. Analogously,
    the sampler has moved ``shots`` out of the options and into the arguments of the
    :meth:`~.BaseSamplerV2.run` method. The sampler has also been changed to return the outputs
    (e.g. bitstrings) from every shot, rather than providing a :class:`~.Counts`\-like return, and
    also to store data from separate :class:`~.ClassicalRegister`\s . This enables derived classes
    to implement sampler support for circuits with classical control flow.

    The primitive V2 base classes are:

    * :class:`.BaseSamplerV2`
    * :class:`.BaseEstimatorV2`

    The new types which are used for inputs and outputs are:

    * :const:`.SamplerPubLike`\: primitive unified bloc (PUB) of sampler inputs; a union type
      of allowed inputs to a sampler
    * :const:`.EstimatorPubLike`\: Primitive unified bloc (PUB) of estimator inputs; a union
      type of allowed inputs to an estimator
    * :class:`.PubResult`\: the data and metadata resulting from a single PUB's execution
    * :class:`.DataBin`\: A namespace to hold data from a single PUB's execution
    * :class:`.BitArray`\: an array-valued collection of bit values in a dense format
    * :class:`.PrimitiveResult`: an iterable of :class:`.PubResult`\s along with metadata

  - |
    The reference implementation :class:`~.StatevectorEstimator` of :class:`~.BaseEstimatorV2` was
    added. As seen in the example below, this estimator (and all V2 estimators) supports providing
    arrays of observables and/or  arrays of parameter value sets that are attached to particular
    circuits.

    Each tuple of ``(circuit, observables, <optional> parameter values, <optional> precision)``,
    called an estimator primitive unified bloc (PUB), produces its own array-based result. The
    :meth:`~.EstimatorV2.run` method can be given many pubs at once.

    .. code-block:: python

        from qiskit.circuit import Parameter, QuantumCircuit
        from qiskit.primitives import StatevectorEstimator
        from qiskit.quantum_info import Pauli, SparsePauliOp

        import matplotlib.pyplot as plt
        import numpy as np

        # Define a circuit with two parameters.
        circuit = QuantumCircuit(2)
        circuit.h(0)
        circuit.cx(0, 1)
        circuit.ry(Parameter("a"), 0)
        circuit.rz(Parameter("b"), 0)
        circuit.cx(0, 1)
        circuit.h(0)

        # Define a sweep over parameter values, where the second axis is over
        # the two parameters in the circuit.
        params = np.vstack([
            np.linspace(-np.pi, np.pi, 100),
            np.linspace(-4 * np.pi, 4 * np.pi, 100)
        ]).T

        # Define three observables. Many formats are supported here including
        # classes such as qiskit.quantum_info.SparsePauliOp. The inner length-1
        # lists cause this array of observables to have shape (3, 1), rather
        # than shape (3,) if they were omitted.
        observables = [
            [SparsePauliOp(["XX", "IY"], [0.5, 0.5])],
            [Pauli("XX")],
            [Pauli("IY")]
        ]

        # Instantiate a new statevector simulation based estimator object.
        estimator = StatevectorEstimator()

        # Estimate the expectation value for all 300 combinations of
        # observables and parameter values, where the pub result will have
        # shape (3, 100). This shape is due to our array of parameter
        # bindings having shape (100,), combined with our array of observables
        # having shape (3, 1)
        pub = (circuit, observables, params)
        job = estimator.run([pub])

        # Extract the result for the 0th pub (this example only has one pub).
        result = job.result()[0]

        # Error-bar information is also available, but the error is 0
        # for this StatevectorEstimator.
        result.data.stds

        # Pull out the array-based expectation value estimate data from the
        # result and plot a trace for each observable.
        for idx, pauli in enumerate(observables):
            plt.plot(result.data.evs[idx], label=pauli)
        plt.legend()

  - |
    The reference implementation :class:`~.StatevectorSampler` of :class:`~.BaseSamplerV2` was
    added. As seen in the example below, this sampler (and all V2 samplers) supports
    providing arrays of parameter value sets to bind against a single circuit.

    Each tuple of ``(circuit, <optional> parameter values, <optional> shots)``, called a sampler
    primitive unified bloc (PUB), produces its own array-based result. The :meth:`~.SamplerV2.run`
    method can be given many pubs at once.

    .. code-block:: python

        from qiskit.circuit import (
            Parameter, QuantumCircuit, ClassicalRegister, QuantumRegister
        )
        from qiskit.primitives import StatevectorSampler

        import matplotlib.pyplot as plt
        import numpy as np

        # Define our circuit registers, including classical registers
        # called 'alpha' and 'beta'.
        qreg = QuantumRegister(3)
        alpha = ClassicalRegister(2, "alpha")
        beta = ClassicalRegister(1, "beta")

        # Define a quantum circuit with two parameters.
        circuit = QuantumCircuit(qreg, alpha, beta)
        circuit.h(0)
        circuit.cx(0, 1)
        circuit.cx(1, 2)
        circuit.ry(Parameter("a"), 0)
        circuit.rz(Parameter("b"), 0)
        circuit.cx(1, 2)
        circuit.cx(0, 1)
        circuit.h(0)
        circuit.measure([0, 1], alpha)
        circuit.measure([2], beta)

        # Define a sweep over parameter values, where the second axis is over.
        # the two parameters in the circuit.
        params = np.vstack([
            np.linspace(-np.pi, np.pi, 100),
            np.linspace(-4 * np.pi, 4 * np.pi, 100)
        ]).T

        # Instantiate a new statevector simulation based sampler object.
        sampler = StatevectorSampler()

        # Start a job that will return shots for all 100 parameter value sets.
        pub = (circuit, params)
        job = sampler.run([pub], shots=256)

        # Extract the result for the 0th pub (this example only has one pub).
        result = job.result()[0]

        # There is one BitArray object for each ClassicalRegister in the
        # circuit. Here, we can see that the BitArray for alpha contains data
        # for all 100 sweep points, and that it is indeed storing data for 2
        # bits over 256 shots.
        assert result.data.alpha.shape == (100,)
        assert result.data.alpha.num_bits == 2
        assert result.data.alpha.num_shots == 256

        # We can work directly with a binary array in performant applications.
        raw = result.data.alpha.array

        # For small registers where it is anticipated to have many counts
        # associated with the same bitstrings, we can turn the data from,
        # for example, the 22nd sweep index into a dictionary of counts.
        counts = result.data.alpha.get_counts(22)

        # Or, convert into a list of bitstrings that preserve shot order.
        bitstrings = result.data.alpha.get_bitstrings(22)
        print(bitstrings)


## Folder: 1.0
### File: psutil-dependancy-removed-bf5366f516d92378.yaml
---
upgrade:
  - |
    The dependency on `psutil <https://pypi.org/project/psutil/>`__ has been removed. The
    psutil library was previously only used for detecting the number of physical CPUs and
    total system memory, however this information provided does not add sufficient value
    to justify the additional dependencies and overhead so it has been removed. This does
    mean that the default number of processes used by :func:`.parallel_map` and functions that
    internally can use :func:`.parallel_map` such as :func:`.transpile` and :meth:`.PassManager.run`
    may use more or less parallel processes than in previous releases. If you'd like to adjust the
    number of processes used you can use the new ``num_processes`` argument to those functions, or
    the ``QISKIT_NUM_PROCS`` environment variable or ``num_processes`` field in a user configuration
    file (see the `local configuration guide
    <https://docs.quantum.ibm.com/guides/configure-qiskit-local>`__
    for more details) if you need to adjust the number of processes that Qiskit potentially uses.


## Folder: 1.0
### File: qasm3-importer-0ba0691bcdeba72f.yaml
---
features_qasm:
  - |
    The :mod:`qiskit.qasm3` package now contains a built-in, Rust-based parser for reading OpenQASM
    3 programs into :class:`.QuantumCircuit`\ s, found at :func:`qiskit.qasm3.load_experimental` and
    :func:`~.qasm3.loads_experimental`.  These are typically several times faster than the existing,
    pure Python :func:`~.qasm3.load` and :func:`~.qasm3.loads` functions, which additionally require
    ``qiskit-qasm3-import`` to be installed.

    For example, we can create a 20,000-instruction entangling :class:`.QuantumCircuit`::

      import numpy as np
      import qiskit.qasm3
      from qiskit.circuit.library import RealAmplitudes

      qc = RealAmplitudes(100, reps=100, flatten=True)
      qc = qc.assign_parameters(np.random.rand(qc.num_parameters))
      oq3 = qiskit.qasm3.dumps(qc)

    The old :func:`.qasm3.loads` took about 7.3s to load the resulting OpenQASM 3 program, whereas
    :func:`.qasm3.loads_experimental` took under 300ms on a consumer Macbook Pro (i7, 2020)–a speedup
    of 25x!

    The supported feature set of the experimental parser is very limited in this preview version,
    but this will expand as both the Qiskit side and `the native Rust-based parser
    <https://github.com/Qiskit/openqasm3_parser>`__ improve.

    One of our main goals with this new parser, alongside the huge speed improvements, is to provide
    top-quality error diagnostics.  As with other parts of the parser, these are a work in progress,
    but you'll start to see much higher quality error messages displayed when parsing invalid
    OpenQASM 3 programs with the experimental parser.


## Folder: 1.0
### File: qasm3-minor-version-2ae00ba8f72a1a53.yaml
---
fixes:
  - |
    The OpenQASM 3 exporters :func:`.qasm3.dump` and :func:`~.qasm3.dumps` will now correctly output
    files claiming to be version ``3.0`` rather than the unqualified ``3``, since the OpenQASM 3
    project has now standardized on versioning.


## Folder: 1.0
### File: qasm3-stable-switch-61a10036d1587778.yaml
---
features_qasm:
  - |
    The OpenQASM 3 exporter (see :func:`~.qasm3.dump` and :func:`~.qasm3.dumps` functions in
    :mod:`qiskit.qasm3`) now supports the stabilized syntax of the ``switch`` statement in OpenQASM 3
    by default.  The pre-certification syntax of the ``switch`` statement is still available by
    using the :attr:`.ExperimentalFeatures.SWITCH_CASE_V1` flag in the ``experimental`` argument of
    the exporter.  There is no feature flag required for the stabilized syntax, but if you are
    interfacing with other tooling that is not yet updated, you may need to pass the experimental
    flag.

    The syntax of the stabilized form is slightly different with regards to terminating ``break``
    statements (no longer required nor permitted), and multiple cases are now combined into a single
    ``case`` line, rather than using C-style fall-through.  For more detail, see `the OpenQASM 3
    documentation on the switch-case construct
    <https://openqasm.com/language/classical.html#the-switch-statement>`__.


## Folder: 1.0
### File: qft_lnn_synthesis-c917dc00c3a8cabc.yaml
---
features_synthesis:
  - |
    Add a new synthesis method :func:`.synth_qft_line` of a QFT circuit
    for linear nearest-neighbor connectivity, which significantly reduces
    the number of SWAPs for large numbers of qubits compared to SABRE.


## Folder: 1.0
### File: refactor-basicaer-to-basicprovider-e27aff9c8e81d26e.yaml
---
upgrade_providers:
  - |
    The ``qiskit.providers.basicaer`` module, exposed as ``qiskit.BasicAer``,
    has been removed following it deprecation on the 0.46 release. Its
    functionality has been replaced by the :mod:`qiskit.quantum_info`
    module and the new :mod:`qiskit.providers.basic_provider` module.

    The migration from using ``qiskit.providers.basicaer`` (``qiskit.BasicAer``)
    to :mod:`qiskit.providers.basic_provider` can be performed as follows:

    .. list-table:: BasicAer equivalences
       :header-rows: 1

       * - Migrate from
         - Replace with
       * - ``qiskit.BasicAer``
         - The new provider doesn't have a global instance, imports should be from ``qiskit.providers.basic_provider``
       * - ``qiskit.providers.basicaer``
         - :mod:`.basic_provider`
       * - ``BasicAerProvider``
         - :class:`.BasicProvider`
       * - ``BasicAerJob``
         - :class:`.BasicProviderJob`
       * - ``QasmSimulatorPy``
         - :class:`.BasicSimulator`
       * - ``UnitarySimulatorPy``
         - use :class:`~.quantum_info.Operator`
       * - ``StatevectorSimulatorPy``
         - use :class:`~.quantum_info.Statevector`

    A notable difference is that the new provider is no longer exposed through a global instance
    (like ``BasicAer``), so it will not be valid to do ``from qiskit import BasicProvider``.
    Instead, the provider class must be imported from its submodule and instantiated manually::

        from qiskit.providers.basic_provider import BasicProvider

        provider = BasicProvider()
        backend = provider.get_backend("basic_simulator")

    The following examples show the migration paths of the three simulators in ``BasicAer``.

    1. Statevector simulator::

        from qiskit import QuantumCircuit
        qc = QuantumCircuit(3)
        qc.h(0)
        qc.h(1)
        qc.cx(1,2)

        # Former path
        from qiskit import BasicAer
        backend = BasicAer.get_backend("statevector_simulator")
        statevector = backend.run(qc).result().get_statevector()

        # New path
        from qiskit.quantum_info import Statevector
        statevector = Statevector(qc)

    2. Unitary simulator::

        from qiskit import QuantumCircuit
        qc = QuantumCircuit(3)
        qc.h(0)
        qc.h(1)
        qc.cx(1,2)

        # Former path
        from qiskit import BasicAer
        backend = BasicAer.get_backend("unitary_simulator")
        result = backend.run(qc).result()

        # New path
        from qiskit.quantum_info import Operator
        result = Operator(qc).data

    3. Qasm simulator::

        from qiskit import QuantumCircuit
        qc = QuantumCircuit(3)
        qc.h(0)
        qc.h(1)
        qc.cx(1,2)
        qc.measure_all()

        # Former path
        from qiskit import BasicAer
        backend = BasicAer.get_backend("qasm_simulator")
        result = backend.run(qc).result()

        # New path
        from qiskit.providers.basic_provider import BasicProvider
        backend = BasicProvider().get_backend("basic_simulator")
        result = backend.run(qc).result()
        # or, directly
        from qiskit.providers.basic_provider import BasicSimulator
        backend = BasicSimulator()
        result = backend.run(qc).result()


## Folder: 1.0
### File: remove-aer-hooks-1144714bbbdd0fe8.yaml
---
upgrade_misc:
  - |
    The object ``qiskit.Aer`` has been removed following its deprecation in Qiskit 0.46.  You can
    instead use :attr:`qiskit_aer.Aer`, which is a drop-in replacement.
  - |
    Importing from ``qiskit.providers.aer`` will no longer work, following its deprecation in Qiskit
    0.46.  You should instead import from ``qiskit_aer``, which is a drop-in replacement.
  - |
    Pulse jobs are no longer supported in fake backends, following the deprecation and removal
    of the underlying simulation functionality in Aer.  For pulse-level simulation, outside
    the context of circuit objects, consider using a special-purpose library such as
    `Qiskit Dynamics <https://qiskit.org/ecosystem/dynamics/>`__.


## Folder: 1.0
### File: remove-algorithm-utils-707648b69af439dc.yaml
---
upgrade_algorithms:
  - |
    The following tools in :mod:`qiskit.utils` have been removed from the codebase:

    * Utils in ``qiskit.utils.arithmetic``
    * Utils in ``qiskit.utils.circuit_utils``
    * Utils in ``qiskit.utils.entangler_map``
    * Utils in ``qiskit.utils.name_unnamed_args``

    These functions were used exclusively in the context of ``qiskit.algorithms`` and
    ``qiskit.opflow``, and were deprecated in Qiskit 0.46. ``qiskit.algorithms`` and
    ``qiskit.opflow`` have been deprecated since Qiskit 0.45 and Qiskit Terra 0.24
    respectively.

    The following utilities have also been removed:

    * Utils in ``qiskit.utils.validation``
    * ``algorithm_globals``

    These were deprecated in Qiskit 0.45 as a consequence of the migration
    of ``qiskit.algorithms`` to `a standalone package
    <https://github.com/qiskit-community/qiskit-algorithms>`_, where
    these utilities have also been migrated. They can be found in the new package
    under ``qiskit_algorithms.utils``.


## Folder: 1.0
### File: remove-bind-parameters-13da38072c28a881.yaml
---
upgrade_circuits:
  - |
    The method ``QuantumCircuit.bind_parameters`` has been removed, following its deprecation in
    Qiskit 0.45.  You can use :meth:`.QuantumCircuit.assign_parameters` as a drop-in replacement
    with all its defaults, and it also exposes additional features over the old method.


## Folder: 1.0
### File: remove-cfun-toplevel-5d0d58bed83d57ed.yaml
---
upgrade_circuits:
  - |
    Importing :class:`.Int1`, :class:`.Int2`, :class:`.BooleanFunction`, :func:`.classical_function`
    from :mod:`qiskit.circuit` is now disabled. Instead, import the objects from the
    :mod:`qiskit.circuit.classicalfunction` submodule, which requires the ``tweedledum`` package.


## Folder: 1.0
### File: remove-configfake-c009f3d28b4fa12b.yaml
---
upgrade_providers:
  - |
    Removed the ``ConfigurableFakeBackend`` class deprecated in
    Qiskit 0.46.0. Instead, a suitable :class:`.FakeBackend` can be used.


## Folder: 1.0
### File: remove-dag-none-be220777dc246803.yaml
---
upgrade_transpiler:
  - |
    It is no longer allowable to pass ``None`` as the ``qargs`` or ``cargs`` parameters in
    :meth:`.DAGCircuit.apply_operation_back` and :meth:`~.DAGCircuit.apply_operation_front`.  If you
    want to explicitly pass an empty argument, use the empty tuple ``()`` instead.


## Folder: 1.0
### File: remove-deprecated-funcs-in-qobj-converter-402408e84b3043bb.yaml
---
upgrade_pulse:
  - |
    Removed deprecated methods in :class:`.InstructionToQobjConverter`
    and :class:`.QobjToInstructionConverter`. This includes

    * :meth:`.InstructionToQobjConverter.convert_acquire`
    * :meth:`.InstructionToQobjConverter.convert_bundled_acquires`
    * :meth:`.InstructionToQobjConverter.convert_set_frequency`
    * :meth:`.InstructionToQobjConverter.convert_shift_frequency`
    * :meth:`.InstructionToQobjConverter.convert_set_phase`
    * :meth:`.InstructionToQobjConverter.convert_shift_phase`
    * :meth:`.InstructionToQobjConverter.convert_delay`
    * :meth:`.InstructionToQobjConverter.convert_play`
    * :meth:`.InstructionToQobjConverter.convert_snapshot`
    * :meth:`.QobjToInstructionConverter.convert_acquire`
    * :meth:`.QobjToInstructionConverter.convert_set_phase`
    * :meth:`.QobjToInstructionConverter.convert_shift_phase`
    * :meth:`.QobjToInstructionConverter.convert_set_frequency`
    * :meth:`.QobjToInstructionConverter.convert_shift_frequency`
    * :meth:`.QobjToInstructionConverter.convert_delay`
    * :meth:`.QobjToInstructionConverter.bind_pulse`
    * :meth:`.QobjToInstructionConverter.convert_parametric`
    * :meth:`.QobjToInstructionConverter.convert_snapshot`

    These public methods are all replaced with protected ones which are implicitly called from
    the single entry point, i.e. calling the class as like a function.


## Folder: 1.0
### File: remove-deprecated-parametric-pulses-class-667e4b970e1163b3.yaml
---
upgrade_pulse:
  - |
    The class ``qiskit.pulse.library.ParametricPulse`` and all subclasses are removed.
    These were deprecated since Qiskit 0.39 (with qiskit-terra 0.22), released in 2022-10.
    Instead, use :class:`.SymbolicPulse` and check its documentation for details.


## Folder: 1.0
### File: remove-deprecated-quantumcircuit-a8c69a8e0b480e17.yaml
---
upgrade_circuits:
  - |
    The ``header`` and ``extension_lib`` data-only attributes from :class:`.QuantumCircuit` are
    removed following their deprecation in Qiskit 0.45.  These were internal details of the OpenQASM
    2 exporter which are no longer used.


## Folder: 1.0
### File: remove-deprecated-unroller-4693330708c681e0.yaml
---
upgrade_transpiler:
  - |
    Removed the deprecated ``Unroller`` class in :mod:`qiskit.transpiler.passes.basis`.
    This class was deprecated in Qiskit 0.45 and use of it can be replaced by
    the combination usage of :class:`.BasisTranslator` and :class:`.UnrollCustomDefinitions`.

    Note that :class:`.BasisTranslator` and :class:`.UnrollCustomDefinitions` take different
    arguments than ``Unroller``, as they requires a ``EquivalenceLibrary`` object to be passed in.

    Where previously ``Unroller(basis_gates)`` could be used,
    you can now use::

      from qiskit.circuit.library.standard_gates.equivalence_library import (
          StandardEquivalenceLibrary as std_eqlib,
      )
      pm = PassManager([
          UnrollCustomDefinitions(std_eqlib, basis_gates)
          BasisTranslator(std_eqlib, basis_gates),
      ])
      translated = pm.run(circuit)


## Folder: 1.0
### File: remove-deprecated-visualization-pulse-8adf40ff1a69df63.yaml
---
upgrade_visualization:
  - |
    The following classes and methods in :mod:`qiskit.visualization.pulse` have been removed follow
    their deprecation in Qiskit 0.40.0:

      * ``SchedStyle``
      * ``PulseStyle``
      * ``matplotlib.EventsOutputChannels``
      * ``matplotlib.WaveformDrawer``
      * ``matplotlib.ScheduleDrawer``
      * ``interpolation.interp1d``
      * ``interpolation.step_wise``

    Use the new interface :func:`qiskit.visualization.pulse_drawer` for pulse visualization.


## Folder: 1.0
### File: remove-discrete-pulse-library-d7aa098a528161df.yaml
---
upgrade_pulse:
  - |
    The discrete pulse library (previously located at ``qiskit.pulse.library.discrete``)
    was removed, following its deprecation in Qiskit 0.46.
    All of the removed pulses have a :class:`~.pulse.SymbolicPulse` counterpart. Consult
    the Qiskit 0.46 release notes for more details.


## Folder: 1.0
### File: remove-execute-699e9aca1662c174.yaml
---
upgrade_misc:
  - |
    Qiskit's :func:`~.execute_function.execute` function is removed.
    This function served as a high-level wrapper around transpiling
    a circuit with some transpile options and running it on a backend
    with some run options.  To do the same thing, you can explicitly
    use the :func:`~.transpile` function (with appropriate transpile
    options) followed by ``backend.run()`` (with appropriate run options).

    For example, instead of running::

      from qiskit import execute
      job = execute(circuit, backend)

    you can run::

      from qiskit import transpile
      new_circuit = transpile(circuit, backend)
      job = backend.run(new_circuit)

    Alternatively, the ``Sampler`` primitive is semantically equivalent to the
    deprecated :func:`~.execute_function.execute` function. The class
    :class:`.BackendSampler` is a generic wrapper for backends that do not support
    primitives::

      from qiskit.primitives import BackendSampler
      sampler = BackendSampler(backend)
      job = sampler.run(circuit)


## Folder: 1.0
### File: remove-extensions-ce520ba419c93c58.yaml
---
upgrade_circuits:
  - |
    Removed the ``qiskit.extensions`` module, which has been pending deprecation since the 0.45 release
    and has been fully deprecated in the 0.46 release.
    The following operations from this module are available in :mod:`qiskit.circuit.library`:

      * :class:`~.library.DiagonalGate`,
      * :class:`~.library.HamiltonianGateGate`,
      * :class:`~.library.Initialize`,
      * :class:`~.library.Isometry`,
      * :class:`~.library.generalized_gates.mcg_up_diag.MCGupDiag`,
      * :class:`~.library.UCGate`,
      * :class:`~.library.UCPauliRotGate`,
      * :class:`~.library.UCRXGate`,
      * :class:`~.library.UCRYGate`,
      * :class:`~.library.UCRZGate`,
      * :class:`~.library.UnitaryGate`.

    The following objects have been removed:

      * ``SingleQubitUnitary`` (instead use :class:`.library.UnitaryGate`),
      * ``Snapshot`` (superseded by Aer's save instructions),
      * ``ExtensionError``,

    along with the following circuit methods:

      * ``QuantumCircuit.snapshot``,
      * ``QuantumCircuit.squ``,
      * ``QuantumCircuit.diagonal``,
      * ``QuantumCircuit.hamiltonian``,
      * ``QuantumCircuit.isometry`` and ``QuantumCircuit.iso``,
      * ``QuantumCircuit.uc``,
      * ``QuantumCircuit.ucrx``,
      * ``QuantumCircuit.ucry``,
      * ``QuantumCircuit.ucrz``.

    These operations can still be performed by appending the appropriate
    instruction to a quantum circuit.
  - |
    Removed deprecated, duplicated :class:`.QuantumCircuit` methods. These include:

      * ``QuantumCircuit.cnot``, instead use :meth:`.QuantumCircuit.cx`,
      * ``QuantumCircuit.toffoli``, instead use :meth:`.QuantumCircuit.ccx`,
      * ``QuantumCircuit.fredkin``, instead use :meth:`.QuantumCircuit.cswap`,
      * ``QuantumCircuit.mct``, instead use :meth:`.QuantumCircuit.mcx`,
      * ``QuantumCircuit.i``, instead use :meth:`.QuantumCircuit.id`.


## Folder: 1.0
### File: remove-fake-provider-and-backends-2fcf5256c772935f.yaml
---
upgrade_providers:
  - |
    The deprecated :mod:`qiskit.providers.fake_provider` module has been migrated to
    the ``qiskit-ibm-runtime`` Python package. For this reason, the following elements in
    the :mod:`qiskit.providers.fake_provider` have been removed following their deprecation
    in Qiskit 0.46:

      * ``qiskit.providers.fake_provider.FakeProvider``
      * ``qiskit.providers.fake_provider.FakeProviderForBackendV2``
      * ``qiskit.providers.fake_provider.FakeProviderFactory``
      * ``qiskit.providers.fake_provider.fake_backends.FakeBackendV2``
      * any fake backend contained in ``qiskit.providers.fake_provider.backends`` (accessible through the provider)
      * ``qiskit.providers.fake_provider.FakeQasmSimulator``
      * ``qiskit.providers.fake_provider.FakeJob``
      * ``qiskit.providers.fake_provider.FakeQobj``

    To use the new fake provider module, you can run ``pip install qiskit-ibm-runtime``
    and replace the qiskit import path (``qiskit.providers.fake_provider``) with
    the new import path (``qiskit_ibm_runtime.fake_provider``).
    Migration example::

      # Legacy path
      from qiskit.providers.fake_provider import FakeProvider, FakeSherbrooke
      backend1 = FakeProvider().get_backend("fake_ourense")
      backend2 = FakeSherbrooke()

      # New path
      # run "pip install qiskit-ibm-runtime"
      from qiskit_ibm_runtime.fake_provider import FakeProvider, FakeSherbrooke
      backend1 = FakeProvider().get_backend("fake_ourense")
      backend2 = FakeSherbrooke()

    Additionally, the following fake backends designed for special testing purposes have
    been superseded by the new :class:`.GenericBackendV2` class, and are also removed
    following their deprecation in Qiskit 0.46:

      * ``qiskit.providers.fake_provider.fake_backend_v2.FakeBackendV2``
      * ```qiskit.providers.fake_provider.fake_backend_v2.FakeBackendV2LegacyQubitProps``
      * ``qiskit.providers.fake_provider.fake_backend_v2.FakeBackend5QV2``
      * ``qiskit.providers.fake_provider.fake_backend_v2.FakeBackendSimple``

    Migration example to the new :class:`.GenericBackendV2` class::

      # Legacy path
      from qiskit.providers.fake_provider import FakeBackend5QV2
      backend = FakeBackend5QV2()

      # New path
      from qiskit.providers.fake_provider import GenericBackendV2
      backend = GenericBackendV2(num_qubits=5)
      # note that this class will generate 5q backend with generic
      # properties that serves the same purpose as FakeBackend5QV2
      # but will generate different results


## Folder: 1.0
### File: remove-ibmq-4bb57a04991da9af.yaml
---
upgrade_misc:
  - |
    The deprecated ``qiskit.IBMQ`` object has been removed. This alias object
    was marked as deprecated in the Qiskit 0.40.0 release. This alias object lazily
    redirected attribute access to ``qiskit.providers.ibmq.IBMQ``. As the
    ``qiskit-ibmq-provider`` package has now been retired and superseded by
    ``qiskit-ibm-provider`` package which maintains its own namespace,
    maintaining this alias is no longer relevant. If you
    were relying on the ``qiskit.IBMQ`` alias you should migrate your usage to
    the ``qiskit-ibm-provider`` package, see the
    `migration guide <https://github.com/Qiskit/qiskit-ibm-provider/blob/stable/0.6/docs/tutorials/Migration_Guide_from_qiskit-ibmq-provider.ipynb>`__
    for more details.
  - |
    Removed the deprecated module ``qiskit.tools.jupyter`` which previously
    included Jupyter magics and widgets for interactively visualizing some data
    from Qiskit. This module was deprecated in Qiskit 0.46.0. Most of this
    functionality was directly tied to the legacy ``qiskit-ibmq-provider``
    package and was no longer valid so the module was removed. Similar
    functionality is available from the ``qiskit_ibm_provider.jupyter`` module
    in the `qiskit-ibm-provider <https://github.com/Qiskit/qiskit-ibm-provider>`_ package.
  - |
    Removed the deprecated module ``qiskit.tools.monitor`` which previously
    included tools for tracking :class:`.JobV1` job instances, primarily from
    the legacy ``qiskit-ibm-provider`` package. This module was marked as
    deprecated in Qiskit 0.46.0. It is being removed because it was directly
    tied to the legacy ``qiskit-ibm-provider`` package.
  - |
    Removed the deprecated import path ``qiskit.test.mock`` which previously was
    used to redirect imports for the mock backends to their newer location in
    the :mod:`qiskit.providers.fake_provider`. This module was marked as
    deprecated in Qiskit 0.37.0. If you were using this module you should update
    your imports from ``qiskit.test.mock`` to
    :mod:`qiskit.providers.fake_provider` instead.


## Folder: 1.0
### File: remove-legacy-qasm2-parser-53ad3f1817fd68cc.yaml
---
upgrade_qasm:
  - |
    The legacy OpenQASM 2 parser module previously present in ``qiskit.qasm`` has
    been removed. It was marked as deprecated in Qiskit 0.46.0 release. The
    OpenQASM 2 parser has been superseded by the :mod:`qiskit.qasm2` module which
    provides a faster and more correct parser for QASM2.
  - |
    The ``qiskit.converters.ast_to_dag`` function has been removed. It
    previously was used to convert the abstract syntax tree generated by the
    legacy OpenQASM 2 parser (in the ``qiskit.qasm`` module which no longer exists)
    and convert that directly to a :class:`.DAGCircuit`. This function was
    marked as deprecated in the Qiskit 0.46.0 release. As the legacy
    OpenQASM 2 parser has been removed, this function no longer serves a purpose.
    If you were previously using this, you can instead parse your OpenQASM 2 files
    into a :class:`.QuantumCircuit` using the
    :meth:`.QuantumCircuit.from_qasm_file` or
    :meth:`.QuantumCircuit.from_qasm_str` constructor methods and then
    converting that :class:`.QuantumCircuit` into a :class:`.DAGCircuit` with
    :func:`.circuit_to_dag`.
upgrade_circuits:
  - |
    Removed the ``QuantumCircuit.qasm()`` method to generate a OpenQASM 2
    representation of the :class:`.QuantumCircuit` object. Instead the
    :func:`.qasm2.dump` or :func:`.qasm2.dumps` functions should be used. This
    function was marked as deprecated in the 0.46.0 release. If you were using
    the ``QuantumCircuit.qasm()`` method to generate pygments-formatted output
    you should instead look at the standalone ``openqasm-pygments`` package
    to provide this functionality.
upgrade_misc:
  - |
    Removed the ``qiskit.tools.jupyter.library.qasm_widget`` function which
    was used to visualize OpenQASM 2 strings in a Jupyter notebook. This function
    was marked as deprecated as part of the Qiskit 0.44.0 release. The function
    was originally used for building documentation but hasn't been used in some
    time and has been removed from Qiskit.


## Folder: 1.0
### File: remove-namespace-hooks-995bdb7515a9fe35.yaml
---
upgrade_misc:
  - |
    Support for extensions of the ``qiskit`` and ``qiskit.providers`` namespaces
    by external packages has been removed. Support for doing this was deprecated
    in the Qiskit 0.44.0 release. In the past, the Qiskit project was composed
    of elements that extended a shared namespace and hook points were added
    to enable doing that. However, it was not intended for these interfaces to
    ever be used by other packages. Now that the overall Qiskit package is no
    longer using that packaging model, leaving the possibility for these
    extensions carry more risk than benefits and has therefore been removed.
    If you’re maintaining a package that extends the Qiskit namespace (i.e.
    your users import from ``qiskit.x`` or ``qiskit.providers.y``) you should
    transition to using a standalone Python namespace for your package.


## Folder: 1.0
### File: remove-old-noise-passes-7e157023a04f5f16.yaml
---
upgrade_transpiler:
  - |
    The deprecated ``NoiseAdaptiveLayout`` transpiler pass has been removed.
    It was marked as deprecated in Qiskit 0.46.0. This pass has been largely
    superseded by :class:`.VF2Layout` and :class:`.VF2PostLayout` which will
    set a layout based on the reported noise characteristics of a backend.
    Along with the pass, the ``layout_method`` plugin ``"noise_adaptive"`` has
    been removed.
  - |
    The deprecated ``CrosstalkAdaptiveSchedule`` transpiler pass has been removed.
    It was marked as deprecated in Qiskit 0.46.0. This pass was not usable any
    longer because its internal operation was dependent on custom properties
    being set in the :class:`.BackendProperties` payload of a
    :class:`.BackendV1` instance. As no backends are setting these fields,
    the pass was removed. If you depend on the pass for a custom workflow you
    can use the version in Qiskit 0.46.x.


## Folder: 1.0
### File: remove-opflow-qi-utils-3debd943c65b17da.yaml
---
upgrade_algorithms:
  - |
    The ``qiskit.opflow`` module has been removed, following its deprecation in
    Qiskit 0.44. For more context on the deprecation and
    detailed migration instructions, you can read the
    `Opflow Migration Guide <https://qisk.it/opflow_migration>`__.


  - |
    A series of legacy quantum execution utilities have been removed, following their deprecation in Qiskit 0.44.
    These include the ``qiskit.utils.QuantumInstance`` class, as well the modules:

     - ``qiskit.utils.backend_utils``
     - ``qiskit.utils.mitigation``
     - ``qiskit.utils.measurement_error_mitigation``
     - ``qiskit.utils.run_circuits``

    Their functionality has been superseded by the use of primitives. For more context on the deprecation and
    detailed migration instructions, you can read the `QuantumInstance Migration Guide <https://qisk.it/qi_migration>`__.


## Folder: 1.0
### File: remove-pulse-scoped-parameters-fa897399900f2ef2.yaml
---
upgrade:
  - |
    The ``scoped_parameters`` and ``search_parameters`` methods have been
    removed from the :class:`.ScheduleBlock` class. These methods returned
    :class:`.Parameter` objects that partially linked to the parameters in the
    :class:`.ScheduleBlock` instance but assigning values using these objects did not
    work correctly. Users should use :attr:`.ScheduleBlock.parameters` instead and
    iterate through :attr:`.ScheduleBlock.references` and compare to the
    :attr:`.Schedule.parameters` attributes of the subreferences when needing to
    distinguish which subroutine a parameter is used in. See `#11654
    <https://github.com/Qiskit/qiskit/issues/11654>`__ for more information.


## Folder: 1.0
### File: remove-qiskit-algorithms-a43541fe24b72208.yaml
---
upgrade:
  - |
    The ``qiskit.algorithms`` module has been removed, following its deprecation in
    Qiskit 0.44. The primitive-based algorithms from this module have been migrated to a standalone library (``qiskit_algorithms``)
    and can be found on PyPI or `GitHub <https://github.com/qiskit-community/qiskit-algorithms>`_.
    The decision to migrate the algorithms module to a separate package
    was made to clarify the purpose Qiskit and make a distinction between the tools
    and libraries built on top of it.


## Folder: 1.0
### File: remove-qiskit-test-8f3f43ed2a185f2f.yaml
---
upgrade_misc:
  - |
    The ``qiskit.test`` module is no longer a public module.  This was never intended to be public,
    nor used outside of Qiskit's own test suite.  All functionality was specific to Qiskit and no
    alternative is provided; if you needed similar functionality, you should include it in your own
    test harnesses.


## Folder: 1.0
### File: remove-tools-2d13fc5ec1f45336.yaml
---
upgrade_misc:
  - |
    The deprecated ``qiskit.tools.visualization`` module has removed. This module
    was deprecated in the Qiskit 0.46.0 release. This module was a legacy redirect
    from the original location of Qiskit's visualization module and was moved to
    :mod:`qiskit.visualization` in Qiskit 0.8.0. If you're still using this path
    you can just update your imports from ``qiskit.tools.visualization``
    to :mod:`qiskit.visualization`.
  - |
    The deprecated ``qiskit.tools.events`` module and the corresponding
    ``qiskit.tools.progressbar`` utility it exposed has been removed. It was deprecated
    in the Qiskit 0.46.0 release. This module's functionality was not widely used and
    better covered by dedicated packages such as `tqdm <https://github.com/tqdm/tqdm>`__.
  - |
    The ``qiskit.tools`` module has been removed. This module was deprecated in Qiskit 0.46.0.
    All the contents from this module have been removed except for the ``qiskit.tools.parallel_map``
    function which now can be used from :func:`qiskit.utils.parallel_map` instead.


## Folder: 1.0
### File: remove-transpiler-synthesis-3efbd076905ed141.yaml
---
upgrade_transpiler:
  - |
    Removed the ``qiskit.transpiler.synthesis`` module, which has been deprecated since the 0.46 release.
    The following objects have been moved:

    * :mod:`qiskit.transpiler.synthesis.aqc` has been moved to :mod:`qiskit.synthesis.unitary.aqc`
      (except of :class:`qiskit.synthesis.unitary.aqc.AQCSynthesisPlugin`).
    * :class:`qiskit.synthesis.unitary.aqc.AQCSynthesisPlugin` has been moved to
      :class:`qiskit.transpiler.passes.synthesis.AQCSynthesisPlugin`.
    * :func:`qiskit.transpiler.synthesis.graysynth` has been moved to
      :func:`qiskit.synthesis.synth_cnot_phase_aam`.
    * :func:`qiskit.transpiler.synthesis.cnot_synth` has been moved to
      :func:`qiskit.synthesis.synth_cnot_count_full_pmh`.


## Folder: 1.0
### File: remove-visualization-code-deprecated-in-0.22-7bc99235f5912424.yaml
upgrade_visualization:
  - |
    The deprecated support for passing a :class:`.QuasiDistribution`,
    :class:`.ProbDistribution`, or a distribution dictionary to the ``data``
    argument of the :func:`.plot_histogram` visualization has been removed.
    This functionality was marked as deprecated in the Qiskit 0.39.0 release
    (2022-10). Instead if you would like to plot a histogram from a
    :class:`.QuasiDistribution`, :class:`.ProbDistribution`, or a distribution
    dictionary you should use the :func:`.plot_distribution` function
    instead.


## Folder: 1.0
### File: remove_deprecated_legacy_pulse_builder_commands-61b85da62d82fb8c.yaml
---
upgrade:
  - |
    Removed logic for injecting :class:`.QuantumCircuit` and :class:`.Gate` operations into the
    pulse context (such as in :func:`.pulse.builder.call`), which was legacy behavior deprecated in
    Qiskit 0.46. Pulse schedules should be built up as a full schedule context; circuits and gates
    are a higher level of abstraction.

    This includes the removal of the related functions:

    * ``pulse.builder.call_gate``
    * ``pulse.builder.cx``
    * ``pulse.builder.u1``
    * ``pulse.builder.u2``
    * ``pulse.builder.u3``
    * ``pulse.builder.x``
    * ``pulse.builder.active_transpiler_settings``
    * ``pulse.builder.active_circuit_scheduler_settings``
    * ``pulse.builder.transpiler_settings``
    * ``pulse.builder.circuit_scheduler_settings``

    The ``default_transpiler_settings`` and ``default_circuit_scheduler_settings`` arguments
    to :func:`.pulse.builder.build` are similarly removed.

    .. code-block:: python

      from qiskit import transpile, schedule, QuantumCircuit, pulse
      from qiskit.providers.fake_provider import Fake7QPulseV1

      backend = Fake7QPulseV1()

      # Create a schedule from a hardware-based circuit.
      qc = QuantumCircuit(2)
      qc.cx(0, 1)
      qc = transpile(qc, backend)
      sched = schedule(qc, backend)

      # These pulse schedules can still be called in builder contexts.
      with pulse.build(backend) as qc_sched:
        pulse.call(sched)

      # Schedules for certain operations can also be directly retrieved
      # from BackendV1 instances:
      sched = backend.defaults().instruction_schedule_map.get('x', (0,))

      # ... and from BackendV2 instances:
      sched = backend.target['x'][(0,)].calibration


## Folder: 1.0
### File: remove_qinfo_synthesis-1917c7ccfcc62180.yaml
---
features_synthesis:
  - |
    The class :class:`~.TwoQubitWeylDecomposition` has been added to the public API in
    :mod:`qiskit.synthesis`.  This class allows to apply the Weyl decomposition of two-qubit
    unitaries.  If you were previously importing this while it was a non-public class in the
    now-removed ``qiskit.quantum_info.synthesis`` module, you should update your import paths.

upgrade_quantum_info:
  - |
    Removed the ``qiskit.quantum_info.synthesis`` module, which has been deprecated since the 0.46 release.
    The following objects have been moved to :mod:`qiskit.synthesis`:

    * :class:`~.OneQubitEulerDecomposer` has been moved to :mod:`qiskit.synthesis.one_qubit`
    * :class:`~.TwoQubitBasisDecomposer` has been moved to :mod:`qiskit.synthesis.two_qubits`
    * :class:`~.XXDecomposer` has been moved to :mod:`qiskit.synthesis.two_qubits`
    * :func:`~.two_qubit_cnot_decompose` has been moved to :mod:`qiskit.synthesis.two_qubits`

    This function was removed, since it has already been deprecated in the 0.46 release:
    * ``cnot_rxx_decompose``

    These functions were removed, since they have already been deprecated in a previous release:
    * ``decompose_clifford`` (use :func:`.synth_clifford_full` instead)
    * ``decompose_cnotdihedral`` (use :func:`.synth_cnotdihedral_full` instead)


## Folder: 1.0
### File: rollup-removals-ce8326ea90c0ad99.yaml
---
upgrade_transpiler:
  - |
    The ``target`` keyword alias when calling :class:`.TwoQubitBasisDecomposer` instances as
    functions has been removed following its deprecation in Qiskit 0.40.0.  You should
    pass the argument positionally as the first argument, or use the new name ``unitary``.
  - |
    The specialized transpiler pass :class:`.LinearFunctionsSynthesis` has been removed following
    its deprecation in Qiskit 0.40.0. Since its deprecation it just has been a very thin wrapper around
    :class:`.HighLevelSynthesis`, which you should use instead.
  - |
    The import path ``qiskit.transpiler.passes.scheduling.calibration_creators`` is removed.
    The transpiler passes it housed, :class:`.RZXCalibrationBuilder` and :class:`.RZXCalibrationBuilderNoEcho`
    can be imported directly from :mod:`qiskit.transpiler.passes`.
  - |
    The import path ``qiskit.transpiler.passes.scheduling.rzx_templates`` is removed.  You
    should import :func:`.rzx_templates` from :mod:`qiskit.transpiler.passes` directly.
upgrade_qasm:
  - |
    The ``qasm()`` methods of the classes :class:`.QuantumRegister` and :class:`.ClassicalRegister`
    have been removed.  There is no replacement necessary; these were an internal detail of a
    legacy implementation of the OpenQASM 2 exporter.  To export a program to OpenQASM 2, use
    :func:`.qasm2.dump` or :func:`.qasm2.dumps`.
upgrade_circuits:
  - |
    You can no longer set :attr:`.QuantumCircuit.metadata` to be ``None``, following deprecation
    in Qiskit 0.43.0.  Its type is :class:`dict`, so to clear it, set it to ``{}``.
  - |
    The attribute ``.Register.name_format`` has been removed following its deprecation
    in Qiskit 0.40.0.  There is no restriction on register names any more, and the
    regular expression there was simply ``[a-z][a-zA-Z0-9_]*``.

upgrade_quantum_info:
  - |
    The functions :func:`.process_fidelity`, :func:`.average_gate_fidelity`, :func:`.gate_error`
    and :func:`.diamond_norm` will no longer attempt to coerce arbitrary inputs to their marked
    expected types, following the deprecation in Qiskit 0.25.0.  Pass inputs of the marked
    types to each argument directly.
upgrade_qpy:
  - |
    The module path ``qiskit.circuit.qpy_serialization`` has been removed, following its
    deprecation in Qiskit 0.40.0.  For QPY serialization, use :mod:`qiskit.qpy`,
    which is the new location.
upgrade_visualization:
  - |
    The ``link_interval_dt`` key of :class:`.QiskitTimelineStyle` has been removed.
    You should use the new name ``link_interval_percent``.


## Folder: 1.0
### File: rr-decomposition-synthesis-70eb88ada9305916.yaml
---
fixes:
  - |
    Fixed an issue in :func:`.unitary_to_gate_sequence` which caused unitary
    decomposition in the RR basis to emit two R gates in some cases where the
    matrix can be expressed as a single R gate. Previously, in those cases you
    would get two R gates with the same phi parameter. Now, they are combined
    into one.


## Folder: 1.0
### File: sabre-no-route-barrier-bc82fecb65d3ab9a.yaml
---
fixes:
  - |
    Fixed an issue in the :class:`.SabreSwap` and :class:`.SabreLayout`
    transpiler passes where they would incorrectly treat 2-qubit
    :class:`.Barrier` instructions as an instruction that needs to be
    routed according the transpiler :class:`.Target`. When this occurred the
    output was still correct but would potentially include unnecessary
    :class:`.SwapGate` instructions.


## Folder: 1.0
### File: singletonize-instructions-78723f68cd0ac03f.yaml
---
features_circuits:
  - |
    The following standard library instructions are now instances of
    :class:`~.SingletonInstruction`:

     * :class:`~.Measure`
     * :class:`~.Reset`

    This means that if these classes are instantiated as (e.g.) ``Measure()`` using
    all the constructor defaults, they will all share a single global
    instance. This results in large reduction in the memory overhead for > 1
    object of these types and significantly faster object construction time.
upgrade_circuits:
  - |
    The following standard library instructions:

     * :class:`~.Measure`
     * :class:`~.Reset`
     
    are immutable, unless the attributes ``label``, ``duration`` and ``unit`` are given as keyword 
    arguments during class construction. 

    The attributes :attr:`~.Instruction.label`, :attr:`~.Instruction.duration`, :attr:`~.Instruction.unit`, 
    and :attr:`~.Instruction.condition` attributes are all not publicly accessible and setting these attributes
    directly is not allowed and it will raise an exception. If they are needed for a particular
    instance you must ensure you have a mutable instance using :meth:`.Instruction.to_mutable`
    and use :meth:`.Instruction.c_if` for :attr:`~.Instruction.condition`

    For the singleton variant of these instructions, there is a special attribute 
    :meth:`~.SingletonInstruction._singleton_lookup_key`, that when called generates a key based on the input
    arguments, which can be used for identifying and indexing these instructions within the framework. 


## Folder: 1.0
### File: standard-gate-mapping-parameters-2b438cea945c82cd.yaml
---
fixes:
  - |
    The parametric form of :class:`.XXPlusYYGate` and :class:`.XXMinusYYGate` returned from
    :func:`.get_standard_gate_name_mapping` now correctly includes the :math:`\beta` parameter as
    well as the initial :math:`\theta` rotation.


## Folder: 1.0
### File: symbolic-pulse-disable-validation-19cd8506b3a839b6.yaml
---
upgrade_pulse:
  - |
    Validation of :class:`qiskit.pulse.SymbolicPulse` objects can now be disabled. By setting
    the class attribute :attr:`~qiskit.pulse.SymbolicPulse.disable_validation` to ``False``
    the method :meth:`.SymbolicPulse.validate_parameters` will not be triggered for all :class:`.SymbolicPulse` objects.
    The automatic validation hindered JAX compatibility of the symbolic pulse library, and this
    upgrade will make it easier to use Qiskit Pulse with JAX. Moreover, the parameter validation will also be
    deactivated when using the :meth:`.Schedule.assign_parameters` and
    :meth:`.ScheduleBlock.assign_parameters` methods. This constitutes a first
    step towards a more general parameter validation mechanism, which will be implemented in the future to enable
    JAX compatibility of the :class:`.ParameterExpression` class, such that parametrized schedules can be generated within a
    JAX framework.

    Note that all library pulses automatically called :meth:`~.SymbolicPulse.validate_parameters`. However, as part
    of the upgrade the call was moved directly to the initialization process of
    :class:`.SymbolicPulse`. While this doesn't change the behavior of library pulses,
    custom symbolic pulses which did not call :meth:`~.SymbolicPulse.validate_parameters` will now trigger the
    method. The new class attribute will allow to easily disable this.


## Folder: 1.0
### File: symengine_1-c907ed541eeb9a02.yaml
---
upgrade:
  - |
    The minimum version required for symengine was bumped to >=0.11.


## Folder: 1.0
### File: template-match-symbols-c00786155f101e39.yaml
---
fixes:
  - |
    The :class:`.TemplateOptimization` pass will now return parametric expressions using the native
    symbolic expression format of :class:`.ParameterExpression`, rather than always using Sympy.
    For most supported platforms, this means that the expressions will be Symengine objects.
    Previously, the pass could return mismatched objects, which could lead to later failures in
    parameter-handling code.


## Folder: 1.0
### File: terra-nullius-7ef598626d8118c1.yaml
---
critical:
  - |
    You cannot upgrade in place to Qiskit 1.0.  You must begin a new virtual environment.

    From Qiskit 1.0, Qiskit is comprised of exactly one Python package: ``qiskit``.  Previously,
    as a legacy of the "component elements" of early Qiskit, the ``qiskit`` package was a
    dependency-only "metapackage", and the core code of Qiskit was in a package called ``qiskit-terra``.
    As Qiskit grew, the other elements split off into their own packages (such as ``qiskit-aer``)
    until only the core was left in the metapackage.  For Qiskit 1.0, we are removing the metapackage
    entirely, and replacing it with the actual Qiskit code.

    This means that you cannot upgrade an existing installation to Qiskit 1.0.  Instead, you must
    create a new Python virtual environment.  Using the built-in ``venv`` module, you can do (Linux
    and Mac):

    .. code-block:: bash

      # Create the new environment (only once).
      python -m venv ~/qiskit-1.0-venv
      # Activate the environment (every session).
      source ~/qiskit-1.0-venv/bin/activate
      # Install Qiskit (only once).
      pip install 'qiskit>=1.0'

    For other platforms, or more unusual shells, refer to `the Python standard-library documentation
    on activating virtual environments <https://docs.python.org/3/library/venv.html#how-venvs-work>`__.

    If you are a library author, or have code that depends on Qiskit, you should update any old
    dependencies on ``qiskit-terra`` to instead depend on ``qiskit``.

    For more information on this change, see our `migration guide on Qiskit packaging <https://qisk.it/1-0-packaging-migration>`__.


## Folder: 1.0
### File: update-dag-dependency-drawer-d06d4ae660c1cbc2.yaml
---
features_visualization:
  - |
    The :func:`.dag_drawer` has been updated for the :class:`.DAGDependency`. These
    drawings have a new color scheme, and the nodes now indicate the qubits and
    clbits that are used by the node. If the node has a condition, the drawings
    will indicate that as well.

      .. code-block:: python

          from qiskit.circuit import QuantumCircuit
          from qiskit.converters import circuit_to_dagdependency

          qc = QuantumCircuit(3, 2)
          qc.h(0)
          qc.cx(0, 1)
          qc.cx(0, 2)
          qc.x(1)
          qc.barrier()
          qc.measure(0, 0)
          dagdep = circuit_to_dagdependency(qc)
          dagdep.draw()


## Folder: 1.0
### File: update-primitive-job-f5c9b31f68c3ec3d.yaml
---
upgrade_primitives:
  - |
    Added the :class:`.BasePrimitiveJob` class as an abstract job class for primitives
    and made :class:`.PrimitiveJob` inherit :class:`.BasePrimitiveJob`
    instead of :class:`.JobV1`.
deprecations_primitives:
  - |
    The methods :meth:`.PrimitiveJob.submit` and :meth:`.PrimitiveJob.wait_for_final_state`
    have been removed following their deprecation in Qiskit 0.46.  These were not intended to be
    public methods, but were a legacy of an incorrect inheritance structure.


## Folder: 1.0
### File: upgrade-pass-manager-98aa64edde67b5bb.yaml
---
upgrade_transpiler:
  - |
    A pattern for the pass piepline construction was upgraded.
    The syntactic sugar shown below for instantiation of flow controller was removed.

    .. code-block:: python

      from qiskit.transpiler import PassManager

      pm = PassManager()
      pm.append(my_pass, condition=condition_callable, do_while=do_while_callable)

    Instead of using this keyword argument pattern, you should explicitly instantiate the
    flow controller.

    .. code-block:: python

      from qiskit.passmanager import ConditionalController, DoWhileController
      from qiskit.transpiler import PassManager

      pm = PassManager()
      pm.append(
        ConditionalController(
          DoWhileController(my_pass, do_while=do_while_callable),
          condition=condition_callable,
        )
      )

    Note that you can manage the pecking order of controllers when you want to nest them,
    which was not possible with keyword arguments.
    You can also build the pipeline with the constructor of the pass manager like below
    because there is no reason to call the append method now.

    .. code-block:: python

      pm = PassManager(
        ConditionalController(
          DoWhileController(my_pass, do_while=do_while_callable),
          condition=condition_callable,
        )
      )

  - |
    The append method of built-in flow controllers was removed. This includes

    * ``ConditionalController.append``
    * ``DoWhileController.append``
    * ``FlowControllerLinear.append``

    The task pipeline in a flow controller is frozen, and it must be passed
    when the controller instance is created.

  - |
    Removed the ``passess`` methods of :class:`.PassManager` and :class:`.StagedPassManager` that
    returned a representation of included passes in the form of list of dictionaries.
    However, this format doesn't efficiently represent more complicated pass pipeline,
    which may include conditional branching and nested conditions.
    Instead of using this representation, please use following pattern

    .. code-block:: python

      pm = PassManager(...)
      pm.to_flow_controller().tasks

    This directly returns a linearized base task instances in tuple format.

  - |
    The ``max_iteration`` argument was removed from :meth:`.PassManager.append`
    and :meth:`.PassManager.replace`.

  - |
    The following legacy classes were removed from the pass manager and transpiler modules following
    their deprecation in Qiskit 0.46:

    * ``qiskit.passmanager.flow_controllers.FlowController``
    * ``qiskit.transpiler.fencedobjs.FencedObject``
    * ``qiskit.transpiler.fencedobjs.FencedPropertySet``
    * ``qiskit.transpiler.fencedobjs.FencedDAGCircuit``
    * ``qiskit.transpiler.runningpassmanager.RunningPassManager``


## Folder: 1.0
### File: vf2-threading-b778a36de5b8832a.yaml
---
other:
  - |
    The :class:`.VF2Layout` and :class:`.VF2PostLayout` transpiler passes previously would
    potentially run their internal scoring using multithreading if the input
    circuits were sufficiently large. However, the multithreading usage has
    been removed from the passes as it was shown to cause a performance
    regression instead of an improvement like originally intended.


## Folder: 1.0
### File: vf2postlayout-no-better-solution-eb5ced3c8a60ea23.yaml
---
features_transpiler:
  - |
    :class:`.VF2PostLayout` now distinguishes between 'no solution' and 'no better solution' when
    determining a :class:`.Layout` for a given quantum circuit. 'no better solution' is set when the
    initial layout of a quantum circuit is also the optimal one, i.e. incurs the least cost in terms of
    error rates.


## Folder: 1.1
### File: abstract-commutation-analysis-3518129e91a33599.yaml
---
features:
  - |
    Extended the commutation analysis performed by :class:`.CommutationChecker` to only operate on
    hardware circuits to also work with abstract circuits, i.e. each operation in
    the input quantum circuit is now checked for its matrix representation before proceeding to the
    analysis. In addition, the operation is now checked for its ability to be cached in the session
    commutation library. For example, this now enables computing whether :class:`.AnnotatedOperation`
    commute. This enables transpiler passes that rely on :class:`.CommutationChecker` internally,
    such as :class:`.CommutativeCancellation`, during earlier stages of a default transpilation pipeline
    (prior to basis translation).



## Folder: 1.1
### File: add-annotated-arg-to-power-4afe90e89fa50f5a.yaml
---
features:
  - |
    The methods :meth:`~qiskit.circuit.QuantumCircuit.power`,
    :meth:`~qiskit.circuit.Gate.power`, as well as the similar methods
    of subclasses of :class:`~qiskit.circuit.Gate`
    (such as of :class:`~qiskit.circuit.library.SGate`) all have an additional
    argument ``annotated``.
    The default value of ``False`` corresponds to the existing behavior.
    Furthermore, for standard gates with an explicitly defined ``power`` method,
    the argument ``annotated`` has no effect, for example both
    ``SGate().power(1.5, annotated=False)`` and ``SGate().power(1.5, annotated=True)``
    return a ``PhaseGate``.
    The difference manifests for gates without an explicitly defined
    power method. The value of ``False`` returns a
    :class:`~.library.UnitaryGate`, just as before, while the value of ``True``
    returns an :class:`~.AnnotatedOperation` that represents the instruction
    modified with the "power modifier".


## Folder: 1.1
### File: add-backend-estimator-v2-26cf14a3612bb81a.yaml
---
features:
  - |
    The implementation :class:`~.BackendEstimatorV2` of :class:`~.BaseEstimatorV2` was added.
    This estimator supports :class:`~.BackendV1` and :class:`~.BackendV2`.

    .. code-block:: python

      import numpy as np
      from qiskit import transpile
      from qiskit.circuit.library import IQP
      from qiskit.primitives import BackendEstimatorV2
      from qiskit.providers.fake_provider import Fake7QPulseV1
      from qiskit.quantum_info import SparsePauliOp, random_hermitian

      backend = Fake7QPulseV1()
      estimator = BackendEstimatorV2(backend=backend)
      n_qubits = 5
      mat = np.real(random_hermitian(n_qubits, seed=1234))
      circuit = IQP(mat)
      observable = SparsePauliOp("Z" * n_qubits)
      isa_circuit = transpile(circuit, backend=backend, optimization_level=1)
      isa_observable = observable.apply_layout(isa_circuit.layout)
      job = estimator.run([(isa_circuit, isa_observable)], precision=0.01)
      result = job.result()
      print(f"> Expectation value: {result[0].data.evs}")
      print(f"> Standard error: {result[0].data.stds}")
      print(f"> Metadata: {result[0].metadata}")


## Folder: 1.1
### File: add-backend-sampler-v2-5e40135781eebc7f.yaml
---
features:
  - |
    The implementation :class:`~.BackendSamplerV2` of :class:`~.BaseSamplerV2` was added.
    This sampler supports :class:`~.BackendV1` and :class:`~.BackendV2` that allow
    ``memory`` option to compute bitstrings.

    .. code-block:: python

      import numpy as np
      from qiskit import transpile
      from qiskit.circuit.library import IQP
      from qiskit.primitives import BackendSamplerV2
      from qiskit.providers.fake_provider import Fake7QPulseV1
      from qiskit.quantum_info import random_hermitian

      backend = Fake7QPulseV1()
      sampler = BackendSamplerV2(backend=backend)
      n_qubits = 5
      mat = np.real(random_hermitian(n_qubits, seed=1234))
      circuit = IQP(mat)
      circuit.measure_all()
      isa_circuit = transpile(circuit, backend=backend, optimization_level=1)
      job = sampler.run([isa_circuit], shots=100)
      result = job.result()
      print(f"> bitstrings: {result[0].data.meas.get_bitstrings()}")
      print(f"> counts: {result[0].data.meas.get_counts()}")
      print(f"> Metadata: {result[0].metadata}")


## Folder: 1.1
### File: add-bitarray-utilities-c85261138d5a1a97.yaml
---
features_primitives:
  - |
    Added methods to join multiple :class:`~.BitArray` objects along various axes.

    - :meth:`~.BitArray.concatenate`: join arrays along an existing axis of the arrays.
    - :meth:`~.BitArray.concatenate_bits`: join arrays along the bit axis.
    - :meth:`~.BitArray.concatenate_shots`: join arrays along the shots axis.

    .. code-block::

      ba = BitArray.from_samples(['00', '11'])
      print(ba)
      # BitArray(<shape=(), num_shots=2, num_bits=2>)

      # reshape the bit array because `concatenate` requires an axis.
      ba_ = ba.reshape(1, 2)
      print(ba_)
      # BitArray(<shape=(1,), num_shots=2, num_bits=2>)

      ba2 = BitArray.concatenate([ba_, ba_])
      print(ba2.get_bitstrings())
      # ['00', '11', '00', '11']

      # `concatenate_bits` and `concatenates_shots` do not require any axis.

      ba3 = BitArray.concatenate_bits([ba, ba])
      print(ba3.get_bitstrings())
      # ['0000', '1111']

      ba4 = BitArray.concatenate_shots([ba, ba])
      print(ba4.get_bitstrings())
      # ['00', '11', '00', '11']

  - |
    Added methods to generate a subset of :class:`~.BitArray` object by slicing along various axes.

    - :meth:`~.BitArray.__getitem__`: slice the array along an existing axis of the array.
    - :meth:`~.BitArray.slice_bits`: slice the array along the bit axis.
    - :meth:`~.BitArray.slice_shots`: slice the array along the shot axis.

    .. code-block::

      ba = BitArray.from_samples(['0000', '0001', '0010', '0011'], 4)
      print(ba)
      # BitArray(<shape=(), num_shots=4, num_bits=4>)
      print(ba.get_bitstrings())
      # ['0000', '0001', '0010', '0011']

      ba2 = ba.reshape(2, 2)
      print(ba2)
      # BitArray(<shape=(2,), num_shots=2, num_bits=2>)
      print(ba2[0].get_bitstrings())
      # ['0000', '0001']
      print(ba2[1].get_bitstrings())
      # ['0010', '0011']

      ba3 = ba.slice_bits([0, 2])
      print(ba3.get_bitstrings())
      # ['00', '01', '00', '01']

      ba4 = ba.slice_shots([0, 2])
      print(ba3.get_bitstrings())
      # ['0000', '0010']

  - |
    Added a method :meth:`~.BitArray.transpose` to transpose a :class:`~.BitArray`.

    .. code-block::

      ba = BitArray.from_samples(['00', '11']).reshape(2, 1, 1)
      print(ba)
      # BitArray(<shape=(2, 1), num_shots=1, num_bits=2>)
      print(ba.transpose())
      # BitArray(<shape=(1, 2), num_shots=1, num_bits=2>)

  - |
    Added a method :meth:`~.BitArray.expectation_values` to compute expectation values of diagonal operators.

    .. code-block::

      ba = BitArray.from_samples(['01', '11'])
      print(ba.expectation_values(["IZ", "ZI", "01"]))
      # [-1.   0.   0.5]


## Folder: 1.1
### File: add-ctrl_state-mcp-parameter-b23562aa7047665a.yaml
---
features:
  - |
    Added ``ctrl_state`` parameter to :func:`QuantumCircuit.mcp()` and
    :class:`MCPhaseGate()`.


    The :func:`QuantumCircuit.mcp()` function and :class:`MCPhaseGate()` have
    been updated to include a ``ctrl_state`` parameter. This enhancement allows
    users to specify the control state of the multi-controlled phase gate. The
    parameter can accept either a decimal value or a bitstring and defaults to
    controlling the '1' state if not provided.


    .. code-block:: python

      from qiskit import QuantumCircuit
      
      qc = QuantumCircuit(4)
      qc.mcp(0.2,[0,1,2],3,ctrl_state=2)


## Folder: 1.1
### File: add-elide-permutations-to-pipeline-077dad03bd55ab9c.yaml
---
features:
  - |
    The transpiler pass :class:`~.ElidePermutations`
    runs by default with optimization level 2 and 3. Intuitively, removing
    :class:`~.SwapGate`\s and :class:`~qiskit.circuit.library.PermutationGate`\s
    in a virtual circuit is almost always beneficial, as it makes the circuit shorter
    and easier to route. As :class:`~.OptimizeSwapBeforeMeasure` is a special case
    of :class:`~.ElidePermutations`, it has been removed from optimization level 3.


## Folder: 1.1
### File: add-elide-swaps-b0a4c373c9af1efd.yaml
---
features:
  - |
    Added a new optimization transpiler pass, :class:`~.ElidePermutations`,
    which is designed to run prior to the :ref:`layout_stage` and will
    optimize away any :class:`~.SwapGate`\s and
    :class:`~qiskit.circuit.library.PermutationGate`\s
    in a circuit by permuting virtual
    qubits. For example, taking a circuit with :class:`~.SwapGate`\s:

    .. plot::

       from qiskit.circuit import QuantumCircuit

       qc = QuantumCircuit(3)
       qc.h(0)
       qc.swap(0, 1)
       qc.swap(2, 0)
       qc.cx(1, 0)
       qc.measure_all()
       qc.draw("mpl")

    will remove the swaps when the pass is run:

    .. plot::
       :include-source:

       from qiskit.transpiler.passes import ElidePermutations
       from qiskit.circuit import QuantumCircuit

       qc = QuantumCircuit(3)
       qc.h(0)
       qc.swap(0, 1)
       qc.swap(2, 0)
       qc.cx(1, 0)
       qc.measure_all()

       ElidePermutations()(qc).draw("mpl")

    The pass also sets the ``virtual_permutation_layout`` property set, storing
    the permutation of the virtual qubits that was optimized away.


## Folder: 1.1
### File: add-linear-plugin-options-b8a0ffe70dfe1676.yaml
---
features:
  - |
    The :class:`.KMSSynthesisLinearFunction` plugin for synthesizing
    :class:`~qiskit.circuit.library.LinearFunction` objects now accepts
    two additional options ``use_inverted`` and ``use_transposed``.
    These option modify the matrix on which the underlying synthesis algorithm runs
    by possibly inverting and/or transposing it, and then suitably adjust
    the synthesized circuit. By varying these options, we generally get different
    synthesized circuits, and in cases may obtain better results than for
    their default values.
  - |
    The :class:`.PMHSynthesisLinearFunction` plugin for synthesizing
    :class:`~qiskit.circuit.library.LinearFunction` objects now accepts
    several additional options. The option ``section_size`` is passed to the underlying
    synthesis method. The options ``use_inverted`` and ``use_transposed``
    modify the matrix on which the underlying synthesis algorithm runs
    by possibly inverting and/or transposing it, and then suitably adjust
    the synthesized circuit. By varying these options, we generally get different
    synthesized circuits, and in cases may obtain better results than for
    their default values.


## Folder: 1.1
### File: add-run-all-plugins-option-ba8806a269e5713c.yaml
---
features:
  - |
    The :class:`~.HLSConfig` now has two additional optional arguments. The argument
    ``plugin_selection`` can be set either to ``"sequential"`` or to ``"all"``.
    If set to "sequential" (default), for every higher-level-object
    the :class:`~qiskit.transpiler.passes.HighLevelSynthesis` pass will consider the
    specified methods sequentially, in the order they appear in the list, stopping
    at the first method that is able to synthesize the object. If set to "all",
    all the specified methods will be considered, and the best synthesized circuit,
    according to ``plugin_evaluation_fn`` will be chosen. The argument
    ``plugin_evaluation_fn`` is an optional callable that evaluates the quality of
    the synthesized quantum circuit; a smaller value means a better circuit. When
    set to ``None``, the quality of the circuit is its size (i.e. the number of gates
    that it contains).

    The following example illustrates the new functionality::

        from qiskit import QuantumCircuit
        from qiskit.circuit.library import LinearFunction
        from qiskit.synthesis.linear import random_invertible_binary_matrix
        from qiskit.transpiler.passes import HighLevelSynthesis, HLSConfig

        # Create a circuit with a linear function
        mat = random_invertible_binary_matrix(7, seed=37)
        qc = QuantumCircuit(7)
        qc.append(LinearFunction(mat), [0, 1, 2, 3, 4, 5, 6])

        # Run different methods with different parameters,
        # choosing the best result in terms of depth.
        hls_config = HLSConfig(
            linear_function=[
                ("pmh", {}),
                ("pmh", {"use_inverted": True}),
                ("pmh", {"use_transposed": True}),
                ("pmh", {"use_inverted": True, "use_transposed": True}),
                ("pmh", {"section_size": 1}),
                ("pmh", {"section_size": 3}),
                ("kms", {}),
                ("kms", {"use_inverted": True}),
            ],
            plugin_selection="all",
            plugin_evaluation_fn=lambda circuit: circuit.depth(),
        )

        # synthesize
        qct = HighLevelSynthesis(hls_config=hls_config)(qc)

    In the example, we run multiple synthesis methods with different parameters,
    choosing the best circuit in terms of depth. Note that optimizing
    ``circuit.size()`` instead would pick a different circuit.


## Folder: 1.1
### File: add-scheduler-warnings-da6968a39fd8e6e7.yaml
fixes:
  - |
    Fixed an issue where the :class:`.ConstrainedReschedule` transpiler pass would previously error
    if the circuit contained a :class:`~.circuit.Reset` instruction. This has been corrected so that the
    pass no longer errors, however an actual hardware may behave differently from 
    what Qiskit scheduler assumes especially for 
    mid-circuit measurements and resets.
    Qiskit scheduler raises ``RuntimeWarning`` if
    it encounters circuit containing either.
    Fixed `#10354 <https://github.com/Qiskit/qiskit/issues/10354>`__



## Folder: 1.1
### File: add-use-dag-flag-two-qubit-basis-decomposer-024a9ced9833289c.yaml
---
features_synthesis:
  - |
    Added a new argument, ``use_dag``, to the :meth:`.TwoQubitBasisDecomposer.__call__`
    and :meth:`.XXDecomposer.__call__` methods. This argument is used to control whether
    a :class:`.DAGCircuit` is returned when calling a :class:`.TwoQubitBasisDecomposer`
    or :class:`.XXDecomposer` instance instead of the default :class:`.QuantumCircuit`.
    For example::

        from qiskit.circuit.library import CXGate
        from qiskit.quantum_info import random_unitary
        from qiskit.synthesis import TwoQubitBasisDecomposer

        decomposer = TwoQubitBasisDecomposer(CXGate(), euler_basis="PSX")
        decomposer(random_unitary(4), use_dag=True)

    will return a :class:`.DAGCircuit` when calling the :class:`.TwoQubitBasisDecomposer`
    instance ``decomposer``.


## Folder: 1.1
### File: added-parameter-ctrl_state-mcx-816dcd80e459a5ed.yaml
---
features:
  - |
    Added `ctrl_state` parameter to :func:`QuantumCircuit.mcx()`.


    The :func:`QuantumCircuit.mcx()` function in the quantum circuit library has
    been enhanced to include a `ctrl_state` parameter, allowing users to specify
    the control state of the multi-controlled X gate. This parameter can accept
    either a decimal value or a bitstring and defaults to controlling the '1'
    state if not provided.

    .. code-block:: python

      from qiskit import QuantumCircuit
      
      qc = QuantumCircuit(3, 3)
      qc.mcx([0, 1], 2, ctrl_state="00")


## Folder: 1.1
### File: classical-store-e64ee1286219a862.yaml
---
features_circuits:
  - |
    A :class:`.QuantumCircuit` can now contain typed classical variables::

        from qiskit.circuit import QuantumCircuit, ClassicalRegister, QuantumRegister
        from qiskit.circuit.classical import expr, types

        qr = QuantumRegister(2, "q")
        cr = ClassicalRegister(2, "c")
        qc = QuantumCircuit(qr, cr)
        # Add two input variables to the circuit with different types.
        a = qc.add_input("a", types.Bool())
        mask = qc.add_input("mask", types.Uint(2))

        # Test whether the input variable was true at runtime.
        with qc.if_test(a) as else_:
            qc.x(0)
        with else_:
            qc.h(0)

        qc.cx(0, 1)
        qc.measure(qr, cr)

        # Add a typed variable manually, initialized to the same value as the classical register.
        b = qc.add_var("b", expr.lift(cr))

        qc.reset([0, 1])
        qc.h(0)
        qc.cx(0, 1)
        qc.measure(qr, cr)

        # Store some calculated value into the `b` variable.
        qc.store(b, expr.bit_and(b, cr))
        # Test whether we had equality, up to a mask.
        with qc.if_test(expr.equal(expr.bit_and(b, mask), mask)):
            qc.x(0)

    These variables can be specified either as *inputs* to the circuit, or as scoped variables.
    The circuit object does not yet have support for representing typed classical-variable *outputs*,
    but this will be added later when hardware and the result interfaces are in more of a position
    to support it.  Circuits that represent a block of an inner scope may also capture variables
    from outer scopes.

    A variable is a :class:`.Var` node, which can now contain an arbitrary type, and represents a
    unique memory location within its live range when added to a circuit.  These can be constructed
    in a circuit using :meth:`.QuantumCircuit.add_var` and :meth:`~.QuantumCircuit.add_input`, or
    at a lower level using :meth:`.Var.new`.

    Variables can be manually stored to, using the :class:`.Store` instruction and its corresponding
    circuit method :meth:`.QuantumCircuit.store`.  This includes writing to :class:`.Clbit` and
    :class:`.ClassicalRegister` instances wrapped in :class:`.Var` nodes.

    Variables can be used wherever classical expressions (see :mod:`qiskit.circuit.classical.expr`)
    are valid.  Currently this is the target expressions of control-flow operations, though we plan
    to expand this to gate parameters in the future, as the type and expression system are expanded.

    See :ref:`circuit-repr-real-time-classical` for more discussion of these variables, and the
    associated data model.

    These are supported throughout the transpiler, through QPY serialization (:mod:`qiskit.qpy`),
    OpenQASM 3 export (:mod:`qiskit.qasm3`), and have initial support through the circuit visualizers
    (see :meth:`.QuantumCircuit.draw`).

    .. note::

      The new classical variables and storage will take some time to become supported on hardware
      and simulator backends.  They are not supported in the primitives interfaces
      (:mod:`qiskit.primitives`), but will likely inform those interfaces as they evolve.


## Folder: 1.1
### File: commutation-checker-utf8-47b13b78a40af196.yaml
---
fixes:
  - |
    Fixed an issue with the :class:`.CommutationChecker` class where it would error if a gate's
    :attr:`~.Gate.name` attribute was UTF8 encoded. Previously only gate names with ascii
    encoding would work.
    Fixed `#12501 <https://github.com/Qiskit/qiskit/issues/12051>`__
    


## Folder: 1.1
### File: commutative-cancellation-preset-passmanager-c137ce516a10eae5.yaml
---
features:
  - |
    Added the :class:`.CommutativeCancellation` pass to the ``init`` stage of the preset pass managers for
    optimization levels 2 and 3. This enables the preset pass managers to cancel additional logical
    operations at the beginning of the compilation pipeline.
    


## Folder: 1.1
### File: databin-construction-72ec041075410cb2.yaml
---
features_primitives:
  - |
    `qiskit.primitives.containers.DataBin` now satisfies the `qiskit.primitives.containers.Shaped` 
    protocol. This means that every `DataBin` instance now has the additional attributes
    * `shape: tuple[int, ...]` the leading shape of every entry in the instance
    * `ndim: int` the length of `shape`
    * `size: int` the product of the entries of `shape`
    The shape can be passed to the constructor.
upgrade_primitives:
  - |
    The function `qiskit.primitives.containers.make_data_bin()` no longer creates and returns a 
    `qiskit.primitives.containers.DataBin` subclass. It instead always returns the `DataBin` class.
    However, it continues to exist for backwards compatibility, though will eventually be deprecated. 
    All users should migrate to construct `DataBin` instances directly, instead of instantiating 
    subclasses as output by `make_data_bin()`.


## Folder: 1.1
### File: databin-mapping-45d24d71f9bb4eda.yaml
---
features_primitives:
  - |
    Added mapping-like features to :class:`~.DataBin`, i.e.,
    ``__getitem__``, ``__contains__``, ``__iter__``,
    :meth:`~.DataBin.keys`, :meth:`~.DataBin.values`, and
    :meth:`~.DataBin.items`.

    .. code-block:: python
    
      from qiskit import QuantumCircuit
      from qiskit.primitives import StatevectorSampler

      circuit = QuantumCircuit(1)
      circuit.h(0)
      circuit.measure_all()

      sampler = StatevectorSampler()
      result = sampler.run([circuit]).result()
      databin = result[0].data
      for creg, arr in databin.items():
          print(creg, arr)
      for creg in databin:
          print(creg, databin[creg])


## Folder: 1.1
### File: deprecate-3.8-a9db071fa3c85b1a.yaml
---
deprecations:
  - |
    Support for running Qiskit with Python 3.8 has been deprecated and will
    be removed in the Qiskit 1.3.0 release. The 1.3.0 is the first release after
    Python 3.8 goes end of life and is no longer supported. [1] This means that
    starting in the 1.3.0 release you will need to upgrade the Python version
    you're using to Python 3.9 or above.

    [1] https://devguide.python.org/versions/


## Folder: 1.1
### File: deprecate_providerV1-ba17d7b4639d1cc5.yaml
---
deprecations_providers:
  - |
    The abstract base classes ``Provider`` and ``ProviderV1`` are now deprecated and will be removed in Qiskit 2.0.0.
    The abstraction provided by these interface definitions were not providing a huge value. solely just the attributes
    ``name``, ``backends``, and a ``get_backend()``. A _provider_, as a concept, will continue existing as a collection
    of backends. If you're implementing a provider currently you can adjust your
    code by simply removing ``ProviderV1`` as the parent class of your
    implementation. As part of this you probably would want to add an
    implementation of ``get_backend`` for backwards compatibility. For example::

        def get_backend(self, name=None, **kwargs):
          backend = self.backends(name, **kwargs)
          if len(backends) > 1:
              raise QiskitBackendNotFoundError("More than one backend matches the criteria")
          if not backends:
              raise QiskitBackendNotFoundError("No backend matches the criteria")
          return backends[0]


## Folder: 1.1
### File: expr-bitshift-index-e9cfc6ea8729ef5e.yaml
---
features_circuits:
  - |
    The classical realtime-expressions module :mod:`qiskit.circuit.classical` can now represent
    indexing and bitshifting of unsigned integers and bitlikes (e.g. :class:`.ClassicalRegister`).
    For example, it is now possible to compare one register with the bitshift of another::

      from qiskit.circuit import QuantumCircuit, ClassicalRegister
      from qiskit.circuit.classical import expr

      cr1 = ClassicalRegister(4, "cr1")
      cr2 = ClassicalRegister(4, "cr2")
      qc = QuantumCircuit(cr1, cr2)
      with qc.if_test(expr.equal(cr1, expr.shift_left(cr2, 2))):
          pass

    Qiskit can also represent a condition that dynamically indexes into a register::
    
      with qc.if_test(expr.index(cr1, cr2)):
          pass


## Folder: 1.1
### File: faster-lie-trotter-ba8f6dd84fe4cae4.yaml
---
features_synthesis:
  - |
    :meth:`.LieTrotter.synthesize` now uses :meth:`.QuantumCircuit.repeat` to generate additional reps
    after the first. This reduces the number of :meth:`.QuantumCircuit.compose` calls by a factor of
    ``reps`` and significantly reduces the runtime for larger operators.


## Folder: 1.1
### File: fix-backend-primitives-performance-1409b08ccc2a5ce9.yaml
---
fixes:
  - |
    Fixed a performance issue in the :class:`~.BackendSamplerV2` and
    :class:`~.BackendEstimatorV2`.
    Fixed `#12290 <https://github.com/Qiskit/qiskit-terra/issues/12290>`__

## Folder: 1.1
### File: fix-control-flow-convert-to-target-ae838418a7ad2a20.yaml
---
fixes:
  - |
    Fixed an issue with the :func:`.convert_to_target` where the converter
    would incorrectly ignore control flow instructions if they were specified
    in the :attr:`.BackendConfiguration.supported_instructions` attribute which
    is the typical location that control flow instructions are specified in a
    :class:`.BackendConfiguration` object.
    Fixed `#11872 <https://github.com/Qiskit/qiskit/issues/11872>`__.


## Folder: 1.1
### File: fix-control-flow-fold-minus-one-f2af168a5313385f.yaml
---
fixes:
  - |
    Fixed an issue with the :func:`circuit_drawer` or :meth:`QuantumCircuit.draw`
    when using the ``mpl`` output option where the program would hang if the
    circuit being drawn had a ControlFlow operation in it and the ``fold`` option
    was set to -1 (meaning no fold).
    Fixed `#12012 <https://github.com/Qiskit/qiskit/issues/12012>`__.


## Folder: 1.1
### File: fix-custom-pulse-qobj-conversion-5d6041b36356cfd1.yaml
---
fixes:
  - |
    Fixed a bug in the conversion of custom pulse instructions to the legacy :mod:`qiskit.qobj` format. The bug was introduced in Qiskit 1.0.0
    and caused conversion of instructions with custom pulse shapes to raise an error. After the fix, the conversion is
    carried out correctly, and the custom pulse is converted to :class:`.pulse.Waveform` as it should.
    Fixed `#11828 <https://github.com/Qiskit/qiskit/issues/11828>`__.


## Folder: 1.1
### File: fix-custom-transpile-constraints-5defa36d540d1608.yaml
---
fixes:
  - |
    A bug in :func:`.transpile` has been fixed where custom ``instruction_durations``, ``dt`` and ``backend_properties``
    constraints would be ignored when provided at the same time as a backend of type :class:`.BackendV2`. The behavior
    after the fix is now independent of whether the provided backend is of type :class:`.BackendV1` or
    type :class:`.BackendV2`. Similarly, custom ``timing_constraints`` are now overridden by ``target`` inputs
    but take precedence over :class:`.BackendV1` and :class:`.BackendV2` inputs.

features_transpiler:
  - |
    The following analysis passes now accept constraints encoded in a :class:`.Target` thanks to a new ``target`` 
    input argument:
    
      * :class:`.InstructionDurationCheck`
      * :class:`.ConstrainedReschedule`
      * :class:`.ValidatePulseGates`
    
    The target constraints will have priority over user-provided constraints, for coherence with the rest of 
    the transpiler pipeline.
    


## Folder: 1.1
### File: fix-equivalence-setentry-5a30b0790666fcf2.yaml
---
fixes:
  - |
    Calling :meth:`.EquivalenceLibrary.set_entry` will now correctly update the internal graph
    object of the library.  Previously, the metadata would be updated, but the graph structure would
    be unaltered, meaning that users like :class:`.BasisTranslator` would still use the old rules.
    Fixed `#11958 <https://github.com/Qiskit/qiskit/issues/11958>`__.


## Folder: 1.1
### File: fix-evolved-operator-ansatz-empty-ops-bf8ecfae8f1e1001.yaml
---
fixes:
  - |
    The :class:`.EvolvedOperatorAnsatz` now correctly handles the case where the
    `operators` argument is an empty list. Previously, this would result in an
    error.
  - |
    From now on, :class:`.EvolvedOperatorAnsatz` will not have any `qregs` when
    thera are zero qubits, instead of having a :class:`.QuantumRegister` instance
    with zero qubits. This behavior aligns more consistently with its superclass 
    :class:`.QuantumCircuit`.


## Folder: 1.1
### File: fix-instruction-repeat-conditional-dfe4d7ced54a7bb6.yaml
---
fixes:
  - |
    The method :meth:`.Instruction.repeat` now moves a set :attr:`~.Instruction.condition` to the
    outer returned :class:`~.circuit.Instruction` and leave the inner gates of its definition
    unconditional.  Previously, the method would leave :class:`.ClassicalRegister` instances within
    the inner definition, which was an invalid state, and would manifest itself as seemingly unrelated
    bugs later, such as during transpilation or export.  Fixed `#11935 <https://github.com/Qiskit/qiskit/issues/11935>`__.


## Folder: 1.1
### File: fix-inverse-cancellation-self-inverse-e09a5553331e1b0b.yaml
---

fixes:
  - |
    Fixed an issue in the :class:`.InverseCancellation` transpiler pass where in some cases it
    would incorrectly cancel a self-inverse parameterized gate even if the parameter value
    didn't match.
    Fixed  `#11815 <https://github.com/Qiskit/qiskit/issues/11815>`__

## Folder: 1.1
### File: fix-mcx-mcp-performance-b00040804b47b200.yaml
---
fixes:
  - |
    Improve the decomposition of the gates :class:`.MCXGate` and :class:`.MCPhaseGate`
    without using ancilla qubits, so that the number of :class:`.CXGate` will grow
    quadratically in the number of qubits and not exponentially.


## Folder: 1.1
### File: fix-missing-qubit-properties-35137aa5250d9368.yaml
---
fixes:
  - |
    A bug that crashes the :func:`.convert_to_target` function when qubit properties
    (either T1, T2 or frequency) are missing was fixed.
    The missing property values in :class:`.QubitProperties` are filled with ``None``.


## Folder: 1.1
### File: fix-passmanager-reuse-151877e1905d49df.yaml
---
fixes:
  - |
    :meth:`.BasePassManager.run` will no longer leak the previous :class:`.PropertySet` into new
    workflows when called more than once.  Previously, the same :class:`.PropertySet` as before
    would be used to initialize follow-on runs, which could mean that invalid property information
    was being given to tasks.  The behavior now matches that of Qiskit 0.44.  Fixed `#11784 <https://github.com/Qiskit/qiskit/issues/11784>`__.


## Folder: 1.1
### File: fix-pauli-evolve-ecr-and-name-bugs.yaml
---
fixes:
  - |
    :meth:`.Pauli.evolve` now correctly handles quantum circuits containing ECR gates. Formerly they were not recognized as Clifford gates, and an error was raised.
  - |
    Fixed a bug in :meth:`.Pauli.evolve` where evolving by a circuit with a name matching certain Clifford gates ('cx', 'cz', etc) would evolve the Pauli according to the name of the circuit, not by the contents of the circuit. This bug occurred only with the non-default option ``frame='s'``.


## Folder: 1.1
### File: fix-performance-scaling-num-bits-qpy-37b5109a40cccc54.yaml
---
fixes:
  - |
    Fixed a performance issue in the :func:`.qpy.load` function when
    deserializing QPY payloads with large numbers of qubits or clbits in
    a circuit.


## Folder: 1.1
### File: fix-pub-coerce-5d13700e15126421.yaml
---

fixes:
  - |
    Fixed a bug where ``qiskit.primitives.containers.estimator_pub.EstimatorPub.coerce()`` and
    ``qiskit.primitives.containers.sampler_pub.SamplerPub.coerce()``
    improperly handle the case where the parameter values are a ``BindingsArray`` instance, giving
    rise to a ``ValueError`` whenever it is attempted.

## Folder: 1.1
### File: fix-pulse-builder-default-alingment-52f81224d90c21e2.yaml
---
fixes:
  - |
    Fixed a bug in the handling of ``default_alignment`` argument of :func:`~qiskit.pulse.build`.
    Inputs of type :class:`~qiskit.pulse.transforms.AlignmentKind` are now correctly processed as
    default alignments.


## Folder: 1.1
### File: fix-pulse-parameter-formatter-2ee3fb91efb2794c.yaml
---
fixes:
  - |
    Fixed a bug in :func:`qiskit.pulse.utils.format_parameter_value` function that
    unintentionally converts large enough integer numbers into float values
    or causes unexpected rounding.
    See `qiskit/#11971 <https://github.com/Qiskit/qiskit/issues/11971>`__  for details.


## Folder: 1.1
### File: fix-qdrift-evolution-bceb9c4f182ab0f5.yaml
fixes:
  - |
    Fix incorrect implemention of `qDRIFT`, negative coefficients of the Hamiltonian are now added back whereas they were always forced to be positive.


## Folder: 1.1
### File: fix-scheduling-units-59477912b47d3dc1.yaml
---
fixes:
  - |
    A bug has been fixed in :func:`.convert_durations_to_dt` where the function would blindly apply
    a conversion from seconds to ``dt`` on circuit durations, independently of the original units of the attribute.
    This could lead to wrong orders of magnitude in the reported circuit durations.


## Folder: 1.1
### File: fix-transpile-control-flow-no-hardware-7c00ad733a569bb9.yaml
---
fixes:
  - |
    The preset pass managers of :func:`.transpile` will no longer fail on circuits
    with control flow, if no hardware target or basis-gate set is specified.  They
    will now treat such abstract targets as permitting all control-flow operations.
    Fixed `#11906 <https://github.com/Qiskit/qiskit/issues/11906>`__.


## Folder: 1.1
### File: fix_soft_compare-3f4148aab3a4606b.yaml
---
fixes:
  - |
    The method :meth:`qiskit.instruction.Instruction.soft_compare` is meant to compare whether two gates match in their name, number of qubits, number of clbits, and the number of parameters. However, there was a typo where it would not check the number of qubits and number of clbits for a match. This resolves the apparent typo.

## Folder: 1.1
### File: fixes_10852-e197344c5f44b4f1.yaml
---
features_providers:
  - |
    The :class:`.BasicSimulator` python-based simulator included in :mod:`qiskit.providers.basic_provider`
    now includes all the standard gates (:mod:`qiskit.circuit.library .standard_gates`) up to 3 qubits.


## Folder: 1.1
### File: fixes_11212-d6de3c007ce6d697.yaml
---
deprecations_transpiler:
  - |
    The pass ``qiskit.transpiler.passes.CXCancellation`` was deprecated in favor of
    class:`.InverseCancellation`, which is more generic.
    ``CXCancellation`` is fully semantically equivalent to ``InverseCancellation([CXGate()])``.


## Folder: 1.1
### File: followup_11468-61c6181e62531796.yaml
---
fixes:
  - |
    The default ``init`` plugin was not properly raising a :class:`.TranspilerError` when called with an invalid optimization level.


## Folder: 1.1
### File: histogram-style-03807965c3cc2e8a.yaml
---
upgrade:
  - |
    Removes the hard-coding of style options for :func:`~.plot_histogram`.  This allows
    Matplotlib style files to be faithfully applied to the figures.  Users looking to go
    beyond the defaults set by Matplotlib can make their own style files, or pass a
    Matplotlib ``Axes`` object to ``plot_histogram`` and post-apply any customizations.


## Folder: 1.1
### File: layout-compose-0b9a9a72359638d8.yaml
---
features:
  - |
    Added a new method :meth:`.Layout.inverse` which is used for taking
    the inverse of a :class:`.Layout` object.
    Added a new method :meth:`.Layout.compose` which is used for composing
    two :class:`.Layout` objects together.
    Added a new method :meth:`.Layout.to_permutation` which is used for
    creating a permutation corresponding to a :class:`.Layout` object.


## Folder: 1.1
### File: macos-arm64-tier-1-c5030f009be6adcb.yaml
---
other:
  - |
    Support for the arm64 macOS platform has been promoted from Tier 3
    to Tier 1. Previously the platform was at Tier 3 because there was
    no available CI environment for testing Qiskit on the platform. Now
    that Github has made an arm64 macOS environment available to open source
    projects [#]_ we're testing the platform along with the other Tier 1
    supported platforms.

    .. [#] https://github.blog/changelog/2024-01-30-github-actions-introducing-the-new-m1-macos-runner-available-to-open-source/


## Folder: 1.1
### File: nlocal-perf-3b8ebd9be1b2f4b3.yaml
---
features_circuits:
  - |
    The construction performance of :class:`.NLocal` and its derived circuit-library subclasses
    (e.g. :class:`.EfficientSU2` and :class:`.RealAmplitudes`) has significantly improved, when the
    rotation and/or entanglement subblocks are simple applications of a single Qiskit
    standard-library gate.  Since these circuits are constructed lazily, you might not see the
    improvement immediately on instantiation of the class, but instead on first access to its
    internal structure.  Performance improvements are on the order of ten times faster.


## Folder: 1.1
### File: numpy-2.0-2f3e35bd42c48518.yaml
---
features:
  - |
    This release of Qiskit finalizes support for NumPy 2.0.  Qiskit will continue to support both
    Numpy 1.x and 2.x for the foreseeable future.


## Folder: 1.1
### File: obs-array-coerce-0d-28b192fb3d004d4a.yaml
---
fixes:
  - |
    Fixed `qiskit.primitives.containers.observables_array.ObservablesArray.coerce()`
    so that it returns a 0-d array when the input is a single, unnested observable. 
    Previously, it erroneously upgraded to a single dimension, with shape `(1,)`.

## Folder: 1.1
### File: operator-from-circuit-bugfix-5dab5993526a2b0a.yaml
---
fixes:
  - |
    Fixed an issue with the :meth:`.Operator.from_circuit` constructor method where it would incorrectly
    interpret the final layout permutation resulting in an invalid `Operator` being constructed.
    Previously, the final layout was processed without regards for the initial layout, i.e. the
    initialization was incorrect for all quantum circuits that have a non-trivial initial layout.


## Folder: 1.1
### File: optimization-level2-2c8c1488173aed31.yaml
---
upgrade_transpiler:
  - |
    The preset :class:`.StagedPassManager` returned for optimization level 2 by
    :func:`.generate_preset_pass_manager` and :func:`.level_2_pass_manager` have
    been reworked to provide a better balance between runtime and optimization.
    This means the output circuits will change compared to earlier releases. If
    you need an exact pass manager from level 2 in earlier releases you can
    either build it manually or use it from an earlier release and save the
    circuits with :mod:`~qiskit.qpy` to load with a newer release.


## Folder: 1.1
### File: optimize-annotated-conjugate-reduction-656438d3642f27dc.yaml
features:
  - |
    Added a new reduction to the :class:`.OptimizeAnnotated` transpiler pass.
    This reduction looks for annotated operations (objects of type :class:`.AnnotatedOperation`
    that consist of a base operation ``B`` and a list ``M`` of control, inverse and power
    modifiers) with the following properties:

    * the base operation ``B`` needs to be synthesized (i.e. it's not already supported
      by the target or belongs to the equivalence library)

    * the definition circuit for ``B`` can be expressed as ``P -- Q -- R`` with :math:`R = P^{-1}`

    In this case the modifiers can be moved to the ``Q``-part only. As a specific example,
    controlled QFT-based adders have the form ``control - [QFT -- U -- IQFT]``, which can be
    simplified to ``QFT -- control-[U] -- IQFT``. By removing the controls over ``QFT`` and
    ``IQFT`` parts of the circuit, one obtains significantly fewer gates in the transpiled
    circuit.
  - |
    Added two new methods to the :class:`~qiskit.dagcircuit.DAGCircuit` class:
    :meth:`qiskit.dagcircuit.DAGCircuit.op_successors` returns an iterator to
    :class:`.DAGOpNode` successors of a node, and
    :meth:`qiskit.dagcircuit.DAGCircuit.op_successors` returns an iterator to
    :class:`.DAGOpNode` predecessors of a node.



## Folder: 1.1
### File: parameter-hash-eq-645f9de55aa78d02.yaml
---
fixes:
  - |
    :class:`.Parameter` was updated so that instances that compare equal always
    have the same hash. Previously, only the :attr:`.Parameter.uuid` was
    compared, so :class:`.Paramemter` instances with different names could
    compare equal if they had been constructed using a common value for the
    ``uuid`` parameter (which is usually not passed explicitly).


## Folder: 1.1
### File: parameter_assignment_by_name_for_pulse_schedules-3a27bbbbf235fb9e.yaml
---
features_pulse:
  - |
    It is now possible to assign parameters to pulse :class:`.Schedule` and :class:`.ScheduleBlock` objects by specifying
    the parameter name as a string. The parameter name can be used to assign values to all parameters within the
    `Schedule` or `ScheduleBlock` that have the same name. Moreover, the parameter name of a `ParameterVector`
    can be used to assign all values of the vector simultaneously (the list of values should therefore match the
    length of the vector).


## Folder: 1.1
### File: pauli-apply-layout-cdcbc1bce724a150.yaml
---
features_quantum_info:
  - |
    Added a new :meth:`~.Pauli.apply_layout`  method that is equivalent to
    :meth:`~.SparsePauliOp.apply_layout`. This method is used to apply
    a :class:`~.TranspileLayout` layout from the transpiler to a :class:`~.Pauli`
    observable that was built for an input circuit. This enables working with
    :class:`~.BaseEstimator` / :class:`~.BaseEstimatorV2` implementations and 
    local transpilation when the input is of type :class:`~.Pauli`. For example::
    
      from qiskit.circuit.library import RealAmplitudes
      from qiskit.primitives import BackendEstimatorV2
      from qiskit.providers.fake_provider import GenericBackendV2
      from qiskit.quantum_info import Pauli
      from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager
  
      psi = RealAmplitudes(num_qubits=2, reps=2)
      H1 = Pauli("XI")
      backend = GenericBackendV2(num_qubits=7)
      estimator = BackendEstimatorV2(backend=backend)
      thetas = [0, 1, 1, 2, 3, 5]
      pm = generate_preset_pass_manager(optimization_level=3, backend=backend)
      transpiled_psi = pm.run(psi)
      permuted_op = H1.apply_layout(transpiled_psi.layout)
      res = estimator.run([(transpiled_psi, permuted_op, thetas)]).result()
    
    where an input circuit is transpiled locally before it's passed to
    :class:`~.BaseEstimator.run`. Transpilation expands the original
    circuit from 2 to 7 qubits (the size of ``backend``) and permutes its layout,
    which is then applied to ``H1`` using :meth:`~.Pauli.apply_layout`
    to reflect the transformations performed by ``pm.run()``.

## Folder: 1.1
### File: public-noncommutation-graph-dd31c931b7045a4f.yaml
---
features_quantum_info:
  - |
    Adds the :meth:`.PauliList.noncommutation_graph` and
    :meth:`.SparsePauliOp.noncommutation_graph` methods, exposing the
    construction of non-commutation graphs, recasting the measurement operator
    grouping problem into a graph coloring problem. This permits users to work
    with these graphs directly, for example to explore coloring algorithms other
    than the one used by :meth:`.SparsePauliOp.group_commuting`.


## Folder: 1.1
### File: pulse_parameter_manager_compat_with_ParameterVector-7d31395fd4019827.yaml
---
features_pulse:
  - |
    The ``assign_parameters`` methods of :class:`.Schedule` and :class:`.ScheduleBlock`
    now support assigning a :class:`.ParameterVector` to a list of parameter values
    simultaneously in addition to assigning individual :class:`.Parameter` instances to
    individual values.


## Folder: 1.1
### File: qasm3-parameter-gate-clash-34ef7b0383849a78.yaml
---
fixes:
  - |
    :class:`.Parameter` instances used as stand-ins for ``input`` variables in
    OpenQASM 3 programs will now have their names escaped to avoid collisions
    with built-in gates during the export to OpenQASM 3.  Previously there
    could be a naming clash, and the exporter would generate invalid OpenQASM 3.


## Folder: 1.1
### File: qcstyle-bug-custom-style-dicts-22deab6c602ccd6a.yaml
---
fixes:
  - |
    Fixed bug in :meth:`.QuantumCircuit.draw` that was causing custom style dictionaries 
    for the Matplotlib drawer to be modified upon execution.


## Folder: 1.1
### File: quantumcircuit-append-copy-8a9b71ad4b789490.yaml
---
features_circuits:
  - |
    :meth:`.QuantumCircuit.append` now has a ``copy`` keyword argument, which defaults to ``True``.
    When an instruction with runtime parameters (:class:`.ParameterExpression`\ s) is appended to
    a circuit, by default, the circuit has always created a copy of the instruction so that if
    :meth:`.QuantumCircuit.assign_parameters` attempts to mutate the instruction in place, it does
    not affect other references to the same instruction.  Now, setting ``copy=False`` allows you to
    override this, so you can avoid the copy penalty if you know your instructions will not be used
    in other locations.
  - |
    :meth:`.QuantumCircuit.compose` now has a ``copy`` keyword argument, which defaults to ``True``.
    By default, :meth:`~.QuantumCircuit.compose` copies all instructions, so that mutations from one
    circuit do not affect any other.  If ``copy=False``, then instructions from the other circuit
    will become directly owned by the new circuit, which may involve mutating them in place.  The
    other circuit must not be used afterwards, in this case.
fixes:
  - |
    :meth:`.QuantumCircuit.append` with ``copy=True`` (its default) will now correctly copy
    instructions parametrized by :class:`.ParameterExpression` instances, and not just by
    :class:`.Parameter` instances.


## Folder: 1.1
### File: qv-perf-be76290f472e4777.yaml
---
features_circuits:
  - |
    Construction time for :class:`.QuantumVolume` circuits has been significantly improved, on the
    order of 10x or a bit more.  The internal SU4 gates will now also use more bits of randomness
    during their generation, leading to more representative volume circuits, especially at large
    widths and depths.
  - |
    :class:`.QuantumVolume` now has a ``flatten`` keyword argument.  This defaults to ``False``,
    where the constructed circuit contains a single instruction that in turn contains the actual
    volume structure.  If set ``True``, the circuit will directly have the volumetric SU4 matrices.
  - |
    :class:`.UnitaryGate` now accepts an optional ``num_qubits`` argument.  The only effect of this
    is to skip the inference of the qubit count, which can be helpful for performance when many
    gates are being constructed.
upgrade_circuits:
  - |
    The random-number usage of :class:`.QuantumVolume` has changed, so you will get a different
    circuit for a fixed seed between older versions of Qiskit and this version.  The random-unitary
    generation now uses more bits of entropy, so large circuits will be less biased.
  - |
    The internal :class:`.UnitaryGate` instances in the definition of a :class:`.QuantumVolume`
    circuit will no longer have a :attr:`~.Instruction.label` field set.  Previously this was set
    to the string ``su4_<seed>`` where ``<seed>`` was a three-digit number denoting the seed of an
    internal Numpy pRNG instance for that gate.  Doing this was a serious performance problem, and
    the seed ought not to have been useful; if you need to retrieve the matrix from the gate, simply
    use the :meth:`.Gate.to_matrix` method.


## Folder: 1.1
### File: remove-final-reset-488247c01c4e147d.yaml
---
features:
  - |
    Added a new transpiler pass, :class:`.RemoveFinalReset`, which
    will remove any :class:`.Reset` operation which is the final
    instruction on a qubit wire.  For example, taking a circuit with
    final :class:`.Reset`\ s:

    .. plot::

       from qiskit.circuit import QuantumCircuit

       qc = QuantumCircuit(3, 1)
       qc.reset(0)
       qc.h(range(3))
       qc.cx(1, 0)
       qc.measure(0, 0)
       qc.reset(range(3))
       qc.draw("mpl")

    will remove the final resets when the pass is run:

    .. plot::
       :include-source:

       from qiskit.transpiler.passes import RemoveFinalReset
       from qiskit.circuit import QuantumCircuit

       qc = QuantumCircuit(3, 1)
       qc.reset(0)
       qc.h(range(3))
       qc.cx(1, 0)
       qc.measure(0, 0)
       qc.reset(range(3))
       RemoveFinalReset()(qc).draw("mpl")


## Folder: 1.1
### File: removed_deprecated_0.21-741d08a01a7ed527.yaml
---
deprecations_transpiler:
  - |
    The transpilation pass ``qiskit.transpiler.passes.ALAPSchedule`` is now deprecated. It was pending for deprecation 
    since Qiskit 0.37 (with Terra 0.21), released on June 2022. The pass is replaced by 
    :class:`~.transpiler.passes.ALAPScheduleAnalysis`, which is an
    analysis pass.
  - |
    The transpilation pass ``qiskit.transpiler.passes.ASAPSchedule`` is now deprecated. It was pending for deprecation 
    since Qiskit 0.37 (with Terra 0.21), released on June 2022. It has been superseded by
    :class:`~.ASAPScheduleAnalysis` and the new scheduling workflow.
  - |
    The transpilation pass ``qiskit.transpiler.passes.DynamicalDecoupling`` is now deprecated. It was pending for deprecation 
    since Qiskit 0.37 (with Terra 0.21), released on June 2022.
    Instead, use :class:`~.transpiler.passes.PadDynamicalDecoupling`, which performs the same
    function but requires scheduling and alignment analysis passes to run prior to it.
  - |
    The transpilation pass ``qiskit.transpiler.passes.AlignMeasures`` is now deprecated. It was pending for deprecation 
    since Qiskit 0.37 (with Terra 0.21), released on June 2022.
    Instead, use :class:`~.ConstrainedReschedule`, which performs the same function 
    and also supports aligning to additional timing constraints.


## Folder: 1.1
### File: reverse-permutation-lnn-409a07c7f6d0eed9.yaml
---
features_synthesis:
  - |
    Add a new synthesis method :func:`.synth_permutation_reverse_lnn_kms`
    of reverse permutations for linear nearest-neighbor architectures using
    Kutin, Moulton, Smithline method.
    This algorithm synthesizes the reverse permutation on :math:`n` qubits over
    a linear nearest-neighbor architecture using CX gates with depth :math:`2 * n + 2`.


## Folder: 1.1
### File: rework-inst-durations-passes-28c78401682e22c0.yaml
---
fixes:
  - |
    The internal handling of custom circuit calibrations and :class:`.InstructionDurations`
    has been offloaded from the :func:`.transpile` function to the individual transpiler passes: 
    :class:`qiskit.transpiler.passes.scheduling.DynamicalDecoupling`,
    :class:`qiskit.transpiler.passes.scheduling.padding.DynamicalDecoupling`. Before, 
    instruction durations from circuit calibrations would not be taken into account unless 
    they were manually incorporated into `instruction_durations` input argument, but the passes
    that need it now analyze the circuit and pick the most relevant duration value according 
    to the following priority order: target > custom input > circuit calibrations.

  - |
    Fixed a bug in :func:`.transpile` where the ``num_processes`` argument would only be used
    if ``dt`` or ``instruction_durations`` were provided. 

## Folder: 1.1
### File: rust-two-qubit-basis-decomposer-329ead588fa7526d.yaml
---
features_synthesis:
  - |
    The :class:`.TwoQubitBasisDecomposer` class has been rewritten in Rust
    which greatly improves the runtime performance.


## Folder: 1.1
### File: rust-two-qubit-weyl-ec551f3f9c812124.yaml
---
features_synthesis:
  - |
    The :class:`.TwoQubitWeylDecomposition` synthesis class has been rewritten
    in Rust for better performance.
upgrade_synthesis:
  - |
    The :class:`.TwoQubitWeylDecomposition` no longer will self-specialize into
    a subclass on creation. This was an internal detail of the :class:`.TwoQubitWeylDecomposition`
    previously, and was not a documented public behavior as all the subclasses behaved
    the same and were only used for internal dispatch. However, as it was discoverable
    behavior this release note is to document that this will no longer occur and all
    instances of :class:`.TwoQubitWeylDecomposition` will be of the same type. There is no
    change in behavior for public methods of the class.

deprecations_synthesis:
  - |
    The :meth:`.TwoQubitWeylDecomposition.specialize` method is now deprecated
    and will be removed in the Qiskit 2.0.0 release. This method never had
    a public purpose and was unsafe for an end user to call as it would
    mutate the calculated decomposition in the object and produce invalid
    fields in the object. It was only used internally to construct a new
    :class:`.TwoQubitWeylDecomposition` object. Despite this it was still a
    documented part of the public API for the class and is now being
    deprecated without any potential replacement. This release it always will
    raise a ``NotImplementedError`` when called because the specialization
    subclassing has been removed as part of the Rust rewrite of the class.


## Folder: 1.1
### File: sampler-pub-result-e64e7de1bae2d35e.yaml
---
features_primitives:
  - |
    The subclass :class:`~.SamplerPubResult` of :class:`~.PubResult` was added,
    which :class:`~.BaseSamplerV2` implementations can return. The main feature
    added in this new subclass is :meth:`~.SamplerPubResult.join_data`, which 
    joins together (a subset of) the contents of :attr:`~.PubResult.data` into 
    a single object. This enables the following patterns:

    .. code:: python

        job_result =  sampler.run([pub1, pub2, pub3], shots=123).result()

        # assuming all returned data entries are BitArrays
        counts1 = job_result[0].join_data().get_counts()
        bistrings2 = job_result[1].join_data().get_bitstrings()
        array3 = job_result[2].join_data().array

## Folder: 1.1
### File: show_idle_and_show_barrier-6e77e1f9d6f55599.yaml
---
deprecations:
  - |
    The parameters ``show_idle`` and ``show_barrier`` in the timeline drawers had been replaced by ``idle_wires`` and ``plot_barriers``
    respectively to match the circuit drawer parameters. Their previous names are now deprecated and will be removed in the next major
    release. The new parameters are fully equivalent.


## Folder: 1.1
### File: spo-to-matrix-26445a791e24f62a.yaml
---
features:
  - |
    The performance of :meth:`.SparsePauliOp.to_matrix` has been greatly improved for both dense and
    sparse forms.  By default, both will now take advantage of threaded parallelism available on
    your system, subject to the ``RAYON_NUM_THREADS`` environment variable.  You can temporarily
    force serial execution using the new ``force_serial`` Boolean argument to
    :meth:`~.SparsePauliOp.to_matrix`.


## Folder: 1.1
### File: star-prerouting-0998b59880c20cef.yaml
---
features:
  - |
    Added a new transpiler pass :class:`.StarPreRouting` which is designed to identify star connectivity subcircuits
    and then replace them with an optimal linear routing. This is useful for certain circuits that are composed of
    this circuit connectivity such as Bernstein Vazirani and QFT. For example:

      .. plot:

         from qiskit.circuit import QuantumCircuit

         qc = QuantumCircuit(10)
         qc.h(0)
         qc.cx(0, range(1, 5))
         qc.h(9)
         qc.cx(9, range(8, 4, -1))
         qc.measure_all()
         qc.draw("mpl")

      .. plot:
         :include-source:

         from qiskit.circuit import QuantumCircuit
         from qiskit.transpiler.passes import StarPreRouting

         qc = QuantumCircuit(10)
         qc.h(0)
         qc.cx(0, range(1, 5))
         qc.h(9)
         qc.cx(9, range(8, 4, -1))
         qc.measure_all()
         StarPreRouting()(qc).draw("mpl")


## Folder: 1.1
### File: update-gate-dictionary-c0c017be67bb2f29.yaml
---
features_circuits:
  - |
    All of the "standard gates" in the circuit library
    (:mod:`qiskit.circuit.library`) can now be specified by string name for
    the entangling operations in :class:`.TwoLocal` circuits, such as
    :class:`.RealAmplitudes` and :class:`.EfficientSU2`.


## Folder: 1.1
### File: use-target-in-transpile-7c04b14549a11f40.yaml
---
upgrade:
  - |
    The :func:`.transpile` function has been upgraded to internally convert 
    `backend` inputs of type :class:`.BackendV1` to :class:`.BackendV2`, 
    which allows the transpilation pipeline to now access the backend 
    constraints through a :class:`.Target`. This change does not require any 
    user action.

## Folder: 1.2
### File: add-generate-preset-pm-global-import-efb12f185f3f738b.yaml
---
features_transpiler:
  - |
    Added a new import path option for :func:`.generate_preset_pass_manager`, so that it can now be imported as::
    
      from qiskit import generate_preset_pass_manager
    
    instead of having to type the full path::
      
      from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager
    
    The function is also importable from the :mod:`qiskit.transpiler` module as::
    
      from qiskit.transpiler import generate_preset_pass_manager

## Folder: 1.2
### File: add-qft-gate-fd4e08f6721a9da4.yaml
---
features:
  - |
    Added a new class :class:`~qiskit.circuit.library.QFTGate` for
    natively representing Quantum Fourier Transforms (QFTs). The older way
    of representing QFTs via quantum circuits, see
    :class:`~qiskit.circuit.library.QFT`, remains for backward compatibility.
    The new way of representing a QFT via a gate avoids synthesizing its
    definition circuit when the gate is declared, delaying the actual synthesis to
    the transpiler. It also allows to easily choose between several different
    algorithms for synthesizing QFTs, which are available as high-level-synthesis
    plugins.
  - |
    Added a synthesis method :func:`.synth_qft_full` for constructing a QFT circuit
    assuming a fully-connected architecture.
  - |
    Added two high-level-synthesis plugins for synthesizing a
    :class:`~qiskit.circuit.library.QFTGate`.
    The class :class:`.QFTSynthesisFull` is based on :func:`.synth_qft_full` and synthesizes
    a QFT gate assuming all-to-all connectivity.
    The class :class:`.QFTSynthesisLine` is based on :func:`.synth_qft_line` and synthesizes
    a QFT gate assuming linear nearest neighbor connectivity.


## Folder: 1.2
### File: add-sabre-all-threads-option-ad4ff7a4d045cb2b.yaml
---
features_transpiler:
  - |
    Added a new user config file option ``sabre_all_threads`` and a
    corresponding environment variable ``QISKIT_SABRE_ALL_THREADS``. When this
    flag is set the preset pass managers will run the :class:`.SabreLayout`
    and :class:`.SabreSwap` transpiler passes using all the available
    CPUs on the local system. Using this option is a tradeoff between
    determinism of output between different computers and potentially better
    output with fewer :class:`.SwapGate`\s.

    These transpiler passes run multiple random trials in parallel and pick
    the output which results in the fewest :class:`.SwapGate`\s. As a rule of
    thumb, if you run more trials, this provides the algorithm more opportunities
    to find a better result. By default, the preset pass managers use a fixed
    number of trials, in this release 5 trials for levels 0 and 1, and 20
    trials for levels 2 and 3, but these numbers may change in future releases
    (and were different in historical releases). Using a fixed number of
    trials results in deterministic results regardless of the local system,
    because even with a fixed seed if you were to default to the number of
    local CPUs available the results would different when running between
    different computers.

    If the default number of trials for a given optimization level is higher
    than the number of local CPUs it will use the optimization level default
    which is higher.


## Folder: 1.2
### File: adjust-neato-settings-3adcc0ae9e245ce9.yaml
---
fixes:
  - |
    Fixes an issue with the visualizations of some backends/coupling maps that showed as folded on their own. The
    `default ``neato`` setting <https://graphviz.org/docs/layouts/neato/>`_ works well in most cases. However,
    ``prism`` overlap returns a more regular layout for other scenarios.


## Folder: 1.2
### File: annotated-params-116288d5628f7ee8.yaml
---
features_circuits:
  - |
    Added support for :meth:`.AnnotatedOperation.params` and
    :meth:`.AnnotatedOperation.validate_parameter`, which enable
    circuit-level parameter handling (such as binding parameters) for
    annotated operations.
fixes:
  - |
    Fixed a series of issues when controlling parameterized standard gates.
    The controlled version of some gates (e.g. :class:`.RXXGate` or
    :class:`.RYGate` for more than 1 control) cannot be synthesized if
    they contain unbound parameters. Previously, calling ``.control()`` but
    now we create an :class:`.AnnotatedOperation` as placeholder. This
    allows to insert the controlled gate into a circuit, bind the parameters
    at a later stage, and then synthesize the operation.
    Fixes `#10311 <https://github.com/Qiskit/qiskit/issues/10311>`_,
    `#10697 <https://github.com/Qiskit/qiskit/issues/10697>`_,
    and `#12135 <https://github.com/Qiskit/qiskit/issues/12135>`_.
  - |
    The :class:`.SGate` and :class:`.SdgGate` now correctly return a 
    :class:`.CSGate`, resp. :class:`.CSdgGate`, if they are controlled on
    a single control qubit.
upgrade_circuits:
  - |
    The ``annotated`` argument of the :meth:`.Gate.control` method is now 
    ``None``, which allows Qiskit to choose whether to annotate a controlled operation.
    If the concrete implementation (``annotated=False``) is available, it will be returned by
    default. Otherwise, the annotated implementation will be returned (``annotated=True``). 
    This allows, for example, to defer the synthesis of controlled, parameterized gates.


## Folder: 1.2
### File: avoid-op-creation-804c0bed6c408911.yaml
---
features_circuits:
  - |
    :class:`.CircuitInstruction` and :class:`.DAGOpNode` each have new methods to query various
    properties of their internal :class:`.Operation`, without necessarily needing to access it.
    These methods are:

    * :meth:`.CircuitInstruction.is_standard_gate` and :meth:`.DAGOpNode.is_standard_gate`,
    * :meth:`.CircuitInstruction.is_controlled_gate` and :meth:`.DAGOpNode.is_controlled_gate`,
    * :meth:`.CircuitInstruction.is_directive` and :meth:`.DAGOpNode.is_directive`,
    * :meth:`.CircuitInstruction.is_control_flow` and :meth:`.DAGOpNode.is_control_flow`, and
    * :meth:`.CircuitInstruction.is_parameterized` and :meth:`.DAGOpNode.is_parameterized`.

    If applicable, using any of these methods is significantly faster than querying
    :attr:`.CircuitInstruction.operation` or :attr:`.DAGOpNode.op` directly, especially if the
    instruction or node represents a Qiskit standard gate.  This is because the standard gates are
    stored natively in Rust, and their Python representation is only created when requested.


## Folder: 1.2
### File: backendv1-d0d0642ed38fed3c.yaml
---
deprecations_providers:
  - |
    The :class:`.BackendV1` class is deprecated and it will be removed not earlier than the next major release.
    There are several migration paths available depending on the main purpose of the backend object::

      - To expose backend information with no access to execution (just a hardware description), consider constructing a :class:`.Target` directly.
      - To provides access to execution capabilities, consider relying on the primitives interfaces instead.
      - Alternatively, to continue providing simultaneous :class:`.Target` (hardware information) and ``run`` (execution) capabilities, consider moving to :class:`.BackendV2` (see <https://qisk.it/backendV1-to-V2>).

  - |
    The models in :mod:`qiskit.providers.models` are part of the deprecated :class:`.BackendV1` workflow
    and no longer necessary for :class:`.BackendV2`. If a user workflow requires these representations it
    likely relies on deprecated functionality and should be updated to use :class:`.BackendV2`.


## Folder: 1.2
### File: bitarray-postselect-659b8f7801ccaa60.yaml
---
features_primitives:
  - |
    Added a new method :meth:`.BitArray.postselect` that returns all shots containing specified bit values.
    Example usage::

      from qiskit.primitives.containers import BitArray

      ba = BitArray.from_counts({'110': 2, '100': 4, '000': 3})
      print(ba.postselect([0,2], [0,1]).get_counts())
      # {'110': 2, '100': 4}


## Folder: 1.2
### File: circuit-gates-rust-5c6ab6c58f7fd2c9.yaml
---
features_circuits:
  - |
    A native rust representation of Qiskit's standard gate library has been added. When a standard gate
    is added to a :class:`~.QuantumCircuit` or :class:`~.DAGCircuit` it is now represented in a more
    efficient manner directly in Rust seamlessly. Accessing that gate object from a circuit or dag will
    return a new Python object representing the standard gate. This leads to faster and more efficient
    transpilation and manipulation of circuits for functionality written in Rust.
features_misc:
  - |
    Added a new build-time environment variable ``QISKIT_NO_CACHE_GATES`` which
    when set to a value of ``1`` (i.e. ``QISKIT_NO_CACHE_GATES=1``) which
    decreases the memory overhead of a :class:`.CircuitInstruction` and
    :class:`.DAGOpNode` object at the cost of decreased runtime on multiple
    accesses to :attr:`.CircuitInstruction.operation` and :attr:`.DAGOpNode.op`.
    If this environment variable is set when building the Qiskit python package
    from source the caching of the return of these attributes will be disabled.
upgrade_circuits:
  - |
    The :class:`.Operation` instances of :attr:`.DAGOpNode.op`
    being returned will not necessarily share a common reference to the
    underlying object anymore. This was never guaranteed to be the case and
    mutating the :attr:`~.DAGOpNode.op` directly by reference
    was unsound and always likely to corrupt the dag's internal state tracking
    Due to the internal refactor of the :class:`.QuantumCircuit` and
    :class:`.DAGCircuit` to store standard gates in rust the output object from
    :attr:`.DAGOpNode.op` will now likely be a copy instead of a shared instance. If you
    need to mutate an element should ensure that you either do::

      op = dag_node.op
      op.params[0] = 3.14159
      dag_node.op = op

    or::

      op = dag_node.op
      op.params[0] = 3.14159
      dag.substitute_node(dag_node, op)

    instead of doing something like::

      dag_node.op.params[0] = 3.14159

    which will not work for any standard gates in this release. It would have
    likely worked by chance in a previous release but was never an API guarantee.
  - |
    The :class:`.Operation` instances of :attr:`.CircuitInstruction.operation`
    being returned will not necessarily share a common reference to the
    underlying object anymore. This was never guaranteed to be the case and
    mutating the :attr:`~.CircuitInstruction.operation` directly by reference
    was unsound and always likely to corrupt the circuit, especially when
    parameters were in use. Due to the internal refactor of the QuantumCircuit
    to store standard gates in rust the output object from
    :attr:`.CircuitInstruction.operation` will now likely be a copy instead
    of a shared instance. If you need to mutate an element in the circuit (which
    is strongly **not** recommended as it's inefficient and error prone) you
    should ensure that you do::

      from qiskit.circuit import QuantumCircuit

      qc = QuantumCircuit(1)
      qc.p(0)

      op = qc.data[0].operation
      op.params[0] = 3.14

      qc.data[0] = qc.data[0].replace(operation=op)

    instead of doing something like::

      from qiskit.circuit import QuantumCircuit

      qc = QuantumCircuit(1)
      qc.p(0)

      qc.data[0].operation.params[0] = 3.14

    which will not work for any standard gates in this release. It would have
    likely worked by chance in a previous release but was never an API guarantee.


## Folder: 1.2
### File: default-level-2-generate-preset-passmanager-ec758ddc896ae2d6.yaml
---
features_transpiler:
  - |
    The ``optimization_level`` argument for the :func:`.generate_preset_pass_manager` function is
    now optional. If it's not specified it will default to using optimization level 2. As the argument
    is now optional, the first positional argument has been expanded to enable passing a :class:`.Target`
    or a :class:`.BackendV2` as the first argument for more convenient construction. For example::

      from qiskit.transpiler.preset_passmanager import generate_preset_pass_manager
      from qiskit.providers.fake_provider import GenericBackendV2

      backend = GenericBackendV2(100)

      generate_preset_pass_manager(backend.Target)

    will construct a default pass manager for the 100 qubit :class`.GenericBackendV2` instance.
upgrade_transpiler:
  - |
    The default ``optimization_level`` used by the :func:`.transpile` function when one is not
    specified has been changed to level 2. This makes it consistent with the default used
    by :func:`.generate_preset_pass_manager` which is used internally by :func:`.transpile`. Optimization
    level 2 provides a much better balance between the run time of the function and the optimizations it
    performs, it's a better tradeoff to use by default.

    The API of :func:`.transpile` remains unchanged because, fundamentally, level 2 and level 1
    have the same semantics. If you were previously relying on the implicit default of level 1,
    you can simply set the argument ``optimization_level=1`` when you call :func:`.transpile`.
    Similarly you can change the default back in your local environment by using a user config
    file and setting the ``transpile_optimization_level`` field to 1.

    The only potential issue is that your transpilation workflow may be relying on an implicit trivial layout (where qubit 0
    in the circuit passed to :func:`.transpile` is mapped to qubit 0 on the target backend/coupling,
    1->1, 2->2, etc.) without specifying ``optimization_level=1``, ``layout_method="trivial"``, or
    explicitly setting ``initial_layout`` when calling :func:`.transpile`. This behavior was a side
    effect of the preset pass manager construction in optimization level 1 and is not mirrored in
    level 2. If you need this behavior you can use any of the three options listed previously to make
    this behavior explicit.

    Similarly, if you were targeting a discrete basis gate set you may encounter an issue using the
    new default with optimization level 2 (or running explicitly optimization level 3), as the additional optimization passes that run in
    level 2 and 3 don't work in all cases with a discrete basis. You can explicitly set
    ``optimization_level=1`` manually in this case. In general the transpiler does not currently
    fully support discrete basis sets and if you're relying on this you should likely construct a
    pass manager manually to build a compilation pipeline that will work with your target.


## Folder: 1.2
### File: deprecate-circuit-internal-helpers-ee65fbac455de47c.yaml
---
deprecations_circuits:
  - |
    The following circuit methods were not intended for public use, but were accidentally left documented in the
    public API during the 1.0 release. They are now deprecated from Qiskit 1.2 and will be removed in Qiskit 2.0:

      * ``QuantumCircuit.cast``
      * ``QuantumCircuit.cls_instances``
      * ``QuantumCircuit.cls_prefix``
      * ``QuantumCircuit.cbit_argument_conversion``
      * ``QuantumCircuit.qbit_argument_conversion``

## Folder: 1.2
### File: deprecate-legacy-circuit-instruction-8a332ab09de73766.yaml
---
deprecations_circuits:
  - |
    Treating :class:`.CircuitInstruction` as a tuple-like iterable is deprecated, and this legacy
    path way will be removed in Qiskit 2.0.  You should use the attribute-access fields
    :attr:`~.CircuitInstruction.operation`, :attr:`~.CircuitInstruction.qubits`, and 
    :attr:`~.CircuitInstruction.clbits` instead.  For example::

      from qiskit.circuit import QuantumCircuit

      qc = QuantumCircuit(2, 2)
      qc.h(0)
      qc.cx(0, 1)
      qc.measure([0, 1], [0, 1])

      # Deprecated.
      for op, qubits, clbits in qc.data:
          pass
      # New style.
      for instruction in qc.data:
          op = instruction.operation
          qubits = instruction.qubits
          clbits = instruction.clbits


## Folder: 1.2
### File: deprecate-primitives-v1.yaml
---
deprecations_primitives:
  - |
    Primitive V1 implementations and V1-exclusive non-versioned type aliases are now 
    deprecated in favor of their V2 counterparts. The deprecation is extended to the 
    following classes implementing V1 interfaces:

    * :class:`.Estimator`, in favor of the V2 equivalent, :class:`.StatevectorEstimator`
    * :class:`.Sampler`, in favor of the V2 equivalent, :class:`.StatevectorSampler`
    * :class:`.BackendEstimator`, in favor of the V2 equivalent, :class:`.BackendEstimatorV2`
    * :class:`.BackendSampler`, in favor of the V2 equivalent, :class:`.BackendSamplerV2`

    As well as the following non-versioned type aliases:
    
    * :class:`.BaseEstimator`, alias for :class:`.BaseEstimatorV1`
    * :class:`.BaseSampler`, alias for :class:`.BaseSamplerV1`

    This deprecation does NOT affect the explicitly-versioned :class:`BaseEstimatorV1` 
    and :class:`BaseSamplerV1` abstract
    interface definitions or related result and job classes.

    In addition, the following utility functions are deprecated:

    * :func:`.init_circuit`, to initialize a circuit from a :class:`.Statevector`,
      use :meth:`.QuantumCircuit.initialize` instead,
    * :func:`.init_observable`, use the constructor of :class:`.SparsePauliOp` instead,
    * :func:`.final_measurement_mapping`, use :meth:`.QuantumCircuit.layout` and
      :meth:`.SparsePauliOp.apply_layout` to adjust an operator for a layout.
      Otherwise, use ``mthree.utils.final_measurement_mapping``.
      See `Mthree Utility functions <https://qiskit-extensions.github.io/mthree/apidocs/utils.html>`__
      for details.



## Folder: 1.2
### File: deprecate-visualize_transition-8c1d257b7f37aa58.yaml
---
deprecations_visualization:
  - |
    The :func:`.transition_visualization` function has been deprecated and will
    be removed in the 2.0.0 release. This function had a number of limitations
    which limited it's utility to only very specific use cases and didn't fit in with
    the rest of the Qiskit visualization module. 


## Folder: 1.2
### File: deprecate_assemble-67486b4d0a8d4f96.yaml
---
deprecations_providers:
  - |
    The `Qobj` structure and related classes are now deprecated, they were introduced as part of the `BackendV1` workflow and are no longer necessary for interacting with  :class:`.BackendV2` backends. Remote backend interaction should be done via `QPY` or `OpenQASM` instead.
deprecations_transpiler:
  - |
    The `assemble` function is now deprecated and will be removed in the 2.0 release. The function was primarily used to create a `Qobj`, which is no longer necessary in :class:`.BackendV2`-based workflows. It was also used for binding parameters, a functionality fully covered by :meth:`~.QuantumCircuit.assign_parameters`.


## Folder: 1.2
### File: extract-standard-parametric-controlled-1a495f6f7ce89397.yaml
---
fixes:
  - |
    Parametric controlled standard-library gates (such as :class:`.CRXGate`) will now get correctly
    extracted to a Rust-space standard gate when using :meth:`.QuantumCircuit.append` and the gate
    object.  Previously there was a discrepancy where using the :meth:`.QuantumCircuit.crx` method
    would cause a correct extraction in Rust space, but the :meth:`~.QuantumCirucit.append` form
    would not.  The bug should generally not have caused any unsoundness from Python.


## Folder: 1.2
### File: fix-2q-basis-decomposer-non-std-kak-gate-edc69ffb5d9ef302.yaml
---
fixes:
  - |
    Fixed a bug in :class:`.TwoQubitBasisDecomposer` where the Rust-based code
    would panic if the given KAK gate wasn't a Rust-space :class:`StandardGate`.

## Folder: 1.2
### File: fix-InstructionDurations-b47a9770b424d7a0.yaml
---
fixes:
  - |
    Fixed a bug where :meth:`.InstructionDurations.from_backend` did not work for :class:`.BackendV2` backends.
    Fixed `#12760 <https://github.com/Qiskit/qiskit/issues/12760>`.

## Folder: 1.2
### File: fix-bitarray-fromcounts-nobits-82958a596b3489ec.yaml
---
fixes:
  - |
    Fixed a bug in :meth:`.BitArray.from_counts` and :meth:`.BitArray.from_samples`.
    Previously these would raise an error if given data containing only zeros, and no
    value for the optional argument ``num_bits``. Now they produce a :class:`.BitArray`
    with :attr:`.BitArray.num_bits` set to 1.


## Folder: 1.2
### File: fix-bitarray-slice-bits-shots-c9cb7e5d907722f5.yaml
---
upgrade_primitives:
  - |
    :meth:`.BitArray.slice_bits` and :meth:`.BitArray.slice_shots`
    will now raise ``IndexError`` when indices are out of bounds.
    They used to raise ``ValueError`` in the case.
  - |
    :meth:`.BitArray.__getitem__` will now raise ``IndexError``
    when indices are out of bounds or the number of dimensions
    of indices does not match that of BitArray.
    They used to raise ``ValueError`` in the case.


## Folder: 1.2
### File: fix-consolidate-blocks-custom-gate-no-target-e2d1e0b0ee7ace11.yaml
---
fixes:
  - |
    Fixed a bug in the :class:`.ConsolidateBlocks` transpiler pass, when the
    input circuit contains a custom opaque gate and neither the
    ``basis_gates`` or ``target`` options are set the pass would raise a
    ``QiskitError`` and fail. This has been corrected so that the in these
    situations the transpiler pass will not consolidate the block identified
    containing a custom gate instead of failing.


## Folder: 1.2
### File: fix-cu-rust-6464b6893ecca1b3.yaml
---
fixes:
  - |
    Fixed the definition of the :class:`.CUGate` matrix in Rust-space. 
    While this was not noticable while handling the :class:`.CUGate` purely on 
    Python side, this had knock-on effects when transpiler passes were using the 
    Rust representation, such as could happen in :class:`.Consolidate2qBlocks`.
    Fixed `#13118 <https://github.com/Qiskit/qiskit/issues/13118>`__.



## Folder: 1.2
### File: fix-dd-misalignment-msg-76fe16e5eb4ae670.yaml
---
fixes:
  - |
    Fixed a bug in :class:`.PadDynamicalDecoupling`, which previously
    did not correctly display the error message that a delay is not
    pulse-aligned, if the previous or following node was an input/output
    node. Now, the error message is correctly displayed.


## Folder: 1.2
### File: fix-elide-permutations-1b9e1d10c3abb2a4.yaml
---
fixes:
  - |
    Fixed a bug in the transpiler pass :class:`~.ElidePermutations` where the
    qubit mapping was not updated correctly in the presence of :class:`.PermutationGate`\s.


## Folder: 1.2
### File: fix-hoare-opt-56d1ca6a07f07a2d.yaml
---
fixes:
  - |
    Fixed a bug in :class:`.HoareOptimizer` where a controlled gate was simplified
    by removing its controls but the new gate was not handled correctly.


## Folder: 1.2
### File: fix-kwarg-validation-BitArray-1bf542a1fb5c15c6.yaml
---
fixes:
  - |
    The keyword argument ``order`` of the function :meth:`.BitArray.from_bool_array` should be 'little' or 'big'. Added checks to raise error if an invalid value is entered.


## Folder: 1.2
### File: fix-mcx-performance-de86bcc9f969b81e.yaml
---
fixes:
  - |
    Improve the decomposition of the gate generated by :meth:`.QuantumCircuit.mcx`
    without using ancilla qubits, so that the number of :class:`.CXGate` will grow
    quadratically in the number of qubits and not exponentially.


## Folder: 1.2
### File: fix-negative-seed-pm-2813a62a020da115.yaml
---
fixes:
  - |
    Fixed the behavior of :meth:`.generate_preset_pass_manager` to raise a `ValueError` exception if not provided with a non-negative integer `seed_transpiler` argument.


## Folder: 1.2
### File: fix-potential-non-determinism-dense-layout-da66de0217121146.yaml
---
fixes:
  - |
    Fixed a potential source of non-determinism in :class:`~.DenseLayout` (and
    by extension :class:`~.SabreLayout`) when targeting a
    :class:`.CouplingMap` or :class:`.Target` that has more than one subgraph
    with the same degree of connectivity. In these case the exact output
    layout from the pass could previously fluctuate based on the number of
    local CPUs and thread execution speed.


## Folder: 1.2
### File: fix-qft-plugins-7106029d33c44b96.yaml
---
fixes:
  - |
    The ``HighLevelSynthesis`` transpiler pass no longer raises an exception when
    encountering a custom gate that is called "qft" but is not an instance of
    :class:`~qiskit.circuit.library.QFTGate`. Instead, the synthesis plugins for
    QFT gates ignore such a gate, and the gate's definition is used (if provided).




## Folder: 1.2
### File: fix-qpy-parsing-123-75357c3709e35963.yaml
---
fixes:
  - |
    Fixed an issue introduced in the now
    `yanked <https://peps.python.org/pep-0592/>`__ 1.2.3 bugfix release that
    would cause an exception with the error message "Qiskit doesn't support
    loading a symengine payload generated with symengine >= 1.0" to be raised
    whenever loading a QPY file that was generated with a different symengine
    version from the version installed by the loading. This issue could only
    occur in 1.2.3.


## Folder: 1.2
### File: fix-qpy-symengine-compat-858970a9a1d6bc14.yaml
---
fixes:
  - |
    Fixed an issue with :func:`.qpy.load` when loading a QPY file containing
    a :class:`.ParameterExpression`, if the versions of ``symengine`` installed
    in the generating and loading environments were not the same.  For example,
    if a QPY file containing :class:`.ParameterExpression`\ s was generated
    using Qiskit 1.2.2 with ``symengine==0.11.0`` installed, Qiskit 1.2.2 with
    ``syengine==0.13.0`` installed would be unable to load it.

    Previously, an error would have been raised by ``symengine`` around this
    version mismatch. This has been worked around for ``symengine`` 0.11 and
    0.13 (there was no 0.12), but if you're trying to use different versions of
    ``symengine`` and there is a mismatch, this version of Qiskit still might not
    work.
issues:
  - |
    Versions of Qiskit before 1.2.4 will not be able to load QPY files dumped
    using :func:`.qpy.dump`, even with ``version`` set appropriately, if:

    * there are unbound :class:`.ParameterExpression`\ s in the QPY file,
    * the ``use_symengine=True`` flag was set (which is the default in Qiskit >=
      1.0.0) in :func:`.qpy.dump`,
    * the version of ``symengine`` installed in the generating and loading
      environments are not within the same minor version.

    This applies regardless of the version of Qiskit used in the generation (at
    least up to Qiskit 1.2.4 inclusive).

    If you want to maximize compatibility with older versions of Qiskit, you
    should set ``use_symengine=False``.  Newer versions of Qiskit should not
    require this.
  - |
    QPY files from the Qiskit 0.45 series can, under a very specific and unlikely
    set of circumstances, fail to load with any newer version of Qiskit,
    including Qiskit 1.2.4.  The criteria are:

    * the :class:`.QuantumCircuit` or :class:`.ScheduleBlock` to be dumped
      contained unbound :class:`.ParameterExpression` objects,
    * the installed version of ``symengine`` was in the 0.9 series (which was the
      most recent release during the support window of Qiskit 0.45),
    * the ``use_symengine=True`` flag was set (which was *not* the default).

    Later versions of Qiskit used during generation are not affected, because
    they required newer versions than ``symengine`` 0.9.

    In this case, you can recover the QPY file by reloading it with an environment
    with Qiskit 0.45.3 and ``symengine`` 0.9.2 installed.  Then, use
    :func:`.qpy.dump` with ``use_symengine=False`` to re-export the file. This
    will then be readable by any newer version of Qiskit.
upgrade:
  - |
    The supported versions of `symengine <https://pypi.org/project/symengine/>`__
    have been pre-emptively capped at < 0.14.0 (which is expected to be the next
    minor version, as of this release of Qiskit).  This has been done to protect
    against a potential incompatibility in :mod:`.qpy` when serializing
    :class:`.ParameterExpression` objects. The serialization used in
    :ref:`qpy_format` versions 10, 11, and 12 for :class:`.ParameterExpression`
    objects is tied to the symengine version used to generate it, and there is the potential
    for a future symengine release to not be compatible. This upper version cap is to prevent
    a future release of symengine causing incompatibilities when trying to load QPY files
    using :class:`.qpy.load`.


## Folder: 1.2
### File: fix-sabre-releasevalve-7f9af9bfc0482e04.yaml
---
fixes:
  - |
    Fixed an edge case in :class:`.SabreLayout`, where in rare cases on large
    devices and challenging circuits, the routing would fail. This was due to the 
    release valve making more than one two-qubit gate routable, where only one was expected.
    Fixed `#13081 <https://github.com/Qiskit/qiskit/issues/13081>`__.

## Folder: 1.2
### File: fix-split-2q-unitaries-custom-gate-d10f7670a35548f4.yaml
---
fixes:
  - |
    Fixed a bug in :class:`.Split2QUnitaries` where it would fail to run on circuits
    with custom gates that didn't implement :meth:`__array__`.
    See `#12984 <https://github.com/Qiskit/qiskit/issues/12970>`__.

## Folder: 1.2
### File: fix-stateprep-normalize-a8057c339ba619bd.yaml
---
fixes:
  - |
    Fixed a bug in :class:`.StatePreparation` where the ``normalize`` 
    argument was ignored for input arrays.
    Fixed `#12984 <https://github.com/Qiskit/qiskit/issues/12984>`__.


## Folder: 1.2
### File: fix-statevector-sampler-c_if-9753f8f97a3d0ff5.yaml
---
fixes:
  - |
    Fixed a bug of :class:`.StatevectorSampler` that ignored gates with ``c_if``.
    It will raise an error because :class:`.Statevector` cannot handle ``c_if``.


## Folder: 1.2
### File: fix-synth-qregs-7662681c0ff02511.yaml
---
fixes:
  - |
    Fixed a bug where various synthesis methods created circuits without quantum or
    classical registers. This also affected functions that internally used the synthesis
    methods, such as :meth:`.Clifford.to_circuit`.
    Fixed `#13041 <https://github.com/Qiskit/qiskit/issues/13041>`__.


## Folder: 1.2
### File: fix_initialize_gates_to_uncompute-d0dba6a642d07f30.yaml
---
fixes:
  - |
    Fix a bug that caused the method :meth:`Initialize.gates_to_uncompute()` fail.


## Folder: 1.2
### File: improve-quantum-causal-cone-f63eaaa9ab658811.yaml
---
features_circuits:
  - |
    Improved performance of the method :meth:`.DAGCircuit.quantum_causal_cone` by not examining
    the same non-directive node multiple times when reached from different paths.


## Folder: 1.2
### File: linear-binary-matrix-utils-rust-c48b5577749c34ab.yaml
---
features_synthesis:
  - |
    Port internal binary matrix utils from Python to Rust, including
    binary matrix multiplication, gaussian elimination, rank calculation,
    binary matrix inversion, and random invertible binary matrix generation.
    These functions are not part of the Qiskit API, and porting them to rust
    improves the performance of certain synthesis methods.


## Folder: 1.2
### File: mcx_recursive_clean_ancilla-2b0f6956e0f4cbbd.yaml
---
features_synthesis:
  - |
    :class:`.MCXRecursive` with :math:`k` control qubits and a single clean auxiliary qubit
    now requires at most :math:`16k-8` CX gates.


## Folder: 1.2
### File: mcxvchain_dirty_auxiliary-5ea4037557209f6e.yaml
---
features:
  - |
    :class:`.MCXVChain` has two new Boolean parameters `relative_phase` and `action_only`.
    If `action_only` the circuit does not clean the dirty qubits. If `relative_phase`
    the gate is implemented up to a global phase. Both parameters are used to optimize the
    decomposition of MCXVChain.
fixes:
  - |
    :class:`.MCXVChain` with k controls and k-2 dirty auxiliary qubits now requires 8k-6 cx gates.


## Folder: 1.2
### File: no-elide-routing-none-7c1bebf1283d48c0.yaml
---
fixes:
  - |
    Fixed an issue when running :func:`.transpile` or
    :meth:`~.StagedPassManager.run` on a pass manager generated by
    :func:`.generate_preset_pass_manager` using ``optimization_level`` 2 or 3
    when the ``routing_method`` argument is set to ``"none"`` to explicitly
    disable routing. Previously under these conditions the transpiler would run
    the :class:`.ElidePermutation` pass as part of the init stage as under normal
    conditions this is a useful optimization to remove :class:`.SwapGate`
    and :class:`.PermutationGate` instances from the circuit. But when
    ``routing_method="none"`` this optimization wasn't expected as it permutes
    the circuit in a similar manner to routing which shouldn't be performed
    when ``routing_method="none"``. This has been fixed by no longer
    running :class:`.ElidePermutation` if ``routing_method="none"`` is set.
    Fixed `#13144 <https://github.com/Qiskit/qiskit/issues/13144>`__


## Folder: 1.2
### File: oxidize-acg-0294a87c0d5974fa.yaml
---
features_synthesis:
  - |
    Port :func:`.synth_permutation_acg`, used to synthesize qubit permutations, to Rust.
    This produces an approximate 3x performance improvement on 1000 qubit circuits.


## Folder: 1.2
### File: oxidize-permbasic-be27578187ac472f.yaml
---
features_synthesis:
  - |
    Port :func:`.synth_permutation_basic`, used to synthesize qubit permutations, to Rust.


## Folder: 1.2
### File: oxidize-pmh-ec74e4002510eaad.yaml
---
features_synthesis:
  - |
    Port :func:`.synth_cnot_full_pmh`, used to synthesize a linear function
    into a CX network, to Rust. This produces approximately 44x speedup,
    as measured on 100 qubit circuits. 
  - |
    The function :func:`.synth_cnot_full_pmh` now allows choosing the 
    (heuristically) optimal ``section_size`` by setting it to ``None``. Then, a value is 
    chosen which attempts to minimize the upper bound on the number of CX gates, that is
    :math:`\alpha \log_2(n)` where :math:`n` is the number of qubits and :math:`\alpha \approx 0.56`.
fixes:
  - |
    Fixed a bug in :func:`.synth_cnot_full_pmh` where providing a ``section_size`` that did 
    not divide the number of qubits without remainder could lead to wrong results. 
    Now any ``section_size`` (at most equal to the number of qubits) synthesizes the correct
    circuit. For a (heuristically) optimal value, set ``section_size=None``.


## Folder: 1.2
### File: oxidize-synth-clifford-bm-91d8b974ca0522b7.yaml
---
features_synthesis:
  - |
    The function :func:`.synth_clifford_bm` was ported to Rust. Recall that this function
    optimally synthesizes :class:`.Clifford` operators on 1, 2 or 3 qubits with respect to the
    number of CX-gates. This leads to a significant increase in performance. For Cliffords
    over 3 qubits, the speedup in on the order of 80 times.


## Folder: 1.2
### File: oxidize-synth-clifford-greedy-0739e9688bc4eedd.yaml
---
features_synthesis:
  - |
    The function :func:`.synth_clifford_greedy` that synthesizes :class:`.Clifford` operators
    was ported to Rust, leading to a significant increase in performance for all numbers of
    qubits. For Cliffords over 50 qubits, the speedup is on the order of 1000 times.


## Folder: 1.2
### File: peephole-before-routing-c3d184b740bb7a8b.yaml
---
features_transpiler:
  - |
    Added a new pass :class:`.Split2QUnitaries` that iterates over all two-qubit gates or unitaries in a
    circuit and replaces them with two single-qubit unitaries, if possible without introducing errors, i.e.
    the two-qubit gate/unitary is actually a (kronecker) product of single-qubit unitaries.
  - |
    The passes :class:`.Collect2qBlocks`, :class:`.ConsolidateBlocks` and :class:`.Split2QUnitaries` have been
    added to the ``init`` stage of the preset pass managers with optimization level 2 and optimization level 3.
    The modification of the `init` stage should allow for a more efficient routing for quantum circuits that either:
    
      * contain two-qubit unitaries/gates that are actually a product of single-qubit gates
      * contain multiple two-qubit gates in a continuous block of two-qubit gates.
      
    In the former case, the routing of the two-qubit gate can simply be skipped as no real interaction
    between a pair of qubits occurs. In the latter case, the lookahead space of routing algorithms is not
    'polluted' by superfluous two-qubit gates, i.e. for routing it is sufficient to only consider one single
    two-qubit gate per continuous block of two-qubit gates. These passes are not run if the pass
    managers target a :class:`.Target` that has a discrete basis gate set, i.e. all basis gates have are not
    parameterized.


## Folder: 1.2
### File: port_star_prerouting-13fae3ff78feb5e3.yaml
---
features_transpiler:
  - |
    Port part of the logic from the :class:`StarPrerouting`, used to 
    find a star graph connectivity subcircuit and replaces it with a 
    linear routing equivalent.
  - | 
    The function :func:`star_preroute` now performs the heavily lifting
    to transform the dag by in the rust space by taking advantage 
    of the functions :func:`_build_sabre_dag` and 
    :func:`_apply_sabre_result`.


## Folder: 1.2
### File: qasm2-builtin-gate-d80c2868cdf5f958.yaml
---
fixes:
  - |
    The OpenQASM 2 importer previously would output incorrect :class:`.Gate` instances for gate
    calls referring to a ``gate`` definition that followed a prior ``gate`` definition that was
    being treated as a built-in operation by a :class:`~.qasm2.CustomInstruction`.  See
    `#13339 <https://github.com/Qiskit/qiskit/issues/13339>`__ for more detail.


## Folder: 1.2
### File: qasm3-basis-gates-keyword-c5998bff1e178715.yaml
---
fixes:
  - |
    The OpenQASM 3 exporter will now correctly error when asked to use a keyword or other invalid
    identifier as a "basis gate", as it has no way of putting out correct output in these cases.


## Folder: 1.2
### File: qasm3-includes-ceb56f49b8c190ff.yaml
---
fixes:
  - |
    The OpenQASM 3 exporter has restored its behavior of accepting non-standard-library include
    files in the ``includes`` argument to :func:`.qasm3.dump`, :func:`~.qasm3.dumps`, and
    :class:`~.qasm3.Exporter`.  These will insert a suitable ``include`` statement into the output
    as before, and the exporter remains unaware of the intended gates in that include file; you
    should pass the gates you expect it to define in the ``basis_gates`` argument to the same functions.

    We expect to improve the export mechanism against non-standard include files in a future release
    of Qiskit.


## Folder: 1.2
### File: qasm3-symbol-table-efad35629639c77d.yaml
---
features_qasm:
  - |
    The internal symbol table of the OpenQASM 3 exporter (:mod:`qiskit.qasm3`) has been rewritten,
    which should result in cleaner outputs when using Qiskit standard-library gates that are not in
    the OpenQASM 3 standard-library headers, and more deterministic outputs.  For example, using
    several :class:`.RZXGate`\ s will now result in only a single parametric definition, and when
    naming collisions occur, the symbol table will assign a deterministic counter to make names
    unique, rather than a non-deterministic integer (previously, the object identity was used).
fixes:
  - |
    The OpenQASM 3 exporter (:mod:`qiskit.qasm3`) will now correctly export multiple instances of
    :class:`.PauliEvolutionGate` from a circuit.  Previously, only a single instance would be exported,
    and all other instances would silently use the same (incorrect) version.
  - |
    The OpenQASM 3 exporter (:mod:`qiskit.qasm3`) will now correctly escape gate names.  Previously,
    a gate whose name was an invalid OpenQASM 3 identifier would cause invalid OpenQASM 3 to be
    generated.


## Folder: 1.2
### File: replace-initialization-algorithm-by-isometry-41f9ffa58f72ece5.yaml
---
features_circuits:
  - |
    Replacing the internal synthesis algorithm of :class:`~.library.StatePreparation`
    and :class:`~.library.Initialize` of Shende et al. by the algorithm given in
    :class:`~.library.Isometry` of Iten et al.
    The new algorithm reduces the number of CX gates and the circuit depth by a factor of 2.


## Folder: 1.2
### File: restrict-split2q-d51d840cc7a7a482.yaml
---
fixes:
  - |
    Fixed an edge case when transpiling a circuit with ``optimization_level`` 2 or 3 with an
    incomplete 1-qubit basis gate set on a circuit containing 2-qubit gates, that can be
    implemented as a product of single qubit gates. This bug is resolved by restricting
    :class:`.Split2QUnitaries` to consider only :class:`.UnitaryGate` objects.
    Fixed `#12970 <https://github.com/Qiskit/qiskit/issues/12970>`__.


## Folder: 1.2
### File: sabre_level0-1524f01965257f3f.yaml
---
upgrade_transpiler:
  - |
    The default routing pass used by optimization level 0 for :func:`.generate_preset_pass_manager`
    and :func:`.transpile` has been changed from :class:`.StochasticSwap` to :class:`.SabreSwap`.
    The :class:`.SabreSwap` pass performs exactly the same function but performs better in both
    runtime and output quality (in number of swap gates and depth) compared to
    :class:`.StochasticSwap`. For ``optimization_level=0`` this shouldn't matter because it's not
    expected to run routing for the typical use case of level 0.
       
    If you were relying on the previous default routing algorithm for any reason you can use the
    ``routing_method`` argument for :func:`.transpile` and :func:`.generate_preset_pass_manager`
    to ``"stochastic"`` to use the :class:`.StochasticSwap` pass.


## Folder: 1.2
### File: synth_permutation_depth_lnn_kms-c444f3a363f3a903.yaml
---
features_synthesis:
  - |
    Port :func:`.synth_permutation_depth_lnn_kms`, used to synthesize permutations for linear connectivity, to Rust.

## Folder: 1.2
### File: unary_pos_for_parameterexpression-6421421b6dc20fbb.yaml
---
features_circuits:
  - |
    :class:`.ParameterExpression` now supports the unary ``+`` operator.


## Folder: 1.2
### File: update-primitive-v2-metadata-cf1226e2d6477688.yaml
---
features_primitives:
  - |
    The metadata of Primitives V2 implementations, i.e., :class:`.StatevectorSampler`,
    :class:`.StatevectorEstimator`, :class:`.BackendSamplerV2` and :class:`.BackendEstimatorV2`,
    has been updated to match that of IBM quantum devices.

    * ``version`` and ``circuit_metadata`` are added for all V2 implementations
    * ``shots`` is added for :class:`.BackendSamplerV2` and :class:`.BackendEstimatorV2`
    * ``precision`` is renamed with ``target_precision`` for :class:`.StatevectorEstimator`

    Note that metadata of :class:`.StatevectorEstimator` does not have ``shots`` because
    the class computes expectation values with :class:`.Statevector` and shots are not used.


## Folder: 1.2
### File: update-qasm3-lib-40e15bc24234970d.yaml
---
features_qasm:
  - |
    The vendored version of the OpenQASM 3.0 standard library has been
    updated to match `the state as of commit 4ca1d79383 <https://github.com/openqasm/openqasm/blob/4ca1d793833b24a195dcb8a5db99f1bd21b0d32f/examples/stdgates.inc>`__.
    This should generally have no effect on your use of Qiskit, unless you
    were retrieving our vendored file for your own use.


## Folder: 1.2
### File: update-rustworkx-min-version-4f07aacfebccae80.yaml
---
upgrade_misc:
  - |
    The minimum version of rustworkx required to run this release has been
    increased from 0.14.0 to 0.15.0. This is required because Qiskit is now
    using new functionality added in the rustworkx 0.15.0 release which
    improves performance.


## Folder: 1.2
### File: use-target-in-generate-preset-pm-5215e00d22d0205c.yaml
---
features_transpiler:
  - |
    A new ``dt`` argument has been added to :func:`.generate_preset_pass_manager` to match
    the set of arguments of :func:`.transpile`. This will allow for the internal conversion 
    of transpilation constraints to a :class:`.Target` representation.
    
upgrade_transpiler:
  - |
    The :func:`.generate_preset_pass_manager` function has been upgraded to, when possible,
    internally convert transpiler constraints into a :class:`.Target` instance.
    If a `backend` input of type :class:`.BackendV1` is provided, it will be 
    converted to :class:`.BackendV2` to expose its :class:`.Target`. This change does 
    not require any user action.

fixes:
  - |
    A series of input-handling inconsistencies between :func:`.transpile` and :func:`.generate_preset_pass_manager` 
    have been fixed. These inconsistencies would lead to different transpilation outputs for the same inputs, 
    or :func:`.generate_preset_pass_manager` failing for certain input combinations accepted by :func:`.transpile`.

## Folder: 1.2
### File: workaroud_12361-994d0ac2d2a6ed41.yaml
---
features_visualization:
  - |
    The user configuration file has a new option ``circuit_idle_wires``, which takes a Boolean
    value. This allows users to set their preferred default behavior of the ``idle_wires`` option
    of the circuit drawers :meth:`.QuantumCircuit.draw` and :func:`.circuit_drawer`.  For example,
    adding a section to ``~/.qiskit/settings.conf`` with:

    .. code-block:: text
    
      [default]
      circuit_idle_wires = false

    will change the default to display the bits in reverse order.
