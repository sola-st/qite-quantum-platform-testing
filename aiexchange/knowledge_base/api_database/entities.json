[
    {
        "api_name": "_new_namespace",
        "full_api_name": "_new_namespace",
        "api_description": "",
        "api_signature": "_new_namespace(fullname, old_namespace, new_package)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/namespace.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QiskitLoader.__init__",
        "api_description": "",
        "api_signature": "__init__(self, new_package, old_namespace)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/namespace.py"
    },
    {
        "api_name": "module_repr",
        "full_api_name": "QiskitLoader.module_repr",
        "api_description": "",
        "api_signature": "module_repr(self, module)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/namespace.py"
    },
    {
        "api_name": "create_module",
        "full_api_name": "QiskitLoader.create_module",
        "api_description": "",
        "api_signature": "create_module(self, spec)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/namespace.py"
    },
    {
        "api_name": "exec_module",
        "full_api_name": "QiskitLoader.exec_module",
        "api_description": "Executes the module. Not needed in Qiskit.",
        "api_signature": "exec_module(self, module)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/namespace.py"
    },
    {
        "api_name": "load_module",
        "full_api_name": "QiskitLoader.load_module",
        "api_description": "",
        "api_signature": "load_module(self, fullname)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/namespace.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QiskitElementImport.__init__",
        "api_description": "",
        "api_signature": "__init__(self, old_namespace, new_package)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/namespace.py"
    },
    {
        "api_name": "find_spec",
        "full_api_name": "QiskitElementImport.find_spec",
        "api_description": "Return the ModuleSpec for Qiskit element.",
        "api_signature": "find_spec(self, fullname, path, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/namespace.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "UserConfig.__init__",
        "api_description": "Create a UserConfig\n\nArgs:\n    filename (str): The path to the user config file. If one isn't\n        specified, ~/.qiskit/settings.conf is used.",
        "api_signature": "__init__(self, filename)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/user_config.py"
    },
    {
        "api_name": "read_config_file",
        "full_api_name": "UserConfig.read_config_file",
        "api_description": "Read config file and parse the contents into the settings attr.",
        "api_signature": "read_config_file(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/user_config.py"
    },
    {
        "api_name": "set_config",
        "full_api_name": "set_config",
        "api_description": "Adds or modifies a user configuration\n\nIt will add configuration to the currently configured location\nor the value of file argument.\n\nOnly valid user config can be set in 'default' section. Custom\nuser config can be added in any other sections.\n\nChanges to the existing config file will not be reflected in\nthe current session since the config file is parsed at import time.\n\nArgs:\n    key (str): name of the config\n    value (obj): value of the config\n    section (str, optional): if not specified, adds it to the\n        `default` section of the config file.\n    file_path (str, optional): the file to which config is added.\n        If not specified, adds it to the default config file or\n        if set, the value of `QISKIT_SETTINGS` env variable.\n\nRaises:\n    QiskitUserConfigError: if the config is invalid",
        "api_signature": "set_config(key, value, section, file_path)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/user_config.py"
    },
    {
        "api_name": "get_config",
        "full_api_name": "get_config",
        "api_description": "Read the config file from the default location or env var\n\nIt will read a config file at either the default location\n~/.qiskit/settings.conf or if set the value of the QISKIT_SETTINGS env var.\n\nIt will return the parsed settings dict from the parsed config file.\nReturns:\n    dict: The settings dict from the parsed config file.",
        "api_signature": "get_config()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/user_config.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QiskitError.__init__",
        "api_description": "Set the error message.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/exceptions.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "QiskitError.__str__",
        "api_description": "Return the message.",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/exceptions.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "MissingOptionalLibraryError.__init__",
        "api_description": "Set the error message.\nArgs:\n    libname: Name of missing library\n    name: Name of class, function, module that uses this library\n    pip_install: pip install command, if any\n    msg: Descriptive message, if any",
        "api_signature": "__init__(self, libname, name, pip_install, msg)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/exceptions.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "MissingOptionalLibraryError.__str__",
        "api_description": "Return the message.",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/exceptions.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "AerWrapper.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/__init__.py"
    },
    {
        "api_name": "__bool__",
        "full_api_name": "AerWrapper.__bool__",
        "api_description": "",
        "api_signature": "__bool__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/__init__.py"
    },
    {
        "api_name": "__getattr__",
        "full_api_name": "AerWrapper.__getattr__",
        "api_description": "",
        "api_signature": "__getattr__(self, attr)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/__init__.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "IBMQWrapper.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/__init__.py"
    },
    {
        "api_name": "__bool__",
        "full_api_name": "IBMQWrapper.__bool__",
        "api_description": "",
        "api_signature": "__bool__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/__init__.py"
    },
    {
        "api_name": "__getattr__",
        "full_api_name": "IBMQWrapper.__getattr__",
        "api_description": "",
        "api_signature": "__getattr__(self, attr)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/__init__.py"
    },
    {
        "api_name": "_minimal_ext_cmd",
        "full_api_name": "_minimal_ext_cmd",
        "api_description": "",
        "api_signature": "_minimal_ext_cmd(cmd)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/version.py"
    },
    {
        "api_name": "git_version",
        "full_api_name": "git_version",
        "api_description": "Get the current git head sha1.",
        "api_signature": "git_version()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/version.py"
    },
    {
        "api_name": "get_version_info",
        "full_api_name": "get_version_info",
        "api_description": "Get the full version string.",
        "api_signature": "get_version_info()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/version.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QiskitVersion.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/version.py"
    },
    {
        "api_name": "_load_versions",
        "full_api_name": "QiskitVersion._load_versions",
        "api_description": "",
        "api_signature": "_load_versions(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/version.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "QiskitVersion.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/version.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "QiskitVersion.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/version.py"
    },
    {
        "api_name": "__getitem__",
        "full_api_name": "QiskitVersion.__getitem__",
        "api_description": "",
        "api_signature": "__getitem__(self, key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/version.py"
    },
    {
        "api_name": "__iter__",
        "full_api_name": "QiskitVersion.__iter__",
        "api_description": "",
        "api_signature": "__iter__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/version.py"
    },
    {
        "api_name": "__len__",
        "full_api_name": "QiskitVersion.__len__",
        "api_description": "",
        "api_signature": "__len__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/version.py"
    },
    {
        "api_name": "_log_submission_time",
        "full_api_name": "_log_submission_time",
        "api_description": "",
        "api_signature": "_log_submission_time(start_time, end_time)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/execute_function.py"
    },
    {
        "api_name": "execute",
        "full_api_name": "execute",
        "api_description": "Execute a list of :class:`qiskit.circuit.QuantumCircuit` or\n:class:`qiskit.pulse.Schedule` on a backend.\n\nThe execution is asynchronous, and a handle to a job instance is returned.\n\nArgs:\n    experiments (QuantumCircuit or list[QuantumCircuit] or Schedule or list[Schedule]):\n        Circuit(s) or pulse schedule(s) to execute\n\n    backend (Backend):\n        Backend to execute circuits on.\n        Transpiler options are automatically grabbed from\n        backend.configuration() and backend.properties().\n        If any other option is explicitly set (e.g. coupling_map), it\n        will override the backend's.\n\n    basis_gates (list[str]):\n        List of basis gate names to unroll to.\n        e.g: ``['u1', 'u2', 'u3', 'cx']``.\n        If ``None``, do not unroll.\n\n    coupling_map (CouplingMap or list): Coupling map (perhaps custom) to\n        target in mapping. Multiple formats are supported:\n\n        #. :class:`.CouplingMap` instance\n        #. ``list``:\n           must be given as an adjacency matrix, where each entry\n           specifies all two-qubit interactions supported by backend\n           e.g: ``[[0, 1], [0, 3], [1, 2], [1, 5], [2, 5], [4, 1], [5, 3]]``\n\n    backend_properties (BackendProperties):\n        Properties returned by a backend, including information on gate\n        errors, readout errors, qubit coherence times, etc. Find a backend\n        that provides this information with:\n        ``backend.properties()``\n\n    initial_layout (Layout or dict or list):\n        Initial position of virtual qubits on physical qubits.\n        If this layout makes the circuit compatible with the coupling_map\n        constraints, it will be used.\n        The final layout is not guaranteed to be the same, as the transpiler\n        may permute qubits through swaps or other means.\n\n        Multiple formats are supported:\n\n        #. :class:`qiskit.transpiler.Layout` instance\n        #. ``dict``:\n\n           * virtual to physical::\n\n                {qr[0]: 0,\n                 qr[1]: 3,\n                 qr[2]: 5}\n\n           * physical to virtual::\n\n                {0: qr[0],\n                 3: qr[1],\n                 5: qr[2]}\n\n        #. ``list``:\n\n           * virtual to physical::\n\n                [0, 3, 5]  # virtual qubits are ordered (in addition to named)\n\n           * physical to virtual::\n\n                [qr[0], None, None, qr[1], None, qr[2]]\n\n    seed_transpiler (int): Sets random seed for the stochastic parts of the transpiler\n\n    optimization_level (int): How much optimization to perform on the circuits.\n        Higher levels generate more optimized circuits,\n        at the expense of longer transpilation time.\n\n        * 0: no optimization\n        * 1: light optimization\n        * 2: heavy optimization\n        * 3: even heavier optimization\n\n        If None, level 1 will be chosen as default.\n\n    pass_manager (PassManager): The pass manager to use during transpilation. If this\n        arg is present, auto-selection of pass manager based on the transpile options\n        will be turned off and this pass manager will be used directly.\n\n    shots (int): Number of repetitions of each circuit, for sampling. Default: 1024\n\n    memory (bool): If True, per-shot measurement bitstrings are returned as well\n        (provided the backend supports it). For OpenPulse jobs, only\n        measurement level 2 supports this option. Default: False\n\n    seed_simulator (int): Random seed to control sampling, for when backend is a simulator\n\n    default_qubit_los (Optional[List[float]]): List of job level qubit drive LO frequencies\n        in Hz. Overridden by ``schedule_los`` if specified. Must have length ``n_qubits``.\n\n    default_meas_los (Optional[List[float]]): List of job level measurement LO frequencies in\n        Hz. Overridden by ``schedule_los`` if specified. Must have length ``n_qubits``.\n\n    qubit_lo_range (Optional[List[List[float]]]): List of job level drive LO ranges each of form\n        ``[range_min, range_max]`` in Hz. Used to validate ``qubit_lo_freq``. Must have length\n        ``n_qubits``.\n\n    meas_lo_range (Optional[List[List[float]]]): List of job level measurement LO ranges each of\n        form ``[range_min, range_max]`` in Hz. Used to validate ``meas_lo_freq``. Must have\n        length ``n_qubits``.\n\n    schedule_los (list):\n        Experiment level (ie circuit or schedule) LO frequency configurations for qubit drive\n        and measurement channels. These values override the job level values from\n        ``default_qubit_los`` and ``default_meas_los``. Frequencies are in Hz. Settable for qasm\n        and pulse jobs.\n\n        If a single LO config or dict is used, the values are set at job level. If a list is\n        used, the list must be the size of the number of experiments in the job, except in the\n        case of a single experiment. In this case, a frequency sweep will be assumed and one\n        experiment will be created for every list entry.\n\n        Not every channel is required to be specified. If not specified, the backend default\n        value will be used.\n\n    meas_level (int or MeasLevel): Set the appropriate level of the\n        measurement output for pulse experiments.\n\n    meas_return (str or MeasReturn): Level of measurement data for the\n        backend to return For ``meas_level`` 0 and 1:\n        ``\"single\"`` returns information from every shot.\n        ``\"avg\"`` returns average measurement output (averaged over number\n        of shots).\n\n    memory_slots (int): Number of classical memory slots used in this job.\n\n    memory_slot_size (int): Size of each memory slot if the output is Level 0.\n\n    rep_time (int): Time per program execution in seconds. Must be from the list provided\n        by the backend (``backend.configuration().rep_times``). Defaults to the first entry.\n\n    rep_delay (float): Delay between programs in seconds. Only supported on certain\n        backends (``backend.configuration().dynamic_reprate_enabled`` ). If supported,\n        ``rep_delay`` will be used instead of ``rep_time`` and must be from the range supplied\n        by the backend (``backend.configuration().rep_delay_range``). Default is given by\n        ``backend.configuration().default_rep_delay``.\n\n    parameter_binds (list[dict]): List of Parameter bindings over which the set of\n        experiments will be executed. Each list element (bind) should be of the form\n        ``{Parameter1: value1, Parameter2: value2, ...}``. All binds will be\n        executed across all experiments, e.g. if parameter_binds is a\n        length-:math:`n` list, and there are :math:`m` experiments, a total of :math:`m \\times n`\n        experiments will be run (one for each experiment/bind pair).\n\n    schedule_circuit (bool): If ``True``, ``experiments`` will be converted to\n        :class:`qiskit.pulse.Schedule` objects prior to execution.\n\n    inst_map (InstructionScheduleMap):\n        Mapping of circuit operations to pulse schedules. If None, defaults to the\n        ``instruction_schedule_map`` of ``backend``.\n\n    meas_map (list(list(int))):\n        List of sets of qubits that must be measured together. If None, defaults to\n        the ``meas_map`` of ``backend``.\n\n    scheduling_method (str or list(str)):\n        Optionally specify a particular scheduling method.\n\n    init_qubits (bool): Whether to reset the qubits to the ground state for each shot.\n                        Default: ``True``.\n\n    run_config (dict):\n        Extra arguments used to configure the run (e.g. for Aer configurable backends).\n        Refer to the backend documentation for details on these arguments.\n        Note: for now, these keyword arguments will both be copied to the\n        Qobj config, and passed to backend.run()\n\nReturns:\n    Job: returns job instance derived from Job\n\nRaises:\n    QiskitError: if the execution cannot be interpreted as either circuits or schedules\n\nExample:\n    Construct a 5-qubit GHZ circuit and execute 4321 shots on a backend.\n\n    .. code-block::\n\n        from qiskit import QuantumCircuit, execute, BasicAer\n\n        backend = BasicAer.get_backend('qasm_simulator')\n\n        qc = QuantumCircuit(5, 5)\n        qc.h(0)\n        qc.cx(0, range(1, 5))\n        qc.measure_all()\n\n        job = execute(qc, backend, shots=4321)",
        "api_signature": "execute(experiments, backend, basis_gates, coupling_map, backend_properties, initial_layout, seed_transpiler, optimization_level, pass_manager, shots, memory, seed_simulator, default_qubit_los, default_meas_los, qubit_lo_range, meas_lo_range, schedule_los, meas_level, meas_return, memory_slots, memory_slot_size, rep_time, rep_delay, parameter_binds, schedule_circuit, inst_map, meas_map, scheduling_method, init_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/execute_function.py"
    },
    {
        "api_name": "_check_conflicting_argument",
        "full_api_name": "_check_conflicting_argument",
        "api_description": "",
        "api_signature": "_check_conflicting_argument()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/execute_function.py"
    },
    {
        "api_name": "normalize_vector",
        "full_api_name": "normalize_vector",
        "api_description": "Normalize the input state vector.",
        "api_signature": "normalize_vector(vector)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/arithmetic.py"
    },
    {
        "api_name": "is_power_of_2",
        "full_api_name": "is_power_of_2",
        "api_description": "Check if the input number is a power of 2.",
        "api_signature": "is_power_of_2(num)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/arithmetic.py"
    },
    {
        "api_name": "log2",
        "full_api_name": "log2",
        "api_description": "Compute the log2 of the input number. Use bit operation if the input is a power of 2.",
        "api_signature": "log2(num)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/arithmetic.py"
    },
    {
        "api_name": "is_power",
        "full_api_name": "is_power",
        "api_description": "Check if num is a perfect power in O(n^3) time, n=ceil(logN)",
        "api_signature": "is_power(num, return_decomposition)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/arithmetic.py"
    },
    {
        "api_name": "next_power_of_2_base",
        "full_api_name": "next_power_of_2_base",
        "api_description": "Return the base of the smallest power of 2 no less than the input number",
        "api_signature": "next_power_of_2_base(n)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/arithmetic.py"
    },
    {
        "api_name": "transpositions",
        "full_api_name": "transpositions",
        "api_description": "Return a sequence of transpositions, corresponding to the permutation.\n\nArgs:\n    permutation: The ``List[int]`` defining the permutation. An element at index ``j`` should be\n        permuted to index ``permutation[j]``.\n\nReturns:\n    List of transpositions, corresponding to the permutation. For permutation = [3, 0, 2, 1],\n    returns [(0,1), (0,3)]",
        "api_signature": "transpositions(permutation)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/arithmetic.py"
    },
    {
        "api_name": "triu_to_dense",
        "full_api_name": "triu_to_dense",
        "api_description": "Converts upper triangular part of matrix to dense matrix.\n\nArgs:\n    triu: array in the form [[A, B, C], [D, E], [F]]\n\nReturns:\n    Array [[A, B, C], [B, D, E], [C, E, F]]",
        "api_signature": "triu_to_dense(triu)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/arithmetic.py"
    },
    {
        "api_name": "validate_in_set",
        "full_api_name": "validate_in_set",
        "api_description": "Args:\n    name: value name.\n    value: value to check.\n    values: set that should contain value.\nRaises:\n    ValueError: invalid value",
        "api_signature": "validate_in_set(name, value, values)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/validation.py"
    },
    {
        "api_name": "validate_min",
        "full_api_name": "validate_min",
        "api_description": "Args:\n    name: value name.\n    value: value to check.\n    minimum: minimum value allowed.\nRaises:\n    ValueError: invalid value",
        "api_signature": "validate_min(name, value, minimum)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/validation.py"
    },
    {
        "api_name": "validate_min_exclusive",
        "full_api_name": "validate_min_exclusive",
        "api_description": "Args:\n    name: value name.\n    value: value to check.\n    minimum: minimum value allowed.\nRaises:\n    ValueError: invalid value",
        "api_signature": "validate_min_exclusive(name, value, minimum)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/validation.py"
    },
    {
        "api_name": "validate_max",
        "full_api_name": "validate_max",
        "api_description": "Args:\n    name: value name.\n    value: value to check.\n    maximum: maximum value allowed.\nRaises:\n    ValueError: invalid value",
        "api_signature": "validate_max(name, value, maximum)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/validation.py"
    },
    {
        "api_name": "validate_max_exclusive",
        "full_api_name": "validate_max_exclusive",
        "api_description": "Args:\n    name: value name.\n    value: value to check.\n    maximum: maximum value allowed.\nRaises:\n    ValueError: invalid value",
        "api_signature": "validate_max_exclusive(name, value, maximum)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/validation.py"
    },
    {
        "api_name": "validate_range",
        "full_api_name": "validate_range",
        "api_description": "Args:\n    name: value name.\n    value: value to check.\n    minimum: minimum value allowed.\n    maximum: maximum value allowed.\nRaises:\n    ValueError: invalid value",
        "api_signature": "validate_range(name, value, minimum, maximum)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/validation.py"
    },
    {
        "api_name": "validate_range_exclusive",
        "full_api_name": "validate_range_exclusive",
        "api_description": "Args:\n    name: value name.\n    value: value to check.\n    minimum: minimum value allowed.\n    maximum: maximum value allowed.\nRaises:\n    ValueError: invalid value",
        "api_signature": "validate_range_exclusive(name, value, minimum, maximum)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/validation.py"
    },
    {
        "api_name": "validate_range_exclusive_min",
        "full_api_name": "validate_range_exclusive_min",
        "api_description": "Args:\n    name: value name.\n    value: value to check.\n    minimum: minimum value allowed.\n    maximum: maximum value allowed.\nRaises:\n    ValueError: invalid value",
        "api_signature": "validate_range_exclusive_min(name, value, minimum, maximum)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/validation.py"
    },
    {
        "api_name": "validate_range_exclusive_max",
        "full_api_name": "validate_range_exclusive_max",
        "api_description": "Args:\n    name: value name.\n    value: value to check.\n    minimum: minimum value allowed.\n    maximum: maximum value allowed.\nRaises:\n    ValueError: invalid value",
        "api_signature": "validate_range_exclusive_max(name, value, minimum, maximum)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/validation.py"
    },
    {
        "api_name": "__new__",
        "full_api_name": "_lift_to_method.__new__",
        "api_description": "",
        "api_signature": "__new__(cls, method)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/classtools.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "_lift_to_method.__init__",
        "api_description": "",
        "api_signature": "__init__(self, method)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/classtools.py"
    },
    {
        "api_name": "__get__",
        "full_api_name": "_lift_to_method.__get__",
        "api_description": "",
        "api_signature": "__get__(self, obj, objtype)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/classtools.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "_WrappedMethod.__init__",
        "api_description": "",
        "api_signature": "__init__(self, method, before, after)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/classtools.py"
    },
    {
        "api_name": "__get__",
        "full_api_name": "_WrappedMethod.__get__",
        "api_description": "",
        "api_signature": "__get__(self, obj, objtype)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/classtools.py"
    },
    {
        "api_name": "out",
        "full_api_name": "_WrappedMethod.out",
        "api_description": "",
        "api_signature": "out()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/classtools.py"
    },
    {
        "api_name": "wrap_method",
        "full_api_name": "wrap_method",
        "api_description": "Wrap the functionality the instance- or class method ``cls.name`` with additional behaviour\n``before`` and ``after``.\n\nThis mutates ``cls``, replacing the attribute ``name`` with the new functionality.  This is\nuseful when creating class decorators.  The method is allowed to be defined on any parent class\ninstead.\n\nIf either ``before`` or ``after`` are given, they should be callables with a compatible\nsignature to the method referred to.  They will be called immediately before or after the method\nas appropriate, and any return value will be ignored.\n\nArgs:\n    cls: the class to modify.\n    name: the name of the method on the class to wrap.\n    before: a callable that should be called before the method that is being wrapped.\n    after: a callable that should be called after the method that is being wrapped.\n\nRaises:\n    ValueError: if the named method is not defined on the class or any parent class.",
        "api_signature": "wrap_method(cls, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/classtools.py"
    },
    {
        "api_name": "find_regs_by_name",
        "full_api_name": "find_regs_by_name",
        "api_description": "Deprecated: Find the registers in the circuits.\n\nArgs:\n    circuit: the quantum circuit.\n    name: name of register\n    qreg: quantum or classical register\n\nReturns:\n    if not found, return None.",
        "api_signature": "find_regs_by_name(circuit, name, qreg)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/run_circuits.py"
    },
    {
        "api_name": "_combine_result_objects",
        "full_api_name": "_combine_result_objects",
        "api_description": "Temporary helper function.\n\nTODO: This function would be removed after Terra supports job with infinite circuits.",
        "api_signature": "_combine_result_objects(results)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/run_circuits.py"
    },
    {
        "api_name": "_safe_get_job_status",
        "full_api_name": "_safe_get_job_status",
        "api_description": "",
        "api_signature": "_safe_get_job_status(job, job_id, max_job_retries, wait)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/run_circuits.py"
    },
    {
        "api_name": "run_circuits",
        "full_api_name": "run_circuits",
        "api_description": "Deprecated: An execution wrapper with Qiskit-Terra, with job auto recover capability.\n\nThe auto-recovery feature is only applied for non-simulator backend.\nThis wrapper will try to get the result no matter how long it takes.\n\nArgs:\n    circuits: circuits to execute\n    backend: backend instance\n    qjob_config: configuration for quantum job object\n    backend_options: backend options\n    noise_config: configuration for noise model\n    run_config: configuration for run\n    job_callback: callback used in querying info of the submitted job, and providing the\n        following arguments: job_id, job_status, queue_position, job.\n    max_job_retries(int): positive non-zero number of trials for the job set (-1 for infinite\n        trials) (default: 50)\n\nReturns:\n    Result object\n\nRaises:\n    QiskitError: Any error except for JobError raised by Qiskit Terra",
        "api_signature": "run_circuits(circuits, backend, qjob_config, backend_options, noise_config, run_config, job_callback, max_job_retries)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/run_circuits.py"
    },
    {
        "api_name": "_safe_submit_circuits",
        "full_api_name": "_safe_submit_circuits",
        "api_description": "",
        "api_signature": "_safe_submit_circuits(circuits, backend, qjob_config, backend_options, noise_config, run_config, max_job_retries)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/run_circuits.py"
    },
    {
        "api_name": "_run_circuits_on_backend",
        "full_api_name": "_run_circuits_on_backend",
        "api_description": "Run on backend.",
        "api_signature": "_run_circuits_on_backend(backend, circuits, backend_options, noise_config, run_config)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/run_circuits.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "_RequireNow.__init__",
        "api_description": "",
        "api_signature": "__init__(self, tester, feature)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/lazy_tester.py"
    },
    {
        "api_name": "__call__",
        "full_api_name": "_RequireNow.__call__",
        "api_description": "",
        "api_signature": "__call__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/lazy_tester.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "LazyDependencyManager.__init__",
        "api_description": "Args:\n    name: the name of this optional dependency.\n    callback: a callback that is called immediately after the availability of the library is\n        tested with the result.  This will only be called once.\n    install: how to install this optional dependency.  Passed to\n        :class:`.MissingOptionalLibraryError` as the ``pip_install`` parameter.\n    msg: an extra message to include in the error raised if this is required.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/lazy_tester.py"
    },
    {
        "api_name": "_is_available",
        "full_api_name": "LazyDependencyManager._is_available",
        "api_description": "Subclasses of :class:`LazyDependencyManager` should override this method to implement the\nactual test of availability.  This method should return a Boolean, where ``True`` indicates\nthat the dependency was available.  This method will only ever be called once.\n\n:meta public:",
        "api_signature": "_is_available(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/lazy_tester.py"
    },
    {
        "api_name": "__bool__",
        "full_api_name": "LazyDependencyManager.__bool__",
        "api_description": "",
        "api_signature": "__bool__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/lazy_tester.py"
    },
    {
        "api_name": "require_in_call",
        "full_api_name": "LazyDependencyManager.require_in_call",
        "api_description": "",
        "api_signature": "require_in_call(self, feature_or_callable)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/lazy_tester.py"
    },
    {
        "api_name": "require_in_call",
        "full_api_name": "LazyDependencyManager.require_in_call",
        "api_description": "",
        "api_signature": "require_in_call(self, feature_or_callable)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/lazy_tester.py"
    },
    {
        "api_name": "require_in_call",
        "full_api_name": "LazyDependencyManager.require_in_call",
        "api_description": "Create a decorator for callables that requires that the dependency is available when the\ndecorated function or method is called.\n\nArgs:\n    feature_or_callable (str or Callable): the name of the feature that requires these\n        dependencies.  If this function is called directly as a decorator (for example\n        ``@HAS_X.require_in_call`` as opposed to\n        ``@HAS_X.require_in_call(\"my feature\")``), then the feature name will be taken to be\n        the function name, or class and method name as appropriate.\n\nReturns:\n    Callable: a decorator that will make its argument require this dependency before it is\n    called.",
        "api_signature": "require_in_call(self, feature_or_callable)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/lazy_tester.py"
    },
    {
        "api_name": "decorator",
        "full_api_name": "LazyDependencyManager.decorator",
        "api_description": "",
        "api_signature": "decorator(function)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/lazy_tester.py"
    },
    {
        "api_name": "out",
        "full_api_name": "LazyDependencyManager.out",
        "api_description": "",
        "api_signature": "out()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/lazy_tester.py"
    },
    {
        "api_name": "out",
        "full_api_name": "LazyDependencyManager.out",
        "api_description": "",
        "api_signature": "out()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/lazy_tester.py"
    },
    {
        "api_name": "require_in_instance",
        "full_api_name": "LazyDependencyManager.require_in_instance",
        "api_description": "",
        "api_signature": "require_in_instance(self, feature_or_class)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/lazy_tester.py"
    },
    {
        "api_name": "require_in_instance",
        "full_api_name": "LazyDependencyManager.require_in_instance",
        "api_description": "",
        "api_signature": "require_in_instance(self, feature_or_class)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/lazy_tester.py"
    },
    {
        "api_name": "require_in_instance",
        "full_api_name": "LazyDependencyManager.require_in_instance",
        "api_description": "A class decorator that requires the dependency is available when the class is\ninitialised.  This decorator can be used even if the class does not define an ``__init__``\nmethod.\n\nArgs:\n    feature_or_class (str or Type): the name of the feature that requires these\n        dependencies.  If this function is called directly as a decorator (for example\n        ``@HAS_X.require_in_instance`` as opposed to\n        ``@HAS_X.require_in_instance(\"my feature\")``), then the feature name will be taken\n        as the name of the class.\n\nReturns:\n    Callable: a class decorator that ensures that the wrapped feature is present if the\n    class is initialised.",
        "api_signature": "require_in_instance(self, feature_or_class)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/lazy_tester.py"
    },
    {
        "api_name": "decorator",
        "full_api_name": "LazyDependencyManager.decorator",
        "api_description": "",
        "api_signature": "decorator(class_)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/lazy_tester.py"
    },
    {
        "api_name": "require_now",
        "full_api_name": "LazyDependencyManager.require_now",
        "api_description": "Eagerly attempt to import the dependencies in this object, and raise an exception if they\ncannot be imported.\n\nArgs:\n    feature: the name of the feature that is requiring these dependencies.\n\nRaises:\n    MissingOptionalLibraryError: if the dependencies cannot be imported.",
        "api_signature": "require_now(self, feature)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/lazy_tester.py"
    },
    {
        "api_name": "disable_locally",
        "full_api_name": "LazyDependencyManager.disable_locally",
        "api_description": "Create a context, during which the value of the dependency manager will be ``False``.  This\nmeans that within the context, any calls to this object will behave as if the dependency is\nnot available, including raising errors.  It is valid to call this method whether or not the\ndependency has already been evaluated.  This is most useful in tests.",
        "api_signature": "disable_locally(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/lazy_tester.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "LazyImportTester.__init__",
        "api_description": "Args:\n    name_map_or_modules: if a name map, then a dictionary where the keys are modules or\n        packages, and the values are iterables of names to try and import from that\n        module.  It should be valid to write ``from <module> import <name1>, <name2>, ...``.\n        If simply a string or iterable of strings, then it should be valid to write\n        ``import <module>`` for each of them.\n\nRaises:\n    ValueError: if no modules are given.",
        "api_signature": "__init__(self, name_map_or_modules)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/lazy_tester.py"
    },
    {
        "api_name": "_is_available",
        "full_api_name": "LazyImportTester._is_available",
        "api_description": "",
        "api_signature": "_is_available(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/lazy_tester.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "LazySubprocessTester.__init__",
        "api_description": "Args:\n    command: the strings that make up the command to be run.  For example,\n        ``[\"pdflatex\", \"-version\"]``.\n\nRaises:\n    ValueError: if an empty command is given.",
        "api_signature": "__init__(self, command)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/lazy_tester.py"
    },
    {
        "api_name": "_is_available",
        "full_api_name": "LazySubprocessTester._is_available",
        "api_description": "",
        "api_signature": "_is_available(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/lazy_tester.py"
    },
    {
        "api_name": "apply_prefix",
        "full_api_name": "apply_prefix",
        "api_description": "Given a SI unit prefix and value, apply the prefix to convert to\nstandard SI unit.\n\nArgs:\n    value: The number to apply prefix to.\n    unit: String prefix.\n\nReturns:\n    Converted value.\n\n.. note::\n\n    This may induce tiny value error due to internal representation of float object.\n    See https://docs.python.org/3/tutorial/floatingpoint.html for details.\n\nRaises:\n    ValueError: If the ``units`` aren't recognized.",
        "api_signature": "apply_prefix(value, unit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/units.py"
    },
    {
        "api_name": "detach_prefix",
        "full_api_name": "detach_prefix",
        "api_description": "Given a SI unit value, find the most suitable prefix to scale the value.\n\nFor example, the ``value = 1.3e8`` will be converted into a tuple of ``(130.0, \"M\")``,\nwhich represents a scaled value and auxiliary unit that may be used to display the value.\nIn above example, that value might be displayed as ``130 MHz`` (unit is arbitrary here).\n\nExample:\n\n    >>> value, prefix = detach_prefix(1e4)\n    >>> print(f\"{value} {prefix}Hz\")\n    10 kHz\n\nArgs:\n    value: The number to find prefix.\n    decimal: Optional. An arbitrary integer number to represent a precision of the value.\n        If specified, it tries to round the mantissa and adjust the prefix to rounded value.\n        For example, 999_999.91 will become 999.9999 k with ``decimal=4``,\n        while 1.0 M with ``decimal=3`` or less.\n\nReturns:\n    A tuple of scaled value and prefix.\n\n.. note::\n\n    This may induce tiny value error due to internal representation of float object.\n    See https://docs.python.org/3/tutorial/floatingpoint.html for details.\n\nRaises:\n    ValueError: If the ``value`` is out of range.\n    ValueError: If the ``value`` is not real number.",
        "api_signature": "detach_prefix(value, decimal)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/units.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QiskitAlgorithmGlobals.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/algorithm_globals.py"
    },
    {
        "api_name": "random_seed",
        "full_api_name": "QiskitAlgorithmGlobals.random_seed",
        "api_description": "Return random seed.",
        "api_signature": "random_seed(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/algorithm_globals.py"
    },
    {
        "api_name": "random_seed",
        "full_api_name": "QiskitAlgorithmGlobals.random_seed",
        "api_description": "Set random seed.",
        "api_signature": "random_seed(self, seed)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/algorithm_globals.py"
    },
    {
        "api_name": "num_processes",
        "full_api_name": "QiskitAlgorithmGlobals.num_processes",
        "api_description": "Return num processes.",
        "api_signature": "num_processes(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/algorithm_globals.py"
    },
    {
        "api_name": "num_processes",
        "full_api_name": "QiskitAlgorithmGlobals.num_processes",
        "api_description": "Set num processes.\nIf 'None' is passed, it resets to QiskitAlgorithmGlobals.CPU_COUNT",
        "api_signature": "num_processes(self, num_processes)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/algorithm_globals.py"
    },
    {
        "api_name": "random",
        "full_api_name": "QiskitAlgorithmGlobals.random",
        "api_description": "Return a numpy np.random.Generator (default_rng).",
        "api_signature": "random(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/algorithm_globals.py"
    },
    {
        "api_name": "massive",
        "full_api_name": "QiskitAlgorithmGlobals.massive",
        "api_description": "Return massive to allow processing of large matrices or vectors.",
        "api_signature": "massive(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/algorithm_globals.py"
    },
    {
        "api_name": "massive",
        "full_api_name": "QiskitAlgorithmGlobals.massive",
        "api_description": "Set massive to allow processing of large matrices or  vectors.",
        "api_signature": "massive(self, massive)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/algorithm_globals.py"
    },
    {
        "api_name": "local_hardware_info",
        "full_api_name": "local_hardware_info",
        "api_description": "Basic hardware information about the local machine.\n\nGives actual number of CPU's in the machine, even when hyperthreading is\nturned on. CPU count defaults to 1 when true count can't be determined.\n\nReturns:\n    dict: The hardware information.",
        "api_signature": "local_hardware_info()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/multiprocessing.py"
    },
    {
        "api_name": "is_main_process",
        "full_api_name": "is_main_process",
        "api_description": "Checks whether the current process is the main one",
        "api_signature": "is_main_process()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/multiprocessing.py"
    },
    {
        "api_name": "deprecate_func",
        "full_api_name": "deprecate_func",
        "api_description": "Decorator to indicate a function has been deprecated.\n\nIt should be placed beneath other decorators like `@staticmethod` and property decorators.\n\nWhen deprecating a class, set this decorator on its `__init__` function.\n\nArgs:\n    since: The version the deprecation started at. If the deprecation is pending, set\n        the version to when that started; but later, when switching from pending to\n        deprecated, update ``since`` to the new version.\n    additional_msg: Put here any additional information, such as what to use instead.\n        For example, \"Instead, use the function ``new_func`` from the module\n        ``<my_module>.<my_submodule>``, which is similar but uses GPU acceleration.\"\n    pending: Set to ``True`` if the deprecation is still pending.\n    package_name: The PyPI package name, e.g. \"qiskit-nature\".\n    removal_timeline: How soon can this deprecation be removed? Expects a value\n        like \"no sooner than 6 months after the latest release\" or \"in release 9.99\".\n    is_property: If the deprecated function is a `@property`, set this to True so that the\n        generated message correctly describes it as such. (This isn't necessary for\n        property setters, as their docstring is ignored by Python.)\n\nReturns:\n    Callable: The decorated callable.",
        "api_signature": "deprecate_func()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/deprecation.py"
    },
    {
        "api_name": "decorator",
        "full_api_name": "decorator",
        "api_description": "",
        "api_signature": "decorator(func)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/deprecation.py"
    },
    {
        "api_name": "wrapper",
        "full_api_name": "wrapper",
        "api_description": "",
        "api_signature": "wrapper()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/deprecation.py"
    },
    {
        "api_name": "deprecate_arg",
        "full_api_name": "deprecate_arg",
        "api_description": "Decorator to indicate an argument has been deprecated in some way.\n\nThis decorator may be used multiple times on the same function, once per deprecated argument.\nIt should be placed beneath other decorators like ``@staticmethod`` and property decorators.\n\nArgs:\n    name: The name of the deprecated argument.\n    since: The version the deprecation started at. If the deprecation is pending, set\n        the version to when that started; but later, when switching from pending to\n        deprecated, update `since` to the new version.\n    deprecation_description: What is being deprecated? E.g. \"Setting my_func()'s `my_arg`\n        argument to `None`.\" If not set, will default to \"{func_name}'s argument `{name}`\".\n    additional_msg: Put here any additional information, such as what to use instead\n        (if new_alias is not set). For example, \"Instead, use the argument `new_arg`,\n        which is similar but does not impact the circuit's setup.\"\n    pending: Set to `True` if the deprecation is still pending.\n    package_name: The PyPI package name, e.g. \"qiskit-nature\".\n    new_alias: If the arg has simply been renamed, set this to the new name. The decorator will\n        dynamically update the `kwargs` so that when the user sets the old arg, it will be\n        passed in as the `new_alias` arg.\n    predicate: Only log the runtime warning if the predicate returns True. This is useful to\n        deprecate certain values or types for an argument, e.g.\n        `lambda my_arg: isinstance(my_arg, dict)`. Regardless of if a predicate is set, the\n        runtime warning will only log when the user specifies the argument.\n    removal_timeline: How soon can this deprecation be removed? Expects a value\n        like \"no sooner than 6 months after the latest release\" or \"in release 9.99\".\n\nReturns:\n    Callable: The decorated callable.",
        "api_signature": "deprecate_arg(name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/deprecation.py"
    },
    {
        "api_name": "decorator",
        "full_api_name": "decorator",
        "api_description": "",
        "api_signature": "decorator(func)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/deprecation.py"
    },
    {
        "api_name": "wrapper",
        "full_api_name": "wrapper",
        "api_description": "",
        "api_signature": "wrapper()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/deprecation.py"
    },
    {
        "api_name": "deprecate_arguments",
        "full_api_name": "deprecate_arguments",
        "api_description": "Deprecated. Instead, use `@deprecate_arg`.\n\nArgs:\n    kwarg_map: A dictionary of the old argument name to the new name.\n    category: Usually either DeprecationWarning or PendingDeprecationWarning.\n    since: The version the deprecation started at. Only Optional for backwards\n        compatibility - this should always be set. If the deprecation is pending, set\n        the version to when that started; but later, when switching from pending to\n        deprecated, update `since` to the new version.\n\nReturns:\n    Callable: The decorated callable.",
        "api_signature": "deprecate_arguments(kwarg_map, category)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/deprecation.py"
    },
    {
        "api_name": "decorator",
        "full_api_name": "decorator",
        "api_description": "",
        "api_signature": "decorator(func)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/deprecation.py"
    },
    {
        "api_name": "wrapper",
        "full_api_name": "wrapper",
        "api_description": "",
        "api_signature": "wrapper()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/deprecation.py"
    },
    {
        "api_name": "deprecate_function",
        "full_api_name": "deprecate_function",
        "api_description": "Deprecated. Instead, use `@deprecate_func`.\n\nArgs:\n    msg: Warning message to emit.\n    stacklevel: The warning stacklevel to use, defaults to 2.\n    category: Usually either DeprecationWarning or PendingDeprecationWarning.\n    since: The version the deprecation started at. Only Optional for backwards\n        compatibility - this should always be set. If the deprecation is pending, set\n        the version to when that started; but later, when switching from pending to\n        deprecated, update `since` to the new version.\n\nReturns:\n    Callable: The decorated, deprecated callable.",
        "api_signature": "deprecate_function(msg, stacklevel, category)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/deprecation.py"
    },
    {
        "api_name": "decorator",
        "full_api_name": "decorator",
        "api_description": "",
        "api_signature": "decorator(func)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/deprecation.py"
    },
    {
        "api_name": "wrapper",
        "full_api_name": "wrapper",
        "api_description": "",
        "api_signature": "wrapper()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/deprecation.py"
    },
    {
        "api_name": "_maybe_warn_and_rename_kwarg",
        "full_api_name": "_maybe_warn_and_rename_kwarg",
        "api_description": "",
        "api_signature": "_maybe_warn_and_rename_kwarg(args, kwargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/deprecation.py"
    },
    {
        "api_name": "_write_deprecation_msg",
        "full_api_name": "_write_deprecation_msg",
        "api_description": "",
        "api_signature": "_write_deprecation_msg()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/deprecation.py"
    },
    {
        "api_name": "add_deprecation_to_docstring",
        "full_api_name": "add_deprecation_to_docstring",
        "api_description": "Dynamically insert the deprecation message into ``func``'s docstring.\n\nArgs:\n    func: The function to modify.\n    msg: The full deprecation message.\n    since: The version the deprecation started at.\n    pending: Is the deprecation still pending?",
        "api_signature": "add_deprecation_to_docstring(func, msg)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/deprecation.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ProviderCheck.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/backend_utils.py"
    },
    {
        "api_name": "_get_backend_interface_version",
        "full_api_name": "_get_backend_interface_version",
        "api_description": "Get the backend version int.",
        "api_signature": "_get_backend_interface_version(backend)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/backend_utils.py"
    },
    {
        "api_name": "_get_backend_provider",
        "full_api_name": "_get_backend_provider",
        "api_description": "",
        "api_signature": "_get_backend_provider(backend)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/backend_utils.py"
    },
    {
        "api_name": "has_ibmq",
        "full_api_name": "has_ibmq",
        "api_description": "Check if IBMQ is installed.",
        "api_signature": "has_ibmq()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/backend_utils.py"
    },
    {
        "api_name": "has_aer",
        "full_api_name": "has_aer",
        "api_description": "Check if Aer is installed.",
        "api_signature": "has_aer()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/backend_utils.py"
    },
    {
        "api_name": "is_aer_provider",
        "full_api_name": "is_aer_provider",
        "api_description": "Detect whether or not backend is from Aer provider.\n\nArgs:\n    backend (Backend): backend instance\nReturns:\n    bool: True is AerProvider",
        "api_signature": "is_aer_provider(backend)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/backend_utils.py"
    },
    {
        "api_name": "is_basicaer_provider",
        "full_api_name": "is_basicaer_provider",
        "api_description": "Detect whether or not backend is from BasicAer provider.\n\nArgs:\n    backend (Backend): backend instance\nReturns:\n    bool: True is BasicAer",
        "api_signature": "is_basicaer_provider(backend)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/backend_utils.py"
    },
    {
        "api_name": "is_ibmq_provider",
        "full_api_name": "is_ibmq_provider",
        "api_description": "Detect whether or not backend is from IBMQ provider.\n\nArgs:\n    backend (Backend): backend instance\nReturns:\n    bool: True is IBMQ",
        "api_signature": "is_ibmq_provider(backend)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/backend_utils.py"
    },
    {
        "api_name": "is_aer_statevector_backend",
        "full_api_name": "is_aer_statevector_backend",
        "api_description": "Return True if backend object is statevector and from Aer provider.\n\nArgs:\n    backend (Backend): backend instance\nReturns:\n    bool: True is statevector",
        "api_signature": "is_aer_statevector_backend(backend)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/backend_utils.py"
    },
    {
        "api_name": "is_statevector_backend",
        "full_api_name": "is_statevector_backend",
        "api_description": "Return True if backend object is statevector.\n\nArgs:\n    backend (Backend): backend instance\nReturns:\n    bool: True is statevector",
        "api_signature": "is_statevector_backend(backend)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/backend_utils.py"
    },
    {
        "api_name": "is_simulator_backend",
        "full_api_name": "is_simulator_backend",
        "api_description": "Return True if backend is a simulator.\n\nArgs:\n    backend (Backend): backend instance\nReturns:\n    bool: True is a simulator",
        "api_signature": "is_simulator_backend(backend)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/backend_utils.py"
    },
    {
        "api_name": "is_local_backend",
        "full_api_name": "is_local_backend",
        "api_description": "Return True if backend is a local backend.\n\nArgs:\n    backend (Backend): backend instance\nReturns:\n    bool: True is a local backend",
        "api_signature": "is_local_backend(backend)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/backend_utils.py"
    },
    {
        "api_name": "is_aer_qasm",
        "full_api_name": "is_aer_qasm",
        "api_description": "Return True if backend is Aer Qasm simulator\nArgs:\n    backend (Backend): backend instance\n\nReturns:\n    bool: True is Aer Qasm simulator",
        "api_signature": "is_aer_qasm(backend)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/backend_utils.py"
    },
    {
        "api_name": "support_backend_options",
        "full_api_name": "support_backend_options",
        "api_description": "Return True if backend supports backend_options\nArgs:\n    backend (Backend): backend instance\n\nReturns:\n    bool: True is support backend_options",
        "api_signature": "support_backend_options(backend)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/backend_utils.py"
    },
    {
        "api_name": "summarize_circuits",
        "full_api_name": "summarize_circuits",
        "api_description": "Summarize circuits based on QuantumCircuit, and five metrics are summarized.\n    - Number of qubits\n    - Number of classical bits\n    - Number of operations\n    - Depth of circuits\n    - Counts of different gate operations\n\nThe average statistic of the first four is provided if multiple circuits are provided.\n\nArgs:\n    circuits (QuantumCircuit or [QuantumCircuit]): the to-be-summarized circuits\n\nReturns:\n    str: a formatted string records the summary",
        "api_signature": "summarize_circuits(circuits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/circuit_utils.py"
    },
    {
        "api_name": "get_measured_qubits",
        "full_api_name": "get_measured_qubits",
        "api_description": "Deprecated: Retrieve the measured qubits from transpiled circuits.\n\nArgs:\n    transpiled_circuits: a list of transpiled circuits\n\nReturns:\n    The used and sorted qubit index\n    Key is qubit index str connected by '_',\n          value is the experiment index. {str: list[int]}\nRaises:\n    QiskitError: invalid qubit mapping",
        "api_signature": "get_measured_qubits(transpiled_circuits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/measurement_error_mitigation.py"
    },
    {
        "api_name": "get_measured_qubits_from_qobj",
        "full_api_name": "get_measured_qubits_from_qobj",
        "api_description": "Deprecated: Retrieve the measured qubits from transpiled circuits.\n\nArgs:\n    qobj: qobj\n\nReturns:\n    the used and sorted qubit index\n    key is qubit index str connected by '_',\n          value is the experiment index. {str: list[int]}\n Raises:\n    QiskitError: invalid qubit mapping",
        "api_signature": "get_measured_qubits_from_qobj(qobj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/measurement_error_mitigation.py"
    },
    {
        "api_name": "build_measurement_error_mitigation_circuits",
        "full_api_name": "build_measurement_error_mitigation_circuits",
        "api_description": "Deprecated: Build measurement error mitigation circuits\nArgs:\n    qubit_list: list of ordered qubits used in the algorithm\n    fitter_cls: CompleteMeasFitter or TensoredMeasFitter\n    backend: backend instance\n    backend_config: configuration for backend\n    compile_config: configuration for compilation\n    mit_pattern: Qubits on which to perform the\n        measurement correction, divided to groups according to tensors.\n        If `None` and `qr` is given then assumed to be performed over the entire\n        `qr` as one group (default `None`).\n\nReturns:\n    the circuit\n    the state labels for build MeasFitter\n    the labels of the calibration circuits\nRaises:\n    QiskitError: when the fitter_cls is not recognizable.",
        "api_signature": "build_measurement_error_mitigation_circuits(qubit_list, fitter_cls, backend, backend_config, compile_config, mit_pattern)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/measurement_error_mitigation.py"
    },
    {
        "api_name": "build_measurement_error_mitigation_qobj",
        "full_api_name": "build_measurement_error_mitigation_qobj",
        "api_description": "Args:\n    qubit_list: list of ordered qubits used in the algorithm\n    fitter_cls: CompleteMeasFitter or TensoredMeasFitter\n    backend: backend instance\n    backend_config: configuration for backend\n    compile_config: configuration for compilation\n    run_config: configuration for running a circuit\n    mit_pattern: Qubits on which to perform the\n        measurement correction, divided to groups according to tensors.\n        If `None` and `qr` is given then assumed to be performed over the entire\n        `qr` as one group (default `None`).\n\nReturns:\n    the Qobj with calibration circuits at the beginning\n    the state labels for build MeasFitter\n    the labels of the calibration circuits\n\nRaises:\n    QiskitError: when the fitter_cls is not recognizable.\n    MissingOptionalLibraryError: Qiskit-Ignis not installed",
        "api_signature": "build_measurement_error_mitigation_qobj(qubit_list, fitter_cls, backend, backend_config, compile_config, run_config, mit_pattern)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/measurement_error_mitigation.py"
    },
    {
        "api_name": "type_from_class",
        "full_api_name": "_MeasFitterType.type_from_class",
        "api_description": "Returns fitter type from class",
        "api_signature": "type_from_class(meas_class)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/quantum_instance.py"
    },
    {
        "api_name": "type_from_instance",
        "full_api_name": "_MeasFitterType.type_from_instance",
        "api_description": "Returns fitter type from instance",
        "api_signature": "type_from_instance(meas_instance)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/quantum_instance.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QuantumInstance.__init__",
        "api_description": "Quantum Instance holds a Qiskit Terra backend as well as configuration for circuit\ntranspilation and execution. When provided to an Aqua algorithm the algorithm will\nexecute the circuits it needs to run using the instance.\n\nArgs:\n    backend (Backend): Instance of selected backend\n    shots: Number of repetitions of each circuit, for sampling. If None, the shots are\n        extracted from the backend. If the backend has none set, the default is 1024.\n    seed_simulator: Random seed for simulators\n    basis_gates: List of basis gate names supported by the\n        target. Defaults to basis gates of the backend.\n    coupling_map (Optional[Union['CouplingMap', List[List]]]):\n        Coupling map (perhaps custom) to target in mapping\n    initial_layout (Optional[Union['Layout', Dict, List]]):\n        Initial layout of qubits in mapping\n    pass_manager (Optional['PassManager']): Pass manager to handle how to compile the circuits.\n        To run only this pass manager and not the ``bound_pass_manager``, call the\n        :meth:`~qiskit.utils.QuantumInstance.transpile` method with the argument\n        ``pass_manager=quantum_instance.unbound_pass_manager``.\n    bound_pass_manager (Optional['PassManager']): A second pass manager to apply on bound\n        circuits only, that is, circuits without any free parameters. To only run this pass\n        manager and not ``pass_manager`` call the\n        :meth:`~qiskit.utils.QuantumInstance.transpile` method with the argument\n        ``pass_manager=quantum_instance.bound_pass_manager``.\n        manager should also be run.\n    seed_transpiler: The random seed for circuit mapper\n    optimization_level: How much optimization to perform on the circuits.\n        Higher levels generate more optimized circuits, at the expense of longer\n        transpilation time.\n    backend_options: All running options for backend, please refer\n        to the provider of the backend for information as to what options it supports.\n    noise_model (Optional['NoiseModel']): noise model for simulator\n    timeout: Seconds to wait for job. If None, wait indefinitely.\n    wait: Seconds between queries for job result\n    skip_qobj_validation: Bypass Qobj validation to decrease circuit\n        processing time during submission to backend.\n    measurement_error_mitigation_cls: The approach to mitigate\n        measurement errors. The classes :class:`~qiskit.utils.mitigation.CompleteMeasFitter`\n        or :class:`~qiskit.utils.mitigation.TensoredMeasFitter` from the\n        :mod:`qiskit.utils.mitigation` module can be used here as exact values, not\n        instances. ``TensoredMeasFitter`` doesn't support the ``subset_fitter`` method.\n    cals_matrix_refresh_period: How often to refresh the calibration\n        matrix in measurement mitigation. in minutes\n    measurement_error_mitigation_shots: The number of shots number for\n        building calibration matrix. If None, the main `shots` parameter value is used.\n    job_callback: Optional user supplied callback which can be used\n        to monitor job progress as jobs are submitted for processing by an Aqua algorithm.\n        The callback is provided the following arguments: `job_id, job_status,\n        queue_position, job`\n    mit_pattern: Qubits on which to perform the TensoredMeasFitter\n        measurement correction, divided to groups according to tensors.\n        If `None` and `qr` is given then assumed to be performed over the entire\n        `qr` as one group (default `None`).\n    max_job_retries(int): positive non-zero number of trials for the job set (-1 for\n        infinite trials) (default: 50)\n\nRaises:\n    QiskitError: the shots exceeds the maximum number of shots\n    QiskitError: set noise model but the backend does not support that\n    QiskitError: set backend_options but the backend does not support that",
        "api_signature": "__init__(self, backend, shots, seed_simulator, basis_gates, coupling_map, initial_layout, pass_manager, bound_pass_manager, seed_transpiler, optimization_level, backend_options, noise_model, timeout, wait, skip_qobj_validation, measurement_error_mitigation_cls, cals_matrix_refresh_period, measurement_error_mitigation_shots, job_callback, mit_pattern, max_job_retries)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/quantum_instance.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "QuantumInstance.__str__",
        "api_description": "Overload string.\n\nReturns:\n    str: the info of the object.",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/quantum_instance.py"
    },
    {
        "api_name": "unbound_pass_manager",
        "full_api_name": "QuantumInstance.unbound_pass_manager",
        "api_description": "Return the pass manager for designated for unbound circuits.\n\nReturns:\n    Optional['PassManager']: The pass manager for unbound circuits, if it has been set.",
        "api_signature": "unbound_pass_manager(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/quantum_instance.py"
    },
    {
        "api_name": "bound_pass_manager",
        "full_api_name": "QuantumInstance.bound_pass_manager",
        "api_description": "Return the pass manager for designated for bound circuits.\n\nReturns:\n    Optional['PassManager']: The pass manager for bound circuits, if it has been set.",
        "api_signature": "bound_pass_manager(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/quantum_instance.py"
    },
    {
        "api_name": "transpile",
        "full_api_name": "QuantumInstance.transpile",
        "api_description": "A wrapper to transpile circuits to allow algorithm access the transpiled circuits.\n\nArgs:\n    circuits (Union['QuantumCircuit', List['QuantumCircuit']]): circuits to transpile\n    pass_manager (Optional['PassManager']): A pass manager to transpile the circuits. If\n        none is given, but either ``pass_manager`` or ``bound_pass_manager`` has been set\n        in the initializer, these are run. If none has been provided there either, the\n        backend and compile configs from the initializer are used.\n\nReturns:\n    List['QuantumCircuit']: The transpiled circuits, it is always a list even though\n        the length is one.",
        "api_signature": "transpile(self, circuits, pass_manager)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/quantum_instance.py"
    },
    {
        "api_name": "assemble",
        "full_api_name": "QuantumInstance.assemble",
        "api_description": "assemble circuits",
        "api_signature": "assemble(self, circuits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/quantum_instance.py"
    },
    {
        "api_name": "execute",
        "full_api_name": "QuantumInstance.execute",
        "api_description": "A wrapper to interface with quantum backend.\n\nArgs:\n    circuits (Union['QuantumCircuit', List['QuantumCircuit']]):\n                circuits to execute\n    had_transpiled: whether or not circuits had been transpiled\n\nRaises:\n    QiskitError: Invalid error mitigation fitter class\n    QiskitError: TensoredMeasFitter class doesn't support subset fitter\n    MissingOptionalLibraryError: Ignis not installed\n\n\nReturns:\n    Result: result object\n\nTODO: Maybe we can combine the circuits for the main ones and calibration circuits before\n      assembling to the qobj.",
        "api_signature": "execute(self, circuits, had_transpiled)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/quantum_instance.py"
    },
    {
        "api_name": "_find_save_state",
        "full_api_name": "QuantumInstance._find_save_state",
        "api_description": "",
        "api_signature": "_find_save_state(data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/quantum_instance.py"
    },
    {
        "api_name": "set_config",
        "full_api_name": "QuantumInstance.set_config",
        "api_description": "Set configurations for the quantum instance.",
        "api_signature": "set_config(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/quantum_instance.py"
    },
    {
        "api_name": "time_taken",
        "full_api_name": "QuantumInstance.time_taken",
        "api_description": "Accumulated time taken for execution.",
        "api_signature": "time_taken(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/quantum_instance.py"
    },
    {
        "api_name": "reset_execution_results",
        "full_api_name": "QuantumInstance.reset_execution_results",
        "api_description": "Reset execution results",
        "api_signature": "reset_execution_results(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/quantum_instance.py"
    },
    {
        "api_name": "qjob_config",
        "full_api_name": "QuantumInstance.qjob_config",
        "api_description": "Getter of qjob_config.",
        "api_signature": "qjob_config(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/quantum_instance.py"
    },
    {
        "api_name": "backend_config",
        "full_api_name": "QuantumInstance.backend_config",
        "api_description": "Getter of backend_config.",
        "api_signature": "backend_config(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/quantum_instance.py"
    },
    {
        "api_name": "compile_config",
        "full_api_name": "QuantumInstance.compile_config",
        "api_description": "Getter of compile_config.",
        "api_signature": "compile_config(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/quantum_instance.py"
    },
    {
        "api_name": "run_config",
        "full_api_name": "QuantumInstance.run_config",
        "api_description": "Getter of run_config.",
        "api_signature": "run_config(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/quantum_instance.py"
    },
    {
        "api_name": "noise_config",
        "full_api_name": "QuantumInstance.noise_config",
        "api_description": "Getter of noise_config.",
        "api_signature": "noise_config(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/quantum_instance.py"
    },
    {
        "api_name": "backend_options",
        "full_api_name": "QuantumInstance.backend_options",
        "api_description": "Getter of backend_options.",
        "api_signature": "backend_options(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/quantum_instance.py"
    },
    {
        "api_name": "circuit_summary",
        "full_api_name": "QuantumInstance.circuit_summary",
        "api_description": "Getter of circuit summary.",
        "api_signature": "circuit_summary(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/quantum_instance.py"
    },
    {
        "api_name": "circuit_summary",
        "full_api_name": "QuantumInstance.circuit_summary",
        "api_description": "sets circuit summary",
        "api_signature": "circuit_summary(self, new_value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/quantum_instance.py"
    },
    {
        "api_name": "max_job_retries",
        "full_api_name": "QuantumInstance.max_job_retries",
        "api_description": "Getter of max tries",
        "api_signature": "max_job_retries(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/quantum_instance.py"
    },
    {
        "api_name": "max_job_retries",
        "full_api_name": "QuantumInstance.max_job_retries",
        "api_description": "Sets the maximum tries",
        "api_signature": "max_job_retries(self, new_value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/quantum_instance.py"
    },
    {
        "api_name": "measurement_error_mitigation_cls",
        "full_api_name": "QuantumInstance.measurement_error_mitigation_cls",
        "api_description": "returns measurement error mitigation cls",
        "api_signature": "measurement_error_mitigation_cls(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/quantum_instance.py"
    },
    {
        "api_name": "measurement_error_mitigation_cls",
        "full_api_name": "QuantumInstance.measurement_error_mitigation_cls",
        "api_description": "sets measurement error mitigation cls",
        "api_signature": "measurement_error_mitigation_cls(self, new_value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/quantum_instance.py"
    },
    {
        "api_name": "cals_matrix_refresh_period",
        "full_api_name": "QuantumInstance.cals_matrix_refresh_period",
        "api_description": "returns matrix refresh period",
        "api_signature": "cals_matrix_refresh_period(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/quantum_instance.py"
    },
    {
        "api_name": "cals_matrix_refresh_period",
        "full_api_name": "QuantumInstance.cals_matrix_refresh_period",
        "api_description": "sets matrix refresh period",
        "api_signature": "cals_matrix_refresh_period(self, new_value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/quantum_instance.py"
    },
    {
        "api_name": "measurement_error_mitigation_shots",
        "full_api_name": "QuantumInstance.measurement_error_mitigation_shots",
        "api_description": "returns measurement error mitigation shots",
        "api_signature": "measurement_error_mitigation_shots(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/quantum_instance.py"
    },
    {
        "api_name": "measurement_error_mitigation_shots",
        "full_api_name": "QuantumInstance.measurement_error_mitigation_shots",
        "api_description": "sets measurement error mitigation shots",
        "api_signature": "measurement_error_mitigation_shots(self, new_value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/quantum_instance.py"
    },
    {
        "api_name": "backend",
        "full_api_name": "QuantumInstance.backend",
        "api_description": "Return Backend backend object.",
        "api_signature": "backend(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/quantum_instance.py"
    },
    {
        "api_name": "backend_name",
        "full_api_name": "QuantumInstance.backend_name",
        "api_description": "Return backend name.",
        "api_signature": "backend_name(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/quantum_instance.py"
    },
    {
        "api_name": "is_statevector",
        "full_api_name": "QuantumInstance.is_statevector",
        "api_description": "Return True if backend is a statevector-type simulator.",
        "api_signature": "is_statevector(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/quantum_instance.py"
    },
    {
        "api_name": "is_simulator",
        "full_api_name": "QuantumInstance.is_simulator",
        "api_description": "Return True if backend is a simulator.",
        "api_signature": "is_simulator(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/quantum_instance.py"
    },
    {
        "api_name": "is_local",
        "full_api_name": "QuantumInstance.is_local",
        "api_description": "Return True if backend is a local backend.",
        "api_signature": "is_local(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/quantum_instance.py"
    },
    {
        "api_name": "skip_qobj_validation",
        "full_api_name": "QuantumInstance.skip_qobj_validation",
        "api_description": "checks if skip qobj validation",
        "api_signature": "skip_qobj_validation(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/quantum_instance.py"
    },
    {
        "api_name": "skip_qobj_validation",
        "full_api_name": "QuantumInstance.skip_qobj_validation",
        "api_description": "sets skip qobj validation flag",
        "api_signature": "skip_qobj_validation(self, new_value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/quantum_instance.py"
    },
    {
        "api_name": "maybe_refresh_cals_matrix",
        "full_api_name": "QuantumInstance.maybe_refresh_cals_matrix",
        "api_description": "Calculate the time difference from the query of last time.\n\nArgs:\n    timestamp: timestamp\n\nReturns:\n    Whether or not refresh the cals_matrix",
        "api_signature": "maybe_refresh_cals_matrix(self, timestamp)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/quantum_instance.py"
    },
    {
        "api_name": "cals_matrix",
        "full_api_name": "QuantumInstance.cals_matrix",
        "api_description": "Get the stored calibration matrices and its timestamp.\n\nArgs:\n    qubit_index: the qubit index of corresponding calibration matrix.\n                 If None, return all stored calibration matrices.\n\nReturns:\n    The calibration matrix and the creation timestamp if qubit_index\n    is not None otherwise, return all matrices and their timestamp\n    in a dictionary.",
        "api_signature": "cals_matrix(self, qubit_index)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/quantum_instance.py"
    },
    {
        "api_name": "get_entangler_map",
        "full_api_name": "get_entangler_map",
        "api_description": "Utility method to get an entangler map among qubits.\n\nArgs:\n    map_type (str): 'full' entangles each qubit with all the subsequent ones\n                    'linear' entangles each qubit with the next\n                    'sca' (shifted circular alternating entanglement) is a\n                    circular entanglement where the 'long' entanglement is\n                    shifted by one position every block and every block the\n                    role or control/target qubits alternate\n    num_qubits (int): Number of qubits for which the map is needed\n    offset (int): Some map_types (e.g. 'sca') can shift the gates in\n                  the entangler map by the specified integer offset.\n\nReturns:\n    list: A map of qubit index to an array of indexes to which this should be entangled\n\nRaises:\n    ValueError: if map_type is not valid.",
        "api_signature": "get_entangler_map(map_type, num_qubits, offset)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/entangler_map.py"
    },
    {
        "api_name": "validate_entangler_map",
        "full_api_name": "validate_entangler_map",
        "api_description": "Validate a user supplied entangler map and converts entries to ints.\n\nArgs:\n    entangler_map (list[list]) : An entangler map, keys are source qubit index (int),\n                            value is array\n                            of target qubit index(es) (int)\n    num_qubits (int) : Number of qubits\n    allow_double_entanglement (bool): If we allow in two qubits can be entangled each other\n\nReturns:\n    list: Validated/converted map\n\nRaises:\n    TypeError: entangler map is not list type or list of list\n    ValueError: the index of entangler map is out of range\n    ValueError: the qubits are cross-entangled.",
        "api_signature": "validate_entangler_map(entangler_map, num_qubits, allow_double_entanglement)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/entangler_map.py"
    },
    {
        "api_name": "name_args",
        "full_api_name": "name_args",
        "api_description": "Decorator to convert unnamed arguments to named ones.\n\nCan be used to deprecate old signatures of a function, e.g.\n\n.. code-block::\n\n    old_f(a: TypeA, b: TypeB, c: TypeC)\n    new_f(a: TypeA, d: TypeD, b: TypeB=None, c: TypeC=None)\n\nThen, to support the old signature this decorator can be used as\n\n.. code-block::\n\n    @name_args([\n        ('a'),  # stays the same\n        ('d', {TypeB: 'b'}),  # if arg is of type TypeB, call if 'b' else 'd'\n        ('b', {TypeC: 'c'})\n    ])\n    def new_f(a: TypeA, d: TypeD, b: TypeB=None, c: TypeC=None):\n        if b is not None:\n            # raise warning, this is deprecated!\n        if c is not None:\n            # raise warning, this is deprecated!",
        "api_signature": "name_args(mapping, skip)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/name_unnamed_args.py"
    },
    {
        "api_name": "decorator",
        "full_api_name": "decorator",
        "api_description": "",
        "api_signature": "decorator(func)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/name_unnamed_args.py"
    },
    {
        "api_name": "wrapper",
        "full_api_name": "wrapper",
        "api_description": "",
        "api_signature": "wrapper()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/name_unnamed_args.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CompleteMeasFitter.__init__",
        "api_description": "Initialize a measurement calibration matrix from the results of running\nthe circuits returned by `measurement_calibration_circuits`\n\nA wrapper for the tensored fitter\n\n.. warning::\n\n    This class is not a public API. The internals are not stable and will\n    likely change. It is used solely for the\n    ``measurement_error_mitigation_cls`` kwarg of the\n    :class:`~qiskit.utils.QuantumInstance` class's constructor (as\n    a class not an instance). Anything outside of that usage does\n    not have the normal user-facing API stability.\n\nArgs:\n    results: the results of running the measurement calibration\n        circuits. If this is `None` the user will set a calibration\n        matrix later.\n    state_labels: list of calibration state labels\n        returned from `measurement_calibration_circuits`.\n        The output matrix will obey this ordering.\n    qubit_list: List of the qubits (for reference and if the\n        subset is needed). If `None`, the qubit_list will be\n        created according to the length of state_labels[0].\n    circlabel: if the qubits were labeled.",
        "api_signature": "__init__(self, results, state_labels, qubit_list, circlabel)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/mitigation/fitters.py"
    },
    {
        "api_name": "cal_matrix",
        "full_api_name": "CompleteMeasFitter.cal_matrix",
        "api_description": "Return cal_matrix.",
        "api_signature": "cal_matrix(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/mitigation/fitters.py"
    },
    {
        "api_name": "cal_matrix",
        "full_api_name": "CompleteMeasFitter.cal_matrix",
        "api_description": "set cal_matrix.",
        "api_signature": "cal_matrix(self, new_cal_matrix)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/mitigation/fitters.py"
    },
    {
        "api_name": "state_labels",
        "full_api_name": "CompleteMeasFitter.state_labels",
        "api_description": "Return state_labels.",
        "api_signature": "state_labels(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/mitigation/fitters.py"
    },
    {
        "api_name": "qubit_list",
        "full_api_name": "CompleteMeasFitter.qubit_list",
        "api_description": "Return list of qubits.",
        "api_signature": "qubit_list(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/mitigation/fitters.py"
    },
    {
        "api_name": "state_labels",
        "full_api_name": "CompleteMeasFitter.state_labels",
        "api_description": "Set state label.",
        "api_signature": "state_labels(self, new_state_labels)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/mitigation/fitters.py"
    },
    {
        "api_name": "filter",
        "full_api_name": "CompleteMeasFitter.filter",
        "api_description": "Return a measurement filter using the cal matrix.",
        "api_signature": "filter(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/mitigation/fitters.py"
    },
    {
        "api_name": "add_data",
        "full_api_name": "CompleteMeasFitter.add_data",
        "api_description": "Add measurement calibration data\n\nArgs:\n    new_results (list or qiskit.result.Result): a single result or list\n        of result objects.\n    rebuild_cal_matrix (bool): rebuild the calibration matrix",
        "api_signature": "add_data(self, new_results, rebuild_cal_matrix)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/mitigation/fitters.py"
    },
    {
        "api_name": "subset_fitter",
        "full_api_name": "CompleteMeasFitter.subset_fitter",
        "api_description": "Return a fitter object that is a subset of the qubits in the original\nlist.\n\nArgs:\n    qubit_sublist (list): must be a subset of qubit_list\n\nReturns:\n    CompleteMeasFitter: A new fitter that has the calibration for a\n        subset of qubits\n\nRaises:\n    QiskitError: If the calibration matrix is not initialized",
        "api_signature": "subset_fitter(self, qubit_sublist)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/mitigation/fitters.py"
    },
    {
        "api_name": "readout_fidelity",
        "full_api_name": "CompleteMeasFitter.readout_fidelity",
        "api_description": "Based on the results, output the readout fidelity which is the\nnormalized trace of the calibration matrix\n\nArgs:\n    label_list (bool): If `None`, returns the average assignment fidelity\n        of a single state. Otherwise it returns the assignment fidelity\n        to be in any one of these states averaged over the second\n        index.\n\nReturns:\n    numpy.array: readout fidelity (assignment fidelity)\n\nAdditional Information:\n    The on-diagonal elements of the calibration matrix are the\n    probabilities of measuring state 'x' given preparation of state\n    'x' and so the normalized trace is the average assignment fidelity",
        "api_signature": "readout_fidelity(self, label_list)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/mitigation/fitters.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "TensoredMeasFitter.__init__",
        "api_description": "Initialize a measurement calibration matrix from the results of running\nthe circuits returned by `measurement_calibration_circuits`.\n\n.. warning::\n\n    This class is not a public API. The internals are not stable and will\n    likely change. It is used solely for the\n    ``measurement_error_mitigation_cls`` kwarg of the\n    :class:`~qiskit.utils.QuantumInstance` class's constructor (as\n    a class not an instance). Anything outside of that usage does\n    not have the normal user-facing API stability.\n\nArgs:\n    results: the results of running the measurement calibration\n        circuits. If this is `None`, the user will set calibration\n        matrices later.\n\n    mit_pattern: qubits to perform the\n        measurement correction on, divided to groups according to\n        tensors\n\n    substate_labels_list: for each\n        calibration matrix, the labels of its rows and columns.\n        If `None`, the labels are ordered lexicographically\n\n    circlabel: if the qubits were labeled\n\nRaises:\n    ValueError: if the mit_pattern doesn't match the\n        substate_labels_list",
        "api_signature": "__init__(self, results, mit_pattern, substate_labels_list, circlabel)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/mitigation/fitters.py"
    },
    {
        "api_name": "cal_matrices",
        "full_api_name": "TensoredMeasFitter.cal_matrices",
        "api_description": "Return cal_matrices.",
        "api_signature": "cal_matrices(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/mitigation/fitters.py"
    },
    {
        "api_name": "cal_matrices",
        "full_api_name": "TensoredMeasFitter.cal_matrices",
        "api_description": "Set _cal_matrices.",
        "api_signature": "cal_matrices(self, new_cal_matrices)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/mitigation/fitters.py"
    },
    {
        "api_name": "substate_labels_list",
        "full_api_name": "TensoredMeasFitter.substate_labels_list",
        "api_description": "Return _substate_labels_list.",
        "api_signature": "substate_labels_list(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/mitigation/fitters.py"
    },
    {
        "api_name": "filter",
        "full_api_name": "TensoredMeasFitter.filter",
        "api_description": "Return a measurement filter using the cal matrices.",
        "api_signature": "filter(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/mitigation/fitters.py"
    },
    {
        "api_name": "nqubits",
        "full_api_name": "TensoredMeasFitter.nqubits",
        "api_description": "Return _qubit_list_sizes.",
        "api_signature": "nqubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/mitigation/fitters.py"
    },
    {
        "api_name": "add_data",
        "full_api_name": "TensoredMeasFitter.add_data",
        "api_description": "Add measurement calibration data\n\nArgs:\n    new_results (list or qiskit.result.Result): a single result or list\n        of Result objects.\n    rebuild_cal_matrix (bool): rebuild the calibration matrix",
        "api_signature": "add_data(self, new_results, rebuild_cal_matrix)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/mitigation/fitters.py"
    },
    {
        "api_name": "readout_fidelity",
        "full_api_name": "TensoredMeasFitter.readout_fidelity",
        "api_description": "Based on the results, output the readout fidelity, which is the average\nof the diagonal entries in the calibration matrices.\n\nArgs:\n    cal_index(integer): readout fidelity for this index in _cal_matrices\n    label_list (list):  Returns the average fidelity over of the groups\n        f states. In the form of a list of lists of states. If `None`,\n        then each state used in the construction of the calibration\n        matrices forms a group of size 1\n\nReturns:\n    numpy.array: The readout fidelity (assignment fidelity)\n\nRaises:\n    QiskitError: If the calibration matrix has not been set for the\n        object.\n\nAdditional Information:\n    The on-diagonal elements of the calibration matrices are the\n    probabilities of measuring state 'x' given preparation of state\n    'x'.",
        "api_signature": "readout_fidelity(self, cal_index, label_list)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/mitigation/fitters.py"
    },
    {
        "api_name": "_build_calibration_matrices",
        "full_api_name": "TensoredMeasFitter._build_calibration_matrices",
        "api_description": "Build the measurement calibration matrices from the results of running\nthe circuits returned by `measurement_calibration`.",
        "api_signature": "_build_calibration_matrices(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/mitigation/fitters.py"
    },
    {
        "api_name": "subset_fitter",
        "full_api_name": "TensoredMeasFitter.subset_fitter",
        "api_description": "Return a fitter object that is a subset of the qubits in the original list.\n\nThis is only a partial implementation of the ``subset_fitter`` method since only\nmitigation patterns of length 1 are supported. This corresponds to patterns of the\nform ``[[0], [1], [2], ...]``. Note however, that such patterns are a good first\napproximation to mitigate readout errors on large quantum circuits.\n\nArgs:\n    qubit_sublist (list): must be a subset of qubit_list\n\nReturns:\n    TensoredMeasFitter: A new fitter that has the calibration for a\n        subset of qubits\n\nRaises:\n    QiskitError: If the calibration matrix is not initialized\n    QiskitError: If the mit pattern is not a tensor of single-qubit\n        measurement error mitigation.\n    QiskitError: If a qubit in the given ``qubit_sublist`` is not in the list of\n        qubits in the mit. pattern.",
        "api_signature": "subset_fitter(self, qubit_sublist)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/mitigation/fitters.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "MeasurementFilter.__init__",
        "api_description": "Initialize a measurement error mitigation filter using the cal_matrix\nfrom a measurement calibration fitter.\n\nArgs:\n    cal_matrix: the calibration matrix for applying the correction\n    state_labels: the states for the ordering of the cal matrix",
        "api_signature": "__init__(self, cal_matrix, state_labels)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/mitigation/_filters.py"
    },
    {
        "api_name": "cal_matrix",
        "full_api_name": "MeasurementFilter.cal_matrix",
        "api_description": "Return cal_matrix.",
        "api_signature": "cal_matrix(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/mitigation/_filters.py"
    },
    {
        "api_name": "state_labels",
        "full_api_name": "MeasurementFilter.state_labels",
        "api_description": "return the state label ordering of the cal matrix",
        "api_signature": "state_labels(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/mitigation/_filters.py"
    },
    {
        "api_name": "state_labels",
        "full_api_name": "MeasurementFilter.state_labels",
        "api_description": "set the state label ordering of the cal matrix",
        "api_signature": "state_labels(self, new_state_labels)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/mitigation/_filters.py"
    },
    {
        "api_name": "cal_matrix",
        "full_api_name": "MeasurementFilter.cal_matrix",
        "api_description": "Set cal_matrix.",
        "api_signature": "cal_matrix(self, new_cal_matrix)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/mitigation/_filters.py"
    },
    {
        "api_name": "apply",
        "full_api_name": "MeasurementFilter.apply",
        "api_description": "Apply the calibration matrix to results.\n\nArgs:\n    raw_data (dict or list): The data to be corrected. Can be in a number of forms:\n\n         Form 1: a counts dictionary from results.get_counts\n\n         Form 2: a list of counts of `length==len(state_labels)`\n\n         Form 3: a list of counts of `length==M*len(state_labels)` where M is an\n         integer (e.g. for use with the tomography data)\n\n         Form 4: a qiskit Result\n\n    method (str): fitting method. If `None`, then least_squares is used.\n\n        ``pseudo_inverse``: direct inversion of the A matrix\n\n        ``least_squares``: constrained to have physical probabilities\n\nReturns:\n    dict or list: The corrected data in the same form as `raw_data`\n\nRaises:\n    QiskitError: if `raw_data` is not an integer multiple\n        of the number of calibrated states.",
        "api_signature": "apply(self, raw_data, method)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/mitigation/_filters.py"
    },
    {
        "api_name": "fun",
        "full_api_name": "MeasurementFilter.fun",
        "api_description": "",
        "api_signature": "fun(x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/mitigation/_filters.py"
    },
    {
        "api_name": "_apply_correction",
        "full_api_name": "MeasurementFilter._apply_correction",
        "api_description": "Wrapper to call apply with a counts dictionary.",
        "api_signature": "_apply_correction(self, resultidx, raw_data, method)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/mitigation/_filters.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "TensoredFilter.__init__",
        "api_description": "Initialize a tensored measurement error mitigation filter using\nthe cal_matrices from a tensored measurement calibration fitter.\nA simple usage this class is explained [here]\n(https://qiskit.org/documentation/tutorials/noise/3_measurement_error_mitigation.html).\n\nArgs:\n    cal_matrices: the calibration matrices for applying the correction.\n    substate_labels_list: for each calibration matrix\n        a list of the states (as strings, states in the subspace)\n    mit_pattern: for each calibration matrix\n        a list of the logical qubit indices (as int, states in the subspace)",
        "api_signature": "__init__(self, cal_matrices, substate_labels_list, mit_pattern)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/mitigation/_filters.py"
    },
    {
        "api_name": "cal_matrices",
        "full_api_name": "TensoredFilter.cal_matrices",
        "api_description": "Return cal_matrices.",
        "api_signature": "cal_matrices(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/mitigation/_filters.py"
    },
    {
        "api_name": "cal_matrices",
        "full_api_name": "TensoredFilter.cal_matrices",
        "api_description": "Set cal_matrices.",
        "api_signature": "cal_matrices(self, new_cal_matrices)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/mitigation/_filters.py"
    },
    {
        "api_name": "substate_labels_list",
        "full_api_name": "TensoredFilter.substate_labels_list",
        "api_description": "Return _substate_labels_list",
        "api_signature": "substate_labels_list(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/mitigation/_filters.py"
    },
    {
        "api_name": "substate_labels_list",
        "full_api_name": "TensoredFilter.substate_labels_list",
        "api_description": "Return _substate_labels_list",
        "api_signature": "substate_labels_list(self, new_substate_labels_list)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/mitigation/_filters.py"
    },
    {
        "api_name": "qubit_list_sizes",
        "full_api_name": "TensoredFilter.qubit_list_sizes",
        "api_description": "Return _qubit_list_sizes.",
        "api_signature": "qubit_list_sizes(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/mitigation/_filters.py"
    },
    {
        "api_name": "nqubits",
        "full_api_name": "TensoredFilter.nqubits",
        "api_description": "Return the number of qubits. See also MeasurementFilter.apply()",
        "api_signature": "nqubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/mitigation/_filters.py"
    },
    {
        "api_name": "apply",
        "full_api_name": "TensoredFilter.apply",
        "api_description": "Apply the calibration matrices to results.\n\nArgs:\n    raw_data (dict or Result): The data to be corrected. Can be in one of two forms:\n\n        * A counts dictionary from results.get_counts\n\n        * A Qiskit Result\n\n    method (str): fitting method. The following methods are supported:\n\n        * 'pseudo_inverse': direct inversion of the cal matrices.\n            Mitigated counts can contain negative values\n            and the sum of counts would not equal to the shots.\n            Mitigation is conducted qubit wise:\n            For each qubit, mitigate the whole counts using the calibration matrices\n            which affect the corresponding qubit.\n            For example, assume we are mitigating the 3rd bit of the 4-bit counts\n            using '2    imes 2' calibration matrix `A_3`.\n            When mitigating the count of '0110' in this step,\n            the following formula is applied:\n            `count['0110'] = A_3^{-1}[1, 0]*count['0100'] + A_3^{-1}[1, 1]*count['0110']`.\n\n            The total time complexity of this method is `O(m2^{n + t})`,\n            where `n` is the size of calibrated qubits,\n            `m` is the number of sets in `mit_pattern`,\n            and `t` is the size of largest set of mit_pattern.\n            If the `mit_pattern` is shaped like `[[0], [1], [2], ..., [n-1]]`,\n            which corresponds to the tensor product noise model without cross-talk,\n            then the time complexity would be `O(n2^n)`.\n            If the `mit_pattern` is shaped like `[[0, 1, 2, ..., n-1]]`,\n            which exactly corresponds to the complete error mitigation,\n            then the time complexity would be `O(2^(n+n)) = O(4^n)`.\n\n\n        * 'least_squares': constrained to have physical probabilities.\n            Instead of directly applying inverse calibration matrices,\n            this method solve a constrained optimization problem to find\n            the closest probability vector to the result from 'pseudo_inverse' method.\n            Sequential least square quadratic programming (SLSQP) is used\n            in the internal process.\n            Every updating step in SLSQP takes `O(m2^{n+t})` time.\n            Since this method is using the SLSQP optimization over\n            the vector with lenght `2^n`, the mitigation for 8 bit counts\n            with the `mit_pattern = [[0], [1], [2], ..., [n-1]]` would\n            take 10 seconds or more.\n\n        * If `None`, 'least_squares' is used.\n\n    meas_layout (list of int): the mapping from classical registers to qubits\n\n        * If you measure qubit `2` to clbit `0`, `0` to `1`, and `1` to `2`,\n            the list becomes `[2, 0, 1]`\n\n        * If `None`, flatten(mit_pattern) is used.\n\nReturns:\n    dict or Result: The corrected data in the same form as raw_data\n\nRaises:\n    QiskitError: if raw_data is not in a one of the defined forms.",
        "api_signature": "apply(self, raw_data, method, meas_layout)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/mitigation/_filters.py"
    },
    {
        "api_name": "fun",
        "full_api_name": "TensoredFilter.fun",
        "api_description": "",
        "api_signature": "fun(x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/mitigation/_filters.py"
    },
    {
        "api_name": "flip_state",
        "full_api_name": "TensoredFilter.flip_state",
        "api_description": "Flip the state according to the chosen qubit positions",
        "api_signature": "flip_state(self, state, mat_index, flip_poses)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/mitigation/_filters.py"
    },
    {
        "api_name": "compute_index_of_cal_mat",
        "full_api_name": "TensoredFilter.compute_index_of_cal_mat",
        "api_description": "Return the index of (pseudo inverse) calibration matrix for the input quantum state",
        "api_signature": "compute_index_of_cal_mat(self, state, pos_qubits, indices)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/mitigation/_filters.py"
    },
    {
        "api_name": "_apply_correction",
        "full_api_name": "TensoredFilter._apply_correction",
        "api_description": "Wrapper to call apply with a counts dictionary.",
        "api_signature": "_apply_correction(self, resultidx, raw_data, method, meas_layout)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/mitigation/_filters.py"
    },
    {
        "api_name": "count_keys",
        "full_api_name": "count_keys",
        "api_description": "Deprecated: Return ordered count keys.\n\nArgs:\n    num_qubits: The number of qubits in the generated list.\nReturns:\n    The strings of all 0/1 combinations of the given number of qubits\nExample:\n    >>> count_keys(3)\n    ['000', '001', '010', '011', '100', '101', '110', '111']",
        "api_signature": "count_keys(num_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/mitigation/circuits.py"
    },
    {
        "api_name": "complete_meas_cal",
        "full_api_name": "complete_meas_cal",
        "api_description": "Deprecated: Return a list of measurement calibration circuits for the full\nHilbert space.\n\nIf the circuit contains :math:`n` qubits, then :math:`2^n` calibration circuits\nare created, each of which creates a basis state.\n\nArgs:\n    qubit_list: A list of qubits to perform the measurement correction on.\n       If `None`, and qr is given then assumed to be performed over the entire\n       qr. The calibration states will be labelled according to this ordering (default `None`).\n\n    qr: Quantum registers (or their size).\n        If ``None``, one is created (default ``None``).\n\n    cr: Classical registers (or their size).\n        If ``None``, one is created(default ``None``).\n\n    circlabel: A string to add to the front of circuit names for\n        unique identification(default ' ').\n\nReturns:\n    A list of QuantumCircuit objects containing the calibration circuits.\n\n    A list of calibration state labels.\n\nAdditional Information:\n    The returned circuits are named circlabel+cal_XXX\n    where XXX is the basis state,\n    e.g., cal_1001.\n\n    Pass the results of these circuits to the CompleteMeasurementFitter\n    constructor.\n\nRaises:\n    QiskitError: if both `qubit_list` and `qr` are `None`.",
        "api_signature": "complete_meas_cal(qubit_list, qr, cr, circlabel)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/mitigation/circuits.py"
    },
    {
        "api_name": "tensored_meas_cal",
        "full_api_name": "tensored_meas_cal",
        "api_description": "Deprecated: Return a list of calibration circuits\n\nArgs:\n    mit_pattern: Qubits on which to perform the\n        measurement correction, divided to groups according to tensors.\n        If `None` and `qr` is given then assumed to be performed over the entire\n        `qr` as one group (default `None`).\n\n    qr: A quantum register (or its size).\n    If `None`, one is created (default `None`).\n\n    cr: A classical register (or its size).\n    If `None`, one is created (default `None`).\n\n    circlabel: A string to add to the front of circuit names for\n        unique identification (default ' ').\n\nReturns:\n    A list of two QuantumCircuit objects containing the calibration circuits\n    mit_pattern\n\nAdditional Information:\n    The returned circuits are named circlabel+cal_XXX\n    where XXX is the basis state,\n    e.g., cal_000 and cal_111.\n\n    Pass the results of these circuits to the TensoredMeasurementFitter\n    constructor.\n\nRaises:\n    QiskitError: if both `mit_pattern` and `qr` are None.\n    QiskitError: if a qubit appears more than once in `mit_pattern`.",
        "api_signature": "tensored_meas_cal(mit_pattern, qr, cr, circlabel)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/mitigation/circuits.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ScheduleConfig.__init__",
        "api_description": "Container for information needed to schedule a QuantumCircuit into a pulse Schedule.\n\nArgs:\n    inst_map: The schedule definition of all gates supported on a backend.\n    meas_map: A list of groups of qubits which have to be measured together.\n    dt: Sample duration.",
        "api_signature": "__init__(self, inst_map, meas_map, dt)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/scheduler/config.py"
    },
    {
        "api_name": "lower_gates",
        "full_api_name": "lower_gates",
        "api_description": "Return a list of Schedules and the qubits they operate on, for each element encountered in the\ninput circuit.\n\nWithout concern for the final schedule, extract and return a list of Schedules and the qubits\nthey operate on, for each element encountered in the input circuit. Measures are grouped when\npossible, so ``qc.measure(q0, c0)`` or ``qc.measure(q1, c1)`` will generate a synchronous\nmeasurement pulse.\n\nArgs:\n    circuit: The quantum circuit to translate.\n    schedule_config: Backend specific parameters used for building the Schedule.\n    backend: Pass in the backend used to build the Schedule, the backend could be BackendV1\n             or BackendV2\n\nReturns:\n    A list of CircuitPulseDefs: the pulse definition for each circuit element.\n\nRaises:\n    QiskitError: If circuit uses a command that isn't defined in config.inst_map.",
        "api_signature": "lower_gates(circuit, schedule_config, backend)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/scheduler/lowering.py"
    },
    {
        "api_name": "get_measure_schedule",
        "full_api_name": "get_measure_schedule",
        "api_description": "Create a schedule to measure the qubits queued for measuring.",
        "api_signature": "get_measure_schedule(qubit_mem_slots)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/scheduler/lowering.py"
    },
    {
        "api_name": "sequence",
        "full_api_name": "sequence",
        "api_description": "Return the pulse Schedule which implements the input scheduled circuit.\n\nAssume all measurements are done at once at the last of the circuit.\nSchedules according to the command definition given by the schedule_config.\n\nArgs:\n    scheduled_circuit: The scheduled quantum circuit to translate.\n    schedule_config: Backend specific parameters used for building the Schedule.\n    backend: A backend used to build the Schedule, the backend could be BackendV1\n             or BackendV2\n\nReturns:\n    A schedule corresponding to the input ``circuit``.\n\nRaises:\n    QiskitError: If invalid scheduled circuit is supplied.",
        "api_signature": "sequence(scheduled_circuit, schedule_config, backend)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/scheduler/sequence.py"
    },
    {
        "api_name": "_meas_start_time",
        "full_api_name": "_meas_start_time",
        "api_description": "",
        "api_signature": "_meas_start_time()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/scheduler/sequence.py"
    },
    {
        "api_name": "schedule_circuit",
        "full_api_name": "schedule_circuit",
        "api_description": "Basic scheduling pass from a circuit to a pulse Schedule, using the backend. If no method is\nspecified, then a basic, as late as possible scheduling pass is performed, i.e. pulses are\nscheduled to occur as late as possible.\n\nSupported methods:\n\n    * ``'as_soon_as_possible'``: Schedule pulses greedily, as early as possible on a\n      qubit resource. (alias: ``'asap'``)\n    * ``'as_late_as_possible'``: Schedule pulses late-- keep qubits in the ground state when\n      possible. (alias: ``'alap'``)\n\nArgs:\n    circuit: The quantum circuit to translate.\n    schedule_config: Backend specific parameters used for building the Schedule.\n    method: The scheduling pass method to use.\n    backend: A backend used to build the Schedule, the backend could be BackendV1\n             or BackendV2.\n\nReturns:\n    Schedule corresponding to the input circuit.\n\nRaises:\n    QiskitError: If method isn't recognized.",
        "api_signature": "schedule_circuit(circuit, schedule_config, method, backend)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/scheduler/schedule_circuit.py"
    },
    {
        "api_name": "as_soon_as_possible",
        "full_api_name": "as_soon_as_possible",
        "api_description": "Return the pulse Schedule which implements the input circuit using an \"as soon as possible\"\n(asap) scheduling policy.\n\nCircuit instructions are first each mapped to equivalent pulse\nSchedules according to the command definition given by the schedule_config. Then, this circuit\ninstruction-equivalent Schedule is appended at the earliest time at which all qubits involved\nin the instruction are available.\n\nArgs:\n    circuit: The quantum circuit to translate.\n    schedule_config: Backend specific parameters used for building the Schedule.\n    backend: A backend used to build the Schedule, the backend could be BackendV1\n             or BackendV2.\n\nReturns:\n    A schedule corresponding to the input ``circuit`` with pulses occurring as early as\n    possible.",
        "api_signature": "as_soon_as_possible(circuit, schedule_config, backend)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/scheduler/methods/basic.py"
    },
    {
        "api_name": "update_times",
        "full_api_name": "update_times",
        "api_description": "Update the time tracker for all inst_qubits to the given time.",
        "api_signature": "update_times(inst_qubits, time)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/scheduler/methods/basic.py"
    },
    {
        "api_name": "as_late_as_possible",
        "full_api_name": "as_late_as_possible",
        "api_description": "Return the pulse Schedule which implements the input circuit using an \"as late as possible\"\n(alap) scheduling policy.\n\nCircuit instructions are first each mapped to equivalent pulse\nSchedules according to the command definition given by the schedule_config. Then, this circuit\ninstruction-equivalent Schedule is appended at the latest time that it can be without allowing\nunnecessary time between instructions or allowing instructions with common qubits to overlap.\n\nThis method should improves the outcome fidelity over ASAP scheduling, because we may\nmaximize the time that the qubit remains in the ground state.\n\nArgs:\n    circuit: The quantum circuit to translate.\n    schedule_config: Backend specific parameters used for building the Schedule.\n    backend: A backend used to build the Schedule, the backend could be BackendV1\n             or BackendV2.\n\nReturns:\n    A schedule corresponding to the input ``circuit`` with pulses occurring as late as\n    possible.",
        "api_signature": "as_late_as_possible(circuit, schedule_config, backend)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/scheduler/methods/basic.py"
    },
    {
        "api_name": "update_times",
        "full_api_name": "update_times",
        "api_description": "Update the time tracker for all inst_qubits to the given time.",
        "api_signature": "update_times(inst_qubits, time)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/scheduler/methods/basic.py"
    },
    {
        "api_name": "_has_connection",
        "full_api_name": "_has_connection",
        "api_description": "Checks if internet connection exists to host via specified port.\n\nIf any exception is raised while trying to open a socket this will return\nfalse.\n\nArgs:\n    hostname (str): Hostname to connect to.\n    port (int): Port to connect to\n\nReturns:\n    bool: Has connection or not",
        "api_signature": "_has_connection(hostname, port)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/decorators.py"
    },
    {
        "api_name": "is_aer_provider_available",
        "full_api_name": "is_aer_provider_available",
        "api_description": "Check if the C++ simulator can be instantiated.\n\nReturns:\n    bool: True if simulator executable is available",
        "api_signature": "is_aer_provider_available()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/decorators.py"
    },
    {
        "api_name": "requires_aer_provider",
        "full_api_name": "requires_aer_provider",
        "api_description": "Decorator that skips test if qiskit aer provider is not available\n\nArgs:\n    test_item (callable): function or class to be decorated.\n\nReturns:\n    callable: the decorated function.",
        "api_signature": "requires_aer_provider(test_item)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/decorators.py"
    },
    {
        "api_name": "slow_test",
        "full_api_name": "slow_test",
        "api_description": "Decorator that signals that the test takes minutes to run.\n\nArgs:\n    func (callable): test function to be decorated.\n\nReturns:\n    callable: the decorated function.",
        "api_signature": "slow_test(func)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/decorators.py"
    },
    {
        "api_name": "_wrapper",
        "full_api_name": "_wrapper",
        "api_description": "",
        "api_signature": "_wrapper()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/decorators.py"
    },
    {
        "api_name": "_get_credentials",
        "full_api_name": "_get_credentials",
        "api_description": "Finds the credentials for a specific test and options.\n\nReturns:\n    Credentials: set of credentials\n\nRaises:\n    SkipTest: when credentials can't be found",
        "api_signature": "_get_credentials()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/decorators.py"
    },
    {
        "api_name": "online_test",
        "full_api_name": "online_test",
        "api_description": "Decorator that signals that the test uses the network (and the online API):\n\nIt involves:\n    * determines if the test should be skipped by checking environment\n        variables.\n    * if the `USE_ALTERNATE_ENV_CREDENTIALS` environment variable is\n      set, it reads the credentials from an alternative set of environment\n      variables.\n    * if the test is not skipped, it reads `qe_token` and `qe_url` from\n        `Qconfig.py`, environment variables or qiskitrc.\n    * if the test is not skipped, it appends `qe_token` and `qe_url` as\n        arguments to the test function.\n\nArgs:\n    func (callable): test function to be decorated.\n\nReturns:\n    callable: the decorated function.",
        "api_signature": "online_test(func)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/decorators.py"
    },
    {
        "api_name": "_wrapper",
        "full_api_name": "_wrapper",
        "api_description": "",
        "api_signature": "_wrapper(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/decorators.py"
    },
    {
        "api_name": "enforce_subclasses_call",
        "full_api_name": "enforce_subclasses_call",
        "api_description": "Class decorator which enforces that if any subclasses define on of the ``methods``, they must\ncall ``super().<method>()`` or face a ``ValueError`` at runtime.\n\nThis is unlikely to be useful for concrete test classes, who are not normally subclassed.  It\nshould not be used on user-facing code, because it prevents subclasses from being free to\noverride parent-class behavior, even when the parent-class behavior is not needed.\n\nThis adds behavior to the ``__init__`` and ``__init_subclass__`` methods of the class, in\naddition to the named methods of this class and all subclasses.  The checks could be averted in\ngrandchildren if a child class overrides ``__init_subclass__`` without up-calling the decorated\nclass's method, though this would typically break inheritance principles.\n\nArguments:\n    methods:\n        Names of the methods to add the enforcement to.  These do not necessarily need to be\n        defined in the class body, provided they are somewhere in the method-resolution tree.\n\n    attr:\n        The attribute which will be added to all instances of this class and subclasses, in\n        order to manage the call enforcement.  This can be changed to avoid clashes.\n\nReturns:\n    A decorator, which returns its input class with the class with the relevant methods modified\n    to include checks, and injection code in the ``__init_subclass__`` method.",
        "api_signature": "enforce_subclasses_call(methods, attr)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/decorators.py"
    },
    {
        "api_name": "initialize_call_memory",
        "full_api_name": "initialize_call_memory",
        "api_description": "Add the extra attribute used for tracking the method calls.",
        "api_signature": "initialize_call_memory(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/decorators.py"
    },
    {
        "api_name": "save_call_status",
        "full_api_name": "save_call_status",
        "api_description": "Decorator, whose return saves the fact that the top-level method call occurred.",
        "api_signature": "save_call_status(name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/decorators.py"
    },
    {
        "api_name": "out",
        "full_api_name": "out",
        "api_description": "",
        "api_signature": "out(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/decorators.py"
    },
    {
        "api_name": "clear_call_status",
        "full_api_name": "clear_call_status",
        "api_description": "Decorator, whose return clears the call status of the method ``name``.  This prepares the\ncall tracking for the child class's method call.",
        "api_signature": "clear_call_status(name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/decorators.py"
    },
    {
        "api_name": "out",
        "full_api_name": "out",
        "api_description": "",
        "api_signature": "out(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/decorators.py"
    },
    {
        "api_name": "enforce_call_occurred",
        "full_api_name": "enforce_call_occurred",
        "api_description": "Decorator, whose return checks that the top-level method call occurred, and raises\n``ValueError`` if not.  Concretely, this is an assertion that ``save_call_status`` ran.",
        "api_signature": "enforce_call_occurred(name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/decorators.py"
    },
    {
        "api_name": "out",
        "full_api_name": "out",
        "api_description": "",
        "api_signature": "out(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/decorators.py"
    },
    {
        "api_name": "wrap_subclass_methods",
        "full_api_name": "wrap_subclass_methods",
        "api_description": "Wrap all the ``methods`` of ``cls`` with the call-tracking assertions that the top-level\nversions of the methods were called (likely via ``super()``).",
        "api_signature": "wrap_subclass_methods(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/decorators.py"
    },
    {
        "api_name": "decorator",
        "full_api_name": "decorator",
        "api_description": "",
        "api_signature": "decorator(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/decorators.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "_TestOptions.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/decorators.py"
    },
    {
        "api_name": "_load",
        "full_api_name": "_TestOptions._load",
        "api_description": "",
        "api_signature": "_load(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/decorators.py"
    },
    {
        "api_name": "__getitem__",
        "full_api_name": "_TestOptions.__getitem__",
        "api_description": "",
        "api_signature": "__getitem__(self, key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/decorators.py"
    },
    {
        "api_name": "__iter__",
        "full_api_name": "_TestOptions.__iter__",
        "api_description": "",
        "api_signature": "__iter__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/decorators.py"
    },
    {
        "api_name": "__len__",
        "full_api_name": "_TestOptions.__len__",
        "api_description": "",
        "api_signature": "__len__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/decorators.py"
    },
    {
        "api_name": "setup_test_logging",
        "full_api_name": "setup_test_logging",
        "api_description": "Set logging to file and stdout for a logger.\n\nArgs:\n    logger (Logger): logger object to be updated.\n    log_level (str): logging level.\n    filename (str): name of the output file.",
        "api_signature": "setup_test_logging(logger, log_level, filename)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/utils.py"
    },
    {
        "api_name": "generate_cases",
        "full_api_name": "generate_cases",
        "api_description": "Combines kwargs in Cartesian product and creates Case with them",
        "api_signature": "generate_cases(docstring, dsc, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/utils.py"
    },
    {
        "api_name": "mock_get_backend",
        "full_api_name": "mock_get_backend",
        "api_description": "Replace qiskit.IBMQ with a mock that returns a single backend.\n\nNote this will set the value of qiskit.IBMQ to a MagicMock object. It is\nintended to be run as part of docstrings with jupyter-example in a hidden\ncell so that later examples which rely on ibmq devices so that the docs can\nbe built without requiring configured credentials. If used outside of this\ncontext be aware that you will have to manually restore qiskit.IBMQ the\nvalue to qiskit.providers.ibmq.IBMQ after you finish using your mock.\n\nArgs:\n    backend (str): The class name as a string for the fake device to\n        return from the mock IBMQ object. For example, FakeVigo.\nRaises:\n    NameError: If the specified value of backend",
        "api_signature": "mock_get_backend(backend)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/ibmq_mock.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "_CanonicalParametersIterator.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/_canonical.py"
    },
    {
        "api_name": "__iter__",
        "full_api_name": "_CanonicalParametersIterator.__iter__",
        "api_description": "",
        "api_signature": "__iter__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/_canonical.py"
    },
    {
        "api_name": "__next__",
        "full_api_name": "_CanonicalParametersIterator.__next__",
        "api_description": "",
        "api_signature": "__next__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/_canonical.py"
    },
    {
        "api_name": "canonicalize_control_flow",
        "full_api_name": "canonicalize_control_flow",
        "api_description": "Canonicalize all control-flow operations in a circuit.\n\nThis is not an efficient operation, and does not affect any properties of the circuit.  Its\nintent is to normalise parts of circuits that have a non-deterministic construction.  These are\nthe ordering of bit arguments in control-flow blocks output by the builder interface, and\nautomatically generated ``for``-loop variables.\n\nThe canonical form sorts the bits in the arguments of these operations so that they always\nappear in the order they were originally added to the outer-most circuit.  For-loop variables\nare re-bound into new, cached auto-generated ones.",
        "api_signature": "canonicalize_control_flow(circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/_canonical.py"
    },
    {
        "api_name": "worker",
        "full_api_name": "worker",
        "api_description": "",
        "api_signature": "worker(circuit, bit_map)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/_canonical.py"
    },
    {
        "api_name": "bit_key",
        "full_api_name": "bit_key",
        "api_description": "",
        "api_signature": "bit_key(bit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/_canonical.py"
    },
    {
        "api_name": "bell",
        "full_api_name": "ReferenceCircuits.bell",
        "api_description": "Return a Bell circuit.",
        "api_signature": "bell()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/reference_circuits.py"
    },
    {
        "api_name": "bell_no_measure",
        "full_api_name": "ReferenceCircuits.bell_no_measure",
        "api_description": "Return a Bell circuit.",
        "api_signature": "bell_no_measure()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/reference_circuits.py"
    },
    {
        "api_name": "get_test_options",
        "full_api_name": "get_test_options",
        "api_description": "Read option_var from env and returns a dict in which the test options are set.\n\nArgs:\n    option_var (str): The env var to read. Default: 'QISKIT_TESTS'\n\nReturns:\n    dict: A dictionary with the format {<option>: (bool)<activated>}.",
        "api_signature": "get_test_options(option_var)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/testing_options.py"
    },
    {
        "api_name": "turn_false",
        "full_api_name": "turn_false",
        "api_description": "Turn an option to False.\n\nArgs:\n    option (str): Turns defaults[option] to False\n\nReturns:\n    bool: True, returns always True.",
        "api_signature": "turn_false(option)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/testing_options.py"
    },
    {
        "api_name": "set_flag",
        "full_api_name": "set_flag",
        "api_description": "Set the flag to True and flip all the flags that need to be rewritten.\n\nArgs:\n    flag_ (str): Option to be True",
        "api_signature": "set_flag(flag_)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/testing_options.py"
    },
    {
        "api_name": "_is_ci_fork_pull_request",
        "full_api_name": "_is_ci_fork_pull_request",
        "api_description": "Check if the tests are being run in a CI environment from a PR.\n\nCheck if the tests are being run in a CI environment and if it is a pull\nrequest.\n\nReturns:\n    bool: True if the tests are executed inside a CI tool, and the changes\n        are not against the \"main\" branch.",
        "api_signature": "_is_ci_fork_pull_request()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/testing_options.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BaseQiskitTestCase.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/base.py"
    },
    {
        "api_name": "setUp",
        "full_api_name": "BaseQiskitTestCase.setUp",
        "api_description": "",
        "api_signature": "setUp(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/base.py"
    },
    {
        "api_name": "tearDown",
        "full_api_name": "BaseQiskitTestCase.tearDown",
        "api_description": "",
        "api_signature": "tearDown(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/base.py"
    },
    {
        "api_name": "_get_resource_path",
        "full_api_name": "BaseQiskitTestCase._get_resource_path",
        "api_description": "Get the absolute path to a resource.\n\nArgs:\n    filename (string): filename or relative path to the resource.\n    path (Path): path used as relative to the filename.\n\nReturns:\n    str: the absolute path to the resource.",
        "api_signature": "_get_resource_path(filename, path)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/base.py"
    },
    {
        "api_name": "assertQuantumCircuitEqual",
        "full_api_name": "BaseQiskitTestCase.assertQuantumCircuitEqual",
        "api_description": "Extra assertion method to give a better error message when two circuits are unequal.",
        "api_signature": "assertQuantumCircuitEqual(self, qc1, qc2, msg)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/base.py"
    },
    {
        "api_name": "assertDictAlmostEqual",
        "full_api_name": "BaseQiskitTestCase.assertDictAlmostEqual",
        "api_description": "Assert two dictionaries with numeric values are almost equal.\n\nFail if the two dictionaries are unequal as determined by\ncomparing that the difference between values with the same key are\nnot greater than delta (default 1e-8), or that difference rounded\nto the given number of decimal places is not zero. If a key in one\ndictionary is not in the other the default_value keyword argument\nwill be used for the missing value (default 0). If the two objects\ncompare equal then they will automatically compare almost equal.\n\nArgs:\n    dict1 (dict): a dictionary.\n    dict2 (dict): a dictionary.\n    delta (number): threshold for comparison (defaults to 1e-8).\n    msg (str): return a custom message on failure.\n    places (int): number of decimal places for comparison.\n    default_value (number): default value for missing keys.\n\nRaises:\n    TypeError: if the arguments are not valid (both `delta` and\n        `places` are specified).\n    AssertionError: if the dictionaries are not almost equal.",
        "api_signature": "assertDictAlmostEqual(self, dict1, dict2, delta, msg, places, default_value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/base.py"
    },
    {
        "api_name": "enable_parallel_processing",
        "full_api_name": "BaseQiskitTestCase.enable_parallel_processing",
        "api_description": "Enables parallel processing, for the duration of a test, on platforms\nthat support it. This is done by temporarily overriding the value of\nthe QISKIT_PARALLEL environment variable with the platform specific default.",
        "api_signature": "enable_parallel_processing(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/base.py"
    },
    {
        "api_name": "set_parallel_env",
        "full_api_name": "BaseQiskitTestCase.set_parallel_env",
        "api_description": "",
        "api_signature": "set_parallel_env(name, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/base.py"
    },
    {
        "api_name": "tearDown",
        "full_api_name": "QiskitTestCase.tearDown",
        "api_description": "",
        "api_signature": "tearDown(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/base.py"
    },
    {
        "api_name": "setUpClass",
        "full_api_name": "QiskitTestCase.setUpClass",
        "api_description": "",
        "api_signature": "setUpClass(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/base.py"
    },
    {
        "api_name": "setUp",
        "full_api_name": "FullQiskitTestCase.setUp",
        "api_description": "",
        "api_signature": "setUp(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/base.py"
    },
    {
        "api_name": "dicts_almost_equal",
        "full_api_name": "dicts_almost_equal",
        "api_description": "Test if two dictionaries with numeric values are almost equal.\n\nFail if the two dictionaries are unequal as determined by\ncomparing that the difference between values with the same key are\nnot greater than delta (default 1e-8), or that difference rounded\nto the given number of decimal places is not zero. If a key in one\ndictionary is not in the other the default_value keyword argument\nwill be used for the missing value (default 0). If the two objects\ncompare equal then they will automatically compare almost equal.\n\nArgs:\n    dict1 (dict): a dictionary.\n    dict2 (dict): a dictionary.\n    delta (number): threshold for comparison (defaults to 1e-8).\n    places (int): number of decimal places for comparison.\n    default_value (number): default value for missing keys.\n\nRaises:\n    TypeError: if the arguments are not valid (both `delta` and\n        `places` are specified).\n\nReturns:\n    String: Empty string if dictionaries are almost equal. A description\n        of their difference if they are deemed not almost equal.",
        "api_signature": "dicts_almost_equal(dict1, dict2, delta, places, default_value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/base.py"
    },
    {
        "api_name": "valid_comparison",
        "full_api_name": "valid_comparison",
        "api_description": "compare value to delta, within places accuracy",
        "api_signature": "valid_comparison(value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/base.py"
    },
    {
        "api_name": "__getattr__",
        "full_api_name": "__getattr__",
        "api_description": "",
        "api_signature": "__getattr__(name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/mock/__init__.py"
    },
    {
        "api_name": "__getattr__",
        "full_api_name": "__getattr__",
        "api_description": "",
        "api_signature": "__getattr__(name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/mock/backends/__init__.py"
    },
    {
        "api_name": "__getattr__",
        "full_api_name": "__getattr__",
        "api_description": "",
        "api_signature": "__getattr__(name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/mock/backends/hanoi/__init__.py"
    },
    {
        "api_name": "__getattr__",
        "full_api_name": "__getattr__",
        "api_description": "",
        "api_signature": "__getattr__(name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/mock/backends/essex/__init__.py"
    },
    {
        "api_name": "__getattr__",
        "full_api_name": "__getattr__",
        "api_description": "",
        "api_signature": "__getattr__(name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/mock/backends/montreal/__init__.py"
    },
    {
        "api_name": "__getattr__",
        "full_api_name": "__getattr__",
        "api_description": "",
        "api_signature": "__getattr__(name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/mock/backends/lagos/__init__.py"
    },
    {
        "api_name": "__getattr__",
        "full_api_name": "__getattr__",
        "api_description": "",
        "api_signature": "__getattr__(name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/mock/backends/melbourne/__init__.py"
    },
    {
        "api_name": "__getattr__",
        "full_api_name": "__getattr__",
        "api_description": "",
        "api_signature": "__getattr__(name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/mock/backends/tokyo/__init__.py"
    },
    {
        "api_name": "__getattr__",
        "full_api_name": "__getattr__",
        "api_description": "",
        "api_signature": "__getattr__(name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/mock/backends/athens/__init__.py"
    },
    {
        "api_name": "__getattr__",
        "full_api_name": "__getattr__",
        "api_description": "",
        "api_signature": "__getattr__(name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/mock/backends/johannesburg/__init__.py"
    },
    {
        "api_name": "__getattr__",
        "full_api_name": "__getattr__",
        "api_description": "",
        "api_signature": "__getattr__(name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/mock/backends/rochester/__init__.py"
    },
    {
        "api_name": "__getattr__",
        "full_api_name": "__getattr__",
        "api_description": "",
        "api_signature": "__getattr__(name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/mock/backends/yorktown/__init__.py"
    },
    {
        "api_name": "__getattr__",
        "full_api_name": "__getattr__",
        "api_description": "",
        "api_signature": "__getattr__(name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/mock/backends/cairo/__init__.py"
    },
    {
        "api_name": "__getattr__",
        "full_api_name": "__getattr__",
        "api_description": "",
        "api_signature": "__getattr__(name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/mock/backends/almaden/__init__.py"
    },
    {
        "api_name": "__getattr__",
        "full_api_name": "__getattr__",
        "api_description": "",
        "api_signature": "__getattr__(name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/mock/backends/casablanca/__init__.py"
    },
    {
        "api_name": "__getattr__",
        "full_api_name": "__getattr__",
        "api_description": "",
        "api_signature": "__getattr__(name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/mock/backends/mumbai/__init__.py"
    },
    {
        "api_name": "__getattr__",
        "full_api_name": "__getattr__",
        "api_description": "",
        "api_signature": "__getattr__(name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/mock/backends/burlington/__init__.py"
    },
    {
        "api_name": "__getattr__",
        "full_api_name": "__getattr__",
        "api_description": "",
        "api_signature": "__getattr__(name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/mock/backends/valencia/__init__.py"
    },
    {
        "api_name": "__getattr__",
        "full_api_name": "__getattr__",
        "api_description": "",
        "api_signature": "__getattr__(name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/mock/backends/sydney/__init__.py"
    },
    {
        "api_name": "__getattr__",
        "full_api_name": "__getattr__",
        "api_description": "",
        "api_signature": "__getattr__(name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/mock/backends/london/__init__.py"
    },
    {
        "api_name": "__getattr__",
        "full_api_name": "__getattr__",
        "api_description": "",
        "api_signature": "__getattr__(name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/mock/backends/boeblingen/__init__.py"
    },
    {
        "api_name": "__getattr__",
        "full_api_name": "__getattr__",
        "api_description": "",
        "api_signature": "__getattr__(name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/mock/backends/ourense/__init__.py"
    },
    {
        "api_name": "__getattr__",
        "full_api_name": "__getattr__",
        "api_description": "",
        "api_signature": "__getattr__(name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/mock/backends/kolkata/__init__.py"
    },
    {
        "api_name": "__getattr__",
        "full_api_name": "__getattr__",
        "api_description": "",
        "api_signature": "__getattr__(name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/mock/backends/paris/__init__.py"
    },
    {
        "api_name": "__getattr__",
        "full_api_name": "__getattr__",
        "api_description": "",
        "api_signature": "__getattr__(name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/mock/backends/tenerife/__init__.py"
    },
    {
        "api_name": "__getattr__",
        "full_api_name": "__getattr__",
        "api_description": "",
        "api_signature": "__getattr__(name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/mock/backends/manila/__init__.py"
    },
    {
        "api_name": "__getattr__",
        "full_api_name": "__getattr__",
        "api_description": "",
        "api_signature": "__getattr__(name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/mock/backends/lima/__init__.py"
    },
    {
        "api_name": "__getattr__",
        "full_api_name": "__getattr__",
        "api_description": "",
        "api_signature": "__getattr__(name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/mock/backends/santiago/__init__.py"
    },
    {
        "api_name": "__getattr__",
        "full_api_name": "__getattr__",
        "api_description": "",
        "api_signature": "__getattr__(name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/mock/backends/toronto/__init__.py"
    },
    {
        "api_name": "__getattr__",
        "full_api_name": "__getattr__",
        "api_description": "",
        "api_signature": "__getattr__(name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/mock/backends/rueschlikon/__init__.py"
    },
    {
        "api_name": "__getattr__",
        "full_api_name": "__getattr__",
        "api_description": "",
        "api_signature": "__getattr__(name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/mock/backends/armonk/__init__.py"
    },
    {
        "api_name": "__getattr__",
        "full_api_name": "__getattr__",
        "api_description": "",
        "api_signature": "__getattr__(name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/mock/backends/manhattan/__init__.py"
    },
    {
        "api_name": "__getattr__",
        "full_api_name": "__getattr__",
        "api_description": "",
        "api_signature": "__getattr__(name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/mock/backends/jakarta/__init__.py"
    },
    {
        "api_name": "__getattr__",
        "full_api_name": "__getattr__",
        "api_description": "",
        "api_signature": "__getattr__(name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/mock/backends/vigo/__init__.py"
    },
    {
        "api_name": "__getattr__",
        "full_api_name": "__getattr__",
        "api_description": "",
        "api_signature": "__getattr__(name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/mock/backends/bogota/__init__.py"
    },
    {
        "api_name": "__getattr__",
        "full_api_name": "__getattr__",
        "api_description": "",
        "api_signature": "__getattr__(name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/mock/backends/quito/__init__.py"
    },
    {
        "api_name": "__getattr__",
        "full_api_name": "__getattr__",
        "api_description": "",
        "api_signature": "__getattr__(name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/mock/backends/nairobi/__init__.py"
    },
    {
        "api_name": "__getattr__",
        "full_api_name": "__getattr__",
        "api_description": "",
        "api_signature": "__getattr__(name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/mock/backends/washington/__init__.py"
    },
    {
        "api_name": "__getattr__",
        "full_api_name": "__getattr__",
        "api_description": "",
        "api_signature": "__getattr__(name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/mock/backends/belem/__init__.py"
    },
    {
        "api_name": "__getattr__",
        "full_api_name": "__getattr__",
        "api_description": "",
        "api_signature": "__getattr__(name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/mock/backends/cambridge/__init__.py"
    },
    {
        "api_name": "__getattr__",
        "full_api_name": "__getattr__",
        "api_description": "",
        "api_signature": "__getattr__(name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/mock/backends/rome/__init__.py"
    },
    {
        "api_name": "__getattr__",
        "full_api_name": "__getattr__",
        "api_description": "",
        "api_signature": "__getattr__(name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/mock/backends/guadalupe/__init__.py"
    },
    {
        "api_name": "__getattr__",
        "full_api_name": "__getattr__",
        "api_description": "",
        "api_signature": "__getattr__(name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/mock/backends/brooklyn/__init__.py"
    },
    {
        "api_name": "__getattr__",
        "full_api_name": "__getattr__",
        "api_description": "",
        "api_signature": "__getattr__(name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/mock/backends/singapore/__init__.py"
    },
    {
        "api_name": "__getattr__",
        "full_api_name": "__getattr__",
        "api_description": "",
        "api_signature": "__getattr__(name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/mock/backends/poughkeepsie/__init__.py"
    },
    {
        "api_name": "setUp",
        "full_api_name": "BackendTestCase.setUp",
        "api_description": "",
        "api_signature": "setUp(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/providers/backend.py"
    },
    {
        "api_name": "setUpClass",
        "full_api_name": "BackendTestCase.setUpClass",
        "api_description": "",
        "api_signature": "setUpClass(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/providers/backend.py"
    },
    {
        "api_name": "_get_backend",
        "full_api_name": "BackendTestCase._get_backend",
        "api_description": "Return an instance of a Provider.",
        "api_signature": "_get_backend(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/providers/backend.py"
    },
    {
        "api_name": "test_configuration",
        "full_api_name": "BackendTestCase.test_configuration",
        "api_description": "Test backend.configuration().",
        "api_signature": "test_configuration(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/providers/backend.py"
    },
    {
        "api_name": "test_properties",
        "full_api_name": "BackendTestCase.test_properties",
        "api_description": "Test backend.properties().",
        "api_signature": "test_properties(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/providers/backend.py"
    },
    {
        "api_name": "test_status",
        "full_api_name": "BackendTestCase.test_status",
        "api_description": "Test backend.status().",
        "api_signature": "test_status(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/providers/backend.py"
    },
    {
        "api_name": "test_run_circuit",
        "full_api_name": "BackendTestCase.test_run_circuit",
        "api_description": "Test running a single circuit.",
        "api_signature": "test_run_circuit(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/providers/backend.py"
    },
    {
        "api_name": "setUp",
        "full_api_name": "ProviderTestCase.setUp",
        "api_description": "",
        "api_signature": "setUp(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/providers/provider.py"
    },
    {
        "api_name": "setUpClass",
        "full_api_name": "ProviderTestCase.setUpClass",
        "api_description": "",
        "api_signature": "setUpClass(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/providers/provider.py"
    },
    {
        "api_name": "_get_provider",
        "full_api_name": "ProviderTestCase._get_provider",
        "api_description": "Return an instance of a Provider.",
        "api_signature": "_get_provider(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/providers/provider.py"
    },
    {
        "api_name": "test_backends",
        "full_api_name": "ProviderTestCase.test_backends",
        "api_description": "Test the provider has backends.",
        "api_signature": "test_backends(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/providers/provider.py"
    },
    {
        "api_name": "test_get_backend",
        "full_api_name": "ProviderTestCase.test_get_backend",
        "api_description": "Test getting a backend from the provider.",
        "api_signature": "test_get_backend(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/test/providers/provider.py"
    },
    {
        "api_name": "estimate_observables",
        "full_api_name": "estimate_observables",
        "api_description": "Accepts a sequence of operators and calculates their expectation values - means\nand metadata. They are calculated with respect to a quantum state provided. A user\ncan optionally provide a threshold value which filters mean values falling below the threshold.\n\nArgs:\n    estimator: An estimator primitive used for calculations.\n    quantum_state: A (parameterized) quantum circuit preparing a quantum state that expectation\n        values are computed against.\n    observables: A list or a dictionary of operators whose expectation values are to be\n        calculated.\n    parameter_values: Optional list of parameters values to evaluate the quantum circuit on.\n    threshold: A threshold value that defines which mean values should be neglected (helpful for\n        ignoring numerical instabilities close to 0).\n\nReturns:\n    A list or a dictionary of tuples (mean, metadata).\n\nRaises:\n    AlgorithmError: If a primitive job is not successful.",
        "api_signature": "estimate_observables(estimator, quantum_state, observables, parameter_values, threshold)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/observables_evaluator.py"
    },
    {
        "api_name": "_handle_zero_ops",
        "full_api_name": "_handle_zero_ops",
        "api_description": "Replaces all occurrence of operators equal to 0 in the list with an equivalent ``PauliSumOp``\noperator.",
        "api_signature": "_handle_zero_ops(observables_list)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/observables_evaluator.py"
    },
    {
        "api_name": "_prepare_result",
        "full_api_name": "_prepare_result",
        "api_description": "Prepares a list of tuples of eigenvalues and metadata tuples from\n``observables_results`` and ``observables``.\n\nArgs:\n    observables_results: A list of tuples (mean, metadata).\n    observables: A list or a dictionary of operators whose expectation values are to be\n        calculated.\n\nReturns:\n    A list or a dictionary of tuples (mean, metadata).",
        "api_signature": "_prepare_result(observables_results, observables)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/observables_evaluator.py"
    },
    {
        "api_name": "initial_point",
        "full_api_name": "VariationalAlgorithm.initial_point",
        "api_description": "Returns initial point.",
        "api_signature": "initial_point(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/variational_algorithm.py"
    },
    {
        "api_name": "initial_point",
        "full_api_name": "VariationalAlgorithm.initial_point",
        "api_description": "Sets initial point.",
        "api_signature": "initial_point(self, initial_point)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/variational_algorithm.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "VariationalResult.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/variational_algorithm.py"
    },
    {
        "api_name": "optimizer_evals",
        "full_api_name": "VariationalResult.optimizer_evals",
        "api_description": "Returns number of optimizer evaluations",
        "api_signature": "optimizer_evals(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/variational_algorithm.py"
    },
    {
        "api_name": "optimizer_evals",
        "full_api_name": "VariationalResult.optimizer_evals",
        "api_description": "Sets number of optimizer evaluations",
        "api_signature": "optimizer_evals(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/variational_algorithm.py"
    },
    {
        "api_name": "optimizer_time",
        "full_api_name": "VariationalResult.optimizer_time",
        "api_description": "Returns time taken for optimization",
        "api_signature": "optimizer_time(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/variational_algorithm.py"
    },
    {
        "api_name": "optimizer_time",
        "full_api_name": "VariationalResult.optimizer_time",
        "api_description": "Sets time taken for optimization",
        "api_signature": "optimizer_time(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/variational_algorithm.py"
    },
    {
        "api_name": "optimal_value",
        "full_api_name": "VariationalResult.optimal_value",
        "api_description": "Returns optimal value",
        "api_signature": "optimal_value(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/variational_algorithm.py"
    },
    {
        "api_name": "optimal_value",
        "full_api_name": "VariationalResult.optimal_value",
        "api_description": "Sets optimal value",
        "api_signature": "optimal_value(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/variational_algorithm.py"
    },
    {
        "api_name": "optimal_point",
        "full_api_name": "VariationalResult.optimal_point",
        "api_description": "Returns optimal point",
        "api_signature": "optimal_point(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/variational_algorithm.py"
    },
    {
        "api_name": "optimal_point",
        "full_api_name": "VariationalResult.optimal_point",
        "api_description": "Sets optimal point",
        "api_signature": "optimal_point(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/variational_algorithm.py"
    },
    {
        "api_name": "optimal_parameters",
        "full_api_name": "VariationalResult.optimal_parameters",
        "api_description": "Returns the optimal parameters in a dictionary",
        "api_signature": "optimal_parameters(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/variational_algorithm.py"
    },
    {
        "api_name": "optimal_parameters",
        "full_api_name": "VariationalResult.optimal_parameters",
        "api_description": "Sets optimal parameters",
        "api_signature": "optimal_parameters(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/variational_algorithm.py"
    },
    {
        "api_name": "optimizer_result",
        "full_api_name": "VariationalResult.optimizer_result",
        "api_description": "Returns the optimizer result",
        "api_signature": "optimizer_result(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/variational_algorithm.py"
    },
    {
        "api_name": "optimizer_result",
        "full_api_name": "VariationalResult.optimizer_result",
        "api_description": "Sets optimizer result",
        "api_signature": "optimizer_result(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/variational_algorithm.py"
    },
    {
        "api_name": "optimal_circuit",
        "full_api_name": "VariationalResult.optimal_circuit",
        "api_description": "The optimal circuits. Along with the optimal parameters,\nthese can be used to retrieve the minimum eigenstate.",
        "api_signature": "optimal_circuit(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/variational_algorithm.py"
    },
    {
        "api_name": "optimal_circuit",
        "full_api_name": "VariationalResult.optimal_circuit",
        "api_description": "",
        "api_signature": "optimal_circuit(self, optimal_circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/variational_algorithm.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "AlgorithmResult.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/algorithm_result.py"
    },
    {
        "api_name": "combine",
        "full_api_name": "AlgorithmResult.combine",
        "api_description": "Any property from the argument that exists in the receiver is\nupdated.\nArgs:\n    result: Argument result with properties to be set.\nRaises:\n    TypeError: Argument is None",
        "api_signature": "combine(self, result)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/algorithm_result.py"
    },
    {
        "api_name": "eval_observables",
        "full_api_name": "eval_observables",
        "api_description": "Deprecated: Accepts a list or a dictionary of operators and calculates\ntheir expectation values - means\nand standard deviations. They are calculated with respect to a quantum state provided. A user\ncan optionally provide a threshold value which filters mean values falling below the threshold.\n\nThis function has been superseded by the\n:func:`qiskit.algorithms.observables_evaluator.eval_observables` function.\nIt will be deprecated in a future release and subsequently\nremoved after that.\n\nArgs:\n    quantum_instance: A quantum instance used for calculations.\n    quantum_state: An unparametrized quantum circuit representing a quantum state that\n        expectation values are computed against.\n    observables: A list or a dictionary of operators whose expectation values are to be\n        calculated.\n    expectation: An instance of ExpectationBase which defines a method for calculating\n        expectation values.\n    threshold: A threshold value that defines which mean values should be neglected (helpful for\n        ignoring numerical instabilities close to 0).\n\nReturns:\n    A list or a dictionary of tuples (mean, standard deviation).\n\nRaises:\n    ValueError: If a ``quantum_state`` with free parameters is provided.",
        "api_signature": "eval_observables(quantum_instance, quantum_state, observables, expectation, threshold)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/aux_ops_evaluator.py"
    },
    {
        "api_name": "_prepare_list_op",
        "full_api_name": "_prepare_list_op",
        "api_description": "Accepts a list or a dictionary of operators and converts them to a ``ListOp``.\n\nArgs:\n    quantum_state: An unparametrized quantum circuit representing a quantum state that\n        expectation values are computed against.\n    observables: A list or a dictionary of operators.\n\nReturns:\n    A ``ListOp`` that includes all provided observables.",
        "api_signature": "_prepare_list_op(quantum_state, observables)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/aux_ops_evaluator.py"
    },
    {
        "api_name": "_prepare_result",
        "full_api_name": "_prepare_result",
        "api_description": "Prepares a list or a dictionary of eigenvalues from ``observables_results`` and\n``observables``.\n\nArgs:\n    observables_results: A list of of tuples (mean, standard deviation).\n    observables: A list or a dictionary of operators whose expectation values are to be\n        calculated.\n\nReturns:\n    A list or a dictionary of tuples (mean, standard deviation).",
        "api_signature": "_prepare_result(observables_results, observables)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/aux_ops_evaluator.py"
    },
    {
        "api_name": "_compute_std_devs",
        "full_api_name": "_compute_std_devs",
        "api_description": "Calculates a list of standard deviations from expectation values of observables provided.\n\nArgs:\n    observables_expect_sampled: Expected values of observables.\n    observables: A list or a dictionary of operators whose expectation values are to be\n        calculated.\n    expectation: An instance of ExpectationBase which defines a method for calculating\n        expectation values.\n    quantum_instance: A quantum instance used for calculations.\n\nReturns:\n    A list of standard deviations.",
        "api_signature": "_compute_std_devs(observables_expect_sampled, observables, expectation, quantum_instance)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/aux_ops_evaluator.py"
    },
    {
        "api_name": "validate_initial_point",
        "full_api_name": "validate_initial_point",
        "api_description": "Validate a choice of initial point against a choice of circuit. If no point is provided, a\nrandom point will be generated within certain parameter bounds. It will first look to the\ncircuit for these bounds. If the circuit does not specify bounds, bounds of :math:`-2\\pi`,\n:math:`2\\pi` will be used.\n\nArgs:\n    point: An initial point.\n    circuit: A parameterized quantum circuit.\n\nReturns:\n    A validated initial point.\n\nRaises:\n    ValueError: If the dimension of the initial point does not match the number of circuit\n    parameters.",
        "api_signature": "validate_initial_point(point, circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/utils/validate_initial_point.py"
    },
    {
        "api_name": "_set_default_batchsize",
        "full_api_name": "_set_default_batchsize",
        "api_description": "Set the default batchsize, if None is set and return whether it was updated or not.",
        "api_signature": "_set_default_batchsize(optimizer)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/utils/set_batching.py"
    },
    {
        "api_name": "validate_bounds",
        "full_api_name": "validate_bounds",
        "api_description": "Validate the bounds provided by a quantum circuit against its number of parameters.\nIf no bounds are obtained, return ``None`` for all lower and upper bounds.\n\nArgs:\n    circuit: A parameterized quantum circuit.\n\nReturns:\n    A list of tuples (lower_bound, upper_bound)).\n\nRaises:\n    ValueError: If the number of bounds does not the match the number of circuit parameters.",
        "api_signature": "validate_bounds(circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/utils/validate_bounds.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "EvolutionResult.__init__",
        "api_description": "Args:\n    evolved_state: An evolved quantum state.\n    aux_ops_evaluated: Optional list of observables for which expected values on an evolved\n        state are calculated. These values are in fact tuples formatted as (mean, standard\n        deviation).",
        "api_signature": "__init__(self, evolved_state, aux_ops_evaluated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/evolvers/evolution_result.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "RealEvolver.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/evolvers/real_evolver.py"
    },
    {
        "api_name": "evolve",
        "full_api_name": "RealEvolver.evolve",
        "api_description": "Perform real time evolution :math:`\\exp(-i t H)|\\Psi\\rangle`.\n\nEvolves an initial state :math:`|\\Psi\\rangle` for a time :math:`t`\nunder a Hamiltonian  :math:`H`, as provided in the ``evolution_problem``.\n\nArgs:\n    evolution_problem: The definition of the evolution problem.\n\nReturns:\n    Evolution result which includes an evolved quantum state.",
        "api_signature": "evolve(self, evolution_problem)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/evolvers/real_evolver.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "EvolutionProblem.__init__",
        "api_description": "Args:\n    hamiltonian: The Hamiltonian under which to evolve the system.\n    time: Total time of evolution.\n    initial_state: The quantum state to be evolved for methods like Trotterization.\n        For variational time evolutions, where the evolution happens in an ansatz,\n        this argument is not required.\n    aux_operators: Optional list of auxiliary operators to be evaluated with the\n        evolved ``initial_state`` and their expectation values returned.\n    truncation_threshold: Defines a threshold under which values can be assumed to be 0.\n        Used when ``aux_operators`` is provided.\n    t_param: Time parameter in case of a time-dependent Hamiltonian. This\n        free parameter must be within the ``hamiltonian``.\n    param_value_dict: Maps free parameters in the problem to values. Depending on the\n        algorithm, it might refer to e.g. a Hamiltonian or an initial state.\n\nRaises:\n    ValueError: If non-positive time of evolution is provided.",
        "api_signature": "__init__(self, hamiltonian, time, initial_state, aux_operators, truncation_threshold, t_param, param_value_dict)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/evolvers/evolution_problem.py"
    },
    {
        "api_name": "time",
        "full_api_name": "EvolutionProblem.time",
        "api_description": "Returns time.",
        "api_signature": "time(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/evolvers/evolution_problem.py"
    },
    {
        "api_name": "time",
        "full_api_name": "EvolutionProblem.time",
        "api_description": "Sets time and validates it.\n\nRaises:\n    ValueError: If time is not positive.",
        "api_signature": "time(self, time)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/evolvers/evolution_problem.py"
    },
    {
        "api_name": "validate_params",
        "full_api_name": "EvolutionProblem.validate_params",
        "api_description": "Checks if all parameters present in the Hamiltonian are also present in the dictionary\nthat maps them to values.\n\nRaises:\n    ValueError: If Hamiltonian parameters cannot be bound with data provided.",
        "api_signature": "validate_params(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/evolvers/evolution_problem.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ImaginaryEvolver.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/evolvers/imaginary_evolver.py"
    },
    {
        "api_name": "evolve",
        "full_api_name": "ImaginaryEvolver.evolve",
        "api_description": "Perform imaginary time evolution :math:`\\exp(-\\tau H)|\\Psi\\rangle`.\n\nEvolves an initial state :math:`|\\Psi\\rangle` for an imaginary time :math:`\\tau`\nunder a Hamiltonian  :math:`H`, as provided in the ``evolution_problem``.\n\nArgs:\n    evolution_problem: The definition of the evolution problem.\n\nReturns:\n    Evolution result which includes an evolved quantum state.",
        "api_signature": "evolve(self, evolution_problem)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/evolvers/imaginary_evolver.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "TrotterQRTE.__init__",
        "api_description": "Args:\n    product_formula: A Lie-Trotter-Suzuki product formula. The default is the Lie-Trotter\n        first order product formula with a single repetition.\n    expectation: An instance of ExpectationBase which defines a method for calculating\n        expectation values of EvolutionProblem.aux_operators.\n    quantum_instance: A quantum instance used for calculating expectation values of\n        EvolutionProblem.aux_operators.",
        "api_signature": "__init__(self, product_formula, expectation, quantum_instance)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/evolvers/trotterization/trotter_qrte.py"
    },
    {
        "api_name": "product_formula",
        "full_api_name": "TrotterQRTE.product_formula",
        "api_description": "Returns a product formula used in the algorithm.",
        "api_signature": "product_formula(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/evolvers/trotterization/trotter_qrte.py"
    },
    {
        "api_name": "product_formula",
        "full_api_name": "TrotterQRTE.product_formula",
        "api_description": "Sets a product formula.\nArgs:\n    product_formula: A formula that defines the Trotterization algorithm.",
        "api_signature": "product_formula(self, product_formula)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/evolvers/trotterization/trotter_qrte.py"
    },
    {
        "api_name": "quantum_instance",
        "full_api_name": "TrotterQRTE.quantum_instance",
        "api_description": "Returns a quantum instance used in the algorithm.",
        "api_signature": "quantum_instance(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/evolvers/trotterization/trotter_qrte.py"
    },
    {
        "api_name": "quantum_instance",
        "full_api_name": "TrotterQRTE.quantum_instance",
        "api_description": "Sets a quantum instance and a circuit sampler.\nArgs:\n    quantum_instance: The quantum instance used to run this algorithm.",
        "api_signature": "quantum_instance(self, quantum_instance)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/evolvers/trotterization/trotter_qrte.py"
    },
    {
        "api_name": "expectation",
        "full_api_name": "TrotterQRTE.expectation",
        "api_description": "Returns an expectation used in the algorithm.",
        "api_signature": "expectation(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/evolvers/trotterization/trotter_qrte.py"
    },
    {
        "api_name": "expectation",
        "full_api_name": "TrotterQRTE.expectation",
        "api_description": "Sets an expectation.\nArgs:\n    expectation: An instance of ExpectationBase which defines a method for calculating\n        expectation values of EvolutionProblem.aux_operators.",
        "api_signature": "expectation(self, expectation)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/evolvers/trotterization/trotter_qrte.py"
    },
    {
        "api_name": "supports_aux_operators",
        "full_api_name": "TrotterQRTE.supports_aux_operators",
        "api_description": "Whether computing the expectation value of auxiliary operators is supported.\n\nReturns:\n    True if ``aux_operators`` expectations in the EvolutionProblem can be evaluated, False\n        otherwise.",
        "api_signature": "supports_aux_operators(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/evolvers/trotterization/trotter_qrte.py"
    },
    {
        "api_name": "evolve",
        "full_api_name": "TrotterQRTE.evolve",
        "api_description": "Evolves a quantum state for a given time using the Trotterization method\nbased on a product formula provided. The result is provided in the form of a quantum\ncircuit. If auxiliary operators are included in the ``evolution_problem``, they are\nevaluated on an evolved state using a backend provided.\n\n.. note::\n    Time-dependent Hamiltonians are not yet supported.\n\nArgs:\n    evolution_problem: Instance defining evolution problem. For the included Hamiltonian,\n        ``PauliOp``, ``SummedOp`` or ``PauliSumOp`` are supported by TrotterQRTE.\n\nReturns:\n    Evolution result that includes an evolved state as a quantum circuit and, optionally,\n    auxiliary operators evaluated for a resulting state on a backend.\n\nRaises:\n    ValueError: If ``t_param`` is not set to None in the EvolutionProblem (feature not\n        currently supported).\n    ValueError: If the ``initial_state`` is not provided in the EvolutionProblem.",
        "api_signature": "evolve(self, evolution_problem)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/evolvers/trotterization/trotter_qrte.py"
    },
    {
        "api_name": "_summed_op_to_pauli_sum_op",
        "full_api_name": "TrotterQRTE._summed_op_to_pauli_sum_op",
        "api_description": "Tries binding parameters in a Hamiltonian.\n\nArgs:\n    hamiltonian: The Hamiltonian that defines an evolution.\n\nReturns:\n    Hamiltonian.\n\nRaises:\n    ValueError: If the ``SummedOp`` Hamiltonian contains operators of an invalid type.",
        "api_signature": "_summed_op_to_pauli_sum_op(hamiltonian)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/evolvers/trotterization/trotter_qrte.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Eigensolver.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigen_solvers/eigen_solver.py"
    },
    {
        "api_name": "compute_eigenvalues",
        "full_api_name": "Eigensolver.compute_eigenvalues",
        "api_description": "Computes eigenvalues. Operator and aux_operators can be supplied here and\nif not None will override any already set into algorithm so it can be reused with\ndifferent operators. While an operator is required by algorithms, aux_operators\nare optional. To 'remove' a previous aux_operators array use an empty list here.\n\nArgs:\n    operator: Qubit operator of the Observable\n    aux_operators: Optional list of auxiliary operators to be evaluated with the\n        eigenstate of the minimum eigenvalue main result and their expectation values\n        returned. For instance in chemistry these can be dipole operators, total particle\n        count operators so we can get values for these at the ground state.\n\nReturns:\n    EigensolverResult",
        "api_signature": "compute_eigenvalues(self, operator, aux_operators)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigen_solvers/eigen_solver.py"
    },
    {
        "api_name": "supports_aux_operators",
        "full_api_name": "Eigensolver.supports_aux_operators",
        "api_description": "Whether computing the expectation value of auxiliary operators is supported.\n\nReturns:\n    True if aux_operator expectations can be evaluated, False otherwise",
        "api_signature": "supports_aux_operators(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigen_solvers/eigen_solver.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "EigensolverResult.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigen_solvers/eigen_solver.py"
    },
    {
        "api_name": "eigenvalues",
        "full_api_name": "EigensolverResult.eigenvalues",
        "api_description": "returns eigen values",
        "api_signature": "eigenvalues(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigen_solvers/eigen_solver.py"
    },
    {
        "api_name": "eigenvalues",
        "full_api_name": "EigensolverResult.eigenvalues",
        "api_description": "set eigen values",
        "api_signature": "eigenvalues(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigen_solvers/eigen_solver.py"
    },
    {
        "api_name": "eigenstates",
        "full_api_name": "EigensolverResult.eigenstates",
        "api_description": "return eigen states",
        "api_signature": "eigenstates(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigen_solvers/eigen_solver.py"
    },
    {
        "api_name": "eigenstates",
        "full_api_name": "EigensolverResult.eigenstates",
        "api_description": "set eigen states",
        "api_signature": "eigenstates(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigen_solvers/eigen_solver.py"
    },
    {
        "api_name": "aux_operator_eigenvalues",
        "full_api_name": "EigensolverResult.aux_operator_eigenvalues",
        "api_description": "Return aux operator expectation values.\n\nThese values are in fact tuples formatted as (mean, standard deviation).",
        "api_signature": "aux_operator_eigenvalues(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigen_solvers/eigen_solver.py"
    },
    {
        "api_name": "aux_operator_eigenvalues",
        "full_api_name": "EigensolverResult.aux_operator_eigenvalues",
        "api_description": "set aux operator eigen values",
        "api_signature": "aux_operator_eigenvalues(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigen_solvers/eigen_solver.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "VQD.__init__",
        "api_description": "Args:\n    ansatz: A parameterized circuit used as ansatz for the wave function.\n    k: the number of eigenvalues to return. Returns the lowest k eigenvalues.\n    betas: beta parameters in the VQD paper.\n        Should have length k - 1, with k the number of excited states.\n        These hyperparameters balance the contribution of each overlap term to the cost\n        function and have a default value computed as the mean square sum of the\n        coefficients of the observable.\n    optimizer: A classical optimizer. Can either be a Qiskit optimizer or a callable\n        that takes an array as input and returns a Qiskit or SciPy optimization result.\n    initial_point: An optional initial point (i.e. initial parameter values)\n        for the optimizer. If ``None`` then VQD will look to the ansatz for a preferred\n        point and if not will simply compute a random one.\n    gradient: An optional gradient function or operator for optimizer.\n        Only used to compute the ground state at the moment.\n    expectation: The Expectation converter for taking the average value of the\n        Observable over the ansatz state function. When ``None`` (the default) an\n        :class:`~qiskit.opflow.expectations.ExpectationFactory` is used to select\n        an appropriate expectation based on the operator and backend. When using Aer\n        qasm_simulator backend, with paulis, it is however much faster to leverage custom\n        Aer function for the computation but, although VQD performs much faster\n        with it, the outcome is ideal, with no shot noise, like using a state vector\n        simulator. If you are just looking for the quickest performance when choosing Aer\n        qasm_simulator and the lack of shot noise is not an issue then set `include_custom`\n        parameter here to ``True`` (defaults to ``False``).\n    include_custom: When `expectation` parameter here is None setting this to ``True`` will\n        allow the factory to include the custom Aer pauli expectation.\n    max_evals_grouped: Max number of evaluations performed simultaneously. Signals the\n        given optimizer that more than one set of parameters can be supplied so that\n        multiple points to compute the gradient can be passed and if computed in parallel\n        potentially the expectation values can be computed in parallel. Typically this is\n        possible when a finite difference gradient is used by the optimizer such that\n        improve overall execution time. Deprecated if a gradient operator or function is\n        given.\n    callback: a callback that can access the intermediate data during the optimization.\n        Four parameter values are passed to the callback as follows during each evaluation\n        by the optimizer for its current set of parameters as it works towards the minimum.\n        These are: the evaluation count, the optimizer parameters for the ansatz, the\n        evaluated mean, the evaluated standard deviation, and the current step.\n    quantum_instance: Quantum Instance or Backend",
        "api_signature": "__init__(self, ansatz, k, betas, optimizer, initial_point, gradient, expectation, include_custom, max_evals_grouped, callback, quantum_instance)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigen_solvers/vqd.py"
    },
    {
        "api_name": "ansatz",
        "full_api_name": "VQD.ansatz",
        "api_description": "Returns the ansatz.",
        "api_signature": "ansatz(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigen_solvers/vqd.py"
    },
    {
        "api_name": "ansatz",
        "full_api_name": "VQD.ansatz",
        "api_description": "Sets the ansatz.\n\nArgs:\n    ansatz: The parameterized circuit used as an ansatz.\n        If None is passed, RealAmplitudes is used by default.",
        "api_signature": "ansatz(self, ansatz)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigen_solvers/vqd.py"
    },
    {
        "api_name": "gradient",
        "full_api_name": "VQD.gradient",
        "api_description": "Returns the gradient.",
        "api_signature": "gradient(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigen_solvers/vqd.py"
    },
    {
        "api_name": "gradient",
        "full_api_name": "VQD.gradient",
        "api_description": "Sets the gradient.",
        "api_signature": "gradient(self, gradient)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigen_solvers/vqd.py"
    },
    {
        "api_name": "quantum_instance",
        "full_api_name": "VQD.quantum_instance",
        "api_description": "Returns quantum instance.",
        "api_signature": "quantum_instance(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigen_solvers/vqd.py"
    },
    {
        "api_name": "quantum_instance",
        "full_api_name": "VQD.quantum_instance",
        "api_description": "Sets a quantum_instance.",
        "api_signature": "quantum_instance(self, quantum_instance)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigen_solvers/vqd.py"
    },
    {
        "api_name": "initial_point",
        "full_api_name": "VQD.initial_point",
        "api_description": "Returns initial point.",
        "api_signature": "initial_point(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigen_solvers/vqd.py"
    },
    {
        "api_name": "initial_point",
        "full_api_name": "VQD.initial_point",
        "api_description": "Sets initial point",
        "api_signature": "initial_point(self, initial_point)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigen_solvers/vqd.py"
    },
    {
        "api_name": "max_evals_grouped",
        "full_api_name": "VQD.max_evals_grouped",
        "api_description": "Returns max_evals_grouped",
        "api_signature": "max_evals_grouped(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigen_solvers/vqd.py"
    },
    {
        "api_name": "max_evals_grouped",
        "full_api_name": "VQD.max_evals_grouped",
        "api_description": "Sets max_evals_grouped",
        "api_signature": "max_evals_grouped(self, max_evals_grouped)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigen_solvers/vqd.py"
    },
    {
        "api_name": "include_custom",
        "full_api_name": "VQD.include_custom",
        "api_description": "Returns include_custom",
        "api_signature": "include_custom(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigen_solvers/vqd.py"
    },
    {
        "api_name": "include_custom",
        "full_api_name": "VQD.include_custom",
        "api_description": "Sets include_custom. If set to another value than the one that was previsously set,\nthe expectation attribute is reset to None.",
        "api_signature": "include_custom(self, include_custom)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigen_solvers/vqd.py"
    },
    {
        "api_name": "callback",
        "full_api_name": "VQD.callback",
        "api_description": "Returns callback",
        "api_signature": "callback(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigen_solvers/vqd.py"
    },
    {
        "api_name": "callback",
        "full_api_name": "VQD.callback",
        "api_description": "Sets callback",
        "api_signature": "callback(self, callback)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigen_solvers/vqd.py"
    },
    {
        "api_name": "expectation",
        "full_api_name": "VQD.expectation",
        "api_description": "The expectation value algorithm used to construct the expectation measurement from\nthe observable.",
        "api_signature": "expectation(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigen_solvers/vqd.py"
    },
    {
        "api_name": "expectation",
        "full_api_name": "VQD.expectation",
        "api_description": "",
        "api_signature": "expectation(self, exp)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigen_solvers/vqd.py"
    },
    {
        "api_name": "_check_operator_ansatz",
        "full_api_name": "VQD._check_operator_ansatz",
        "api_description": "Check that the number of qubits of operator and ansatz match.",
        "api_signature": "_check_operator_ansatz(self, operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigen_solvers/vqd.py"
    },
    {
        "api_name": "optimizer",
        "full_api_name": "VQD.optimizer",
        "api_description": "Returns optimizer",
        "api_signature": "optimizer(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigen_solvers/vqd.py"
    },
    {
        "api_name": "optimizer",
        "full_api_name": "VQD.optimizer",
        "api_description": "Sets the optimizer attribute.\n\nArgs:\n    optimizer: The optimizer to be used. If None is passed, SLSQP is used by default.",
        "api_signature": "optimizer(self, optimizer)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigen_solvers/vqd.py"
    },
    {
        "api_name": "setting",
        "full_api_name": "VQD.setting",
        "api_description": "Prepare the setting of VQD as a string.",
        "api_signature": "setting(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigen_solvers/vqd.py"
    },
    {
        "api_name": "print_settings",
        "full_api_name": "VQD.print_settings",
        "api_description": "Preparing the setting of VQD into a string.\n\nReturns:\n    str: the formatted setting of VQD.",
        "api_signature": "print_settings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigen_solvers/vqd.py"
    },
    {
        "api_name": "construct_expectation",
        "full_api_name": "VQD.construct_expectation",
        "api_description": "Generate the ansatz circuit and expectation value measurement, and return their\nrunnable composition.\n\nArgs:\n    parameter: Parameters for the ansatz circuit.\n    operator: Qubit operator of the Observable\n    return_expectation: If True, return the ``ExpectationBase`` expectation converter used\n        in the construction of the expectation value. Useful e.g. to compute the standard\n        deviation of the expectation value.\n\nReturns:\n    The Operator equalling the measurement of the ansatz :class:`StateFn` by the\n    Observable's expectation :class:`StateFn`, and, optionally, the expectation converter.\n\nRaises:\n    AlgorithmError: If no operator has been provided.\n    AlgorithmError: If no expectation is passed and None could be inferred via the\n        ExpectationFactory.",
        "api_signature": "construct_expectation(self, parameter, operator, return_expectation)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigen_solvers/vqd.py"
    },
    {
        "api_name": "construct_circuit",
        "full_api_name": "VQD.construct_circuit",
        "api_description": "Return the circuits used to compute the expectation value.\n\nArgs:\n    parameter: Parameters for the ansatz circuit.\n    operator: Qubit operator of the Observable\n\nReturns:\n    A list of the circuits used to compute the expectation value.",
        "api_signature": "construct_circuit(self, parameter, operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigen_solvers/vqd.py"
    },
    {
        "api_name": "extract_circuits",
        "full_api_name": "VQD.extract_circuits",
        "api_description": "",
        "api_signature": "extract_circuits(op)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigen_solvers/vqd.py"
    },
    {
        "api_name": "supports_aux_operators",
        "full_api_name": "VQD.supports_aux_operators",
        "api_description": "",
        "api_signature": "supports_aux_operators(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigen_solvers/vqd.py"
    },
    {
        "api_name": "_eval_aux_ops",
        "full_api_name": "VQD._eval_aux_ops",
        "api_description": "",
        "api_signature": "_eval_aux_ops(self, parameters, aux_operators, expectation, threshold)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigen_solvers/vqd.py"
    },
    {
        "api_name": "compute_eigenvalues",
        "full_api_name": "VQD.compute_eigenvalues",
        "api_description": "",
        "api_signature": "compute_eigenvalues(self, operator, aux_operators)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigen_solvers/vqd.py"
    },
    {
        "api_name": "get_energy_evaluation",
        "full_api_name": "VQD.get_energy_evaluation",
        "api_description": "Returns a function handle to evaluates the energy at given parameters for the ansatz.\n\nThis return value is the objective function to be passed to the optimizer for evaluation.\n\nArgs:\n    step: level of energy being calculated. 0 for ground, 1 for first excited state...\n    operator: The operator whose energy to evaluate.\n    return_expectation: If True, return the ``ExpectationBase`` expectation converter used\n        in the construction of the expectation value. Useful e.g. to evaluate other\n        operators with the same expectation value converter.\n    prev_states: List of parameters from previous rounds of optimization.\n\n\nReturns:\n    A callable that computes and returns the energy of the hamiltonian\n    of each parameter, and, optionally, the expectation\n\nRaises:\n    RuntimeError: If the circuit is not parameterized (i.e. has 0 free parameters).\n    AlgorithmError: If operator was not provided.",
        "api_signature": "get_energy_evaluation(self, step, operator, return_expectation, prev_states)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigen_solvers/vqd.py"
    },
    {
        "api_name": "energy_evaluation",
        "full_api_name": "VQD.energy_evaluation",
        "api_description": "",
        "api_signature": "energy_evaluation(parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigen_solvers/vqd.py"
    },
    {
        "api_name": "_get_eigenstate",
        "full_api_name": "VQD._get_eigenstate",
        "api_description": "Get the simulation outcome of the ansatz, provided with parameters.",
        "api_signature": "_get_eigenstate(self, optimal_parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigen_solvers/vqd.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "VQDResult.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigen_solvers/vqd.py"
    },
    {
        "api_name": "cost_function_evals",
        "full_api_name": "VQDResult.cost_function_evals",
        "api_description": "Returns number of cost optimizer evaluations",
        "api_signature": "cost_function_evals(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigen_solvers/vqd.py"
    },
    {
        "api_name": "cost_function_evals",
        "full_api_name": "VQDResult.cost_function_evals",
        "api_description": "Sets number of cost function evaluations",
        "api_signature": "cost_function_evals(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigen_solvers/vqd.py"
    },
    {
        "api_name": "eigenstates",
        "full_api_name": "VQDResult.eigenstates",
        "api_description": "return eigen state",
        "api_signature": "eigenstates(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigen_solvers/vqd.py"
    },
    {
        "api_name": "eigenstates",
        "full_api_name": "VQDResult.eigenstates",
        "api_description": "set eigen state",
        "api_signature": "eigenstates(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigen_solvers/vqd.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "NumPyEigensolver.__init__",
        "api_description": "Args:\n    k: How many eigenvalues are to be computed, has a min. value of 1.\n    filter_criterion: callable that allows to filter eigenvalues/eigenstates, only feasible\n        eigenstates are returned in the results. The callable has the signature\n        `filter(eigenstate, eigenvalue, aux_values)` and must return a boolean to indicate\n        whether to keep this value in the final returned result or not. If the number of\n        elements that satisfies the criterion is smaller than `k` then the returned list has\n        fewer elements and can even be empty.",
        "api_signature": "__init__(self, k, filter_criterion)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigen_solvers/numpy_eigen_solver.py"
    },
    {
        "api_name": "k",
        "full_api_name": "NumPyEigensolver.k",
        "api_description": "returns k (number of eigenvalues requested)",
        "api_signature": "k(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigen_solvers/numpy_eigen_solver.py"
    },
    {
        "api_name": "k",
        "full_api_name": "NumPyEigensolver.k",
        "api_description": "set k (number of eigenvalues requested)",
        "api_signature": "k(self, k)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigen_solvers/numpy_eigen_solver.py"
    },
    {
        "api_name": "filter_criterion",
        "full_api_name": "NumPyEigensolver.filter_criterion",
        "api_description": "returns the filter criterion if set",
        "api_signature": "filter_criterion(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigen_solvers/numpy_eigen_solver.py"
    },
    {
        "api_name": "filter_criterion",
        "full_api_name": "NumPyEigensolver.filter_criterion",
        "api_description": "set the filter criterion",
        "api_signature": "filter_criterion(self, filter_criterion)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigen_solvers/numpy_eigen_solver.py"
    },
    {
        "api_name": "supports_aux_operators",
        "full_api_name": "NumPyEigensolver.supports_aux_operators",
        "api_description": "",
        "api_signature": "supports_aux_operators(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigen_solvers/numpy_eigen_solver.py"
    },
    {
        "api_name": "_check_set_k",
        "full_api_name": "NumPyEigensolver._check_set_k",
        "api_description": "",
        "api_signature": "_check_set_k(self, operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigen_solvers/numpy_eigen_solver.py"
    },
    {
        "api_name": "_solve",
        "full_api_name": "NumPyEigensolver._solve",
        "api_description": "",
        "api_signature": "_solve(self, operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigen_solvers/numpy_eigen_solver.py"
    },
    {
        "api_name": "_get_ground_state_energy",
        "full_api_name": "NumPyEigensolver._get_ground_state_energy",
        "api_description": "",
        "api_signature": "_get_ground_state_energy(self, operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigen_solvers/numpy_eigen_solver.py"
    },
    {
        "api_name": "_get_energies",
        "full_api_name": "NumPyEigensolver._get_energies",
        "api_description": "",
        "api_signature": "_get_energies(self, operator, aux_operators)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigen_solvers/numpy_eigen_solver.py"
    },
    {
        "api_name": "_eval_aux_operators",
        "full_api_name": "NumPyEigensolver._eval_aux_operators",
        "api_description": "",
        "api_signature": "_eval_aux_operators(aux_operators, wavefn, threshold)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigen_solvers/numpy_eigen_solver.py"
    },
    {
        "api_name": "compute_eigenvalues",
        "full_api_name": "NumPyEigensolver.compute_eigenvalues",
        "api_description": "",
        "api_signature": "compute_eigenvalues(self, operator, aux_operators)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigen_solvers/numpy_eigen_solver.py"
    },
    {
        "api_name": "_make_param_shift_parameter_values",
        "full_api_name": "_make_param_shift_parameter_values",
        "api_description": "Returns a list of parameter values with offsets for parameter shift rule.\n\nArgs:\n    circuit: The original quantum circuit\n    parameter_values: parameter values to be added to the base parameter values.\n    parameters: The parameters to be shifted.\n\nReturns:\n    A list of parameter values with offsets for parameter shift rule.",
        "api_signature": "_make_param_shift_parameter_values(circuit, parameter_values, parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/utils.py"
    },
    {
        "api_name": "_make_lin_comb_gradient_circuit",
        "full_api_name": "_make_lin_comb_gradient_circuit",
        "api_description": "Makes a circuit that computes the linear combination of the gradient circuits.",
        "api_signature": "_make_lin_comb_gradient_circuit(circuit, add_measurement)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/utils.py"
    },
    {
        "api_name": "_gate_gradient",
        "full_api_name": "_gate_gradient",
        "api_description": "Returns the derivative of the gate",
        "api_signature": "_gate_gradient(gate)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/utils.py"
    },
    {
        "api_name": "_make_lin_comb_qgt_circuit",
        "full_api_name": "_make_lin_comb_qgt_circuit",
        "api_description": "Makes a circuit that computes the linear combination of the QGT circuits.",
        "api_signature": "_make_lin_comb_qgt_circuit(circuit, add_measurement)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/utils.py"
    },
    {
        "api_name": "_make_lin_comb_observables",
        "full_api_name": "_make_lin_comb_observables",
        "api_description": "Make the observable with an ancillary operator for the linear combination gradient.\n\nArgs:\n    observable: The observable.\n    derivative_type: The type of derivative. Can be either ``DerivativeType.REAL``\n        ``DerivativeType.IMAG``, or ``DerivativeType.COMPLEX``.\n\nReturns:\n    The observable with an ancillary operator for the linear combination gradient.\n\nRaises:\n    ValueError: If the derivative type is not supported.",
        "api_signature": "_make_lin_comb_observables(observable, derivative_type)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/utils.py"
    },
    {
        "api_name": "_assign_unique_parameters",
        "full_api_name": "_assign_unique_parameters",
        "api_description": "Assign unique parameters to the circuit.\n\nArgs:\n    circuit: The circuit to assign unique parameters.\n\nReturns:\n    The circuit with unique parameters and the mapping from the original parameters to the\n    unique parameters.",
        "api_signature": "_assign_unique_parameters(circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/utils.py"
    },
    {
        "api_name": "_make_gradient_parameter_values",
        "full_api_name": "_make_gradient_parameter_values",
        "api_description": "Makes parameter values for the gradient circuit.\n\nArgs:\n    circuit: The original quantum circuit\n    gradient_circuit: The gradient circuit\n    parameter_values: The parameter values for the original circuit\n    parameter_set: The parameter set to calculate gradients\n\nReturns:\n    The parameter values for the gradient circuit.",
        "api_signature": "_make_gradient_parameter_values(circuit, gradient_circuit, parameter_values)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/utils.py"
    },
    {
        "api_name": "_make_gradient_parameters",
        "full_api_name": "_make_gradient_parameters",
        "api_description": "Makes parameter set for the gradient circuit.\n\nArgs:\n    gradient_circuit: The gradient circuit\n    parameters: The parameters in the original circuit to calculate gradients\n\nReturns:\n    The parameters in the gradient circuit to calculate gradients.",
        "api_signature": "_make_gradient_parameters(gradient_circuit, parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/utils.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QFI.__init__",
        "api_description": "Args:\n    qgt: The quantum geometric tensor used to compute the QFI.\n    options: Backend runtime options used for circuit execution. The order of priority is:\n        options in ``run`` method > QFI's default options > primitive's default\n        setting. Higher priority setting overrides lower priority setting.",
        "api_signature": "__init__(self, qgt, options)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/qfi.py"
    },
    {
        "api_name": "run",
        "full_api_name": "QFI.run",
        "api_description": "Run the job of the QFIs on the given circuits.\n\nArgs:\n    circuits: The list of quantum circuits to compute the QFIs.\n    parameter_values: The list of parameter values to be bound to the circuit.\n    parameters: The sequence of parameters to calculate only the QFIs of\n        the specified parameters. Each sequence of parameters corresponds to a circuit in\n        ``circuits``. Defaults to None, which means that the QFIs of all parameters in\n        each circuit are calculated.\n    options: Primitive backend runtime options used for circuit execution.\n        The order of priority is: options in ``run`` method > QFI's\n        default options > QGT's default setting.\n        Higher priority setting overrides lower priority setting.\n\nReturns:\n    The job object of the QFIs of the expectation values. The i-th result corresponds to\n    ``circuits[i]`` evaluated with parameters bound as ``parameter_values[i]``.",
        "api_signature": "run(self, circuits, parameter_values, parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/qfi.py"
    },
    {
        "api_name": "_run",
        "full_api_name": "QFI._run",
        "api_description": "Compute the QFI on the given circuits.",
        "api_signature": "_run(self, circuits, parameter_values, parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/qfi.py"
    },
    {
        "api_name": "options",
        "full_api_name": "QFI.options",
        "api_description": "Return the union of QGT's options setting and QFI's default options,\nwhere, if the same field is set in both, the QFI's default options override\nthe QGT's default setting.\n\nReturns:\n    The QFI default + QGT options.",
        "api_signature": "options(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/qfi.py"
    },
    {
        "api_name": "update_default_options",
        "full_api_name": "QFI.update_default_options",
        "api_description": "Update the gradient's default options setting.\n\nArgs:\n    **options: The fields to update the default options.",
        "api_signature": "update_default_options(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/qfi.py"
    },
    {
        "api_name": "_get_local_options",
        "full_api_name": "QFI._get_local_options",
        "api_description": "Return the union of the QFI default setting,\nthe QGT default options, and the options in the ``run`` method.\nThe order of priority is: options in ``run`` method > QFI's default options > QGT's\ndefault setting.\n\nArgs:\n    options: The fields to update the options\n\nReturns:\n    The QFI default + QGT default + run options.",
        "api_signature": "_get_local_options(self, options)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/qfi.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BaseQGT.__init__",
        "api_description": "Args:\n    estimator: The estimator used to compute the QGT.\n    phase_fix: Whether to calculate the second term (phase fix) of the QGT, which is\n        :math:`\\langle\\partial_i \\psi | \\psi \\rangle \\langle\\psi | \\partial_j \\psi \\rangle`.\n        Defaults to ``True``.\n    derivative_type: The type of derivative. Can be either ``DerivativeType.REAL``\n        ``DerivativeType.IMAG``, or ``DerivativeType.COMPLEX``. Defaults to\n        ``DerivativeType.REAL``.\n\n        - ``DerivativeType.REAL`` computes\n\n        .. math::\n\n            \\mathrm{Re(QGT)}_{ij}= \\mathrm{Re}[\\langle \\partial_i \\psi | \\partial_j \\psi \\rangle\n                - \\langle\\partial_i \\psi | \\psi \\rangle \\langle\\psi | \\partial_j \\psi \\rangle].\n\n        - ``DerivativeType.IMAG`` computes\n\n        .. math::\n\n            \\mathrm{Im(QGT)}_{ij}= \\mathrm{Im}[\\langle \\partial_i \\psi | \\partial_j \\psi \\rangle\n                - \\langle\\partial_i \\psi | \\psi \\rangle \\langle\\psi | \\partial_j \\psi \\rangle].\n\n        - ``DerivativeType.COMPLEX`` computes\n\n        .. math::\n\n            \\mathrm{QGT}_{ij}= [\\langle \\partial_i \\psi | \\partial_j \\psi \\rangle\n                - \\langle\\partial_i \\psi | \\psi \\rangle \\langle\\psi | \\partial_j \\psi \\rangle].\n\n    options: Backend runtime options used for circuit execution. The order of priority is:\n        options in ``run`` method > QGT's default options > primitive's default\n        setting. Higher priority setting overrides lower priority setting.",
        "api_signature": "__init__(self, estimator, phase_fix, derivative_type, options)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/base/base_qgt.py"
    },
    {
        "api_name": "derivative_type",
        "full_api_name": "BaseQGT.derivative_type",
        "api_description": "The derivative type.",
        "api_signature": "derivative_type(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/base/base_qgt.py"
    },
    {
        "api_name": "derivative_type",
        "full_api_name": "BaseQGT.derivative_type",
        "api_description": "Set the derivative type.",
        "api_signature": "derivative_type(self, derivative_type)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/base/base_qgt.py"
    },
    {
        "api_name": "run",
        "full_api_name": "BaseQGT.run",
        "api_description": "Run the job of the QGTs on the given circuits.\n\nArgs:\n    circuits: The list of quantum circuits to compute the QGTs.\n    parameter_values: The list of parameter values to be bound to the circuit.\n    parameters: The sequence of parameters to calculate only the QGTs of\n        the specified parameters. Each sequence of parameters corresponds to a circuit in\n        ``circuits``. Defaults to None, which means that the QGTs of all parameters in\n        each circuit are calculated.\n    options: Primitive backend runtime options used for circuit execution.\n        The order of priority is: options in ``run`` method > QGT's\n        default options > primitive's default setting.\n        Higher priority setting overrides lower priority setting.\n\nReturns:\n    The job object of the QGTs of the expectation values. The i-th result corresponds to\n    ``circuits[i]`` evaluated with parameters bound as ``parameter_values[i]``.\n\nRaises:\n    ValueError: Invalid arguments are given.",
        "api_signature": "run(self, circuits, parameter_values, parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/base/base_qgt.py"
    },
    {
        "api_name": "_run",
        "full_api_name": "BaseQGT._run",
        "api_description": "Compute the QGTs on the given circuits.",
        "api_signature": "_run(self, circuits, parameter_values, parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/base/base_qgt.py"
    },
    {
        "api_name": "_preprocess",
        "full_api_name": "BaseQGT._preprocess",
        "api_description": "Preprocess the gradient. This makes a gradient circuit for each circuit. The gradient\ncircuit is a transpiled circuit by using the supported gates, and has unique parameters.\n``parameter_values`` and ``parameters`` are also updated to match the gradient circuit.\n\nArgs:\n    circuits: The list of quantum circuits to compute the gradients.\n    parameter_values: The list of parameter values to be bound to the circuit.\n    parameters: The sequence of parameters to calculate only the gradients of the specified\n        parameters.\n    supported_gates: The supported gates used to transpile the circuit.\n\nReturns:\n    The list of gradient circuits, the list of parameter values, and the list of parameters.\n    parameter_values and parameters are updated to match the gradient circuit.",
        "api_signature": "_preprocess(self, circuits, parameter_values, parameters, supported_gates)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/base/base_qgt.py"
    },
    {
        "api_name": "_postprocess",
        "full_api_name": "BaseQGT._postprocess",
        "api_description": "Postprocess the QGTs. This method computes the QGTs of the original circuits\nby applying the chain rule to the QGTs of the circuits with unique parameters.\n\nArgs:\n    results: The computed QGT for the circuits with unique parameters.\n    circuits: The list of original circuits submitted for gradient computation.\n    parameter_values: The list of parameter values to be bound to the circuits.\n    parameters: The sequence of parameters to calculate only the gradients of the specified\n        parameters.\n\nReturns:\n    The QGTs of the original circuits.",
        "api_signature": "_postprocess(self, results, circuits, parameter_values, parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/base/base_qgt.py"
    },
    {
        "api_name": "_validate_arguments",
        "full_api_name": "BaseQGT._validate_arguments",
        "api_description": "Validate the arguments of the ``run`` method.\n\nArgs:\n    circuits: The list of quantum circuits to compute the QGTs.\n    parameter_values: The list of parameter values to be bound to the circuits.\n    parameters: The sequence of parameters with respect to which the QGTs should be\n        computed.\n\nRaises:\n    ValueError: Invalid arguments are given.",
        "api_signature": "_validate_arguments(circuits, parameter_values, parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/base/base_qgt.py"
    },
    {
        "api_name": "options",
        "full_api_name": "BaseQGT.options",
        "api_description": "Return the union of estimator options setting and QGT default options,\nwhere, if the same field is set in both, the QGT's default options override\nthe primitive's default setting.\n\nReturns:\n    The QGT default + estimator options.",
        "api_signature": "options(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/base/base_qgt.py"
    },
    {
        "api_name": "update_default_options",
        "full_api_name": "BaseQGT.update_default_options",
        "api_description": "Update the gradient's default options setting.\n\nArgs:\n    **options: The fields to update the default options.",
        "api_signature": "update_default_options(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/base/base_qgt.py"
    },
    {
        "api_name": "_get_local_options",
        "full_api_name": "BaseQGT._get_local_options",
        "api_description": "Return the union of the primitive's default setting,\nthe QGT default options, and the options in the ``run`` method.\nThe order of priority is: options in ``run`` method > QGT's default options > primitive's\ndefault setting.\n\nArgs:\n    options: The fields to update the options\n\nReturns:\n    The QGT default + estimator + run options.",
        "api_signature": "_get_local_options(self, options)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/base/base_qgt.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BaseEstimatorGradient.__init__",
        "api_description": "Args:\n    estimator: The estimator used to compute the gradients.\n    options: Primitive backend runtime options used for circuit execution.\n        The order of priority is: options in ``run`` method > gradient's\n        default options > primitive's default setting.\n        Higher priority setting overrides lower priority setting\n    derivative_type: The type of derivative. Can be either ``DerivativeType.REAL``\n        ``DerivativeType.IMAG``, or ``DerivativeType.COMPLEX``.\n\n            - ``DerivativeType.REAL`` computes :math:`2 \\mathrm{Re}[\u27e8\u03c8(\u03c9)|O(\u03b8)|d\u03c9 \u03c8(\u03c9)\u3009]`.\n            - ``DerivativeType.IMAG`` computes :math:`2 \\mathrm{Im}[\u27e8\u03c8(\u03c9)|O(\u03b8)|d\u03c9 \u03c8(\u03c9)\u3009]`.\n            - ``DerivativeType.COMPLEX`` computes :math:`2 \u27e8\u03c8(\u03c9)|O(\u03b8)|d\u03c9 \u03c8(\u03c9)\u3009`.\n\n        Defaults to ``DerivativeType.REAL``, as this yields e.g. the commonly-used energy\n        gradient and this type is the only supported type for function-level schemes like\n        finite difference.",
        "api_signature": "__init__(self, estimator, options, derivative_type)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/base/base_estimator_gradient.py"
    },
    {
        "api_name": "derivative_type",
        "full_api_name": "BaseEstimatorGradient.derivative_type",
        "api_description": "Return the derivative type (real, imaginary or complex).\n\nReturns:\n    The derivative type.",
        "api_signature": "derivative_type(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/base/base_estimator_gradient.py"
    },
    {
        "api_name": "run",
        "full_api_name": "BaseEstimatorGradient.run",
        "api_description": "Run the job of the estimator gradient on the given circuits.\n\nArgs:\n    circuits: The list of quantum circuits to compute the gradients.\n    observables: The list of observables.\n    parameter_values: The list of parameter values to be bound to the circuit.\n    parameters: The sequence of parameters to calculate only the gradients of\n        the specified parameters. Each sequence of parameters corresponds to a circuit in\n        ``circuits``. Defaults to None, which means that the gradients of all parameters in\n        each circuit are calculated. None in the sequence means that the gradients of all\n        parameters in the corresponding circuit are calculated.\n    options: Primitive backend runtime options used for circuit execution.\n        The order of priority is: options in ``run`` method > gradient's\n        default options > primitive's default setting.\n        Higher priority setting overrides lower priority setting\n\nReturns:\n    The job object of the gradients of the expectation values. The i-th result corresponds to\n    ``circuits[i]`` evaluated with parameters bound as ``parameter_values[i]``. The j-th\n    element of the i-th result corresponds to the gradient of the i-th circuit with respect\n    to the j-th parameter.\n\nRaises:\n    ValueError: Invalid arguments are given.",
        "api_signature": "run(self, circuits, observables, parameter_values, parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/base/base_estimator_gradient.py"
    },
    {
        "api_name": "_run",
        "full_api_name": "BaseEstimatorGradient._run",
        "api_description": "Compute the estimator gradients on the given circuits.",
        "api_signature": "_run(self, circuits, observables, parameter_values, parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/base/base_estimator_gradient.py"
    },
    {
        "api_name": "_preprocess",
        "full_api_name": "BaseEstimatorGradient._preprocess",
        "api_description": "Preprocess the gradient. This makes a gradient circuit for each circuit. The gradient\ncircuit is a transpiled circuit by using the supported gates, and has unique parameters.\n``parameter_values`` and ``parameters`` are also updated to match the gradient circuit.\n\nArgs:\n    circuits: The list of quantum circuits to compute the gradients.\n    parameter_values: The list of parameter values to be bound to the circuit.\n    parameters: The sequence of parameters to calculate only the gradients of the specified\n        parameters.\n    supported_gates: The supported gates used to transpile the circuit.\n\nReturns:\n    The list of gradient circuits, the list of parameter values, and the list of parameters.\n    parameter_values and parameters are updated to match the gradient circuit.",
        "api_signature": "_preprocess(self, circuits, parameter_values, parameters, supported_gates)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/base/base_estimator_gradient.py"
    },
    {
        "api_name": "_postprocess",
        "full_api_name": "BaseEstimatorGradient._postprocess",
        "api_description": "Postprocess the gradients. This method computes the gradient of the original circuits\nby applying the chain rule to the gradient of the circuits with unique parameters.\n\nArgs:\n    results: The computed gradients for the circuits with unique parameters.\n    circuits: The list of original circuits submitted for gradient computation.\n    parameter_values: The list of parameter values to be bound to the circuits.\n    parameters: The sequence of parameters to calculate only the gradients of the specified\n        parameters.\n\nReturns:\n    The gradients of the original circuits.",
        "api_signature": "_postprocess(self, results, circuits, parameter_values, parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/base/base_estimator_gradient.py"
    },
    {
        "api_name": "_validate_arguments",
        "full_api_name": "BaseEstimatorGradient._validate_arguments",
        "api_description": "Validate the arguments of the ``run`` method.\n\nArgs:\n    circuits: The list of quantum circuits to compute the gradients.\n    observables: The list of observables.\n    parameter_values: The list of parameter values to be bound to the circuit.\n    parameters: The sequence of parameters to calculate only the gradients of the specified\n        parameters.\n\nRaises:\n    ValueError: Invalid arguments are given.",
        "api_signature": "_validate_arguments(circuits, observables, parameter_values, parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/base/base_estimator_gradient.py"
    },
    {
        "api_name": "options",
        "full_api_name": "BaseEstimatorGradient.options",
        "api_description": "Return the union of estimator options setting and gradient default options,\nwhere, if the same field is set in both, the gradient's default options override\nthe primitive's default setting.\n\nReturns:\n    The gradient default + estimator options.",
        "api_signature": "options(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/base/base_estimator_gradient.py"
    },
    {
        "api_name": "update_default_options",
        "full_api_name": "BaseEstimatorGradient.update_default_options",
        "api_description": "Update the gradient's default options setting.\n\nArgs:\n    **options: The fields to update the default options.",
        "api_signature": "update_default_options(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/base/base_estimator_gradient.py"
    },
    {
        "api_name": "_get_local_options",
        "full_api_name": "BaseEstimatorGradient._get_local_options",
        "api_description": "Return the union of the primitive's default setting,\nthe gradient default options, and the options in the ``run`` method.\nThe order of priority is: options in ``run`` method > gradient's\n        default options > primitive's default setting.\n\nArgs:\n    options: The fields to update the options\n\nReturns:\n    The gradient default + estimator + run options.",
        "api_signature": "_get_local_options(self, options)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/base/base_estimator_gradient.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BaseSamplerGradient.__init__",
        "api_description": "Args:\n    sampler: The sampler used to compute the gradients.\n    options: Primitive backend runtime options used for circuit execution.\n        The order of priority is: options in ``run`` method > gradient's\n        default options > primitive's default setting.\n        Higher priority setting overrides lower priority setting",
        "api_signature": "__init__(self, sampler, options)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/base/base_sampler_gradient.py"
    },
    {
        "api_name": "run",
        "full_api_name": "BaseSamplerGradient.run",
        "api_description": "Run the job of the sampler gradient on the given circuits.\n\nArgs:\n    circuits: The list of quantum circuits to compute the gradients.\n    parameter_values: The list of parameter values to be bound to the circuit.\n    parameters: The sequence of parameters to calculate only the gradients of\n        the specified parameters. Each sequence of parameters corresponds to a circuit in\n        ``circuits``. Defaults to None, which means that the gradients of all parameters in\n        each circuit are calculated. None in the sequence means that the gradients of all\n        parameters in the corresponding circuit are calculated.\n    options: Primitive backend runtime options used for circuit execution.\n        The order of priority is: options in ``run`` method > gradient's\n        default options > primitive's default setting.\n        Higher priority setting overrides lower priority setting\nReturns:\n    The job object of the gradients of the sampling probability. The i-th result\n    corresponds to ``circuits[i]`` evaluated with parameters bound as ``parameter_values[i]``.\n    The j-th quasi-probability distribution in the i-th result corresponds to the gradients of\n    the sampling probability for the j-th parameter in ``circuits[i]``.\n\nRaises:\n    ValueError: Invalid arguments are given.",
        "api_signature": "run(self, circuits, parameter_values, parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/base/base_sampler_gradient.py"
    },
    {
        "api_name": "_run",
        "full_api_name": "BaseSamplerGradient._run",
        "api_description": "Compute the sampler gradients on the given circuits.",
        "api_signature": "_run(self, circuits, parameter_values, parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/base/base_sampler_gradient.py"
    },
    {
        "api_name": "_preprocess",
        "full_api_name": "BaseSamplerGradient._preprocess",
        "api_description": "Preprocess the gradient. This makes a gradient circuit for each circuit. The gradient\ncircuit is a transpiled circuit by using the supported gates, and has unique parameters.\n``parameter_values`` and ``parameters`` are also updated to match the gradient circuit.\n\nArgs:\n    circuits: The list of quantum circuits to compute the gradients.\n    parameter_values: The list of parameter values to be bound to the circuit.\n    parameters: The sequence of parameters to calculate only the gradients of the specified\n        parameters.\n    supported_gates: The supported gates used to transpile the circuit.\n\nReturns:\n    The list of gradient circuits, the list of parameter values, and the list of parameters.\n    parameter_values and parameters are updated to match the gradient circuit.",
        "api_signature": "_preprocess(self, circuits, parameter_values, parameters, supported_gates)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/base/base_sampler_gradient.py"
    },
    {
        "api_name": "_postprocess",
        "full_api_name": "BaseSamplerGradient._postprocess",
        "api_description": "Postprocess the gradient. This computes the gradient of the original circuit from the\ngradient of the gradient circuit by using the chain rule.\n\nArgs:\n    results: The results of the gradient of the gradient circuits.\n    circuits: The list of quantum circuits to compute the gradients.\n    parameter_values: The list of parameter values to be bound to the circuit.\n    parameters: The sequence of parameters to calculate only the gradients of the specified\n        parameters.\n\nReturns:\n    The results of the gradient of the original circuits.",
        "api_signature": "_postprocess(self, results, circuits, parameter_values, parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/base/base_sampler_gradient.py"
    },
    {
        "api_name": "_validate_arguments",
        "full_api_name": "BaseSamplerGradient._validate_arguments",
        "api_description": "Validate the arguments of the ``run`` method.\n\nArgs:\n    circuits: The list of quantum circuits to compute the gradients.\n    parameter_values: The list of parameter values to be bound to the circuit.\n    parameters: The sequence of parameters to calculate only the gradients of the specified\n        parameters.\n\nRaises:\n    ValueError: Invalid arguments are given.",
        "api_signature": "_validate_arguments(circuits, parameter_values, parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/base/base_sampler_gradient.py"
    },
    {
        "api_name": "options",
        "full_api_name": "BaseSamplerGradient.options",
        "api_description": "Return the union of sampler options setting and gradient default options,\nwhere, if the same field is set in both, the gradient's default options override\nthe primitive's default setting.\n\nReturns:\n    The gradient default + sampler options.",
        "api_signature": "options(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/base/base_sampler_gradient.py"
    },
    {
        "api_name": "update_default_options",
        "full_api_name": "BaseSamplerGradient.update_default_options",
        "api_description": "Update the gradient's default options setting.\n\nArgs:\n    **options: The fields to update the default options.",
        "api_signature": "update_default_options(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/base/base_sampler_gradient.py"
    },
    {
        "api_name": "_get_local_options",
        "full_api_name": "BaseSamplerGradient._get_local_options",
        "api_description": "Return the union of the primitive's default setting,\nthe gradient default options, and the options in the ``run`` method.\nThe order of priority is: options in ``run`` method > gradient's\n        default options > primitive's default setting.\n\nArgs:\n    options: The fields to update the options\n\nReturns:\n    The gradient default + sampler + run options.",
        "api_signature": "_get_local_options(self, options)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/base/base_sampler_gradient.py"
    },
    {
        "api_name": "_run",
        "full_api_name": "ParamShiftSamplerGradient._run",
        "api_description": "Compute the estimator gradients on the given circuits.",
        "api_signature": "_run(self, circuits, parameter_values, parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/param_shift/param_shift_sampler_gradient.py"
    },
    {
        "api_name": "_run_unique",
        "full_api_name": "ParamShiftSamplerGradient._run_unique",
        "api_description": "Compute the sampler gradients on the given circuits.",
        "api_signature": "_run_unique(self, circuits, parameter_values, parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/param_shift/param_shift_sampler_gradient.py"
    },
    {
        "api_name": "_run",
        "full_api_name": "ParamShiftEstimatorGradient._run",
        "api_description": "Compute the gradients of the expectation values by the parameter shift rule.",
        "api_signature": "_run(self, circuits, observables, parameter_values, parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/param_shift/param_shift_estimator_gradient.py"
    },
    {
        "api_name": "_run_unique",
        "full_api_name": "ParamShiftEstimatorGradient._run_unique",
        "api_description": "Compute the estimator gradients on the given circuits.",
        "api_signature": "_run_unique(self, circuits, observables, parameter_values, parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/param_shift/param_shift_estimator_gradient.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ReverseEstimatorGradient.__init__",
        "api_description": "Args:\n    derivative_type: Defines whether the real, imaginary or real plus imaginary part\n        of the gradient is returned.",
        "api_signature": "__init__(self, derivative_type)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/reverse/reverse_gradient.py"
    },
    {
        "api_name": "derivative_type",
        "full_api_name": "ReverseEstimatorGradient.derivative_type",
        "api_description": "Set the derivative type.",
        "api_signature": "derivative_type(self, derivative_type)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/reverse/reverse_gradient.py"
    },
    {
        "api_name": "_run",
        "full_api_name": "ReverseEstimatorGradient._run",
        "api_description": "Compute the gradients of the expectation values by the parameter shift rule.",
        "api_signature": "_run(self, circuits, observables, parameter_values, parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/reverse/reverse_gradient.py"
    },
    {
        "api_name": "_run_unique",
        "full_api_name": "ReverseEstimatorGradient._run_unique",
        "api_description": "",
        "api_signature": "_run_unique(self, circuits, observables, parameter_values, parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/reverse/reverse_gradient.py"
    },
    {
        "api_name": "_to_derivtype",
        "full_api_name": "ReverseEstimatorGradient._to_derivtype",
        "api_description": "",
        "api_signature": "_to_derivtype(self, gradient)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/reverse/reverse_gradient.py"
    },
    {
        "api_name": "_evolve_by_operator",
        "full_api_name": "_evolve_by_operator",
        "api_description": "Evolve the Statevector state by operator.",
        "api_signature": "_evolve_by_operator(operator, state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/reverse/reverse_gradient.py"
    },
    {
        "api_name": "gradient_lookup",
        "full_api_name": "gradient_lookup",
        "api_description": "Returns a circuit implementing the gradient of the input gate.\n\nArgs:\n    gate: The gate whose derivative is returned.\n\nReturns:\n    The derivative of the input gate as list of ``(coeff, circuit)`` pairs,\n    where the sum of all ``coeff * circuit`` elements describes the full derivative.\n    The circuit is the unitary part of the derivative with a potential separate ``coeff``.\n    The output is a list as derivatives of e.g. controlled gates can only be described\n    as a sum of ``coeff * circuit`` pairs.\n\nRaises:\n    NotImplementedError: If the derivative of ``gate`` is not implemented.",
        "api_signature": "gradient_lookup(gate)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/reverse/derive_circuit.py"
    },
    {
        "api_name": "derive_circuit",
        "full_api_name": "derive_circuit",
        "api_description": "Return the analytic gradient expression of the input circuit wrt. a single parameter.\n\nReturns a list of ``(coeff, gradient_circuit)`` tuples, where the derivative of the circuit is\ngiven by the sum of the gradient circuits multiplied by their coefficient.\n\nFor example, the circuit::\n\n       \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n    q: \u2524 H \u251c\u2524 Rx(x) \u251c\u2524 Sdg \u251c\n       \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n\nreturns the coefficient `-0.5j` and the circuit equivalent to::\n\n       \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n    q: \u2524 H \u251c\u2524 Rx(x) \u251c\u2524 X \u251c\u2524 Sdg \u251c\n       \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n\nas the derivative of `Rx(x)` is `-0.5j Rx(x) X`.\n\nArgs:\n    circuit: The quantum circuit to derive.\n    parameter: The parameter with respect to which we derive.\n\nReturns:\n    A list of ``(coeff, gradient_circuit)`` tuples.\n\nRaises:\n    ValueError: If ``parameter`` is of the wrong type.\n    ValueError: If ``parameter`` is not in this circuit.\n    NotImplementedError: If a non-unique parameter is added, as the product rule is not yet\n        supported in this function.",
        "api_signature": "derive_circuit(circuit, parameter)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/reverse/derive_circuit.py"
    },
    {
        "api_name": "split",
        "full_api_name": "split",
        "api_description": "Split the circuit at ParameterExpressions.\n\nArgs:\n    circuit: The circuit to split.\n    parameters: The parameters at which to split. If None, split at each parameter.\n\nReturns:\n    A list of the split circuits along with a list of which parameters are in the subcircuits.",
        "api_signature": "split(circuit, parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/reverse/split_circuits.py"
    },
    {
        "api_name": "bind",
        "full_api_name": "bind",
        "api_description": "Bind parameters in a circuit (or list of circuits).\n\nThis method also allows passing parameter binds to parameters that are not in the circuit,\nand thereby differs to :meth:`.QuantumCircuit.assign_parameters`.\n\nArgs:\n    circuits: Input circuit(s).\n    parameter_binds: A dictionary with ``{Parameter: float}`` pairs determining the values to\n        which the free parameters in the circuit(s) are bound.\n    inplace: If ``True``, bind the values in place, otherwise return circuit copies.\n\nReturns:\n    The bound circuits, if ``inplace=False``, otherwise None.",
        "api_signature": "bind(circuits, parameter_binds, inplace)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/reverse/bind.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ReverseQGT.__init__",
        "api_description": "Args:\n    phase_fix: Whether or not to include the phase fix.\n    derivative_type: Determines whether the complex QGT or only the real or imaginary\n        parts are calculated.",
        "api_signature": "__init__(self, phase_fix, derivative_type)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/reverse/reverse_qgt.py"
    },
    {
        "api_name": "options",
        "full_api_name": "ReverseQGT.options",
        "api_description": "There are no options for the reverse QGT, returns an empty options dict.\n\nReturns:\n    Empty options.",
        "api_signature": "options(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/reverse/reverse_qgt.py"
    },
    {
        "api_name": "_run",
        "full_api_name": "ReverseQGT._run",
        "api_description": "Compute the QGT on the given circuits.",
        "api_signature": "_run(self, circuits, parameter_values, parameter_sets)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/reverse/reverse_qgt.py"
    },
    {
        "api_name": "_run_unique",
        "full_api_name": "ReverseQGT._run_unique",
        "api_description": "",
        "api_signature": "_run_unique(self, circuits, parameter_values, parameter_sets)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/reverse/reverse_qgt.py"
    },
    {
        "api_name": "_to_derivtype",
        "full_api_name": "ReverseQGT._to_derivtype",
        "api_description": "",
        "api_signature": "_to_derivtype(self, qgt)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/reverse/reverse_qgt.py"
    },
    {
        "api_name": "_l_term",
        "full_api_name": "_l_term",
        "api_description": "",
        "api_signature": "_l_term(coeffs_i, states_i, coeffs_j, states_j)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/reverse/reverse_qgt.py"
    },
    {
        "api_name": "_phasefix_term",
        "full_api_name": "_phasefix_term",
        "api_description": "",
        "api_signature": "_phasefix_term(chi, coeffs, states)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/reverse/reverse_qgt.py"
    },
    {
        "api_name": "_extract_parameter",
        "full_api_name": "_extract_parameter",
        "api_description": "",
        "api_signature": "_extract_parameter(expression)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/reverse/reverse_qgt.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "LinCombSamplerGradient.__init__",
        "api_description": "Args:\n    sampler: The sampler used to compute the gradients.\n    options: Primitive backend runtime options used for circuit execution.\n        The order of priority is: options in ``run`` method > gradient's\n        default options > primitive's default setting.\n        Higher priority setting overrides lower priority setting",
        "api_signature": "__init__(self, sampler, options)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/lin_comb/lin_comb_sampler_gradient.py"
    },
    {
        "api_name": "_run",
        "full_api_name": "LinCombSamplerGradient._run",
        "api_description": "Compute the estimator gradients on the given circuits.",
        "api_signature": "_run(self, circuits, parameter_values, parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/lin_comb/lin_comb_sampler_gradient.py"
    },
    {
        "api_name": "_run_unique",
        "full_api_name": "LinCombSamplerGradient._run_unique",
        "api_description": "Compute the sampler gradients on the given circuits.",
        "api_signature": "_run_unique(self, circuits, parameter_values, parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/lin_comb/lin_comb_sampler_gradient.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "LinCombEstimatorGradient.__init__",
        "api_description": "Args:\n    estimator: The estimator used to compute the gradients.\n    derivative_type: The type of derivative. Can be either ``DerivativeType.REAL``\n        ``DerivativeType.IMAG``, or ``DerivativeType.COMPLEX``. Defaults to\n        ``DerivativeType.REAL``.\n\n            - ``DerivativeType.REAL`` computes :math:`2 \\mathrm{Re}[\u27e8\u03c8(\u03c9)|O(\u03b8)|d\u03c9 \u03c8(\u03c9)\u3009]`.\n            - ``DerivativeType.IMAG`` computes :math:`2 \\mathrm{Im}[\u27e8\u03c8(\u03c9)|O(\u03b8)|d\u03c9 \u03c8(\u03c9)\u3009]`.\n            - ``DerivativeType.COMPLEX`` computes :math:`2 \u27e8\u03c8(\u03c9)|O(\u03b8)|d\u03c9 \u03c8(\u03c9)\u3009`.\n\n    options: Primitive backend runtime options used for circuit execution.\n        The order of priority is: options in ``run`` method > gradient's\n        default options > primitive's default setting.\n        Higher priority setting overrides lower priority setting.",
        "api_signature": "__init__(self, estimator, derivative_type, options)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/lin_comb/lin_comb_estimator_gradient.py"
    },
    {
        "api_name": "derivative_type",
        "full_api_name": "LinCombEstimatorGradient.derivative_type",
        "api_description": "Set the derivative type.",
        "api_signature": "derivative_type(self, derivative_type)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/lin_comb/lin_comb_estimator_gradient.py"
    },
    {
        "api_name": "_run",
        "full_api_name": "LinCombEstimatorGradient._run",
        "api_description": "Compute the estimator gradients on the given circuits.",
        "api_signature": "_run(self, circuits, observables, parameter_values, parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/lin_comb/lin_comb_estimator_gradient.py"
    },
    {
        "api_name": "_run_unique",
        "full_api_name": "LinCombEstimatorGradient._run_unique",
        "api_description": "Compute the estimator gradients on the given circuits.",
        "api_signature": "_run_unique(self, circuits, observables, parameter_values, parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/lin_comb/lin_comb_estimator_gradient.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "LinCombQGT.__init__",
        "api_description": "Args:\n    estimator: The estimator used to compute the QGT.\n    phase_fix: Whether to calculate the second term (phase fix) of the QGT, which is\n        :math:`\\langle\\partial_i \\psi | \\psi \\rangle \\langle\\psi | \\partial_j \\psi \\rangle`.\n        Default to ``True``.\n    derivative_type: The type of derivative. Can be either ``DerivativeType.REAL``\n        ``DerivativeType.IMAG``, or ``DerivativeType.COMPLEX``. Defaults to\n        ``DerivativeType.REAL``.\n\n        - ``DerivativeType.REAL`` computes\n\n        .. math::\n\n            \\mathrm{Re(QGT)}_{ij}= \\mathrm{Re}[\\langle \\partial_i \\psi | \\partial_j \\psi \\rangle\n                - \\langle\\partial_i \\psi | \\psi \\rangle \\langle\\psi | \\partial_j \\psi \\rangle].\n\n        - ``DerivativeType.IMAG`` computes\n\n        .. math::\n\n            \\mathrm{Re(QGT)}_{ij}= \\mathrm{Im}[\\langle \\partial_i \\psi | \\partial_j \\psi \\rangle\n                - \\langle\\partial_i \\psi | \\psi \\rangle \\langle\\psi | \\partial_j \\psi \\rangle].\n\n        - ``DerivativeType.COMPLEX`` computes\n\n        .. math::\n\n            \\mathrm{QGT}_{ij}= [\\langle \\partial_i \\psi | \\partial_j \\psi \\rangle\n                - \\langle\\partial_i \\psi | \\psi \\rangle \\langle\\psi | \\partial_j \\psi \\rangle].\n\n    options: Backend runtime options used for circuit execution. The order of priority is:\n        options in ``run`` method > QGT's default options > primitive's default\n        setting. Higher priority setting overrides lower priority setting.",
        "api_signature": "__init__(self, estimator, phase_fix, derivative_type, options)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/lin_comb/lin_comb_qgt.py"
    },
    {
        "api_name": "_run",
        "full_api_name": "LinCombQGT._run",
        "api_description": "Compute the QGT on the given circuits.",
        "api_signature": "_run(self, circuits, parameter_values, parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/lin_comb/lin_comb_qgt.py"
    },
    {
        "api_name": "_run_unique",
        "full_api_name": "LinCombQGT._run_unique",
        "api_description": "Compute the QGTs on the given circuits.",
        "api_signature": "_run_unique(self, circuits, parameter_values, parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/lin_comb/lin_comb_qgt.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "FiniteDiffSamplerGradient.__init__",
        "api_description": "Args:\n    sampler: The sampler used to compute the gradients.\n    epsilon: The offset size for the finite difference gradients.\n    options: Primitive backend runtime options used for circuit execution.\n        The order of priority is: options in ``run`` method > gradient's\n        default options > primitive's default setting.\n        Higher priority setting overrides lower priority setting\n    method: The computation method of the gradients.\n\n            - ``central`` computes :math:`\\frac{f(x+e)-f(x-e)}{2e}`,\n            - ``forward`` computes :math:`\\frac{f(x+e) - f(x)}{e}`,\n            - ``backward`` computes :math:`\\frac{f(x)-f(x-e)}{e}`\n\n        where :math:`e` is epsilon.\n\nRaises:\n    ValueError: If ``epsilon`` is not positive.\n    TypeError: If ``method`` is invalid.",
        "api_signature": "__init__(self, sampler, epsilon, options)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/finite_diff/finite_diff_sampler_gradient.py"
    },
    {
        "api_name": "_run",
        "full_api_name": "FiniteDiffSamplerGradient._run",
        "api_description": "Compute the sampler gradients on the given circuits.",
        "api_signature": "_run(self, circuits, parameter_values, parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/finite_diff/finite_diff_sampler_gradient.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "FiniteDiffEstimatorGradient.__init__",
        "api_description": "Args:\n    estimator: The estimator used to compute the gradients.\n    epsilon: The offset size for the finite difference gradients.\n    options: Primitive backend runtime options used for circuit execution.\n        The order of priority is: options in ``run`` method > gradient's\n        default options > primitive's default setting.\n        Higher priority setting overrides lower priority setting\n    method: The computation method of the gradients.\n\n            - ``central`` computes :math:`\\frac{f(x+e)-f(x-e)}{2e}`,\n            - ``forward`` computes :math:`\\frac{f(x+e) - f(x)}{e}`,\n            - ``backward`` computes :math:`\\frac{f(x)-f(x-e)}{e}`\n\n        where :math:`e` is epsilon.\n\nRaises:\n    ValueError: If ``epsilon`` is not positive.\n    TypeError: If ``method`` is invalid.",
        "api_signature": "__init__(self, estimator, epsilon, options)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/finite_diff/finite_diff_estimator_gradient.py"
    },
    {
        "api_name": "_run",
        "full_api_name": "FiniteDiffEstimatorGradient._run",
        "api_description": "Compute the estimator gradients on the given circuits.",
        "api_signature": "_run(self, circuits, observables, parameter_values, parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/finite_diff/finite_diff_estimator_gradient.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SPSAEstimatorGradient.__init__",
        "api_description": "Args:\n    estimator: The estimator used to compute the gradients.\n    epsilon: The offset size for the SPSA gradients.\n    batch_size: The number of gradients to average.\n    seed: The seed for a random perturbation vector.\n    options: Primitive backend runtime options used for circuit execution.\n        The order of priority is: options in ``run`` method > gradient's\n        default options > primitive's default setting.\n        Higher priority setting overrides lower priority setting\n\nRaises:\n    ValueError: If ``epsilon`` is not positive.",
        "api_signature": "__init__(self, estimator, epsilon, batch_size, seed, options)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/spsa/spsa_estimator_gradient.py"
    },
    {
        "api_name": "_run",
        "full_api_name": "SPSAEstimatorGradient._run",
        "api_description": "Compute the estimator gradients on the given circuits.",
        "api_signature": "_run(self, circuits, observables, parameter_values, parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/spsa/spsa_estimator_gradient.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SPSASamplerGradient.__init__",
        "api_description": "Args:\n    sampler: The sampler used to compute the gradients.\n    epsilon: The offset size for the SPSA gradients.\n    batch_size: number of gradients to average.\n    seed: The seed for a random perturbation vector.\n    options: Primitive backend runtime options used for circuit execution.\n        The order of priority is: options in ``run`` method > gradient's\n        default options > primitive's default setting.\n        Higher priority setting overrides lower priority setting\n\nRaises:\n    ValueError: If ``epsilon`` is not positive.",
        "api_signature": "__init__(self, sampler, epsilon, batch_size, seed, options)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/spsa/spsa_sampler_gradient.py"
    },
    {
        "api_name": "_run",
        "full_api_name": "SPSASamplerGradient._run",
        "api_description": "Compute the sampler gradients on the given circuits.",
        "api_signature": "_run(self, circuits, parameter_values, parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/gradients/spsa/spsa_sampler_gradient.py"
    },
    {
        "api_name": "estimate",
        "full_api_name": "AmplitudeEstimator.estimate",
        "api_description": "Run the amplitude estimation algorithm.\n\nArgs:\n    estimation_problem: An ``EstimationProblem`` containing all problem-relevant information\n        such as the state preparation and the objective qubits.",
        "api_signature": "estimate(self, estimation_problem)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/amplitude_estimator.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "AmplitudeEstimatorResult.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/amplitude_estimator.py"
    },
    {
        "api_name": "circuit_results",
        "full_api_name": "AmplitudeEstimatorResult.circuit_results",
        "api_description": "Return the circuit results. Can be a statevector or counts dictionary.",
        "api_signature": "circuit_results(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/amplitude_estimator.py"
    },
    {
        "api_name": "circuit_results",
        "full_api_name": "AmplitudeEstimatorResult.circuit_results",
        "api_description": "Set the circuit results.",
        "api_signature": "circuit_results(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/amplitude_estimator.py"
    },
    {
        "api_name": "shots",
        "full_api_name": "AmplitudeEstimatorResult.shots",
        "api_description": "Return the number of shots used. Is 1 for statevector-based simulations.",
        "api_signature": "shots(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/amplitude_estimator.py"
    },
    {
        "api_name": "shots",
        "full_api_name": "AmplitudeEstimatorResult.shots",
        "api_description": "Set the number of shots used.",
        "api_signature": "shots(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/amplitude_estimator.py"
    },
    {
        "api_name": "estimation",
        "full_api_name": "AmplitudeEstimatorResult.estimation",
        "api_description": "Return the estimation for the amplitude in :math:`[0, 1]`.",
        "api_signature": "estimation(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/amplitude_estimator.py"
    },
    {
        "api_name": "estimation",
        "full_api_name": "AmplitudeEstimatorResult.estimation",
        "api_description": "Set the estimation for the amplitude in :math:`[0, 1]`.",
        "api_signature": "estimation(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/amplitude_estimator.py"
    },
    {
        "api_name": "estimation_processed",
        "full_api_name": "AmplitudeEstimatorResult.estimation_processed",
        "api_description": "Return the estimation for the amplitude after the post-processing has been applied.",
        "api_signature": "estimation_processed(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/amplitude_estimator.py"
    },
    {
        "api_name": "estimation_processed",
        "full_api_name": "AmplitudeEstimatorResult.estimation_processed",
        "api_description": "Set the estimation for the amplitude after the post-processing has been applied.",
        "api_signature": "estimation_processed(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/amplitude_estimator.py"
    },
    {
        "api_name": "num_oracle_queries",
        "full_api_name": "AmplitudeEstimatorResult.num_oracle_queries",
        "api_description": "Return the number of Grover oracle queries.",
        "api_signature": "num_oracle_queries(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/amplitude_estimator.py"
    },
    {
        "api_name": "num_oracle_queries",
        "full_api_name": "AmplitudeEstimatorResult.num_oracle_queries",
        "api_description": "Set the number of Grover oracle queries.",
        "api_signature": "num_oracle_queries(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/amplitude_estimator.py"
    },
    {
        "api_name": "post_processing",
        "full_api_name": "AmplitudeEstimatorResult.post_processing",
        "api_description": "Return a handle to the post processing function.",
        "api_signature": "post_processing(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/amplitude_estimator.py"
    },
    {
        "api_name": "post_processing",
        "full_api_name": "AmplitudeEstimatorResult.post_processing",
        "api_description": "Set a handle to the post processing function.",
        "api_signature": "post_processing(self, post_processing)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/amplitude_estimator.py"
    },
    {
        "api_name": "confidence_interval",
        "full_api_name": "AmplitudeEstimatorResult.confidence_interval",
        "api_description": "Return the confidence interval for the amplitude (95% interval by default).",
        "api_signature": "confidence_interval(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/amplitude_estimator.py"
    },
    {
        "api_name": "confidence_interval",
        "full_api_name": "AmplitudeEstimatorResult.confidence_interval",
        "api_description": "Set the confidence interval for the amplitude (95% interval by default).",
        "api_signature": "confidence_interval(self, confidence_interval)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/amplitude_estimator.py"
    },
    {
        "api_name": "confidence_interval_processed",
        "full_api_name": "AmplitudeEstimatorResult.confidence_interval_processed",
        "api_description": "Return the post-processed confidence interval (95% interval by default).",
        "api_signature": "confidence_interval_processed(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/amplitude_estimator.py"
    },
    {
        "api_name": "confidence_interval_processed",
        "full_api_name": "AmplitudeEstimatorResult.confidence_interval_processed",
        "api_description": "Set the post-processed confidence interval (95% interval by default).",
        "api_signature": "confidence_interval_processed(self, confidence_interval)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/amplitude_estimator.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "FasterAmplitudeEstimation.__init__",
        "api_description": "Args:\n    delta: The probability that the true value is outside of the final confidence interval.\n    maxiter: The number of iterations, the maximal power of Q is `2 ** (maxiter - 1)`.\n    rescale: Whether to rescale the problem passed to `estimate`.\n    quantum_instance: Deprecated: The quantum instance or backend\n        to run the circuits.\n    sampler: A sampler primitive to evaluate the circuits.\n\n.. note::\n\n    This algorithm overwrites the number of shots set in the ``quantum_instance``\n    argument, but will reset them to the initial number after running.",
        "api_signature": "__init__(self, delta, maxiter, rescale, quantum_instance, sampler)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/fae.py"
    },
    {
        "api_name": "sampler",
        "full_api_name": "FasterAmplitudeEstimation.sampler",
        "api_description": "Get the sampler primitive.\n\nReturns:\n    The sampler primitive to evaluate the circuits.",
        "api_signature": "sampler(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/fae.py"
    },
    {
        "api_name": "sampler",
        "full_api_name": "FasterAmplitudeEstimation.sampler",
        "api_description": "Set sampler primitive.\n\nArgs:\n    sampler: A sampler primitive to evaluate the circuits.",
        "api_signature": "sampler(self, sampler)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/fae.py"
    },
    {
        "api_name": "quantum_instance",
        "full_api_name": "FasterAmplitudeEstimation.quantum_instance",
        "api_description": "Deprecated. Get the quantum instance.\n\nReturns:\n    The quantum instance used to run this algorithm.",
        "api_signature": "quantum_instance(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/fae.py"
    },
    {
        "api_name": "quantum_instance",
        "full_api_name": "FasterAmplitudeEstimation.quantum_instance",
        "api_description": "Deprecated. Set quantum instance.\n\nArgs:\n    quantum_instance: The quantum instance used to run this algorithm.",
        "api_signature": "quantum_instance(self, quantum_instance)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/fae.py"
    },
    {
        "api_name": "_cos_estimate",
        "full_api_name": "FasterAmplitudeEstimation._cos_estimate",
        "api_description": "",
        "api_signature": "_cos_estimate(self, estimation_problem, k, shots)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/fae.py"
    },
    {
        "api_name": "_chernoff",
        "full_api_name": "FasterAmplitudeEstimation._chernoff",
        "api_description": "",
        "api_signature": "_chernoff(self, cos, shots)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/fae.py"
    },
    {
        "api_name": "construct_circuit",
        "full_api_name": "FasterAmplitudeEstimation.construct_circuit",
        "api_description": "Construct the circuit :math:`Q^k X |0\\rangle>`.\n\nThe A operator is the unitary specifying the QAE problem and Q the associated Grover\noperator.\n\nArgs:\n    estimation_problem: The estimation problem for which to construct the circuit.\n    k: The power of the Q operator.\n    measurement: Boolean flag to indicate if measurements should be included in the\n        circuits.\n\nReturns:\n    The circuit :math:`Q^k X |0\\rangle`.",
        "api_signature": "construct_circuit(self, estimation_problem, k, measurement)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/fae.py"
    },
    {
        "api_name": "estimate",
        "full_api_name": "FasterAmplitudeEstimation.estimate",
        "api_description": "Run the amplitude estimation algorithm on provided estimation problem.\n\nArgs:\n    estimation_problem: The estimation problem.\n\nReturns:\n    An amplitude estimation results object.\n\nRaises:\n    ValueError: A quantum instance or Sampler must be provided.\n    AlgorithmError: Sampler run error.",
        "api_signature": "estimate(self, estimation_problem)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/fae.py"
    },
    {
        "api_name": "cos_estimate",
        "full_api_name": "FasterAmplitudeEstimation.cos_estimate",
        "api_description": "",
        "api_signature": "cos_estimate(power, shots)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/fae.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "FasterAmplitudeEstimationResult.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/fae.py"
    },
    {
        "api_name": "success_probability",
        "full_api_name": "FasterAmplitudeEstimationResult.success_probability",
        "api_description": "Return the success probability of the algorithm.",
        "api_signature": "success_probability(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/fae.py"
    },
    {
        "api_name": "success_probability",
        "full_api_name": "FasterAmplitudeEstimationResult.success_probability",
        "api_description": "Set the success probability of the algorithm.",
        "api_signature": "success_probability(self, probability)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/fae.py"
    },
    {
        "api_name": "num_steps",
        "full_api_name": "FasterAmplitudeEstimationResult.num_steps",
        "api_description": "Return the total number of steps taken in the algorithm.",
        "api_signature": "num_steps(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/fae.py"
    },
    {
        "api_name": "num_steps",
        "full_api_name": "FasterAmplitudeEstimationResult.num_steps",
        "api_description": "Set the total number of steps taken in the algorithm.",
        "api_signature": "num_steps(self, num_steps)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/fae.py"
    },
    {
        "api_name": "num_first_state_steps",
        "full_api_name": "FasterAmplitudeEstimationResult.num_first_state_steps",
        "api_description": "Return the number of steps taken in the first step of algorithm.",
        "api_signature": "num_first_state_steps(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/fae.py"
    },
    {
        "api_name": "num_first_state_steps",
        "full_api_name": "FasterAmplitudeEstimationResult.num_first_state_steps",
        "api_description": "Set the number of steps taken in the first step of algorithm.",
        "api_signature": "num_first_state_steps(self, num_steps)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/fae.py"
    },
    {
        "api_name": "theta_intervals",
        "full_api_name": "FasterAmplitudeEstimationResult.theta_intervals",
        "api_description": "Return the confidence intervals for the angles in each iteration.",
        "api_signature": "theta_intervals(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/fae.py"
    },
    {
        "api_name": "theta_intervals",
        "full_api_name": "FasterAmplitudeEstimationResult.theta_intervals",
        "api_description": "Set the confidence intervals for the angles in each iteration.",
        "api_signature": "theta_intervals(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/fae.py"
    },
    {
        "api_name": "bisect_max",
        "full_api_name": "bisect_max",
        "api_description": "Find the maximum of the real-valued function f in the interval [a, b] using bisection.\n\nArgs:\n    f (callable): the function to find the maximum of\n    a (float): the lower limit of the interval\n    b (float): the upper limit of the interval\n    steps (int): the maximum number of steps in the bisection\n    minwidth (float): if the current interval is smaller than minwidth stop\n        the search\n    retval (bool): return value\n\nReturns:\n    float: The maximum of f in [a,b] according to this algorithm.",
        "api_signature": "bisect_max(f, a, b, steps, minwidth, retval)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/ae_utils.py"
    },
    {
        "api_name": "_circ_dist",
        "full_api_name": "_circ_dist",
        "api_description": "Circumferential distance function.\n\nFor two angles :math:`x` and :math:`p` on the unit circuit this function is defined as\n\n.. math::\n\n        d(x, p) = \\min_{z \\in [-1, 0, 1]} |z + p - x|\n\nArgs:\n    x (float): first angle\n    p (float): second angle\n\nReturns:\n    float: d(x, p)",
        "api_signature": "_circ_dist(x, p)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/ae_utils.py"
    },
    {
        "api_name": "_derivative_circ_dist",
        "full_api_name": "_derivative_circ_dist",
        "api_description": "Derivative of circumferential distance function.\n\nArgs:\n    x (float): first angle\n    p (float): second angle\n\nReturns:\n    float: The derivative.",
        "api_signature": "_derivative_circ_dist(x, p)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/ae_utils.py"
    },
    {
        "api_name": "_amplitude_to_angle",
        "full_api_name": "_amplitude_to_angle",
        "api_description": "Transform from the amplitude :math:`a \\in [0, 1]` to the generating angle.\n\nIn QAE, the amplitude can be written from a generating angle :math:`\\omega` as\n\n.. math:\n\n    a = \\sin^2(\\pi \\omega)\n\nThis returns the :math:`\\omega` for a given :math:`a`.\n\nArgs:\n    a (float): A value in :math:`[0,1]`.\n\nReturns:\n    float: :math:`\\sin^{-1}(\\sqrt{a}) / \\pi`",
        "api_signature": "_amplitude_to_angle(a)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/ae_utils.py"
    },
    {
        "api_name": "_derivative_amplitude_to_angle",
        "full_api_name": "_derivative_amplitude_to_angle",
        "api_description": "Compute the derivative of ``amplitude_to_angle``.",
        "api_signature": "_derivative_amplitude_to_angle(a)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/ae_utils.py"
    },
    {
        "api_name": "_alpha",
        "full_api_name": "_alpha",
        "api_description": "Helper function for `pdf_a`, alpha = pi * d(omega(x), omega(p)).\n\nHere, omega(x) is `_amplitude_to_angle(x)`.",
        "api_signature": "_alpha(x, p)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/ae_utils.py"
    },
    {
        "api_name": "_derivative_alpha",
        "full_api_name": "_derivative_alpha",
        "api_description": "Compute the derivative of alpha.",
        "api_signature": "_derivative_alpha(x, p)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/ae_utils.py"
    },
    {
        "api_name": "_beta",
        "full_api_name": "_beta",
        "api_description": "Helper function for `pdf_a`, beta = pi * d(1 - omega(x), omega(p)).",
        "api_signature": "_beta(x, p)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/ae_utils.py"
    },
    {
        "api_name": "_derivative_beta",
        "full_api_name": "_derivative_beta",
        "api_description": "Compute the derivative of beta.",
        "api_signature": "_derivative_beta(x, p)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/ae_utils.py"
    },
    {
        "api_name": "_pdf_a_single_angle",
        "full_api_name": "_pdf_a_single_angle",
        "api_description": "Helper function for `pdf_a`.",
        "api_signature": "_pdf_a_single_angle(x, p, m, pi_delta)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/ae_utils.py"
    },
    {
        "api_name": "pdf_a",
        "full_api_name": "pdf_a",
        "api_description": "Return the PDF of a, i.e. the probability of getting the estimate x\n(in [0, 1]) if p (in [0, 1]) is the true value, given that we use m qubits.\n\nArgs:\n    x (float): the grid point\n    p (float): the true value\n    m (float): the number of evaluation qubits\n\nReturns:\n    float: PDF(x|p)",
        "api_signature": "pdf_a(x, p, m)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/ae_utils.py"
    },
    {
        "api_name": "derivative_log_pdf_a",
        "full_api_name": "derivative_log_pdf_a",
        "api_description": "Return the derivative of the logarithm of the PDF of a.\n\nArgs:\n    x (float): the grid point\n    p (float): the true value\n    m (float): the number of evaluation qubits\n\nReturns:\n    float: d/dp log(PDF(x|p))",
        "api_signature": "derivative_log_pdf_a(x, p, m)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/ae_utils.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "MaximumLikelihoodAmplitudeEstimation.__init__",
        "api_description": "Args:\n    evaluation_schedule: If a list, the powers applied to the Grover operator. The list\n        element must be non-negative. If a non-negative integer, an exponential schedule is\n        used where the highest power is 2 to the integer minus 1:\n        `[id, Q^2^0, ..., Q^2^(evaluation_schedule-1)]`.\n    minimizer: A minimizer used to find the minimum of the likelihood function.\n        Defaults to a brute search where the number of evaluation points is determined\n        according to ``evaluation_schedule``. The minimizer takes a function as first\n        argument and a list of (float, float) tuples (as bounds) as second argument and\n        returns a single float which is the found minimum.\n    quantum_instance: Deprecated: Quantum Instance or Backend\n    sampler: A sampler primitive to evaluate the circuits.\n\nRaises:\n    ValueError: If the number of oracle circuits is smaller than 1.",
        "api_signature": "__init__(self, evaluation_schedule, minimizer, quantum_instance, sampler)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/mlae.py"
    },
    {
        "api_name": "default_minimizer",
        "full_api_name": "MaximumLikelihoodAmplitudeEstimation.default_minimizer",
        "api_description": "",
        "api_signature": "default_minimizer(objective_fn, bounds)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/mlae.py"
    },
    {
        "api_name": "sampler",
        "full_api_name": "MaximumLikelihoodAmplitudeEstimation.sampler",
        "api_description": "Get the sampler primitive.\n\nReturns:\n    The sampler primitive to evaluate the circuits.",
        "api_signature": "sampler(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/mlae.py"
    },
    {
        "api_name": "sampler",
        "full_api_name": "MaximumLikelihoodAmplitudeEstimation.sampler",
        "api_description": "Set sampler primitive.\n\nArgs:\n    sampler: A sampler primitive to evaluate the circuits.",
        "api_signature": "sampler(self, sampler)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/mlae.py"
    },
    {
        "api_name": "quantum_instance",
        "full_api_name": "MaximumLikelihoodAmplitudeEstimation.quantum_instance",
        "api_description": "Deprecated. Get the quantum instance.\n\nReturns:\n    The quantum instance used to run this algorithm.",
        "api_signature": "quantum_instance(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/mlae.py"
    },
    {
        "api_name": "quantum_instance",
        "full_api_name": "MaximumLikelihoodAmplitudeEstimation.quantum_instance",
        "api_description": "Deprecated. Set quantum instance.\n\nArgs:\n    quantum_instance: The quantum instance used to run this algorithm.",
        "api_signature": "quantum_instance(self, quantum_instance)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/mlae.py"
    },
    {
        "api_name": "construct_circuits",
        "full_api_name": "MaximumLikelihoodAmplitudeEstimation.construct_circuits",
        "api_description": "Construct the Amplitude Estimation w/o QPE quantum circuits.\n\nArgs:\n    estimation_problem: The estimation problem for which to construct the QAE circuit.\n    measurement: Boolean flag to indicate if measurement should be included in the circuits.\n\nReturns:\n    A list with the QuantumCircuit objects for the algorithm.",
        "api_signature": "construct_circuits(self, estimation_problem, measurement)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/mlae.py"
    },
    {
        "api_name": "compute_confidence_interval",
        "full_api_name": "MaximumLikelihoodAmplitudeEstimation.compute_confidence_interval",
        "api_description": "Compute the `alpha` confidence interval using the method `kind`.\n\nThe confidence level is (1 - `alpha`) and supported kinds are 'fisher',\n'likelihood_ratio' and 'observed_fisher' with shorthand\nnotations 'fi', 'lr' and 'oi', respectively.\n\nArgs:\n    result: A maximum likelihood amplitude estimation result.\n    alpha: The confidence level.\n    kind: The method to compute the confidence interval. Defaults to 'fisher', which\n        computes the theoretical Fisher information.\n    apply_post_processing: If True, apply post-processing to the confidence interval.\n\nReturns:\n    The specified confidence interval.\n\nRaises:\n    AlgorithmError: If `run()` hasn't been called yet.\n    NotImplementedError: If the method `kind` is not supported.",
        "api_signature": "compute_confidence_interval(result, alpha, kind, apply_post_processing)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/mlae.py"
    },
    {
        "api_name": "compute_mle",
        "full_api_name": "MaximumLikelihoodAmplitudeEstimation.compute_mle",
        "api_description": "Compute the MLE via a grid-search.\n\nThis is a stable approach if sufficient gridpoints are used.\n\nArgs:\n    circuit_results: A list of circuit outcomes. Can be counts or statevectors.\n    estimation_problem: The estimation problem containing the evaluation schedule and the\n        number of likelihood function evaluations used to find the minimum.\n    num_state_qubits: The number of state qubits, required for statevector simulations.\n    return_counts: If True, returns the good counts.\n\nReturns:\n    The MLE for the provided result object.",
        "api_signature": "compute_mle(self, circuit_results, estimation_problem, num_state_qubits, return_counts)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/mlae.py"
    },
    {
        "api_name": "loglikelihood",
        "full_api_name": "MaximumLikelihoodAmplitudeEstimation.loglikelihood",
        "api_description": "",
        "api_signature": "loglikelihood(theta)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/mlae.py"
    },
    {
        "api_name": "estimate",
        "full_api_name": "MaximumLikelihoodAmplitudeEstimation.estimate",
        "api_description": "Run the amplitude estimation algorithm on provided estimation problem.\n\nArgs:\n    estimation_problem: The estimation problem.\n\nReturns:\n    An amplitude estimation results object.\n\nRaises:\n    ValueError: A quantum instance or Sampler must be provided.\n    AlgorithmError: If `state_preparation` is not set in\n        `estimation_problem`.\n    AlgorithmError: Sampler job run error",
        "api_signature": "estimate(self, estimation_problem)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/mlae.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "MaximumLikelihoodAmplitudeEstimationResult.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/mlae.py"
    },
    {
        "api_name": "theta",
        "full_api_name": "MaximumLikelihoodAmplitudeEstimationResult.theta",
        "api_description": "Return the estimate for the angle :math:`\\theta`.",
        "api_signature": "theta(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/mlae.py"
    },
    {
        "api_name": "theta",
        "full_api_name": "MaximumLikelihoodAmplitudeEstimationResult.theta",
        "api_description": "Set the estimate for the angle :math:`\\theta`.",
        "api_signature": "theta(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/mlae.py"
    },
    {
        "api_name": "minimizer",
        "full_api_name": "MaximumLikelihoodAmplitudeEstimationResult.minimizer",
        "api_description": "Return the minimizer used for the search of the likelihood function.",
        "api_signature": "minimizer(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/mlae.py"
    },
    {
        "api_name": "minimizer",
        "full_api_name": "MaximumLikelihoodAmplitudeEstimationResult.minimizer",
        "api_description": "Set the number minimizer used for the search of the likelihood function.",
        "api_signature": "minimizer(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/mlae.py"
    },
    {
        "api_name": "good_counts",
        "full_api_name": "MaximumLikelihoodAmplitudeEstimationResult.good_counts",
        "api_description": "Return the percentage of good counts per circuit power.",
        "api_signature": "good_counts(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/mlae.py"
    },
    {
        "api_name": "good_counts",
        "full_api_name": "MaximumLikelihoodAmplitudeEstimationResult.good_counts",
        "api_description": "Set the percentage of good counts per circuit power.",
        "api_signature": "good_counts(self, counts)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/mlae.py"
    },
    {
        "api_name": "evaluation_schedule",
        "full_api_name": "MaximumLikelihoodAmplitudeEstimationResult.evaluation_schedule",
        "api_description": "Return the evaluation schedule for the powers of the Grover operator.",
        "api_signature": "evaluation_schedule(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/mlae.py"
    },
    {
        "api_name": "evaluation_schedule",
        "full_api_name": "MaximumLikelihoodAmplitudeEstimationResult.evaluation_schedule",
        "api_description": "Set the evaluation schedule for the powers of the Grover operator.",
        "api_signature": "evaluation_schedule(self, evaluation_schedule)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/mlae.py"
    },
    {
        "api_name": "fisher_information",
        "full_api_name": "MaximumLikelihoodAmplitudeEstimationResult.fisher_information",
        "api_description": "Return the Fisher information for the estimated amplitude.",
        "api_signature": "fisher_information(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/mlae.py"
    },
    {
        "api_name": "fisher_information",
        "full_api_name": "MaximumLikelihoodAmplitudeEstimationResult.fisher_information",
        "api_description": "Set the Fisher information for the estimated amplitude.",
        "api_signature": "fisher_information(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/mlae.py"
    },
    {
        "api_name": "_safe_min",
        "full_api_name": "_safe_min",
        "api_description": "",
        "api_signature": "_safe_min(array, default)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/mlae.py"
    },
    {
        "api_name": "_safe_max",
        "full_api_name": "_safe_max",
        "api_description": "",
        "api_signature": "_safe_max(array, default)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/mlae.py"
    },
    {
        "api_name": "_compute_fisher_information",
        "full_api_name": "_compute_fisher_information",
        "api_description": "Compute the Fisher information.\n\nArgs:\n    result: A maximum likelihood amplitude estimation result.\n    num_sum_terms: The number of sum terms to be included in the calculation of the\n        Fisher information. By default all values are included.\n    observed: If True, compute the observed Fisher information, otherwise the theoretical\n        one.\n\nReturns:\n    The computed Fisher information, or np.inf if statevector simulation was used.\n\nRaises:\n    KeyError: Call run() first!",
        "api_signature": "_compute_fisher_information(result, num_sum_terms, observed)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/mlae.py"
    },
    {
        "api_name": "_fisher_confint",
        "full_api_name": "_fisher_confint",
        "api_description": "Compute the `alpha` confidence interval based on the Fisher information.\n\nArgs:\n    result: A maximum likelihood amplitude estimation results object.\n    alpha: The level of the confidence interval (must be <= 0.5), default to 0.05.\n    observed: If True, use observed Fisher information.\n\nReturns:\n    float: The alpha confidence interval based on the Fisher information\nRaises:\n    AssertionError: Call run() first!",
        "api_signature": "_fisher_confint(result, alpha, observed)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/mlae.py"
    },
    {
        "api_name": "_likelihood_ratio_confint",
        "full_api_name": "_likelihood_ratio_confint",
        "api_description": "Compute the likelihood-ratio confidence interval.\n\nArgs:\n    result: A maximum likelihood amplitude estimation results object.\n    alpha: The level of the confidence interval (< 0.5), defaults to 0.05.\n    nevals: The number of evaluations to find the intersection with the loglikelihood\n        function. Defaults to an adaptive value based on the maximal power of Q.\n\nReturns:\n    The alpha-likelihood-ratio confidence interval.",
        "api_signature": "_likelihood_ratio_confint(result, alpha, nevals)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/mlae.py"
    },
    {
        "api_name": "loglikelihood",
        "full_api_name": "loglikelihood",
        "api_description": "",
        "api_signature": "loglikelihood(theta, one_counts, all_counts)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/mlae.py"
    },
    {
        "api_name": "_get_counts",
        "full_api_name": "_get_counts",
        "api_description": "Get the good and total counts.\n\nReturns:\n    A pair of two lists, ([1-counts per experiment], [shots per experiment]).\n\nRaises:\n    AlgorithmError: If self.run() has not been called yet.",
        "api_signature": "_get_counts(circuit_results, estimation_problem, num_state_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/mlae.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "AmplitudeEstimation.__init__",
        "api_description": "Args:\n    num_eval_qubits: The number of evaluation qubits.\n    phase_estimation_circuit: The phase estimation circuit used to run the algorithm.\n        Defaults to the standard phase estimation circuit from the circuit library,\n        `qiskit.circuit.library.PhaseEstimation` when None.\n    iqft: The inverse quantum Fourier transform component, defaults to using a standard\n        implementation from `qiskit.circuit.library.QFT` when None.\n    quantum_instance: Deprecated: The backend (or `QuantumInstance`) to execute\n        the circuits on.\n    sampler: A sampler primitive to evaluate the circuits.\n\nRaises:\n    ValueError: If the number of evaluation qubits is smaller than 1.",
        "api_signature": "__init__(self, num_eval_qubits, phase_estimation_circuit, iqft, quantum_instance, sampler)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/ae.py"
    },
    {
        "api_name": "sampler",
        "full_api_name": "AmplitudeEstimation.sampler",
        "api_description": "Get the sampler primitive.\n\nReturns:\n    The sampler primitive to evaluate the circuits.",
        "api_signature": "sampler(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/ae.py"
    },
    {
        "api_name": "sampler",
        "full_api_name": "AmplitudeEstimation.sampler",
        "api_description": "Set sampler primitive.\n\nArgs:\n    sampler: A sampler primitive to evaluate the circuits.",
        "api_signature": "sampler(self, sampler)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/ae.py"
    },
    {
        "api_name": "quantum_instance",
        "full_api_name": "AmplitudeEstimation.quantum_instance",
        "api_description": "Deprecated: Get the quantum instance.\n\nReturns:\n    The quantum instance used to run this algorithm.",
        "api_signature": "quantum_instance(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/ae.py"
    },
    {
        "api_name": "quantum_instance",
        "full_api_name": "AmplitudeEstimation.quantum_instance",
        "api_description": "Deprecated: Set quantum instance.\n\nArgs:\n    quantum_instance: The quantum instance used to run this algorithm.",
        "api_signature": "quantum_instance(self, quantum_instance)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/ae.py"
    },
    {
        "api_name": "construct_circuit",
        "full_api_name": "AmplitudeEstimation.construct_circuit",
        "api_description": "Construct the Amplitude Estimation quantum circuit.\n\nArgs:\n    estimation_problem: The estimation problem for which to construct the QAE circuit.\n    measurement: Boolean flag to indicate if measurements should be included in the circuit.\n\nReturns:\n    The QuantumCircuit object for the constructed circuit.",
        "api_signature": "construct_circuit(self, estimation_problem, measurement)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/ae.py"
    },
    {
        "api_name": "evaluate_measurements",
        "full_api_name": "AmplitudeEstimation.evaluate_measurements",
        "api_description": "Evaluate the results from the circuit simulation.\n\nGiven the probabilities from statevector simulation of the QAE circuit, compute the\nprobabilities that the measurements y/gridpoints a are the best estimate.\n\nArgs:\n    circuit_results: The circuit result from the QAE circuit. Can be either a counts dict\n        or a statevector or a quasi-probabilities dict.\n    threshold: Measurements with probabilities below the threshold are discarded.\n\nReturns:\n    Dictionaries containing the a gridpoints with respective probabilities and\n        y measurements with respective probabilities, in this order.",
        "api_signature": "evaluate_measurements(self, circuit_results, threshold)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/ae.py"
    },
    {
        "api_name": "_evaluate_statevector_results",
        "full_api_name": "AmplitudeEstimation._evaluate_statevector_results",
        "api_description": "",
        "api_signature": "_evaluate_statevector_results(self, statevector)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/ae.py"
    },
    {
        "api_name": "_evaluate_quasi_probabilities_results",
        "full_api_name": "AmplitudeEstimation._evaluate_quasi_probabilities_results",
        "api_description": "",
        "api_signature": "_evaluate_quasi_probabilities_results(self, circuit_results)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/ae.py"
    },
    {
        "api_name": "_evaluate_count_results",
        "full_api_name": "AmplitudeEstimation._evaluate_count_results",
        "api_description": "",
        "api_signature": "_evaluate_count_results(self, counts)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/ae.py"
    },
    {
        "api_name": "compute_mle",
        "full_api_name": "AmplitudeEstimation.compute_mle",
        "api_description": "Compute the Maximum Likelihood Estimator (MLE).\n\nArgs:\n    result: An amplitude estimation result object.\n    apply_post_processing: If True, apply the post processing to the MLE before returning\n        it.\n\nReturns:\n    The MLE for the provided result object.",
        "api_signature": "compute_mle(result, apply_post_processing)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/ae.py"
    },
    {
        "api_name": "loglikelihood",
        "full_api_name": "AmplitudeEstimation.loglikelihood",
        "api_description": "",
        "api_signature": "loglikelihood(a)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/ae.py"
    },
    {
        "api_name": "estimate",
        "full_api_name": "AmplitudeEstimation.estimate",
        "api_description": "Run the amplitude estimation algorithm on provided estimation problem.\n\nArgs:\n    estimation_problem: The estimation problem.\n\nReturns:\n    An amplitude estimation results object.\n\nRaises:\n    ValueError: If `state_preparation` or `objective_qubits` are not set in the\n        `estimation_problem`.\n    ValueError: A quantum instance or sampler must be provided.\n    AlgorithmError: Sampler job run error.",
        "api_signature": "estimate(self, estimation_problem)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/ae.py"
    },
    {
        "api_name": "compute_confidence_interval",
        "full_api_name": "AmplitudeEstimation.compute_confidence_interval",
        "api_description": "Compute the (1 - alpha) confidence interval.\n\nArgs:\n    result: An amplitude estimation result for which to compute the confidence interval.\n    alpha: Confidence level: compute the (1 - alpha) confidence interval.\n    kind: The method to compute the confidence interval, can be 'fisher', 'observed_fisher'\n        or 'likelihood_ratio' (default)\n\nReturns:\n    The (1 - alpha) confidence interval of the specified kind.\n\nRaises:\n    NotImplementedError: If the confidence interval method `kind` is not implemented.",
        "api_signature": "compute_confidence_interval(result, alpha, kind)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/ae.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "AmplitudeEstimationResult.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/ae.py"
    },
    {
        "api_name": "num_evaluation_qubits",
        "full_api_name": "AmplitudeEstimationResult.num_evaluation_qubits",
        "api_description": "Returns the number of evaluation qubits.",
        "api_signature": "num_evaluation_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/ae.py"
    },
    {
        "api_name": "num_evaluation_qubits",
        "full_api_name": "AmplitudeEstimationResult.num_evaluation_qubits",
        "api_description": "Set the number of evaluation qubits.",
        "api_signature": "num_evaluation_qubits(self, num_evaluation_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/ae.py"
    },
    {
        "api_name": "mle_processed",
        "full_api_name": "AmplitudeEstimationResult.mle_processed",
        "api_description": "Return the post-processed MLE for the amplitude.",
        "api_signature": "mle_processed(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/ae.py"
    },
    {
        "api_name": "mle_processed",
        "full_api_name": "AmplitudeEstimationResult.mle_processed",
        "api_description": "Set the post-processed MLE for the amplitude.",
        "api_signature": "mle_processed(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/ae.py"
    },
    {
        "api_name": "samples_processed",
        "full_api_name": "AmplitudeEstimationResult.samples_processed",
        "api_description": "Return the post-processed measurement samples with their measurement probability.",
        "api_signature": "samples_processed(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/ae.py"
    },
    {
        "api_name": "samples_processed",
        "full_api_name": "AmplitudeEstimationResult.samples_processed",
        "api_description": "Set the post-processed measurement samples.",
        "api_signature": "samples_processed(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/ae.py"
    },
    {
        "api_name": "mle",
        "full_api_name": "AmplitudeEstimationResult.mle",
        "api_description": "Return the MLE for the amplitude, in $[0, 1]$.",
        "api_signature": "mle(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/ae.py"
    },
    {
        "api_name": "mle",
        "full_api_name": "AmplitudeEstimationResult.mle",
        "api_description": "Set the MLE for the amplitude, in $[0, 1]$.",
        "api_signature": "mle(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/ae.py"
    },
    {
        "api_name": "samples",
        "full_api_name": "AmplitudeEstimationResult.samples",
        "api_description": "Return the measurement samples with their measurement probability.",
        "api_signature": "samples(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/ae.py"
    },
    {
        "api_name": "samples",
        "full_api_name": "AmplitudeEstimationResult.samples",
        "api_description": "Set the measurement samples with their measurement probability.",
        "api_signature": "samples(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/ae.py"
    },
    {
        "api_name": "measurements",
        "full_api_name": "AmplitudeEstimationResult.measurements",
        "api_description": "Return the measurements as integers with their measurement probability.",
        "api_signature": "measurements(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/ae.py"
    },
    {
        "api_name": "measurements",
        "full_api_name": "AmplitudeEstimationResult.measurements",
        "api_description": "Set the measurements as integers with their measurement probability.",
        "api_signature": "measurements(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/ae.py"
    },
    {
        "api_name": "max_probability",
        "full_api_name": "AmplitudeEstimationResult.max_probability",
        "api_description": "Return the maximum sampling probability.",
        "api_signature": "max_probability(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/ae.py"
    },
    {
        "api_name": "max_probability",
        "full_api_name": "AmplitudeEstimationResult.max_probability",
        "api_description": "Set the maximum sampling probability.",
        "api_signature": "max_probability(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/ae.py"
    },
    {
        "api_name": "_compute_fisher_information",
        "full_api_name": "_compute_fisher_information",
        "api_description": "Computes the Fisher information for the output of the previous run.\n\nArgs:\n    result: An amplitude estimation result for which to compute the confidence interval.\n    observed: If True, the observed Fisher information is returned, otherwise\n        the expected Fisher information.\n\nReturns:\n    The Fisher information.",
        "api_signature": "_compute_fisher_information(result, observed)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/ae.py"
    },
    {
        "api_name": "integrand",
        "full_api_name": "integrand",
        "api_description": "",
        "api_signature": "integrand(x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/ae.py"
    },
    {
        "api_name": "_fisher_confint",
        "full_api_name": "_fisher_confint",
        "api_description": "Compute the Fisher information confidence interval for the MLE of the previous run.\n\nArgs:\n    result: An amplitude estimation result for which to compute the confidence interval.\n    alpha: Specifies the (1 - alpha) confidence level (0 < alpha < 1).\n    observed: If True, the observed Fisher information is used to construct the\n        confidence interval, otherwise the expected Fisher information.\n\nReturns:\n    The Fisher information confidence interval.",
        "api_signature": "_fisher_confint(result, alpha, observed)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/ae.py"
    },
    {
        "api_name": "_likelihood_ratio_confint",
        "full_api_name": "_likelihood_ratio_confint",
        "api_description": "Compute the likelihood ratio confidence interval for the MLE of the previous run.\n\nArgs:\n    result: An amplitude estimation result for which to compute the confidence interval.\n    alpha: Specifies the (1 - alpha) confidence level (0 < alpha < 1).\n\nReturns:\n    The likelihood ratio confidence interval.",
        "api_signature": "_likelihood_ratio_confint(result, alpha)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/ae.py"
    },
    {
        "api_name": "loglikelihood",
        "full_api_name": "loglikelihood",
        "api_description": "",
        "api_signature": "loglikelihood(a)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/ae.py"
    },
    {
        "api_name": "cut",
        "full_api_name": "cut",
        "api_description": "",
        "api_signature": "cut(x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/ae.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "IterativeAmplitudeEstimation.__init__",
        "api_description": "The output of the algorithm is an estimate for the amplitude `a`, that with at least\nprobability 1 - alpha has an error of epsilon. The number of A operator calls scales\nlinearly in 1/epsilon (up to a logarithmic factor).\n\nArgs:\n    epsilon_target: Target precision for estimation target `a`, has values between 0 and 0.5\n    alpha: Confidence level, the target probability is 1 - alpha, has values between 0 and 1\n    confint_method: Statistical method used to estimate the confidence intervals in\n        each iteration, can be 'chernoff' for the Chernoff intervals or 'beta' for the\n        Clopper-Pearson intervals (default)\n    min_ratio: Minimal q-ratio (:math:`K_{i+1} / K_i`) for FindNextK\n    quantum_instance: Deprecated: Quantum Instance or Backend\n    sampler: A sampler primitive to evaluate the circuits.\n\nRaises:\n    AlgorithmError: if the method to compute the confidence intervals is not supported\n    ValueError: If the target epsilon is not in (0, 0.5]\n    ValueError: If alpha is not in (0, 1)\n    ValueError: If confint_method is not supported",
        "api_signature": "__init__(self, epsilon_target, alpha, confint_method, min_ratio, quantum_instance, sampler)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/iae.py"
    },
    {
        "api_name": "sampler",
        "full_api_name": "IterativeAmplitudeEstimation.sampler",
        "api_description": "Get the sampler primitive.\n\nReturns:\n    The sampler primitive to evaluate the circuits.",
        "api_signature": "sampler(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/iae.py"
    },
    {
        "api_name": "sampler",
        "full_api_name": "IterativeAmplitudeEstimation.sampler",
        "api_description": "Set sampler primitive.\n\nArgs:\n    sampler: A sampler primitive to evaluate the circuits.",
        "api_signature": "sampler(self, sampler)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/iae.py"
    },
    {
        "api_name": "quantum_instance",
        "full_api_name": "IterativeAmplitudeEstimation.quantum_instance",
        "api_description": "Deprecated. Get the quantum instance.\n\nReturns:\n    The quantum instance used to run this algorithm.",
        "api_signature": "quantum_instance(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/iae.py"
    },
    {
        "api_name": "quantum_instance",
        "full_api_name": "IterativeAmplitudeEstimation.quantum_instance",
        "api_description": "Deprecated. Set quantum instance.\n\nArgs:\n    quantum_instance: The quantum instance used to run this algorithm.",
        "api_signature": "quantum_instance(self, quantum_instance)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/iae.py"
    },
    {
        "api_name": "epsilon_target",
        "full_api_name": "IterativeAmplitudeEstimation.epsilon_target",
        "api_description": "Returns the target precision ``epsilon_target`` of the algorithm.\n\nReturns:\n    The target precision (which is half the width of the confidence interval).",
        "api_signature": "epsilon_target(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/iae.py"
    },
    {
        "api_name": "epsilon_target",
        "full_api_name": "IterativeAmplitudeEstimation.epsilon_target",
        "api_description": "Set the target precision of the algorithm.\n\nArgs:\n    epsilon: Target precision for estimation target `a`.",
        "api_signature": "epsilon_target(self, epsilon)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/iae.py"
    },
    {
        "api_name": "_find_next_k",
        "full_api_name": "IterativeAmplitudeEstimation._find_next_k",
        "api_description": "Find the largest integer k_next, such that the interval (4 * k_next + 2)*theta_interval\nlies completely in [0, pi] or [pi, 2pi], for theta_interval = (theta_lower, theta_upper).\n\nArgs:\n    k: The current power of the Q operator.\n    upper_half_circle: Boolean flag of whether theta_interval lies in the\n        upper half-circle [0, pi] or in the lower one [pi, 2pi].\n    theta_interval: The current confidence interval for the angle theta,\n        i.e. (theta_lower, theta_upper).\n    min_ratio: Minimal ratio K/K_next allowed in the algorithm.\n\nReturns:\n    The next power k, and boolean flag for the extrapolated interval.\n\nRaises:\n    AlgorithmError: if min_ratio is smaller or equal to 1",
        "api_signature": "_find_next_k(self, k, upper_half_circle, theta_interval, min_ratio)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/iae.py"
    },
    {
        "api_name": "construct_circuit",
        "full_api_name": "IterativeAmplitudeEstimation.construct_circuit",
        "api_description": "Construct the circuit :math:`\\mathcal{Q}^k \\mathcal{A} |0\\rangle`.\n\nThe A operator is the unitary specifying the QAE problem and Q the associated Grover\noperator.\n\nArgs:\n    estimation_problem: The estimation problem for which to construct the QAE circuit.\n    k: The power of the Q operator.\n    measurement: Boolean flag to indicate if measurements should be included in the\n        circuits.\n\nReturns:\n    The circuit implementing :math:`\\mathcal{Q}^k \\mathcal{A} |0\\rangle`.",
        "api_signature": "construct_circuit(self, estimation_problem, k, measurement)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/iae.py"
    },
    {
        "api_name": "_good_state_probability",
        "full_api_name": "IterativeAmplitudeEstimation._good_state_probability",
        "api_description": "Get the probability to measure '1' in the last qubit.\n\nArgs:\n    problem: The estimation problem, used to obtain the number of objective qubits and\n        the ``is_good_state`` function.\n    counts_or_statevector: Either a counts-dictionary (with one measured qubit only!) or\n        the statevector returned from the statevector_simulator.\n    num_state_qubits: The number of state qubits.\n\nReturns:\n    If a dict is given, return (#one-counts, #one-counts/#all-counts),\n    otherwise Pr(measure '1' in the last qubit).",
        "api_signature": "_good_state_probability(self, problem, counts_or_statevector, num_state_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/iae.py"
    },
    {
        "api_name": "estimate",
        "full_api_name": "IterativeAmplitudeEstimation.estimate",
        "api_description": "Run the amplitude estimation algorithm on provided estimation problem.\n\nArgs:\n    estimation_problem: The estimation problem.\n\nReturns:\n    An amplitude estimation results object.\n\nRaises:\n    ValueError: A quantum instance or Sampler must be provided.\n    AlgorithmError: Sampler job run error.",
        "api_signature": "estimate(self, estimation_problem)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/iae.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "IterativeAmplitudeEstimationResult.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/iae.py"
    },
    {
        "api_name": "alpha",
        "full_api_name": "IterativeAmplitudeEstimationResult.alpha",
        "api_description": "Return the confidence level :math:`\\alpha`.",
        "api_signature": "alpha(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/iae.py"
    },
    {
        "api_name": "alpha",
        "full_api_name": "IterativeAmplitudeEstimationResult.alpha",
        "api_description": "Set the confidence level :math:`\\alpha`.",
        "api_signature": "alpha(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/iae.py"
    },
    {
        "api_name": "epsilon_target",
        "full_api_name": "IterativeAmplitudeEstimationResult.epsilon_target",
        "api_description": "Return the target half-width of the confidence interval.",
        "api_signature": "epsilon_target(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/iae.py"
    },
    {
        "api_name": "epsilon_target",
        "full_api_name": "IterativeAmplitudeEstimationResult.epsilon_target",
        "api_description": "Set the target half-width of the confidence interval.",
        "api_signature": "epsilon_target(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/iae.py"
    },
    {
        "api_name": "epsilon_estimated",
        "full_api_name": "IterativeAmplitudeEstimationResult.epsilon_estimated",
        "api_description": "Return the estimated half-width of the confidence interval.",
        "api_signature": "epsilon_estimated(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/iae.py"
    },
    {
        "api_name": "epsilon_estimated",
        "full_api_name": "IterativeAmplitudeEstimationResult.epsilon_estimated",
        "api_description": "Set the estimated half-width of the confidence interval.",
        "api_signature": "epsilon_estimated(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/iae.py"
    },
    {
        "api_name": "epsilon_estimated_processed",
        "full_api_name": "IterativeAmplitudeEstimationResult.epsilon_estimated_processed",
        "api_description": "Return the post-processed estimated half-width of the confidence interval.",
        "api_signature": "epsilon_estimated_processed(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/iae.py"
    },
    {
        "api_name": "epsilon_estimated_processed",
        "full_api_name": "IterativeAmplitudeEstimationResult.epsilon_estimated_processed",
        "api_description": "Set the post-processed estimated half-width of the confidence interval.",
        "api_signature": "epsilon_estimated_processed(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/iae.py"
    },
    {
        "api_name": "estimate_intervals",
        "full_api_name": "IterativeAmplitudeEstimationResult.estimate_intervals",
        "api_description": "Return the confidence intervals for the estimate in each iteration.",
        "api_signature": "estimate_intervals(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/iae.py"
    },
    {
        "api_name": "estimate_intervals",
        "full_api_name": "IterativeAmplitudeEstimationResult.estimate_intervals",
        "api_description": "Set the confidence intervals for the estimate in each iteration.",
        "api_signature": "estimate_intervals(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/iae.py"
    },
    {
        "api_name": "theta_intervals",
        "full_api_name": "IterativeAmplitudeEstimationResult.theta_intervals",
        "api_description": "Return the confidence intervals for the angles in each iteration.",
        "api_signature": "theta_intervals(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/iae.py"
    },
    {
        "api_name": "theta_intervals",
        "full_api_name": "IterativeAmplitudeEstimationResult.theta_intervals",
        "api_description": "Set the confidence intervals for the angles in each iteration.",
        "api_signature": "theta_intervals(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/iae.py"
    },
    {
        "api_name": "powers",
        "full_api_name": "IterativeAmplitudeEstimationResult.powers",
        "api_description": "Return the powers of the Grover operator in each iteration.",
        "api_signature": "powers(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/iae.py"
    },
    {
        "api_name": "powers",
        "full_api_name": "IterativeAmplitudeEstimationResult.powers",
        "api_description": "Set the powers of the Grover operator in each iteration.",
        "api_signature": "powers(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/iae.py"
    },
    {
        "api_name": "ratios",
        "full_api_name": "IterativeAmplitudeEstimationResult.ratios",
        "api_description": "Return the ratios :math:`K_{i+1}/K_{i}` for each iteration :math:`i`.",
        "api_signature": "ratios(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/iae.py"
    },
    {
        "api_name": "ratios",
        "full_api_name": "IterativeAmplitudeEstimationResult.ratios",
        "api_description": "Set the ratios :math:`K_{i+1}/K_{i}` for each iteration :math:`i`.",
        "api_signature": "ratios(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/iae.py"
    },
    {
        "api_name": "confidence_interval_processed",
        "full_api_name": "IterativeAmplitudeEstimationResult.confidence_interval_processed",
        "api_description": "Return the post-processed confidence interval.",
        "api_signature": "confidence_interval_processed(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/iae.py"
    },
    {
        "api_name": "confidence_interval_processed",
        "full_api_name": "IterativeAmplitudeEstimationResult.confidence_interval_processed",
        "api_description": "Set the post-processed confidence interval.",
        "api_signature": "confidence_interval_processed(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/iae.py"
    },
    {
        "api_name": "_chernoff_confint",
        "full_api_name": "_chernoff_confint",
        "api_description": "Compute the Chernoff confidence interval for `shots` i.i.d. Bernoulli trials.\n\nThe confidence interval is\n\n    [value - eps, value + eps], where eps = sqrt(3 * log(2 * max_rounds/ alpha) / shots)\n\nbut at most [0, 1].\n\nArgs:\n    value: The current estimate.\n    shots: The number of shots.\n    max_rounds: The maximum number of rounds, used to compute epsilon_a.\n    alpha: The confidence level, used to compute epsilon_a.\n\nReturns:\n    The Chernoff confidence interval.",
        "api_signature": "_chernoff_confint(value, shots, max_rounds, alpha)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/iae.py"
    },
    {
        "api_name": "_clopper_pearson_confint",
        "full_api_name": "_clopper_pearson_confint",
        "api_description": "Compute the Clopper-Pearson confidence interval for `shots` i.i.d. Bernoulli trials.\n\nArgs:\n    counts: The number of positive counts.\n    shots: The number of shots.\n    alpha: The confidence level for the confidence interval.\n\nReturns:\n    The Clopper-Pearson confidence interval.",
        "api_signature": "_clopper_pearson_confint(counts, shots, alpha)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/iae.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "EstimationProblem.__init__",
        "api_description": "Args:\n    state_preparation: A circuit preparing the input state, referred to as\n        :math:`\\mathcal{A}`.\n    objective_qubits: A single qubit index or a list of qubit indices to specify which\n        qubits to measure. The ``is_good_state`` function is applied on the bitstring of\n        these objective qubits.\n    grover_operator: The Grover operator :math:`\\mathcal{Q}` used as unitary in the\n        phase estimation circuit.\n    post_processing: A mapping applied to the result of the algorithm\n        :math:`0 \\leq a \\leq 1`, usually used to map the estimate to a target interval.\n        Defaults to the identity.\n    is_good_state: A function to check whether a string represents a good state. Defaults\n        to all objective qubits being in state :math:`|1\\rangle`.",
        "api_signature": "__init__(self, state_preparation, objective_qubits, grover_operator, post_processing, is_good_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/estimation_problem.py"
    },
    {
        "api_name": "state_preparation",
        "full_api_name": "EstimationProblem.state_preparation",
        "api_description": "Get the :math:`\\mathcal{A}` operator encoding the amplitude :math:`a`.\n\nReturns:\n    The :math:`\\mathcal{A}` operator as `QuantumCircuit`.",
        "api_signature": "state_preparation(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/estimation_problem.py"
    },
    {
        "api_name": "state_preparation",
        "full_api_name": "EstimationProblem.state_preparation",
        "api_description": "Set the :math:`\\mathcal{A}` operator, that encodes the amplitude to be estimated.\n\nArgs:\n    state_preparation: The new :math:`\\mathcal{A}` operator.",
        "api_signature": "state_preparation(self, state_preparation)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/estimation_problem.py"
    },
    {
        "api_name": "objective_qubits",
        "full_api_name": "EstimationProblem.objective_qubits",
        "api_description": "Get the criterion for a measurement outcome to be in a 'good' state.\n\nReturns:\n    The criterion as list of qubit indices.",
        "api_signature": "objective_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/estimation_problem.py"
    },
    {
        "api_name": "objective_qubits",
        "full_api_name": "EstimationProblem.objective_qubits",
        "api_description": "Set the criterion for a measurement outcome to be in a 'good' state.\n\nArgs:\n    objective_qubits: The criterion as callable of list of qubit indices.",
        "api_signature": "objective_qubits(self, objective_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/estimation_problem.py"
    },
    {
        "api_name": "post_processing",
        "full_api_name": "EstimationProblem.post_processing",
        "api_description": "Apply post processing to the input value.\n\nReturns:\n    A handle to the post processing function. Acts as identity by default.",
        "api_signature": "post_processing(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/estimation_problem.py"
    },
    {
        "api_name": "post_processing",
        "full_api_name": "EstimationProblem.post_processing",
        "api_description": "Set the post processing function.\n\nArgs:\n    post_processing: A handle to the post processing function. If set to ``None``, the\n        identity will be used as post processing.",
        "api_signature": "post_processing(self, post_processing)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/estimation_problem.py"
    },
    {
        "api_name": "has_good_state",
        "full_api_name": "EstimationProblem.has_good_state",
        "api_description": "Check whether an :attr:`is_good_state` function is set.\n\nSome amplitude estimators, such as :class:`.AmplitudeEstimation` do not support\na custom implementation of the :attr:`is_good_state` function, and can only handle\nthe default.\n\nReturns:\n    ``True``, if a custom :attr:`is_good_state` is set, otherwise returns ``False``.",
        "api_signature": "has_good_state(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/estimation_problem.py"
    },
    {
        "api_name": "is_good_state",
        "full_api_name": "EstimationProblem.is_good_state",
        "api_description": "Checks whether a bitstring represents a good state.\n\nReturns:\n    Handle to the ``is_good_state`` callable.",
        "api_signature": "is_good_state(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/estimation_problem.py"
    },
    {
        "api_name": "is_good_state",
        "full_api_name": "EstimationProblem.is_good_state",
        "api_description": "Set the ``is_good_state`` function.\n\nArgs:\n    is_good_state: A function to determine whether a bitstring represents a good state.\n        If set to ``None``, the good state will be defined as all bits being one.",
        "api_signature": "is_good_state(self, is_good_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/estimation_problem.py"
    },
    {
        "api_name": "grover_operator",
        "full_api_name": "EstimationProblem.grover_operator",
        "api_description": "Get the :math:`\\mathcal{Q}` operator, or Grover operator.\n\nIf the Grover operator is not set, we try to build it from the :math:`\\mathcal{A}` operator\nand `objective_qubits`. This only works if `objective_qubits` is a list of integers.\n\nReturns:\n    The Grover operator, or None if neither the Grover operator nor the\n    :math:`\\mathcal{A}` operator is  set.",
        "api_signature": "grover_operator(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/estimation_problem.py"
    },
    {
        "api_name": "grover_operator",
        "full_api_name": "EstimationProblem.grover_operator",
        "api_description": "Set the :math:`\\mathcal{Q}` operator.\n\nArgs:\n    grover_operator: The new :math:`\\mathcal{Q}` operator. If set to ``None``,\n        the default construction via ``qiskit.circuit.library.GroverOperator`` is used.",
        "api_signature": "grover_operator(self, grover_operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/estimation_problem.py"
    },
    {
        "api_name": "rescale",
        "full_api_name": "EstimationProblem.rescale",
        "api_description": "Rescale the good state amplitude in the estimation problem.\n\nArgs:\n    scaling_factor: The scaling factor in [0, 1].\n\nReturns:\n    A rescaled estimation problem.",
        "api_signature": "rescale(self, scaling_factor)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/estimation_problem.py"
    },
    {
        "api_name": "is_good_state",
        "full_api_name": "EstimationProblem.is_good_state",
        "api_description": "",
        "api_signature": "is_good_state(bitstr)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/estimation_problem.py"
    },
    {
        "api_name": "_rescale_amplitudes",
        "full_api_name": "_rescale_amplitudes",
        "api_description": "Uses an auxiliary qubit to scale the amplitude of :math:`|1\\rangle` by ``scaling_factor``.\n\nExplained in Section 2.1. of [1].\n\nFor example, for a scaling factor of 0.25 this turns this circuit\n\n.. parsed-literal::\n\n                  \u250c\u2500\u2500\u2500\u2510\n    state_0: \u2500\u2500\u2500\u2500\u2500\u2524 H \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\n              \u250c\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2510\n      obj_0: \u2500\u2524 RY(0.125) \u251c\u2500\u2524 RY(1) \u251c\n              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\ninto\n\n.. parsed-literal::\n\n                  \u250c\u2500\u2500\u2500\u2510\n    state_0: \u2500\u2500\u2500\u2500\u2500\u2524 H \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\n              \u250c\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2510\n      obj_0: \u2500\u2524 RY(0.125) \u251c\u2500\u2524 RY(1) \u251c\n             \u250c\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2510\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n  scaling_0: \u2524 RY(0.50536) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nReferences:\n\n    [1]: K. Nakaji. Faster Amplitude Estimation, 2020;\n        `arXiv:2002.02417 <https://arxiv.org/pdf/2003.02417.pdf>`_\n\nArgs:\n    circuit: The circuit whose amplitudes to rescale.\n    scaling_factor: The rescaling factor.\n\nReturns:\n    A copy of the circuit with an additional qubit and RY gate for the rescaling.",
        "api_signature": "_rescale_amplitudes(circuit, scaling_factor)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_estimators/estimation_problem.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "AmplificationProblem.__init__",
        "api_description": "Args:\n    oracle: The oracle reflecting about the bad states.\n    state_preparation: A circuit preparing the input state, referred to as\n        :math:`\\mathcal{A}`. If None, a layer of Hadamard gates is used.\n    grover_operator: The Grover operator :math:`\\mathcal{Q}` used as unitary in the\n        phase estimation circuit. If None, this operator is constructed from the ``oracle``\n        and ``state_preparation``.\n    post_processing: A mapping applied to the most likely bitstring.\n    objective_qubits: If set, specifies the indices of the qubits that should be measured.\n        If None, all qubits will be measured. The ``is_good_state`` function will be\n        applied on the measurement outcome of these qubits.\n    is_good_state: A function to check whether a string represents a good state. By default\n        if the ``oracle`` argument has an ``evaluate_bitstring`` method (currently only\n        provided by the :class:`~qiskit.circuit.library.PhaseOracle` class) this will be\n        used, otherwise this kwarg is required and **must** be specified.",
        "api_signature": "__init__(self, oracle, state_preparation, grover_operator, post_processing, objective_qubits, is_good_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_amplifiers/amplification_problem.py"
    },
    {
        "api_name": "oracle",
        "full_api_name": "AmplificationProblem.oracle",
        "api_description": "Return the oracle.\n\nReturns:\n    The oracle.",
        "api_signature": "oracle(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_amplifiers/amplification_problem.py"
    },
    {
        "api_name": "oracle",
        "full_api_name": "AmplificationProblem.oracle",
        "api_description": "Set the oracle.\n\nArgs:\n    oracle: The oracle.",
        "api_signature": "oracle(self, oracle)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_amplifiers/amplification_problem.py"
    },
    {
        "api_name": "state_preparation",
        "full_api_name": "AmplificationProblem.state_preparation",
        "api_description": "Get the state preparation operator :math:`\\mathcal{A}`.\n\nReturns:\n    The :math:`\\mathcal{A}` operator as `QuantumCircuit`.",
        "api_signature": "state_preparation(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_amplifiers/amplification_problem.py"
    },
    {
        "api_name": "state_preparation",
        "full_api_name": "AmplificationProblem.state_preparation",
        "api_description": "Set the :math:`\\mathcal{A}` operator. If None, a layer of Hadamard gates is used.\n\nArgs:\n    state_preparation: The new :math:`\\mathcal{A}` operator or None.",
        "api_signature": "state_preparation(self, state_preparation)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_amplifiers/amplification_problem.py"
    },
    {
        "api_name": "post_processing",
        "full_api_name": "AmplificationProblem.post_processing",
        "api_description": "Apply post processing to the input value.\n\nReturns:\n    A handle to the post processing function. Acts as identity by default.",
        "api_signature": "post_processing(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_amplifiers/amplification_problem.py"
    },
    {
        "api_name": "post_processing",
        "full_api_name": "AmplificationProblem.post_processing",
        "api_description": "Set the post processing function.\n\nArgs:\n    post_processing: A handle to the post processing function.",
        "api_signature": "post_processing(self, post_processing)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_amplifiers/amplification_problem.py"
    },
    {
        "api_name": "objective_qubits",
        "full_api_name": "AmplificationProblem.objective_qubits",
        "api_description": "The indices of the objective qubits.\n\nReturns:\n    The indices of the objective qubits as list of integers.",
        "api_signature": "objective_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_amplifiers/amplification_problem.py"
    },
    {
        "api_name": "objective_qubits",
        "full_api_name": "AmplificationProblem.objective_qubits",
        "api_description": "Set the objective qubits.\n\nArgs:\n    objective_qubits: The indices of the qubits that should be measured.\n        If None, all qubits will be measured. The ``is_good_state`` function will be\n        applied on the measurement outcome of these qubits.",
        "api_signature": "objective_qubits(self, objective_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_amplifiers/amplification_problem.py"
    },
    {
        "api_name": "is_good_state",
        "full_api_name": "AmplificationProblem.is_good_state",
        "api_description": "Check whether a provided bitstring is a good state or not.\n\nReturns:\n    A callable that takes in a bitstring and returns True if the measurement is a good\n    state, False otherwise.",
        "api_signature": "is_good_state(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_amplifiers/amplification_problem.py"
    },
    {
        "api_name": "is_good_state",
        "full_api_name": "AmplificationProblem.is_good_state",
        "api_description": "Set the ``is_good_state`` function.\n\nArgs:\n    is_good_state: A function to determine whether a bitstring represents a good state.",
        "api_signature": "is_good_state(self, is_good_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_amplifiers/amplification_problem.py"
    },
    {
        "api_name": "grover_operator",
        "full_api_name": "AmplificationProblem.grover_operator",
        "api_description": "Get the :math:`\\mathcal{Q}` operator, or Grover operator.\n\nIf the Grover operator is not set, we try to build it from the :math:`\\mathcal{A}` operator\nand `objective_qubits`. This only works if `objective_qubits` is a list of integers.\n\nReturns:\n    The Grover operator, or None if neither the Grover operator nor the\n    :math:`\\mathcal{A}` operator is  set.",
        "api_signature": "grover_operator(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_amplifiers/amplification_problem.py"
    },
    {
        "api_name": "grover_operator",
        "full_api_name": "AmplificationProblem.grover_operator",
        "api_description": "Set the :math:`\\mathcal{Q}` operator.\n\nIf None, this operator is constructed from the ``oracle`` and ``state_preparation``.\n\nArgs:\n    grover_operator: The new :math:`\\mathcal{Q}` operator or None.",
        "api_signature": "grover_operator(self, grover_operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_amplifiers/amplification_problem.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Grover.__init__",
        "api_description": "Args:\n    iterations: Specify the number of iterations/power of Grover's operator to be checked.\n        * If an int, only one circuit is run with that power of the Grover operator.\n        If the number of solutions is known, this option should be used with the optimal\n        power. The optimal power can be computed with ``Grover.optimal_num_iterations``.\n        * If a list, all the powers in the list are run in the specified order.\n        * If an iterator, the powers yielded by the iterator are checked, until a maximum\n        number of iterations or maximum power is reached.\n        * If ``None``, the :obj:`AmplificationProblem` provided must have an ``is_good_state``,\n        and circuits are run until that good state is reached.\n    growth_rate: If specified, the iterator is set to increasing powers of ``growth_rate``,\n        i.e. to ``int(growth_rate ** 1), int(growth_rate ** 2), ...`` until a maximum\n        number of iterations is reached.\n    sample_from_iterations: If True, instead of taking the values in ``iterations`` as\n        powers of the Grover operator, a random integer sample between 0 and smaller value\n        than the iteration is used as a power, see [1], Section 4.\n    quantum_instance: Deprecated: A Quantum Instance or Backend to run the circuits.\n    sampler: A Sampler to use for sampling the results of the circuits.\n\nRaises:\n    ValueError: If ``growth_rate`` is a float but not larger than 1.\n    ValueError: If both ``iterations`` and ``growth_rate`` is set.\n\nReferences:\n    [1]: Boyer et al., Tight bounds on quantum searching\n         `<https://arxiv.org/abs/quant-ph/9605034>`_",
        "api_signature": "__init__(self, iterations, growth_rate, sample_from_iterations, quantum_instance, sampler)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_amplifiers/grover.py"
    },
    {
        "api_name": "quantum_instance",
        "full_api_name": "Grover.quantum_instance",
        "api_description": "Deprecated. Get the quantum instance.\n\nReturns:\n    The quantum instance used to run this algorithm.",
        "api_signature": "quantum_instance(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_amplifiers/grover.py"
    },
    {
        "api_name": "quantum_instance",
        "full_api_name": "Grover.quantum_instance",
        "api_description": "Deprecated. Set quantum instance.\n\nArgs:\n    quantum_instance: The quantum instance used to run this algorithm.",
        "api_signature": "quantum_instance(self, quantum_instance)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_amplifiers/grover.py"
    },
    {
        "api_name": "sampler",
        "full_api_name": "Grover.sampler",
        "api_description": "Get the sampler.\n\nReturns:\n    The sampler used to run this algorithm.",
        "api_signature": "sampler(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_amplifiers/grover.py"
    },
    {
        "api_name": "sampler",
        "full_api_name": "Grover.sampler",
        "api_description": "Set the sampler.\n\nArgs:\n    sampler: The sampler used to run this algorithm.",
        "api_signature": "sampler(self, sampler)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_amplifiers/grover.py"
    },
    {
        "api_name": "amplify",
        "full_api_name": "Grover.amplify",
        "api_description": "Run the Grover algorithm.\n\nArgs:\n    amplification_problem: The amplification problem.\n\nReturns:\n    The result as a ``GroverResult``, where e.g. the most likely state can be queried\n    as ``result.top_measurement``.\n\nRaises:\n    ValueError: If a quantum instance or sampler is not set.\n    AlgorithmError: If a sampler job fails.\n    TypeError: If ``is_good_state`` is not provided and is required (i.e. when iterations\n    is ``None`` or a ``list``)",
        "api_signature": "amplify(self, amplification_problem)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_amplifiers/grover.py"
    },
    {
        "api_name": "optimal_num_iterations",
        "full_api_name": "Grover.optimal_num_iterations",
        "api_description": "Return the optimal number of iterations, if the number of solutions is known.\n\nArgs:\n    num_solutions: The number of solutions.\n    num_qubits: The number of qubits used to encode the states.\n\nReturns:\n    The optimal number of iterations for Grover's algorithm to succeed.",
        "api_signature": "optimal_num_iterations(num_solutions, num_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_amplifiers/grover.py"
    },
    {
        "api_name": "construct_circuit",
        "full_api_name": "Grover.construct_circuit",
        "api_description": "Construct the circuit for Grover's algorithm with ``power`` Grover operators.\n\nArgs:\n    problem: The amplification problem for the algorithm.\n    power: The number of times the Grover operator is repeated. If None, this argument\n        is set to the first item in ``iterations``.\n    measurement: Boolean flag to indicate if measurement should be included in the circuit.\n\nReturns:\n    QuantumCircuit: the QuantumCircuit object for the constructed circuit\n\nRaises:\n    ValueError: If no power is passed and the iterations are not an integer.",
        "api_signature": "construct_circuit(self, problem, power, measurement)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_amplifiers/grover.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "GroverResult.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_amplifiers/grover.py"
    },
    {
        "api_name": "iterations",
        "full_api_name": "GroverResult.iterations",
        "api_description": "All the powers of the Grover operator that have been tried.\n\nReturns:\n    The powers of the Grover operator tested.",
        "api_signature": "iterations(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_amplifiers/grover.py"
    },
    {
        "api_name": "iterations",
        "full_api_name": "GroverResult.iterations",
        "api_description": "Set the powers of the Grover operator that have been tried.\n\nArgs:\n    value: A new value for the powers.",
        "api_signature": "iterations(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_amplifiers/grover.py"
    },
    {
        "api_name": "amplify",
        "full_api_name": "AmplitudeAmplifier.amplify",
        "api_description": "Run the amplification algorithm.\n\nArgs:\n    amplification_problem: The amplification problem.\n\nReturns:\n    The result as a ``AmplificationResult``, where e.g. the most likely state can be queried\n    as ``result.top_measurement``.",
        "api_signature": "amplify(self, amplification_problem)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_amplifiers/amplitude_amplifier.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "AmplitudeAmplifierResult.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_amplifiers/amplitude_amplifier.py"
    },
    {
        "api_name": "top_measurement",
        "full_api_name": "AmplitudeAmplifierResult.top_measurement",
        "api_description": "The most frequently measured output as bitstring.\n\nReturns:\n    The most frequently measured output state.",
        "api_signature": "top_measurement(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_amplifiers/amplitude_amplifier.py"
    },
    {
        "api_name": "top_measurement",
        "full_api_name": "AmplitudeAmplifierResult.top_measurement",
        "api_description": "Set the most frequently measured bitstring.\n\nArgs:\n    value: A new value for the top measurement.",
        "api_signature": "top_measurement(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_amplifiers/amplitude_amplifier.py"
    },
    {
        "api_name": "assignment",
        "full_api_name": "AmplitudeAmplifierResult.assignment",
        "api_description": "The post-processed value of the most likely bitstring.\n\nReturns:\n    The output of the ``post_processing`` function of the respective\n    ``AmplificationProblem``, where the input is the ``top_measurement``. The type\n    is the same as the return type of the post-processing function.",
        "api_signature": "assignment(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_amplifiers/amplitude_amplifier.py"
    },
    {
        "api_name": "assignment",
        "full_api_name": "AmplitudeAmplifierResult.assignment",
        "api_description": "Set the value for the assignment.\n\nArgs:\n    value: A new value for the assignment/solution.",
        "api_signature": "assignment(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_amplifiers/amplitude_amplifier.py"
    },
    {
        "api_name": "oracle_evaluation",
        "full_api_name": "AmplitudeAmplifierResult.oracle_evaluation",
        "api_description": "Whether the classical oracle evaluation of the top measurement was True or False.\n\nReturns:\n    The classical oracle evaluation of the top measurement.",
        "api_signature": "oracle_evaluation(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_amplifiers/amplitude_amplifier.py"
    },
    {
        "api_name": "oracle_evaluation",
        "full_api_name": "AmplitudeAmplifierResult.oracle_evaluation",
        "api_description": "Set the classical oracle evaluation of the top measurement.\n\nArgs:\n    value: A new value for the classical oracle evaluation.",
        "api_signature": "oracle_evaluation(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_amplifiers/amplitude_amplifier.py"
    },
    {
        "api_name": "circuit_results",
        "full_api_name": "AmplitudeAmplifierResult.circuit_results",
        "api_description": "Return the circuit results. Can be a statevector or counts dictionary.",
        "api_signature": "circuit_results(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_amplifiers/amplitude_amplifier.py"
    },
    {
        "api_name": "circuit_results",
        "full_api_name": "AmplitudeAmplifierResult.circuit_results",
        "api_description": "Set the circuit results.",
        "api_signature": "circuit_results(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_amplifiers/amplitude_amplifier.py"
    },
    {
        "api_name": "max_probability",
        "full_api_name": "AmplitudeAmplifierResult.max_probability",
        "api_description": "Return the maximum sampling probability.",
        "api_signature": "max_probability(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_amplifiers/amplitude_amplifier.py"
    },
    {
        "api_name": "max_probability",
        "full_api_name": "AmplitudeAmplifierResult.max_probability",
        "api_description": "Set the maximum sampling probability.",
        "api_signature": "max_probability(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/amplitude_amplifiers/amplitude_amplifier.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "MinimumEigensolver.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigen_solvers/minimum_eigen_solver.py"
    },
    {
        "api_name": "compute_minimum_eigenvalue",
        "full_api_name": "MinimumEigensolver.compute_minimum_eigenvalue",
        "api_description": "Computes minimum eigenvalue. Operator and aux_operators can be supplied here and\nif not None will override any already set into algorithm so it can be reused with\ndifferent operators. While an operator is required by algorithms, aux_operators\nare optional. To 'remove' a previous aux_operators array use an empty list here.\n\nArgs:\n    operator: Qubit operator of the Observable\n    aux_operators: Optional list of auxiliary operators to be evaluated with the\n        eigenstate of the minimum eigenvalue main result and their expectation values\n        returned. For instance in chemistry these can be dipole operators, total particle\n        count operators so we can get values for these at the ground state.\n\nReturns:\n    MinimumEigensolverResult",
        "api_signature": "compute_minimum_eigenvalue(self, operator, aux_operators)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigen_solvers/minimum_eigen_solver.py"
    },
    {
        "api_name": "supports_aux_operators",
        "full_api_name": "MinimumEigensolver.supports_aux_operators",
        "api_description": "Whether computing the expectation value of auxiliary operators is supported.\n\nIf the minimum eigensolver computes an eigenstate of the main operator then it\ncan compute the expectation value of the aux_operators for that state. Otherwise\nthey will be ignored.\n\nReturns:\n    True if aux_operator expectations can be evaluated, False otherwise",
        "api_signature": "supports_aux_operators(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigen_solvers/minimum_eigen_solver.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "MinimumEigensolverResult.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigen_solvers/minimum_eigen_solver.py"
    },
    {
        "api_name": "eigenvalue",
        "full_api_name": "MinimumEigensolverResult.eigenvalue",
        "api_description": "returns eigen value",
        "api_signature": "eigenvalue(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigen_solvers/minimum_eigen_solver.py"
    },
    {
        "api_name": "eigenvalue",
        "full_api_name": "MinimumEigensolverResult.eigenvalue",
        "api_description": "set eigen value",
        "api_signature": "eigenvalue(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigen_solvers/minimum_eigen_solver.py"
    },
    {
        "api_name": "eigenstate",
        "full_api_name": "MinimumEigensolverResult.eigenstate",
        "api_description": "return eigen state",
        "api_signature": "eigenstate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigen_solvers/minimum_eigen_solver.py"
    },
    {
        "api_name": "eigenstate",
        "full_api_name": "MinimumEigensolverResult.eigenstate",
        "api_description": "set eigen state",
        "api_signature": "eigenstate(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigen_solvers/minimum_eigen_solver.py"
    },
    {
        "api_name": "aux_operator_eigenvalues",
        "full_api_name": "MinimumEigensolverResult.aux_operator_eigenvalues",
        "api_description": "Return aux operator expectation values.\n\nThese values are in fact tuples formatted as (mean, standard deviation).",
        "api_signature": "aux_operator_eigenvalues(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigen_solvers/minimum_eigen_solver.py"
    },
    {
        "api_name": "aux_operator_eigenvalues",
        "full_api_name": "MinimumEigensolverResult.aux_operator_eigenvalues",
        "api_description": "set aux operator eigen values",
        "api_signature": "aux_operator_eigenvalues(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigen_solvers/minimum_eigen_solver.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "VQE.__init__",
        "api_description": "Args:\n    ansatz: A parameterized circuit used as Ansatz for the wave function.\n    optimizer: A classical optimizer. Can either be a Qiskit optimizer or a callable\n        that takes an array as input and returns a Qiskit or SciPy optimization result.\n    initial_point: An optional initial point (i.e. initial parameter values)\n        for the optimizer. If ``None`` then VQE will look to the ansatz for a preferred\n        point and if not will simply compute a random one.\n    gradient: An optional gradient function or operator for optimizer.\n    expectation: The Expectation converter for taking the average value of the\n        Observable over the ansatz state function. When ``None`` (the default) an\n        :class:`~qiskit.opflow.expectations.ExpectationFactory` is used to select\n        an appropriate expectation based on the operator and backend. When using Aer\n        qasm_simulator backend, with paulis, it is however much faster to leverage custom\n        Aer function for the computation but, although VQE performs much faster\n        with it, the outcome is ideal, with no shot noise, like using a state vector\n        simulator. If you are just looking for the quickest performance when choosing Aer\n        qasm_simulator and the lack of shot noise is not an issue then set `include_custom`\n        parameter here to ``True`` (defaults to ``False``).\n    include_custom: When `expectation` parameter here is None setting this to ``True`` will\n        allow the factory to include the custom Aer pauli expectation.\n    max_evals_grouped: Max number of evaluations performed simultaneously. Signals the\n        given optimizer that more than one set of parameters can be supplied so that\n        potentially the expectation values can be computed in parallel. Typically this is\n        possible when a finite difference gradient is used by the optimizer such that\n        multiple points to compute the gradient can be passed and if computed in parallel\n        improve overall execution time. Deprecated if a gradient operator or function is\n        given.\n    callback: a callback that can access the intermediate data during the optimization.\n        Four parameter values are passed to the callback as follows during each evaluation\n        by the optimizer for its current set of parameters as it works towards the minimum.\n        These are: the evaluation count, the optimizer parameters for the\n        ansatz, the evaluated mean and the evaluated standard deviation.`\n    quantum_instance: Quantum Instance or Backend",
        "api_signature": "__init__(self, ansatz, optimizer, initial_point, gradient, expectation, include_custom, max_evals_grouped, callback, quantum_instance)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigen_solvers/vqe.py"
    },
    {
        "api_name": "ansatz",
        "full_api_name": "VQE.ansatz",
        "api_description": "Returns the ansatz.",
        "api_signature": "ansatz(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigen_solvers/vqe.py"
    },
    {
        "api_name": "ansatz",
        "full_api_name": "VQE.ansatz",
        "api_description": "Sets the ansatz.\n\nArgs:\n    ansatz: The parameterized circuit used as an ansatz.\n    If None is passed, RealAmplitudes is used by default.",
        "api_signature": "ansatz(self, ansatz)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigen_solvers/vqe.py"
    },
    {
        "api_name": "gradient",
        "full_api_name": "VQE.gradient",
        "api_description": "Returns the gradient.",
        "api_signature": "gradient(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigen_solvers/vqe.py"
    },
    {
        "api_name": "gradient",
        "full_api_name": "VQE.gradient",
        "api_description": "Sets the gradient.",
        "api_signature": "gradient(self, gradient)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigen_solvers/vqe.py"
    },
    {
        "api_name": "quantum_instance",
        "full_api_name": "VQE.quantum_instance",
        "api_description": "Returns quantum instance.",
        "api_signature": "quantum_instance(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigen_solvers/vqe.py"
    },
    {
        "api_name": "quantum_instance",
        "full_api_name": "VQE.quantum_instance",
        "api_description": "Sets quantum_instance",
        "api_signature": "quantum_instance(self, quantum_instance)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigen_solvers/vqe.py"
    },
    {
        "api_name": "initial_point",
        "full_api_name": "VQE.initial_point",
        "api_description": "Returns initial point",
        "api_signature": "initial_point(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigen_solvers/vqe.py"
    },
    {
        "api_name": "initial_point",
        "full_api_name": "VQE.initial_point",
        "api_description": "Sets initial point",
        "api_signature": "initial_point(self, initial_point)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigen_solvers/vqe.py"
    },
    {
        "api_name": "max_evals_grouped",
        "full_api_name": "VQE.max_evals_grouped",
        "api_description": "Returns max_evals_grouped",
        "api_signature": "max_evals_grouped(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigen_solvers/vqe.py"
    },
    {
        "api_name": "max_evals_grouped",
        "full_api_name": "VQE.max_evals_grouped",
        "api_description": "Sets max_evals_grouped",
        "api_signature": "max_evals_grouped(self, max_evals_grouped)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigen_solvers/vqe.py"
    },
    {
        "api_name": "include_custom",
        "full_api_name": "VQE.include_custom",
        "api_description": "Returns include_custom",
        "api_signature": "include_custom(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigen_solvers/vqe.py"
    },
    {
        "api_name": "include_custom",
        "full_api_name": "VQE.include_custom",
        "api_description": "Sets include_custom. If set to another value than the one that was previsously set,\nthe expectation attribute is reset to None.",
        "api_signature": "include_custom(self, include_custom)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigen_solvers/vqe.py"
    },
    {
        "api_name": "callback",
        "full_api_name": "VQE.callback",
        "api_description": "Returns callback",
        "api_signature": "callback(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigen_solvers/vqe.py"
    },
    {
        "api_name": "callback",
        "full_api_name": "VQE.callback",
        "api_description": "Sets callback",
        "api_signature": "callback(self, callback)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigen_solvers/vqe.py"
    },
    {
        "api_name": "expectation",
        "full_api_name": "VQE.expectation",
        "api_description": "The expectation value algorithm used to construct the expectation measurement from\nthe observable.",
        "api_signature": "expectation(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigen_solvers/vqe.py"
    },
    {
        "api_name": "expectation",
        "full_api_name": "VQE.expectation",
        "api_description": "",
        "api_signature": "expectation(self, exp)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigen_solvers/vqe.py"
    },
    {
        "api_name": "_check_operator_ansatz",
        "full_api_name": "VQE._check_operator_ansatz",
        "api_description": "Check that the number of qubits of operator and ansatz match.",
        "api_signature": "_check_operator_ansatz(self, operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigen_solvers/vqe.py"
    },
    {
        "api_name": "optimizer",
        "full_api_name": "VQE.optimizer",
        "api_description": "Returns optimizer",
        "api_signature": "optimizer(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigen_solvers/vqe.py"
    },
    {
        "api_name": "optimizer",
        "full_api_name": "VQE.optimizer",
        "api_description": "Sets the optimizer attribute.\n\nArgs:\n    optimizer: The optimizer to be used. If None is passed, SLSQP is used by default.",
        "api_signature": "optimizer(self, optimizer)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigen_solvers/vqe.py"
    },
    {
        "api_name": "setting",
        "full_api_name": "VQE.setting",
        "api_description": "Prepare the setting of VQE as a string.",
        "api_signature": "setting(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigen_solvers/vqe.py"
    },
    {
        "api_name": "print_settings",
        "full_api_name": "VQE.print_settings",
        "api_description": "Preparing the setting of VQE into a string.\n\nReturns:\n    str: the formatted setting of VQE",
        "api_signature": "print_settings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigen_solvers/vqe.py"
    },
    {
        "api_name": "construct_expectation",
        "full_api_name": "VQE.construct_expectation",
        "api_description": "Generate the ansatz circuit and expectation value measurement, and return their\nrunnable composition.\n\nArgs:\n    parameter: Parameters for the ansatz circuit.\n    operator: Qubit operator of the Observable\n    return_expectation: If True, return the ``ExpectationBase`` expectation converter used\n        in the construction of the expectation value. Useful e.g. to compute the standard\n        deviation of the expectation value.\n\nReturns:\n    The Operator equalling the measurement of the ansatz :class:`StateFn` by the\n    Observable's expectation :class:`StateFn`, and, optionally, the expectation converter.\n\nRaises:\n    AlgorithmError: If no operator has been provided.\n    AlgorithmError: If no expectation is passed and None could be inferred via the\n        ExpectationFactory.",
        "api_signature": "construct_expectation(self, parameter, operator, return_expectation)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigen_solvers/vqe.py"
    },
    {
        "api_name": "construct_circuit",
        "full_api_name": "VQE.construct_circuit",
        "api_description": "Return the circuits used to compute the expectation value.\n\nArgs:\n    parameter: Parameters for the ansatz circuit.\n    operator: Qubit operator of the Observable\n\nReturns:\n    A list of the circuits used to compute the expectation value.",
        "api_signature": "construct_circuit(self, parameter, operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigen_solvers/vqe.py"
    },
    {
        "api_name": "extract_circuits",
        "full_api_name": "VQE.extract_circuits",
        "api_description": "",
        "api_signature": "extract_circuits(op)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigen_solvers/vqe.py"
    },
    {
        "api_name": "supports_aux_operators",
        "full_api_name": "VQE.supports_aux_operators",
        "api_description": "",
        "api_signature": "supports_aux_operators(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigen_solvers/vqe.py"
    },
    {
        "api_name": "compute_minimum_eigenvalue",
        "full_api_name": "VQE.compute_minimum_eigenvalue",
        "api_description": "",
        "api_signature": "compute_minimum_eigenvalue(self, operator, aux_operators)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigen_solvers/vqe.py"
    },
    {
        "api_name": "get_energy_evaluation",
        "full_api_name": "VQE.get_energy_evaluation",
        "api_description": "Returns a function handle to evaluates the energy at given parameters for the ansatz.\n\nThis is the objective function to be passed to the optimizer that is used for evaluation.\n\nArgs:\n    operator: The operator whose energy to evaluate.\n    return_expectation: If True, return the ``ExpectationBase`` expectation converter used\n        in the construction of the expectation value. Useful e.g. to evaluate other\n        operators with the same expectation value converter.\n\n\nReturns:\n    Energy of the hamiltonian of each parameter, and, optionally, the expectation\n    converter.\n\nRaises:\n    RuntimeError: If the circuit is not parameterized (i.e. has 0 free parameters).",
        "api_signature": "get_energy_evaluation(self, operator, return_expectation)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigen_solvers/vqe.py"
    },
    {
        "api_name": "energy_evaluation",
        "full_api_name": "VQE.energy_evaluation",
        "api_description": "",
        "api_signature": "energy_evaluation(parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigen_solvers/vqe.py"
    },
    {
        "api_name": "_get_eigenstate",
        "full_api_name": "VQE._get_eigenstate",
        "api_description": "Get the simulation outcome of the ansatz, provided with parameters.",
        "api_signature": "_get_eigenstate(self, optimal_parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigen_solvers/vqe.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "VQEResult.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigen_solvers/vqe.py"
    },
    {
        "api_name": "cost_function_evals",
        "full_api_name": "VQEResult.cost_function_evals",
        "api_description": "Returns number of cost optimizer evaluations",
        "api_signature": "cost_function_evals(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigen_solvers/vqe.py"
    },
    {
        "api_name": "cost_function_evals",
        "full_api_name": "VQEResult.cost_function_evals",
        "api_description": "Sets number of cost function evaluations",
        "api_signature": "cost_function_evals(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigen_solvers/vqe.py"
    },
    {
        "api_name": "eigenstate",
        "full_api_name": "VQEResult.eigenstate",
        "api_description": "return eigen state",
        "api_signature": "eigenstate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigen_solvers/vqe.py"
    },
    {
        "api_name": "eigenstate",
        "full_api_name": "VQEResult.eigenstate",
        "api_description": "set eigen state",
        "api_signature": "eigenstate(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigen_solvers/vqe.py"
    },
    {
        "api_name": "_validate_initial_point",
        "full_api_name": "_validate_initial_point",
        "api_description": "",
        "api_signature": "_validate_initial_point(point, ansatz)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigen_solvers/vqe.py"
    },
    {
        "api_name": "_validate_bounds",
        "full_api_name": "_validate_bounds",
        "api_description": "",
        "api_signature": "_validate_bounds(ansatz)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigen_solvers/vqe.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QAOA.__init__",
        "api_description": "Args:\n    optimizer: A classical optimizer, see also :class:`~qiskit.algorithms.VQE` for\n        more details on the possible types.\n    reps: the integer parameter :math:`p` as specified in https://arxiv.org/abs/1411.4028,\n        Has a minimum valid value of 1.\n    initial_state: An optional initial state to prepend the QAOA circuit with\n    mixer: the mixer Hamiltonian to evolve with or a custom quantum circuit. Allows support\n        of optimizations in constrained subspaces as per https://arxiv.org/abs/1709.03489\n        as well as warm-starting the optimization as introduced\n        in http://arxiv.org/abs/2009.10095.\n    initial_point: An optional initial point (i.e. initial parameter values)\n        for the optimizer. If ``None`` then it will simply compute a random one.\n    gradient: An optional gradient operator respectively a gradient function used for\n              optimization.\n    expectation: The Expectation converter for taking the average value of the\n        Observable over the ansatz state function. When None (the default) an\n        :class:`~qiskit.opflow.expectations.ExpectationFactory` is used to select\n        an appropriate expectation based on the operator and backend. When using Aer\n        qasm_simulator backend, with paulis, it is however much faster to leverage custom\n        Aer function for the computation but, although VQE performs much faster\n        with it, the outcome is ideal, with no shot noise, like using a state vector\n        simulator. If you are just looking for the quickest performance when choosing Aer\n        qasm_simulator and the lack of shot noise is not an issue then set `include_custom`\n        parameter here to True (defaults to False).\n    include_custom: When `expectation` parameter here is None setting this to True will\n        allow the factory to include the custom Aer pauli expectation.\n    max_evals_grouped: Max number of evaluations performed simultaneously. Signals the\n        given optimizer that more than one set of parameters can be supplied so that\n        potentially the expectation values can be computed in parallel. Typically this is\n        possible when a finite difference gradient is used by the optimizer such that\n        multiple points to compute the gradient can be passed and if computed in parallel\n        improve overall execution time. Ignored if a gradient operator or function is\n        given.\n    callback: a callback that can access the intermediate data during the optimization.\n        Four parameter values are passed to the callback as follows during each evaluation\n        by the optimizer for its current set of parameters as it works towards the minimum.\n        These are: the evaluation count, the optimizer parameters for the\n        ansatz, the evaluated mean and the evaluated standard deviation.\n    quantum_instance: Quantum Instance or Backend",
        "api_signature": "__init__(self, optimizer, reps, initial_state, mixer, initial_point, gradient, expectation, include_custom, max_evals_grouped, callback, quantum_instance)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigen_solvers/qaoa.py"
    },
    {
        "api_name": "_check_operator_ansatz",
        "full_api_name": "QAOA._check_operator_ansatz",
        "api_description": "",
        "api_signature": "_check_operator_ansatz(self, operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigen_solvers/qaoa.py"
    },
    {
        "api_name": "initial_state",
        "full_api_name": "QAOA.initial_state",
        "api_description": "Returns:\n    Returns the initial state.",
        "api_signature": "initial_state(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigen_solvers/qaoa.py"
    },
    {
        "api_name": "initial_state",
        "full_api_name": "QAOA.initial_state",
        "api_description": "Args:\n    initial_state: Initial state to set.",
        "api_signature": "initial_state(self, initial_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigen_solvers/qaoa.py"
    },
    {
        "api_name": "mixer",
        "full_api_name": "QAOA.mixer",
        "api_description": "Returns:\n    Returns the mixer.",
        "api_signature": "mixer(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigen_solvers/qaoa.py"
    },
    {
        "api_name": "mixer",
        "full_api_name": "QAOA.mixer",
        "api_description": "Args:\n    mixer: Mixer to set.",
        "api_signature": "mixer(self, mixer)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigen_solvers/qaoa.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "NumPyMinimumEigensolver.__init__",
        "api_description": "Args:\n    filter_criterion: callable that allows to filter eigenvalues/eigenstates. The minimum\n        eigensolver is only searching over feasible states and returns an eigenstate that\n        has the smallest eigenvalue among feasible states. The callable has the signature\n        `filter(eigenstate, eigenvalue, aux_values)` and must return a boolean to indicate\n        whether to consider this value or not. If there is no\n        feasible element, the result can even be empty.",
        "api_signature": "__init__(self, filter_criterion)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigen_solvers/numpy_minimum_eigen_solver.py"
    },
    {
        "api_name": "filter_criterion",
        "full_api_name": "NumPyMinimumEigensolver.filter_criterion",
        "api_description": "returns the filter criterion if set",
        "api_signature": "filter_criterion(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigen_solvers/numpy_minimum_eigen_solver.py"
    },
    {
        "api_name": "filter_criterion",
        "full_api_name": "NumPyMinimumEigensolver.filter_criterion",
        "api_description": "set the filter criterion",
        "api_signature": "filter_criterion(self, filter_criterion)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigen_solvers/numpy_minimum_eigen_solver.py"
    },
    {
        "api_name": "supports_aux_operators",
        "full_api_name": "NumPyMinimumEigensolver.supports_aux_operators",
        "api_description": "",
        "api_signature": "supports_aux_operators(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigen_solvers/numpy_minimum_eigen_solver.py"
    },
    {
        "api_name": "compute_minimum_eigenvalue",
        "full_api_name": "NumPyMinimumEigensolver.compute_minimum_eigenvalue",
        "api_description": "",
        "api_signature": "compute_minimum_eigenvalue(self, operator, aux_operators)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigen_solvers/numpy_minimum_eigen_solver.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "TimeEvolutionResult.__init__",
        "api_description": "Args:\n    evolved_state: An evolved quantum state.\n    aux_ops_evaluated: Optional list of observables for which expected values on an evolved\n        state are calculated. These values are in fact tuples formatted as (mean, standard\n        deviation).\n    observables: Optional list of observables for which expected values are calculated for\n         each timestep. These values are in fact tuples formatted as (mean array, standard\n         deviation array).\n    times: Optional list of times at which each observable has been evaluated.",
        "api_signature": "__init__(self, evolved_state, aux_ops_evaluated, observables, times)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/time_evolvers/time_evolution_result.py"
    },
    {
        "api_name": "evolve",
        "full_api_name": "ImaginaryTimeEvolver.evolve",
        "api_description": "Perform imaginary time evolution :math:`\\exp(-\\tau H)|\\Psi\\rangle`.\n\nEvolves an initial state :math:`|\\Psi\\rangle` for an imaginary time :math:`\\tau`\nunder a Hamiltonian  :math:`H`, as provided in the ``evolution_problem``.\n\nArgs:\n    evolution_problem: The definition of the evolution problem.\n\nReturns:\n    Evolution result which includes an evolved quantum state.",
        "api_signature": "evolve(self, evolution_problem)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/time_evolvers/imaginary_time_evolver.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "TimeEvolutionProblem.__init__",
        "api_description": "Args:\n    hamiltonian: The Hamiltonian under which to evolve the system.\n    time: Total time of evolution.\n    initial_state: The quantum state to be evolved for methods like Trotterization.\n        For variational time evolutions, where the evolution happens in an ansatz,\n        this argument is not required.\n    aux_operators: Optional list of auxiliary operators to be evaluated with the\n        evolved ``initial_state`` and their expectation values returned.\n    truncation_threshold: Defines a threshold under which values can be assumed to be 0.\n        Used when ``aux_operators`` is provided.\n    t_param: Time parameter in case of a time-dependent Hamiltonian. This\n        free parameter must be within the ``hamiltonian``.\n    param_value_map: Maps free parameters in the problem to values. Depending on the\n        algorithm, it might refer to e.g. a Hamiltonian or an initial state.\n\nRaises:\n    ValueError: If non-positive time of evolution is provided.",
        "api_signature": "__init__(self, hamiltonian, time, initial_state, aux_operators, truncation_threshold, t_param, param_value_map)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/time_evolvers/time_evolution_problem.py"
    },
    {
        "api_name": "time",
        "full_api_name": "TimeEvolutionProblem.time",
        "api_description": "Returns time.",
        "api_signature": "time(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/time_evolvers/time_evolution_problem.py"
    },
    {
        "api_name": "time",
        "full_api_name": "TimeEvolutionProblem.time",
        "api_description": "Sets time and validates it.",
        "api_signature": "time(self, time)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/time_evolvers/time_evolution_problem.py"
    },
    {
        "api_name": "validate_params",
        "full_api_name": "TimeEvolutionProblem.validate_params",
        "api_description": "Checks if all parameters present in the Hamiltonian are also present in the dictionary\nthat maps them to values.\n\nRaises:\n    ValueError: If Hamiltonian parameters cannot be bound with data provided.",
        "api_signature": "validate_params(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/time_evolvers/time_evolution_problem.py"
    },
    {
        "api_name": "evolve",
        "full_api_name": "RealTimeEvolver.evolve",
        "api_description": "Perform real time evolution :math:`\\exp(-i t H)|\\Psi\\rangle`.\n\nEvolves an initial state :math:`|\\Psi\\rangle` for a time :math:`t`\nunder a Hamiltonian :math:`H`, as provided in the ``evolution_problem``.\n\nArgs:\n    evolution_problem: The definition of the evolution problem.\n\nReturns:\n    Evolution result which includes an evolved quantum state.",
        "api_signature": "evolve(self, evolution_problem)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/time_evolvers/real_time_evolver.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PVQDResult.__init__",
        "api_description": "Args:\n    evolved_state: An evolved quantum state.\n    aux_ops_evaluated: Optional list of observables for which expected values on an evolved\n        state are calculated. These values are in fact tuples formatted as (mean, standard\n        deviation).\n    times: The times evaluated during the time integration.\n    parameters: The parameter values at each evaluation time.\n    fidelities: The fidelity of the Trotter step and variational update at each iteration.\n    estimated_error: The overall estimated error evaluated as one minus the\n        product of all fidelities.\n    observables: The value of the observables evaluated at each iteration.",
        "api_signature": "__init__(self, evolved_state, aux_ops_evaluated, times, parameters, fidelities, estimated_error, observables)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/time_evolvers/pvqd/pvqd_result.py"
    },
    {
        "api_name": "_is_gradient_supported",
        "full_api_name": "_is_gradient_supported",
        "api_description": "Check whether we can apply a simple parameter shift rule to obtain gradients.",
        "api_signature": "_is_gradient_supported(ansatz)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/time_evolvers/pvqd/utils.py"
    },
    {
        "api_name": "_get_observable_evaluator",
        "full_api_name": "_get_observable_evaluator",
        "api_description": "Get a callable to evaluate a (list of) observable(s) for given circuit parameters.",
        "api_signature": "_get_observable_evaluator(ansatz, observables, estimator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/time_evolvers/pvqd/utils.py"
    },
    {
        "api_name": "evaluate_observables",
        "full_api_name": "evaluate_observables",
        "api_description": "Evaluate the observables for the ansatz parameters ``theta``.\n\nArgs:\n    theta: The ansatz parameters.\n\nReturns:\n    The observables evaluated at the ansatz parameters.\n\nRaises:\n    AlgorithmError: If a primitive job fails.",
        "api_signature": "evaluate_observables(theta)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/time_evolvers/pvqd/utils.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PVQD.__init__",
        "api_description": "Args:\n    fidelity: A fidelity primitive used by the algorithm.\n    ansatz: A parameterized circuit preparing the variational ansatz to model the\n        time evolved quantum state.\n    initial_parameters: The initial parameters for the ansatz. Together with the ansatz,\n        these define the initial state of the time evolution.\n    estimator: An estimator primitive used for calculating expected values of auxiliary\n        operators (if provided via the problem).\n    optimizer: The classical optimizers used to minimize the overlap between\n        Trotterization and ansatz. Can be either a :class:`.Optimizer` or a callable\n        using the :class:`.Minimizer` protocol. This argument is optional since it is\n        not required for :meth:`get_loss`, but it has to be set before :meth:`evolve`\n        is called.\n    num_timesteps: The number of time steps. If ``None`` it will be set such that the\n        timestep is close to 0.01.\n    evolution: The evolution synthesis to use for the construction of the Trotter step.\n        Defaults to first-order Lie-Trotter decomposition, see also\n        :mod:`~qiskit.synthesis.evolution` for different options.\n    use_parameter_shift: If True, use the parameter shift rule to compute gradients.\n        If False, the optimizer will not be passed a gradient callable. In that case,\n        Qiskit optimizers will use a finite difference rule to approximate the gradients.\n    initial_guess: The initial guess for the first VQE optimization. Afterwards the\n        previous iteration result is used as initial guess. If None, this is set to\n        a random vector with elements in the interval :math:`[-0.01, 0.01]`.",
        "api_signature": "__init__(self, fidelity, ansatz, initial_parameters, estimator, optimizer, num_timesteps, evolution, use_parameter_shift, initial_guess)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/time_evolvers/pvqd/pvqd.py"
    },
    {
        "api_name": "step",
        "full_api_name": "PVQD.step",
        "api_description": "Perform a single time step.\n\nArgs:\n    hamiltonian: The Hamiltonian under which to evolve.\n    ansatz: The parameterized quantum circuit which attempts to approximate the\n        time-evolved state.\n    theta: The current parameters.\n    dt: The time step.\n    initial_guess: The initial guess for the classical optimization of the\n        fidelity between the next variational state and the Trotter-evolved last state.\n        If None, this is set to a random vector with elements in the interval\n        :math:`[-0.01, 0.01]`.\n\nReturns:\n    A tuple consisting of the next parameters and the fidelity of the optimization.",
        "api_signature": "step(self, hamiltonian, ansatz, theta, dt, initial_guess)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/time_evolvers/pvqd/pvqd.py"
    },
    {
        "api_name": "get_loss",
        "full_api_name": "PVQD.get_loss",
        "api_description": "Get a function to evaluate the infidelity between Trotter step and ansatz.\n\nArgs:\n    hamiltonian: The Hamiltonian under which to evolve.\n    ansatz: The parameterized quantum circuit which attempts to approximate the\n        time-evolved state.\n    dt: The time step.\n    current_parameters: The current parameters.\n\nReturns:\n    A callable to evaluate the infidelity and, if gradients are supported and required,\n        a second callable to evaluate the gradient of the infidelity.",
        "api_signature": "get_loss(self, hamiltonian, ansatz, dt, current_parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/time_evolvers/pvqd/pvqd.py"
    },
    {
        "api_name": "evaluate_loss",
        "full_api_name": "PVQD.evaluate_loss",
        "api_description": "Evaluate the overlap of the ansatz with the Trotterized evolution.\n\nArgs:\n    displacement: The parameters for the ansatz.\n\nReturns:\n    The fidelity of the ansatz with parameters ``theta`` and the Trotterized evolution.\n\nRaises:\n    AlgorithmError: If a primitive job fails.",
        "api_signature": "evaluate_loss(displacement)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/time_evolvers/pvqd/pvqd.py"
    },
    {
        "api_name": "evaluate_gradient",
        "full_api_name": "PVQD.evaluate_gradient",
        "api_description": "Evaluate the gradient with the parameter-shift rule.\n\nThis is hardcoded here since the gradient framework does not support computing\ngradients for overlaps.\n\nArgs:\n    displacement: The parameters for the ansatz.\n\nReturns:\n    The gradient.",
        "api_signature": "evaluate_gradient(displacement)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/time_evolvers/pvqd/pvqd.py"
    },
    {
        "api_name": "_transpose_param_dicts",
        "full_api_name": "PVQD._transpose_param_dicts",
        "api_description": "",
        "api_signature": "_transpose_param_dicts(self, params)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/time_evolvers/pvqd/pvqd.py"
    },
    {
        "api_name": "evolve",
        "full_api_name": "PVQD.evolve",
        "api_description": "Perform real time evolution :math:`\\exp(-i t H)|\\Psi\\rangle`.\n\nEvolves an initial state :math:`|\\Psi\\rangle` for a time :math:`t`\nunder a Hamiltonian  :math:`H`, as provided in the ``evolution_problem``.\n\nArgs:\n    evolution_problem: The evolution problem containing the hamiltonian, total evolution\n        time and observables to evaluate.\n\nReturns:\n    A result object containing the evolution information and evaluated observables.\n\nRaises:\n    ValueError: If ``aux_operators`` provided in the time evolution problem but no estimator\n        provided to the algorithm.\n    NotImplementedError: If the evolution problem contains an initial state.",
        "api_signature": "evolve(self, evolution_problem)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/time_evolvers/pvqd/pvqd.py"
    },
    {
        "api_name": "_validate_setup",
        "full_api_name": "PVQD._validate_setup",
        "api_description": "Validate the current setup and raise an error if something misses to run.",
        "api_signature": "_validate_setup(self, skip)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/time_evolvers/pvqd/pvqd.py"
    },
    {
        "api_name": "_create_observable_output",
        "full_api_name": "_create_observable_output",
        "api_description": "Creates the right output format for the evaluated auxiliary operators.\nArgs:\n    ops_ev_mean: Array containing the expectation value of each observable at each timestep.\n    evolution_problem: Time Evolution Problem to create the output of.\n\nReturns:\n    An output with the observables mean value at the appropriate times depending on whether\n    the auxiliary operators in the time evolution problem are a `list` or a `dict`.",
        "api_signature": "_create_observable_output(ops_ev_mean, evolution_problem)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/time_evolvers/classical_methods/evolve.py"
    },
    {
        "api_name": "_create_obs_final",
        "full_api_name": "_create_obs_final",
        "api_description": "Creates the right output format for the final value of the auxiliary operators.\n\nArgs:\n    ops_ev_mean: Array containing the expectation value of each observable at the final timestep.\n    evolution_problem: Evolution problem to create the output of.\n\nReturns:\n    An output with the observables mean value at the appropriate times depending on whether\n    the auxiliary operators in the evolution problem are a `list` or a `dict`.",
        "api_signature": "_create_obs_final(ops_ev_mean, evolution_problem)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/time_evolvers/classical_methods/evolve.py"
    },
    {
        "api_name": "_evaluate_aux_ops",
        "full_api_name": "_evaluate_aux_ops",
        "api_description": "Evaluates the aux operators if they are provided and stores their value.\n\nReturns:\n    Mean of the aux operators for a given state.",
        "api_signature": "_evaluate_aux_ops(aux_ops, state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/time_evolvers/classical_methods/evolve.py"
    },
    {
        "api_name": "_operator_to_matrix",
        "full_api_name": "_operator_to_matrix",
        "api_description": "",
        "api_signature": "_operator_to_matrix(operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/time_evolvers/classical_methods/evolve.py"
    },
    {
        "api_name": "_build_scipy_operators",
        "full_api_name": "_build_scipy_operators",
        "api_description": "Returns the matrices and parameters needed for time evolution in the appropriate format.\n\nArgs:\n    evolution_problem: The definition of the evolution problem.\n    num_timesteps: Number of timesteps to be performed.\n    real_time: If `True`, returned operators will correspond to real time evolution,\n        Else, they will correspond to imaginary time evolution.\n\nReturns:\n    A tuple with the initial state, the list of operators to evaluate and the operator to be\n    exponentiated to perform one timestep.\n\nRaises:\n    ValueError: If the Hamiltonian can not be converted into a sparse matrix or dense matrix.",
        "api_signature": "_build_scipy_operators(evolution_problem, num_timesteps, real_time)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/time_evolvers/classical_methods/evolve.py"
    },
    {
        "api_name": "_evolve",
        "full_api_name": "_evolve",
        "api_description": "Performs either real  or imaginary time evolution :math:`\\exp(-i t H)|\\Psi\\rangle`.\n\nArgs:\n    evolution_problem: The definition of the evolution problem.\n    num_timesteps: Number of timesteps to be performed.\n    real_time: If `True`, returned operators will correspond to real time evolution,\n        Else, they will correspond to imaginary time evolution.\n\nReturns:\n    Evolution result which includes an evolved quantum state.\n\nRaises:\n    ValueError: If the Hamiltonian is time dependent.\n    ValueError: If the initial state is `None`.",
        "api_signature": "_evolve(evolution_problem, num_timesteps, real_time)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/time_evolvers/classical_methods/evolve.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SciPyRealEvolver.__init__",
        "api_description": "Args:\n    num_timesteps: The number of timesteps in the simulation.\nRaises:\n    ValueError: If `steps` is not a positive integer.",
        "api_signature": "__init__(self, num_timesteps)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/time_evolvers/classical_methods/scipy_real_evolver.py"
    },
    {
        "api_name": "evolve",
        "full_api_name": "SciPyRealEvolver.evolve",
        "api_description": "Perform real time evolution :math:`\\exp(-i t H)|\\Psi\\rangle`.\n\nEvolves an initial state :math:`|\\Psi\\rangle` for a time :math:`t`\nunder a Hamiltonian  :math:`H`, as provided in the ``evolution_problem``.\n\nArgs:\n    evolution_problem: The definition of the evolution problem.\n\nReturns:\n    Evolution result which includes an evolved quantum state.",
        "api_signature": "evolve(self, evolution_problem)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/time_evolvers/classical_methods/scipy_real_evolver.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SciPyImaginaryEvolver.__init__",
        "api_description": "Args:\n    num_timesteps: The number of timesteps in the simulation.\nRaises:\n    ValueError: If `num_timesteps` is not a positive integer.",
        "api_signature": "__init__(self, num_timesteps)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/time_evolvers/classical_methods/scipy_imaginary_evolver.py"
    },
    {
        "api_name": "evolve",
        "full_api_name": "SciPyImaginaryEvolver.evolve",
        "api_description": "Perform imaginary time evolution :math:`\\exp(-\\tau H)|\\Psi\\rangle`.\n\nEvolves an initial state :math:`|\\Psi\\rangle` for an imaginary time :math:`\\tau`\nunder a Hamiltonian :math:`H`, as provided in the ``evolution_problem``.\n\nArgs:\n    evolution_problem: The definition of the evolution problem.\n\nReturns:\n    Evolution result which includes an evolved quantum state.",
        "api_signature": "evolve(self, evolution_problem)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/time_evolvers/classical_methods/scipy_imaginary_evolver.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "TrotterQRTE.__init__",
        "api_description": "Args:\n    product_formula: A Lie-Trotter-Suzuki product formula. If ``None`` provided, the\n        Lie-Trotter first order product formula with a single repetition is used. ``reps``\n        should be 1 to obtain a number of time-steps equal to ``num_timesteps`` and an\n        evaluation of :attr:`.TimeEvolutionProblem.aux_operators` at every time-step. If ``reps``\n        is larger than 1, the true number of time-steps will be ``num_timesteps * reps``.\n    num_timesteps: The number of time-steps the full evolution time is devided into\n        (repetitions of ``product_formula``)\n    estimator: An estimator primitive used for calculating expectation values of\n        ``TimeEvolutionProblem.aux_operators``.",
        "api_signature": "__init__(self, product_formula, estimator, num_timesteps)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/time_evolvers/trotterization/trotter_qrte.py"
    },
    {
        "api_name": "product_formula",
        "full_api_name": "TrotterQRTE.product_formula",
        "api_description": "Returns a product formula.",
        "api_signature": "product_formula(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/time_evolvers/trotterization/trotter_qrte.py"
    },
    {
        "api_name": "product_formula",
        "full_api_name": "TrotterQRTE.product_formula",
        "api_description": "Sets a product formula. If ``None`` provided, sets the Lie-Trotter first order product\nformula with a single repetition.",
        "api_signature": "product_formula(self, product_formula)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/time_evolvers/trotterization/trotter_qrte.py"
    },
    {
        "api_name": "estimator",
        "full_api_name": "TrotterQRTE.estimator",
        "api_description": "Returns an estimator.",
        "api_signature": "estimator(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/time_evolvers/trotterization/trotter_qrte.py"
    },
    {
        "api_name": "estimator",
        "full_api_name": "TrotterQRTE.estimator",
        "api_description": "Sets an estimator.",
        "api_signature": "estimator(self, estimator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/time_evolvers/trotterization/trotter_qrte.py"
    },
    {
        "api_name": "num_timesteps",
        "full_api_name": "TrotterQRTE.num_timesteps",
        "api_description": "Returns the number of timesteps.",
        "api_signature": "num_timesteps(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/time_evolvers/trotterization/trotter_qrte.py"
    },
    {
        "api_name": "num_timesteps",
        "full_api_name": "TrotterQRTE.num_timesteps",
        "api_description": "Sets the number of time-steps.\n\nRaises:\n    ValueError: If num_timesteps is not positive.",
        "api_signature": "num_timesteps(self, num_timesteps)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/time_evolvers/trotterization/trotter_qrte.py"
    },
    {
        "api_name": "supports_aux_operators",
        "full_api_name": "TrotterQRTE.supports_aux_operators",
        "api_description": "Whether computing the expectation value of auxiliary operators is supported.\n\nReturns:\n    ``True`` if ``aux_operators`` expectations in the ``TimeEvolutionProblem`` can be\n    evaluated, ``False`` otherwise.",
        "api_signature": "supports_aux_operators(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/time_evolvers/trotterization/trotter_qrte.py"
    },
    {
        "api_name": "evolve",
        "full_api_name": "TrotterQRTE.evolve",
        "api_description": "Evolves a quantum state for a given time using the Trotterization method\nbased on a product formula provided. The result is provided in the form of a quantum\ncircuit. If auxiliary operators are included in the ``evolution_problem``, they are\nevaluated on the ``init_state`` and on the evolved state at every step (``num_timesteps``\ntimes) using an estimator primitive provided.\n\nArgs:\n    evolution_problem: Instance defining evolution problem. For the included Hamiltonian,\n        ``Pauli`` or ``PauliSumOp`` are supported by TrotterQRTE.\n\nReturns:\n    Evolution result that includes an evolved state as a quantum circuit and, optionally,\n    auxiliary operators evaluated for a resulting state on an estimator primitive.\n\nRaises:\n    ValueError: If ``t_param`` is not set to ``None`` in the ``TimeEvolutionProblem``\n        (feature not currently supported).\n    ValueError: If ``aux_operators`` provided in the time evolution problem but no estimator\n        provided to the algorithm.\n    ValueError: If the ``initial_state`` is not provided in the ``TimeEvolutionProblem``.\n    ValueError: If an unsupported Hamiltonian type is provided.",
        "api_signature": "evolve(self, evolution_problem)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/time_evolvers/trotterization/trotter_qrte.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "VarQITE.__init__",
        "api_description": "Args:\n    ansatz: Ansatz to be used for variational time evolution.\n    initial_parameters: Initial parameter values for the ansatz.\n    variational_principle: Variational Principle to be used. Defaults to\n        ``ImaginaryMcLachlanPrinciple``.\n    estimator: An estimator primitive used for calculating expectation values of\n        TimeEvolutionProblem.aux_operators.\n    ode_solver: ODE solver callable that implements a SciPy ``OdeSolver`` interface or a\n        string indicating a valid method offered by SciPy.\n    lse_solver: Linear system of equations solver callable. It accepts ``A`` and ``b`` to\n        solve ``Ax=b`` and returns ``x``. If ``None``, the default ``np.linalg.lstsq``\n        solver is used.\n    num_timesteps: The number of timesteps to take. If ``None``, it is\n        automatically selected to achieve a timestep of approximately 0.01. Only\n        relevant in case of the ``ForwardEulerSolver``.\n    imag_part_tol: Allowed value of an imaginary part that can be neglected if no\n        imaginary part is expected.\n    num_instability_tol: The amount of negative value that is allowed to be\n        rounded up to 0 for quantities that are expected to be non-negative.",
        "api_signature": "__init__(self, ansatz, initial_parameters, variational_principle, estimator, ode_solver, lse_solver, num_timesteps, imag_part_tol, num_instability_tol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/time_evolvers/variational/var_qite.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "VarQTEResult.__init__",
        "api_description": "Args:\n    evolved_state: An evolved quantum state.\n    aux_ops_evaluated: Optional list of observables for which expected values on an evolved\n        state are calculated. These values are in fact tuples formatted as (mean, standard\n        deviation).\n    observables: Optional list of observables for which expected on an evolved state are\n        calculated at each timestep.\n        These values are in fact lists of tuples formatted as (mean, standard deviation).\n    times: Optional list of times at which each observable has been evaluated.\n    parameter_values: Optional list of parameter values obtained after each evolution step.",
        "api_signature": "__init__(self, evolved_state, aux_ops_evaluated, observables, times, parameter_values)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/time_evolvers/variational/var_qte_result.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "VarQTE.__init__",
        "api_description": "Args:\n    ansatz: Ansatz to be used for variational time evolution.\n    initial_parameters: Initial parameter values for an ansatz.\n    variational_principle: Variational Principle to be used.\n    estimator: An estimator primitive used for calculating expectation values of\n        TimeEvolutionProblem.aux_operators.\n    ode_solver: ODE solver callable that implements a SciPy ``OdeSolver`` interface or a\n        string indicating a valid method offered by SciPy.\n    lse_solver: Linear system of equations solver callable. It accepts ``A`` and ``b`` to\n        solve ``Ax=b`` and returns ``x``.\n    num_timesteps: The number of timesteps to take. If None, it is\n        automatically selected to achieve a timestep of approximately 0.01. Only\n        relevant in case of the ``ForwardEulerSolver``.\n    imag_part_tol: Allowed value of an imaginary part that can be neglected if no\n        imaginary part is expected.\n    num_instability_tol: The amount of negative value that is allowed to be\n        rounded up to 0 for quantities that are expected to be\n        non-negative.",
        "api_signature": "__init__(self, ansatz, initial_parameters, variational_principle, estimator, ode_solver, lse_solver, num_timesteps, imag_part_tol, num_instability_tol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/time_evolvers/variational/var_qte.py"
    },
    {
        "api_name": "evolve",
        "full_api_name": "VarQTE.evolve",
        "api_description": "Apply Variational Quantum Time Evolution to the given operator.\n\nArgs:\n    evolution_problem: Instance defining an evolution problem.\nReturns:\n    Result of the evolution which includes a quantum circuit with bound parameters as an\n    evolved state and, if provided, observables evaluated on the evolved state.\n\nRaises:\n    ValueError: If ``initial_state`` is included in the ``evolution_problem``.",
        "api_signature": "evolve(self, evolution_problem)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/time_evolvers/variational/var_qte.py"
    },
    {
        "api_name": "_evolve",
        "full_api_name": "VarQTE._evolve",
        "api_description": "Helper method for performing time evolution. Works both for imaginary and real case.\n\nArgs:\n    init_state_param_dict: Parameter dictionary with initial values for a given\n        parametrized state/ansatz.\n    hamiltonian: Operator used for Variational Quantum Time Evolution (VarQTE).\n    time: Total time of evolution.\n    t_param: Time parameter in case of a time-dependent Hamiltonian.\n\nReturns:\n    Result of the evolution which is a quantum circuit with bound parameters as an\n    evolved state.",
        "api_signature": "_evolve(self, init_state_param_dict, hamiltonian, time, t_param)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/time_evolvers/variational/var_qte.py"
    },
    {
        "api_name": "_create_init_state_param_dict",
        "full_api_name": "VarQTE._create_init_state_param_dict",
        "api_description": "If ``param_values`` is a dictionary, it looks for parameters present in an initial state\n(an ansatz) in a ``param_values``. Based on that, it creates a new dictionary containing\nonly parameters present in an initial state and their respective values.\nIf ``param_values`` is a list of values, it creates a new dictionary containing\nparameters present in an initial state and their respective values.\n\nArgs:\n    param_values: Dictionary which relates parameter values to the parameters or a list of\n        values.\n    init_state_parameters: Parameters present in a quantum state.\n\nReturns:\n    Dictionary that maps parameters of an initial state to some values.\n\nRaises:\n    ValueError: If the dictionary with parameter values provided does not include all\n        parameters present in the initial state or if the list of values provided is not the\n        same length as the list of parameters.\n    TypeError: If an unsupported type of ``param_values`` provided.",
        "api_signature": "_create_init_state_param_dict(param_values, init_state_parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/time_evolvers/variational/var_qte.py"
    },
    {
        "api_name": "_validate_aux_ops",
        "full_api_name": "VarQTE._validate_aux_ops",
        "api_description": "",
        "api_signature": "_validate_aux_ops(self, evolution_problem)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/time_evolvers/variational/var_qte.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "VarQRTE.__init__",
        "api_description": "Args:\n    ansatz: Ansatz to be used for variational time evolution.\n    initial_parameters: Initial parameter values for an ansatz.\n    variational_principle: Variational Principle to be used. Defaults to\n        ``RealMcLachlanPrinciple``.\n    estimator: An estimator primitive used for calculating expectation values of\n        TimeEvolutionProblem.aux_operators.\n    ode_solver: ODE solver callable that implements a SciPy ``OdeSolver`` interface or a\n        string indicating a valid method offered by SciPy.\n    lse_solver: Linear system of equations solver callable. It accepts ``A`` and ``b`` to\n        solve ``Ax=b`` and returns ``x``. If ``None``, the default ``np.linalg.lstsq``\n        solver is used.\n    num_timesteps: The number of timesteps to take. If ``None``, it is\n        automatically selected to achieve a timestep of approximately 0.01. Only\n        relevant in case of the ``ForwardEulerSolver``.\n    imag_part_tol: Allowed value of an imaginary part that can be neglected if no\n        imaginary part is expected.\n    num_instability_tol: The amount of negative value that is allowed to be\n        rounded up to 0 for quantities that are expected to be\n        non-negative.",
        "api_signature": "__init__(self, ansatz, initial_parameters, variational_principle, estimator, ode_solver, lse_solver, num_timesteps, imag_part_tol, num_instability_tol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/time_evolvers/variational/var_qrte.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "RealMcLachlanPrinciple.__init__",
        "api_description": "Args:\n    qgt: Instance of a the GQT class used to compute the QFI.\n        If ``None`` provided, ``LinCombQGT`` is used.\n    gradient: Instance of a class used to compute the state gradient.\n        If ``None`` provided, ``LinCombEstimatorGradient`` is used.\n\nRaises:\n    AlgorithmError: If the gradient instance does not contain an estimator.",
        "api_signature": "__init__(self, qgt, gradient)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/time_evolvers/variational/variational_principles/real_mc_lachlan_principle.py"
    },
    {
        "api_name": "evolution_gradient",
        "full_api_name": "RealMcLachlanPrinciple.evolution_gradient",
        "api_description": "Calculates an evolution gradient according to the rules of this variational principle.\n\nArgs:\n    hamiltonian: Operator used for Variational Quantum Time Evolution.\n    ansatz: Quantum state in the form of a parametrized quantum circuit.\n    param_values: Values of parameters to be bound.\n    gradient_params: List of parameters with respect to which gradients should be computed.\n        If ``None`` given, gradients w.r.t. all parameters will be computed.\n\nReturns:\n    An evolution gradient.\n\nRaises:\n    AlgorithmError: If a gradient job fails.",
        "api_signature": "evolution_gradient(self, hamiltonian, ansatz, param_values, gradient_params)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/time_evolvers/variational/variational_principles/real_mc_lachlan_principle.py"
    },
    {
        "api_name": "_construct_modified_hamiltonian",
        "full_api_name": "RealMcLachlanPrinciple._construct_modified_hamiltonian",
        "api_description": "Modifies a Hamiltonian according to the rules of this variational principle.\n\nArgs:\n    hamiltonian: Operator used for Variational Quantum Time Evolution.\n    energy: The energy correction value.\n\nReturns:\n    A modified Hamiltonian.",
        "api_signature": "_construct_modified_hamiltonian(hamiltonian, energy)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/time_evolvers/variational/variational_principles/real_mc_lachlan_principle.py"
    },
    {
        "api_name": "_validate_grad_settings",
        "full_api_name": "RealMcLachlanPrinciple._validate_grad_settings",
        "api_description": "",
        "api_signature": "_validate_grad_settings(gradient)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/time_evolvers/variational/variational_principles/real_mc_lachlan_principle.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "VariationalPrinciple.__init__",
        "api_description": "Args:\n    qgt: Instance of a class used to compute the GQT.\n    gradient: Instance of a class used to compute the state gradient.",
        "api_signature": "__init__(self, qgt, gradient)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/time_evolvers/variational/variational_principles/variational_principle.py"
    },
    {
        "api_name": "metric_tensor",
        "full_api_name": "VariationalPrinciple.metric_tensor",
        "api_description": "Calculates a metric tensor according to the rules of this variational principle.\n\nArgs:\n    ansatz: Quantum state in the form of a parametrized quantum circuit.\n    param_values: Values of parameters to be bound.\n\nReturns:\n    Metric tensor.\n\nRaises:\n    AlgorithmError: If a QFI job fails.",
        "api_signature": "metric_tensor(self, ansatz, param_values)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/time_evolvers/variational/variational_principles/variational_principle.py"
    },
    {
        "api_name": "evolution_gradient",
        "full_api_name": "VariationalPrinciple.evolution_gradient",
        "api_description": "Calculates an evolution gradient according to the rules of this variational principle.\n\nArgs:\n    hamiltonian: Operator used for Variational Quantum Time Evolution.\n    ansatz: Quantum state in the form of a parametrized quantum circuit.\n    param_values: Values of parameters to be bound.\n    gradient_params: List of parameters with respect to which gradients should be computed.\n        If ``None`` given, gradients w.r.t. all parameters will be computed.\n\nReturns:\n    An evolution gradient.",
        "api_signature": "evolution_gradient(self, hamiltonian, ansatz, param_values, gradient_params)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/time_evolvers/variational/variational_principles/variational_principle.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ImaginaryMcLachlanPrinciple.__init__",
        "api_description": "Args:\n    qgt: Instance of a the GQT class used to compute the QFI.\n        If ``None`` provided, ``LinCombQGT`` is used.\n    gradient: Instance of a class used to compute the state gradient.\n        If ``None`` provided, ``LinCombEstimatorGradient`` is used.\n\nRaises:\n    AlgorithmError: If the gradient instance does not contain an estimator.",
        "api_signature": "__init__(self, qgt, gradient)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/time_evolvers/variational/variational_principles/imaginary_mc_lachlan_principle.py"
    },
    {
        "api_name": "evolution_gradient",
        "full_api_name": "ImaginaryMcLachlanPrinciple.evolution_gradient",
        "api_description": "Calculates an evolution gradient according to the rules of this variational principle.\n\nArgs:\n    hamiltonian: Operator used for Variational Quantum Time Evolution.\n    ansatz: Quantum state in the form of a parametrized quantum circuit.\n    param_values: Values of parameters to be bound.\n    gradient_params: List of parameters with respect to which gradients should be computed.\n        If ``None`` given, gradients w.r.t. all parameters will be computed.\n\nReturns:\n    An evolution gradient.\n\nRaises:\n    AlgorithmError: If a gradient job fails.",
        "api_signature": "evolution_gradient(self, hamiltonian, ansatz, param_values, gradient_params)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/time_evolvers/variational/variational_principles/imaginary_mc_lachlan_principle.py"
    },
    {
        "api_name": "_validate_grad_settings",
        "full_api_name": "ImaginaryMcLachlanPrinciple._validate_grad_settings",
        "api_description": "",
        "api_signature": "_validate_grad_settings(gradient)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/time_evolvers/variational/variational_principles/imaginary_mc_lachlan_principle.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "VarQTELinearSolver.__init__",
        "api_description": "Args:\n    var_principle: Variational Principle to be used.\n    hamiltonian: Operator used for Variational Quantum Time Evolution.\n    ansatz: Quantum state in the form of a parametrized quantum circuit.\n    gradient_params: List of parameters with respect to which gradients should be computed.\n        If ``None`` given, gradients w.r.t. all parameters will be computed.\n    t_param: Time parameter in case of a time-dependent Hamiltonian.\n    lse_solver: Linear system of equations solver callable. It accepts ``A`` and ``b`` to\n        solve ``Ax=b`` and returns ``x``. If ``None``, the default ``np.linalg.lstsq``\n        solver is used.\n    imag_part_tol: Allowed value of an imaginary part that can be neglected if no\n        imaginary part is expected.\n\nRaises:\n    TypeError: If t_param is provided and Hamiltonian is not of type SparsePauliOp.",
        "api_signature": "__init__(self, var_principle, hamiltonian, ansatz, gradient_params, t_param, lse_solver, imag_part_tol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/time_evolvers/variational/solvers/var_qte_linear_solver.py"
    },
    {
        "api_name": "lse_solver",
        "full_api_name": "VarQTELinearSolver.lse_solver",
        "api_description": "Returns an LSE solver callable.",
        "api_signature": "lse_solver(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/time_evolvers/variational/solvers/var_qte_linear_solver.py"
    },
    {
        "api_name": "lse_solver",
        "full_api_name": "VarQTELinearSolver.lse_solver",
        "api_description": "Sets an LSE solver. Uses a ``np.linalg.lstsq`` callable if ``None`` provided.",
        "api_signature": "lse_solver(self, lse_solver)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/time_evolvers/variational/solvers/var_qte_linear_solver.py"
    },
    {
        "api_name": "solve_lse",
        "full_api_name": "VarQTELinearSolver.solve_lse",
        "api_description": "Solve the system of linear equations underlying McLachlan's variational principle for the\ncalculation without error bounds.\n\nArgs:\n    param_dict: Dictionary which relates parameter values to the parameters in the ansatz.\n    time_value: Time value that will be bound to ``t_param``. It is required if ``t_param``\n        is not ``None``.\n\nReturns:\n    Solution to the LSE, A from Ax=b, b from Ax=b.\n\nRaises:\n    ValueError: If no time value is provided for time dependent hamiltonians.",
        "api_signature": "solve_lse(self, param_dict, time_value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/time_evolvers/variational/solvers/var_qte_linear_solver.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "OdeFunctionFactory.__init__",
        "api_description": "Args:\n    ode_function_type: An Enum that defines a type of an ODE function to be built. If\n        not provided, a default ``STANDARD_ODE`` is used.",
        "api_signature": "__init__(self, ode_function_type)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/time_evolvers/variational/solvers/ode/ode_function_factory.py"
    },
    {
        "api_name": "_build",
        "full_api_name": "OdeFunctionFactory._build",
        "api_description": "Initializes an ODE function specified in the class.\n\nArgs:\n    varqte_linear_solver: Solver of LSE for the VarQTE algorithm.\n    param_dict: Dictionary which relates parameter values to the parameters in the ansatz.\n    t_param: Time parameter in case of a time-dependent Hamiltonian.\n\nReturns:\n    An ODE function.\n\nRaises:\n    ValueError: If unsupported ODE function provided.",
        "api_signature": "_build(self, varqte_linear_solver, param_dict, t_param)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/time_evolvers/variational/solvers/ode/ode_function_factory.py"
    },
    {
        "api_name": "var_qte_ode_function",
        "full_api_name": "OdeFunction.var_qte_ode_function",
        "api_description": "Evaluates an ODE function for a given time and parameter values. It is used by an ODE\nsolver.\n\nArgs:\n    time: Current time of evolution.\n    parameter_values: Current values of parameters.\n\nReturns:\n    ODE gradient arising from solving a system of linear equations.",
        "api_signature": "var_qte_ode_function(self, time, parameter_values)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/time_evolvers/variational/solvers/ode/ode_function.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "AbstractOdeFunction.__init__",
        "api_description": "",
        "api_signature": "__init__(self, varqte_linear_solver, param_dict, t_param)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/time_evolvers/variational/solvers/ode/abstract_ode_function.py"
    },
    {
        "api_name": "var_qte_ode_function",
        "full_api_name": "AbstractOdeFunction.var_qte_ode_function",
        "api_description": "Evaluates an ODE function for a given time and parameter values. It is used by an ODE\nsolver.\n\nArgs:\n    time: Current time of evolution.\n    parameter_values: Current values of parameters.\n\nReturns:\n    ODE gradient arising from solving a system of linear equations.",
        "api_signature": "var_qte_ode_function(self, time, parameter_values)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/time_evolvers/variational/solvers/ode/abstract_ode_function.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ForwardEulerSolver.__init__",
        "api_description": "Forward Euler ODE solver that implements an interface from SciPy.\n\nArgs:\n    function: Right-hand side of the system. The calling signature is ``fun(t, y)``. Here\n        ``t`` is a scalar, and there are two options for the ndarray ``y``:\n        It can either have shape (n,); then ``fun`` must return array_like with\n        shape (n,). Alternatively it can have shape (n, k); then ``fun``\n        must return an array_like with shape (n, k), i.e., each column\n        corresponds to a single column in ``y``. The choice between the two\n        options is determined by `vectorized` argument (see below). The\n        vectorized implementation allows a faster approximation of the Jacobian\n        by finite differences (required for this solver).\n    t0: Initial time.\n    y0: Initial state.\n    t_bound: Boundary time - the integration won't continue beyond it. It also determines\n        the direction of the integration.\n    vectorized: Whether ``fun`` is implemented in a vectorized fashion. Default is False.\n    support_complex: Whether integration in a complex domain should be supported.\n        Generally determined by a derived solver class capabilities. Default is False.\n    num_t_steps: Number of time steps for the forward Euler method.",
        "api_signature": "__init__(self, function, t0, y0, t_bound, vectorized, support_complex, num_t_steps)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/time_evolvers/variational/solvers/ode/forward_euler_solver.py"
    },
    {
        "api_name": "_step_impl",
        "full_api_name": "ForwardEulerSolver._step_impl",
        "api_description": "Takes an Euler step.",
        "api_signature": "_step_impl(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/time_evolvers/variational/solvers/ode/forward_euler_solver.py"
    },
    {
        "api_name": "_dense_output_impl",
        "full_api_name": "ForwardEulerSolver._dense_output_impl",
        "api_description": "",
        "api_signature": "_dense_output_impl(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/time_evolvers/variational/solvers/ode/forward_euler_solver.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "VarQTEOdeSolver.__init__",
        "api_description": "Initialize ODE Solver.\n\nArgs:\n    init_params: Set of initial parameters for time 0.\n    ode_function: Generates the ODE function.\n    ode_solver: ODE solver callable that implements a SciPy ``OdeSolver`` interface or a\n        string indicating a valid method offered by SciPy.\n    num_timesteps: The number of timesteps to take. If None, it is\n        automatically selected to achieve a timestep of approximately 0.01. Only\n        relevant in case of the ``ForwardEulerSolver``.",
        "api_signature": "__init__(self, init_params, ode_function, ode_solver, num_timesteps)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/time_evolvers/variational/solvers/ode/var_qte_ode_solver.py"
    },
    {
        "api_name": "run",
        "full_api_name": "VarQTEOdeSolver.run",
        "api_description": "Finds numerical solution with ODE Solver.\n\nArgs:\n    evolution_time: Evolution time.\n\nReturns:\n    List of parameters found by an ODE solver for a given ODE function callable.",
        "api_signature": "run(self, evolution_time)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/time_evolvers/variational/solvers/ode/var_qte_ode_solver.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "IterativePhaseEstimation.__init__",
        "api_description": "Args:\n    num_iterations: The number of iterations (rounds) of the phase estimation to run.\n    quantum_instance: Deprecated: The quantum instance on which the\n        circuit will be run.\n    sampler: The sampler primitive on which the circuit will be sampled.\n\nRaises:\n    ValueError: if num_iterations is not greater than zero.\n    AlgorithmError: If neither sampler nor quantum instance is provided.",
        "api_signature": "__init__(self, num_iterations, quantum_instance, sampler)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/phase_estimators/ipe.py"
    },
    {
        "api_name": "construct_circuit",
        "full_api_name": "IterativePhaseEstimation.construct_circuit",
        "api_description": "Construct the kth iteration Quantum Phase Estimation circuit.\n\nFor details of parameters, see Fig. 2 in https://arxiv.org/pdf/quant-ph/0610214.pdf.\n\nArgs:\n    unitary: The circuit representing the unitary operator whose eigenvalue (via phase)\n         will be measured.\n    state_preparation: The circuit that prepares the state whose eigenphase will be\n         measured.  If this parameter is omitted, no preparation circuit\n         will be run and input state will be the all-zero state in the\n         computational basis.\n    k: the iteration idx.\n    omega: the feedback angle.\n    measurement: Boolean flag to indicate if measurement should\n        be included in the circuit.\n\nReturns:\n    QuantumCircuit: the quantum circuit per iteration",
        "api_signature": "construct_circuit(self, unitary, state_preparation, k, omega, measurement)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/phase_estimators/ipe.py"
    },
    {
        "api_name": "_estimate_phase_iteratively",
        "full_api_name": "IterativePhaseEstimation._estimate_phase_iteratively",
        "api_description": "Main loop of iterative phase estimation.",
        "api_signature": "_estimate_phase_iteratively(self, unitary, state_preparation)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/phase_estimators/ipe.py"
    },
    {
        "api_name": "estimate",
        "full_api_name": "IterativePhaseEstimation.estimate",
        "api_description": "Estimate the eigenphase of the input unitary and initial-state pair.\n\nArgs:\n    unitary: The circuit representing the unitary operator whose eigenvalue (via phase)\n             will be measured.\n    state_preparation: The circuit that prepares the state whose eigenphase will be\n             measured.  If this parameter is omitted, no preparation circuit\n             will be run and input state will be the all-zero state in the\n             computational basis.\n\nReturns:\n    Estimated phase in an IterativePhaseEstimationResult object.\n\nRaises:\n    AlgorithmError: If neither sampler nor quantum instance is provided.",
        "api_signature": "estimate(self, unitary, state_preparation)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/phase_estimators/ipe.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "IterativePhaseEstimationResult.__init__",
        "api_description": "Args:\n    num_iterations: number of iterations used in the phase estimation.\n    phase: the estimated phase.",
        "api_signature": "__init__(self, num_iterations, phase)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/phase_estimators/ipe.py"
    },
    {
        "api_name": "phase",
        "full_api_name": "IterativePhaseEstimationResult.phase",
        "api_description": "Return the estimated phase as a number in :math:`[0.0, 1.0)`.\n\n1.0 corresponds to a phase of :math:`2\\pi`. It is assumed that the input vector is an\neigenvector of the unitary so that the peak of the probability density occurs at the bit\nstring that most closely approximates the true phase.",
        "api_signature": "phase(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/phase_estimators/ipe.py"
    },
    {
        "api_name": "num_iterations",
        "full_api_name": "IterativePhaseEstimationResult.num_iterations",
        "api_description": "Return the number of iterations used in the estimation algorithm.",
        "api_signature": "num_iterations(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/phase_estimators/ipe.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PhaseEstimationResult.__init__",
        "api_description": "Args:\n    num_evaluation_qubits: number of qubits in phase-readout register.\n    circuit_result: result object returned by method running circuit.\n    phases: ndarray or dict of phases and frequencies determined by QPE.",
        "api_signature": "__init__(self, num_evaluation_qubits, circuit_result, phases)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/phase_estimators/phase_estimation_result.py"
    },
    {
        "api_name": "phases",
        "full_api_name": "PhaseEstimationResult.phases",
        "api_description": "Return all phases and their frequencies computed by QPE.\n\nThis is an array or dict whose values correspond to weights on bit strings.",
        "api_signature": "phases(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/phase_estimators/phase_estimation_result.py"
    },
    {
        "api_name": "circuit_result",
        "full_api_name": "PhaseEstimationResult.circuit_result",
        "api_description": "Return the result object returned by running the QPE circuit (on hardware or simulator).\n\nThis is useful for inspecting and troubleshooting the QPE algorithm.",
        "api_signature": "circuit_result(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/phase_estimators/phase_estimation_result.py"
    },
    {
        "api_name": "most_likely_phase",
        "full_api_name": "PhaseEstimationResult.most_likely_phase",
        "api_description": "DEPRECATED - Return the most likely phase as a number in :math:`[0.0, 1.0)`.\n\n1.0 corresponds to a phase of :math:`2\\pi`. This selects the phase corresponding\nto the bit string with the highesest probability. This is the most likely phase.",
        "api_signature": "most_likely_phase(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/phase_estimators/phase_estimation_result.py"
    },
    {
        "api_name": "phase",
        "full_api_name": "PhaseEstimationResult.phase",
        "api_description": "Return the most likely phase as a number in :math:`[0.0, 1.0)`.\n\n1.0 corresponds to a phase of :math:`2\\pi`. This selects the phase corresponding\nto the bit string with the highesest probability. This is the most likely phase.",
        "api_signature": "phase(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/phase_estimators/phase_estimation_result.py"
    },
    {
        "api_name": "filter_phases",
        "full_api_name": "PhaseEstimationResult.filter_phases",
        "api_description": "Return a filtered dict of phases (keys) and frequencies (values).\n\nOnly phases with frequencies (counts) larger than `cutoff` are included.\nIt is assumed that the `run` method has been called so that the phases have been computed.\nWhen using a noiseless, shot-based simulator to read a single phase that can\nbe represented exactly by `num_evaluation_qubits`, all the weight will\nbe concentrated on a single phase. In all other cases, many, or all, bit\nstrings will have non-zero weight. This method is useful for filtering\nout these uninteresting bit strings.\n\nArgs:\n    cutoff: Minimum weight of number of counts required to keep a bit string.\n        The default value is `0.0`.\n    as_float: If `True`, returned keys are floats in :math:`[0.0, 1.0)`. If `False`\n        returned keys are bit strings.\n\nReturns:\n    A filtered dict of phases (keys) and frequencies (values).",
        "api_signature": "filter_phases(self, cutoff, as_float)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/phase_estimators/phase_estimation_result.py"
    },
    {
        "api_name": "_bit_string_to_phase",
        "full_api_name": "_bit_string_to_phase",
        "api_description": "Convert bit string to a normalized phase in :math:`[0,1)`.\n\nIt is assumed that the bit string is correctly padded and that the order of\nthe bits has been reversed relative to their order when the counts\nwere recorded. The LSB is the right most when interpreting the bitstring as\na phase.\n\nArgs:\n    binary_string: A string of characters '0' and '1'.\n\nReturns:\n    A phase scaled to :math:`[0,1)`.",
        "api_signature": "_bit_string_to_phase(binary_string)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/phase_estimators/phase_estimation_result.py"
    },
    {
        "api_name": "_sort_phases",
        "full_api_name": "_sort_phases",
        "api_description": "Sort a dict of bit strings representing phases (keys) and frequencies (values) by bit string.\n\nThe bit strings are sorted according to increasing phase. This relies on Python\npreserving insertion order when building dicts.",
        "api_signature": "_sort_phases(phases)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/phase_estimators/phase_estimation_result.py"
    },
    {
        "api_name": "estimate",
        "full_api_name": "PhaseEstimator.estimate",
        "api_description": "Estimate the phase.",
        "api_signature": "estimate(self, unitary, state_preparation)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/phase_estimators/phase_estimator.py"
    },
    {
        "api_name": "_get_reversed_bitstring",
        "full_api_name": "PhaseEstimator._get_reversed_bitstring",
        "api_description": "",
        "api_signature": "_get_reversed_bitstring(length, number)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/phase_estimators/phase_estimator.py"
    },
    {
        "api_name": "phase",
        "full_api_name": "PhaseEstimatorResult.phase",
        "api_description": "Return the estimated phase as a number in :math:`[0.0, 1.0)`.\n\n1.0 corresponds to a phase of :math:`2\\pi`. In case the phase estimation algorithm\ncomputes more than one phase, this attribute returns a canonical single phase; for\nexample, the most likely phase.",
        "api_signature": "phase(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/phase_estimators/phase_estimator.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PhaseEstimationScale.__init__",
        "api_description": "Args:\n    bound: an upper bound on the absolute value of the eigenvalues of a Hermitian operator.\n        (The operator is not needed here.)",
        "api_signature": "__init__(self, bound)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/phase_estimators/phase_estimation_scale.py"
    },
    {
        "api_name": "scale",
        "full_api_name": "PhaseEstimationScale.scale",
        "api_description": "Return the Hamiltonian scaling factor.\n\nReturn the scale factor by which a Hermitian operator must be multiplied\nso that the phase of the corresponding unitary is restricted to :math:`[-\\pi, \\pi]`.\nThis factor is computed from the bound on the absolute values of the eigenvalues\nof the operator. The methods ``scale_phase`` and ``scale_phases`` are used recover\nthe eigenvalues corresponding the original (unscaled) Hermitian operator.\n\nReturns:\n    The scale factor.",
        "api_signature": "scale(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/phase_estimators/phase_estimation_scale.py"
    },
    {
        "api_name": "scale_phase",
        "full_api_name": "PhaseEstimationScale.scale_phase",
        "api_description": "Convert a phase into an eigenvalue.\n\nThe input phase ``phi`` corresponds to the eigenvalue of a unitary obtained by\nexponentiating a scaled Hermitian operator. Recall that the phase\nis obtained from ``phi`` as :math:`2\\pi\\phi`. Furthermore, the Hermitian operator\nwas scaled so that ``phi`` is restricted to :math:`[-1/2, 1/2]`, corresponding to\nphases in :math:`[-\\pi, \\pi]`. But the values of `phi` read from the phase-readout\nregister are in :math:`[0, 1)`. Any value of ``phi`` greater than :math:`1/2` corresponds\nto a raw phase of minus the complement with respect to 1. After this possible\nshift, the phase is scaled by the inverse of the factor by which the\nHermitian operator was scaled to recover the eigenvalue of the Hermitian\noperator.\n\nArgs:\n    phi: Normalized phase in :math:`[0, 1)` to be converted to an eigenvalue.\n    id_coefficient: All eigenvalues are shifted by this value.\n\nReturns:\n    An eigenvalue computed from the input phase.",
        "api_signature": "scale_phase(self, phi, id_coefficient)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/phase_estimators/phase_estimation_scale.py"
    },
    {
        "api_name": "scale_phases",
        "full_api_name": "PhaseEstimationScale.scale_phases",
        "api_description": "Convert a list or dict of phases to eigenvalues.\n\nThe values in the list, or keys in the dict, are values of ``phi` and\nare converted as described in the description of ``scale_phase``. In case\n``phases`` is a dict, the values of the dict are passed unchanged.\n\nArgs:\n    phases: a list or dict of values of ``phi``.\n    id_coefficient: All eigenvalues are shifted by this value.\n\nReturns:\n    Eigenvalues computed from phases.",
        "api_signature": "scale_phases(self, phases, id_coefficient)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/phase_estimators/phase_estimation_scale.py"
    },
    {
        "api_name": "from_pauli_sum",
        "full_api_name": "PhaseEstimationScale.from_pauli_sum",
        "api_description": "Create a PhaseEstimationScale from a `SummedOp` representing a sum of Pauli Operators.\n\nIt is assumed that the ``pauli_sum`` is the sum of ``PauliOp`` objects. The bound on\nthe absolute value of the eigenvalues of the sum is obtained as the sum of the\nabsolute values of the coefficients of the terms. This is the best bound available in\nthe generic case. A ``PhaseEstimationScale`` object is instantiated using this bound.\n\nArgs:\n    pauli_sum: A ``SummedOp`` whose terms are ``PauliOp`` objects.\n\nRaises:\n    ValueError: if ``pauli_sum`` is not a sum of Pauli operators.\n\nReturns:\n    A ``PhaseEstimationScale`` object",
        "api_signature": "from_pauli_sum(cls, pauli_sum)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/phase_estimators/phase_estimation_scale.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PhaseEstimation.__init__",
        "api_description": "Args:\n    num_evaluation_qubits: The number of qubits used in estimating the phase. The phase will\n        be estimated as a binary string with this many bits.\n    quantum_instance: Deprecated: The quantum instance on which the\n        circuit will be run.\n    sampler: The sampler primitive on which the circuit will be sampled.\n\nRaises:\n    AlgorithmError: If neither sampler nor quantum instance is provided.",
        "api_signature": "__init__(self, num_evaluation_qubits, quantum_instance, sampler)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/phase_estimators/phase_estimation.py"
    },
    {
        "api_name": "construct_circuit",
        "full_api_name": "PhaseEstimation.construct_circuit",
        "api_description": "Return the circuit to be executed to estimate phases.\n\nThis circuit includes as sub-circuits the core phase estimation circuit,\nwith the addition of the state-preparation circuit and possibly measurement instructions.",
        "api_signature": "construct_circuit(self, unitary, state_preparation)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/phase_estimators/phase_estimation.py"
    },
    {
        "api_name": "_add_measurement_if_required",
        "full_api_name": "PhaseEstimation._add_measurement_if_required",
        "api_description": "",
        "api_signature": "_add_measurement_if_required(self, pe_circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/phase_estimators/phase_estimation.py"
    },
    {
        "api_name": "_compute_phases",
        "full_api_name": "PhaseEstimation._compute_phases",
        "api_description": "Compute frequencies/counts of phases from the result of running the QPE circuit.\n\nHow the frequencies are computed depends on whether the backend computes amplitude or\nsamples outcomes.\n\n1) If the backend is a statevector simulator, then the reduced density matrix of the\nphase-reading register is computed from the combined phase-reading- and input-state\nregisters. The elements of the diagonal :math:`(i, i)` give the probability to measure the\neach of the states `i`. The index `i` expressed as a binary integer with the LSB rightmost\ngives the state of the phase-reading register with the LSB leftmost when interpreted as a\nphase. In order to maintain the compact representation, the phases are maintained as decimal\nintegers.  They may be converted to other forms via the results object,\n`PhaseEstimationResult` or `HamiltonianPhaseEstimationResult`.\n\n 2) If the backend samples bitstrings, then the counts are first retrieved as a dict.  The\nbinary strings (the keys) are then reversed so that the LSB is rightmost and the counts are\nconverted to frequencies. Then the keys are sorted according to increasing phase, so that\nthey can be easily understood when displaying or plotting a histogram.\n\nArgs:\n    num_unitary_qubits: The number of qubits in the unitary.\n    circuit_result: the result object returned by the backend that ran the QPE circuit.\n\nReturns:\n    Either a dict or numpy.ndarray representing the frequencies of the phases.",
        "api_signature": "_compute_phases(self, num_unitary_qubits, circuit_result)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/phase_estimators/phase_estimation.py"
    },
    {
        "api_name": "estimate_from_pe_circuit",
        "full_api_name": "PhaseEstimation.estimate_from_pe_circuit",
        "api_description": "Run the phase estimation algorithm on a phase estimation circuit\n\nArgs:\n    pe_circuit: The phase estimation circuit.\n    num_unitary_qubits: Must agree with the number of qubits in the unitary in `pe_circuit`.\n\nReturns:\n    An instance of qiskit.algorithms.phase_estimator_result.PhaseEstimationResult.\n\nRaises:\n    AlgorithmError: Primitive job failed.",
        "api_signature": "estimate_from_pe_circuit(self, pe_circuit, num_unitary_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/phase_estimators/phase_estimation.py"
    },
    {
        "api_name": "estimate",
        "full_api_name": "PhaseEstimation.estimate",
        "api_description": "Build a phase estimation circuit and run the corresponding algorithm.\n\nArgs:\n    unitary: The circuit representing the unitary operator whose eigenvalues (via phase)\n        will be measured.\n    state_preparation: The circuit that prepares the state whose eigenphase will be\n        measured.  If this parameter is omitted, no preparation circuit\n        will be run and input state will be the all-zero state in the\n        computational basis.\n\nReturns:\n    An instance of qiskit.algorithms.phase_estimator_result.PhaseEstimationResult.",
        "api_signature": "estimate(self, unitary, state_preparation)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/phase_estimators/phase_estimation.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "HamiltonianPhaseEstimation.__init__",
        "api_description": "Args:\n    num_evaluation_qubits: The number of qubits used in estimating the phase. The phase will\n        be estimated as a binary string with this many bits.\n    quantum_instance: Deprecated: The quantum instance on which\n        the circuit will be run.\n    sampler: The sampler primitive on which the circuit will be sampled.",
        "api_signature": "__init__(self, num_evaluation_qubits, quantum_instance, sampler)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/phase_estimators/hamiltonian_phase_estimation.py"
    },
    {
        "api_name": "_get_scale",
        "full_api_name": "HamiltonianPhaseEstimation._get_scale",
        "api_description": "",
        "api_signature": "_get_scale(self, hamiltonian, bound)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/phase_estimators/hamiltonian_phase_estimation.py"
    },
    {
        "api_name": "_get_unitary",
        "full_api_name": "HamiltonianPhaseEstimation._get_unitary",
        "api_description": "Evolve the Hamiltonian to obtain a unitary.\n\nApply the scaling to the Hamiltonian that has been computed from an eigenvalue bound\nand compute the unitary by applying the evolution object.",
        "api_signature": "_get_unitary(self, hamiltonian, pe_scale, evolution)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/phase_estimators/hamiltonian_phase_estimation.py"
    },
    {
        "api_name": "estimate",
        "full_api_name": "HamiltonianPhaseEstimation.estimate",
        "api_description": "Run the Hamiltonian phase estimation algorithm.\n\nArgs:\n    hamiltonian: A Hermitian operator. If the algorithm is used with a ``Sampler``\n        primitive, the allowed types are ``Pauli``, ``SparsePauliOp``, and ``PauliSumOp``.\n        If the algorithm is used with a ``QuantumInstance``, ``PauliOp, ``MatrixOp``,\n        ``PauliSumOp``, and ``SummedOp`` types are allowed.\n    state_preparation: The ``StateFn`` to be prepared, whose eigenphase will be\n        measured. If this parameter is omitted, no preparation circuit will be run and\n        input state will be the all-zero state in the computational basis.\n    evolution: An evolution converter that generates a unitary from ``hamiltonian``. If\n        ``None``, then the default ``PauliTrotterEvolution`` is used.\n    bound: An upper bound on the absolute value of the eigenvalues of\n        ``hamiltonian``. If omitted, then ``hamiltonian`` must be a Pauli sum, or a\n        ``PauliOp``, in which case a bound will be computed. If ``hamiltonian``\n        is a ``MatrixOp``, then ``bound`` may not be ``None``. The tighter the bound,\n        the higher the resolution of computed phases.\n\nReturns:\n    ``HamiltonianPhaseEstimationResult`` instance containing the result of the estimation\n    and diagnostic information.\n\nRaises:\n    TypeError: If ``evolution`` is not of type ``EvolutionSynthesis`` when a ``Sampler`` is\n        provided.\n    TypeError: If ``hamiltonian`` type is not ``Pauli`` or ``SparsePauliOp`` or\n        ``PauliSumOp`` when a ``Sampler`` is provided.\n    ValueError: If ``bound`` is ``None`` and ``hamiltonian`` is not a Pauli sum, i.e. a\n        ``PauliSumOp`` or a ``SummedOp`` whose terms are of type ``PauliOp``.\n    TypeError: If ``evolution`` is not of type ``EvolutionBase`` when no ``Sampler`` is\n        provided.",
        "api_signature": "estimate(self, hamiltonian, state_preparation, evolution, bound)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/phase_estimators/hamiltonian_phase_estimation.py"
    },
    {
        "api_name": "_remove_identity",
        "full_api_name": "_remove_identity",
        "api_description": "Remove any identity operators from `pauli_sum`. Return\nthe sum of the coefficients of the identities and the new operator.",
        "api_signature": "_remove_identity(pauli_sum)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/phase_estimators/hamiltonian_phase_estimation.py"
    },
    {
        "api_name": "_remove_identity_pauli_sum_op",
        "full_api_name": "_remove_identity_pauli_sum_op",
        "api_description": "Remove any identity operators from ``pauli_sum``. Return\nthe sum of the coefficients of the identities and the new operator.",
        "api_signature": "_remove_identity_pauli_sum_op(pauli_sum)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/phase_estimators/hamiltonian_phase_estimation.py"
    },
    {
        "api_name": "_get_identity",
        "full_api_name": "_get_identity",
        "api_description": "",
        "api_signature": "_get_identity(size)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/phase_estimators/hamiltonian_phase_estimation.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "HamiltonianPhaseEstimationResult.__init__",
        "api_description": "Args:\n    phase_estimation_result: The result object returned by PhaseEstimation.estimate.\n    phase_estimation_scale: object used to scale phases to obtain eigenvalues.\n    id_coefficient: The coefficient of the identity term in the Hamiltonian.\n                    Eigenvalues are computed without this term so that the\n                    coefficient must added to give correct eigenvalues.\n                    This is done automatically when retrieving eigenvalues.",
        "api_signature": "__init__(self, phase_estimation_result, phase_estimation_scale, id_coefficient)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/phase_estimators/hamiltonian_phase_estimation_result.py"
    },
    {
        "api_name": "filter_phases",
        "full_api_name": "HamiltonianPhaseEstimationResult.filter_phases",
        "api_description": "Filter phases as does `PhaseEstimatorResult.filter_phases`, with\nthe addition that `phi` is shifted and translated to return eigenvalues\nof the Hamiltonian.\n\nArgs:\n    cutoff: Minimum weight of number of counts required to keep a bit string.\n        The default value is `0.0`.\n    scaled: If False, return `phi` in :math:`[0, 1)` rather than the eigenvalues of\n        the Hamiltonian.\n    as_float: If `True`, returned keys are floats in :math:`[0.0, 1.0)`. If `False`\n        returned keys are bit strings.\n\nRaises:\n    ValueError: if `as_float` is `False` and `scaled` is `True`.\n\nReturns:\n    A dict of filtered phases.",
        "api_signature": "filter_phases(self, cutoff, scaled, as_float)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/phase_estimators/hamiltonian_phase_estimation_result.py"
    },
    {
        "api_name": "phase",
        "full_api_name": "HamiltonianPhaseEstimationResult.phase",
        "api_description": "The most likely phase of the unitary corresponding to the Hamiltonian.\n\nReturns:\n    The most likely phase.",
        "api_signature": "phase(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/phase_estimators/hamiltonian_phase_estimation_result.py"
    },
    {
        "api_name": "most_likely_eigenvalue",
        "full_api_name": "HamiltonianPhaseEstimationResult.most_likely_eigenvalue",
        "api_description": "The most likely eigenvalue of the Hamiltonian.\n\nThis method calls `most_likely_phase` and scales the result to\nobtain an eigenvalue.\n\nReturns:\n    The most likely eigenvalue of the Hamiltonian.",
        "api_signature": "most_likely_eigenvalue(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/phase_estimators/hamiltonian_phase_estimation_result.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "NumPyEigensolver.__init__",
        "api_description": "Args:\n    k: Number of eigenvalues are to be computed, with a minimum value of 1.\n    filter_criterion: Callable that allows to filter eigenvalues/eigenstates. Only feasible\n        eigenstates are returned in the results. The callable has the signature\n        ``filter(eigenstate, eigenvalue, aux_values)`` and must return a boolean to indicate\n        whether to keep this value in the final returned result or not. If the number of\n        elements that satisfies the criterion is smaller than ``k``, then the returned list will\n        have fewer elements and can even be empty.",
        "api_signature": "__init__(self, k, filter_criterion)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigensolvers/numpy_eigensolver.py"
    },
    {
        "api_name": "k",
        "full_api_name": "NumPyEigensolver.k",
        "api_description": "Return k (number of eigenvalues requested).",
        "api_signature": "k(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigensolvers/numpy_eigensolver.py"
    },
    {
        "api_name": "k",
        "full_api_name": "NumPyEigensolver.k",
        "api_description": "Set k (number of eigenvalues requested).",
        "api_signature": "k(self, k)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigensolvers/numpy_eigensolver.py"
    },
    {
        "api_name": "filter_criterion",
        "full_api_name": "NumPyEigensolver.filter_criterion",
        "api_description": "Return the filter criterion if set.",
        "api_signature": "filter_criterion(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigensolvers/numpy_eigensolver.py"
    },
    {
        "api_name": "filter_criterion",
        "full_api_name": "NumPyEigensolver.filter_criterion",
        "api_description": "Set the filter criterion.",
        "api_signature": "filter_criterion(self, filter_criterion)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigensolvers/numpy_eigensolver.py"
    },
    {
        "api_name": "supports_aux_operators",
        "full_api_name": "NumPyEigensolver.supports_aux_operators",
        "api_description": "",
        "api_signature": "supports_aux_operators(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigensolvers/numpy_eigensolver.py"
    },
    {
        "api_name": "_check_set_k",
        "full_api_name": "NumPyEigensolver._check_set_k",
        "api_description": "",
        "api_signature": "_check_set_k(self, operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigensolvers/numpy_eigensolver.py"
    },
    {
        "api_name": "_solve",
        "full_api_name": "NumPyEigensolver._solve",
        "api_description": "",
        "api_signature": "_solve(self, operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigensolvers/numpy_eigensolver.py"
    },
    {
        "api_name": "_solve_sparse",
        "full_api_name": "NumPyEigensolver._solve_sparse",
        "api_description": "",
        "api_signature": "_solve_sparse(op_matrix, k)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigensolvers/numpy_eigensolver.py"
    },
    {
        "api_name": "_solve_dense",
        "full_api_name": "NumPyEigensolver._solve_dense",
        "api_description": "",
        "api_signature": "_solve_dense(op_matrix)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigensolvers/numpy_eigensolver.py"
    },
    {
        "api_name": "_eval_aux_operators",
        "full_api_name": "NumPyEigensolver._eval_aux_operators",
        "api_description": "",
        "api_signature": "_eval_aux_operators(aux_operators, wavefn, threshold)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigensolvers/numpy_eigensolver.py"
    },
    {
        "api_name": "compute_eigenvalues",
        "full_api_name": "NumPyEigensolver.compute_eigenvalues",
        "api_description": "",
        "api_signature": "compute_eigenvalues(self, operator, aux_operators)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigensolvers/numpy_eigensolver.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "NumPyEigensolverResult.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigensolvers/numpy_eigensolver.py"
    },
    {
        "api_name": "eigenstates",
        "full_api_name": "NumPyEigensolverResult.eigenstates",
        "api_description": "Return eigenstates.",
        "api_signature": "eigenstates(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigensolvers/numpy_eigensolver.py"
    },
    {
        "api_name": "eigenstates",
        "full_api_name": "NumPyEigensolverResult.eigenstates",
        "api_description": "Set eigenstates.",
        "api_signature": "eigenstates(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigensolvers/numpy_eigensolver.py"
    },
    {
        "api_name": "compute_eigenvalues",
        "full_api_name": "Eigensolver.compute_eigenvalues",
        "api_description": "Computes the minimum eigenvalue. The ``operator`` and ``aux_operators`` are supplied here.\nWhile an ``operator`` is required by algorithms, ``aux_operators`` are optional.\n\nArgs:\n    operator: Qubit operator of the observable.\n    aux_operators: Optional list of auxiliary operators to be evaluated with the\n        eigenstate of the minimum eigenvalue main result and their expectation values\n        returned. For instance, in chemistry, these can be dipole operators and total particle\n        count operators, so we can get values for these at the ground state.\n\nReturns:\n     An eigensolver result.",
        "api_signature": "compute_eigenvalues(self, operator, aux_operators)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigensolvers/eigensolver.py"
    },
    {
        "api_name": "supports_aux_operators",
        "full_api_name": "Eigensolver.supports_aux_operators",
        "api_description": "Whether computing the expectation value of auxiliary operators is supported.\n\nIf the eigensolver computes the eigenvalues of the main operator, then it can compute\nthe expectation value of the ``aux_operators`` for that state. Otherwise they will be ignored.\n\nReturns:\n    ``True`` if ``aux_operator`` expectations can be evaluated, ``False`` otherwise.",
        "api_signature": "supports_aux_operators(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigensolvers/eigensolver.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "EigensolverResult.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigensolvers/eigensolver.py"
    },
    {
        "api_name": "eigenvalues",
        "full_api_name": "EigensolverResult.eigenvalues",
        "api_description": "Return the eigenvalues.",
        "api_signature": "eigenvalues(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigensolvers/eigensolver.py"
    },
    {
        "api_name": "eigenvalues",
        "full_api_name": "EigensolverResult.eigenvalues",
        "api_description": "Set the eigenvalues.",
        "api_signature": "eigenvalues(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigensolvers/eigensolver.py"
    },
    {
        "api_name": "aux_operators_evaluated",
        "full_api_name": "EigensolverResult.aux_operators_evaluated",
        "api_description": "Return the aux operator expectation values.\n\nThese values are in fact tuples formatted as (mean, metadata).",
        "api_signature": "aux_operators_evaluated(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigensolvers/eigensolver.py"
    },
    {
        "api_name": "aux_operators_evaluated",
        "full_api_name": "EigensolverResult.aux_operators_evaluated",
        "api_description": "Set the aux operator eigenvalues.",
        "api_signature": "aux_operators_evaluated(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigensolvers/eigensolver.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "VQD.__init__",
        "api_description": "Args:\n    estimator: The estimator primitive.\n    fidelity: The fidelity class using primitives.\n    ansatz: A parameterized circuit used as ansatz for the wave function.\n    optimizer: A classical optimizer or a list of optimizers, one for every k-th eigenvalue.\n    Can either be a Qiskit optimizer or a callable\n        that takes an array as input and returns a Qiskit or SciPy optimization result.\n    k: The number of eigenvalues to return. Returns the lowest k eigenvalues.\n    betas: Beta parameters in the VQD paper.\n        Should have length k - 1, with k the number of excited states.\n        These hyperparameters balance the contribution of each overlap term to the cost\n        function and have a default value computed as the mean square sum of the\n        coefficients of the observable.\n    initial_point: An optional initial point (i.e. initial parameter values)\n        or a list of initial points (one for every k-th eigenvalue)\n        for the optimizer.\n        If ``None`` then VQD will look to the ansatz for a preferred\n        point and if not will simply compute a random one.\n    callback: A callback that can access the intermediate data\n        during the optimization. Four parameter values are passed to the callback as\n        follows during each evaluation by the optimizer: the evaluation count,\n        the optimizer parameters for the ansatz, the estimated value,\n        the estimation metadata, and the current step.",
        "api_signature": "__init__(self, estimator, fidelity, ansatz, optimizer)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigensolvers/vqd.py"
    },
    {
        "api_name": "initial_point",
        "full_api_name": "VQD.initial_point",
        "api_description": "Returns initial point.",
        "api_signature": "initial_point(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigensolvers/vqd.py"
    },
    {
        "api_name": "initial_point",
        "full_api_name": "VQD.initial_point",
        "api_description": "Sets initial point",
        "api_signature": "initial_point(self, initial_point)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigensolvers/vqd.py"
    },
    {
        "api_name": "_check_operator_ansatz",
        "full_api_name": "VQD._check_operator_ansatz",
        "api_description": "Check that the number of qubits of operator and ansatz match.",
        "api_signature": "_check_operator_ansatz(self, operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigensolvers/vqd.py"
    },
    {
        "api_name": "supports_aux_operators",
        "full_api_name": "VQD.supports_aux_operators",
        "api_description": "",
        "api_signature": "supports_aux_operators(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigensolvers/vqd.py"
    },
    {
        "api_name": "compute_eigenvalues",
        "full_api_name": "VQD.compute_eigenvalues",
        "api_description": "",
        "api_signature": "compute_eigenvalues(self, operator, aux_operators)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigensolvers/vqd.py"
    },
    {
        "api_name": "_get_evaluate_energy",
        "full_api_name": "VQD._get_evaluate_energy",
        "api_description": "Returns a function handle to evaluate the ansatz's energy for any given parameters.\n    This is the objective function to be passed to the optimizer that is used for evaluation.\n\nArgs:\n    step: level of energy being calculated. 0 for ground, 1 for first excited state...\n    operator: The operator whose energy to evaluate.\n    betas: Beta parameters in the VQD paper.\n    prev_states: List of optimal circuits from previous rounds of optimization.\n\nReturns:\n    A callable that computes and returns the energy of the hamiltonian\n    of each parameter.\n\nRaises:\n    AlgorithmError: If the circuit is not parameterized (i.e. has 0 free parameters).\n    AlgorithmError: If operator was not provided.\n    RuntimeError: If the previous states array is of the wrong size.",
        "api_signature": "_get_evaluate_energy(self, step, operator, betas, prev_states)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigensolvers/vqd.py"
    },
    {
        "api_name": "evaluate_energy",
        "full_api_name": "VQD.evaluate_energy",
        "api_description": "",
        "api_signature": "evaluate_energy(parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigensolvers/vqd.py"
    },
    {
        "api_name": "_build_vqd_result",
        "full_api_name": "VQD._build_vqd_result",
        "api_description": "",
        "api_signature": "_build_vqd_result()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigensolvers/vqd.py"
    },
    {
        "api_name": "_update_vqd_result",
        "full_api_name": "VQD._update_vqd_result",
        "api_description": "",
        "api_signature": "_update_vqd_result(result, opt_result, eval_time, ansatz)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigensolvers/vqd.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "VQDResult.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigensolvers/vqd.py"
    },
    {
        "api_name": "cost_function_evals",
        "full_api_name": "VQDResult.cost_function_evals",
        "api_description": "Returns number of cost optimizer evaluations",
        "api_signature": "cost_function_evals(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigensolvers/vqd.py"
    },
    {
        "api_name": "cost_function_evals",
        "full_api_name": "VQDResult.cost_function_evals",
        "api_description": "Sets number of cost function evaluations",
        "api_signature": "cost_function_evals(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigensolvers/vqd.py"
    },
    {
        "api_name": "optimizer_times",
        "full_api_name": "VQDResult.optimizer_times",
        "api_description": "Returns time taken for optimization for each step",
        "api_signature": "optimizer_times(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigensolvers/vqd.py"
    },
    {
        "api_name": "optimizer_times",
        "full_api_name": "VQDResult.optimizer_times",
        "api_description": "Sets time taken for optimization for each step",
        "api_signature": "optimizer_times(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigensolvers/vqd.py"
    },
    {
        "api_name": "optimal_values",
        "full_api_name": "VQDResult.optimal_values",
        "api_description": "Returns optimal value for each step",
        "api_signature": "optimal_values(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigensolvers/vqd.py"
    },
    {
        "api_name": "optimal_values",
        "full_api_name": "VQDResult.optimal_values",
        "api_description": "Sets optimal values",
        "api_signature": "optimal_values(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigensolvers/vqd.py"
    },
    {
        "api_name": "optimal_points",
        "full_api_name": "VQDResult.optimal_points",
        "api_description": "Returns optimal point for each step",
        "api_signature": "optimal_points(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigensolvers/vqd.py"
    },
    {
        "api_name": "optimal_points",
        "full_api_name": "VQDResult.optimal_points",
        "api_description": "Sets optimal points",
        "api_signature": "optimal_points(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigensolvers/vqd.py"
    },
    {
        "api_name": "optimal_parameters",
        "full_api_name": "VQDResult.optimal_parameters",
        "api_description": "Returns the optimal parameters for each step",
        "api_signature": "optimal_parameters(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigensolvers/vqd.py"
    },
    {
        "api_name": "optimal_parameters",
        "full_api_name": "VQDResult.optimal_parameters",
        "api_description": "Sets optimal parameters",
        "api_signature": "optimal_parameters(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigensolvers/vqd.py"
    },
    {
        "api_name": "optimizer_results",
        "full_api_name": "VQDResult.optimizer_results",
        "api_description": "Returns the optimizer results for each step",
        "api_signature": "optimizer_results(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigensolvers/vqd.py"
    },
    {
        "api_name": "optimizer_results",
        "full_api_name": "VQDResult.optimizer_results",
        "api_description": "Sets optimizer results",
        "api_signature": "optimizer_results(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigensolvers/vqd.py"
    },
    {
        "api_name": "optimal_circuits",
        "full_api_name": "VQDResult.optimal_circuits",
        "api_description": "The optimal circuits. Along with the optimal parameters,\nthese can be used to retrieve the different eigenstates.",
        "api_signature": "optimal_circuits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigensolvers/vqd.py"
    },
    {
        "api_name": "optimal_circuits",
        "full_api_name": "VQDResult.optimal_circuits",
        "api_description": "",
        "api_signature": "optimal_circuits(self, optimal_circuits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/eigensolvers/vqd.py"
    },
    {
        "api_name": "compute_minimum_eigenvalue",
        "full_api_name": "MinimumEigensolver.compute_minimum_eigenvalue",
        "api_description": "Computes the minimum eigenvalue. The ``operator`` and ``aux_operators`` are supplied here.\nWhile an ``operator`` is required by algorithms, ``aux_operators`` are optional.\n\nArgs:\n    operator: Qubit operator of the observable.\n    aux_operators: Optional list of auxiliary operators to be evaluated with the\n        parameters of the minimum eigenvalue main result and their expectation values\n        returned. For instance in chemistry these can be dipole operators and total particle\n        count operators, so we can get values for these at the ground state.\n\nReturns:\n    A minimum eigensolver result.",
        "api_signature": "compute_minimum_eigenvalue(self, operator, aux_operators)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/minimum_eigensolver.py"
    },
    {
        "api_name": "supports_aux_operators",
        "full_api_name": "MinimumEigensolver.supports_aux_operators",
        "api_description": "Whether computing the expectation value of auxiliary operators is supported.\n\nIf the minimum eigensolver computes an eigenvalue of the main ``operator`` then it can\ncompute the expectation value of the ``aux_operators`` for that state. Otherwise they will\nbe ignored.\n\nReturns:\n    True if aux_operator expectations can be evaluated, False otherwise",
        "api_signature": "supports_aux_operators(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/minimum_eigensolver.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "MinimumEigensolverResult.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/minimum_eigensolver.py"
    },
    {
        "api_name": "eigenvalue",
        "full_api_name": "MinimumEigensolverResult.eigenvalue",
        "api_description": "The computed minimum eigenvalue.",
        "api_signature": "eigenvalue(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/minimum_eigensolver.py"
    },
    {
        "api_name": "eigenvalue",
        "full_api_name": "MinimumEigensolverResult.eigenvalue",
        "api_description": "",
        "api_signature": "eigenvalue(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/minimum_eigensolver.py"
    },
    {
        "api_name": "aux_operators_evaluated",
        "full_api_name": "MinimumEigensolverResult.aux_operators_evaluated",
        "api_description": "The aux operator expectation values.\n\nThese values are in fact tuples formatted as (mean, (variance, shots)).",
        "api_signature": "aux_operators_evaluated(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/minimum_eigensolver.py"
    },
    {
        "api_name": "aux_operators_evaluated",
        "full_api_name": "MinimumEigensolverResult.aux_operators_evaluated",
        "api_description": "",
        "api_signature": "aux_operators_evaluated(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/minimum_eigensolver.py"
    },
    {
        "api_name": "compute_minimum_eigenvalue",
        "full_api_name": "SamplingMinimumEigensolver.compute_minimum_eigenvalue",
        "api_description": "Compute the minimum eigenvalue of a diagonal operator.\n\nArgs:\n    operator: Diagonal qubit operator.\n    aux_operators: Optional list of auxiliary operators to be evaluated with the\n        final state.\n\nReturns:\n    A :class:`~.SamplingMinimumEigensolverResult` containing the optimization result.",
        "api_signature": "compute_minimum_eigenvalue(self, operator, aux_operators)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/sampling_mes.py"
    },
    {
        "api_name": "supports_aux_operators",
        "full_api_name": "SamplingMinimumEigensolver.supports_aux_operators",
        "api_description": "Whether computing the expectation value of auxiliary operators is supported.\n\nIf the minimum eigensolver computes an eigenstate of the main operator then it\ncan compute the expectation value of the aux_operators for that state. Otherwise\nthey will be ignored.\n\nReturns:\n    True if aux_operator expectations can be evaluated, False otherwise",
        "api_signature": "supports_aux_operators(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/sampling_mes.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SamplingMinimumEigensolverResult.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/sampling_mes.py"
    },
    {
        "api_name": "eigenvalue",
        "full_api_name": "SamplingMinimumEigensolverResult.eigenvalue",
        "api_description": "Return the approximation to the eigenvalue.",
        "api_signature": "eigenvalue(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/sampling_mes.py"
    },
    {
        "api_name": "eigenvalue",
        "full_api_name": "SamplingMinimumEigensolverResult.eigenvalue",
        "api_description": "Set the approximation to the eigenvalue.",
        "api_signature": "eigenvalue(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/sampling_mes.py"
    },
    {
        "api_name": "eigenstate",
        "full_api_name": "SamplingMinimumEigensolverResult.eigenstate",
        "api_description": "Return the quasi-distribution sampled from the final state.\n\nThe ansatz is sampled when parameterized with the optimal parameters that where obtained\ncomputing the minimum eigenvalue. The keys represent a measured classical value and the\nvalue is a float for the quasi-probability of that result.",
        "api_signature": "eigenstate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/sampling_mes.py"
    },
    {
        "api_name": "eigenstate",
        "full_api_name": "SamplingMinimumEigensolverResult.eigenstate",
        "api_description": "Set the quasi-distribution sampled from the final state.",
        "api_signature": "eigenstate(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/sampling_mes.py"
    },
    {
        "api_name": "aux_operators_evaluated",
        "full_api_name": "SamplingMinimumEigensolverResult.aux_operators_evaluated",
        "api_description": "Return aux operator expectation values and metadata.\n\nThese are formatted as (mean, metadata).",
        "api_signature": "aux_operators_evaluated(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/sampling_mes.py"
    },
    {
        "api_name": "aux_operators_evaluated",
        "full_api_name": "SamplingMinimumEigensolverResult.aux_operators_evaluated",
        "api_description": "",
        "api_signature": "aux_operators_evaluated(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/sampling_mes.py"
    },
    {
        "api_name": "best_measurement",
        "full_api_name": "SamplingMinimumEigensolverResult.best_measurement",
        "api_description": "Return the best measurement over the entire optimization.\n\nPossesses keys: ``state``, ``bitstring``, ``value``, ``probability``.",
        "api_signature": "best_measurement(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/sampling_mes.py"
    },
    {
        "api_name": "best_measurement",
        "full_api_name": "SamplingMinimumEigensolverResult.best_measurement",
        "api_description": "Set the best measurement over the entire optimization.",
        "api_signature": "best_measurement(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/sampling_mes.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "SamplingMinimumEigensolverResult.__str__",
        "api_description": "Return a string representation of the result.",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/sampling_mes.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "_DiagonalEstimator.__init__",
        "api_description": "Evaluate the expectation of quantum state with respect to a diagonal operator.\n\nArgs:\n    sampler: The sampler used to evaluate the circuits.\n    aggregation: The aggregation function to aggregate the measurement outcomes. If a float\n        this specified the CVaR :math:`\\alpha` parameter.\n    callback: A callback which is given the best measurements of all circuits in each\n        evaluation.\n    run_options: Options for the sampler.",
        "api_signature": "__init__(self, sampler, aggregation, callback)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/diagonal_estimator.py"
    },
    {
        "api_name": "_run",
        "full_api_name": "_DiagonalEstimator._run",
        "api_description": "",
        "api_signature": "_run(self, circuits, observables, parameter_values)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/diagonal_estimator.py"
    },
    {
        "api_name": "_call",
        "full_api_name": "_DiagonalEstimator._call",
        "api_description": "",
        "api_signature": "_call(self, circuits, observables, parameter_values)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/diagonal_estimator.py"
    },
    {
        "api_name": "_get_cvar_aggregation",
        "full_api_name": "_get_cvar_aggregation",
        "api_description": "Get the aggregation function for CVaR with confidence level ``alpha``.",
        "api_signature": "_get_cvar_aggregation(alpha)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/diagonal_estimator.py"
    },
    {
        "api_name": "aggregate",
        "full_api_name": "aggregate",
        "api_description": "",
        "api_signature": "aggregate(measurements)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/diagonal_estimator.py"
    },
    {
        "api_name": "aggregate",
        "full_api_name": "aggregate",
        "api_description": "",
        "api_signature": "aggregate(measurements)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/diagonal_estimator.py"
    },
    {
        "api_name": "_evaluate_sparsepauli",
        "full_api_name": "_evaluate_sparsepauli",
        "api_description": "",
        "api_signature": "_evaluate_sparsepauli(state, observable)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/diagonal_estimator.py"
    },
    {
        "api_name": "_check_observable_is_diagonal",
        "full_api_name": "_check_observable_is_diagonal",
        "api_description": "",
        "api_signature": "_check_observable_is_diagonal(observable)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/diagonal_estimator.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "AdaptVQE.__init__",
        "api_description": "Args:\n    solver: a :class:`~.VQE` instance used internally to compute the minimum eigenvalues.\n        It is a requirement that the :attr:`~.VQE.ansatz` of this solver is of type\n        :class:`~qiskit.circuit.library.EvolvedOperatorAnsatz`.\n    gradient_threshold: once all gradients have an absolute value smaller than this\n        threshold, the algorithm has converged and terminates.\n    eigenvalue_threshold: once the eigenvalue has changed by less than this threshold from\n        one iteration to the next, the algorithm has converged and terminates. When this\n        case occurs, the excitation included in the final iteration did not result in a\n        significant improvement of the eigenvalue and, thus, the results from this iteration\n        are not considered.\n    max_iterations: the maximum number of iterations for the adaptive loop. If ``None``, the\n        algorithm is not bound in its number of iterations.\n    threshold: once all gradients have an absolute value smaller than this threshold, the\n        algorithm has converged and terminates. Defaults to ``1e-5``.",
        "api_signature": "__init__(self, solver)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/adapt_vqe.py"
    },
    {
        "api_name": "threshold",
        "full_api_name": "AdaptVQE.threshold",
        "api_description": "The threshold for the gradients.\n\nOnce all gradients have an absolute value smaller than this threshold, the algorithm has\nconverged and terminates.",
        "api_signature": "threshold(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/adapt_vqe.py"
    },
    {
        "api_name": "threshold",
        "full_api_name": "AdaptVQE.threshold",
        "api_description": "",
        "api_signature": "threshold(self, threshold)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/adapt_vqe.py"
    },
    {
        "api_name": "initial_point",
        "full_api_name": "AdaptVQE.initial_point",
        "api_description": "Returns the initial point of the internal :class:`~.VQE` solver.",
        "api_signature": "initial_point(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/adapt_vqe.py"
    },
    {
        "api_name": "initial_point",
        "full_api_name": "AdaptVQE.initial_point",
        "api_description": "Sets the initial point of the internal :class:`~.VQE` solver.",
        "api_signature": "initial_point(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/adapt_vqe.py"
    },
    {
        "api_name": "supports_aux_operators",
        "full_api_name": "AdaptVQE.supports_aux_operators",
        "api_description": "",
        "api_signature": "supports_aux_operators(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/adapt_vqe.py"
    },
    {
        "api_name": "_compute_gradients",
        "full_api_name": "AdaptVQE._compute_gradients",
        "api_description": "Computes the gradients for all available excitation operators.\n\nArgs:\n    theta: List of (up to now) optimal parameters.\n    operator: operator whose gradient needs to be computed.\nReturns:\n    List of pairs consisting of the computed gradient and excitation operator.",
        "api_signature": "_compute_gradients(self, theta, operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/adapt_vqe.py"
    },
    {
        "api_name": "_check_cyclicity",
        "full_api_name": "AdaptVQE._check_cyclicity",
        "api_description": "Auxiliary function to check for cycles in the indices of the selected excitations.\n\nArgs:\n    indices: The list of chosen gradient indices.\n\nReturns:\n    Whether repeating sequences of indices have been detected.",
        "api_signature": "_check_cyclicity(indices)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/adapt_vqe.py"
    },
    {
        "api_name": "compute_minimum_eigenvalue",
        "full_api_name": "AdaptVQE.compute_minimum_eigenvalue",
        "api_description": "Computes the minimum eigenvalue.\n\nArgs:\n    operator: Operator whose minimum eigenvalue we want to find.\n    aux_operators: Additional auxiliary operators to evaluate.\n\nRaises:\n    TypeError: If an ansatz other than :class:`~.EvolvedOperatorAnsatz` is provided.\n    QiskitError: If all evaluated gradients lie below the convergence threshold in the first\n        iteration of the algorithm.\n\nReturns:\n    An :class:`~.AdaptVQEResult` which is a :class:`~.VQEResult` but also but also\n    includes runtime information about the AdaptVQE algorithm like the number of iterations,\n    termination criterion, and the final maximum gradient.",
        "api_signature": "compute_minimum_eigenvalue(self, operator, aux_operators)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/adapt_vqe.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "AdaptVQEResult.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/adapt_vqe.py"
    },
    {
        "api_name": "num_iterations",
        "full_api_name": "AdaptVQEResult.num_iterations",
        "api_description": "Returns the number of iterations.",
        "api_signature": "num_iterations(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/adapt_vqe.py"
    },
    {
        "api_name": "num_iterations",
        "full_api_name": "AdaptVQEResult.num_iterations",
        "api_description": "Sets the number of iterations.",
        "api_signature": "num_iterations(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/adapt_vqe.py"
    },
    {
        "api_name": "final_max_gradient",
        "full_api_name": "AdaptVQEResult.final_max_gradient",
        "api_description": "Returns the final maximum gradient.",
        "api_signature": "final_max_gradient(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/adapt_vqe.py"
    },
    {
        "api_name": "final_max_gradient",
        "full_api_name": "AdaptVQEResult.final_max_gradient",
        "api_description": "Sets the final maximum gradient.",
        "api_signature": "final_max_gradient(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/adapt_vqe.py"
    },
    {
        "api_name": "termination_criterion",
        "full_api_name": "AdaptVQEResult.termination_criterion",
        "api_description": "Returns the termination criterion.",
        "api_signature": "termination_criterion(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/adapt_vqe.py"
    },
    {
        "api_name": "termination_criterion",
        "full_api_name": "AdaptVQEResult.termination_criterion",
        "api_description": "Sets the termination criterion.",
        "api_signature": "termination_criterion(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/adapt_vqe.py"
    },
    {
        "api_name": "eigenvalue_history",
        "full_api_name": "AdaptVQEResult.eigenvalue_history",
        "api_description": "Returns the history of computed eigenvalues.\n\nThe history's length matches the number of iterations and includes the final computed value.",
        "api_signature": "eigenvalue_history(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/adapt_vqe.py"
    },
    {
        "api_name": "eigenvalue_history",
        "full_api_name": "AdaptVQEResult.eigenvalue_history",
        "api_description": "Sets the history of computed eigenvalues.",
        "api_signature": "eigenvalue_history(self, eigenvalue_history)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/adapt_vqe.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "VQE.__init__",
        "api_description": "Args:\n    estimator: The estimator primitive to compute the expectation value of the\n        Hamiltonian operator.\n    ansatz: A parameterized quantum circuit to prepare the trial state.\n    optimizer: A classical optimizer to find the minimum energy. This can either be a\n        Qiskit :class:`.Optimizer` or a callable implementing the :class:`.Minimizer`\n        protocol.\n    gradient: An optional estimator gradient to be used with the optimizer.\n    initial_point: An optional initial point (i.e. initial parameter values) for the\n        optimizer. The length of the initial point must match the number of :attr:`ansatz`\n        parameters. If ``None``, a random point will be generated within certain parameter\n        bounds. ``VQE`` will look to the ansatz for these bounds. If the ansatz does not\n        specify bounds, bounds of :math:`-2\\pi`, :math:`2\\pi` will be used.\n    callback: A callback that can access the intermediate data at each optimization step.\n        These data are: the evaluation count, the optimizer parameters for the ansatz, the\n        estimated value, and the metadata dictionary.",
        "api_signature": "__init__(self, estimator, ansatz, optimizer)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/vqe.py"
    },
    {
        "api_name": "initial_point",
        "full_api_name": "VQE.initial_point",
        "api_description": "",
        "api_signature": "initial_point(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/vqe.py"
    },
    {
        "api_name": "initial_point",
        "full_api_name": "VQE.initial_point",
        "api_description": "",
        "api_signature": "initial_point(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/vqe.py"
    },
    {
        "api_name": "compute_minimum_eigenvalue",
        "full_api_name": "VQE.compute_minimum_eigenvalue",
        "api_description": "",
        "api_signature": "compute_minimum_eigenvalue(self, operator, aux_operators)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/vqe.py"
    },
    {
        "api_name": "supports_aux_operators",
        "full_api_name": "VQE.supports_aux_operators",
        "api_description": "",
        "api_signature": "supports_aux_operators(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/vqe.py"
    },
    {
        "api_name": "_get_evaluate_energy",
        "full_api_name": "VQE._get_evaluate_energy",
        "api_description": "Returns a function handle to evaluate the energy at given parameters for the ansatz.\nThis is the objective function to be passed to the optimizer that is used for evaluation.\n\nArgs:\n    ansatz: The ansatz preparing the quantum state.\n    operator: The operator whose energy to evaluate.\n\nReturns:\n    A callable that computes and returns the energy of the hamiltonian of each parameter.\n\nRaises:\n    AlgorithmError: If the primitive job to evaluate the energy fails.",
        "api_signature": "_get_evaluate_energy(self, ansatz, operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/vqe.py"
    },
    {
        "api_name": "evaluate_energy",
        "full_api_name": "VQE.evaluate_energy",
        "api_description": "",
        "api_signature": "evaluate_energy(parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/vqe.py"
    },
    {
        "api_name": "_get_evaluate_gradient",
        "full_api_name": "VQE._get_evaluate_gradient",
        "api_description": "Get a function handle to evaluate the gradient at given parameters for the ansatz.\n\nArgs:\n    ansatz: The ansatz preparing the quantum state.\n    operator: The operator whose energy to evaluate.\n\nReturns:\n    A function handle to evaluate the gradient at given parameters for the ansatz.\n\nRaises:\n    AlgorithmError: If the primitive job to evaluate the gradient fails.",
        "api_signature": "_get_evaluate_gradient(self, ansatz, operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/vqe.py"
    },
    {
        "api_name": "evaluate_gradient",
        "full_api_name": "VQE.evaluate_gradient",
        "api_description": "",
        "api_signature": "evaluate_gradient(parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/vqe.py"
    },
    {
        "api_name": "_check_operator_ansatz",
        "full_api_name": "VQE._check_operator_ansatz",
        "api_description": "Check that the number of qubits of operator and ansatz match and that the ansatz is\nparameterized.",
        "api_signature": "_check_operator_ansatz(self, operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/vqe.py"
    },
    {
        "api_name": "_build_vqe_result",
        "full_api_name": "VQE._build_vqe_result",
        "api_description": "",
        "api_signature": "_build_vqe_result(self, ansatz, optimizer_result, aux_operators_evaluated, optimizer_time)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/vqe.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "VQEResult.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/vqe.py"
    },
    {
        "api_name": "cost_function_evals",
        "full_api_name": "VQEResult.cost_function_evals",
        "api_description": "The number of cost optimizer evaluations.",
        "api_signature": "cost_function_evals(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/vqe.py"
    },
    {
        "api_name": "cost_function_evals",
        "full_api_name": "VQEResult.cost_function_evals",
        "api_description": "",
        "api_signature": "cost_function_evals(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/vqe.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QAOA.__init__",
        "api_description": "Args:\n    sampler: The sampler primitive to sample the circuits.\n    optimizer: A classical optimizer to find the minimum energy. This can either be a\n        Qiskit :class:`.Optimizer` or a callable implementing the :class:`.Minimizer`\n        protocol.\n    reps: The integer parameter :math:`p`. Has a minimum valid value of 1.\n    initial_state: An optional initial state to prepend the QAOA circuit with.\n    mixer: The mixer Hamiltonian to evolve with or a custom quantum circuit. Allows support\n        of optimizations in constrained subspaces [2, 3] as well as warm-starting the\n        optimization [4].\n    initial_point: An optional initial point (i.e. initial parameter values) for the\n        optimizer. The length of the initial point must match the number of :attr:`ansatz`\n        parameters. If ``None``, a random point will be generated within certain parameter\n        bounds. ``QAOA`` will look to the ansatz for these bounds. If the ansatz does not\n        specify bounds, bounds of :math:`-2\\pi`, :math:`2\\pi` will be used.\n    aggregation: A float or callable to specify how the objective function evaluated on the\n        basis states should be aggregated. If a float, this specifies the :math:`\\alpha \\in\n        [0,1]` parameter for a CVaR expectation value.\n    callback: A callback that can access the intermediate data at each optimization step.\n        These data are: the evaluation count, the optimizer parameters for the ansatz, the\n        evaluated value, the metadata dictionary.",
        "api_signature": "__init__(self, sampler, optimizer)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/qaoa.py"
    },
    {
        "api_name": "_check_operator_ansatz",
        "full_api_name": "QAOA._check_operator_ansatz",
        "api_description": "",
        "api_signature": "_check_operator_ansatz(self, operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/qaoa.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SamplingVQE.__init__",
        "api_description": "Args:\n    sampler: The sampler primitive to sample the circuits.\n    ansatz: A parameterized quantum circuit to prepare the trial state.\n    optimizer: A classical optimizer to find the minimum energy. This can either be a Qiskit\n        :class:`.Optimizer` or a callable implementing the :class:`.Minimizer` protocol.\n    initial_point: An optional initial point (i.e. initial parameter values) for the\n        optimizer. The length of the initial point must match the number of :attr:`ansatz`\n        parameters. If ``None``, a random point will be generated within certain parameter\n        bounds. ``SamplingVQE`` will look to the ansatz for these bounds. If the ansatz does\n        not specify bounds, bounds of :math:`-2\\pi`, :math:`2\\pi` will be used.\n    aggregation: A float or callable to specify how the objective function evaluated on the\n        basis states should be aggregated.\n    callback: A callback that can access the intermediate data at each optimization step.\n        These data are: the evaluation count, the optimizer parameters for the ansatz, the\n        estimated value, and the metadata dictionary.",
        "api_signature": "__init__(self, sampler, ansatz, optimizer)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/sampling_vqe.py"
    },
    {
        "api_name": "initial_point",
        "full_api_name": "SamplingVQE.initial_point",
        "api_description": "Return the initial point.",
        "api_signature": "initial_point(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/sampling_vqe.py"
    },
    {
        "api_name": "initial_point",
        "full_api_name": "SamplingVQE.initial_point",
        "api_description": "Set the initial point.",
        "api_signature": "initial_point(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/sampling_vqe.py"
    },
    {
        "api_name": "_check_operator_ansatz",
        "full_api_name": "SamplingVQE._check_operator_ansatz",
        "api_description": "Check that the number of qubits of operator and ansatz match and that the ansatz is\nparameterized.",
        "api_signature": "_check_operator_ansatz(self, operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/sampling_vqe.py"
    },
    {
        "api_name": "supports_aux_operators",
        "full_api_name": "SamplingVQE.supports_aux_operators",
        "api_description": "",
        "api_signature": "supports_aux_operators(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/sampling_vqe.py"
    },
    {
        "api_name": "compute_minimum_eigenvalue",
        "full_api_name": "SamplingVQE.compute_minimum_eigenvalue",
        "api_description": "",
        "api_signature": "compute_minimum_eigenvalue(self, operator, aux_operators)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/sampling_vqe.py"
    },
    {
        "api_name": "_get_evaluate_energy",
        "full_api_name": "SamplingVQE._get_evaluate_energy",
        "api_description": "Returns a function handle to evaluate the energy at given parameters.\n\nThis is the objective function to be passed to the optimizer that is used for evaluation.\n\nArgs:\n    operator: The operator whose energy to evaluate.\n    ansatz: The ansatz preparing the quantum state.\n    return_best_measurement: If True, a handle to a dictionary containing the best\n        measurement evaluated with the cost function.\n\nReturns:\n    A tuple of a callable evaluating the energy and (optionally) a dictionary containing the\n    best measurement of the energy evaluation.\n\nRaises:\n    AlgorithmError: If the circuit is not parameterized (i.e. has 0 free parameters).",
        "api_signature": "_get_evaluate_energy(self, operator, ansatz, return_best_measurement)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/sampling_vqe.py"
    },
    {
        "api_name": "store_best_measurement",
        "full_api_name": "SamplingVQE.store_best_measurement",
        "api_description": "",
        "api_signature": "store_best_measurement(best)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/sampling_vqe.py"
    },
    {
        "api_name": "evaluate_energy",
        "full_api_name": "SamplingVQE.evaluate_energy",
        "api_description": "",
        "api_signature": "evaluate_energy(parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/sampling_vqe.py"
    },
    {
        "api_name": "_build_sampling_vqe_result",
        "full_api_name": "SamplingVQE._build_sampling_vqe_result",
        "api_description": "",
        "api_signature": "_build_sampling_vqe_result(self, ansatz, optimizer_result, aux_operators_evaluated, best_measurement, final_state, optimizer_time)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/sampling_vqe.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SamplingVQEResult.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/sampling_vqe.py"
    },
    {
        "api_name": "cost_function_evals",
        "full_api_name": "SamplingVQEResult.cost_function_evals",
        "api_description": "Returns number of cost optimizer evaluations",
        "api_signature": "cost_function_evals(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/sampling_vqe.py"
    },
    {
        "api_name": "cost_function_evals",
        "full_api_name": "SamplingVQEResult.cost_function_evals",
        "api_description": "Sets number of cost function evaluations",
        "api_signature": "cost_function_evals(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/sampling_vqe.py"
    },
    {
        "api_name": "_compare_measurements",
        "full_api_name": "_compare_measurements",
        "api_description": "Compare two best measurements. Returns True if the candidate is better than current value.\n\nThis compares the following two criteria, in this precedence:\n\n    1. The smaller objective value is better\n    2. The higher probability for the objective value is better",
        "api_signature": "_compare_measurements(candidate, current_best)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/sampling_vqe.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "NumPyMinimumEigensolver.__init__",
        "api_description": "Args:\n    filter_criterion: Callable that allows to filter eigenvalues/eigenstates. The minimum\n        eigensolver is only searching over feasible states and returns an eigenstate that\n        has the smallest eigenvalue among feasible states. The callable has the signature\n        ``filter(eigenstate, eigenvalue, aux_values)`` and must return a boolean to indicate\n        whether to consider this value or not. If there is no feasible element, the result\n        can even be empty.",
        "api_signature": "__init__(self, filter_criterion)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/numpy_minimum_eigensolver.py"
    },
    {
        "api_name": "filter_criterion",
        "full_api_name": "NumPyMinimumEigensolver.filter_criterion",
        "api_description": "Returns the criterion for filtering eigenstates/eigenvalues.",
        "api_signature": "filter_criterion(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/numpy_minimum_eigensolver.py"
    },
    {
        "api_name": "filter_criterion",
        "full_api_name": "NumPyMinimumEigensolver.filter_criterion",
        "api_description": "",
        "api_signature": "filter_criterion(self, filter_criterion)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/numpy_minimum_eigensolver.py"
    },
    {
        "api_name": "supports_aux_operators",
        "full_api_name": "NumPyMinimumEigensolver.supports_aux_operators",
        "api_description": "",
        "api_signature": "supports_aux_operators(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/numpy_minimum_eigensolver.py"
    },
    {
        "api_name": "compute_minimum_eigenvalue",
        "full_api_name": "NumPyMinimumEigensolver.compute_minimum_eigenvalue",
        "api_description": "",
        "api_signature": "compute_minimum_eigenvalue(self, operator, aux_operators)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/numpy_minimum_eigensolver.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "NumPyMinimumEigensolverResult.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/numpy_minimum_eigensolver.py"
    },
    {
        "api_name": "eigenstate",
        "full_api_name": "NumPyMinimumEigensolverResult.eigenstate",
        "api_description": "Returns the eigenstate corresponding to the computed minimum eigenvalue.",
        "api_signature": "eigenstate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/numpy_minimum_eigensolver.py"
    },
    {
        "api_name": "eigenstate",
        "full_api_name": "NumPyMinimumEigensolverResult.eigenstate",
        "api_description": "",
        "api_signature": "eigenstate(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/numpy_minimum_eigensolver.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ComputeUncompute.__init__",
        "api_description": "Args:\n    sampler: Sampler primitive instance.\n    options: Primitive backend runtime options used for circuit execution.\n        The order of priority is: options in ``run`` method > fidelity's\n        default options > primitive's default setting.\n        Higher priority setting overrides lower priority setting.\n    local: If set to ``True``, the fidelity is averaged over\n        single-qubit projectors\n\n        .. math::\n\n            \\hat{O} = \\frac{1}{N}\\sum_{i=1}^N|0_i\\rangle\\langle 0_i|,\n\n        instead of the global projector :math:`|0\\rangle\\langle 0|^{\\otimes n}`.\n        This coincides with the standard (global) fidelity in the limit of\n        the fidelity approaching 1. Might be used to increase the variance\n        to improve trainability in algorithms such as :class:`~.time_evolvers.PVQD`.\n\nRaises:\n    ValueError: If the sampler is not an instance of ``BaseSampler``.",
        "api_signature": "__init__(self, sampler, options, local)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/state_fidelities/compute_uncompute.py"
    },
    {
        "api_name": "create_fidelity_circuit",
        "full_api_name": "ComputeUncompute.create_fidelity_circuit",
        "api_description": "Combines ``circuit_1`` and ``circuit_2`` to create the\nfidelity circuit following the compute-uncompute method.\n\nArgs:\n    circuit_1: (Parametrized) quantum circuit.\n    circuit_2: (Parametrized) quantum circuit.\n\nReturns:\n    The fidelity quantum circuit corresponding to circuit_1 and circuit_2.",
        "api_signature": "create_fidelity_circuit(self, circuit_1, circuit_2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/state_fidelities/compute_uncompute.py"
    },
    {
        "api_name": "_run",
        "full_api_name": "ComputeUncompute._run",
        "api_description": "Computes the state overlap (fidelity) calculation between two\n(parametrized) circuits (first and second) for a specific set of parameter\nvalues (first and second) following the compute-uncompute method.\n\nArgs:\n    circuits_1: (Parametrized) quantum circuits preparing :math:`|\\psi\\rangle`.\n    circuits_2: (Parametrized) quantum circuits preparing :math:`|\\phi\\rangle`.\n    values_1: Numerical parameters to be bound to the first circuits.\n    values_2: Numerical parameters to be bound to the second circuits.\n    options: Primitive backend runtime options used for circuit execution.\n            The order of priority is: options in ``run`` method > fidelity's\n            default options > primitive's default setting.\n            Higher priority setting overrides lower priority setting.\n\nReturns:\n    The result of the fidelity calculation.\n\nRaises:\n    ValueError: At least one pair of circuits must be defined.\n    AlgorithmError: If the sampler job is not completed successfully.",
        "api_signature": "_run(self, circuits_1, circuits_2, values_1, values_2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/state_fidelities/compute_uncompute.py"
    },
    {
        "api_name": "options",
        "full_api_name": "ComputeUncompute.options",
        "api_description": "Return the union of estimator options setting and fidelity default options,\nwhere, if the same field is set in both, the fidelity's default options override\nthe primitive's default setting.\n\nReturns:\n    The fidelity default + estimator options.",
        "api_signature": "options(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/state_fidelities/compute_uncompute.py"
    },
    {
        "api_name": "update_default_options",
        "full_api_name": "ComputeUncompute.update_default_options",
        "api_description": "Update the fidelity's default options setting.\n\nArgs:\n    **options: The fields to update the default options.",
        "api_signature": "update_default_options(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/state_fidelities/compute_uncompute.py"
    },
    {
        "api_name": "_get_local_options",
        "full_api_name": "ComputeUncompute._get_local_options",
        "api_description": "Return the union of the primitive's default setting,\nthe fidelity default options, and the options in the ``run`` method.\nThe order of priority is: options in ``run`` method > fidelity's\n        default options > primitive's default setting.\n\nArgs:\n    options: The fields to update the options\n\nReturns:\n    The fidelity default + estimator + run options.",
        "api_signature": "_get_local_options(self, options)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/state_fidelities/compute_uncompute.py"
    },
    {
        "api_name": "_get_global_fidelity",
        "full_api_name": "ComputeUncompute._get_global_fidelity",
        "api_description": "Process the probability distribution of a measurement to determine the\nglobal fidelity.\n\nArgs:\n    probability_distribution: Obtained from the measurement result\n\nReturns:\n    The global fidelity.",
        "api_signature": "_get_global_fidelity(self, probability_distribution)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/state_fidelities/compute_uncompute.py"
    },
    {
        "api_name": "_get_local_fidelity",
        "full_api_name": "ComputeUncompute._get_local_fidelity",
        "api_description": "Process the probability distribution of a measurement to determine the\nlocal fidelity by averaging over single-qubit projectors.\n\nArgs:\n    probability_distribution: Obtained from the measurement result\n\nReturns:\n    The local fidelity.",
        "api_signature": "_get_local_fidelity(self, probability_distribution, num_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/state_fidelities/compute_uncompute.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BaseStateFidelity.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/state_fidelities/base_state_fidelity.py"
    },
    {
        "api_name": "_preprocess_values",
        "full_api_name": "BaseStateFidelity._preprocess_values",
        "api_description": "Checks whether the passed values match the shape of the parameters\nof the corresponding circuits and formats values to 2D list.\n\nArgs:\n    circuits: List of circuits to be checked.\n    values: Parameter values corresponding to the circuits to be checked.\n\nReturns:\n    A 2D value list if the values match the circuits, or an empty 2D list\n    if values is None.\n\nRaises:\n    ValueError: if the number of parameter values doesn't match the number of\n                circuit parameters\n    TypeError: if the input values are not a sequence.",
        "api_signature": "_preprocess_values(circuits, values)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/state_fidelities/base_state_fidelity.py"
    },
    {
        "api_name": "_check_qubits_match",
        "full_api_name": "BaseStateFidelity._check_qubits_match",
        "api_description": "Checks that the number of qubits of 2 circuits matches.\nArgs:\n    circuit_1: (Parametrized) quantum circuit.\n    circuit_2: (Parametrized) quantum circuit.\n\nRaises:\n    ValueError: when ``circuit_1`` and ``circuit_2`` don't have the\n    same number of qubits.",
        "api_signature": "_check_qubits_match(self, circuit_1, circuit_2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/state_fidelities/base_state_fidelity.py"
    },
    {
        "api_name": "create_fidelity_circuit",
        "full_api_name": "BaseStateFidelity.create_fidelity_circuit",
        "api_description": "Implementation-dependent method to create a fidelity circuit\nfrom 2 circuit inputs.\n\nArgs:\n    circuit_1: (Parametrized) quantum circuit.\n    circuit_2: (Parametrized) quantum circuit.\n\nReturns:\n    The fidelity quantum circuit corresponding to ``circuit_1`` and ``circuit_2``.",
        "api_signature": "create_fidelity_circuit(self, circuit_1, circuit_2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/state_fidelities/base_state_fidelity.py"
    },
    {
        "api_name": "_construct_circuits",
        "full_api_name": "BaseStateFidelity._construct_circuits",
        "api_description": "Constructs the list of fidelity circuits to be evaluated.\nThese circuits represent the state overlap between pairs of input circuits,\nand their construction depends on the fidelity method implementations.\n\nArgs:\n    circuits_1: (Parametrized) quantum circuits.\n    circuits_2: (Parametrized) quantum circuits.\n\nReturns:\n    List of constructed fidelity circuits.\n\nRaises:\n    ValueError: if the length of the input circuit lists doesn't match.",
        "api_signature": "_construct_circuits(self, circuits_1, circuits_2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/state_fidelities/base_state_fidelity.py"
    },
    {
        "api_name": "_construct_value_list",
        "full_api_name": "BaseStateFidelity._construct_value_list",
        "api_description": "Preprocesses input parameter values to match the fidelity\ncircuit parametrization, and return in list format.\n\nArgs:\n   circuits_1: (Parametrized) quantum circuits preparing the\n                first list of quantum states.\n   circuits_2: (Parametrized) quantum circuits preparing the\n                second list of quantum states.\n   values_1: Numerical parameters to be bound to the first circuits.\n   values_2: Numerical parameters to be bound to the second circuits.\n\nReturns:\n     List of parameter values for fidelity circuit.",
        "api_signature": "_construct_value_list(self, circuits_1, circuits_2, values_1, values_2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/state_fidelities/base_state_fidelity.py"
    },
    {
        "api_name": "_run",
        "full_api_name": "BaseStateFidelity._run",
        "api_description": "Computes the state overlap (fidelity) calculation between two\n(parametrized) circuits (first and second) for a specific set of parameter\nvalues (first and second).\n\nArgs:\n    circuits_1: (Parametrized) quantum circuits preparing :math:`|\\psi\\rangle`.\n    circuits_2: (Parametrized) quantum circuits preparing :math:`|\\phi\\rangle`.\n    values_1: Numerical parameters to be bound to the first set of circuits\n    values_2: Numerical parameters to be bound to the second set of circuits.\n    options: Primitive backend runtime options used for circuit execution. The order\n        of priority is\\: options in ``run`` method > fidelity's default\n        options > primitive's default setting.\n        Higher priority setting overrides lower priority setting.\n\nReturns:\n    The result of the fidelity calculation.",
        "api_signature": "_run(self, circuits_1, circuits_2, values_1, values_2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/state_fidelities/base_state_fidelity.py"
    },
    {
        "api_name": "run",
        "full_api_name": "BaseStateFidelity.run",
        "api_description": "Runs asynchronously the state overlap (fidelity) calculation between two\n(parametrized) circuits (first and second) for a specific set of parameter\nvalues (first and second). This calculation depends on the particular\nfidelity method implementation.\n\nArgs:\n    circuits_1: (Parametrized) quantum circuits preparing :math:`|\\psi\\rangle`.\n    circuits_2: (Parametrized) quantum circuits preparing :math:`|\\phi\\rangle`.\n    values_1: Numerical parameters to be bound to the first set of circuits.\n    values_2: Numerical parameters to be bound to the second set of circuits.\n    options: Primitive backend runtime options used for circuit execution. The order\n        of priority is\\: options in ``run`` method > fidelity's default\n        options > primitive's default setting.\n        Higher priority setting overrides lower priority setting.\n\nReturns:\n    Primitive job for the fidelity calculation.\n    The job's result is an instance of ``StateFidelityResult``.",
        "api_signature": "run(self, circuits_1, circuits_2, values_1, values_2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/state_fidelities/base_state_fidelity.py"
    },
    {
        "api_name": "_truncate_fidelities",
        "full_api_name": "BaseStateFidelity._truncate_fidelities",
        "api_description": "Ensures fidelity result in [0,1].\n\nArgs:\n   fidelities: Sequence of raw fidelity results.\n\nReturns:\n     List of truncated fidelities.",
        "api_signature": "_truncate_fidelities(self, fidelities)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/state_fidelities/base_state_fidelity.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "UMDA.__init__",
        "api_description": "Args:\n    maxiter: Maximum number of iterations.\n    size_gen: Population size of each generation.\n    alpha: Percentage (0, 1] of the population to be selected as elite selection.\n    callback: A callback function passed information in each iteration step. The\n        information is, in this order: the number of function evaluations, the parameters,\n        the best function value in this iteration.",
        "api_signature": "__init__(self, maxiter, size_gen, alpha, callback)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/umda.py"
    },
    {
        "api_name": "_initialization",
        "full_api_name": "UMDA._initialization",
        "api_description": "",
        "api_signature": "_initialization(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/umda.py"
    },
    {
        "api_name": "_new_generation",
        "full_api_name": "UMDA._new_generation",
        "api_description": "Build a new generation sampled from the vector of probabilities.\nUpdates the generation pandas dataframe",
        "api_signature": "_new_generation(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/umda.py"
    },
    {
        "api_name": "_truncation",
        "full_api_name": "UMDA._truncation",
        "api_description": "Selection of the best individuals of the actual generation.\nUpdates the generation by selecting the best individuals.",
        "api_signature": "_truncation(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/umda.py"
    },
    {
        "api_name": "_check_generation",
        "full_api_name": "UMDA._check_generation",
        "api_description": "Check the cost of each individual in the cost function implemented by the user.",
        "api_signature": "_check_generation(self, objective_function)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/umda.py"
    },
    {
        "api_name": "_update_vector",
        "full_api_name": "UMDA._update_vector",
        "api_description": "From the best individuals update the vector of normal distributions in order to the next\ngeneration can sample from it. Update the vector of normal distributions",
        "api_signature": "_update_vector(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/umda.py"
    },
    {
        "api_name": "minimize",
        "full_api_name": "UMDA.minimize",
        "api_description": "",
        "api_signature": "minimize(self, fun, x0, jac, bounds)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/umda.py"
    },
    {
        "api_name": "size_gen",
        "full_api_name": "UMDA.size_gen",
        "api_description": "Returns the size of the generations (number of individuals per generation)",
        "api_signature": "size_gen(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/umda.py"
    },
    {
        "api_name": "size_gen",
        "full_api_name": "UMDA.size_gen",
        "api_description": "Sets the size of the generations of the algorithm.\n\nArgs:\n    value: Size of the generations (number of individuals per generation).\n\nRaises:\n    ValueError: If `value` is lower than 1.",
        "api_signature": "size_gen(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/umda.py"
    },
    {
        "api_name": "maxiter",
        "full_api_name": "UMDA.maxiter",
        "api_description": "Returns the maximum number of iterations",
        "api_signature": "maxiter(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/umda.py"
    },
    {
        "api_name": "maxiter",
        "full_api_name": "UMDA.maxiter",
        "api_description": "Sets the maximum number of iterations of the algorithm.\n\nArgs:\n    value: Maximum number of iterations of the algorithm.\n\nRaises:\n    ValueError: If `value` is lower than 1.",
        "api_signature": "maxiter(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/umda.py"
    },
    {
        "api_name": "alpha",
        "full_api_name": "UMDA.alpha",
        "api_description": "Returns the alpha parameter value (percentage of population selected to update\nprobabilistic model)",
        "api_signature": "alpha(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/umda.py"
    },
    {
        "api_name": "alpha",
        "full_api_name": "UMDA.alpha",
        "api_description": "Sets the alpha parameter (percentage of individuals selected to update the probabilistic\nmodel)\n\nArgs:\n    value: Percentage (0,1] of generation selected to update the probabilistic model.\n\nRaises:\n    ValueError: If `value` is lower than 0 or greater than 1.",
        "api_signature": "alpha(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/umda.py"
    },
    {
        "api_name": "settings",
        "full_api_name": "UMDA.settings",
        "api_description": "",
        "api_signature": "settings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/umda.py"
    },
    {
        "api_name": "get_support_level",
        "full_api_name": "UMDA.get_support_level",
        "api_description": "Get the support level dictionary.",
        "api_signature": "get_support_level(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/umda.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ADAM.__init__",
        "api_description": "Args:\n    maxiter: Maximum number of iterations\n    tol: Tolerance for termination\n    lr: Value >= 0, Learning rate.\n    beta_1: Value in range 0 to 1, Generally close to 1.\n    beta_2: Value in range 0 to 1, Generally close to 1.\n    noise_factor: Value >= 0, Noise factor\n    eps : Value >=0, Epsilon to be used for finite differences if no analytic\n        gradient method is given.\n    amsgrad: True to use AMSGRAD, False if not\n    snapshot_dir: If not None save the optimizer's parameter\n        after every step to the given directory",
        "api_signature": "__init__(self, maxiter, tol, lr, beta_1, beta_2, noise_factor, eps, amsgrad, snapshot_dir)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/adam_amsgrad.py"
    },
    {
        "api_name": "settings",
        "full_api_name": "ADAM.settings",
        "api_description": "",
        "api_signature": "settings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/adam_amsgrad.py"
    },
    {
        "api_name": "get_support_level",
        "full_api_name": "ADAM.get_support_level",
        "api_description": "Return support level dictionary",
        "api_signature": "get_support_level(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/adam_amsgrad.py"
    },
    {
        "api_name": "save_params",
        "full_api_name": "ADAM.save_params",
        "api_description": "Save the current iteration parameters to a file called ``adam_params.csv``.\n\nNote:\n\n    The current parameters are appended to the file, if it exists already.\n    The file is not overwritten.\n\nArgs:\n    snapshot_dir: The directory to store the file in.",
        "api_signature": "save_params(self, snapshot_dir)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/adam_amsgrad.py"
    },
    {
        "api_name": "load_params",
        "full_api_name": "ADAM.load_params",
        "api_description": "Load iteration parameters for a file called ``adam_params.csv``.\n\nArgs:\n    load_dir: The directory containing ``adam_params.csv``.",
        "api_signature": "load_params(self, load_dir)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/adam_amsgrad.py"
    },
    {
        "api_name": "minimize",
        "full_api_name": "ADAM.minimize",
        "api_description": "Minimize the scalar function.\n\nArgs:\n    fun: The scalar function to minimize.\n    x0: The initial point for the minimization.\n    jac: The gradient of the scalar function ``fun``.\n    bounds: Bounds for the variables of ``fun``. This argument might be ignored if the\n        optimizer does not support bounds.\n    objective_function: DEPRECATED. A function handle to the objective function.\n    initial_point: DEPRECATED. The initial iteration point.\n    gradient_function: DEPRECATED. A function handle to the gradient of the objective\n        function.\n\nReturns:\n    The result of the optimization, containing e.g. the result as attribute ``x``.",
        "api_signature": "minimize(self, fun, x0, jac, bounds, objective_function, initial_point, gradient_function)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/adam_amsgrad.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "AQGD.__init__",
        "api_description": "Performs Analytical Quantum Gradient Descent (AQGD) with Epochs.\n\nArgs:\n    maxiter: Maximum number of iterations (full gradient steps)\n    eta: The coefficient of the gradient update. Increasing this value\n        results in larger step sizes: param = previous_param - eta * deriv\n    tol: Tolerance for change in windowed average of objective values.\n        Convergence occurs when either objective tolerance is met OR parameter\n        tolerance is met.\n    momentum: Bias towards the previous gradient momentum in current\n        update. Must be within the bounds: [0,1)\n    param_tol: Tolerance for change in norm of parameters.\n    averaging: Length of window over which to average objective values for objective\n        convergence criterion\n\nRaises:\n    AlgorithmError: If the length of ``maxiter``, `momentum``, and ``eta`` is not the same.",
        "api_signature": "__init__(self, maxiter, eta, tol, momentum, param_tol, averaging)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/aqgd.py"
    },
    {
        "api_name": "get_support_level",
        "full_api_name": "AQGD.get_support_level",
        "api_description": "Support level dictionary\n\nReturns:\n    Dict[str, int]: gradient, bounds and initial point\n                    support information that is ignored/required.",
        "api_signature": "get_support_level(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/aqgd.py"
    },
    {
        "api_name": "settings",
        "full_api_name": "AQGD.settings",
        "api_description": "",
        "api_signature": "settings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/aqgd.py"
    },
    {
        "api_name": "_compute_objective_fn_and_gradient",
        "full_api_name": "AQGD._compute_objective_fn_and_gradient",
        "api_description": "Obtains the objective function value for params and the analytical quantum derivatives of\nthe objective function with respect to each parameter. Requires\n2*(number parameters) + 1 objective evaluations\n\nArgs:\n    params: Current value of the parameters to evaluate the objective function\n    obj: Objective function of interest\n\nReturns:\n    Tuple containing the objective value and array of gradients for the given parameter set.",
        "api_signature": "_compute_objective_fn_and_gradient(self, params, obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/aqgd.py"
    },
    {
        "api_name": "_update",
        "full_api_name": "AQGD._update",
        "api_description": "Updates full parameter array based on a step that is a convex\ncombination of the gradient and previous momentum\n\nArgs:\n    params: Current value of the parameters to evaluate the objective function at\n    gradient: Gradient of objective wrt parameters\n    mprev: Momentum vector for each parameter\n    step_size: The scaling of step to take\n    momentum_coeff: Bias towards previous momentum vector when updating current\n        momentum/step vector\n\nReturns:\n    Tuple of the updated parameter and momentum vectors respectively.",
        "api_signature": "_update(self, params, gradient, mprev, step_size, momentum_coeff)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/aqgd.py"
    },
    {
        "api_name": "_converged_objective",
        "full_api_name": "AQGD._converged_objective",
        "api_description": "Tests convergence based on the change in a moving windowed average of past objective values\n\nArgs:\n    objval: Current value of the objective function\n    tol: tolerance below which (average) objective function change must be\n    window_size: size of averaging window\n\nReturns:\n    Bool indicating whether or not the optimization has converged.",
        "api_signature": "_converged_objective(self, objval, tol, window_size)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/aqgd.py"
    },
    {
        "api_name": "_converged_parameter",
        "full_api_name": "AQGD._converged_parameter",
        "api_description": "Tests convergence based on change in parameter\n\nArgs:\n    parameter: current parameter values\n    tol: tolerance for change in norm of parameters\n\nReturns:\n    Bool indicating whether or not the optimization has converged",
        "api_signature": "_converged_parameter(self, parameter, tol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/aqgd.py"
    },
    {
        "api_name": "_converged_alt",
        "full_api_name": "AQGD._converged_alt",
        "api_description": "Tests convergence from norm of windowed average of gradients\n\nArgs:\n    gradient: current gradient\n    tol: tolerance for average gradient norm\n    window_size: size of averaging window\n\nReturns:\n    Bool indicating whether or not the optimization has converged",
        "api_signature": "_converged_alt(self, gradient, tol, window_size)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/aqgd.py"
    },
    {
        "api_name": "minimize",
        "full_api_name": "AQGD.minimize",
        "api_description": "",
        "api_signature": "minimize(self, fun, x0, jac, bounds)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/aqgd.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BOBYQA.__init__",
        "api_description": "Args:\n    maxiter: Maximum number of function evaluations.\n\nRaises:\n    MissingOptionalLibraryError: scikit-quant not installed",
        "api_signature": "__init__(self, maxiter)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/bobyqa.py"
    },
    {
        "api_name": "get_support_level",
        "full_api_name": "BOBYQA.get_support_level",
        "api_description": "Returns support level dictionary.",
        "api_signature": "get_support_level(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/bobyqa.py"
    },
    {
        "api_name": "settings",
        "full_api_name": "BOBYQA.settings",
        "api_description": "",
        "api_signature": "settings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/bobyqa.py"
    },
    {
        "api_name": "minimize",
        "full_api_name": "BOBYQA.minimize",
        "api_description": "",
        "api_signature": "minimize(self, fun, x0, jac, bounds)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/bobyqa.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QNSPSA.__init__",
        "api_description": "Args:\n    fidelity: A function to compute the fidelity of the ansatz state with itself for\n        two different sets of parameters.\n    maxiter: The maximum number of iterations. Note that this is not the maximal number\n        of function evaluations.\n    blocking: If True, only accepts updates that improve the loss (up to some allowed\n        increase, see next argument).\n    allowed_increase: If ``blocking`` is ``True``, this argument determines by how much\n        the loss can increase with the proposed parameters and still be accepted.\n        If ``None``, the allowed increases is calibrated automatically to be twice the\n        approximated standard deviation of the loss function.\n    learning_rate: The update step is the learning rate is multiplied with the gradient.\n        If the learning rate is a float, it remains constant over the course of the\n        optimization. It can also be a callable returning an iterator which yields the\n        learning rates for each optimization step.\n        If ``learning_rate`` is set ``perturbation`` must also be provided.\n    perturbation: Specifies the magnitude of the perturbation for the finite difference\n        approximation of the gradients. Can be either a float or a generator yielding\n        the perturbation magnitudes per step.\n        If ``perturbation`` is set ``learning_rate`` must also be provided.\n    resamplings: The number of times the gradient (and Hessian) is sampled using a random\n        direction to construct a gradient estimate. Per default the gradient is estimated\n        using only one random direction. If an integer, all iterations use the same number\n        of resamplings. If a dictionary, this is interpreted as\n        ``{iteration: number of resamplings per iteration}``.\n    perturbation_dims: The number of perturbed dimensions. Per default, all dimensions\n        are perturbed, but a smaller, fixed number can be perturbed. If set, the perturbed\n        dimensions are chosen uniformly at random.\n    regularization: To ensure the preconditioner is symmetric and positive definite, the\n        identity times a small coefficient is added to it. This generator yields that\n        coefficient.\n    hessian_delay: Start multiplying the gradient with the inverse Hessian only after a\n        certain number of iterations. The Hessian is still evaluated and therefore this\n        argument can be useful to first get a stable average over the last iterations before\n        using it as preconditioner.\n    lse_solver: The method to solve for the inverse of the Hessian. Per default an\n        exact LSE solver is used, but can e.g. be overwritten by a minimization routine.\n    initial_hessian: The initial guess for the Hessian. By default the identity matrix\n        is used.\n    callback: A callback function passed information in each iteration step. The\n        information is, in this order: the parameters, the function value, the number\n        of function evaluations, the stepsize, whether the step was accepted.\n    termination_checker: A callback function executed at the end of each iteration step. The\n        arguments are, in this order: the parameters, the function value, the number\n        of function evaluations, the stepsize, whether the step was accepted. If the callback\n        returns True, the optimization is terminated.\n        To prevent additional evaluations of the objective method, if the objective has not yet\n        been evaluated, the objective is estimated by taking the mean of the objective\n        evaluations used in the estimate of the gradient.",
        "api_signature": "__init__(self, fidelity, maxiter, blocking, allowed_increase, learning_rate, perturbation, resamplings, perturbation_dims, regularization, hessian_delay, lse_solver, initial_hessian, callback, termination_checker)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/qnspsa.py"
    },
    {
        "api_name": "_point_sample",
        "full_api_name": "QNSPSA._point_sample",
        "api_description": "",
        "api_signature": "_point_sample(self, loss, x, eps, delta1, delta2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/qnspsa.py"
    },
    {
        "api_name": "settings",
        "full_api_name": "QNSPSA.settings",
        "api_description": "The optimizer settings in a dictionary format.",
        "api_signature": "settings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/qnspsa.py"
    },
    {
        "api_name": "get_fidelity",
        "full_api_name": "QNSPSA.get_fidelity",
        "api_description": "Get a function to compute the fidelity of ``circuit`` with itself.\n\n.. note::\n\n    Using this function with a backend and expectation converter is pending deprecation,\n    instead pass a Qiskit Primitive sampler, such as :class:`~.Sampler`.\n    The sampler can be passed as keyword argument or, positionally, as second argument.\n\nLet ``circuit`` be a parameterized quantum circuit performing the operation\n:math:`U(\\theta)` given a set of parameters :math:`\\theta`. Then this method returns\na function to evaluate\n\n.. math::\n\n    F(\\theta, \\phi) = \\big|\\langle 0 | U^\\dagger(\\theta) U(\\phi) |0\\rangle  \\big|^2.\n\nThe output of this function can be used as input for the ``fidelity`` to the\n:class:`~.QNSPSA` optimizer.\n\nArgs:\n    circuit: The circuit preparing the parameterized ansatz.\n    backend: Deprecated. A backend of quantum instance to evaluate the circuits.\n        If None, plain matrix multiplication will be used.\n    expectation: Deprecated. An expectation converter to specify how the expected\n        value is computed. If a shot-based readout is used this should be set to\n        ``PauliExpectation``.\n    sampler: A sampler primitive to sample from a quantum state.\n\nReturns:\n    A handle to the function :math:`F`.",
        "api_signature": "get_fidelity(circuit, backend, expectation)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/qnspsa.py"
    },
    {
        "api_name": "fidelity",
        "full_api_name": "QNSPSA.fidelity",
        "api_description": "",
        "api_signature": "fidelity(values_x, values_y)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/qnspsa.py"
    },
    {
        "api_name": "_legacy_get_fidelity",
        "full_api_name": "QNSPSA._legacy_get_fidelity",
        "api_description": "Deprecated. Get a function to compute the fidelity of ``circuit`` with itself.\n\n.. note::\n\n    This method is deprecated. Instead use the :class:`~.ComputeUncompute`\n    class which implements the fidelity calculation in the same fashion as this method.\n\nLet ``circuit`` be a parameterized quantum circuit performing the operation\n:math:`U(\\theta)` given a set of parameters :math:`\\theta`. Then this method returns\na function to evaluate\n\n.. math::\n\n    F(\\theta, \\phi) = \\big|\\langle 0 | U^\\dagger(\\theta) U(\\phi) |0\\rangle  \\big|^2.\n\nThe output of this function can be used as input for the ``fidelity`` to the\n:class:~`qiskit.algorithms.optimizers.QNSPSA` optimizer.\n\nArgs:\n    circuit: The circuit preparing the parameterized ansatz.\n    backend: A backend of quantum instance to evaluate the circuits. If None, plain\n        matrix multiplication will be used.\n    expectation: An expectation converter to specify how the expected value is computed.\n        If a shot-based readout is used this should be set to ``PauliExpectation``.\n\nReturns:\n    A handle to the function :math:`F`.",
        "api_signature": "_legacy_get_fidelity(circuit, backend, expectation)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/qnspsa.py"
    },
    {
        "api_name": "fidelity",
        "full_api_name": "QNSPSA.fidelity",
        "api_description": "",
        "api_signature": "fidelity(values_x, values_y)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/qnspsa.py"
    },
    {
        "api_name": "fidelity",
        "full_api_name": "QNSPSA.fidelity",
        "api_description": "",
        "api_signature": "fidelity(values_x, values_y)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/qnspsa.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SteppableOptimizer.__init__",
        "api_description": "Args:\n    maxiter: Number of steps in the optimization process before ending the loop.",
        "api_signature": "__init__(self, maxiter)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/steppable_optimizer.py"
    },
    {
        "api_name": "state",
        "full_api_name": "SteppableOptimizer.state",
        "api_description": "Return the current state of the optimizer.",
        "api_signature": "state(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/steppable_optimizer.py"
    },
    {
        "api_name": "state",
        "full_api_name": "SteppableOptimizer.state",
        "api_description": "Set the current state of the optimizer.",
        "api_signature": "state(self, state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/steppable_optimizer.py"
    },
    {
        "api_name": "ask",
        "full_api_name": "SteppableOptimizer.ask",
        "api_description": "Ask the optimizer for a set of points to evaluate.\n\nThis method asks the optimizer which are the next points to evaluate.\nThese points can, e.g., correspond to function values and/or its derivative.\nIt may also correspond to variables that let the user infer which points to evaluate.\nIt is the first method inside of a :meth:`~.step` in the optimization process.\n\nReturns:\n    An object containing the data needed to make the function evaluation to advance the\n    optimization process.",
        "api_signature": "ask(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/steppable_optimizer.py"
    },
    {
        "api_name": "tell",
        "full_api_name": "SteppableOptimizer.tell",
        "api_description": "Updates the optimization state using the results of the function evaluation.\n\nA canonical optimization example using :meth:`~.ask` and :meth:`~.tell` can be seen\nin :meth:`~.step`.\n\nArgs:\n    ask_data: Contains the information on how the evaluation was done.\n    tell_data: Contains all relevant information about the evaluation of the objective\n        function.",
        "api_signature": "tell(self, ask_data, tell_data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/steppable_optimizer.py"
    },
    {
        "api_name": "evaluate",
        "full_api_name": "SteppableOptimizer.evaluate",
        "api_description": "Evaluates the function according to the instructions contained in :attr:`~.ask_data`.\n\nIf the user decides to use :meth:`~.step` instead of :meth:`~.ask` and :meth:`~.tell`\nthis function will contain the logic on how to evaluate the function.\n\nArgs:\n    ask_data: Contains the information on how to do the evaluation.\n\nReturns:\n    Data of all relevant information about the function evaluation.",
        "api_signature": "evaluate(self, ask_data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/steppable_optimizer.py"
    },
    {
        "api_name": "_callback_wrapper",
        "full_api_name": "SteppableOptimizer._callback_wrapper",
        "api_description": "Wraps the callback function to accommodate each optimizer.",
        "api_signature": "_callback_wrapper(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/steppable_optimizer.py"
    },
    {
        "api_name": "step",
        "full_api_name": "SteppableOptimizer.step",
        "api_description": "Performs one step in the optimization process.\n\nThis method composes :meth:`~.ask`, :meth:`~.evaluate`, and :meth:`~.tell` to make a \"step\"\nin the optimization process.",
        "api_signature": "step(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/steppable_optimizer.py"
    },
    {
        "api_name": "start",
        "full_api_name": "SteppableOptimizer.start",
        "api_description": "Populates the state of the optimizer with the data provided and sets all the counters to 0.\n\nArgs:\n    fun: Function to minimize.\n    x0: Initial point.\n    jac: Function to compute the gradient.\n    bounds: Bounds of the search space.",
        "api_signature": "start(self, fun, x0, jac, bounds)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/steppable_optimizer.py"
    },
    {
        "api_name": "minimize",
        "full_api_name": "SteppableOptimizer.minimize",
        "api_description": "Minimizes the function.\n\nFor well behaved functions the user can call this method to minimize a function.\nIf the user wants more control on how to evaluate the function a custom loop can be\ncreated using :meth:`~.ask` and :meth:`~.tell` and evaluating the function manually.\n\nArgs:\n    fun: Function to minimize.\n    x0: Initial point.\n    jac: Function to compute the gradient.\n    bounds: Bounds of the search space.\n\nReturns:\n    Object containing the result of the optimization.",
        "api_signature": "minimize(self, fun, x0, jac, bounds)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/steppable_optimizer.py"
    },
    {
        "api_name": "create_result",
        "full_api_name": "SteppableOptimizer.create_result",
        "api_description": "Returns the result of the optimization.\n\nAll the information needed to create such a result should be stored in the optimizer state\nand will typically contain the best point found, the function value and gradient at that point,\nthe number of function and gradient evaluation and the number of iterations in the optimization.\n\nReturns:\n    The result of the optimization process.",
        "api_signature": "create_result(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/steppable_optimizer.py"
    },
    {
        "api_name": "continue_condition",
        "full_api_name": "SteppableOptimizer.continue_condition",
        "api_description": "Condition that indicates the optimization process should continue.\n\nReturns:\n    ``True`` if the optimization process should continue, ``False`` otherwise.",
        "api_signature": "continue_condition(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/steppable_optimizer.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SciPyOptimizer.__init__",
        "api_description": "Args:\n    method: Type of solver.\n    options: A dictionary of solver options.\n    kwargs: additional kwargs for scipy.optimize.minimize.\n    max_evals_grouped: Max number of default gradient evaluations performed simultaneously.",
        "api_signature": "__init__(self, method, options, max_evals_grouped)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/scipy_optimizer.py"
    },
    {
        "api_name": "get_support_level",
        "full_api_name": "SciPyOptimizer.get_support_level",
        "api_description": "Return support level dictionary",
        "api_signature": "get_support_level(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/scipy_optimizer.py"
    },
    {
        "api_name": "settings",
        "full_api_name": "SciPyOptimizer.settings",
        "api_description": "",
        "api_signature": "settings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/scipy_optimizer.py"
    },
    {
        "api_name": "minimize",
        "full_api_name": "SciPyOptimizer.minimize",
        "api_description": "",
        "api_signature": "minimize(self, fun, x0, jac, bounds)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/scipy_optimizer.py"
    },
    {
        "api_name": "_wrap_gradient",
        "full_api_name": "SciPyOptimizer._wrap_gradient",
        "api_description": "",
        "api_signature": "_wrap_gradient(gradient_function)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/scipy_optimizer.py"
    },
    {
        "api_name": "wrapped_gradient",
        "full_api_name": "SciPyOptimizer.wrapped_gradient",
        "api_description": "",
        "api_signature": "wrapped_gradient(x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/scipy_optimizer.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SPSA.__init__",
        "api_description": "Args:\n    maxiter: The maximum number of iterations. Note that this is not the maximal number\n        of function evaluations.\n    blocking: If True, only accepts updates that improve the loss (up to some allowed\n        increase, see next argument).\n    allowed_increase: If ``blocking`` is ``True``, this argument determines by how much\n        the loss can increase with the proposed parameters and still be accepted.\n        If ``None``, the allowed increases is calibrated automatically to be twice the\n        approximated standard deviation of the loss function.\n    trust_region: If ``True``, restricts the norm of the update step to be :math:`\\leq 1`.\n    learning_rate: The update step is the learning rate is multiplied with the gradient.\n        If the learning rate is a float, it remains constant over the course of the\n        optimization. If a NumPy array, the :math:`i`-th element is the learning rate for\n        the :math:`i`-th iteration. It can also be a callable returning an iterator which\n        yields the learning rates for each optimization step.\n        If ``learning_rate`` is set ``perturbation`` must also be provided.\n    perturbation: Specifies the magnitude of the perturbation for the finite difference\n        approximation of the gradients. See ``learning_rate`` for the supported types.\n        If ``perturbation`` is set ``learning_rate`` must also be provided.\n    last_avg: Return the average of the ``last_avg`` parameters instead of just the\n        last parameter values.\n    resamplings: The number of times the gradient (and Hessian) is sampled using a random\n        direction to construct a gradient estimate. Per default the gradient is estimated\n        using only one random direction. If an integer, all iterations use the same number\n        of resamplings. If a dictionary, this is interpreted as\n        ``{iteration: number of resamplings per iteration}``.\n    perturbation_dims: The number of perturbed dimensions. Per default, all dimensions\n        are perturbed, but a smaller, fixed number can be perturbed. If set, the perturbed\n        dimensions are chosen uniformly at random.\n    second_order: If True, use 2-SPSA instead of SPSA. In 2-SPSA, the Hessian is estimated\n        additionally to the gradient, and the gradient is preconditioned with the inverse\n        of the Hessian to improve convergence.\n    regularization: To ensure the preconditioner is symmetric and positive definite, the\n        identity times a small coefficient is added to it. This generator yields that\n        coefficient.\n    hessian_delay: Start multiplying the gradient with the inverse Hessian only after a\n        certain number of iterations. The Hessian is still evaluated and therefore this\n        argument can be useful to first get a stable average over the last iterations before\n        using it as preconditioner.\n    lse_solver: The method to solve for the inverse of the Hessian. Per default an\n        exact LSE solver is used, but can e.g. be overwritten by a minimization routine.\n    initial_hessian: The initial guess for the Hessian. By default the identity matrix\n        is used.\n    callback: A callback function passed information in each iteration step. The\n        information is, in this order: the number of function evaluations, the parameters,\n        the function value, the stepsize, whether the step was accepted.\n    termination_checker: A callback function executed at the end of each iteration step. The\n        arguments are, in this order: the parameters, the function value, the number\n        of function evaluations, the stepsize, whether the step was accepted. If the callback\n        returns True, the optimization is terminated.\n        To prevent additional evaluations of the objective method, if the objective has not yet\n        been evaluated, the objective is estimated by taking the mean of the objective\n        evaluations used in the estimate of the gradient.\n\n\nRaises:\n    ValueError: If ``learning_rate`` or ``perturbation`` is an array with less elements\n        than the number of iterations.",
        "api_signature": "__init__(self, maxiter, blocking, allowed_increase, trust_region, learning_rate, perturbation, last_avg, resamplings, perturbation_dims, second_order, regularization, hessian_delay, lse_solver, initial_hessian, callback, termination_checker)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/spsa.py"
    },
    {
        "api_name": "calibrate",
        "full_api_name": "SPSA.calibrate",
        "api_description": "Calibrate SPSA parameters with a powerseries as learning rate and perturbation coeffs.\n\nThe powerseries are:\n\n.. math::\n\n    a_k = \\frac{a}{(A + k + 1)^\\alpha}, c_k = \\frac{c}{(k + 1)^\\gamma}\n\nArgs:\n    loss: The loss function.\n    initial_point: The initial guess of the iteration.\n    c: The initial perturbation magnitude.\n    stability_constant: The value of `A`.\n    target_magnitude: The target magnitude for the first update step, defaults to\n        :math:`2\\pi / 10`.\n    alpha: The exponent of the learning rate powerseries.\n    gamma: The exponent of the perturbation powerseries.\n    modelspace: Whether the target magnitude is the difference of parameter values\n        or function values (= model space).\n    max_evals_grouped: The number of grouped evaluations supported by the loss function.\n        Defaults to 1, i.e. no grouping.\n\nReturns:\n    tuple(generator, generator): A tuple of powerseries generators, the first one for the\n        learning rate and the second one for the perturbation.",
        "api_signature": "calibrate(loss, initial_point, c, stability_constant, target_magnitude, alpha, gamma, modelspace, max_evals_grouped)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/spsa.py"
    },
    {
        "api_name": "learning_rate",
        "full_api_name": "SPSA.learning_rate",
        "api_description": "",
        "api_signature": "learning_rate()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/spsa.py"
    },
    {
        "api_name": "perturbation",
        "full_api_name": "SPSA.perturbation",
        "api_description": "",
        "api_signature": "perturbation()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/spsa.py"
    },
    {
        "api_name": "estimate_stddev",
        "full_api_name": "SPSA.estimate_stddev",
        "api_description": "Estimate the standard deviation of the loss function.",
        "api_signature": "estimate_stddev(loss, initial_point, avg, max_evals_grouped)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/spsa.py"
    },
    {
        "api_name": "settings",
        "full_api_name": "SPSA.settings",
        "api_description": "",
        "api_signature": "settings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/spsa.py"
    },
    {
        "api_name": "_point_sample",
        "full_api_name": "SPSA._point_sample",
        "api_description": "A single sample of the gradient at position ``x`` in direction ``delta``.",
        "api_signature": "_point_sample(self, loss, x, eps, delta1, delta2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/spsa.py"
    },
    {
        "api_name": "_point_estimate",
        "full_api_name": "SPSA._point_estimate",
        "api_description": "The gradient estimate at point x.",
        "api_signature": "_point_estimate(self, loss, x, eps, num_samples)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/spsa.py"
    },
    {
        "api_name": "_compute_update",
        "full_api_name": "SPSA._compute_update",
        "api_description": "",
        "api_signature": "_compute_update(self, loss, x, k, eps, lse_solver)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/spsa.py"
    },
    {
        "api_name": "minimize",
        "full_api_name": "SPSA.minimize",
        "api_description": "",
        "api_signature": "minimize(self, fun, x0, jac, bounds)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/spsa.py"
    },
    {
        "api_name": "get_support_level",
        "full_api_name": "SPSA.get_support_level",
        "api_description": "Get the support level dictionary.",
        "api_signature": "get_support_level(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/spsa.py"
    },
    {
        "api_name": "optimize",
        "full_api_name": "SPSA.optimize",
        "api_description": "Perform optimization.\n\nArgs:\n    num_vars (int): Number of parameters to be optimized.\n    objective_function (callable): A function that computes the objective function.\n    gradient_function (callable): Not supported for SPSA.\n    variable_bounds (list[(float, float)]): Not supported for SPSA.\n    initial_point (numpy.ndarray[float]): Initial point.\n\nReturns:\n    tuple: point, value, nfev\n       point: is a 1D numpy.ndarray[float] containing the solution\n       value: is a float with the objective function value\n       nfev: number of objective function calls made if available or None",
        "api_signature": "optimize(self, num_vars, objective_function, gradient_function, variable_bounds, initial_point)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/spsa.py"
    },
    {
        "api_name": "bernoulli_perturbation",
        "full_api_name": "bernoulli_perturbation",
        "api_description": "Get a Bernoulli random perturbation.",
        "api_signature": "bernoulli_perturbation(dim, perturbation_dims)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/spsa.py"
    },
    {
        "api_name": "powerseries",
        "full_api_name": "powerseries",
        "api_description": "Yield a series decreasing by a powerlaw.",
        "api_signature": "powerseries(eta, power, offset)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/spsa.py"
    },
    {
        "api_name": "constant",
        "full_api_name": "constant",
        "api_description": "Yield a constant series.",
        "api_signature": "constant(eta)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/spsa.py"
    },
    {
        "api_name": "_batch_evaluate",
        "full_api_name": "_batch_evaluate",
        "api_description": "Evaluate a function on all points with batches of max_evals_grouped.\n\nThe points are a list of inputs, as ``[in1, in2, in3, ...]``. If the individual\ninputs are tuples (because the function takes multiple inputs), set ``unpack_points`` to ``True``.",
        "api_signature": "_batch_evaluate(function, points, max_evals_grouped, unpack_points)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/spsa.py"
    },
    {
        "api_name": "_as_list",
        "full_api_name": "_as_list",
        "api_description": "Convert a list or numpy array into a list.",
        "api_signature": "_as_list(obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/spsa.py"
    },
    {
        "api_name": "_repack_points",
        "full_api_name": "_repack_points",
        "api_description": "Turn a list of tuples of points into a tuple of lists of points.\nE.g. turns\n    [(a1, a2, a3), (b1, b2, b3)]\ninto\n    ([a1, b1], [a2, b2], [a3, b3])\nwhere all elements are np.ndarray.",
        "api_signature": "_repack_points(points)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/spsa.py"
    },
    {
        "api_name": "_make_spd",
        "full_api_name": "_make_spd",
        "api_description": "",
        "api_signature": "_make_spd(matrix, bias)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/spsa.py"
    },
    {
        "api_name": "_validate_pert_and_learningrate",
        "full_api_name": "_validate_pert_and_learningrate",
        "api_description": "",
        "api_signature": "_validate_pert_and_learningrate(perturbation, learning_rate)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/spsa.py"
    },
    {
        "api_name": "get_eps",
        "full_api_name": "get_eps",
        "api_description": "",
        "api_signature": "get_eps()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/spsa.py"
    },
    {
        "api_name": "get_eps",
        "full_api_name": "get_eps",
        "api_description": "",
        "api_signature": "get_eps()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/spsa.py"
    },
    {
        "api_name": "get_eta",
        "full_api_name": "get_eta",
        "api_description": "",
        "api_signature": "get_eta()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/spsa.py"
    },
    {
        "api_name": "get_eta",
        "full_api_name": "get_eta",
        "api_description": "",
        "api_signature": "get_eta()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/spsa.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "IMFIL.__init__",
        "api_description": "Args:\n    maxiter: Maximum number of function evaluations.\n\nRaises:\n    MissingOptionalLibraryError: scikit-quant not installed",
        "api_signature": "__init__(self, maxiter)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/imfil.py"
    },
    {
        "api_name": "get_support_level",
        "full_api_name": "IMFIL.get_support_level",
        "api_description": "Returns support level dictionary.",
        "api_signature": "get_support_level(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/imfil.py"
    },
    {
        "api_name": "settings",
        "full_api_name": "IMFIL.settings",
        "api_description": "",
        "api_signature": "settings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/imfil.py"
    },
    {
        "api_name": "minimize",
        "full_api_name": "IMFIL.minimize",
        "api_description": "",
        "api_signature": "minimize(self, fun, x0, jac, bounds)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/imfil.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "TNC.__init__",
        "api_description": "Args:\n    maxiter: Maximum number of function evaluation.\n    disp: Set to True to print convergence messages.\n    accuracy: Relative precision for finite difference calculations.\n        If <= machine_precision, set to sqrt(machine_precision). Defaults to 0.\n    ftol: Precision goal for the value of f in the stopping criterion.\n        If ftol < 0.0, ftol is set to 0.0 defaults to -1.\n    xtol: Precision goal for the value of x in the stopping criterion\n        (after applying x scaling factors).\n        If xtol < 0.0, xtol is set to sqrt(machine_precision). Defaults to -1.\n    gtol: Precision goal for the value of the projected gradient in\n        the stopping criterion (after applying x scaling factors).\n        If gtol < 0.0, gtol is set to 1e-2 * sqrt(accuracy).\n        Setting it to 0.0 is not recommended. Defaults to -1.\n    tol: Tolerance for termination.\n    eps: Step size used for numerical approximation of the Jacobian.\n    options: A dictionary of solver options.\n    max_evals_grouped: Max number of default gradient evaluations performed simultaneously.\n    kwargs: additional kwargs for scipy.optimize.minimize.",
        "api_signature": "__init__(self, maxiter, disp, accuracy, ftol, xtol, gtol, tol, eps, options, max_evals_grouped)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/tnc.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "NFT.__init__",
        "api_description": "Built out using scipy framework, for details, please refer to\nhttps://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html.\n\nArgs:\n    maxiter: Maximum number of iterations to perform.\n    maxfev: Maximum number of function evaluations to perform.\n    disp: disp\n    reset_interval: The minimum estimates directly once\n                    in ``reset_interval`` times.\n    options: A dictionary of solver options.\n    kwargs: additional kwargs for scipy.optimize.minimize.\n\nNotes:\n    In this optimization method, the optimization function have to satisfy\n    three conditions written in [1]_.\n\nReferences:\n    .. [1] K. M. Nakanishi, K. Fujii, and S. Todo. 2019.\n        Sequential minimal optimization for quantum-classical hybrid algorithms.\n        arXiv preprint arXiv:1903.12166.",
        "api_signature": "__init__(self, maxiter, maxfev, disp, reset_interval, options)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/nft.py"
    },
    {
        "api_name": "nakanishi_fujii_todo",
        "full_api_name": "nakanishi_fujii_todo",
        "api_description": "Find the global minimum of a function using the nakanishi_fujii_todo\nalgorithm [1].\nArgs:\n    fun (callable): ``f(x, *args)``\n        Function to be optimized.  ``args`` can be passed as an optional item\n        in the dict ``minimizer_kwargs``.\n        This function must satisfy the three condition written in Ref. [1].\n    x0 (ndarray): shape (n,)\n        Initial guess. Array of real elements of size (n,),\n        where 'n' is the number of independent variables.\n    args (tuple, optional):\n        Extra arguments passed to the objective function.\n    maxiter (int):\n        Maximum number of iterations to perform.\n        Default: None.\n    maxfev (int):\n        Maximum number of function evaluations to perform.\n        Default: 1024.\n    reset_interval (int):\n        The minimum estimates directly once in ``reset_interval`` times.\n        Default: 32.\n    eps (float): eps\n    **_ : additional options\n    callback (callable, optional):\n        Called after each iteration.\nReturns:\n    OptimizeResult:\n        The optimization result represented as a ``OptimizeResult`` object.\n        Important attributes are: ``x`` the solution array. See\n        `OptimizeResult` for a description of other attributes.\nNotes:\n    In this optimization method, the optimization function have to satisfy\n    three conditions written in [2]_.\n\nReferences:\n    .. [2] K. M. Nakanishi, K. Fujii, and S. Todo. 2019.\n    Sequential minimal optimization for quantum-classical hybrid algorithms.\n    arXiv preprint arXiv:1903.12166.",
        "api_signature": "nakanishi_fujii_todo(fun, x0, args, maxiter, maxfev, reset_interval, eps, callback)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/nft.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "L_BFGS_B.__init__",
        "api_description": "Args:\n    maxfun: Maximum number of function evaluations.\n    maxiter: Maximum number of iterations.\n    ftol: The iteration stops when\n        :math:`(f^k - f^{k+1}) / \\max\\{|f^k|, |f^{k+1}|,1\\} \\leq \\text{ftol}`.\n    iprint: Controls the frequency of output. ``iprint < 0`` means no output;\n        ``iprint = 0`` print only one line at the last iteration; ``0 < iprint < 99``\n        print also :math:`f` and :math:`|\\text{proj} g|` every iprint iterations;\n        ``iprint = 99`` print details of every iteration except n-vectors; ``iprint = 100``\n        print also the changes of active set and final :math:`x`; ``iprint > 100`` print\n        details of every iteration including :math:`x` and :math:`g`.\n    eps: If jac is approximated, use this value for the step size.\n    options: A dictionary of solver options.\n    max_evals_grouped: Max number of default gradient evaluations performed simultaneously.\n    kwargs: additional kwargs for ``scipy.optimize.minimize``.",
        "api_signature": "__init__(self, maxfun, maxiter, ftol, iprint, eps, options, max_evals_grouped)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/l_bfgs_b.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "P_BFGS.__init__",
        "api_description": "Args:\n    maxfun: Maximum number of function evaluations.\n    ftol: The iteration stops when (f\\^k - f\\^{k+1})/max{\\|f\\^k\\|,\\|f\\^{k+1}\\|,1} <= ftol.\n    iprint: Controls the frequency of output. iprint < 0 means no output;\n        iprint = 0 print only one line at the last iteration; 0 < iprint < 99\n        print also f and \\|proj g\\| every iprint iterations; iprint = 99 print\n        details of every iteration except n-vectors; iprint = 100 print also the\n        changes of active set and final x; iprint > 100 print details of\n        every iteration including x and g.\n    max_processes: maximum number of processes allowed, has a min. value of 1 if not None.\n    options: A dictionary of solver options.\n    max_evals_grouped: Max number of default gradient evaluations performed simultaneously.\n    kwargs: additional kwargs for scipy.optimize.minimize.",
        "api_signature": "__init__(self, maxfun, ftol, iprint, max_processes, options, max_evals_grouped)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/p_bfgs.py"
    },
    {
        "api_name": "minimize",
        "full_api_name": "P_BFGS.minimize",
        "api_description": "",
        "api_signature": "minimize(self, fun, x0, jac, bounds)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/p_bfgs.py"
    },
    {
        "api_name": "optimize_runner",
        "full_api_name": "P_BFGS.optimize_runner",
        "api_description": "",
        "api_signature": "optimize_runner(_queue, _i_pt)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/p_bfgs.py"
    },
    {
        "api_name": "_optimize",
        "full_api_name": "P_BFGS._optimize",
        "api_description": "",
        "api_signature": "_optimize(self, objective_function, initial_point, gradient_function, variable_bounds)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/p_bfgs.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "POWELL.__init__",
        "api_description": "Args:\n    maxiter: Maximum allowed number of iterations. If both maxiter and maxfev\n        are set, minimization will stop at the first reached.\n    maxfev: Maximum allowed number of function evaluations. If both maxiter and\n        maxfev are set, minimization will stop at the first reached.\n    disp: Set to True to print convergence messages.\n    xtol: Relative error in solution xopt acceptable for convergence.\n    tol: Tolerance for termination.\n    options: A dictionary of solver options.\n    kwargs: additional kwargs for scipy.optimize.minimize.",
        "api_signature": "__init__(self, maxiter, maxfev, disp, xtol, tol, options)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/powell.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "GradientDescent.__init__",
        "api_description": "Args:\n    maxiter: The maximum number of iterations.\n    learning_rate: A constant, list, array or factory of generators yielding learning rates\n                   for the parameter updates. See the docstring for an example.\n    tol: If the norm of the parameter update is smaller than this threshold, the\n        optimizer has converged.\n    perturbation: If no gradient is passed to :meth:`~.minimize` the gradient is\n        approximated with a forward finite difference scheme with ``perturbation``\n        perturbation in both directions (defaults to 1e-2 if required).\n        Ignored when we have an explicit function for the gradient.\nRaises:\n    ValueError: If ``learning_rate`` is an array and its length is less than ``maxiter``.",
        "api_signature": "__init__(self, maxiter, learning_rate, tol, callback, perturbation)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/gradient_descent.py"
    },
    {
        "api_name": "state",
        "full_api_name": "GradientDescent.state",
        "api_description": "Return the current state of the optimizer.",
        "api_signature": "state(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/gradient_descent.py"
    },
    {
        "api_name": "state",
        "full_api_name": "GradientDescent.state",
        "api_description": "Set the current state of the optimizer.",
        "api_signature": "state(self, state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/gradient_descent.py"
    },
    {
        "api_name": "tol",
        "full_api_name": "GradientDescent.tol",
        "api_description": "Returns the tolerance of the optimizer.\n\nAny step with smaller stepsize than this value will stop the optimization.",
        "api_signature": "tol(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/gradient_descent.py"
    },
    {
        "api_name": "tol",
        "full_api_name": "GradientDescent.tol",
        "api_description": "Set the tolerance.",
        "api_signature": "tol(self, tol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/gradient_descent.py"
    },
    {
        "api_name": "perturbation",
        "full_api_name": "GradientDescent.perturbation",
        "api_description": "Returns the perturbation.\n\nThis is the perturbation used in the finite difference gradient approximation.",
        "api_signature": "perturbation(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/gradient_descent.py"
    },
    {
        "api_name": "perturbation",
        "full_api_name": "GradientDescent.perturbation",
        "api_description": "Set the perturbation.",
        "api_signature": "perturbation(self, perturbation)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/gradient_descent.py"
    },
    {
        "api_name": "_callback_wrapper",
        "full_api_name": "GradientDescent._callback_wrapper",
        "api_description": "Wraps the callback function to accommodate GradientDescent.\n\nWill call :attr:`~.callback` and pass the following arguments:\ncurrent number of function values, current parameters, current function value,\nnorm of current gradient.",
        "api_signature": "_callback_wrapper(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/gradient_descent.py"
    },
    {
        "api_name": "settings",
        "full_api_name": "GradientDescent.settings",
        "api_description": "",
        "api_signature": "settings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/gradient_descent.py"
    },
    {
        "api_name": "ask",
        "full_api_name": "GradientDescent.ask",
        "api_description": "Returns an object with the data needed to evaluate the gradient.\n\nIf this object contains a gradient function the gradient can be evaluated directly. Otherwise\napproximate it with a finite difference scheme.",
        "api_signature": "ask(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/gradient_descent.py"
    },
    {
        "api_name": "tell",
        "full_api_name": "GradientDescent.tell",
        "api_description": "Updates :attr:`.~GradientDescentState.x` by an amount proportional to the learning\nrate and value of the gradient at that point.\n\nArgs:\n    ask_data: The data used to evaluate the function.\n    tell_data: The data from the function evaluation.\n\nRaises:\n    ValueError: If the gradient passed doesn't have the right dimension.",
        "api_signature": "tell(self, ask_data, tell_data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/gradient_descent.py"
    },
    {
        "api_name": "evaluate",
        "full_api_name": "GradientDescent.evaluate",
        "api_description": "Evaluates the gradient.\n\nIt does so either by evaluating an analytic gradient or by approximating it with a\nfinite difference scheme. It will either add ``1`` to the number of gradient evaluations or add\n``N+1`` to the number of function evaluations (Where N is the dimension of the gradient).\n\nArgs:\n    ask_data: It contains the point where the gradient is to be evaluated and the gradient\n              function or, in its absence, the objective function to perform a finite difference\n              approximation.\n\nReturns:\n    The data containing the gradient evaluation.",
        "api_signature": "evaluate(self, ask_data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/gradient_descent.py"
    },
    {
        "api_name": "create_result",
        "full_api_name": "GradientDescent.create_result",
        "api_description": "Creates a result of the optimization process.\n\nThis result contains the best point, the best function value, the number of function/gradient\nevaluations and the number of iterations.\n\nReturns:\n    The result of the optimization process.",
        "api_signature": "create_result(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/gradient_descent.py"
    },
    {
        "api_name": "start",
        "full_api_name": "GradientDescent.start",
        "api_description": "",
        "api_signature": "start(self, fun, x0, jac, bounds)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/gradient_descent.py"
    },
    {
        "api_name": "continue_condition",
        "full_api_name": "GradientDescent.continue_condition",
        "api_description": "Condition that indicates the optimization process should come to an end.\n\nWhen the stepsize is smaller than the tolerance, the optimization process is considered\nfinished.\n\nReturns:\n    ``True`` if the optimization process should continue, ``False`` otherwise.",
        "api_signature": "continue_condition(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/gradient_descent.py"
    },
    {
        "api_name": "get_support_level",
        "full_api_name": "GradientDescent.get_support_level",
        "api_description": "Get the support level dictionary.",
        "api_signature": "get_support_level(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/gradient_descent.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "GSLS.__init__",
        "api_description": "Args:\n    maxiter: Maximum number of iterations.\n    max_eval: Maximum number of evaluations.\n    disp: Set to True to display convergence messages.\n    sampling_radius: Sampling radius to determine gradient estimate.\n    sample_size_factor: The size of the sample set at each iteration is this number\n        multiplied by the dimension of the problem, rounded to the nearest integer.\n    initial_step_size: Initial step size for the descent algorithm.\n    min_step_size: Minimum step size for the descent algorithm.\n    step_size_multiplier: Step size reduction after unsuccessful steps, in the\n        interval (0, 1).\n    armijo_parameter: Armijo parameter for sufficient decrease criterion, in the\n        interval (0, 1).\n    min_gradient_norm: If the gradient norm is below this threshold, the algorithm stops.\n    max_failed_rejection_sampling: Maximum number of attempts to sample points within\n        bounds.",
        "api_signature": "__init__(self, maxiter, max_eval, disp, sampling_radius, sample_size_factor, initial_step_size, min_step_size, step_size_multiplier, armijo_parameter, min_gradient_norm, max_failed_rejection_sampling)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/gsls.py"
    },
    {
        "api_name": "get_support_level",
        "full_api_name": "GSLS.get_support_level",
        "api_description": "Return support level dictionary.\n\nReturns:\n    A dictionary containing the support levels for different options.",
        "api_signature": "get_support_level(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/gsls.py"
    },
    {
        "api_name": "settings",
        "full_api_name": "GSLS.settings",
        "api_description": "",
        "api_signature": "settings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/gsls.py"
    },
    {
        "api_name": "minimize",
        "full_api_name": "GSLS.minimize",
        "api_description": "",
        "api_signature": "minimize(self, fun, x0, jac, bounds)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/gsls.py"
    },
    {
        "api_name": "ls_optimize",
        "full_api_name": "GSLS.ls_optimize",
        "api_description": "Run the line search optimization.\n\nArgs:\n    n: Dimension of the problem.\n    obj_fun: Objective function.\n    initial_point: Initial point.\n    var_lb: Vector of lower bounds on the decision variables. Vector elements can be -np.inf\n            if the corresponding variable is unbounded from below.\n    var_ub: Vector of upper bounds on the decision variables. Vector elements can be np.inf\n            if the corresponding variable is unbounded from below.\n\nReturns:\n    Final iterate as a vector, corresponding objective function value,\n    number of evaluations, and norm of the gradient estimate.\n\nRaises:\n    ValueError: If the number of dimensions mismatches the size of the initial point or\n        the length of the lower or upper bound.",
        "api_signature": "ls_optimize(self, n, obj_fun, initial_point, var_lb, var_ub)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/gsls.py"
    },
    {
        "api_name": "sample_points",
        "full_api_name": "GSLS.sample_points",
        "api_description": "Sample ``num_points`` points around ``x`` on the ``n``-sphere of specified radius.\n\nThe radius of the sphere is ``self._options['sampling_radius']``.\n\nArgs:\n    n: Dimension of the problem.\n    x: Point around which the sample set is constructed.\n    num_points: Number of points in the sample set.\n\nReturns:\n    A tuple containing the sampling points and the directions.",
        "api_signature": "sample_points(self, n, x, num_points)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/gsls.py"
    },
    {
        "api_name": "sample_set",
        "full_api_name": "GSLS.sample_set",
        "api_description": "Construct sample set of given size.\n\nArgs:\n    n: Dimension of the problem.\n    x: Point around which the sample set is constructed.\n    var_lb: Vector of lower bounds on the decision variables. Vector elements can be -np.inf\n        if the corresponding variable is unbounded from below.\n    var_ub: Vector of lower bounds on the decision variables. Vector elements can be np.inf\n        if the corresponding variable is unbounded from above.\n    num_points: Number of points in the sample set.\n\nReturns:\n    Matrices of (unit-norm) sample directions and sample points, one per row.\n    Both matrices are 2D arrays of floats.\n\nRaises:\n    RuntimeError: If not enough samples could be generated within the bounds.",
        "api_signature": "sample_set(self, n, x, var_lb, var_ub, num_points)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/gsls.py"
    },
    {
        "api_name": "gradient_approximation",
        "full_api_name": "GSLS.gradient_approximation",
        "api_description": "Construct gradient approximation from given sample.\n\nArgs:\n    n: Dimension of the problem.\n    x: Point around which the sample set was constructed.\n    x_value: Objective function value at x.\n    directions: Directions of the sample points wrt the central point x, as a 2D array.\n    sample_set_x: x-coordinates of the sample set, one point per row, as a 2D array.\n    sample_set_y: Objective function values of the points in sample_set_x, as a 1D array.\n\nReturns:\n    Gradient approximation at x, as a 1D array.",
        "api_signature": "gradient_approximation(self, n, x, x_value, directions, sample_set_x, sample_set_y)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/gsls.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SNOBFIT.__init__",
        "api_description": "Args:\n    maxiter: Maximum number of function evaluations.\n    maxmp: Maximum number of  model points requested for the local fit.\n         Default = 2 * number of parameters + 6 set to this value when None.\n    maxfail: Maximum number of failures to improve the solution. Stops the algorithm\n            after maxfail is reached.\n    verbose: Provide verbose (debugging) output.\n\nRaises:\n    MissingOptionalLibraryError: scikit-quant or SQSnobFit not installed\n    QiskitError: If NumPy 1.24.0 or above is installed.\n        See https://github.com/scikit-quant/scikit-quant/issues/24 for more details.",
        "api_signature": "__init__(self, maxiter, maxfail, maxmp, verbose)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/snobfit.py"
    },
    {
        "api_name": "get_support_level",
        "full_api_name": "SNOBFIT.get_support_level",
        "api_description": "Returns support level dictionary.",
        "api_signature": "get_support_level(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/snobfit.py"
    },
    {
        "api_name": "settings",
        "full_api_name": "SNOBFIT.settings",
        "api_description": "",
        "api_signature": "settings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/snobfit.py"
    },
    {
        "api_name": "minimize",
        "full_api_name": "SNOBFIT.minimize",
        "api_description": "",
        "api_signature": "minimize(self, fun, x0, jac, bounds)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/snobfit.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "NELDER_MEAD.__init__",
        "api_description": "Args:\n    maxiter: Maximum allowed number of iterations. If both maxiter and maxfev are set,\n        minimization will stop at the first reached.\n    maxfev: Maximum allowed number of function evaluations. If both maxiter and\n        maxfev are set, minimization will stop at the first reached.\n    disp: Set to True to print convergence messages.\n    xatol: Absolute error in xopt between iterations that is acceptable for convergence.\n    tol: Tolerance for termination.\n    adaptive: Adapt algorithm parameters to dimensionality of problem.\n    options: A dictionary of solver options.\n    kwargs: additional kwargs for scipy.optimize.minimize.",
        "api_signature": "__init__(self, maxiter, maxfev, disp, xatol, tol, adaptive, options)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/nelder_mead.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CG.__init__",
        "api_description": "Args:\n    maxiter: Maximum number of iterations to perform.\n    disp: Set to True to print convergence messages.\n    gtol: Gradient norm must be less than gtol before successful termination.\n    tol: Tolerance for termination.\n    eps: If jac is approximated, use this value for the step size.\n    options: A dictionary of solver options.\n    max_evals_grouped: Max number of default gradient evaluations performed simultaneously.\n    kwargs: additional kwargs for scipy.optimize.minimize.",
        "api_signature": "__init__(self, maxiter, disp, gtol, tol, eps, options, max_evals_grouped)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/cg.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "COBYLA.__init__",
        "api_description": "Args:\n    maxiter: Maximum number of function evaluations.\n    disp: Set to True to print convergence messages.\n    rhobeg: Reasonable initial changes to the variables.\n    tol: Final accuracy in the optimization (not precisely guaranteed).\n         This is a lower bound on the size of the trust region.\n    options: A dictionary of solver options.\n    kwargs: additional kwargs for scipy.optimize.minimize.",
        "api_signature": "__init__(self, maxiter, disp, rhobeg, tol, options)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/cobyla.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "OptimizerResult.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/optimizer.py"
    },
    {
        "api_name": "x",
        "full_api_name": "OptimizerResult.x",
        "api_description": "The final point of the minimization.",
        "api_signature": "x(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/optimizer.py"
    },
    {
        "api_name": "x",
        "full_api_name": "OptimizerResult.x",
        "api_description": "Set the final point of the minimization.",
        "api_signature": "x(self, x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/optimizer.py"
    },
    {
        "api_name": "fun",
        "full_api_name": "OptimizerResult.fun",
        "api_description": "The final value of the minimization.",
        "api_signature": "fun(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/optimizer.py"
    },
    {
        "api_name": "fun",
        "full_api_name": "OptimizerResult.fun",
        "api_description": "Set the final value of the minimization.",
        "api_signature": "fun(self, fun)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/optimizer.py"
    },
    {
        "api_name": "jac",
        "full_api_name": "OptimizerResult.jac",
        "api_description": "The final gradient of the minimization.",
        "api_signature": "jac(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/optimizer.py"
    },
    {
        "api_name": "jac",
        "full_api_name": "OptimizerResult.jac",
        "api_description": "Set the final gradient of the minimization.",
        "api_signature": "jac(self, jac)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/optimizer.py"
    },
    {
        "api_name": "nfev",
        "full_api_name": "OptimizerResult.nfev",
        "api_description": "The total number of function evaluations.",
        "api_signature": "nfev(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/optimizer.py"
    },
    {
        "api_name": "nfev",
        "full_api_name": "OptimizerResult.nfev",
        "api_description": "Set the total number of function evaluations.",
        "api_signature": "nfev(self, nfev)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/optimizer.py"
    },
    {
        "api_name": "njev",
        "full_api_name": "OptimizerResult.njev",
        "api_description": "The total number of gradient evaluations.",
        "api_signature": "njev(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/optimizer.py"
    },
    {
        "api_name": "njev",
        "full_api_name": "OptimizerResult.njev",
        "api_description": "Set the total number of gradient evaluations.",
        "api_signature": "njev(self, njev)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/optimizer.py"
    },
    {
        "api_name": "nit",
        "full_api_name": "OptimizerResult.nit",
        "api_description": "The total number of iterations.",
        "api_signature": "nit(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/optimizer.py"
    },
    {
        "api_name": "nit",
        "full_api_name": "OptimizerResult.nit",
        "api_description": "Set the total number of iterations.",
        "api_signature": "nit(self, nit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/optimizer.py"
    },
    {
        "api_name": "__call__",
        "full_api_name": "Minimizer.__call__",
        "api_description": "Minimize the objective function.\n\nThis interface is based on `SciPy's optimize module <https://docs.scipy.org/doc\n/scipy/reference/generated/scipy.optimize.minimize.html>`__.\n\nArgs:\n    fun: The objective function to minimize (for example the energy in the case of the VQE).\n    x0: The initial point for the optimization.\n    jac: The gradient of the objective function.\n    bounds: Parameters bounds for the optimization. Note that these might not be supported\n        by all optimizers.\n\nReturns:\n     The minimization result object (either SciPy's or Qiskit's).",
        "api_signature": "__call__(self, fun, x0, jac, bounds)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/optimizer.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Optimizer.__init__",
        "api_description": "Initialize the optimization algorithm, setting the support\nlevel for _gradient_support_level, _bound_support_level,\n_initial_point_support_level, and empty options.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/optimizer.py"
    },
    {
        "api_name": "get_support_level",
        "full_api_name": "Optimizer.get_support_level",
        "api_description": "Return support level dictionary",
        "api_signature": "get_support_level(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/optimizer.py"
    },
    {
        "api_name": "set_options",
        "full_api_name": "Optimizer.set_options",
        "api_description": "Sets or updates values in the options dictionary.\n\nThe options dictionary may be used internally by a given optimizer to\npass additional optional values for the underlying optimizer/optimization\nfunction used. The options dictionary may be initially populated with\na set of key/values when the given optimizer is constructed.\n\nArgs:\n    kwargs (dict): options, given as name=value.",
        "api_signature": "set_options(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/optimizer.py"
    },
    {
        "api_name": "gradient_num_diff",
        "full_api_name": "Optimizer.gradient_num_diff",
        "api_description": "We compute the gradient with the numeric differentiation in the parallel way,\naround the point x_center.\n\nArgs:\n    x_center (ndarray): point around which we compute the gradient\n    f (func): the function of which the gradient is to be computed.\n    epsilon (float): the epsilon used in the numeric differentiation.\n    max_evals_grouped (int): max evals grouped, defaults to 1 (i.e. no batching).\nReturns:\n    grad: the gradient computed",
        "api_signature": "gradient_num_diff(x_center, f, epsilon, max_evals_grouped)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/optimizer.py"
    },
    {
        "api_name": "wrap_function",
        "full_api_name": "Optimizer.wrap_function",
        "api_description": "Wrap the function to implicitly inject the args at the call of the function.\n\nArgs:\n    function (func): the target function\n    args (tuple): the args to be injected\nReturns:\n    function_wrapper: wrapper",
        "api_signature": "wrap_function(function, args)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/optimizer.py"
    },
    {
        "api_name": "function_wrapper",
        "full_api_name": "Optimizer.function_wrapper",
        "api_description": "",
        "api_signature": "function_wrapper()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/optimizer.py"
    },
    {
        "api_name": "setting",
        "full_api_name": "Optimizer.setting",
        "api_description": "Return setting",
        "api_signature": "setting(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/optimizer.py"
    },
    {
        "api_name": "settings",
        "full_api_name": "Optimizer.settings",
        "api_description": "The optimizer settings in a dictionary format.\n\nThe settings can for instance be used for JSON-serialization (if all settings are\nserializable, which e.g. doesn't hold per default for callables), such that the\noptimizer object can be reconstructed as\n\n.. code-block::\n\n    settings = optimizer.settings\n    # JSON serialize and send to another server\n    optimizer = OptimizerClass(**settings)",
        "api_signature": "settings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/optimizer.py"
    },
    {
        "api_name": "minimize",
        "full_api_name": "Optimizer.minimize",
        "api_description": "Minimize the scalar function.\n\nArgs:\n    fun: The scalar function to minimize.\n    x0: The initial point for the minimization.\n    jac: The gradient of the scalar function ``fun``.\n    bounds: Bounds for the variables of ``fun``. This argument might be ignored if the\n        optimizer does not support bounds.\n\nReturns:\n    The result of the optimization, containing e.g. the result as attribute ``x``.",
        "api_signature": "minimize(self, fun, x0, jac, bounds)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/optimizer.py"
    },
    {
        "api_name": "gradient_support_level",
        "full_api_name": "Optimizer.gradient_support_level",
        "api_description": "Returns gradient support level",
        "api_signature": "gradient_support_level(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/optimizer.py"
    },
    {
        "api_name": "is_gradient_ignored",
        "full_api_name": "Optimizer.is_gradient_ignored",
        "api_description": "Returns is gradient ignored",
        "api_signature": "is_gradient_ignored(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/optimizer.py"
    },
    {
        "api_name": "is_gradient_supported",
        "full_api_name": "Optimizer.is_gradient_supported",
        "api_description": "Returns is gradient supported",
        "api_signature": "is_gradient_supported(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/optimizer.py"
    },
    {
        "api_name": "is_gradient_required",
        "full_api_name": "Optimizer.is_gradient_required",
        "api_description": "Returns is gradient required",
        "api_signature": "is_gradient_required(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/optimizer.py"
    },
    {
        "api_name": "bounds_support_level",
        "full_api_name": "Optimizer.bounds_support_level",
        "api_description": "Returns bounds support level",
        "api_signature": "bounds_support_level(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/optimizer.py"
    },
    {
        "api_name": "is_bounds_ignored",
        "full_api_name": "Optimizer.is_bounds_ignored",
        "api_description": "Returns is bounds ignored",
        "api_signature": "is_bounds_ignored(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/optimizer.py"
    },
    {
        "api_name": "is_bounds_supported",
        "full_api_name": "Optimizer.is_bounds_supported",
        "api_description": "Returns is bounds supported",
        "api_signature": "is_bounds_supported(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/optimizer.py"
    },
    {
        "api_name": "is_bounds_required",
        "full_api_name": "Optimizer.is_bounds_required",
        "api_description": "Returns is bounds required",
        "api_signature": "is_bounds_required(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/optimizer.py"
    },
    {
        "api_name": "initial_point_support_level",
        "full_api_name": "Optimizer.initial_point_support_level",
        "api_description": "Returns initial point support level",
        "api_signature": "initial_point_support_level(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/optimizer.py"
    },
    {
        "api_name": "is_initial_point_ignored",
        "full_api_name": "Optimizer.is_initial_point_ignored",
        "api_description": "Returns is initial point ignored",
        "api_signature": "is_initial_point_ignored(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/optimizer.py"
    },
    {
        "api_name": "is_initial_point_supported",
        "full_api_name": "Optimizer.is_initial_point_supported",
        "api_description": "Returns is initial point supported",
        "api_signature": "is_initial_point_supported(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/optimizer.py"
    },
    {
        "api_name": "is_initial_point_required",
        "full_api_name": "Optimizer.is_initial_point_required",
        "api_description": "Returns is initial point required",
        "api_signature": "is_initial_point_required(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/optimizer.py"
    },
    {
        "api_name": "print_options",
        "full_api_name": "Optimizer.print_options",
        "api_description": "Print algorithm-specific options.",
        "api_signature": "print_options(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/optimizer.py"
    },
    {
        "api_name": "set_max_evals_grouped",
        "full_api_name": "Optimizer.set_max_evals_grouped",
        "api_description": "Set max evals grouped",
        "api_signature": "set_max_evals_grouped(self, limit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/optimizer.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SLSQP.__init__",
        "api_description": "Args:\n    maxiter: Maximum number of iterations.\n    disp: Set to True to print convergence messages.\n    ftol: Precision goal for the value of f in the stopping criterion.\n    tol: Tolerance for termination.\n    eps: Step size used for numerical approximation of the Jacobian.\n    options: A dictionary of solver options.\n    max_evals_grouped: Max number of default gradient evaluations performed simultaneously.\n    kwargs: additional kwargs for scipy.optimize.minimize.",
        "api_signature": "__init__(self, maxiter, disp, ftol, tol, eps, options, max_evals_grouped)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/slsqp.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "LearningRate.__init__",
        "api_description": "Args:\n    learning_rate: Used to create a generator to iterate on.",
        "api_signature": "__init__(self, learning_rate)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/optimizer_utils/learning_rate.py"
    },
    {
        "api_name": "send",
        "full_api_name": "LearningRate.send",
        "api_description": "Send a value into the generator.\nReturn next yielded value or raise StopIteration.",
        "api_signature": "send(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/optimizer_utils/learning_rate.py"
    },
    {
        "api_name": "throw",
        "full_api_name": "LearningRate.throw",
        "api_description": "Raise an exception in the generator.\nReturn next yielded value or raise StopIteration.",
        "api_signature": "throw(self, typ, val, tb)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/optimizer_utils/learning_rate.py"
    },
    {
        "api_name": "current",
        "full_api_name": "LearningRate.current",
        "api_description": "Returns the current value of the learning rate.",
        "api_signature": "current(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/optimizer_utils/learning_rate.py"
    },
    {
        "api_name": "constant",
        "full_api_name": "constant",
        "api_description": "Returns a python generator that always yields the same value.\n\nArgs:\n    learning_rate: The value to yield.\n\nYields:\n    The learning rate for the next iteration.",
        "api_signature": "constant(learning_rate)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/optimizer_utils/learning_rate.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "NLoptOptimizer.__init__",
        "api_description": "Args:\n    max_evals: Maximum allowed number of function evaluations.\n\nRaises:\n    MissingOptionalLibraryError: NLopt library not installed.",
        "api_signature": "__init__(self, max_evals)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/nlopts/nloptimizer.py"
    },
    {
        "api_name": "get_nlopt_optimizer",
        "full_api_name": "NLoptOptimizer.get_nlopt_optimizer",
        "api_description": "return NLopt optimizer enum type",
        "api_signature": "get_nlopt_optimizer(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/nlopts/nloptimizer.py"
    },
    {
        "api_name": "get_support_level",
        "full_api_name": "NLoptOptimizer.get_support_level",
        "api_description": "return support level dictionary",
        "api_signature": "get_support_level(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/nlopts/nloptimizer.py"
    },
    {
        "api_name": "settings",
        "full_api_name": "NLoptOptimizer.settings",
        "api_description": "",
        "api_signature": "settings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/nlopts/nloptimizer.py"
    },
    {
        "api_name": "minimize",
        "full_api_name": "NLoptOptimizer.minimize",
        "api_description": "",
        "api_signature": "minimize(self, fun, x0, jac, bounds)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/nlopts/nloptimizer.py"
    },
    {
        "api_name": "wrap_objfunc_global",
        "full_api_name": "NLoptOptimizer.wrap_objfunc_global",
        "api_description": "",
        "api_signature": "wrap_objfunc_global(x, _grad)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/nlopts/nloptimizer.py"
    },
    {
        "api_name": "get_nlopt_optimizer",
        "full_api_name": "DIRECT_L.get_nlopt_optimizer",
        "api_description": "Return NLopt optimizer type",
        "api_signature": "get_nlopt_optimizer(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/nlopts/direct_l.py"
    },
    {
        "api_name": "get_nlopt_optimizer",
        "full_api_name": "ESCH.get_nlopt_optimizer",
        "api_description": "Return NLopt optimizer type",
        "api_signature": "get_nlopt_optimizer(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/nlopts/esch.py"
    },
    {
        "api_name": "get_nlopt_optimizer",
        "full_api_name": "ISRES.get_nlopt_optimizer",
        "api_description": "Return NLopt optimizer type",
        "api_signature": "get_nlopt_optimizer(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/nlopts/isres.py"
    },
    {
        "api_name": "get_nlopt_optimizer",
        "full_api_name": "CRS.get_nlopt_optimizer",
        "api_description": "Return NLopt optimizer type",
        "api_signature": "get_nlopt_optimizer(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/nlopts/crs.py"
    },
    {
        "api_name": "get_nlopt_optimizer",
        "full_api_name": "DIRECT_L_RAND.get_nlopt_optimizer",
        "api_description": "Return NLopt optimizer type",
        "api_signature": "get_nlopt_optimizer(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/algorithms/optimizers/nlopts/direct_l_rand.py"
    },
    {
        "api_name": "get_platform_parallel_default",
        "full_api_name": "get_platform_parallel_default",
        "api_description": "Returns the default parallelism flag value for the current platform.\n\nReturns:\n    parallel_default: The default parallelism flag value for the\n    current platform.",
        "api_signature": "get_platform_parallel_default()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/parallel.py"
    },
    {
        "api_name": "_task_wrapper",
        "full_api_name": "_task_wrapper",
        "api_description": "",
        "api_signature": "_task_wrapper(param)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/parallel.py"
    },
    {
        "api_name": "parallel_map",
        "full_api_name": "parallel_map",
        "api_description": "Parallel execution of a mapping of `values` to the function `task`. This\nis functionally equivalent to::\n\n    result = [task(value, *task_args, **task_kwargs) for value in values]\n\nOn Windows this function defaults to a serial implementation to avoid the\noverhead from spawning processes in Windows.\n\nArgs:\n    task (func): Function that is to be called for each value in ``values``.\n    values (array_like): List or array of values for which the ``task``\n                        function is to be evaluated.\n    task_args (list): Optional additional arguments to the ``task`` function.\n    task_kwargs (dict): Optional additional keyword argument to the ``task`` function.\n    num_processes (int): Number of processes to spawn.\n\nReturns:\n    result: The result list contains the value of\n            ``task(value, *task_args, **task_kwargs)`` for\n                each value in ``values``.\n\nRaises:\n    QiskitError: If user interrupts via keyboard.\n\nEvents:\n    terra.parallel.start: The collection of parallel tasks are about to start.\n    terra.parallel.update: One of the parallel task has finished.\n    terra.parallel.finish: All the parallel tasks have finished.\n\nExamples:\n\n    .. code-block:: python\n\n        import time\n        from qiskit.tools.parallel import parallel_map\n        def func(_):\n                time.sleep(0.1)\n                return 0\n        parallel_map(func, list(range(10)));",
        "api_signature": "parallel_map(task, values, task_args, task_kwargs, num_processes)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/parallel.py"
    },
    {
        "api_name": "_callback",
        "full_api_name": "_callback",
        "api_description": "",
        "api_signature": "_callback(_)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/parallel.py"
    },
    {
        "api_name": "get_unique_backends",
        "full_api_name": "get_unique_backends",
        "api_description": "Gets the unique backends that are available.\n\nReturns:\n    list: Unique available backends.\n\nRaises:\n    QiskitError: No backends available.\n    MissingOptionalLibraryError: If qiskit-ibmq-provider is not installed",
        "api_signature": "get_unique_backends()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/monitor/overview.py"
    },
    {
        "api_name": "backend_monitor",
        "full_api_name": "backend_monitor",
        "api_description": "Monitor a single IBMQ backend.\n\nArgs:\n    backend (IBMQBackend): Backend to monitor.\nRaises:\n    QiskitError: Input is not a IBMQ backend.\n    MissingOptionalLibraryError: If qiskit-ibmq-provider is not installed\n\nExamples:\n.. code-block:: python\n\n   from qiskit.providers.ibmq import IBMQ\n   from qiskit.tools.monitor import backend_monitor\n   provider = IBMQ.get_provider(hub='ibm-q')\n   backend_monitor(provider.backends.ibmq_lima)",
        "api_signature": "backend_monitor(backend)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/monitor/overview.py"
    },
    {
        "api_name": "backend_overview",
        "full_api_name": "backend_overview",
        "api_description": "Gives overview information on all the IBMQ\nbackends that are available.\n\nExamples:\n\n    .. code-block:: python\n\n        from qiskit.providers.ibmq import IBMQ\n        from qiskit.tools.monitor import backend_overview\n        provider = IBMQ.get_provider(hub='ibm-q')\n        backend_overview()",
        "api_signature": "backend_overview()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/monitor/overview.py"
    },
    {
        "api_name": "_text_checker",
        "full_api_name": "_text_checker",
        "api_description": "A text-based job status checker\n\nArgs:\n    job (BaseJob): The job to check.\n    interval (int): The interval at which to check.\n    _interval_set (bool): Was interval time set by user?\n    quiet (bool): If True, do not print status messages.\n    output (file): The file like object to write status messages to.\n    By default this is sys.stdout.\n    line_discipline (string): character emitted at start of a line of job monitor output,\n    This defaults to \\r.",
        "api_signature": "_text_checker(job, interval, _interval_set, quiet, output, line_discipline)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/monitor/job_monitor.py"
    },
    {
        "api_name": "job_monitor",
        "full_api_name": "job_monitor",
        "api_description": "Monitor the status of a IBMQJob instance.\n\nArgs:\n    job (BaseJob): Job to monitor.\n    interval (int): Time interval between status queries.\n    quiet (bool): If True, do not print status messages.\n    output (file): The file like object to write status messages to.\n    By default this is sys.stdout.\n    line_discipline (string): character emitted at start of a line of job monitor output,\n    This defaults to \\r.\n\nExamples:\n\n    .. code-block:: python\n\n        from qiskit import BasicAer, transpile\n        from qiskit.circuit import QuantumCircuit\n        from qiskit.tools.monitor import job_monitor\n        sim_backend = BasicAer.get_backend(\"qasm_simulator\")\n        qc = QuantumCircuit(2, 2)\n        qc.h(0)\n        qc.cx(0, 1)\n        qc.measure_all()\n        tqc = transpile(qc, sim_backend)\n        job_sim = sim_backend.run(tqc)\n        job_monitor(job_sim)",
        "api_signature": "job_monitor(job, interval, quiet, output, line_discipline)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/monitor/job_monitor.py"
    },
    {
        "api_name": "__new__",
        "full_api_name": "_Broker.__new__",
        "api_description": "",
        "api_signature": "__new__(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/events/pubsub.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "_Subscription.__init__",
        "api_description": "",
        "api_signature": "__init__(self, event, callback)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/events/pubsub.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "_Subscription.__eq__",
        "api_description": "Overrides the default implementation",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/events/pubsub.py"
    },
    {
        "api_name": "subscribe",
        "full_api_name": "subscribe",
        "api_description": "Subscribes to an event, so when it's emitted all the callbacks subscribed,\nwill be executed. We are not allowing double registration.\n\nArgs:\n    event (string): The event to subscribed in the form of:\n                    \"terra.<component>.<method>.<action>\"\n    callback (callable): The callback that will be executed when an event is\n                          emitted.",
        "api_signature": "subscribe(self, event, callback)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/events/pubsub.py"
    },
    {
        "api_name": "dispatch",
        "full_api_name": "dispatch",
        "api_description": "Emits an event if there are any subscribers.\n\nArgs:\n    event (String): The event to be emitted\n    args: Arguments linked with the event\n    kwargs: Named arguments linked with the event",
        "api_signature": "dispatch(self, event)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/events/pubsub.py"
    },
    {
        "api_name": "unsubscribe",
        "full_api_name": "unsubscribe",
        "api_description": "Unsubscribe the specific callback to the event.\n\nArgs\n    event (String): The event to unsubscribe\n    callback (callable): The callback that won't be executed anymore\n\nReturns\n    True: if we have successfully unsubscribed to the event\n    False: if there's no callback previously registered",
        "api_signature": "unsubscribe(self, event, callback)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/events/pubsub.py"
    },
    {
        "api_name": "clear",
        "full_api_name": "clear",
        "api_description": "Unsubscribe everything, leaving the Broker without subscribers/events.",
        "api_signature": "clear(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/events/pubsub.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Publisher.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/events/pubsub.py"
    },
    {
        "api_name": "publish",
        "full_api_name": "Publisher.publish",
        "api_description": "Triggers an event, and associates some data to it, so if there are any\nsubscribers, their callback will be called synchronously.",
        "api_signature": "publish(self, event)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/events/pubsub.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Subscriber.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/events/pubsub.py"
    },
    {
        "api_name": "subscribe",
        "full_api_name": "Subscriber.subscribe",
        "api_description": "Subscribes to an event, associating a callback function to that event, so\nwhen the event occurs, the callback will be called.\nThis is a blocking call, so try to keep callbacks as lightweight as possible.",
        "api_signature": "subscribe(self, event, callback)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/events/pubsub.py"
    },
    {
        "api_name": "unsubscribe",
        "full_api_name": "Subscriber.unsubscribe",
        "api_description": "Unsubscribe a pair event-callback, so the callback will not be called anymore\nwhen the event occurs.",
        "api_signature": "unsubscribe(self, event, callback)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/events/pubsub.py"
    },
    {
        "api_name": "clear",
        "full_api_name": "Subscriber.clear",
        "api_description": "Unsubscribe everything",
        "api_signature": "clear(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/events/pubsub.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BaseProgressBar.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/events/progressbar.py"
    },
    {
        "api_name": "start",
        "full_api_name": "BaseProgressBar.start",
        "api_description": "Start the progress bar.\n\nParameters:\n    iterations (int): Number of iterations.",
        "api_signature": "start(self, iterations)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/events/progressbar.py"
    },
    {
        "api_name": "update",
        "full_api_name": "BaseProgressBar.update",
        "api_description": "Update status of progress bar.",
        "api_signature": "update(self, n)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/events/progressbar.py"
    },
    {
        "api_name": "time_elapsed",
        "full_api_name": "BaseProgressBar.time_elapsed",
        "api_description": "Return the time elapsed since start.\n\nReturns:\n    elapsed_time: Time since progress bar started.",
        "api_signature": "time_elapsed(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/events/progressbar.py"
    },
    {
        "api_name": "time_remaining_est",
        "full_api_name": "BaseProgressBar.time_remaining_est",
        "api_description": "Estimate the remaining time left.\n\nParameters:\n    completed_iter (int): Number of iterations completed.\n\nReturns:\n    est_time: Estimated time remaining.",
        "api_signature": "time_remaining_est(self, completed_iter)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/events/progressbar.py"
    },
    {
        "api_name": "finished",
        "full_api_name": "BaseProgressBar.finished",
        "api_description": "Run when progress bar has completed.",
        "api_signature": "finished(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/events/progressbar.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "TextProgressBar.__init__",
        "api_description": "",
        "api_signature": "__init__(self, output_handler)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/events/progressbar.py"
    },
    {
        "api_name": "_init_subscriber",
        "full_api_name": "TextProgressBar._init_subscriber",
        "api_description": "",
        "api_signature": "_init_subscriber(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/events/progressbar.py"
    },
    {
        "api_name": "_initialize_progress_bar",
        "full_api_name": "TextProgressBar._initialize_progress_bar",
        "api_description": "",
        "api_signature": "_initialize_progress_bar(num_tasks)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/events/progressbar.py"
    },
    {
        "api_name": "_update_progress_bar",
        "full_api_name": "TextProgressBar._update_progress_bar",
        "api_description": "",
        "api_signature": "_update_progress_bar(progress)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/events/progressbar.py"
    },
    {
        "api_name": "_finish_progress_bar",
        "full_api_name": "TextProgressBar._finish_progress_bar",
        "api_description": "",
        "api_signature": "_finish_progress_bar()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/events/progressbar.py"
    },
    {
        "api_name": "start",
        "full_api_name": "TextProgressBar.start",
        "api_description": "",
        "api_signature": "start(self, iterations)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/events/progressbar.py"
    },
    {
        "api_name": "update",
        "full_api_name": "TextProgressBar.update",
        "api_description": "",
        "api_signature": "update(self, n)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/events/progressbar.py"
    },
    {
        "api_name": "_generate_circuit_library_visualization",
        "full_api_name": "_generate_circuit_library_visualization",
        "api_description": "",
        "api_signature": "_generate_circuit_library_visualization(circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/jupyter/library.py"
    },
    {
        "api_name": "circuit_data_table",
        "full_api_name": "circuit_data_table",
        "api_description": "Create a HTML table widget for a given quantum circuit.\n\nArgs:\n    circuit: Input quantum circuit.\n\nReturns:\n    Output widget.",
        "api_signature": "circuit_data_table(circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/jupyter/library.py"
    },
    {
        "api_name": "properties_widget",
        "full_api_name": "properties_widget",
        "api_description": "Create a HTML table widget with header for a given quantum circuit.\n\nArgs:\n    circuit: Input quantum circuit.\n\nReturns:\n    Output widget.",
        "api_signature": "properties_widget(circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/jupyter/library.py"
    },
    {
        "api_name": "qasm_widget",
        "full_api_name": "qasm_widget",
        "api_description": "Generate an OpenQASM widget with header for a quantum circuit.\n\nArgs:\n    circuit: Input quantum circuit.\n\nReturns:\n    Output widget.",
        "api_signature": "qasm_widget(circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/jupyter/library.py"
    },
    {
        "api_name": "circuit_diagram_widget",
        "full_api_name": "circuit_diagram_widget",
        "api_description": "Create a circuit diagram widget.\n\nReturns:\n    Output widget.",
        "api_signature": "circuit_diagram_widget()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/jupyter/library.py"
    },
    {
        "api_name": "circuit_library_widget",
        "full_api_name": "circuit_library_widget",
        "api_description": "Create a circuit library widget.\n\nArgs:\n    circuit: Input quantum circuit.",
        "api_signature": "circuit_library_widget(circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/jupyter/library.py"
    },
    {
        "api_name": "qiskit_backend_overview",
        "full_api_name": "BackendOverview.qiskit_backend_overview",
        "api_description": "A Jupyter magic function to monitor backends.",
        "api_signature": "qiskit_backend_overview(self, line)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/jupyter/backend_overview.py"
    },
    {
        "api_name": "__del__",
        "full_api_name": "GridBox_with_thread.__del__",
        "api_description": "Object disposal",
        "api_signature": "__del__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/jupyter/backend_overview.py"
    },
    {
        "api_name": "backend_widget",
        "full_api_name": "backend_widget",
        "api_description": "Creates a backend widget.",
        "api_signature": "backend_widget(backend)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/jupyter/backend_overview.py"
    },
    {
        "api_name": "update_backend_info",
        "full_api_name": "update_backend_info",
        "api_description": "Updates the monitor info\nCalled from another thread.",
        "api_signature": "update_backend_info(self, interval)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/jupyter/backend_overview.py"
    },
    {
        "api_name": "generate_jobs_pending_widget",
        "full_api_name": "generate_jobs_pending_widget",
        "api_description": "Generates a jobs_pending progress bar widget.",
        "api_signature": "generate_jobs_pending_widget()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/jupyter/backend_overview.py"
    },
    {
        "api_name": "_on_max_change",
        "full_api_name": "_on_max_change",
        "api_description": "",
        "api_signature": "_on_max_change(change)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/jupyter/backend_overview.py"
    },
    {
        "api_name": "_on_val_change",
        "full_api_name": "_on_val_change",
        "api_description": "",
        "api_signature": "_on_val_change(change)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/jupyter/backend_overview.py"
    },
    {
        "api_name": "monospaced_output",
        "full_api_name": "MonospacedOutput.monospaced_output",
        "api_description": "A Jupyter magic function to set \"Courier New\" for output code.",
        "api_signature": "monospaced_output(self, line, cell)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/jupyter/monospace.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "HTMLProgressBar.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/jupyter/progressbar.py"
    },
    {
        "api_name": "_init_subscriber",
        "full_api_name": "HTMLProgressBar._init_subscriber",
        "api_description": "",
        "api_signature": "_init_subscriber(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/jupyter/progressbar.py"
    },
    {
        "api_name": "_initialize_progress_bar",
        "full_api_name": "HTMLProgressBar._initialize_progress_bar",
        "api_description": "When an event of compilation starts, this function will be called, and\nwill initialize the progress bar.\n\nArgs:\n    num_tasks: Number of compilation tasks the progress bar will track",
        "api_signature": "_initialize_progress_bar(num_tasks)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/jupyter/progressbar.py"
    },
    {
        "api_name": "_update_progress_bar",
        "full_api_name": "HTMLProgressBar._update_progress_bar",
        "api_description": "When an event of compilation completes, this function will be called, and\nwill update the progress bar indication.\n\nArgs:\n    progress: Number of tasks completed",
        "api_signature": "_update_progress_bar(progress)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/jupyter/progressbar.py"
    },
    {
        "api_name": "_finish_progress_bar",
        "full_api_name": "HTMLProgressBar._finish_progress_bar",
        "api_description": "When an event of compilation finishes (meaning that there's no more circuits to\ncompile), this function will be called, unsubscribing from all events and\nfinishing the progress bar.",
        "api_signature": "_finish_progress_bar()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/jupyter/progressbar.py"
    },
    {
        "api_name": "start",
        "full_api_name": "HTMLProgressBar.start",
        "api_description": "",
        "api_signature": "start(self, iterations)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/jupyter/progressbar.py"
    },
    {
        "api_name": "update",
        "full_api_name": "HTMLProgressBar.update",
        "api_description": "",
        "api_signature": "update(self, n)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/jupyter/progressbar.py"
    },
    {
        "api_name": "finished",
        "full_api_name": "HTMLProgressBar.finished",
        "api_description": "",
        "api_signature": "finished(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/jupyter/progressbar.py"
    },
    {
        "api_name": "_html_checker",
        "full_api_name": "_html_checker",
        "api_description": "Internal function that updates the status\nof a HTML job monitor.\n\nArgs:\n    job_var (BaseJob): The job to keep track of.\n    interval (int): The status check interval\n    status (widget): HTML ipywidget for output to screen\n    header (str): String representing HTML code for status.\n    _interval_set (bool): Was interval set by user?",
        "api_signature": "_html_checker(job_var, interval, status, header, _interval_set)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/jupyter/jupyter_magics.py"
    },
    {
        "api_name": "qiskit_job_status",
        "full_api_name": "StatusMagic.qiskit_job_status",
        "api_description": "A Jupyter magic function to check the status of a Qiskit job instance.",
        "api_signature": "qiskit_job_status(self, line, cell)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/jupyter/jupyter_magics.py"
    },
    {
        "api_name": "qiskit_progress_bar",
        "full_api_name": "ProgressBarMagic.qiskit_progress_bar",
        "api_description": "A Jupyter magic function to generate progressbar.",
        "api_signature": "qiskit_progress_bar(self, line, cell)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/jupyter/jupyter_magics.py"
    },
    {
        "api_name": "circuit_library_info",
        "full_api_name": "circuit_library_info",
        "api_description": "Displays library information for a quantum circuit.\n\nArgs:\n    circuit: Input quantum circuit.",
        "api_signature": "circuit_library_info(circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/jupyter/jupyter_magics.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "JobWatcher.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/jupyter/job_watcher.py"
    },
    {
        "api_name": "refresh_viewer",
        "full_api_name": "JobWatcher.refresh_viewer",
        "api_description": "Refreshes the job viewer.",
        "api_signature": "refresh_viewer(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/jupyter/job_watcher.py"
    },
    {
        "api_name": "stop_viewer",
        "full_api_name": "JobWatcher.stop_viewer",
        "api_description": "Stops the job viewer.",
        "api_signature": "stop_viewer(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/jupyter/job_watcher.py"
    },
    {
        "api_name": "start_viewer",
        "full_api_name": "JobWatcher.start_viewer",
        "api_description": "Starts the job viewer",
        "api_signature": "start_viewer(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/jupyter/job_watcher.py"
    },
    {
        "api_name": "update_single_job",
        "full_api_name": "JobWatcher.update_single_job",
        "api_description": "Update a single job instance\n\nArgs:\n    update_info (tuple): Updated job info.",
        "api_signature": "update_single_job(self, update_info)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/jupyter/job_watcher.py"
    },
    {
        "api_name": "cancel_job",
        "full_api_name": "JobWatcher.cancel_job",
        "api_description": "Cancels a job in the watcher\n\nArgs:\n    job_id (str): Job id to remove.\n\nRaises:\n    Exception: Job id not found.",
        "api_signature": "cancel_job(self, job_id)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/jupyter/job_watcher.py"
    },
    {
        "api_name": "clear_done",
        "full_api_name": "JobWatcher.clear_done",
        "api_description": "Clears the done jobs from the list.",
        "api_signature": "clear_done(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/jupyter/job_watcher.py"
    },
    {
        "api_name": "_init_subscriber",
        "full_api_name": "JobWatcher._init_subscriber",
        "api_description": "",
        "api_signature": "_init_subscriber(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/jupyter/job_watcher.py"
    },
    {
        "api_name": "_add_job",
        "full_api_name": "JobWatcher._add_job",
        "api_description": "",
        "api_signature": "_add_job(job)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/jupyter/job_watcher.py"
    },
    {
        "api_name": "qiskit_job_watcher",
        "full_api_name": "JobWatcherMagic.qiskit_job_watcher",
        "api_description": "A Jupyter magic function to enable job watcher.",
        "api_signature": "qiskit_job_watcher(self, line, cell)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/jupyter/job_watcher.py"
    },
    {
        "api_name": "qiskit_disable_job_watcher",
        "full_api_name": "JobWatcherMagic.qiskit_disable_job_watcher",
        "api_description": "A Jupyter magic function to disable job watcher.",
        "api_signature": "qiskit_disable_job_watcher(self, line, cell)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/jupyter/job_watcher.py"
    },
    {
        "api_name": "qiskit_copyright",
        "full_api_name": "Copyright.qiskit_copyright",
        "api_description": "A Jupyter magic function return qiskit copyright",
        "api_signature": "qiskit_copyright(self, line, cell)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/jupyter/copyright.py"
    },
    {
        "api_name": "make_clear_button",
        "full_api_name": "make_clear_button",
        "api_description": "Makes the clear button\n\nArgs:\n    watcher (widget): The watcher widget instance.\n\nReturns:\n    widget: The clear button widget.",
        "api_signature": "make_clear_button(watcher)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/jupyter/job_widgets.py"
    },
    {
        "api_name": "on_clear_button_clicked",
        "full_api_name": "on_clear_button_clicked",
        "api_description": "",
        "api_signature": "on_clear_button_clicked(_)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/jupyter/job_widgets.py"
    },
    {
        "api_name": "make_labels",
        "full_api_name": "make_labels",
        "api_description": "Makes the labels widget.\n\nReturns:\n    widget: The labels widget.",
        "api_signature": "make_labels()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/jupyter/job_widgets.py"
    },
    {
        "api_name": "create_job_widget",
        "full_api_name": "create_job_widget",
        "api_description": "Creates a widget corresponding to a particular job instance.\n\nArgs:\n    watcher (widget): The job watcher instance.\n    job (IBMQJob): The job.\n    backend (str): The backend the job is running on.\n    status (str): The job status.\n    queue_pos (int): Queue position, if any.\n    msg (str): Job message, if any.\n\nReturns:\n    widget: The job widget",
        "api_signature": "create_job_widget(watcher, job, backend, status, queue_pos, msg)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/jupyter/job_widgets.py"
    },
    {
        "api_name": "cancel_on_click",
        "full_api_name": "cancel_on_click",
        "api_description": "",
        "api_signature": "cancel_on_click(_)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/jupyter/job_widgets.py"
    },
    {
        "api_name": "build_job_viewer",
        "full_api_name": "build_job_viewer",
        "api_description": "Builds the job viewer widget\n\nReturns:\n    widget: Job viewer.",
        "api_signature": "build_job_viewer()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/jupyter/job_widgets.py"
    },
    {
        "api_name": "_load_jobs_data",
        "full_api_name": "_load_jobs_data",
        "api_description": "Loads backend jobs data",
        "api_signature": "_load_jobs_data(self, change)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/jupyter/backend_monitor.py"
    },
    {
        "api_name": "_backend_monitor",
        "full_api_name": "_backend_monitor",
        "api_description": "A private function to generate a monitor widget\nfor a IBMQ backend repr.\n\nArgs:\n    backend (IBMQBackend | FakeBackend): The backend.\n\nRaises:\n    QiskitError: Input is not an IBMQBackend",
        "api_signature": "_backend_monitor(backend)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/jupyter/backend_monitor.py"
    },
    {
        "api_name": "config_tab",
        "full_api_name": "config_tab",
        "api_description": "The backend configuration widget.\n\nArgs:\n    backend (IBMQBackend | FakeBackend): The backend.\n\nReturns:\n    grid: A GridBox widget.",
        "api_signature": "config_tab(backend)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/jupyter/backend_monitor.py"
    },
    {
        "api_name": "qubits_tab",
        "full_api_name": "qubits_tab",
        "api_description": "The qubits properties widget\n\nArgs:\n    backend (IBMQBackend | FakeBackend): The backend.\n\nReturns:\n    VBox: A VBox widget.",
        "api_signature": "qubits_tab(backend)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/jupyter/backend_monitor.py"
    },
    {
        "api_name": "gates_tab",
        "full_api_name": "gates_tab",
        "api_description": "The multiple qubit gate error widget.\n\nArgs:\n    backend (IBMQBackend | FakeBackend): The backend.\n\nReturns:\n    VBox: A VBox widget.",
        "api_signature": "gates_tab(backend)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/jupyter/backend_monitor.py"
    },
    {
        "api_name": "detailed_map",
        "full_api_name": "detailed_map",
        "api_description": "Widget for displaying detailed noise map.\n\nArgs:\n    backend (IBMQBackend | FakeBackend): The backend.\n\nReturns:\n    GridBox: Widget holding noise map images.",
        "api_signature": "detailed_map(backend)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/jupyter/backend_monitor.py"
    },
    {
        "api_name": "job_history",
        "full_api_name": "job_history",
        "api_description": "Widget for displaying job history\n\nArgs:\n backend (IBMQBackend | FakeBackend): The backend.\n\nReturns:\n    Tab: A tab widget for history images.",
        "api_signature": "job_history(backend)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/jupyter/backend_monitor.py"
    },
    {
        "api_name": "_build_job_history",
        "full_api_name": "_build_job_history",
        "api_description": "",
        "api_signature": "_build_job_history(tabs, backend)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/jupyter/backend_monitor.py"
    },
    {
        "api_name": "plot_job_history",
        "full_api_name": "plot_job_history",
        "api_description": "Plots the job history of the user from the given list of jobs.\n\nArgs:\n    jobs (list): A list of jobs with type IBMQjob.\n    interval (str): Interval over which to examine.\n\nReturns:\n    fig: A Matplotlib figure instance.",
        "api_signature": "plot_job_history(jobs, interval)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/jupyter/backend_monitor.py"
    },
    {
        "api_name": "get_date",
        "full_api_name": "get_date",
        "api_description": "Returns a datetime object from a IBMQJob instance.\n\nArgs:\n    job (IBMQJob): A job.\n\nReturns:\n    dt: A datetime object.",
        "api_signature": "get_date(job)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/jupyter/backend_monitor.py"
    },
    {
        "api_name": "qiskit_version_table",
        "full_api_name": "VersionTable.qiskit_version_table",
        "api_description": "Print an HTML-formatted table with version numbers for Qiskit and its\ndependencies. This should make it possible to reproduce the environment\nand the calculation later on.",
        "api_signature": "qiskit_version_table(self, line, cell)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/jupyter/version_table.py"
    },
    {
        "api_name": "_job_monitor",
        "full_api_name": "_job_monitor",
        "api_description": "Monitor the status of a IBMQJob instance.\n\nArgs:\n    job (BaseJob): Job to monitor.\n    status (Enum): Job status.\n    watcher (JobWatcher): Job watcher instance",
        "api_signature": "_job_monitor(job, status, watcher)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/jupyter/watcher_monitor.py"
    },
    {
        "api_name": "_job_checker",
        "full_api_name": "_job_checker",
        "api_description": "A simple job status checker\n\nArgs:\n    job (BaseJob): The job to check.\n    status (Enum): Job status.\n    watcher (JobWatcher): Job watcher instance",
        "api_signature": "_job_checker(job, status, watcher)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/tools/jupyter/watcher_monitor.py"
    },
    {
        "api_name": "dagdependency_to_circuit",
        "full_api_name": "dagdependency_to_circuit",
        "api_description": "Build a ``QuantumCircuit`` object from a ``DAGDependency``.\n\nArgs:\n    dagdependency (DAGDependency): the input dag.\n\nReturn:\n    QuantumCircuit: the circuit representing the input dag dependency.",
        "api_signature": "dagdependency_to_circuit(dagdependency)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/converters/dagdependency_to_circuit.py"
    },
    {
        "api_name": "circuit_to_instruction",
        "full_api_name": "circuit_to_instruction",
        "api_description": "Build an :class:`~.circuit.Instruction` object from a :class:`.QuantumCircuit`.\n\nThe instruction is anonymous (not tied to a named quantum register),\nand so can be inserted into another circuit. The instruction will\nhave the same string name as the circuit.\n\nArgs:\n    circuit (QuantumCircuit): the input circuit.\n    parameter_map (dict): For parameterized circuits, a mapping from\n       parameters in the circuit to parameters to be used in the instruction.\n       If None, existing circuit parameters will also parameterize the\n       instruction.\n    equivalence_library (EquivalenceLibrary): Optional equivalence library\n       where the converted instruction will be registered.\n    label (str): Optional instruction label.\n\nRaises:\n    QiskitError: if parameter_map is not compatible with circuit\n\nReturn:\n    qiskit.circuit.Instruction: an instruction equivalent to the action of the\n    input circuit. Upon decomposition, this instruction will\n    yield the components comprising the original circuit.\n\nExample:\n    .. code-block::\n\n        from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit\n        from qiskit.converters import circuit_to_instruction\n\n        q = QuantumRegister(3, 'q')\n        c = ClassicalRegister(3, 'c')\n        circ = QuantumCircuit(q, c)\n        circ.h(q[0])\n        circ.cx(q[0], q[1])\n        circ.measure(q[0], c[0])\n        circ.rz(0.5, q[1]).c_if(c, 2)\n        circuit_to_instruction(circ)",
        "api_signature": "circuit_to_instruction(circuit, parameter_map, equivalence_library, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/converters/circuit_to_instruction.py"
    },
    {
        "api_name": "dagdependency_to_dag",
        "full_api_name": "dagdependency_to_dag",
        "api_description": "Build a ``DAGCircuit`` object from a ``DAGDependency``.\n\nArgs:\n    dag dependency (DAGDependency): the input dag.\n\nReturn:\n    DAGCircuit: the DAG representing the input circuit.",
        "api_signature": "dagdependency_to_dag(dagdependency)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/converters/dagdependency_to_dag.py"
    },
    {
        "api_name": "dag_to_dagdependency",
        "full_api_name": "dag_to_dagdependency",
        "api_description": "Build a ``DAGDependency`` object from a ``DAGCircuit``.\n\nArgs:\n    dag (DAGCircuit): the input dag.\n    create_preds_and_succs (bool): whether to construct lists of\n        predecessors and successors for every node.\n\nReturn:\n    DAGDependency: the DAG representing the input circuit as a dag dependency.",
        "api_signature": "dag_to_dagdependency(dag, create_preds_and_succs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/converters/dag_to_dagdependency.py"
    },
    {
        "api_name": "dag_to_circuit",
        "full_api_name": "dag_to_circuit",
        "api_description": "Build a ``QuantumCircuit`` object from a ``DAGCircuit``.\n\nArgs:\n    dag (DAGCircuit): the input dag.\n    copy_operations (bool): Deep copy the operation objects\n        in the :class:`~.DAGCircuit` for the output :class:`~.QuantumCircuit`.\n        This should only be set to ``False`` if the input :class:`~.DAGCircuit`\n        will not be used anymore as the operations in the output\n        :class:`~.QuantumCircuit` will be shared instances and\n        modifications to operations in the :class:`~.DAGCircuit` will\n        be reflected in the :class:`~.QuantumCircuit` (and vice versa).\n\nReturn:\n    QuantumCircuit: the circuit representing the input dag.\n\nExample:\n    .. plot::\n       :include-source:\n\n       from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit\n       from qiskit.dagcircuit import DAGCircuit\n       from qiskit.converters import circuit_to_dag\n       from qiskit.circuit.library.standard_gates import CHGate, U2Gate, CXGate\n       from qiskit.converters import dag_to_circuit\n\n       q = QuantumRegister(3, 'q')\n       c = ClassicalRegister(3, 'c')\n       circ = QuantumCircuit(q, c)\n       circ.h(q[0])\n       circ.cx(q[0], q[1])\n       circ.measure(q[0], c[0])\n       circ.rz(0.5, q[1]).c_if(c, 2)\n       dag = circuit_to_dag(circ)\n       circuit = dag_to_circuit(dag)\n       circuit.draw('mpl')",
        "api_signature": "dag_to_circuit(dag, copy_operations)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/converters/dag_to_circuit.py"
    },
    {
        "api_name": "_check_is_gate",
        "full_api_name": "_check_is_gate",
        "api_description": "Checks whether op can be converted to Gate.",
        "api_signature": "_check_is_gate(op)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/converters/circuit_to_gate.py"
    },
    {
        "api_name": "circuit_to_gate",
        "full_api_name": "circuit_to_gate",
        "api_description": "Build a :class:`.Gate` object from a :class:`.QuantumCircuit`.\n\nThe gate is anonymous (not tied to a named quantum register),\nand so can be inserted into another circuit. The gate will\nhave the same string name as the circuit.\n\nArgs:\n    circuit (QuantumCircuit): the input circuit.\n    parameter_map (dict): For parameterized circuits, a mapping from\n       parameters in the circuit to parameters to be used in the gate.\n       If None, existing circuit parameters will also parameterize the\n       Gate.\n    equivalence_library (EquivalenceLibrary): Optional equivalence library\n       where the converted gate will be registered.\n    label (str): Optional gate label.\n\nRaises:\n    QiskitError: if circuit is non-unitary or if\n        parameter_map is not compatible with circuit\n\nReturn:\n    Gate: a Gate equivalent to the action of the\n    input circuit. Upon decomposition, this gate will\n    yield the components comprising the original circuit.",
        "api_signature": "circuit_to_gate(circuit, parameter_map, equivalence_library, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/converters/circuit_to_gate.py"
    },
    {
        "api_name": "ast_to_dag",
        "full_api_name": "ast_to_dag",
        "api_description": "Build a ``DAGCircuit`` object from an AST ``Node`` object.\n\nArgs:\n    ast (Program): a Program Node of an AST (parser's output)\n\nReturn:\n    DAGCircuit: the DAG representing an OpenQASM's AST\n\nRaises:\n    QiskitError: if the AST is malformed.\n\nExample:\n    .. code-block::\n\n        from qiskit.converters import ast_to_dag\n        from qiskit import qasm, QuantumCircuit, ClassicalRegister, QuantumRegister\n\n        q = QuantumRegister(3, 'q')\n        c = ClassicalRegister(3, 'c')\n        circ = QuantumCircuit(q, c)\n        circ.h(q[0])\n        circ.cx(q[0], q[1])\n        circ.measure(q[0], c[0])\n        circ.rz(0.5, q[1]).c_if(c, 2)\n        qasm_str = circ.qasm()\n        ast = qasm.Qasm(data=qasm_str).parse()\n        dag = ast_to_dag(ast)",
        "api_signature": "ast_to_dag(ast)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/converters/ast_to_dag.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "AstInterpreter.__init__",
        "api_description": "Initialize interpreter's data.",
        "api_signature": "__init__(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/converters/ast_to_dag.py"
    },
    {
        "api_name": "_process_bit_id",
        "full_api_name": "AstInterpreter._process_bit_id",
        "api_description": "Process an Id or IndexedId node as a bit or register type.\n\nReturn a list of tuples (Register,index).",
        "api_signature": "_process_bit_id(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/converters/ast_to_dag.py"
    },
    {
        "api_name": "_process_custom_unitary",
        "full_api_name": "AstInterpreter._process_custom_unitary",
        "api_description": "Process a custom unitary node.",
        "api_signature": "_process_custom_unitary(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/converters/ast_to_dag.py"
    },
    {
        "api_name": "_process_u",
        "full_api_name": "AstInterpreter._process_u",
        "api_description": "Process a U gate node.",
        "api_signature": "_process_u(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/converters/ast_to_dag.py"
    },
    {
        "api_name": "_arguments",
        "full_api_name": "AstInterpreter._arguments",
        "api_description": "",
        "api_signature": "_arguments(self, name, bits, args)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/converters/ast_to_dag.py"
    },
    {
        "api_name": "_process_gate",
        "full_api_name": "AstInterpreter._process_gate",
        "api_description": "Process a gate node.\n\nIf opaque is True, process the node as an opaque gate node.",
        "api_signature": "_process_gate(self, node, opaque)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/converters/ast_to_dag.py"
    },
    {
        "api_name": "_process_cnot",
        "full_api_name": "AstInterpreter._process_cnot",
        "api_description": "Process a CNOT gate node.",
        "api_signature": "_process_cnot(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/converters/ast_to_dag.py"
    },
    {
        "api_name": "_process_measure",
        "full_api_name": "AstInterpreter._process_measure",
        "api_description": "Process a measurement node.",
        "api_signature": "_process_measure(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/converters/ast_to_dag.py"
    },
    {
        "api_name": "_process_if",
        "full_api_name": "AstInterpreter._process_if",
        "api_description": "Process an if node.",
        "api_signature": "_process_if(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/converters/ast_to_dag.py"
    },
    {
        "api_name": "_process_children",
        "full_api_name": "AstInterpreter._process_children",
        "api_description": "Call process_node for all children of node.",
        "api_signature": "_process_children(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/converters/ast_to_dag.py"
    },
    {
        "api_name": "_process_node",
        "full_api_name": "AstInterpreter._process_node",
        "api_description": "Carry out the action associated with a node.",
        "api_signature": "_process_node(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/converters/ast_to_dag.py"
    },
    {
        "api_name": "_gate_rules_to_qiskit_circuit",
        "full_api_name": "AstInterpreter._gate_rules_to_qiskit_circuit",
        "api_description": "From a gate definition in OpenQASM, to a QuantumCircuit format.",
        "api_signature": "_gate_rules_to_qiskit_circuit(self, node, params)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/converters/ast_to_dag.py"
    },
    {
        "api_name": "_create_dag_op",
        "full_api_name": "AstInterpreter._create_dag_op",
        "api_description": "Create a DAG node out of a parsed AST op node.\n\nArgs:\n    name (str): operation name to apply to the DAG\n    params (list): op parameters\n    qargs (list(Qubit)): qubits to attach to\n\nRaises:\n    QiskitError: if encountering a non-basis opaque gate",
        "api_signature": "_create_dag_op(self, name, params, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/converters/ast_to_dag.py"
    },
    {
        "api_name": "_create_op",
        "full_api_name": "AstInterpreter._create_op",
        "api_description": "",
        "api_signature": "_create_op(self, name, params)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/converters/ast_to_dag.py"
    },
    {
        "api_name": "circuit_to_dagdependency",
        "full_api_name": "circuit_to_dagdependency",
        "api_description": "Build a ``DAGDependency`` object from a :class:`~.QuantumCircuit`.\n\nArgs:\n    circuit (QuantumCircuit): the input circuit.\n    create_preds_and_succs (bool): whether to construct lists of\n        predecessors and successors for every node.\n\nReturn:\n    DAGDependency: the DAG representing the input circuit as a dag dependency.",
        "api_signature": "circuit_to_dagdependency(circuit, create_preds_and_succs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/converters/circuit_to_dagdependency.py"
    },
    {
        "api_name": "isinstanceint",
        "full_api_name": "isinstanceint",
        "api_description": "Like isinstance(obj,int), but with casting. Except for strings.",
        "api_signature": "isinstanceint(obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/converters/__init__.py"
    },
    {
        "api_name": "isinstancelist",
        "full_api_name": "isinstancelist",
        "api_description": "Like isinstance(obj, list), but with casting. Except for strings and dicts.",
        "api_signature": "isinstancelist(obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/converters/__init__.py"
    },
    {
        "api_name": "circuit_to_dag",
        "full_api_name": "circuit_to_dag",
        "api_description": "Build a :class:`.DAGCircuit` object from a :class:`.QuantumCircuit`.\n\nArgs:\n    circuit (QuantumCircuit): the input circuit.\n    copy_operations (bool): Deep copy the operation objects\n        in the :class:`~.QuantumCircuit` for the output :class:`~.DAGCircuit`.\n        This should only be set to ``False`` if the input :class:`~.QuantumCircuit`\n        will not be used anymore as the operations in the output\n        :class:`~.DAGCircuit` will be shared instances and modifications to\n        operations in the :class:`~.DAGCircuit` will be reflected in the\n        :class:`~.QuantumCircuit` (and vice versa).\n    qubit_order (Iterable[Qubit] or None): the order that the qubits should be indexed in the\n        output DAG.  Defaults to the same order as in the circuit.\n    clbit_order (Iterable[Clbit] or None): the order that the clbits should be indexed in the\n        output DAG.  Defaults to the same order as in the circuit.\n\nReturn:\n    DAGCircuit: the DAG representing the input circuit.\n\nRaises:\n    ValueError: if the ``qubit_order`` or ``clbit_order`` parameters do not match the bits in\n        the circuit.\n\nExample:\n    .. code-block::\n\n        from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit\n        from qiskit.dagcircuit import DAGCircuit\n        from qiskit.converters import circuit_to_dag\n\n        q = QuantumRegister(3, 'q')\n        c = ClassicalRegister(3, 'c')\n        circ = QuantumCircuit(q, c)\n        circ.h(q[0])\n        circ.cx(q[0], q[1])\n        circ.measure(q[0], c[0])\n        circ.rz(0.5, q[1]).c_if(c, 2)\n        dag = circuit_to_dag(circ)",
        "api_signature": "circuit_to_dag(circuit, copy_operations)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/converters/circuit_to_dag.py"
    },
    {
        "api_name": "read_generic_typed_data",
        "full_api_name": "read_generic_typed_data",
        "api_description": "Read a single data chunk from the file like object.\n\nArgs:\n    file_obj (File): A file like object that contains the QPY binary data.\n\nReturns:\n    tuple: Tuple of type key binary and the bytes object of the single data.",
        "api_signature": "read_generic_typed_data(file_obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/common.py"
    },
    {
        "api_name": "read_sequence",
        "full_api_name": "read_sequence",
        "api_description": "Read a sequence of data from the file like object.\n\nArgs:\n    file_obj (File): A file like object that contains the QPY binary data.\n    deserializer (Callable): Deserializer callback that can handle input object type.\n        This must take type key and binary data of the element and return object.\n    kwargs: Options set to the deserializer.\n\nReturns:\n    list: Deserialized object.",
        "api_signature": "read_sequence(file_obj, deserializer)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/common.py"
    },
    {
        "api_name": "read_mapping",
        "full_api_name": "read_mapping",
        "api_description": "Read a mapping from the file like object.\n\n.. note::\n\n    This function must be used to make a binary data of mapping\n    which include QPY serialized values.\n    It's easier to use JSON serializer followed by encoding for standard data formats.\n    This only supports flat dictionary and key must be string.\n\nArgs:\n    file_obj (File): A file like object that contains the QPY binary data.\n    deserializer (Callable): Deserializer callback that can handle mapping item.\n        This must take type key and binary data of the mapping value and return object.\n    kwargs: Options set to the deserializer.\n\nReturns:\n    dict: Deserialized object.",
        "api_signature": "read_mapping(file_obj, deserializer)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/common.py"
    },
    {
        "api_name": "read_type_key",
        "full_api_name": "read_type_key",
        "api_description": "Read a type key from the file like object.\n\nArgs:\n    file_obj (File): A file like object that contains the QPY binary data.\n\nReturns:\n    bytes: Type key.",
        "api_signature": "read_type_key(file_obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/common.py"
    },
    {
        "api_name": "write_generic_typed_data",
        "full_api_name": "write_generic_typed_data",
        "api_description": "Write statically typed binary data to the file like object.\n\nArgs:\n    file_obj (File): A file like object to write data.\n    type_key (Enum): Object type of the data.\n    data_binary (bytes): Binary data to write.",
        "api_signature": "write_generic_typed_data(file_obj, type_key, data_binary)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/common.py"
    },
    {
        "api_name": "write_sequence",
        "full_api_name": "write_sequence",
        "api_description": "Write a sequence of data in the file like object.\n\nArgs:\n    file_obj (File): A file like object to write data.\n    sequence (Sequence): Object to serialize.\n    serializer (Callable): Serializer callback that can handle input object type.\n        This must return type key and binary data of each element.\n    kwargs: Options set to the serializer.",
        "api_signature": "write_sequence(file_obj, sequence, serializer)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/common.py"
    },
    {
        "api_name": "write_mapping",
        "full_api_name": "write_mapping",
        "api_description": "Write a mapping in the file like object.\n\n.. note::\n\n    This function must be used to make a binary data of mapping\n    which include QPY serialized values.\n    It's easier to use JSON serializer followed by encoding for standard data formats.\n    This only supports flat dictionary and key must be string.\n\nArgs:\n    file_obj (File): A file like object to write data.\n    mapping (Mapping): Object to serialize.\n    serializer (Callable): Serializer callback that can handle mapping item.\n        This must return type key and binary data of the mapping value.\n    kwargs: Options set to the serializer.",
        "api_signature": "write_mapping(file_obj, mapping, serializer)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/common.py"
    },
    {
        "api_name": "write_type_key",
        "full_api_name": "write_type_key",
        "api_description": "Write a type key in the file like object.\n\nArgs:\n    file_obj (File): A file like object that contains the QPY binary data.\n    type_key (bytes): Type key to write.",
        "api_signature": "write_type_key(file_obj, type_key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/common.py"
    },
    {
        "api_name": "data_to_binary",
        "full_api_name": "data_to_binary",
        "api_description": "Convert object into binary data with specified serializer.\n\nArgs:\n    obj (any): Object to serialize.\n    serializer (Callable): Serializer callback that can handle input object type.\n    kwargs: Options set to the serializer.\n\nReturns:\n    bytes: Binary data.",
        "api_signature": "data_to_binary(obj, serializer)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/common.py"
    },
    {
        "api_name": "sequence_to_binary",
        "full_api_name": "sequence_to_binary",
        "api_description": "Convert sequence into binary data with specified serializer.\n\nArgs:\n    sequence (Sequence): Object to serialize.\n    serializer (Callable): Serializer callback that can handle input object type.\n        This must return type key and binary data of each element.\n    kwargs: Options set to the serializer.\n\nReturns:\n    bytes: Binary data.",
        "api_signature": "sequence_to_binary(sequence, serializer)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/common.py"
    },
    {
        "api_name": "mapping_to_binary",
        "full_api_name": "mapping_to_binary",
        "api_description": "Convert mapping into binary data with specified serializer.\n\n.. note::\n\n    This function must be used to make a binary data of mapping\n    which include QPY serialized values.\n    It's easier to use JSON serializer followed by encoding for standard data formats.\n    This only supports flat dictionary and key must be string.\n\nArgs:\n    mapping (Mapping): Object to serialize.\n    serializer (Callable): Serializer callback that can handle mapping item.\n        This must return type key and binary data of the mapping value.\n    kwargs: Options set to the serializer.\n\nReturns:\n    bytes: Binary data.",
        "api_signature": "mapping_to_binary(mapping, serializer)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/common.py"
    },
    {
        "api_name": "data_from_binary",
        "full_api_name": "data_from_binary",
        "api_description": "Load object from binary data with specified deserializer.\n\nArgs:\n    binary_data (bytes): Binary data to deserialize.\n    deserializer (Callable): Deserializer callback that can handle input object type.\n    kwargs: Options set to the deserializer.\n\nReturns:\n    any: Deserialized object.",
        "api_signature": "data_from_binary(binary_data, deserializer)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/common.py"
    },
    {
        "api_name": "sequence_from_binary",
        "full_api_name": "sequence_from_binary",
        "api_description": "Load object from binary sequence with specified deserializer.\n\nArgs:\n    binary_data (bytes): Binary data to deserialize.\n    deserializer (Callable): Deserializer callback that can handle input object type.\n        This must take type key and binary data of the element and return object.\n    kwargs: Options set to the deserializer.\n\nReturns:\n    any: Deserialized sequence.",
        "api_signature": "sequence_from_binary(binary_data, deserializer)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/common.py"
    },
    {
        "api_name": "mapping_from_binary",
        "full_api_name": "mapping_from_binary",
        "api_description": "Load object from binary mapping with specified deserializer.\n\n.. note::\n\n    This function must be used to make a binary data of mapping\n    which include QPY serialized values.\n    It's easier to use JSON serializer followed by encoding for standard data formats.\n    This only supports flat dictionary and key must be string.\n\nArgs:\n    binary_data (bytes): Binary data to deserialize.\n    deserializer (Callable): Deserializer callback that can handle mapping item.\n        This must take type key and binary data of the mapping value and return object.\n    kwargs: Options set to the deserializer.\n\nReturns:\n    dict: Deserialized object.",
        "api_signature": "mapping_from_binary(binary_data, deserializer)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/common.py"
    },
    {
        "api_name": "dump",
        "full_api_name": "dump",
        "api_description": "Write QPY binary data to a file\n\nThis function is used to save a circuit to a file for later use or transfer\nbetween machines. The QPY format is backwards compatible and can be\nloaded with future versions of Qiskit.\n\nFor example:\n\n.. code-block:: python\n\n    from qiskit.circuit import QuantumCircuit\n    from qiskit import qpy\n\n    qc = QuantumCircuit(2, name='Bell', metadata={'test': True})\n    qc.h(0)\n    qc.cx(0, 1)\n    qc.measure_all()\n\nfrom this you can write the qpy data to a file:\n\n.. code-block:: python\n\n    with open('bell.qpy', 'wb') as fd:\n        qpy.dump(qc, fd)\n\nor a gzip compressed file:\n\n.. code-block:: python\n\n    import gzip\n\n    with gzip.open('bell.qpy.gz', 'wb') as fd:\n        qpy.dump(qc, fd)\n\nWhich will save the qpy serialized circuit to the provided file.\n\nArgs:\n    programs: QPY supported object(s) to store in the specified file like object.\n        QPY supports :class:`.QuantumCircuit` and :class:`.ScheduleBlock`.\n        Different data types must be separately serialized.\n    file_obj: The file like object to write the QPY data too\n    metadata_serializer: An optional JSONEncoder class that\n        will be passed the ``.metadata`` attribute for each program in ``programs`` and will be\n        used as the ``cls`` kwarg on the `json.dump()`` call to JSON serialize that dictionary.\n    use_symengine: If True, all objects containing symbolic expressions will be serialized\n        using symengine's native mechanism. This is a faster serialization alternative,\n        but not supported in all platforms. Please check that your target platform is supported\n        by the symengine library before setting this option, as it will be required by qpy to\n        deserialize the payload. For this reason, the option defaults to False.\nRaises:\n    QpyError: When multiple data format is mixed in the output.\n    TypeError: When invalid data type is input.",
        "api_signature": "dump(programs, file_obj, metadata_serializer, use_symengine)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/interface.py"
    },
    {
        "api_name": "load",
        "full_api_name": "load",
        "api_description": "Load a QPY binary file\n\nThis function is used to load a serialized QPY Qiskit program file and create\n:class:`~qiskit.circuit.QuantumCircuit` objects or\n:class:`~qiskit.pulse.schedule.ScheduleBlock` objects from its contents.\nFor example:\n\n.. code-block:: python\n\n    from qiskit import qpy\n\n    with open('bell.qpy', 'rb') as fd:\n        circuits = qpy.load(fd)\n\nor with a gzip compressed file:\n\n.. code-block:: python\n\n    import gzip\n    from qiskit import qpy\n\n    with gzip.open('bell.qpy.gz', 'rb') as fd:\n        circuits = qpy.load(fd)\n\nwhich will read the contents of the qpy and return a list of\n:class:`~qiskit.circuit.QuantumCircuit` objects or\n:class:`~qiskit.pulse.schedule.ScheduleBlock` objects from the file.\n\nArgs:\n    file_obj: A file like object that contains the QPY binary\n        data for a circuit or pulse schedule.\n    metadata_deserializer: An optional JSONDecoder class\n        that will be used for the ``cls`` kwarg on the internal\n        ``json.load`` call used to deserialize the JSON payload used for\n        the ``.metadata`` attribute for any programs in the QPY file.\n        If this is not specified the circuit metadata will\n        be parsed as JSON with the stdlib ``json.load()`` function using\n        the default ``JSONDecoder`` class.\n\nReturns:\n    The list of Qiskit programs contained in the QPY data.\n    A list is always returned, even if there is only 1 program in the QPY data.\n\nRaises:\n    QiskitError: if ``file_obj`` is not a valid QPY file\n    TypeError: When invalid data type is loaded.",
        "api_signature": "load(file_obj, metadata_deserializer)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/interface.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QpyError.__init__",
        "api_description": "Set the error message.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/exceptions.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "QpyError.__str__",
        "api_description": "Return the message.",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/exceptions.py"
    },
    {
        "api_name": "assign",
        "full_api_name": "TypeKeyBase.assign",
        "api_description": "Assign type key to given object.\n\nArgs:\n    obj (any): Arbitrary object to evaluate.\n\nReturns:\n    TypeKey: Corresponding key object.",
        "api_signature": "assign(cls, obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/type_keys.py"
    },
    {
        "api_name": "retrieve",
        "full_api_name": "TypeKeyBase.retrieve",
        "api_description": "Get a class from given type key.\n\nArgs:\n    type_key (bytes): Object type key.\n\nReturns:\n    any: Corresponding class.",
        "api_signature": "retrieve(cls, type_key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/type_keys.py"
    },
    {
        "api_name": "assign",
        "full_api_name": "Value.assign",
        "api_description": "",
        "api_signature": "assign(cls, obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/type_keys.py"
    },
    {
        "api_name": "retrieve",
        "full_api_name": "Value.retrieve",
        "api_description": "",
        "api_signature": "retrieve(cls, type_key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/type_keys.py"
    },
    {
        "api_name": "assign",
        "full_api_name": "Container.assign",
        "api_description": "",
        "api_signature": "assign(cls, obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/type_keys.py"
    },
    {
        "api_name": "retrieve",
        "full_api_name": "Container.retrieve",
        "api_description": "",
        "api_signature": "retrieve(cls, type_key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/type_keys.py"
    },
    {
        "api_name": "assign",
        "full_api_name": "CircuitInstruction.assign",
        "api_description": "",
        "api_signature": "assign(cls, obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/type_keys.py"
    },
    {
        "api_name": "retrieve",
        "full_api_name": "CircuitInstruction.retrieve",
        "api_description": "",
        "api_signature": "retrieve(cls, type_key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/type_keys.py"
    },
    {
        "api_name": "assign",
        "full_api_name": "ScheduleAlignment.assign",
        "api_description": "",
        "api_signature": "assign(cls, obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/type_keys.py"
    },
    {
        "api_name": "retrieve",
        "full_api_name": "ScheduleAlignment.retrieve",
        "api_description": "",
        "api_signature": "retrieve(cls, type_key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/type_keys.py"
    },
    {
        "api_name": "assign",
        "full_api_name": "ScheduleInstruction.assign",
        "api_description": "",
        "api_signature": "assign(cls, obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/type_keys.py"
    },
    {
        "api_name": "retrieve",
        "full_api_name": "ScheduleInstruction.retrieve",
        "api_description": "",
        "api_signature": "retrieve(cls, type_key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/type_keys.py"
    },
    {
        "api_name": "assign",
        "full_api_name": "ScheduleOperand.assign",
        "api_description": "",
        "api_signature": "assign(cls, obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/type_keys.py"
    },
    {
        "api_name": "retrieve",
        "full_api_name": "ScheduleOperand.retrieve",
        "api_description": "",
        "api_signature": "retrieve(cls, type_key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/type_keys.py"
    },
    {
        "api_name": "assign",
        "full_api_name": "ScheduleChannel.assign",
        "api_description": "",
        "api_signature": "assign(cls, obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/type_keys.py"
    },
    {
        "api_name": "retrieve",
        "full_api_name": "ScheduleChannel.retrieve",
        "api_description": "",
        "api_signature": "retrieve(cls, type_key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/type_keys.py"
    },
    {
        "api_name": "assign",
        "full_api_name": "Program.assign",
        "api_description": "",
        "api_signature": "assign(cls, obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/type_keys.py"
    },
    {
        "api_name": "retrieve",
        "full_api_name": "Program.retrieve",
        "api_description": "",
        "api_signature": "retrieve(cls, type_key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/type_keys.py"
    },
    {
        "api_name": "assign",
        "full_api_name": "Expression.assign",
        "api_description": "",
        "api_signature": "assign(cls, obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/type_keys.py"
    },
    {
        "api_name": "retrieve",
        "full_api_name": "Expression.retrieve",
        "api_description": "",
        "api_signature": "retrieve(cls, type_key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/type_keys.py"
    },
    {
        "api_name": "assign",
        "full_api_name": "ExprType.assign",
        "api_description": "",
        "api_signature": "assign(cls, obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/type_keys.py"
    },
    {
        "api_name": "retrieve",
        "full_api_name": "ExprType.retrieve",
        "api_description": "",
        "api_signature": "retrieve(cls, type_key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/type_keys.py"
    },
    {
        "api_name": "assign",
        "full_api_name": "ExprVar.assign",
        "api_description": "",
        "api_signature": "assign(cls, obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/type_keys.py"
    },
    {
        "api_name": "retrieve",
        "full_api_name": "ExprVar.retrieve",
        "api_description": "",
        "api_signature": "retrieve(cls, type_key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/type_keys.py"
    },
    {
        "api_name": "assign",
        "full_api_name": "ExprValue.assign",
        "api_description": "",
        "api_signature": "assign(cls, obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/type_keys.py"
    },
    {
        "api_name": "retrieve",
        "full_api_name": "ExprValue.retrieve",
        "api_description": "",
        "api_signature": "retrieve(cls, type_key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/type_keys.py"
    },
    {
        "api_name": "assign",
        "full_api_name": "SymExprEncoding.assign",
        "api_description": "",
        "api_signature": "assign(cls, obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/type_keys.py"
    },
    {
        "api_name": "retrieve",
        "full_api_name": "SymExprEncoding.retrieve",
        "api_description": "",
        "api_signature": "retrieve(cls, type_key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/type_keys.py"
    },
    {
        "api_name": "_write_parameter",
        "full_api_name": "_write_parameter",
        "api_description": "",
        "api_signature": "_write_parameter(file_obj, obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/value.py"
    },
    {
        "api_name": "_write_parameter_vec",
        "full_api_name": "_write_parameter_vec",
        "api_description": "",
        "api_signature": "_write_parameter_vec(file_obj, obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/value.py"
    },
    {
        "api_name": "_write_parameter_expression",
        "full_api_name": "_write_parameter_expression",
        "api_description": "",
        "api_signature": "_write_parameter_expression(file_obj, obj, use_symengine)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/value.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "_ExprWriter.__init__",
        "api_description": "",
        "api_signature": "__init__(self, file_obj, clbit_indices)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/value.py"
    },
    {
        "api_name": "visit_generic",
        "full_api_name": "_ExprWriter.visit_generic",
        "api_description": "",
        "api_signature": "visit_generic()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/value.py"
    },
    {
        "api_name": "visit_var",
        "full_api_name": "_ExprWriter.visit_var",
        "api_description": "",
        "api_signature": "visit_var()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/value.py"
    },
    {
        "api_name": "visit_value",
        "full_api_name": "_ExprWriter.visit_value",
        "api_description": "",
        "api_signature": "visit_value()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/value.py"
    },
    {
        "api_name": "visit_cast",
        "full_api_name": "_ExprWriter.visit_cast",
        "api_description": "",
        "api_signature": "visit_cast()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/value.py"
    },
    {
        "api_name": "visit_unary",
        "full_api_name": "_ExprWriter.visit_unary",
        "api_description": "",
        "api_signature": "visit_unary()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/value.py"
    },
    {
        "api_name": "visit_binary",
        "full_api_name": "_ExprWriter.visit_binary",
        "api_description": "",
        "api_signature": "visit_binary()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/value.py"
    },
    {
        "api_name": "_write_expr",
        "full_api_name": "_write_expr",
        "api_description": "",
        "api_signature": "_write_expr(file_obj, node, clbit_indices)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/value.py"
    },
    {
        "api_name": "_write_expr_type",
        "full_api_name": "_write_expr_type",
        "api_description": "",
        "api_signature": "_write_expr_type(file_obj, type_)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/value.py"
    },
    {
        "api_name": "_read_parameter",
        "full_api_name": "_read_parameter",
        "api_description": "",
        "api_signature": "_read_parameter(file_obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/value.py"
    },
    {
        "api_name": "_read_parameter_vec",
        "full_api_name": "_read_parameter_vec",
        "api_description": "",
        "api_signature": "_read_parameter_vec(file_obj, vectors)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/value.py"
    },
    {
        "api_name": "_read_parameter_expression",
        "full_api_name": "_read_parameter_expression",
        "api_description": "",
        "api_signature": "_read_parameter_expression(file_obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/value.py"
    },
    {
        "api_name": "_read_parameter_expression_v3",
        "full_api_name": "_read_parameter_expression_v3",
        "api_description": "",
        "api_signature": "_read_parameter_expression_v3(file_obj, vectors, use_symengine)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/value.py"
    },
    {
        "api_name": "_read_expr",
        "full_api_name": "_read_expr",
        "api_description": "",
        "api_signature": "_read_expr(file_obj, clbits, cregs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/value.py"
    },
    {
        "api_name": "_read_expr_type",
        "full_api_name": "_read_expr_type",
        "api_description": "",
        "api_signature": "_read_expr_type(file_obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/value.py"
    },
    {
        "api_name": "dumps_value",
        "full_api_name": "dumps_value",
        "api_description": "Serialize input value object.\n\nArgs:\n    obj (any): Arbitrary value object to serialize.\n    index_map (dict): Dictionary with two keys, \"q\" and \"c\".  Each key has a value that is a\n        dictionary mapping :class:`.Qubit` or :class:`.Clbit` instances (respectively) to their\n        integer indices.\n    use_symengine (bool): If True, symbolic objects will be serialized using symengine's\n        native mechanism. This is a faster serialization alternative, but not supported in all\n        platforms. Please check that your target platform is supported by the symengine library\n        before setting this option, as it will be required by qpy to deserialize the payload.\n\nReturns:\n    tuple: TypeKey and binary data.\n\nRaises:\n    QpyError: Serializer for given format is not ready.",
        "api_signature": "dumps_value(obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/value.py"
    },
    {
        "api_name": "write_value",
        "full_api_name": "write_value",
        "api_description": "Write a value to the file like object.\n\nArgs:\n    file_obj (File): A file like object to write data.\n    obj (any): Value to write.\n    index_map (dict): Dictionary with two keys, \"q\" and \"c\".  Each key has a value that is a\n        dictionary mapping :class:`.Qubit` or :class:`.Clbit` instances (respectively) to their\n        integer indices.\n    use_symengine (bool): If True, symbolic objects will be serialized using symengine's\n        native mechanism. This is a faster serialization alternative, but not supported in all\n        platforms. Please check that your target platform is supported by the symengine library\n        before setting this option, as it will be required by qpy to deserialize the payload.",
        "api_signature": "write_value(file_obj, obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/value.py"
    },
    {
        "api_name": "loads_value",
        "full_api_name": "loads_value",
        "api_description": "Deserialize input binary data to value object.\n\nArgs:\n    type_key (ValueTypeKey): Type enum information.\n    binary_data (bytes): Data to deserialize.\n    version (int): QPY version.\n    vectors (dict): ParameterVector in current scope.\n    clbits (Sequence[Clbit]): Clbits in the current scope.\n    cregs (Mapping[str, ClassicalRegister]): Classical registers in the current scope.\n    use_symengine (bool): If True, symbolic objects will be de-serialized using symengine's\n        native mechanism. This is a faster serialization alternative, but not supported in all\n        platforms. Please check that your target platform is supported by the symengine library\n        before setting this option, as it will be required by qpy to deserialize the payload.\n\nReturns:\n    any: Deserialized value object.\n\nRaises:\n    QpyError: Serializer for given format is not ready.",
        "api_signature": "loads_value(type_key, binary_data, version, vectors)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/value.py"
    },
    {
        "api_name": "read_value",
        "full_api_name": "read_value",
        "api_description": "Read a value from the file like object.\n\nArgs:\n    file_obj (File): A file like object to write data.\n    version (int): QPY version.\n    vectors (dict): ParameterVector in current scope.\n    clbits (Sequence[Clbit]): Clbits in the current scope.\n    cregs (Mapping[str, ClassicalRegister]): Classical registers in the current scope.\n    use_symengine (bool): If True, symbolic objects will be de-serialized using symengine's\n        native mechanism. This is a faster serialization alternative, but not supported in all\n        platforms. Please check that your target platform is supported by the symengine library\n        before setting this option, as it will be required by qpy to deserialize the payload.\n\nReturns:\n    any: Deserialized value object.",
        "api_signature": "read_value(file_obj, version, vectors)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/value.py"
    },
    {
        "api_name": "_read_header_v2",
        "full_api_name": "_read_header_v2",
        "api_description": "",
        "api_signature": "_read_header_v2(file_obj, version, vectors, metadata_deserializer)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/circuits.py"
    },
    {
        "api_name": "_read_header",
        "full_api_name": "_read_header",
        "api_description": "",
        "api_signature": "_read_header(file_obj, metadata_deserializer)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/circuits.py"
    },
    {
        "api_name": "_read_registers_v4",
        "full_api_name": "_read_registers_v4",
        "api_description": "",
        "api_signature": "_read_registers_v4(file_obj, num_registers)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/circuits.py"
    },
    {
        "api_name": "_read_registers",
        "full_api_name": "_read_registers",
        "api_description": "",
        "api_signature": "_read_registers(file_obj, num_registers)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/circuits.py"
    },
    {
        "api_name": "_loads_instruction_parameter",
        "full_api_name": "_loads_instruction_parameter",
        "api_description": "",
        "api_signature": "_loads_instruction_parameter(type_key, data_bytes, version, vectors, registers, circuit, use_symengine)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/circuits.py"
    },
    {
        "api_name": "_loads_register_param",
        "full_api_name": "_loads_register_param",
        "api_description": "",
        "api_signature": "_loads_register_param(data_bytes, circuit, registers)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/circuits.py"
    },
    {
        "api_name": "_read_instruction",
        "full_api_name": "_read_instruction",
        "api_description": "",
        "api_signature": "_read_instruction(file_obj, circuit, registers, custom_operations, version, vectors, use_symengine)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/circuits.py"
    },
    {
        "api_name": "_parse_custom_operation",
        "full_api_name": "_parse_custom_operation",
        "api_description": "",
        "api_signature": "_parse_custom_operation(custom_operations, gate_name, params, version, vectors, registers, use_symengine)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/circuits.py"
    },
    {
        "api_name": "_read_pauli_evolution_gate",
        "full_api_name": "_read_pauli_evolution_gate",
        "api_description": "",
        "api_signature": "_read_pauli_evolution_gate(file_obj, version, vectors)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/circuits.py"
    },
    {
        "api_name": "_read_custom_operations",
        "full_api_name": "_read_custom_operations",
        "api_description": "",
        "api_signature": "_read_custom_operations(file_obj, version, vectors)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/circuits.py"
    },
    {
        "api_name": "_read_calibrations",
        "full_api_name": "_read_calibrations",
        "api_description": "",
        "api_signature": "_read_calibrations(file_obj, version, vectors, metadata_deserializer)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/circuits.py"
    },
    {
        "api_name": "_dumps_register",
        "full_api_name": "_dumps_register",
        "api_description": "",
        "api_signature": "_dumps_register(register, index_map)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/circuits.py"
    },
    {
        "api_name": "_dumps_instruction_parameter",
        "full_api_name": "_dumps_instruction_parameter",
        "api_description": "",
        "api_signature": "_dumps_instruction_parameter(param, index_map, use_symengine)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/circuits.py"
    },
    {
        "api_name": "_write_instruction",
        "full_api_name": "_write_instruction",
        "api_description": "",
        "api_signature": "_write_instruction(file_obj, instruction, custom_operations, index_map, use_symengine)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/circuits.py"
    },
    {
        "api_name": "_write_pauli_evolution_gate",
        "full_api_name": "_write_pauli_evolution_gate",
        "api_description": "",
        "api_signature": "_write_pauli_evolution_gate(file_obj, evolution_gate)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/circuits.py"
    },
    {
        "api_name": "_write_elem",
        "full_api_name": "_write_elem",
        "api_description": "",
        "api_signature": "_write_elem(buffer, op)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/circuits.py"
    },
    {
        "api_name": "_write_custom_operation",
        "full_api_name": "_write_custom_operation",
        "api_description": "",
        "api_signature": "_write_custom_operation(file_obj, name, operation, custom_operations, use_symengine)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/circuits.py"
    },
    {
        "api_name": "_write_calibrations",
        "full_api_name": "_write_calibrations",
        "api_description": "",
        "api_signature": "_write_calibrations(file_obj, calibrations, metadata_serializer)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/circuits.py"
    },
    {
        "api_name": "_write_registers",
        "full_api_name": "_write_registers",
        "api_description": "",
        "api_signature": "_write_registers(file_obj, in_circ_regs, full_bits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/circuits.py"
    },
    {
        "api_name": "_write_layout",
        "full_api_name": "_write_layout",
        "api_description": "",
        "api_signature": "_write_layout(file_obj, circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/circuits.py"
    },
    {
        "api_name": "_read_layout",
        "full_api_name": "_read_layout",
        "api_description": "",
        "api_signature": "_read_layout(file_obj, circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/circuits.py"
    },
    {
        "api_name": "_read_common_layout",
        "full_api_name": "_read_common_layout",
        "api_description": "",
        "api_signature": "_read_common_layout(file_obj, header, circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/circuits.py"
    },
    {
        "api_name": "_read_layout_v2",
        "full_api_name": "_read_layout_v2",
        "api_description": "",
        "api_signature": "_read_layout_v2(file_obj, circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/circuits.py"
    },
    {
        "api_name": "write_circuit",
        "full_api_name": "write_circuit",
        "api_description": "Write a single QuantumCircuit object in the file like object.\n\nArgs:\n    file_obj (FILE): The file like object to write the circuit data in.\n    circuit (QuantumCircuit): The circuit data to write.\n    metadata_serializer (JSONEncoder): An optional JSONEncoder class that\n        will be passed the :attr:`.QuantumCircuit.metadata` dictionary for\n        ``circuit`` and will be used as the ``cls`` kwarg\n        on the ``json.dump()`` call to JSON serialize that dictionary.\n    use_symengine (bool): If True, symbolic objects will be serialized using symengine's\n        native mechanism. This is a faster serialization alternative, but not supported in all\n        platforms. Please check that your target platform is supported by the symengine library\n        before setting this option, as it will be required by qpy to deserialize the payload.",
        "api_signature": "write_circuit(file_obj, circuit, metadata_serializer, use_symengine)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/circuits.py"
    },
    {
        "api_name": "read_circuit",
        "full_api_name": "read_circuit",
        "api_description": "Read a single QuantumCircuit object from the file like object.\n\nArgs:\n    file_obj (FILE): The file like object to read the circuit data from.\n    version (int): QPY version.\n    metadata_deserializer (JSONDecoder): An optional JSONDecoder class\n        that will be used for the ``cls`` kwarg on the internal\n        ``json.load`` call used to deserialize the JSON payload used for\n        the :attr:`.QuantumCircuit.metadata` attribute for a circuit\n        in the file-like object. If this is not specified the circuit metadata will\n        be parsed as JSON with the stdlib ``json.load()`` function using\n        the default ``JSONDecoder`` class.\n    use_symengine (bool): If True, symbolic objects will be de-serialized using\n        symengine's native mechanism. This is a faster serialization alternative, but not\n        supported in all platforms. Please check that your target platform is supported by\n        the symengine library before setting this option, as it will be required by qpy to\n        deserialize the payload.\nReturns:\n    QuantumCircuit: The circuit object from the file.\n\nRaises:\n    QpyError: Invalid register.",
        "api_signature": "read_circuit(file_obj, version, metadata_deserializer, use_symengine)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/circuits.py"
    },
    {
        "api_name": "_read_channel",
        "full_api_name": "_read_channel",
        "api_description": "",
        "api_signature": "_read_channel(file_obj, version)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/schedules.py"
    },
    {
        "api_name": "_read_waveform",
        "full_api_name": "_read_waveform",
        "api_description": "",
        "api_signature": "_read_waveform(file_obj, version)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/schedules.py"
    },
    {
        "api_name": "_loads_obj",
        "full_api_name": "_loads_obj",
        "api_description": "Wraps `value.loads_value` to deserialize binary data to dictionary\nor list objects which are not supported by `value.loads_value`.",
        "api_signature": "_loads_obj(type_key, binary_data, version, vectors)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/schedules.py"
    },
    {
        "api_name": "_read_kernel",
        "full_api_name": "_read_kernel",
        "api_description": "",
        "api_signature": "_read_kernel(file_obj, version)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/schedules.py"
    },
    {
        "api_name": "_read_discriminator",
        "full_api_name": "_read_discriminator",
        "api_description": "",
        "api_signature": "_read_discriminator(file_obj, version)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/schedules.py"
    },
    {
        "api_name": "_loads_symbolic_expr",
        "full_api_name": "_loads_symbolic_expr",
        "api_description": "",
        "api_signature": "_loads_symbolic_expr(expr_bytes, use_symengine)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/schedules.py"
    },
    {
        "api_name": "_read_symbolic_pulse",
        "full_api_name": "_read_symbolic_pulse",
        "api_description": "",
        "api_signature": "_read_symbolic_pulse(file_obj, version)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/schedules.py"
    },
    {
        "api_name": "_read_symbolic_pulse_v6",
        "full_api_name": "_read_symbolic_pulse_v6",
        "api_description": "",
        "api_signature": "_read_symbolic_pulse_v6(file_obj, version, use_symengine)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/schedules.py"
    },
    {
        "api_name": "_read_alignment_context",
        "full_api_name": "_read_alignment_context",
        "api_description": "",
        "api_signature": "_read_alignment_context(file_obj, version)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/schedules.py"
    },
    {
        "api_name": "_loads_operand",
        "full_api_name": "_loads_operand",
        "api_description": "",
        "api_signature": "_loads_operand(type_key, data_bytes, version, use_symengine)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/schedules.py"
    },
    {
        "api_name": "_read_element",
        "full_api_name": "_read_element",
        "api_description": "",
        "api_signature": "_read_element(file_obj, version, metadata_deserializer, use_symengine)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/schedules.py"
    },
    {
        "api_name": "_loads_reference_item",
        "full_api_name": "_loads_reference_item",
        "api_description": "",
        "api_signature": "_loads_reference_item(type_key, data_bytes, version, metadata_deserializer)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/schedules.py"
    },
    {
        "api_name": "_write_channel",
        "full_api_name": "_write_channel",
        "api_description": "",
        "api_signature": "_write_channel(file_obj, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/schedules.py"
    },
    {
        "api_name": "_write_waveform",
        "full_api_name": "_write_waveform",
        "api_description": "",
        "api_signature": "_write_waveform(file_obj, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/schedules.py"
    },
    {
        "api_name": "_dumps_obj",
        "full_api_name": "_dumps_obj",
        "api_description": "Wraps `value.dumps_value` to serialize dictionary and list objects\nwhich are not supported by `value.dumps_value`.",
        "api_signature": "_dumps_obj(obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/schedules.py"
    },
    {
        "api_name": "_write_kernel",
        "full_api_name": "_write_kernel",
        "api_description": "",
        "api_signature": "_write_kernel(file_obj, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/schedules.py"
    },
    {
        "api_name": "_write_discriminator",
        "full_api_name": "_write_discriminator",
        "api_description": "",
        "api_signature": "_write_discriminator(file_obj, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/schedules.py"
    },
    {
        "api_name": "_dumps_symbolic_expr",
        "full_api_name": "_dumps_symbolic_expr",
        "api_description": "",
        "api_signature": "_dumps_symbolic_expr(expr, use_symengine)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/schedules.py"
    },
    {
        "api_name": "_write_symbolic_pulse",
        "full_api_name": "_write_symbolic_pulse",
        "api_description": "",
        "api_signature": "_write_symbolic_pulse(file_obj, data, use_symengine)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/schedules.py"
    },
    {
        "api_name": "_write_alignment_context",
        "full_api_name": "_write_alignment_context",
        "api_description": "",
        "api_signature": "_write_alignment_context(file_obj, context)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/schedules.py"
    },
    {
        "api_name": "_dumps_operand",
        "full_api_name": "_dumps_operand",
        "api_description": "",
        "api_signature": "_dumps_operand(operand, use_symengine)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/schedules.py"
    },
    {
        "api_name": "_write_element",
        "full_api_name": "_write_element",
        "api_description": "",
        "api_signature": "_write_element(file_obj, element, metadata_serializer, use_symengine)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/schedules.py"
    },
    {
        "api_name": "_dumps_reference_item",
        "full_api_name": "_dumps_reference_item",
        "api_description": "",
        "api_signature": "_dumps_reference_item(schedule, metadata_serializer)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/schedules.py"
    },
    {
        "api_name": "read_schedule_block",
        "full_api_name": "read_schedule_block",
        "api_description": "Read a single ScheduleBlock from the file like object.\n\nArgs:\n    file_obj (File): A file like object that contains the QPY binary data.\n    version (int): QPY version.\n    metadata_deserializer (JSONDecoder): An optional JSONDecoder class\n        that will be used for the ``cls`` kwarg on the internal\n        ``json.load`` call used to deserialize the JSON payload used for\n        the :attr:`.ScheduleBlock.metadata` attribute for a schdule block\n        in the file-like object. If this is not specified the circuit metadata will\n        be parsed as JSON with the stdlib ``json.load()`` function using\n        the default ``JSONDecoder`` class.\n    use_symengine (bool): If True, symbolic objects will be serialized using symengine's\n        native mechanism. This is a faster serialization alternative, but not supported in all\n        platforms. Please check that your target platform is supported by the symengine library\n        before setting this option, as it will be required by qpy to deserialize the payload.\nReturns:\n    ScheduleBlock: The schedule block object from the file.\n\nRaises:\n    TypeError: If any of the instructions is invalid data format.\n    QiskitError: QPY version is earlier than block support.",
        "api_signature": "read_schedule_block(file_obj, version, metadata_deserializer, use_symengine)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/schedules.py"
    },
    {
        "api_name": "write_schedule_block",
        "full_api_name": "write_schedule_block",
        "api_description": "Write a single ScheduleBlock object in the file like object.\n\nArgs:\n    file_obj (File): The file like object to write the circuit data in.\n    block (ScheduleBlock): A schedule block data to write.\n    metadata_serializer (JSONEncoder): An optional JSONEncoder class that\n        will be passed the :attr:`.ScheduleBlock.metadata` dictionary for\n        ``block`` and will be used as the ``cls`` kwarg\n        on the ``json.dump()`` call to JSON serialize that dictionary.\n    use_symengine (bool): If True, symbolic objects will be serialized using symengine's\n        native mechanism. This is a faster serialization alternative, but not supported in all\n        platforms. Please check that your target platform is supported by the symengine library\n        before setting this option, as it will be required by qpy to deserialize the payload.\nRaises:\n    TypeError: If any of the instructions is invalid data format.",
        "api_signature": "write_schedule_block(file_obj, block, metadata_serializer, use_symengine)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/schedules.py"
    },
    {
        "api_name": "commutator",
        "full_api_name": "commutator",
        "api_description": "Deprecated: Compute commutator of `op_a` and `op_b`.\n\n.. math::\n\n    AB - BA.\n\nArgs:\n    op_a: Operator A\n    op_b: Operator B\nReturns:\n    OperatorBase: the commutator",
        "api_signature": "commutator(op_a, op_b)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/utils.py"
    },
    {
        "api_name": "anti_commutator",
        "full_api_name": "anti_commutator",
        "api_description": "Deprecated: Compute anti-commutator of `op_a` and `op_b`.\n\n.. math::\n\n    AB + BA.\n\nArgs:\n    op_a: Operator A\n    op_b: Operator B\nReturns:\n    OperatorBase: the anti-commutator",
        "api_signature": "anti_commutator(op_a, op_b)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/utils.py"
    },
    {
        "api_name": "double_commutator",
        "full_api_name": "double_commutator",
        "api_description": "Deprecated: Compute symmetric double commutator of `op_a`, `op_b` and `op_c`.\nSee McWeeny chapter 13.6 Equation of motion methods (page 479)\n\nIf `sign` is `False`, it returns\n\n.. math::\n\n     [[A, B], C]/2 + [A, [B, C]]/2\n     = (2ABC + 2CBA - BAC - CAB - ACB - BCA)/2.\n\nIf `sign` is `True`, it returns\n\n.. math::\n     \\lbrace[A, B], C\\rbrace/2 + \\lbrace A, [B, C]\\rbrace/2\n     = (2ABC - 2CBA - BAC + CAB - ACB + BCA)/2.\n\nArgs:\n    op_a: Operator A\n    op_b: Operator B\n    op_c: Operator C\n    sign: False anti-commutes, True commutes\nReturns:\n    OperatorBase: the double commutator",
        "api_signature": "double_commutator(op_a, op_b, op_c, sign)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/utils.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "OpflowError.__init__",
        "api_description": "Set the error message.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/exceptions.py"
    },
    {
        "api_name": "make_immutable",
        "full_api_name": "make_immutable",
        "api_description": "Deprecate\\: Delete the __setattr__ property to make the object mostly immutable.",
        "api_signature": "make_immutable(obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/operator_globals.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "OperatorBase.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/operator_base.py"
    },
    {
        "api_name": "settings",
        "full_api_name": "OperatorBase.settings",
        "api_description": "Return settings of this object in a dictionary.\n\nYou can, for example, use this ``settings`` dictionary to serialize the\nobject in JSON format, if the JSON encoder you use supports all types in\nthe dictionary.\n\nReturns:\n    Object settings in a dictionary.",
        "api_signature": "settings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/operator_base.py"
    },
    {
        "api_name": "instance_id",
        "full_api_name": "OperatorBase.instance_id",
        "api_description": "Return the unique instance id.",
        "api_signature": "instance_id(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/operator_base.py"
    },
    {
        "api_name": "num_qubits",
        "full_api_name": "OperatorBase.num_qubits",
        "api_description": "The number of qubits over which the Operator is defined. If\n``op.num_qubits == 5``, then ``op.eval('1' * 5)`` will be valid, but\n``op.eval('11')`` will not.\n\nReturns:\n    The number of qubits accepted by the Operator's underlying function.",
        "api_signature": "num_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/operator_base.py"
    },
    {
        "api_name": "primitive_strings",
        "full_api_name": "OperatorBase.primitive_strings",
        "api_description": "Return a set of strings describing the primitives contained in the Operator. For\nexample, ``{'QuantumCircuit', 'Pauli'}``. For hierarchical Operators, such as ``ListOps``,\nthis can help illuminate the primitives represented in the various recursive levels,\nand therefore which conversions can be applied.\n\nReturns:\n    A set of strings describing the primitives contained within the Operator.",
        "api_signature": "primitive_strings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/operator_base.py"
    },
    {
        "api_name": "eval",
        "full_api_name": "OperatorBase.eval",
        "api_description": "Evaluate the Operator's underlying function, either on a binary string or another Operator.\nA square binary Operator can be defined as a function taking a binary function to another\nbinary function. This method returns the value of that function for a given StateFn or\nbinary string. For example, ``op.eval('0110').eval('1110')`` can be seen as querying the\nOperator's matrix representation by row 6 and column 14, and will return the complex\nvalue at those \"indices.\" Similarly for a StateFn, ``op.eval('1011')`` will return the\ncomplex value at row 11 of the vector representation of the StateFn, as all StateFns are\ndefined to be evaluated from Zero implicitly (i.e. it is as if ``.eval('0000')`` is already\ncalled implicitly to always \"indexing\" from column 0).\n\nIf ``front`` is None, the matrix-representation of the operator is returned.\n\nArgs:\n    front: The bitstring, dict of bitstrings (with values being coefficients), or\n        StateFn to evaluated by the Operator's underlying function, or None.\n\nReturns:\n    The output of the Operator's evaluation function. If self is a ``StateFn``, the result\n    is a float or complex. If self is an Operator (``PrimitiveOp, ComposedOp, SummedOp,\n    EvolvedOp,`` etc.), the result is a StateFn.\n    If ``front`` is None, the matrix-representation of the operator is returned, which\n    is a ``MatrixOp`` for the operators and a ``VectorStateFn`` for state-functions.\n    If either self or front contain proper\n    ``ListOps`` (not ListOp subclasses), the result is an n-dimensional list of complex\n    or StateFn results, resulting from the recursive evaluation by each OperatorBase\n    in the ListOps.",
        "api_signature": "eval(self, front)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/operator_base.py"
    },
    {
        "api_name": "reduce",
        "full_api_name": "OperatorBase.reduce",
        "api_description": "Try collapsing the Operator structure, usually after some type of conversion,\ne.g. trying to add Operators in a SummedOp or delete needless IGates in a CircuitOp.\nIf no reduction is available, just returns self.\n\nReturns:\n    The reduced ``OperatorBase``.",
        "api_signature": "reduce(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/operator_base.py"
    },
    {
        "api_name": "to_matrix",
        "full_api_name": "OperatorBase.to_matrix",
        "api_description": "Return NumPy representation of the Operator. Represents the evaluation of\nthe Operator's underlying function on every combination of basis binary strings.\nWarn if more than 16 qubits to force having to set ``massive=True`` if such a\nlarge vector is desired.\n\nReturns:\n      The NumPy ``ndarray`` equivalent to this Operator.",
        "api_signature": "to_matrix(self, massive)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/operator_base.py"
    },
    {
        "api_name": "to_matrix_op",
        "full_api_name": "OperatorBase.to_matrix_op",
        "api_description": "Returns a ``MatrixOp`` equivalent to this Operator.",
        "api_signature": "to_matrix_op(self, massive)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/operator_base.py"
    },
    {
        "api_name": "to_circuit_op",
        "full_api_name": "OperatorBase.to_circuit_op",
        "api_description": "Returns a ``CircuitOp`` equivalent to this Operator.",
        "api_signature": "to_circuit_op(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/operator_base.py"
    },
    {
        "api_name": "to_spmatrix",
        "full_api_name": "OperatorBase.to_spmatrix",
        "api_description": "Return SciPy sparse matrix representation of the Operator. Represents the evaluation of\nthe Operator's underlying function on every combination of basis binary strings.\n\nReturns:\n      The SciPy ``spmatrix`` equivalent to this Operator.",
        "api_signature": "to_spmatrix(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/operator_base.py"
    },
    {
        "api_name": "is_hermitian",
        "full_api_name": "OperatorBase.is_hermitian",
        "api_description": "Return True if the operator is hermitian.\n\nReturns: Boolean value",
        "api_signature": "is_hermitian(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/operator_base.py"
    },
    {
        "api_name": "_indent",
        "full_api_name": "OperatorBase._indent",
        "api_description": "Indented representation to allow pretty representation of nested operators.",
        "api_signature": "_indent(lines, indentation)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/operator_base.py"
    },
    {
        "api_name": "add",
        "full_api_name": "OperatorBase.add",
        "api_description": "Return Operator addition of self and other, overloaded by ``+``.\n\nArgs:\n    other: An ``OperatorBase`` with the same number of qubits as self, and in the same\n        'Operator', 'State function', or 'Measurement' category as self (i.e. the same type\n        of underlying function).\n\nReturns:\n    An ``OperatorBase`` equivalent to the sum of self and other.",
        "api_signature": "add(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/operator_base.py"
    },
    {
        "api_name": "neg",
        "full_api_name": "OperatorBase.neg",
        "api_description": "Return the Operator's negation, effectively just multiplying by -1.0,\noverloaded by ``-``.\n\nReturns:\n    An ``OperatorBase`` equivalent to the negation of self.",
        "api_signature": "neg(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/operator_base.py"
    },
    {
        "api_name": "adjoint",
        "full_api_name": "OperatorBase.adjoint",
        "api_description": "Return a new Operator equal to the Operator's adjoint (conjugate transpose),\noverloaded by ``~``. For StateFns, this also turns the StateFn into a measurement.\n\nReturns:\n    An ``OperatorBase`` equivalent to the adjoint of self.",
        "api_signature": "adjoint(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/operator_base.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "OperatorBase.__eq__",
        "api_description": "Overload ``==`` operation to evaluate equality between Operators.\n\nArgs:\n    other: The ``OperatorBase`` to compare to self.\n\nReturns:\n    A bool equal to the equality of self and other.",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/operator_base.py"
    },
    {
        "api_name": "equals",
        "full_api_name": "OperatorBase.equals",
        "api_description": "Evaluate Equality between Operators, overloaded by ``==``. Only returns True if self and\nother are of the same representation (e.g. a DictStateFn and CircuitStateFn will never be\nequal, even if their vector representations are equal), their underlying primitives are\nequal (this means for ListOps, OperatorStateFns, or EvolvedOps the equality is evaluated\nrecursively downwards), and their coefficients are equal.\n\nArgs:\n    other: The ``OperatorBase`` to compare to self.\n\nReturns:\n    A bool equal to the equality of self and other.",
        "api_signature": "equals(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/operator_base.py"
    },
    {
        "api_name": "mul",
        "full_api_name": "OperatorBase.mul",
        "api_description": "Returns the scalar multiplication of the Operator, overloaded by ``*``, including\nsupport for Terra's ``Parameters``, which can be bound to values later (via\n``bind_parameters``).\n\nArgs:\n    scalar: The real or complex scalar by which to multiply the Operator,\n        or the ``ParameterExpression`` to serve as a placeholder for a scalar factor.\n\nReturns:\n    An ``OperatorBase`` equivalent to product of self and scalar.",
        "api_signature": "mul(self, scalar)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/operator_base.py"
    },
    {
        "api_name": "tensor",
        "full_api_name": "OperatorBase.tensor",
        "api_description": "Return tensor product between self and other, overloaded by ``^``.\nNote: You must be conscious of Qiskit's big-endian bit printing convention.\nMeaning, X.tensor(Y) produces an X on qubit 0 and an Y on qubit 1, or X\u2a02Y,\nbut would produce a QuantumCircuit which looks like\n\n    -[Y]-\n    -[X]-\n\nBecause Terra prints circuits and results with qubit 0 at the end of the string\nor circuit.\n\nArgs:\n    other: The ``OperatorBase`` to tensor product with self.\n\nReturns:\n    An ``OperatorBase`` equivalent to the tensor product of self and other.",
        "api_signature": "tensor(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/operator_base.py"
    },
    {
        "api_name": "tensorpower",
        "full_api_name": "OperatorBase.tensorpower",
        "api_description": "Return tensor product with self multiple times, overloaded by ``^``.\n\nArgs:\n    other: The int number of times to tensor product self with itself via ``tensorpower``.\n\nReturns:\n    An ``OperatorBase`` equivalent to the tensorpower of self by other.",
        "api_signature": "tensorpower(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/operator_base.py"
    },
    {
        "api_name": "parameters",
        "full_api_name": "OperatorBase.parameters",
        "api_description": "Return a set of Parameter objects contained in the Operator.",
        "api_signature": "parameters(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/operator_base.py"
    },
    {
        "api_name": "assign_parameters",
        "full_api_name": "OperatorBase.assign_parameters",
        "api_description": "Binds scalar values to any Terra ``Parameters`` in the coefficients or primitives of\nthe Operator, or substitutes one ``Parameter`` for another. This method differs from\nTerra's ``assign_parameters`` in that it also supports lists of values to assign for a\ngive ``Parameter``, in which case self will be copied for each parameterization in the\nbinding list(s), and all the copies will be returned in an ``OpList``. If lists of\nparameterizations are used, every ``Parameter`` in the param_dict must have the same\nlength list of parameterizations.\n\nArgs:\n    param_dict: The dictionary of ``Parameters`` to replace, and values or lists of\n        values by which to replace them.\n\nReturns:\n    The ``OperatorBase`` with the ``Parameters`` in self replaced by the\n    values or ``Parameters`` in param_dict. If param_dict contains parameterization lists,\n    this ``OperatorBase`` is an ``OpList``.",
        "api_signature": "assign_parameters(self, param_dict)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/operator_base.py"
    },
    {
        "api_name": "_expand_dim",
        "full_api_name": "OperatorBase._expand_dim",
        "api_description": "Expands the operator with identity operator of dimension 2**num_qubits.\n\nReturns:\n    Operator corresponding to self.tensor(identity_operator), where dimension of identity\n    operator is 2 ** num_qubits.",
        "api_signature": "_expand_dim(self, num_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/operator_base.py"
    },
    {
        "api_name": "permute",
        "full_api_name": "OperatorBase.permute",
        "api_description": "Permutes the qubits of the operator.\n\nArgs:\n    permutation: A list defining where each qubit should be permuted. The qubit at index\n        j should be permuted to position permutation[j].\n\nReturns:\n    A new OperatorBase containing the permuted operator.\n\nRaises:\n    OpflowError: if indices do not define a new index for each qubit.",
        "api_signature": "permute(self, permutation)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/operator_base.py"
    },
    {
        "api_name": "bind_parameters",
        "full_api_name": "OperatorBase.bind_parameters",
        "api_description": "Same as assign_parameters, but maintained for consistency with QuantumCircuit in\nTerra (which has both assign_parameters and bind_parameters).",
        "api_signature": "bind_parameters(self, param_dict)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/operator_base.py"
    },
    {
        "api_name": "_unroll_param_dict",
        "full_api_name": "OperatorBase._unroll_param_dict",
        "api_description": "Unrolls the ParameterVectors in a param_dict into separate Parameters, and unrolls\nparameterization value lists into separate param_dicts without list nesting.",
        "api_signature": "_unroll_param_dict(value_dict)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/operator_base.py"
    },
    {
        "api_name": "_get_param_dict_for_index",
        "full_api_name": "OperatorBase._get_param_dict_for_index",
        "api_description": "Gets a single non-list-nested param_dict for a given list index from a nested one.",
        "api_signature": "_get_param_dict_for_index(unrolled_dict, i)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/operator_base.py"
    },
    {
        "api_name": "_expand_shorter_operator_and_permute",
        "full_api_name": "OperatorBase._expand_shorter_operator_and_permute",
        "api_description": "",
        "api_signature": "_expand_shorter_operator_and_permute(self, other, permutation)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/operator_base.py"
    },
    {
        "api_name": "copy",
        "full_api_name": "OperatorBase.copy",
        "api_description": "Return a deep copy of the Operator.",
        "api_signature": "copy(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/operator_base.py"
    },
    {
        "api_name": "compose",
        "full_api_name": "OperatorBase.compose",
        "api_description": "Return Operator Composition between self and other (linear algebra-style:\nA@B(x) = A(B(x))), overloaded by ``@``.\n\nNote: You must be conscious of Quantum Circuit vs. Linear Algebra ordering\nconventions. Meaning, X.compose(Y)\nproduces an X\u2218Y on qubit 0, but would produce a QuantumCircuit which looks like\n\n    -[Y]-[X]-\n\nBecause Terra prints circuits with the initial state at the left side of the circuit.\n\nArgs:\n    other: The ``OperatorBase`` with which to compose self.\n    permutation: ``List[int]`` which defines permutation on other operator.\n    front: If front==True, return ``other.compose(self)``.\n\nReturns:\n    An ``OperatorBase`` equivalent to the function composition of self and other.",
        "api_signature": "compose(self, other, permutation, front)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/operator_base.py"
    },
    {
        "api_name": "_check_massive",
        "full_api_name": "OperatorBase._check_massive",
        "api_description": "Checks if matrix or vector generated will be too large.\n\nArgs:\n    method: Name of the calling method\n    matrix: True if object is matrix, otherwise vector\n    num_qubits: number of qubits\n    massive: True if it is ok to proceed with large matrix\n\nRaises:\n    ValueError: Massive is False and number of qubits is greater than 16",
        "api_signature": "_check_massive(method, matrix, num_qubits, massive)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/operator_base.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "OperatorBase.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/operator_base.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ComposedOp.__init__",
        "api_description": "Args:\n    oplist: The Operators being composed.\n    coeff: A coefficient multiplying the operator\n    abelian: Indicates whether the Operators in ``oplist`` are known to mutually commute.",
        "api_signature": "__init__(self, oplist, coeff, abelian)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/composed_op.py"
    },
    {
        "api_name": "num_qubits",
        "full_api_name": "ComposedOp.num_qubits",
        "api_description": "",
        "api_signature": "num_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/composed_op.py"
    },
    {
        "api_name": "distributive",
        "full_api_name": "ComposedOp.distributive",
        "api_description": "",
        "api_signature": "distributive(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/composed_op.py"
    },
    {
        "api_name": "settings",
        "full_api_name": "ComposedOp.settings",
        "api_description": "Return settings.",
        "api_signature": "settings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/composed_op.py"
    },
    {
        "api_name": "to_matrix",
        "full_api_name": "ComposedOp.to_matrix",
        "api_description": "",
        "api_signature": "to_matrix(self, massive)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/composed_op.py"
    },
    {
        "api_name": "to_circuit",
        "full_api_name": "ComposedOp.to_circuit",
        "api_description": "Returns the quantum circuit, representing the composed operator.\n\nReturns:\n    The circuit representation of the composed operator.\n\nRaises:\n    OpflowError: for operators where a single underlying circuit can not be obtained.",
        "api_signature": "to_circuit(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/composed_op.py"
    },
    {
        "api_name": "adjoint",
        "full_api_name": "ComposedOp.adjoint",
        "api_description": "",
        "api_signature": "adjoint(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/composed_op.py"
    },
    {
        "api_name": "compose",
        "full_api_name": "ComposedOp.compose",
        "api_description": "",
        "api_signature": "compose(self, other, permutation, front)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/composed_op.py"
    },
    {
        "api_name": "eval",
        "full_api_name": "ComposedOp.eval",
        "api_description": "",
        "api_signature": "eval(self, front)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/composed_op.py"
    },
    {
        "api_name": "tree_recursive_eval",
        "full_api_name": "ComposedOp.tree_recursive_eval",
        "api_description": "",
        "api_signature": "tree_recursive_eval(r, l_arg)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/composed_op.py"
    },
    {
        "api_name": "non_distributive_reduce",
        "full_api_name": "ComposedOp.non_distributive_reduce",
        "api_description": "Reduce without attempting to expand all distributive compositions.\n\nReturns:\n    The reduced Operator.",
        "api_signature": "non_distributive_reduce(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/composed_op.py"
    },
    {
        "api_name": "reduce",
        "full_api_name": "ComposedOp.reduce",
        "api_description": "",
        "api_signature": "reduce(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/composed_op.py"
    },
    {
        "api_name": "distribute_compose",
        "full_api_name": "ComposedOp.distribute_compose",
        "api_description": "",
        "api_signature": "distribute_compose(l_arg, r)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/composed_op.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "TensoredOp.__init__",
        "api_description": "Args:\n    oplist: The Operators being tensored.\n    coeff: A coefficient multiplying the operator\n    abelian: Indicates whether the Operators in ``oplist`` are known to mutually commute.",
        "api_signature": "__init__(self, oplist, coeff, abelian)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/tensored_op.py"
    },
    {
        "api_name": "num_qubits",
        "full_api_name": "TensoredOp.num_qubits",
        "api_description": "",
        "api_signature": "num_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/tensored_op.py"
    },
    {
        "api_name": "distributive",
        "full_api_name": "TensoredOp.distributive",
        "api_description": "",
        "api_signature": "distributive(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/tensored_op.py"
    },
    {
        "api_name": "settings",
        "full_api_name": "TensoredOp.settings",
        "api_description": "Return settings.",
        "api_signature": "settings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/tensored_op.py"
    },
    {
        "api_name": "_expand_dim",
        "full_api_name": "TensoredOp._expand_dim",
        "api_description": "Appends I ^ num_qubits to ``oplist``. Choice of PauliOp as\nidentity is arbitrary and can be substituted for other PrimitiveOp identity.\n\nReturns:\n    TensoredOp expanded with identity operator.",
        "api_signature": "_expand_dim(self, num_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/tensored_op.py"
    },
    {
        "api_name": "tensor",
        "full_api_name": "TensoredOp.tensor",
        "api_description": "",
        "api_signature": "tensor(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/tensored_op.py"
    },
    {
        "api_name": "eval",
        "full_api_name": "TensoredOp.eval",
        "api_description": "",
        "api_signature": "eval(self, front)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/tensored_op.py"
    },
    {
        "api_name": "reduce",
        "full_api_name": "TensoredOp.reduce",
        "api_description": "",
        "api_signature": "reduce(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/tensored_op.py"
    },
    {
        "api_name": "to_circuit",
        "full_api_name": "TensoredOp.to_circuit",
        "api_description": "Returns the quantum circuit, representing the tensored operator.\n\nReturns:\n    The circuit representation of the tensored operator.\n\nRaises:\n    OpflowError: for operators where a single underlying circuit can not be produced.",
        "api_signature": "to_circuit(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/tensored_op.py"
    },
    {
        "api_name": "to_matrix",
        "full_api_name": "TensoredOp.to_matrix",
        "api_description": "",
        "api_signature": "to_matrix(self, massive)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/tensored_op.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ListOp.__init__",
        "api_description": "Args:\n    oplist: The list of ``OperatorBases`` defining this Operator's underlying function.\n    combo_fn: The recombination function to combine classical results of the\n        ``oplist`` Operators' eval functions (e.g. sum). Default is lambda x: x.\n    coeff: A coefficient multiplying the operator\n    abelian: Indicates whether the Operators in ``oplist`` are known to mutually commute.\n    grad_combo_fn: The gradient of recombination function. If None, the gradient will\n        be computed automatically.\n    Note that the default \"recombination function\" lambda above is essentially the\n    identity - it accepts the list of values, and returns them in a list.",
        "api_signature": "__init__(self, oplist, combo_fn, coeff, abelian, grad_combo_fn)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/list_op.py"
    },
    {
        "api_name": "_check_input_types",
        "full_api_name": "ListOp._check_input_types",
        "api_description": "",
        "api_signature": "_check_input_types(self, oplist)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/list_op.py"
    },
    {
        "api_name": "_state",
        "full_api_name": "ListOp._state",
        "api_description": "",
        "api_signature": "_state(self, coeff, combo_fn, abelian, grad_combo_fn)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/list_op.py"
    },
    {
        "api_name": "settings",
        "full_api_name": "ListOp.settings",
        "api_description": "Return settings.",
        "api_signature": "settings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/list_op.py"
    },
    {
        "api_name": "oplist",
        "full_api_name": "ListOp.oplist",
        "api_description": "The list of ``OperatorBases`` defining the underlying function of this\nOperator.\n\nReturns:\n    The Operators defining the ListOp",
        "api_signature": "oplist(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/list_op.py"
    },
    {
        "api_name": "default_combo_fn",
        "full_api_name": "ListOp.default_combo_fn",
        "api_description": "ListOp default combo function i.e. lambda x: x",
        "api_signature": "default_combo_fn(x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/list_op.py"
    },
    {
        "api_name": "combo_fn",
        "full_api_name": "ListOp.combo_fn",
        "api_description": "The function defining how to combine ``oplist`` (or Numbers, or NumPy arrays) to\nproduce the Operator's underlying function. For example, SummedOp's combination function\nis to add all of the Operators in ``oplist``.\n\nReturns:\n    The combination function.",
        "api_signature": "combo_fn(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/list_op.py"
    },
    {
        "api_name": "grad_combo_fn",
        "full_api_name": "ListOp.grad_combo_fn",
        "api_description": "The gradient of ``combo_fn``.",
        "api_signature": "grad_combo_fn(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/list_op.py"
    },
    {
        "api_name": "abelian",
        "full_api_name": "ListOp.abelian",
        "api_description": "Whether the Operators in ``oplist`` are known to commute with one another.\n\nReturns:\n    A bool indicating whether the ``oplist`` is Abelian.",
        "api_signature": "abelian(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/list_op.py"
    },
    {
        "api_name": "distributive",
        "full_api_name": "ListOp.distributive",
        "api_description": "Indicates whether the ListOp or subclass is distributive under composition.\nListOp and SummedOp are, meaning that (opv @ op) = (opv[0] @ op + opv[1] @ op)\n(using plus for SummedOp, list for ListOp, etc.), while ComposedOp and TensoredOp\ndo not behave this way.\n\nReturns:\n    A bool indicating whether the ListOp is distributive under composition.",
        "api_signature": "distributive(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/list_op.py"
    },
    {
        "api_name": "coeff",
        "full_api_name": "ListOp.coeff",
        "api_description": "The scalar coefficient multiplying the Operator.\n\nReturns:\n    The coefficient.",
        "api_signature": "coeff(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/list_op.py"
    },
    {
        "api_name": "coeffs",
        "full_api_name": "ListOp.coeffs",
        "api_description": "Return a list of the coefficients of the operators listed.\nRaises exception for nested Listops.",
        "api_signature": "coeffs(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/list_op.py"
    },
    {
        "api_name": "primitive_strings",
        "full_api_name": "ListOp.primitive_strings",
        "api_description": "",
        "api_signature": "primitive_strings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/list_op.py"
    },
    {
        "api_name": "num_qubits",
        "full_api_name": "ListOp.num_qubits",
        "api_description": "",
        "api_signature": "num_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/list_op.py"
    },
    {
        "api_name": "add",
        "full_api_name": "ListOp.add",
        "api_description": "",
        "api_signature": "add(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/list_op.py"
    },
    {
        "api_name": "adjoint",
        "full_api_name": "ListOp.adjoint",
        "api_description": "",
        "api_signature": "adjoint(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/list_op.py"
    },
    {
        "api_name": "traverse",
        "full_api_name": "ListOp.traverse",
        "api_description": "Apply the convert_fn to each node in the oplist.\n\nArgs:\n    convert_fn: The function to apply to the internal OperatorBase.\n    coeff: A coefficient to multiply by after applying convert_fn.\n        If it is None, self.coeff is used instead.\n\nReturns:\n    The converted ListOp.",
        "api_signature": "traverse(self, convert_fn, coeff)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/list_op.py"
    },
    {
        "api_name": "equals",
        "full_api_name": "ListOp.equals",
        "api_description": "",
        "api_signature": "equals(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/list_op.py"
    },
    {
        "api_name": "mul",
        "full_api_name": "ListOp.mul",
        "api_description": "",
        "api_signature": "mul(self, scalar)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/list_op.py"
    },
    {
        "api_name": "tensor",
        "full_api_name": "ListOp.tensor",
        "api_description": "",
        "api_signature": "tensor(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/list_op.py"
    },
    {
        "api_name": "tensorpower",
        "full_api_name": "ListOp.tensorpower",
        "api_description": "",
        "api_signature": "tensorpower(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/list_op.py"
    },
    {
        "api_name": "_expand_dim",
        "full_api_name": "ListOp._expand_dim",
        "api_description": "",
        "api_signature": "_expand_dim(self, num_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/list_op.py"
    },
    {
        "api_name": "permute",
        "full_api_name": "ListOp.permute",
        "api_description": "Permute the qubits of the operator.\n\nArgs:\n    permutation: A list defining where each qubit should be permuted. The qubit at index\n        j should be permuted to position permutation[j].\n\nReturns:\n    A new ListOp representing the permuted operator.\n\nRaises:\n    OpflowError: if indices do not define a new index for each qubit.",
        "api_signature": "permute(self, permutation)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/list_op.py"
    },
    {
        "api_name": "compose",
        "full_api_name": "ListOp.compose",
        "api_description": "",
        "api_signature": "compose(self, other, permutation, front)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/list_op.py"
    },
    {
        "api_name": "power",
        "full_api_name": "ListOp.power",
        "api_description": "",
        "api_signature": "power(self, exponent)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/list_op.py"
    },
    {
        "api_name": "to_matrix",
        "full_api_name": "ListOp.to_matrix",
        "api_description": "",
        "api_signature": "to_matrix(self, massive)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/list_op.py"
    },
    {
        "api_name": "to_spmatrix",
        "full_api_name": "ListOp.to_spmatrix",
        "api_description": "Returns SciPy sparse matrix representation of the Operator.\n\nReturns:\n    CSR sparse matrix representation of the Operator, or List thereof.",
        "api_signature": "to_spmatrix(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/list_op.py"
    },
    {
        "api_name": "eval",
        "full_api_name": "ListOp.eval",
        "api_description": "Evaluate the Operator's underlying function, either on a binary string or another Operator.\nA square binary Operator can be defined as a function taking a binary function to another\nbinary function. This method returns the value of that function for a given StateFn or\nbinary string. For example, ``op.eval('0110').eval('1110')`` can be seen as querying the\nOperator's matrix representation by row 6 and column 14, and will return the complex\nvalue at those \"indices.\" Similarly for a StateFn, ``op.eval('1011')`` will return the\ncomplex value at row 11 of the vector representation of the StateFn, as all StateFns are\ndefined to be evaluated from Zero implicitly (i.e. it is as if ``.eval('0000')`` is already\ncalled implicitly to always \"indexing\" from column 0).\n\nListOp's eval recursively evaluates each Operator in ``oplist``,\nand combines the results using the recombination function ``combo_fn``.\n\nArgs:\n    front: The bitstring, dict of bitstrings (with values being coefficients), or\n        StateFn to evaluated by the Operator's underlying function.\n\nReturns:\n    The output of the ``oplist`` Operators' evaluation function, combined with the\n    ``combo_fn``. If either self or front contain proper ``ListOps`` (not ListOp\n    subclasses), the result is an n-dimensional list of complex or StateFn results,\n    resulting from the recursive evaluation by each OperatorBase in the ListOps.\n\nRaises:\n    NotImplementedError: Raised if called for a subclass which is not distributive.\n    TypeError: Operators with mixed hierarchies, such as a ListOp containing both\n        PrimitiveOps and ListOps, are not supported.\n    NotImplementedError: Attempting to call ListOp's eval from a non-distributive subclass.",
        "api_signature": "eval(self, front)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/list_op.py"
    },
    {
        "api_name": "exp_i",
        "full_api_name": "ListOp.exp_i",
        "api_description": "Return an ``OperatorBase`` equivalent to an exponentiation of self * -i, e^(-i*op).",
        "api_signature": "exp_i(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/list_op.py"
    },
    {
        "api_name": "log_i",
        "full_api_name": "ListOp.log_i",
        "api_description": "Return a ``MatrixOp`` equivalent to log(H)/-i for this operator H. This\nfunction is the effective inverse of exp_i, equivalent to finding the Hermitian\nOperator which produces self when exponentiated. For proper ListOps, applies ``log_i``\nto all ops in oplist.",
        "api_signature": "log_i(self, massive)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/list_op.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "ListOp.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/list_op.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "ListOp.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/list_op.py"
    },
    {
        "api_name": "parameters",
        "full_api_name": "ListOp.parameters",
        "api_description": "",
        "api_signature": "parameters(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/list_op.py"
    },
    {
        "api_name": "assign_parameters",
        "full_api_name": "ListOp.assign_parameters",
        "api_description": "",
        "api_signature": "assign_parameters(self, param_dict)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/list_op.py"
    },
    {
        "api_name": "reduce",
        "full_api_name": "ListOp.reduce",
        "api_description": "",
        "api_signature": "reduce(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/list_op.py"
    },
    {
        "api_name": "to_matrix_op",
        "full_api_name": "ListOp.to_matrix_op",
        "api_description": "Returns an equivalent Operator composed of only NumPy-based primitives, such as\n``MatrixOp`` and ``VectorStateFn``.",
        "api_signature": "to_matrix_op(self, massive)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/list_op.py"
    },
    {
        "api_name": "to_circuit_op",
        "full_api_name": "ListOp.to_circuit_op",
        "api_description": "Returns an equivalent Operator composed of only QuantumCircuit-based primitives,\nsuch as ``CircuitOp`` and ``CircuitStateFn``.",
        "api_signature": "to_circuit_op(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/list_op.py"
    },
    {
        "api_name": "to_pauli_op",
        "full_api_name": "ListOp.to_pauli_op",
        "api_description": "Returns an equivalent Operator composed of only Pauli-based primitives,\nsuch as ``PauliOp``.",
        "api_signature": "to_pauli_op(self, massive)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/list_op.py"
    },
    {
        "api_name": "_is_empty",
        "full_api_name": "ListOp._is_empty",
        "api_description": "",
        "api_signature": "_is_empty(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/list_op.py"
    },
    {
        "api_name": "__getitem__",
        "full_api_name": "ListOp.__getitem__",
        "api_description": "Allows array-indexing style access to the Operators in ``oplist``.\n\nArgs:\n    offset: The index of ``oplist`` desired.\n\nReturns:\n    The ``OperatorBase`` at index ``offset`` of ``oplist``,\n    or another ListOp with the same properties as this one if offset is a slice.",
        "api_signature": "__getitem__(self, offset)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/list_op.py"
    },
    {
        "api_name": "__iter__",
        "full_api_name": "ListOp.__iter__",
        "api_description": "Returns an iterator over the operators in ``oplist``.\n\nReturns:\n    An iterator over the operators in ``oplist``",
        "api_signature": "__iter__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/list_op.py"
    },
    {
        "api_name": "__len__",
        "full_api_name": "ListOp.__len__",
        "api_description": "Length of ``oplist``.\n\nReturns:\n    An int equal to the length of ``oplist``.",
        "api_signature": "__len__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/list_op.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SummedOp.__init__",
        "api_description": "Args:\n    oplist: The Operators being summed.\n    coeff: A coefficient multiplying the operator\n    abelian: Indicates whether the Operators in ``oplist`` are known to mutually commute.",
        "api_signature": "__init__(self, oplist, coeff, abelian)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/summed_op.py"
    },
    {
        "api_name": "num_qubits",
        "full_api_name": "SummedOp.num_qubits",
        "api_description": "",
        "api_signature": "num_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/summed_op.py"
    },
    {
        "api_name": "distributive",
        "full_api_name": "SummedOp.distributive",
        "api_description": "",
        "api_signature": "distributive(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/summed_op.py"
    },
    {
        "api_name": "settings",
        "full_api_name": "SummedOp.settings",
        "api_description": "Return settings.",
        "api_signature": "settings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/summed_op.py"
    },
    {
        "api_name": "add",
        "full_api_name": "SummedOp.add",
        "api_description": "Return Operator addition of ``self`` and ``other``, overloaded by ``+``.\n\nNote:\n    This appends ``other`` to ``self.oplist`` without checking ``other`` is already\n    included or not. If you want to simplify them, please use :meth:`simplify`.\n\nArgs:\n    other: An ``OperatorBase`` with the same number of qubits as self, and in the same\n        'Operator', 'State function', or 'Measurement' category as self (i.e. the same type\n        of underlying function).\n\nReturns:\n    A ``SummedOp`` equivalent to the sum of self and other.",
        "api_signature": "add(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/summed_op.py"
    },
    {
        "api_name": "collapse_summands",
        "full_api_name": "SummedOp.collapse_summands",
        "api_description": "Return Operator by simplifying duplicate operators.\n\nE.g., ``SummedOp([2 * X ^ Y, X ^ Y]).collapse_summands() -> SummedOp([3 * X ^ Y])``.\n\nReturns:\n    A simplified ``SummedOp`` equivalent to self.",
        "api_signature": "collapse_summands(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/summed_op.py"
    },
    {
        "api_name": "reduce",
        "full_api_name": "SummedOp.reduce",
        "api_description": "Try collapsing list or trees of sums.\n\nTries to sum up duplicate operators and reduces the operators\nin the sum.\n\nReturns:\n    A collapsed version of self, if possible.",
        "api_signature": "reduce(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/summed_op.py"
    },
    {
        "api_name": "to_circuit",
        "full_api_name": "SummedOp.to_circuit",
        "api_description": "Returns the quantum circuit, representing the SummedOp. In the first step,\nthe SummedOp is converted to MatrixOp. This is straightforward for most operators,\nbut it is not supported for operators containing parameterized PrimitiveOps (in that case,\nOpflowError is raised). In the next step, the MatrixOp representation of SummedOp is\nconverted to circuit. In most cases, if the summands themselves are unitary operators,\nthe SummedOp itself is non-unitary and can not be converted to circuit. In that case,\nExtensionError is raised in the underlying modules.\n\nReturns:\n    The circuit representation of the summed operator.\n\nRaises:\n    OpflowError: if SummedOp can not be converted to MatrixOp (e.g. SummedOp is composed of\n    parameterized PrimitiveOps).",
        "api_signature": "to_circuit(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/summed_op.py"
    },
    {
        "api_name": "to_matrix_op",
        "full_api_name": "SummedOp.to_matrix_op",
        "api_description": "Returns an equivalent Operator composed of only NumPy-based primitives, such as\n``MatrixOp`` and ``VectorStateFn``.",
        "api_signature": "to_matrix_op(self, massive)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/summed_op.py"
    },
    {
        "api_name": "to_pauli_op",
        "full_api_name": "SummedOp.to_pauli_op",
        "api_description": "",
        "api_signature": "to_pauli_op(self, massive)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/summed_op.py"
    },
    {
        "api_name": "equals",
        "full_api_name": "SummedOp.equals",
        "api_description": "Check if other is equal to self.\n\nNote:\n    This is not a mathematical check for equality.\n    If ``self`` and ``other`` implement the same operation but differ\n    in the representation (e.g. different type of summands)\n    ``equals`` will evaluate to ``False``.\n\nArgs:\n    other: The other operator to check for equality.\n\nReturns:\n    True, if other and self are equal, otherwise False.\n\nExamples:\n    >>> from qiskit.opflow import X, Z\n    >>> 2 * X == X + X\n    True\n    >>> X + Z == Z + X\n    True",
        "api_signature": "equals(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/list_ops/summed_op.py"
    },
    {
        "api_name": "build",
        "full_api_name": "EvolutionFactory.build",
        "api_description": "A factory method for convenient automatic selection of an Evolution algorithm based on the\nOperator to be converted.\n\nArgs:\n    operator: the Operator being evolved\n\nReturns:\n    EvolutionBase: the ``EvolutionBase`` best suited to evolve operator.\n\nRaises:\n    ValueError: If operator is not of a composition for which we know the best Evolution\n        method.",
        "api_signature": "build(operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/evolutions/evolution_factory.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "EvolvedOp.__init__",
        "api_description": "Args:\n    primitive: The operator being wrapped to signify evolution later.\n    coeff: A coefficient multiplying the operator",
        "api_signature": "__init__(self, primitive, coeff)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/evolutions/evolved_op.py"
    },
    {
        "api_name": "primitive_strings",
        "full_api_name": "EvolvedOp.primitive_strings",
        "api_description": "",
        "api_signature": "primitive_strings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/evolutions/evolved_op.py"
    },
    {
        "api_name": "num_qubits",
        "full_api_name": "EvolvedOp.num_qubits",
        "api_description": "",
        "api_signature": "num_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/evolutions/evolved_op.py"
    },
    {
        "api_name": "add",
        "full_api_name": "EvolvedOp.add",
        "api_description": "",
        "api_signature": "add(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/evolutions/evolved_op.py"
    },
    {
        "api_name": "adjoint",
        "full_api_name": "EvolvedOp.adjoint",
        "api_description": "",
        "api_signature": "adjoint(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/evolutions/evolved_op.py"
    },
    {
        "api_name": "equals",
        "full_api_name": "EvolvedOp.equals",
        "api_description": "",
        "api_signature": "equals(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/evolutions/evolved_op.py"
    },
    {
        "api_name": "tensor",
        "full_api_name": "EvolvedOp.tensor",
        "api_description": "",
        "api_signature": "tensor(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/evolutions/evolved_op.py"
    },
    {
        "api_name": "_expand_dim",
        "full_api_name": "EvolvedOp._expand_dim",
        "api_description": "",
        "api_signature": "_expand_dim(self, num_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/evolutions/evolved_op.py"
    },
    {
        "api_name": "permute",
        "full_api_name": "EvolvedOp.permute",
        "api_description": "",
        "api_signature": "permute(self, permutation)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/evolutions/evolved_op.py"
    },
    {
        "api_name": "compose",
        "full_api_name": "EvolvedOp.compose",
        "api_description": "",
        "api_signature": "compose(self, other, permutation, front)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/evolutions/evolved_op.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "EvolvedOp.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/evolutions/evolved_op.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "EvolvedOp.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/evolutions/evolved_op.py"
    },
    {
        "api_name": "reduce",
        "full_api_name": "EvolvedOp.reduce",
        "api_description": "",
        "api_signature": "reduce(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/evolutions/evolved_op.py"
    },
    {
        "api_name": "assign_parameters",
        "full_api_name": "EvolvedOp.assign_parameters",
        "api_description": "",
        "api_signature": "assign_parameters(self, param_dict)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/evolutions/evolved_op.py"
    },
    {
        "api_name": "eval",
        "full_api_name": "EvolvedOp.eval",
        "api_description": "",
        "api_signature": "eval(self, front)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/evolutions/evolved_op.py"
    },
    {
        "api_name": "to_matrix",
        "full_api_name": "EvolvedOp.to_matrix",
        "api_description": "",
        "api_signature": "to_matrix(self, massive)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/evolutions/evolved_op.py"
    },
    {
        "api_name": "to_matrix_op",
        "full_api_name": "EvolvedOp.to_matrix_op",
        "api_description": "Returns a ``MatrixOp`` equivalent to this Operator.",
        "api_signature": "to_matrix_op(self, massive)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/evolutions/evolved_op.py"
    },
    {
        "api_name": "log_i",
        "full_api_name": "EvolvedOp.log_i",
        "api_description": "",
        "api_signature": "log_i(self, massive)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/evolutions/evolved_op.py"
    },
    {
        "api_name": "to_instruction",
        "full_api_name": "EvolvedOp.to_instruction",
        "api_description": "",
        "api_signature": "to_instruction(self, massive)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/evolutions/evolved_op.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "MatrixEvolution.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/evolutions/matrix_evolution.py"
    },
    {
        "api_name": "convert",
        "full_api_name": "MatrixEvolution.convert",
        "api_description": "Traverse the operator, replacing ``EvolvedOps`` with ``CircuitOps`` containing\n``UnitaryGates`` or ``HamiltonianGates`` (if self.coeff is a ``ParameterExpression``)\nequalling the exponentiation of -i * operator. This is done by converting the\n``EvolvedOp.primitive`` to a ``MatrixOp`` and simply calling ``.exp_i()`` on that.\n\nArgs:\n    operator: The Operator to convert.\n\nReturns:\n    The converted operator.",
        "api_signature": "convert(self, operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/evolutions/matrix_evolution.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "EvolutionBase.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/evolutions/evolution_base.py"
    },
    {
        "api_name": "convert",
        "full_api_name": "EvolutionBase.convert",
        "api_description": "Traverse the operator, replacing any ``EvolutionOps`` with their equivalent evolution\n``CircuitOps``.\n\n Args:\n     operator: The Operator to convert.\n\nReturns:\n    The converted Operator, with ``EvolutionOps`` replaced by ``CircuitOps``.",
        "api_signature": "convert(self, operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/evolutions/evolution_base.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PauliTrotterEvolution.__init__",
        "api_description": "Args:\n    trotter_mode: A string ('trotter', 'suzuki', or 'qdrift') to pass to the\n        TrotterizationFactory, or a TrotterizationBase, indicating how to combine\n        individual Pauli evolution circuits to equal the exponentiation of the Pauli sum.\n    reps: How many Trotterization repetitions to make, to improve the approximation\n        accuracy.\n    # TODO uncomment when we implement Abelian grouped evolution.\n    # group_paulis: Whether to group Pauli sums into Abelian\n    #     sub-groups, so a single diagonalization circuit can be used for each group\n    #     rather than each Pauli.",
        "api_signature": "__init__(self, trotter_mode, reps)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/evolutions/pauli_trotter_evolution.py"
    },
    {
        "api_name": "trotter",
        "full_api_name": "PauliTrotterEvolution.trotter",
        "api_description": "TrotterizationBase used to evolve SummedOps.",
        "api_signature": "trotter(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/evolutions/pauli_trotter_evolution.py"
    },
    {
        "api_name": "trotter",
        "full_api_name": "PauliTrotterEvolution.trotter",
        "api_description": "Set TrotterizationBase used to evolve SummedOps.",
        "api_signature": "trotter(self, trotter)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/evolutions/pauli_trotter_evolution.py"
    },
    {
        "api_name": "convert",
        "full_api_name": "PauliTrotterEvolution.convert",
        "api_description": "Traverse the operator, replacing ``EvolvedOps`` with ``CircuitOps`` containing\nTrotterized evolutions equalling the exponentiation of -i * operator.\n\nArgs:\n    operator: The Operator to convert.\n\nReturns:\n    The converted operator.",
        "api_signature": "convert(self, operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/evolutions/pauli_trotter_evolution.py"
    },
    {
        "api_name": "_get_evolution_synthesis",
        "full_api_name": "PauliTrotterEvolution._get_evolution_synthesis",
        "api_description": "Return the ``EvolutionSynthesis`` corresponding to this Trotterization.",
        "api_signature": "_get_evolution_synthesis(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/evolutions/pauli_trotter_evolution.py"
    },
    {
        "api_name": "_recursive_convert",
        "full_api_name": "PauliTrotterEvolution._recursive_convert",
        "api_description": "",
        "api_signature": "_recursive_convert(self, operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/evolutions/pauli_trotter_evolution.py"
    },
    {
        "api_name": "evolution_for_pauli",
        "full_api_name": "PauliTrotterEvolution.evolution_for_pauli",
        "api_description": "Compute evolution Operator for a single Pauli using a ``PauliBasisChange``.\n\nArgs:\n    pauli_op: The ``PauliOp`` to evolve.\n\nReturns:\n    A ``PrimitiveOp``, either the evolution ``CircuitOp`` or a ``PauliOp`` equal to the\n    identity if pauli_op is the identity.",
        "api_signature": "evolution_for_pauli(self, pauli_op)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/evolutions/pauli_trotter_evolution.py"
    },
    {
        "api_name": "replacement_fn",
        "full_api_name": "PauliTrotterEvolution.replacement_fn",
        "api_description": "",
        "api_signature": "replacement_fn(cob_instr_op, dest_pauli_op)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/evolutions/pauli_trotter_evolution.py"
    },
    {
        "api_name": "evolution_for_abelian_paulisum",
        "full_api_name": "PauliTrotterEvolution.evolution_for_abelian_paulisum",
        "api_description": "Evolution for abelian pauli sum",
        "api_signature": "evolution_for_abelian_paulisum(self, op_sum)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/evolutions/pauli_trotter_evolution.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QDrift.__init__",
        "api_description": "Args:\n    reps: The number of times to repeat the Trotterization circuit.",
        "api_signature": "__init__(self, reps)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/evolutions/trotterizations/qdrift.py"
    },
    {
        "api_name": "convert",
        "full_api_name": "QDrift.convert",
        "api_description": "",
        "api_signature": "convert(self, operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/evolutions/trotterizations/qdrift.py"
    },
    {
        "api_name": "build",
        "full_api_name": "TrotterizationFactory.build",
        "api_description": "A factory for conveniently creating TrotterizationBase instances.\n\nArgs:\n    mode: One of 'trotter', 'suzuki', 'qdrift'\n    reps: The number of times to repeat the Trotterization circuit.\n\nReturns:\n    The desired TrotterizationBase instance.\n\nRaises:\n    ValueError: A string not in ['trotter', 'suzuki', 'qdrift'] is given for mode.",
        "api_signature": "build(mode, reps)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/evolutions/trotterizations/trotterization_factory.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Trotter.__init__",
        "api_description": "Args:\n    reps: The number of times to repeat the Trotterization circuit.",
        "api_signature": "__init__(self, reps)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/evolutions/trotterizations/trotter.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Suzuki.__init__",
        "api_description": "Args:\n    reps: The number of times to repeat the expansion circuit.\n    order: The order of the expansion to perform.",
        "api_signature": "__init__(self, reps, order)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/evolutions/trotterizations/suzuki.py"
    },
    {
        "api_name": "order",
        "full_api_name": "Suzuki.order",
        "api_description": "returns order",
        "api_signature": "order(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/evolutions/trotterizations/suzuki.py"
    },
    {
        "api_name": "order",
        "full_api_name": "Suzuki.order",
        "api_description": "sets order",
        "api_signature": "order(self, order)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/evolutions/trotterizations/suzuki.py"
    },
    {
        "api_name": "convert",
        "full_api_name": "Suzuki.convert",
        "api_description": "",
        "api_signature": "convert(self, operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/evolutions/trotterizations/suzuki.py"
    },
    {
        "api_name": "_recursive_expansion",
        "full_api_name": "Suzuki._recursive_expansion",
        "api_description": "Compute the list of pauli terms for a single slice of the Suzuki expansion\nfollowing the paper https://arxiv.org/pdf/quant-ph/0508139.pdf.\n\nArgs:\n    op_list: The slice's weighted Pauli list for the Suzuki expansion\n    evo_time: The parameter lambda as defined in said paper,\n        adjusted for the evolution time and the number of time slices\n    expansion_order: The order for the Suzuki expansion.\n    reps: The number of times to repeat the expansion circuit.\n\nReturns:\n    The evolution list after expansion.",
        "api_signature": "_recursive_expansion(op_list, evo_time, expansion_order, reps)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/evolutions/trotterizations/suzuki.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "TrotterizationBase.__init__",
        "api_description": "",
        "api_signature": "__init__(self, reps)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/evolutions/trotterizations/trotterization_base.py"
    },
    {
        "api_name": "reps",
        "full_api_name": "TrotterizationBase.reps",
        "api_description": "The number of repetitions to use in the Trotterization, improving the approximation\naccuracy.",
        "api_signature": "reps(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/evolutions/trotterizations/trotterization_base.py"
    },
    {
        "api_name": "reps",
        "full_api_name": "TrotterizationBase.reps",
        "api_description": "Set the number of repetitions to use in the Trotterization.",
        "api_signature": "reps(self, reps)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/evolutions/trotterizations/trotterization_base.py"
    },
    {
        "api_name": "convert",
        "full_api_name": "TrotterizationBase.convert",
        "api_description": "Convert a ``SummedOp`` into a ``ComposedOp`` or ``CircuitOp`` representing an\napproximation of e^-i*``op_sum``.\n\nArgs:\n    operator: The ``SummedOp`` to evolve.\n\nReturns:\n    The Operator approximating op_sum's evolution.\n\nRaises:\n    TypeError: A non-SummedOps Operator is passed into ``convert``.",
        "api_signature": "convert(self, operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/evolutions/trotterizations/trotterization_base.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "AerPauliExpectation.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/expectations/aer_pauli_expectation.py"
    },
    {
        "api_name": "convert",
        "full_api_name": "AerPauliExpectation.convert",
        "api_description": "Accept an Operator and return a new Operator with the Pauli measurements replaced by\nAerSnapshot-based expectation circuits.\n\nArgs:\n    operator: The operator to convert. If it contains non-hermitian terms, the\n        operator is decomposed into hermitian and anti-hermitian parts.\n\nReturns:\n    The converted operator.",
        "api_signature": "convert(self, operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/expectations/aer_pauli_expectation.py"
    },
    {
        "api_name": "_replace_pauli_sums",
        "full_api_name": "AerPauliExpectation._replace_pauli_sums",
        "api_description": "",
        "api_signature": "_replace_pauli_sums(cls, operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/expectations/aer_pauli_expectation.py"
    },
    {
        "api_name": "compute_variance",
        "full_api_name": "AerPauliExpectation.compute_variance",
        "api_description": "Compute the variance of the expectation estimator. Because Aer takes this expectation\nwith matrix multiplication, the estimation is exact and the variance is always 0,\nbut we need to return those values in a way which matches the Operator's structure.\n\nArgs:\n    exp_op: The full expectation value Operator after sampling.\n\nReturns:\n     The variances or lists thereof (if exp_op contains ListOps) of the expectation value\n     estimation, equal to 0.",
        "api_signature": "compute_variance(self, exp_op)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/expectations/aer_pauli_expectation.py"
    },
    {
        "api_name": "sum_variance",
        "full_api_name": "AerPauliExpectation.sum_variance",
        "api_description": "",
        "api_signature": "sum_variance(operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/expectations/aer_pauli_expectation.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ExpectationBase.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/expectations/expectation_base.py"
    },
    {
        "api_name": "convert",
        "full_api_name": "ExpectationBase.convert",
        "api_description": "Accept an Operator and return a new Operator with the measurements replaced by\nalternate methods to compute the expectation value.\n\nArgs:\n    operator: The operator to convert.\n\nReturns:\n    The converted operator.",
        "api_signature": "convert(self, operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/expectations/expectation_base.py"
    },
    {
        "api_name": "compute_variance",
        "full_api_name": "ExpectationBase.compute_variance",
        "api_description": "Compute the variance of the expectation estimator.\n\nArgs:\n    exp_op: The full expectation value Operator after sampling.\n\nReturns:\n     The variances or lists thereof (if exp_op contains ListOps) of the expectation value\n     estimation.",
        "api_signature": "compute_variance(self, exp_op)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/expectations/expectation_base.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "MatrixExpectation.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/expectations/matrix_expectation.py"
    },
    {
        "api_name": "convert",
        "full_api_name": "MatrixExpectation.convert",
        "api_description": "Accept an Operator and return a new Operator with the Pauli measurements replaced by\nMatrix based measurements.\n\nArgs:\n    operator: The operator to convert.\n\nReturns:\n    The converted operator.",
        "api_signature": "convert(self, operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/expectations/matrix_expectation.py"
    },
    {
        "api_name": "compute_variance",
        "full_api_name": "MatrixExpectation.compute_variance",
        "api_description": "Compute the variance of the expectation estimator. Because this expectation\nworks by matrix multiplication, the estimation is exact and the variance is\nalways 0, but we need to return those values in a way which matches the Operator's\nstructure.\n\nArgs:\n    exp_op: The full expectation value Operator.\n\nReturns:\n     The variances or lists thereof (if exp_op contains ListOps) of the expectation value\n     estimation, equal to 0.",
        "api_signature": "compute_variance(self, exp_op)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/expectations/matrix_expectation.py"
    },
    {
        "api_name": "sum_variance",
        "full_api_name": "MatrixExpectation.sum_variance",
        "api_description": "",
        "api_signature": "sum_variance(operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/expectations/matrix_expectation.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CVaRExpectation.__init__",
        "api_description": "Args:\n    alpha: The alpha value describing the quantile considered in the expectation value.\n    expectation: An expectation object to compute the expectation value. Defaults\n        to the PauliExpectation calculation.\n\nRaises:\n    NotImplementedError: If the ``expectation`` is an AerPauliExpecation.",
        "api_signature": "__init__(self, alpha, expectation)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/expectations/cvar_expectation.py"
    },
    {
        "api_name": "convert",
        "full_api_name": "CVaRExpectation.convert",
        "api_description": "Return an expression that computes the CVaR expectation upon calling ``eval``.\nArgs:\n    operator: The operator to convert.\n\nReturns:\n    The converted operator.",
        "api_signature": "convert(self, operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/expectations/cvar_expectation.py"
    },
    {
        "api_name": "replace_with_cvar",
        "full_api_name": "CVaRExpectation.replace_with_cvar",
        "api_description": "",
        "api_signature": "replace_with_cvar(operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/expectations/cvar_expectation.py"
    },
    {
        "api_name": "compute_variance",
        "full_api_name": "CVaRExpectation.compute_variance",
        "api_description": "Returns the variance of the CVaR calculation\n\nArgs:\n    exp_op: The operator whose evaluation yields an expectation\n        of some StateFn against a diagonal observable.\n\nReturns:\n    The variance of the CVaR estimate corresponding to the converted\n        exp_op.\nRaises:\n    ValueError: If the exp_op does not correspond to an expectation value.",
        "api_signature": "compute_variance(self, exp_op)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/expectations/cvar_expectation.py"
    },
    {
        "api_name": "cvar_variance",
        "full_api_name": "CVaRExpectation.cvar_variance",
        "api_description": "",
        "api_signature": "cvar_variance(operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/expectations/cvar_expectation.py"
    },
    {
        "api_name": "build",
        "full_api_name": "ExpectationFactory.build",
        "api_description": "A factory method for convenient automatic selection of an Expectation based on the\nOperator to be converted and backend used to sample the expectation value.\n\nArgs:\n    operator: The Operator whose expectation value will be taken.\n    backend: The backend which will be used to sample the expectation value.\n    include_custom: Whether the factory will include the (Aer) specific custom\n        expectations if their behavior against the backend might not be as expected.\n        For instance when using Aer qasm_simulator with paulis the Aer snapshot can\n        be used but the outcome lacks shot noise and hence does not intuitively behave\n        overall as people might expect when choosing a qasm_simulator. It is however\n        fast as long as the more state vector like behavior is acceptable.\n\nReturns:\n    The expectation algorithm which best fits the Operator and backend.\n\nRaises:\n    ValueError: If operator is not of a composition for which we know the best Expectation\n        method.",
        "api_signature": "build(operator, backend, include_custom)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/expectations/expectation_factory.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PauliExpectation.__init__",
        "api_description": "Args:\n    group_paulis: Whether to group the Pauli measurements into commuting sums, which all\n        have the same diagonalizing circuit.",
        "api_signature": "__init__(self, group_paulis)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/expectations/pauli_expectation.py"
    },
    {
        "api_name": "convert",
        "full_api_name": "PauliExpectation.convert",
        "api_description": "Accepts an Operator and returns a new Operator with the Pauli measurements replaced by\ndiagonal Pauli post-rotation based measurements so they can be evaluated by sampling and\naveraging.\n\nArgs:\n    operator: The operator to convert.\n\nReturns:\n    The converted operator.",
        "api_signature": "convert(self, operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/expectations/pauli_expectation.py"
    },
    {
        "api_name": "compute_variance",
        "full_api_name": "PauliExpectation.compute_variance",
        "api_description": "",
        "api_signature": "compute_variance(self, exp_op)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/expectations/pauli_expectation.py"
    },
    {
        "api_name": "sum_variance",
        "full_api_name": "PauliExpectation.sum_variance",
        "api_description": "",
        "api_signature": "sum_variance(operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/expectations/pauli_expectation.py"
    },
    {
        "api_name": "__init_subclass__",
        "full_api_name": "PrimitiveOp.__init_subclass__",
        "api_description": "",
        "api_signature": "__init_subclass__(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/primitive_op.py"
    },
    {
        "api_name": "__new__",
        "full_api_name": "PrimitiveOp.__new__",
        "api_description": "A factory method to produce the correct type of PrimitiveOp subclass\nbased on the primitive passed in. Primitive and coeff arguments are passed into\nsubclass's init() as-is automatically by new().\n\nArgs:\n    primitive: The operator primitive being wrapped.\n    coeff: A coefficient multiplying the primitive.\n\nReturns:\n    The appropriate PrimitiveOp subclass for ``primitive``.\n\nRaises:\n    TypeError: Unsupported primitive type passed.",
        "api_signature": "__new__(cls, primitive, coeff)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/primitive_op.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PrimitiveOp.__init__",
        "api_description": "Args:\n    primitive: The operator primitive being wrapped.\n    coeff: A coefficient multiplying the primitive.",
        "api_signature": "__init__(self, primitive, coeff)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/primitive_op.py"
    },
    {
        "api_name": "primitive",
        "full_api_name": "PrimitiveOp.primitive",
        "api_description": "The primitive defining the underlying function of the Operator.\n\nReturns:\n     The primitive object.",
        "api_signature": "primitive(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/primitive_op.py"
    },
    {
        "api_name": "coeff",
        "full_api_name": "PrimitiveOp.coeff",
        "api_description": "The scalar coefficient multiplying the Operator.\n\nReturns:\n      The coefficient.",
        "api_signature": "coeff(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/primitive_op.py"
    },
    {
        "api_name": "num_qubits",
        "full_api_name": "PrimitiveOp.num_qubits",
        "api_description": "",
        "api_signature": "num_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/primitive_op.py"
    },
    {
        "api_name": "settings",
        "full_api_name": "PrimitiveOp.settings",
        "api_description": "Return operator settings.",
        "api_signature": "settings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/primitive_op.py"
    },
    {
        "api_name": "primitive_strings",
        "full_api_name": "PrimitiveOp.primitive_strings",
        "api_description": "",
        "api_signature": "primitive_strings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/primitive_op.py"
    },
    {
        "api_name": "add",
        "full_api_name": "PrimitiveOp.add",
        "api_description": "",
        "api_signature": "add(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/primitive_op.py"
    },
    {
        "api_name": "adjoint",
        "full_api_name": "PrimitiveOp.adjoint",
        "api_description": "",
        "api_signature": "adjoint(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/primitive_op.py"
    },
    {
        "api_name": "equals",
        "full_api_name": "PrimitiveOp.equals",
        "api_description": "",
        "api_signature": "equals(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/primitive_op.py"
    },
    {
        "api_name": "mul",
        "full_api_name": "PrimitiveOp.mul",
        "api_description": "",
        "api_signature": "mul(self, scalar)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/primitive_op.py"
    },
    {
        "api_name": "tensor",
        "full_api_name": "PrimitiveOp.tensor",
        "api_description": "",
        "api_signature": "tensor(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/primitive_op.py"
    },
    {
        "api_name": "tensorpower",
        "full_api_name": "PrimitiveOp.tensorpower",
        "api_description": "",
        "api_signature": "tensorpower(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/primitive_op.py"
    },
    {
        "api_name": "compose",
        "full_api_name": "PrimitiveOp.compose",
        "api_description": "",
        "api_signature": "compose(self, other, permutation, front)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/primitive_op.py"
    },
    {
        "api_name": "_expand_dim",
        "full_api_name": "PrimitiveOp._expand_dim",
        "api_description": "",
        "api_signature": "_expand_dim(self, num_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/primitive_op.py"
    },
    {
        "api_name": "permute",
        "full_api_name": "PrimitiveOp.permute",
        "api_description": "",
        "api_signature": "permute(self, permutation)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/primitive_op.py"
    },
    {
        "api_name": "exp_i",
        "full_api_name": "PrimitiveOp.exp_i",
        "api_description": "Return Operator exponentiation, equaling e^(-i * op)",
        "api_signature": "exp_i(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/primitive_op.py"
    },
    {
        "api_name": "log_i",
        "full_api_name": "PrimitiveOp.log_i",
        "api_description": "Return a ``MatrixOp`` equivalent to log(H)/-i for this operator H. This\nfunction is the effective inverse of exp_i, equivalent to finding the Hermitian\nOperator which produces self when exponentiated.",
        "api_signature": "log_i(self, massive)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/primitive_op.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "PrimitiveOp.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/primitive_op.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "PrimitiveOp.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/primitive_op.py"
    },
    {
        "api_name": "eval",
        "full_api_name": "PrimitiveOp.eval",
        "api_description": "",
        "api_signature": "eval(self, front)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/primitive_op.py"
    },
    {
        "api_name": "parameters",
        "full_api_name": "PrimitiveOp.parameters",
        "api_description": "",
        "api_signature": "parameters(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/primitive_op.py"
    },
    {
        "api_name": "assign_parameters",
        "full_api_name": "PrimitiveOp.assign_parameters",
        "api_description": "",
        "api_signature": "assign_parameters(self, param_dict)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/primitive_op.py"
    },
    {
        "api_name": "reduce",
        "full_api_name": "PrimitiveOp.reduce",
        "api_description": "",
        "api_signature": "reduce(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/primitive_op.py"
    },
    {
        "api_name": "to_matrix",
        "full_api_name": "PrimitiveOp.to_matrix",
        "api_description": "",
        "api_signature": "to_matrix(self, massive)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/primitive_op.py"
    },
    {
        "api_name": "to_matrix_op",
        "full_api_name": "PrimitiveOp.to_matrix_op",
        "api_description": "Returns a ``MatrixOp`` equivalent to this Operator.",
        "api_signature": "to_matrix_op(self, massive)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/primitive_op.py"
    },
    {
        "api_name": "to_instruction",
        "full_api_name": "PrimitiveOp.to_instruction",
        "api_description": "Returns an ``Instruction`` equivalent to this Operator.",
        "api_signature": "to_instruction(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/primitive_op.py"
    },
    {
        "api_name": "to_circuit",
        "full_api_name": "PrimitiveOp.to_circuit",
        "api_description": "Returns a ``QuantumCircuit`` equivalent to this Operator.",
        "api_signature": "to_circuit(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/primitive_op.py"
    },
    {
        "api_name": "to_circuit_op",
        "full_api_name": "PrimitiveOp.to_circuit_op",
        "api_description": "Returns a ``CircuitOp`` equivalent to this Operator.",
        "api_signature": "to_circuit_op(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/primitive_op.py"
    },
    {
        "api_name": "to_pauli_op",
        "full_api_name": "PrimitiveOp.to_pauli_op",
        "api_description": "Returns a sum of ``PauliOp`` s equivalent to this Operator.",
        "api_signature": "to_pauli_op(self, massive)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/primitive_op.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PauliOp.__init__",
        "api_description": "Args:\n    primitive: The Pauli which defines the behavior of the underlying function.\n    coeff: A coefficient multiplying the primitive.\n\nRaises:\n    TypeError: invalid parameters.",
        "api_signature": "__init__(self, primitive, coeff)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/pauli_op.py"
    },
    {
        "api_name": "primitive_strings",
        "full_api_name": "PauliOp.primitive_strings",
        "api_description": "",
        "api_signature": "primitive_strings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/pauli_op.py"
    },
    {
        "api_name": "num_qubits",
        "full_api_name": "PauliOp.num_qubits",
        "api_description": "",
        "api_signature": "num_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/pauli_op.py"
    },
    {
        "api_name": "add",
        "full_api_name": "PauliOp.add",
        "api_description": "",
        "api_signature": "add(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/pauli_op.py"
    },
    {
        "api_name": "adjoint",
        "full_api_name": "PauliOp.adjoint",
        "api_description": "",
        "api_signature": "adjoint(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/pauli_op.py"
    },
    {
        "api_name": "equals",
        "full_api_name": "PauliOp.equals",
        "api_description": "",
        "api_signature": "equals(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/pauli_op.py"
    },
    {
        "api_name": "_expand_dim",
        "full_api_name": "PauliOp._expand_dim",
        "api_description": "",
        "api_signature": "_expand_dim(self, num_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/pauli_op.py"
    },
    {
        "api_name": "tensor",
        "full_api_name": "PauliOp.tensor",
        "api_description": "",
        "api_signature": "tensor(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/pauli_op.py"
    },
    {
        "api_name": "permute",
        "full_api_name": "PauliOp.permute",
        "api_description": "Permutes the sequence of Pauli matrices.\n\nArgs:\n    permutation: A list defining where each Pauli should be permuted. The Pauli at index\n        j of the primitive should be permuted to position permutation[j].\n\nReturns:\n      A new PauliOp representing the permuted operator. For operator (X ^ Y ^ Z) and\n      indices=[1,2,4], it returns (X ^ I ^ Y ^ Z ^ I).\n\nRaises:\n    OpflowError: if indices do not define a new index for each qubit.",
        "api_signature": "permute(self, permutation)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/pauli_op.py"
    },
    {
        "api_name": "compose",
        "full_api_name": "PauliOp.compose",
        "api_description": "",
        "api_signature": "compose(self, other, permutation, front)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/pauli_op.py"
    },
    {
        "api_name": "to_matrix",
        "full_api_name": "PauliOp.to_matrix",
        "api_description": "",
        "api_signature": "to_matrix(self, massive)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/pauli_op.py"
    },
    {
        "api_name": "to_spmatrix",
        "full_api_name": "PauliOp.to_spmatrix",
        "api_description": "Returns SciPy sparse matrix representation of the Operator.\n\nReturns:\n    CSR sparse matrix representation of the Operator.\n\nRaises:\n    ValueError: invalid parameters.",
        "api_signature": "to_spmatrix(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/pauli_op.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "PauliOp.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/pauli_op.py"
    },
    {
        "api_name": "eval",
        "full_api_name": "PauliOp.eval",
        "api_description": "",
        "api_signature": "eval(self, front)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/pauli_op.py"
    },
    {
        "api_name": "exp_i",
        "full_api_name": "PauliOp.exp_i",
        "api_description": "Return a ``CircuitOp`` equivalent to e^-iH for this operator H.",
        "api_signature": "exp_i(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/pauli_op.py"
    },
    {
        "api_name": "to_circuit",
        "full_api_name": "PauliOp.to_circuit",
        "api_description": "",
        "api_signature": "to_circuit(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/pauli_op.py"
    },
    {
        "api_name": "to_instruction",
        "full_api_name": "PauliOp.to_instruction",
        "api_description": "",
        "api_signature": "to_instruction(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/pauli_op.py"
    },
    {
        "api_name": "to_pauli_op",
        "full_api_name": "PauliOp.to_pauli_op",
        "api_description": "",
        "api_signature": "to_pauli_op(self, massive)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/pauli_op.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CircuitOp.__init__",
        "api_description": "Args:\n    primitive: The QuantumCircuit which defines the\n    behavior of the underlying function.\n    coeff: A coefficient multiplying the primitive\n\nRaises:\n    TypeError: Unsupported primitive, or primitive has ClassicalRegisters.",
        "api_signature": "__init__(self, primitive, coeff)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/circuit_op.py"
    },
    {
        "api_name": "primitive_strings",
        "full_api_name": "CircuitOp.primitive_strings",
        "api_description": "",
        "api_signature": "primitive_strings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/circuit_op.py"
    },
    {
        "api_name": "num_qubits",
        "full_api_name": "CircuitOp.num_qubits",
        "api_description": "",
        "api_signature": "num_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/circuit_op.py"
    },
    {
        "api_name": "add",
        "full_api_name": "CircuitOp.add",
        "api_description": "",
        "api_signature": "add(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/circuit_op.py"
    },
    {
        "api_name": "adjoint",
        "full_api_name": "CircuitOp.adjoint",
        "api_description": "",
        "api_signature": "adjoint(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/circuit_op.py"
    },
    {
        "api_name": "equals",
        "full_api_name": "CircuitOp.equals",
        "api_description": "",
        "api_signature": "equals(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/circuit_op.py"
    },
    {
        "api_name": "tensor",
        "full_api_name": "CircuitOp.tensor",
        "api_description": "",
        "api_signature": "tensor(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/circuit_op.py"
    },
    {
        "api_name": "compose",
        "full_api_name": "CircuitOp.compose",
        "api_description": "",
        "api_signature": "compose(self, other, permutation, front)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/circuit_op.py"
    },
    {
        "api_name": "to_matrix",
        "full_api_name": "CircuitOp.to_matrix",
        "api_description": "",
        "api_signature": "to_matrix(self, massive)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/circuit_op.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "CircuitOp.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/circuit_op.py"
    },
    {
        "api_name": "assign_parameters",
        "full_api_name": "CircuitOp.assign_parameters",
        "api_description": "",
        "api_signature": "assign_parameters(self, param_dict)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/circuit_op.py"
    },
    {
        "api_name": "eval",
        "full_api_name": "CircuitOp.eval",
        "api_description": "",
        "api_signature": "eval(self, front)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/circuit_op.py"
    },
    {
        "api_name": "to_circuit",
        "full_api_name": "CircuitOp.to_circuit",
        "api_description": "",
        "api_signature": "to_circuit(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/circuit_op.py"
    },
    {
        "api_name": "to_circuit_op",
        "full_api_name": "CircuitOp.to_circuit_op",
        "api_description": "",
        "api_signature": "to_circuit_op(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/circuit_op.py"
    },
    {
        "api_name": "to_instruction",
        "full_api_name": "CircuitOp.to_instruction",
        "api_description": "",
        "api_signature": "to_instruction(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/circuit_op.py"
    },
    {
        "api_name": "reduce",
        "full_api_name": "CircuitOp.reduce",
        "api_description": "",
        "api_signature": "reduce(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/circuit_op.py"
    },
    {
        "api_name": "_expand_dim",
        "full_api_name": "CircuitOp._expand_dim",
        "api_description": "",
        "api_signature": "_expand_dim(self, num_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/circuit_op.py"
    },
    {
        "api_name": "permute",
        "full_api_name": "CircuitOp.permute",
        "api_description": "Permute the qubits of the circuit.\n\nArgs:\n    permutation: A list defining where each qubit should be permuted. The qubit at index\n        j of the circuit should be permuted to position permutation[j].\n\nReturns:\n    A new CircuitOp containing the permuted circuit.",
        "api_signature": "permute(self, permutation)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/circuit_op.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PauliSumOp.__init__",
        "api_description": "Args:\n    primitive: The SparsePauliOp which defines the behavior of the underlying function.\n    coeff: A coefficient multiplying the primitive.\n    grouping_type: The type of grouping. If None, the operator is not grouped.\n\nRaises:\n    TypeError: invalid parameters.",
        "api_signature": "__init__(self, primitive, coeff, grouping_type)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/pauli_sum_op.py"
    },
    {
        "api_name": "primitive_strings",
        "full_api_name": "PauliSumOp.primitive_strings",
        "api_description": "",
        "api_signature": "primitive_strings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/pauli_sum_op.py"
    },
    {
        "api_name": "grouping_type",
        "full_api_name": "PauliSumOp.grouping_type",
        "api_description": "Returns: Type of Grouping",
        "api_signature": "grouping_type(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/pauli_sum_op.py"
    },
    {
        "api_name": "num_qubits",
        "full_api_name": "PauliSumOp.num_qubits",
        "api_description": "",
        "api_signature": "num_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/pauli_sum_op.py"
    },
    {
        "api_name": "coeffs",
        "full_api_name": "PauliSumOp.coeffs",
        "api_description": "Return the Pauli coefficients.",
        "api_signature": "coeffs(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/pauli_sum_op.py"
    },
    {
        "api_name": "settings",
        "full_api_name": "PauliSumOp.settings",
        "api_description": "Return operator settings.",
        "api_signature": "settings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/pauli_sum_op.py"
    },
    {
        "api_name": "matrix_iter",
        "full_api_name": "PauliSumOp.matrix_iter",
        "api_description": "Return a matrix representation iterator.\n\nThis is a lazy iterator that converts each term in the PauliSumOp\ninto a matrix as it is used. To convert to a single matrix use the\n:meth:`to_matrix` method.\n\nArgs:\n    sparse (bool): optionally return sparse CSR matrices if True,\n                   otherwise return Numpy array matrices\n                   (Default: False)\n\nReturns:\n    MatrixIterator: matrix iterator object for the PauliSumOp.",
        "api_signature": "matrix_iter(self, sparse)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/pauli_sum_op.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "MatrixIterator.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/pauli_sum_op.py"
    },
    {
        "api_name": "__getitem__",
        "full_api_name": "MatrixIterator.__getitem__",
        "api_description": "",
        "api_signature": "__getitem__(self, key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/pauli_sum_op.py"
    },
    {
        "api_name": "add",
        "full_api_name": "add",
        "api_description": "",
        "api_signature": "add(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/pauli_sum_op.py"
    },
    {
        "api_name": "mul",
        "full_api_name": "mul",
        "api_description": "",
        "api_signature": "mul(self, scalar)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/pauli_sum_op.py"
    },
    {
        "api_name": "adjoint",
        "full_api_name": "adjoint",
        "api_description": "",
        "api_signature": "adjoint(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/pauli_sum_op.py"
    },
    {
        "api_name": "equals",
        "full_api_name": "equals",
        "api_description": "",
        "api_signature": "equals(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/pauli_sum_op.py"
    },
    {
        "api_name": "_expand_dim",
        "full_api_name": "_expand_dim",
        "api_description": "",
        "api_signature": "_expand_dim(self, num_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/pauli_sum_op.py"
    },
    {
        "api_name": "tensor",
        "full_api_name": "tensor",
        "api_description": "",
        "api_signature": "tensor(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/pauli_sum_op.py"
    },
    {
        "api_name": "permute",
        "full_api_name": "permute",
        "api_description": "Permutes the sequence of ``PauliSumOp``.\n\nArgs:\n    permutation: A list defining where each Pauli should be permuted. The Pauli at index\n        j of the primitive should be permuted to position permutation[j].\n\nReturns:\n      A new PauliSumOp representing the permuted operator. For operator (X ^ Y ^ Z) and\n      indices=[1,2,4], it returns (X ^ I ^ Y ^ Z ^ I).\n\nRaises:\n    OpflowError: if indices do not define a new index for each qubit.",
        "api_signature": "permute(self, permutation)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/pauli_sum_op.py"
    },
    {
        "api_name": "compose",
        "full_api_name": "compose",
        "api_description": "",
        "api_signature": "compose(self, other, permutation, front)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/pauli_sum_op.py"
    },
    {
        "api_name": "to_matrix",
        "full_api_name": "to_matrix",
        "api_description": "",
        "api_signature": "to_matrix(self, massive)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/pauli_sum_op.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/pauli_sum_op.py"
    },
    {
        "api_name": "format_sign",
        "full_api_name": "format_sign",
        "api_description": "",
        "api_signature": "format_sign(x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/pauli_sum_op.py"
    },
    {
        "api_name": "format_number",
        "full_api_name": "format_number",
        "api_description": "",
        "api_signature": "format_number(x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/pauli_sum_op.py"
    },
    {
        "api_name": "eval",
        "full_api_name": "eval",
        "api_description": "",
        "api_signature": "eval(self, front)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/pauli_sum_op.py"
    },
    {
        "api_name": "exp_i",
        "full_api_name": "exp_i",
        "api_description": "Return a ``CircuitOp`` equivalent to e^-iH for this operator H.",
        "api_signature": "exp_i(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/pauli_sum_op.py"
    },
    {
        "api_name": "to_instruction",
        "full_api_name": "to_instruction",
        "api_description": "",
        "api_signature": "to_instruction(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/pauli_sum_op.py"
    },
    {
        "api_name": "to_pauli_op",
        "full_api_name": "to_pauli_op",
        "api_description": "",
        "api_signature": "to_pauli_op(self, massive)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/pauli_sum_op.py"
    },
    {
        "api_name": "to_native",
        "full_api_name": "to_native",
        "api_description": "",
        "api_signature": "to_native(x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/pauli_sum_op.py"
    },
    {
        "api_name": "__getitem__",
        "full_api_name": "__getitem__",
        "api_description": "Allows array-indexing style access to the ``PauliSumOp``.\n\nArgs:\n    offset: The index of ``PauliSumOp``.\n\nReturns:\n    The ``PauliSumOp`` at index ``offset``,",
        "api_signature": "__getitem__(self, offset)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/pauli_sum_op.py"
    },
    {
        "api_name": "__iter__",
        "full_api_name": "__iter__",
        "api_description": "",
        "api_signature": "__iter__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/pauli_sum_op.py"
    },
    {
        "api_name": "__len__",
        "full_api_name": "__len__",
        "api_description": "Length of ``SparsePauliOp``.\n\nReturns:\n    An int equal to the length of SparsePauliOp.",
        "api_signature": "__len__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/pauli_sum_op.py"
    },
    {
        "api_name": "reduce",
        "full_api_name": "reduce",
        "api_description": "Simplify the primitive ``SparsePauliOp``.\n\nArgs:\n    atol: Absolute tolerance for checking if coefficients are zero (Default: 1e-8).\n    rtol: Relative tolerance for checking if coefficients are zero (Default: 1e-5).\n\nReturns:\n    The simplified ``PauliSumOp``.",
        "api_signature": "reduce(self, atol, rtol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/pauli_sum_op.py"
    },
    {
        "api_name": "to_spmatrix",
        "full_api_name": "to_spmatrix",
        "api_description": "Returns SciPy sparse matrix representation of the ``PauliSumOp``.\n\nReturns:\n    CSR sparse matrix representation of the ``PauliSumOp``.\n\nRaises:\n    ValueError: invalid parameters.",
        "api_signature": "to_spmatrix(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/pauli_sum_op.py"
    },
    {
        "api_name": "from_list",
        "full_api_name": "from_list",
        "api_description": "Construct from a pauli_list with the form [(pauli_str, coeffs)]\n\nArgs:\n    pauli_list: A list of Tuple of pauli_str and coefficient.\n    coeff: A coefficient multiplying the primitive.\n    dtype: The dtype to use to construct the internal SparsePauliOp.\n        Defaults to ``complex``.\n\nReturns:\n    The PauliSumOp constructed from the pauli_list.",
        "api_signature": "from_list(cls, pauli_list, coeff, dtype)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/pauli_sum_op.py"
    },
    {
        "api_name": "is_zero",
        "full_api_name": "is_zero",
        "api_description": "Return this operator is zero operator or not.",
        "api_signature": "is_zero(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/pauli_sum_op.py"
    },
    {
        "api_name": "is_hermitian",
        "full_api_name": "is_hermitian",
        "api_description": "",
        "api_signature": "is_hermitian(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/pauli_sum_op.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "TaperedPauliSumOp.__init__",
        "api_description": "Args:\n    primitive: The SparsePauliOp which defines the behavior of the underlying function.\n    z2_symmetries: Z2 symmetries which the Operator has.\n    coeff: A coefficient multiplying the primitive.\n\nRaises:\n    TypeError: invalid parameters.",
        "api_signature": "__init__(self, primitive, z2_symmetries, coeff)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/tapered_pauli_sum_op.py"
    },
    {
        "api_name": "z2_symmetries",
        "full_api_name": "TaperedPauliSumOp.z2_symmetries",
        "api_description": "Z2 symmetries which the Operator has.\n\nReturns:\n    The Z2 Symmetries.",
        "api_signature": "z2_symmetries(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/tapered_pauli_sum_op.py"
    },
    {
        "api_name": "settings",
        "full_api_name": "TaperedPauliSumOp.settings",
        "api_description": "Return operator settings.",
        "api_signature": "settings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/tapered_pauli_sum_op.py"
    },
    {
        "api_name": "assign_parameters",
        "full_api_name": "TaperedPauliSumOp.assign_parameters",
        "api_description": "",
        "api_signature": "assign_parameters(self, param_dict)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/tapered_pauli_sum_op.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Z2Symmetries.__init__",
        "api_description": "Args:\n    symmetries: the list of Pauli objects representing the Z_2 symmetries\n    sq_paulis: the list of single - qubit Pauli objects to construct the\n                             Clifford operators\n    sq_list: the list of support of the single-qubit Pauli objects used to build\n                         the Clifford operators\n    tapering_values: values determines the sector.\n    tol: Tolerance threshold for ignoring real and complex parts of a coefficient.\n\nRaises:\n    OpflowError: Invalid paulis",
        "api_signature": "__init__(self, symmetries, sq_paulis, sq_list, tapering_values, tol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/tapered_pauli_sum_op.py"
    },
    {
        "api_name": "tol",
        "full_api_name": "Z2Symmetries.tol",
        "api_description": "Tolerance threshold for ignoring real and complex parts of a coefficient.",
        "api_signature": "tol(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/tapered_pauli_sum_op.py"
    },
    {
        "api_name": "tol",
        "full_api_name": "Z2Symmetries.tol",
        "api_description": "Set the tolerance threshold for ignoring real and complex parts of a coefficient.",
        "api_signature": "tol(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/tapered_pauli_sum_op.py"
    },
    {
        "api_name": "symmetries",
        "full_api_name": "Z2Symmetries.symmetries",
        "api_description": "return symmetries",
        "api_signature": "symmetries(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/tapered_pauli_sum_op.py"
    },
    {
        "api_name": "sq_paulis",
        "full_api_name": "Z2Symmetries.sq_paulis",
        "api_description": "returns sq paulis",
        "api_signature": "sq_paulis(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/tapered_pauli_sum_op.py"
    },
    {
        "api_name": "cliffords",
        "full_api_name": "Z2Symmetries.cliffords",
        "api_description": "Get clifford operators, build based on symmetries and single-qubit X.\nReturns:\n    a list of unitaries used to diagonalize the Hamiltonian.",
        "api_signature": "cliffords(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/tapered_pauli_sum_op.py"
    },
    {
        "api_name": "sq_list",
        "full_api_name": "Z2Symmetries.sq_list",
        "api_description": "returns sq list",
        "api_signature": "sq_list(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/tapered_pauli_sum_op.py"
    },
    {
        "api_name": "tapering_values",
        "full_api_name": "Z2Symmetries.tapering_values",
        "api_description": "returns tapering values",
        "api_signature": "tapering_values(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/tapered_pauli_sum_op.py"
    },
    {
        "api_name": "tapering_values",
        "full_api_name": "Z2Symmetries.tapering_values",
        "api_description": "set tapering values",
        "api_signature": "tapering_values(self, new_value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/tapered_pauli_sum_op.py"
    },
    {
        "api_name": "settings",
        "full_api_name": "Z2Symmetries.settings",
        "api_description": "Return operator settings.",
        "api_signature": "settings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/tapered_pauli_sum_op.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "Z2Symmetries.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/tapered_pauli_sum_op.py"
    },
    {
        "api_name": "copy",
        "full_api_name": "Z2Symmetries.copy",
        "api_description": "Get a copy of self.\nReturns:\n    copy",
        "api_signature": "copy(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/tapered_pauli_sum_op.py"
    },
    {
        "api_name": "is_empty",
        "full_api_name": "Z2Symmetries.is_empty",
        "api_description": "Check the z2_symmetries is empty or not.\nReturns:\n    Empty or not",
        "api_signature": "is_empty(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/tapered_pauli_sum_op.py"
    },
    {
        "api_name": "find_Z2_symmetries",
        "full_api_name": "Z2Symmetries.find_Z2_symmetries",
        "api_description": "Finds Z2 Pauli-type symmetries of an Operator.\n\nReturns:\n    a z2_symmetries object contains symmetries, single-qubit X, single-qubit list.",
        "api_signature": "find_Z2_symmetries(cls, operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/tapered_pauli_sum_op.py"
    },
    {
        "api_name": "convert_clifford",
        "full_api_name": "Z2Symmetries.convert_clifford",
        "api_description": "This method operates the first part of the tapering.\nIt converts the operator by composing it with the clifford unitaries defined in the current\nsymmetry.\n\nArgs:\n    operator: to-be-tapered operator\n\nReturns:\n    :class:`PauliSumOp` corresponding to the converted operator.\n\nRaises:\n    OpflowError: Z2 symmetries, single qubit pauli and single qubit list cannot be empty",
        "api_signature": "convert_clifford(self, operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/tapered_pauli_sum_op.py"
    },
    {
        "api_name": "taper_clifford",
        "full_api_name": "Z2Symmetries.taper_clifford",
        "api_description": "This method operates the second part of the tapering.\nThis function assumes that the input operators have already been transformed using\n:meth:`convert_clifford`. The redundant qubits due to the symmetries are dropped and\nreplaced by their two possible eigenvalues.\nThe `tapering_values` will be stored into the resulted operator for a record.\n\nArgs:\n    operator: Partially tapered operator resulting from a call to :meth:`convert_clifford`\n\nReturns:\n    If tapering_values is None: [:class:`PauliSumOp`]; otherwise, :class:`PauliSumOp`\n\nRaises:\n    OpflowError: Z2 symmetries, single qubit pauli and single qubit list cannot be empty",
        "api_signature": "taper_clifford(self, operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/tapered_pauli_sum_op.py"
    },
    {
        "api_name": "taper",
        "full_api_name": "Z2Symmetries.taper",
        "api_description": "Taper an operator based on the z2_symmetries info and sector defined by `tapering_values`.\nThe `tapering_values` will be stored into the resulted operator for a record.\n\nThe tapering is a two-step algorithm which first converts the operator into a\n:class:`PauliSumOp` with same eigenvalues but where some qubits are only acted upon\nwith the Pauli operators I or X.\nThe number M of these redundant qubits is equal to the number M of identified symmetries.\n\nThe second step of the reduction consists in replacing these qubits with the possible\neigenvalues of the corresponding Pauli X, giving 2^M new operators with M less qubits.\nIf an eigenvalue sector was previously identified for the solution, then this reduces to\n1 new operator with M less qubits.\n\nArgs:\n    operator: the to-be-tapered operator\n\nReturns:\n    If tapering_values is None: [:class:`PauliSumOp`]; otherwise, :class:`PauliSumOp`\n\nRaises:\n    OpflowError: Z2 symmetries, single qubit pauli and single qubit list cannot be empty",
        "api_signature": "taper(self, operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/tapered_pauli_sum_op.py"
    },
    {
        "api_name": "_taper",
        "full_api_name": "Z2Symmetries._taper",
        "api_description": "",
        "api_signature": "_taper(self, op, curr_tapering_values)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/tapered_pauli_sum_op.py"
    },
    {
        "api_name": "consistent_tapering",
        "full_api_name": "Z2Symmetries.consistent_tapering",
        "api_description": "Tapering the `operator` with the same manner of how this tapered operator\nis created. i.e., using the same Cliffords and tapering values.\n\nArgs:\n    operator: the to-be-tapered operator\n\nReturns:\n    The tapered operator\n\nRaises:\n    OpflowError: The given operator does not commute with the symmetry",
        "api_signature": "consistent_tapering(self, operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/tapered_pauli_sum_op.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "Z2Symmetries.__eq__",
        "api_description": "Overload `==` operation to evaluate equality between Z2Symmetries.\n\nArgs:\n    other: The `Z2Symmetries` to compare to self.\n\nReturns:\n    A bool equal to the equality of self and other.",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/tapered_pauli_sum_op.py"
    },
    {
        "api_name": "_kernel_F2",
        "full_api_name": "_kernel_F2",
        "api_description": "Computes the kernel of a binary matrix on the binary finite field\nArgs:\n    matrix_in (numpy.ndarray): binary matrix\nReturns:\n    The list of kernel vectors",
        "api_signature": "_kernel_F2(matrix_in)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/tapered_pauli_sum_op.py"
    },
    {
        "api_name": "_row_echelon_F2",
        "full_api_name": "_row_echelon_F2",
        "api_description": "Computes the row Echelon form of a binary matrix on the binary finite field\nArgs:\n    matrix_in (numpy.ndarray): binary matrix\nReturns:\n    Matrix_in in Echelon row form",
        "api_signature": "_row_echelon_F2(matrix_in)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/tapered_pauli_sum_op.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "MatrixOp.__init__",
        "api_description": "Args:\n    primitive: The matrix-like object which defines the behavior of the underlying function.\n    coeff: A coefficient multiplying the primitive\n\nRaises:\n    TypeError: invalid parameters.\n    ValueError: invalid parameters.",
        "api_signature": "__init__(self, primitive, coeff)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/matrix_op.py"
    },
    {
        "api_name": "primitive_strings",
        "full_api_name": "MatrixOp.primitive_strings",
        "api_description": "",
        "api_signature": "primitive_strings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/matrix_op.py"
    },
    {
        "api_name": "num_qubits",
        "full_api_name": "MatrixOp.num_qubits",
        "api_description": "",
        "api_signature": "num_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/matrix_op.py"
    },
    {
        "api_name": "add",
        "full_api_name": "MatrixOp.add",
        "api_description": "",
        "api_signature": "add(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/matrix_op.py"
    },
    {
        "api_name": "adjoint",
        "full_api_name": "MatrixOp.adjoint",
        "api_description": "",
        "api_signature": "adjoint(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/matrix_op.py"
    },
    {
        "api_name": "equals",
        "full_api_name": "MatrixOp.equals",
        "api_description": "",
        "api_signature": "equals(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/matrix_op.py"
    },
    {
        "api_name": "_expand_dim",
        "full_api_name": "MatrixOp._expand_dim",
        "api_description": "",
        "api_signature": "_expand_dim(self, num_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/matrix_op.py"
    },
    {
        "api_name": "tensor",
        "full_api_name": "MatrixOp.tensor",
        "api_description": "",
        "api_signature": "tensor(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/matrix_op.py"
    },
    {
        "api_name": "compose",
        "full_api_name": "MatrixOp.compose",
        "api_description": "",
        "api_signature": "compose(self, other, permutation, front)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/matrix_op.py"
    },
    {
        "api_name": "permute",
        "full_api_name": "MatrixOp.permute",
        "api_description": "Creates a new MatrixOp that acts on the permuted qubits.\n\nArgs:\n    permutation: A list defining where each qubit should be permuted. The qubit at index\n        j should be permuted to position permutation[j].\n\nReturns:\n    A new MatrixOp representing the permuted operator.\n\nRaises:\n    OpflowError: if indices do not define a new index for each qubit.",
        "api_signature": "permute(self, permutation)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/matrix_op.py"
    },
    {
        "api_name": "to_matrix",
        "full_api_name": "MatrixOp.to_matrix",
        "api_description": "",
        "api_signature": "to_matrix(self, massive)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/matrix_op.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "MatrixOp.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/matrix_op.py"
    },
    {
        "api_name": "eval",
        "full_api_name": "MatrixOp.eval",
        "api_description": "",
        "api_signature": "eval(self, front)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/matrix_op.py"
    },
    {
        "api_name": "exp_i",
        "full_api_name": "MatrixOp.exp_i",
        "api_description": "Return a ``CircuitOp`` equivalent to e^-iH for this operator H",
        "api_signature": "exp_i(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/matrix_op.py"
    },
    {
        "api_name": "to_matrix_op",
        "full_api_name": "MatrixOp.to_matrix_op",
        "api_description": "",
        "api_signature": "to_matrix_op(self, massive)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/matrix_op.py"
    },
    {
        "api_name": "to_instruction",
        "full_api_name": "MatrixOp.to_instruction",
        "api_description": "",
        "api_signature": "to_instruction(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/primitive_ops/matrix_op.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "OperatorStateFn.__init__",
        "api_description": "Args:\n    primitive: The ``OperatorBase`` which defines the behavior of the underlying State\n        function.\n    coeff: A coefficient by which to multiply the state function\n    is_measurement: Whether the StateFn is a measurement operator",
        "api_signature": "__init__(self, primitive, coeff, is_measurement)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/operator_state_fn.py"
    },
    {
        "api_name": "primitive_strings",
        "full_api_name": "OperatorStateFn.primitive_strings",
        "api_description": "",
        "api_signature": "primitive_strings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/operator_state_fn.py"
    },
    {
        "api_name": "num_qubits",
        "full_api_name": "OperatorStateFn.num_qubits",
        "api_description": "",
        "api_signature": "num_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/operator_state_fn.py"
    },
    {
        "api_name": "add",
        "full_api_name": "OperatorStateFn.add",
        "api_description": "",
        "api_signature": "add(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/operator_state_fn.py"
    },
    {
        "api_name": "adjoint",
        "full_api_name": "OperatorStateFn.adjoint",
        "api_description": "",
        "api_signature": "adjoint(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/operator_state_fn.py"
    },
    {
        "api_name": "_expand_dim",
        "full_api_name": "OperatorStateFn._expand_dim",
        "api_description": "",
        "api_signature": "_expand_dim(self, num_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/operator_state_fn.py"
    },
    {
        "api_name": "permute",
        "full_api_name": "OperatorStateFn.permute",
        "api_description": "",
        "api_signature": "permute(self, permutation)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/operator_state_fn.py"
    },
    {
        "api_name": "tensor",
        "full_api_name": "OperatorStateFn.tensor",
        "api_description": "",
        "api_signature": "tensor(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/operator_state_fn.py"
    },
    {
        "api_name": "to_density_matrix",
        "full_api_name": "OperatorStateFn.to_density_matrix",
        "api_description": "Return numpy matrix of density operator, warn if more than 16 qubits\nto force the user to set\nmassive=True if they want such a large matrix. Generally big methods like\nthis should require the use of a\nconverter, but in this case a convenience method for quick hacking and\naccess to classical tools is\nappropriate.",
        "api_signature": "to_density_matrix(self, massive)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/operator_state_fn.py"
    },
    {
        "api_name": "to_matrix_op",
        "full_api_name": "OperatorStateFn.to_matrix_op",
        "api_description": "Return a MatrixOp for this operator.",
        "api_signature": "to_matrix_op(self, massive)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/operator_state_fn.py"
    },
    {
        "api_name": "to_matrix",
        "full_api_name": "OperatorStateFn.to_matrix",
        "api_description": "Note: this does not return a density matrix, it returns a classical matrix\ncontaining the quantum or classical vector representing the evaluation of the state\nfunction on each binary basis state. Do not assume this is is a normalized quantum or\nclassical probability vector. If we allowed this to return a density matrix,\nthen we would need to change the definition of composition to be ~Op @ StateFn @ Op for\nthose cases, whereas by this methodology we can ensure that composition always means Op\n@ StateFn.\n\nReturn numpy vector of state vector, warn if more than 16 qubits to force the user to set\nmassive=True if they want such a large vector.\n\nArgs:\n    massive: Whether to allow large conversions, e.g. creating a matrix representing\n        over 16 qubits.\n\nReturns:\n    np.ndarray: Vector of state vector\n\nRaises:\n    ValueError: Invalid parameters.",
        "api_signature": "to_matrix(self, massive)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/operator_state_fn.py"
    },
    {
        "api_name": "diag_over_tree",
        "full_api_name": "OperatorStateFn.diag_over_tree",
        "api_description": "",
        "api_signature": "diag_over_tree(op)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/operator_state_fn.py"
    },
    {
        "api_name": "to_circuit_op",
        "full_api_name": "OperatorStateFn.to_circuit_op",
        "api_description": "Return ``StateFnCircuit`` corresponding to this StateFn. Ignore for now because this is\nundefined. TODO maybe call to_pauli_op and diagonalize here, but that could be very\ninefficient, e.g. splitting one Stabilizer measurement into hundreds of 1 qubit Paulis.",
        "api_signature": "to_circuit_op(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/operator_state_fn.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "OperatorStateFn.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/operator_state_fn.py"
    },
    {
        "api_name": "eval",
        "full_api_name": "OperatorStateFn.eval",
        "api_description": "",
        "api_signature": "eval(self, front)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/operator_state_fn.py"
    },
    {
        "api_name": "sample",
        "full_api_name": "OperatorStateFn.sample",
        "api_description": "",
        "api_signature": "sample(self, shots, massive, reverse_endianness)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/operator_state_fn.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SparseVectorStateFn.__init__",
        "api_description": "Args:\n    primitive: The underlying sparse vector.\n    coeff: A coefficient multiplying the state function.\n    is_measurement: Whether the StateFn is a measurement operator\n\nRaises:\n    ValueError: If the primitive is not a column vector.\n    ValueError: If the number of elements in the primitive is not a power of 2.",
        "api_signature": "__init__(self, primitive, coeff, is_measurement)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/sparse_vector_state_fn.py"
    },
    {
        "api_name": "primitive_strings",
        "full_api_name": "SparseVectorStateFn.primitive_strings",
        "api_description": "",
        "api_signature": "primitive_strings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/sparse_vector_state_fn.py"
    },
    {
        "api_name": "num_qubits",
        "full_api_name": "SparseVectorStateFn.num_qubits",
        "api_description": "",
        "api_signature": "num_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/sparse_vector_state_fn.py"
    },
    {
        "api_name": "add",
        "full_api_name": "SparseVectorStateFn.add",
        "api_description": "",
        "api_signature": "add(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/sparse_vector_state_fn.py"
    },
    {
        "api_name": "adjoint",
        "full_api_name": "SparseVectorStateFn.adjoint",
        "api_description": "",
        "api_signature": "adjoint(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/sparse_vector_state_fn.py"
    },
    {
        "api_name": "equals",
        "full_api_name": "SparseVectorStateFn.equals",
        "api_description": "",
        "api_signature": "equals(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/sparse_vector_state_fn.py"
    },
    {
        "api_name": "to_dict_fn",
        "full_api_name": "SparseVectorStateFn.to_dict_fn",
        "api_description": "Convert this state function to a ``DictStateFn``.\n\nReturns:\n    A new DictStateFn equivalent to ``self``.",
        "api_signature": "to_dict_fn(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/sparse_vector_state_fn.py"
    },
    {
        "api_name": "to_matrix",
        "full_api_name": "SparseVectorStateFn.to_matrix",
        "api_description": "",
        "api_signature": "to_matrix(self, massive)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/sparse_vector_state_fn.py"
    },
    {
        "api_name": "to_matrix_op",
        "full_api_name": "SparseVectorStateFn.to_matrix_op",
        "api_description": "",
        "api_signature": "to_matrix_op(self, massive)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/sparse_vector_state_fn.py"
    },
    {
        "api_name": "to_spmatrix",
        "full_api_name": "SparseVectorStateFn.to_spmatrix",
        "api_description": "",
        "api_signature": "to_spmatrix(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/sparse_vector_state_fn.py"
    },
    {
        "api_name": "to_circuit_op",
        "full_api_name": "SparseVectorStateFn.to_circuit_op",
        "api_description": "Convert this state function to a ``CircuitStateFn``.",
        "api_signature": "to_circuit_op(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/sparse_vector_state_fn.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "SparseVectorStateFn.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/sparse_vector_state_fn.py"
    },
    {
        "api_name": "eval",
        "full_api_name": "SparseVectorStateFn.eval",
        "api_description": "",
        "api_signature": "eval(self, front)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/sparse_vector_state_fn.py"
    },
    {
        "api_name": "sample",
        "full_api_name": "SparseVectorStateFn.sample",
        "api_description": "",
        "api_signature": "sample(self, shots, massive, reverse_endianness)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/sparse_vector_state_fn.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "VectorStateFn.__init__",
        "api_description": "Args:\n    primitive: The ``Statevector``, NumPy array, or list, which defines the behavior of\n        the underlying function.\n    coeff: A coefficient multiplying the state function.\n    is_measurement: Whether the StateFn is a measurement operator",
        "api_signature": "__init__(self, primitive, coeff, is_measurement)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/vector_state_fn.py"
    },
    {
        "api_name": "primitive_strings",
        "full_api_name": "VectorStateFn.primitive_strings",
        "api_description": "",
        "api_signature": "primitive_strings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/vector_state_fn.py"
    },
    {
        "api_name": "num_qubits",
        "full_api_name": "VectorStateFn.num_qubits",
        "api_description": "",
        "api_signature": "num_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/vector_state_fn.py"
    },
    {
        "api_name": "add",
        "full_api_name": "VectorStateFn.add",
        "api_description": "",
        "api_signature": "add(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/vector_state_fn.py"
    },
    {
        "api_name": "adjoint",
        "full_api_name": "VectorStateFn.adjoint",
        "api_description": "",
        "api_signature": "adjoint(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/vector_state_fn.py"
    },
    {
        "api_name": "permute",
        "full_api_name": "VectorStateFn.permute",
        "api_description": "",
        "api_signature": "permute(self, permutation)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/vector_state_fn.py"
    },
    {
        "api_name": "to_dict_fn",
        "full_api_name": "VectorStateFn.to_dict_fn",
        "api_description": "Creates the equivalent state function of type DictStateFn.\n\nReturns:\n    A new DictStateFn equivalent to ``self``.",
        "api_signature": "to_dict_fn(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/vector_state_fn.py"
    },
    {
        "api_name": "_expand_dim",
        "full_api_name": "VectorStateFn._expand_dim",
        "api_description": "",
        "api_signature": "_expand_dim(self, num_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/vector_state_fn.py"
    },
    {
        "api_name": "tensor",
        "full_api_name": "VectorStateFn.tensor",
        "api_description": "",
        "api_signature": "tensor(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/vector_state_fn.py"
    },
    {
        "api_name": "to_density_matrix",
        "full_api_name": "VectorStateFn.to_density_matrix",
        "api_description": "",
        "api_signature": "to_density_matrix(self, massive)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/vector_state_fn.py"
    },
    {
        "api_name": "to_matrix",
        "full_api_name": "VectorStateFn.to_matrix",
        "api_description": "",
        "api_signature": "to_matrix(self, massive)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/vector_state_fn.py"
    },
    {
        "api_name": "to_matrix_op",
        "full_api_name": "VectorStateFn.to_matrix_op",
        "api_description": "",
        "api_signature": "to_matrix_op(self, massive)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/vector_state_fn.py"
    },
    {
        "api_name": "to_circuit_op",
        "full_api_name": "VectorStateFn.to_circuit_op",
        "api_description": "Return ``StateFnCircuit`` corresponding to this StateFn.",
        "api_signature": "to_circuit_op(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/vector_state_fn.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "VectorStateFn.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/vector_state_fn.py"
    },
    {
        "api_name": "eval",
        "full_api_name": "VectorStateFn.eval",
        "api_description": "",
        "api_signature": "eval(self, front)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/vector_state_fn.py"
    },
    {
        "api_name": "sample",
        "full_api_name": "VectorStateFn.sample",
        "api_description": "",
        "api_signature": "sample(self, shots, massive, reverse_endianness)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/vector_state_fn.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CVaRMeasurement.__init__",
        "api_description": "Args:\n    primitive: The ``OperatorBase`` which defines the diagonal operator\n               measurement.\n    coeff: A coefficient by which to multiply the state function\n    alpha: A real-valued parameter between 0 and 1 which specifies the\n           fraction of observed samples to include when computing the\n           objective value. alpha = 1 corresponds to a standard observable\n           expectation value. alpha = 0 corresponds to only using the single\n           sample with the lowest energy. alpha = 0.5 corresponds to ranking each\n           observation by lowest energy and using the best\n\nRaises:\n    ValueError: TODO remove that this raises an error\n    ValueError: If alpha is not in [0, 1].\n    OpflowError: If the primitive is not diagonal.",
        "api_signature": "__init__(self, primitive, alpha, coeff)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/cvar_measurement.py"
    },
    {
        "api_name": "alpha",
        "full_api_name": "CVaRMeasurement.alpha",
        "api_description": "A real-valued parameter between 0 and 1 which specifies the\n   fraction of observed samples to include when computing the\n   objective value. alpha = 1 corresponds to a standard observable\n   expectation value. alpha = 0 corresponds to only using the single\n   sample with the lowest energy. alpha = 0.5 corresponds to ranking each\n   observation by lowest energy and using the best half.\n\nReturns:\n    The parameter alpha which was given at initialization",
        "api_signature": "alpha(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/cvar_measurement.py"
    },
    {
        "api_name": "settings",
        "full_api_name": "CVaRMeasurement.settings",
        "api_description": "Return settings.",
        "api_signature": "settings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/cvar_measurement.py"
    },
    {
        "api_name": "add",
        "full_api_name": "CVaRMeasurement.add",
        "api_description": "",
        "api_signature": "add(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/cvar_measurement.py"
    },
    {
        "api_name": "adjoint",
        "full_api_name": "CVaRMeasurement.adjoint",
        "api_description": "The adjoint of a CVaRMeasurement is not defined.\n\nReturns:\n    Does not return anything, raises an error.\n\nRaises:\n    OpflowError: The adjoint of a CVaRMeasurement is not defined.",
        "api_signature": "adjoint(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/cvar_measurement.py"
    },
    {
        "api_name": "mul",
        "full_api_name": "CVaRMeasurement.mul",
        "api_description": "",
        "api_signature": "mul(self, scalar)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/cvar_measurement.py"
    },
    {
        "api_name": "tensor",
        "full_api_name": "CVaRMeasurement.tensor",
        "api_description": "",
        "api_signature": "tensor(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/cvar_measurement.py"
    },
    {
        "api_name": "to_density_matrix",
        "full_api_name": "CVaRMeasurement.to_density_matrix",
        "api_description": "Not defined.",
        "api_signature": "to_density_matrix(self, massive)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/cvar_measurement.py"
    },
    {
        "api_name": "to_matrix_op",
        "full_api_name": "CVaRMeasurement.to_matrix_op",
        "api_description": "Not defined.",
        "api_signature": "to_matrix_op(self, massive)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/cvar_measurement.py"
    },
    {
        "api_name": "to_matrix",
        "full_api_name": "CVaRMeasurement.to_matrix",
        "api_description": "Not defined.",
        "api_signature": "to_matrix(self, massive)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/cvar_measurement.py"
    },
    {
        "api_name": "to_circuit_op",
        "full_api_name": "CVaRMeasurement.to_circuit_op",
        "api_description": "Not defined.",
        "api_signature": "to_circuit_op(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/cvar_measurement.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "CVaRMeasurement.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/cvar_measurement.py"
    },
    {
        "api_name": "eval",
        "full_api_name": "CVaRMeasurement.eval",
        "api_description": "Given the energies of each sampled measurement outcome (H_i) as well as the\nsampling probability of each measurement outcome (p_i, we can compute the\nCVaR as H_j + 1/\u03b1*(sum_i<j p_i*(H_i - H_j)). Note that index j corresponds\nto the measurement outcome such that only some of the samples with\nmeasurement outcome j will be used in computing CVaR. Note also that the\nsampling probabilities serve as an alternative to knowing the counts of each\nobservation.\n\nThis computation is broken up into two subroutines. One which evaluates each\nmeasurement outcome and determines the sampling probabilities of each. And one\nwhich carries out the above calculation. The computation is split up this way\nto enable a straightforward calculation of the variance of this estimator.\n\nArgs:\n    front: A StateFn or primitive which specifies the results of evaluating\n              a quantum state.\n\nReturns:\n    The CVaR of the diagonal observable specified by self.primitive and\n        the sampled quantum state described by the inputs\n        (energies, probabilities). For index j (described above), the CVaR\n        is computed as H_j + 1/\u03b1*(sum_i<j p_i*(H_i - H_j))",
        "api_signature": "eval(self, front)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/cvar_measurement.py"
    },
    {
        "api_name": "eval_variance",
        "full_api_name": "CVaRMeasurement.eval_variance",
        "api_description": "Given the energies of each sampled measurement outcome (H_i) as well as the\nsampling probability of each measurement outcome (p_i, we can compute the\nvariance of the CVaR estimator as\nH_j^2 + 1/\u03b1 * (sum_i<j p_i*(H_i^2 - H_j^2)).\nThis follows from the definition that Var[X] = E[X^2] - E[X]^2.\nIn this case, X = E[<bi|H|bi>], where H is the diagonal observable and bi\ncorresponds to measurement outcome i. Given this, E[X^2] = E[<bi|H|bi>^2]\n\nArgs:\n    front: A StateFn or primitive which specifies the results of evaluating\n              a quantum state.\n\nReturns:\n    The Var[CVaR] of the diagonal observable specified by self.primitive\n        and the sampled quantum state described by the inputs\n        (energies, probabilities). For index j (described above), the CVaR\n        is computed as H_j^2 + 1/\u03b1*(sum_i<j p_i*(H_i^2 - H_j^2))",
        "api_signature": "eval_variance(self, front)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/cvar_measurement.py"
    },
    {
        "api_name": "get_outcome_energies_probabilities",
        "full_api_name": "CVaRMeasurement.get_outcome_energies_probabilities",
        "api_description": "In order to compute the  CVaR of an observable expectation, we require\nthe energies of each sampled measurement outcome as well as the sampling\nprobability of each measurement outcome. Note that the counts for each\nmeasurement outcome will also suffice (and this is often how the CVaR\nis presented).\n\nArgs:\n    front: A StateFn or a primitive which defines a StateFn.\n           This input holds the results of a sampled/simulated circuit.\n\nReturns:\n    Two lists of equal length. `energies` contains the energy of each\n        unique measurement outcome computed against the diagonal observable\n        stored in self.primitive. `probabilities` contains the corresponding\n        sampling probability for each measurement outcome in `energies`.\n\nRaises:\n    ValueError: front isn't a DictStateFn or VectorStateFn",
        "api_signature": "get_outcome_energies_probabilities(self, front)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/cvar_measurement.py"
    },
    {
        "api_name": "compute_cvar",
        "full_api_name": "CVaRMeasurement.compute_cvar",
        "api_description": "Given the energies of each sampled measurement outcome (H_i) as well as the\nsampling probability of each measurement outcome (p_i, we can compute the\nCVaR. Note that the sampling probabilities serve as an alternative to knowing\nthe counts of each observation and that the input energies are assumed to be\nsorted in increasing order.\n\nConsider the outcome with index j, such that only some of the samples with\nmeasurement outcome j will be used in computing CVaR. The CVaR calculation\ncan then be separated into two parts. First we sum each of the energies for\noutcomes i < j, weighted by the probability of observing that outcome (i.e\nthe normalized counts). Second, we add the energy for outcome j, weighted by\nthe difference (\u03b1  - \\sum_i<j p_i)\n\nArgs:\n    energies: A list containing the energies (H_i) of each sample measurement\n              outcome, sorted in increasing order.\n    probabilities: The sampling probabilities (p_i) for each corresponding\n                   measurement outcome.\n\nReturns:\n    The CVaR of the diagonal observable specified by self.primitive and\n        the sampled quantum state described by the inputs\n        (energies, probabilities). For index j (described above), the CVaR\n        is computed as H_j + 1/\u03b1 * (sum_i<j p_i*(H_i - H_j))\n\nRaises:\n    ValueError: front isn't a DictStateFn or VectorStateFn",
        "api_signature": "compute_cvar(self, energies, probabilities)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/cvar_measurement.py"
    },
    {
        "api_name": "traverse",
        "full_api_name": "CVaRMeasurement.traverse",
        "api_description": "Apply the convert_fn to the internal primitive if the primitive is an Operator (as in\nthe case of ``OperatorStateFn``). Otherwise do nothing. Used by converters.\n\nArgs:\n    convert_fn: The function to apply to the internal OperatorBase.\n    coeff: A coefficient to multiply by after applying convert_fn.\n        If it is None, self.coeff is used instead.\n\nReturns:\n    The converted StateFn.",
        "api_signature": "traverse(self, convert_fn, coeff)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/cvar_measurement.py"
    },
    {
        "api_name": "sample",
        "full_api_name": "CVaRMeasurement.sample",
        "api_description": "",
        "api_signature": "sample(self, shots, massive, reverse_endianness)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/cvar_measurement.py"
    },
    {
        "api_name": "_check_is_diagonal",
        "full_api_name": "_check_is_diagonal",
        "api_description": "Check whether ``operator`` is diagonal.\n\nArgs:\n    operator: The operator to check for diagonality.\n\nReturns:\n    True, if the operator is diagonal, False otherwise.\n\nRaises:\n    OpflowError: If the operator is not diagonal.",
        "api_signature": "_check_is_diagonal(operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/cvar_measurement.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "DictStateFn.__init__",
        "api_description": "Args:\n    primitive: The dict, single bitstring (if defining a basis sate), or Qiskit\n        Result, which defines the behavior of the underlying function.\n    coeff: A coefficient by which to multiply the state function.\n    is_measurement: Whether the StateFn is a measurement operator.\n    from_operator: if True the StateFn is derived from OperatorStateFn. (Default: False)\n\nRaises:\n    TypeError: invalid parameters.",
        "api_signature": "__init__(self, primitive, coeff, is_measurement, from_operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/dict_state_fn.py"
    },
    {
        "api_name": "primitive_strings",
        "full_api_name": "DictStateFn.primitive_strings",
        "api_description": "",
        "api_signature": "primitive_strings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/dict_state_fn.py"
    },
    {
        "api_name": "num_qubits",
        "full_api_name": "DictStateFn.num_qubits",
        "api_description": "",
        "api_signature": "num_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/dict_state_fn.py"
    },
    {
        "api_name": "settings",
        "full_api_name": "DictStateFn.settings",
        "api_description": "Return settings.",
        "api_signature": "settings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/dict_state_fn.py"
    },
    {
        "api_name": "add",
        "full_api_name": "DictStateFn.add",
        "api_description": "",
        "api_signature": "add(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/dict_state_fn.py"
    },
    {
        "api_name": "adjoint",
        "full_api_name": "DictStateFn.adjoint",
        "api_description": "",
        "api_signature": "adjoint(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/dict_state_fn.py"
    },
    {
        "api_name": "permute",
        "full_api_name": "DictStateFn.permute",
        "api_description": "",
        "api_signature": "permute(self, permutation)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/dict_state_fn.py"
    },
    {
        "api_name": "perm",
        "full_api_name": "DictStateFn.perm",
        "api_description": "",
        "api_signature": "perm(key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/dict_state_fn.py"
    },
    {
        "api_name": "_expand_dim",
        "full_api_name": "DictStateFn._expand_dim",
        "api_description": "",
        "api_signature": "_expand_dim(self, num_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/dict_state_fn.py"
    },
    {
        "api_name": "tensor",
        "full_api_name": "DictStateFn.tensor",
        "api_description": "",
        "api_signature": "tensor(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/dict_state_fn.py"
    },
    {
        "api_name": "to_density_matrix",
        "full_api_name": "DictStateFn.to_density_matrix",
        "api_description": "",
        "api_signature": "to_density_matrix(self, massive)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/dict_state_fn.py"
    },
    {
        "api_name": "to_matrix",
        "full_api_name": "DictStateFn.to_matrix",
        "api_description": "",
        "api_signature": "to_matrix(self, massive)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/dict_state_fn.py"
    },
    {
        "api_name": "to_spmatrix",
        "full_api_name": "DictStateFn.to_spmatrix",
        "api_description": "Same as to_matrix, but returns csr sparse matrix.\n\nReturns:\n    CSR sparse matrix representation of the State function.\n\nRaises:\n    ValueError: invalid parameters.",
        "api_signature": "to_spmatrix(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/dict_state_fn.py"
    },
    {
        "api_name": "to_spmatrix_op",
        "full_api_name": "DictStateFn.to_spmatrix_op",
        "api_description": "Convert this state function to a ``SparseVectorStateFn``.",
        "api_signature": "to_spmatrix_op(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/dict_state_fn.py"
    },
    {
        "api_name": "to_circuit_op",
        "full_api_name": "DictStateFn.to_circuit_op",
        "api_description": "Convert this state function to a ``CircuitStateFn``.",
        "api_signature": "to_circuit_op(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/dict_state_fn.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "DictStateFn.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/dict_state_fn.py"
    },
    {
        "api_name": "eval",
        "full_api_name": "DictStateFn.eval",
        "api_description": "",
        "api_signature": "eval(self, front)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/dict_state_fn.py"
    },
    {
        "api_name": "sample",
        "full_api_name": "DictStateFn.sample",
        "api_description": "",
        "api_signature": "sample(self, shots, massive, reverse_endianness)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/dict_state_fn.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CircuitStateFn.__init__",
        "api_description": "Args:\n    primitive: The ``QuantumCircuit`` (or ``Instruction``, which will be converted) which\n        defines the behavior of the underlying function.\n    coeff: A coefficient multiplying the state function.\n    is_measurement: Whether the StateFn is a measurement operator.\n    from_operator: if True the StateFn is derived from OperatorStateFn. (Default: False)\n\nRaises:\n    TypeError: Unsupported primitive, or primitive has ClassicalRegisters.",
        "api_signature": "__init__(self, primitive, coeff, is_measurement, from_operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/circuit_state_fn.py"
    },
    {
        "api_name": "from_dict",
        "full_api_name": "CircuitStateFn.from_dict",
        "api_description": "Construct the CircuitStateFn from a dict mapping strings to probability densities.\n\nArgs:\n    density_dict: The dict representing the desired state.\n\nReturns:\n    The CircuitStateFn created from the dict.",
        "api_signature": "from_dict(density_dict)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/circuit_state_fn.py"
    },
    {
        "api_name": "from_vector",
        "full_api_name": "CircuitStateFn.from_vector",
        "api_description": "Construct the CircuitStateFn from a vector representing the statevector.\n\nArgs:\n    statevector: The statevector representing the desired state.\n\nReturns:\n    The CircuitStateFn created from the vector.",
        "api_signature": "from_vector(statevector)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/circuit_state_fn.py"
    },
    {
        "api_name": "primitive_strings",
        "full_api_name": "CircuitStateFn.primitive_strings",
        "api_description": "",
        "api_signature": "primitive_strings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/circuit_state_fn.py"
    },
    {
        "api_name": "settings",
        "full_api_name": "CircuitStateFn.settings",
        "api_description": "Return settings.",
        "api_signature": "settings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/circuit_state_fn.py"
    },
    {
        "api_name": "num_qubits",
        "full_api_name": "CircuitStateFn.num_qubits",
        "api_description": "",
        "api_signature": "num_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/circuit_state_fn.py"
    },
    {
        "api_name": "add",
        "full_api_name": "CircuitStateFn.add",
        "api_description": "",
        "api_signature": "add(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/circuit_state_fn.py"
    },
    {
        "api_name": "adjoint",
        "full_api_name": "CircuitStateFn.adjoint",
        "api_description": "",
        "api_signature": "adjoint(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/circuit_state_fn.py"
    },
    {
        "api_name": "compose",
        "full_api_name": "CircuitStateFn.compose",
        "api_description": "",
        "api_signature": "compose(self, other, permutation, front)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/circuit_state_fn.py"
    },
    {
        "api_name": "tensor",
        "full_api_name": "CircuitStateFn.tensor",
        "api_description": "Return tensor product between self and other, overloaded by ``^``.\nNote: You must be conscious of Qiskit's big-endian bit printing convention.\nMeaning, Plus.tensor(Zero)\nproduces a \\|+\u27e9 on qubit 0 and a \\|0\u27e9 on qubit 1, or \\|+\u27e9\u2a02\\|0\u27e9, but would produce\na QuantumCircuit like:\n\n    \\|0\u27e9--\n    \\|+\u27e9--\n\nBecause Terra prints circuits and results with qubit 0 at the end of the string or circuit.\n\nArgs:\n    other: The ``OperatorBase`` to tensor product with self.\n\nReturns:\n    An ``OperatorBase`` equivalent to the tensor product of self and other.",
        "api_signature": "tensor(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/circuit_state_fn.py"
    },
    {
        "api_name": "to_density_matrix",
        "full_api_name": "CircuitStateFn.to_density_matrix",
        "api_description": "Return numpy matrix of density operator, warn if more than 16 qubits to\nforce the user to set\nmassive=True if they want such a large matrix. Generally big methods like this\nshould require the use of a\nconverter, but in this case a convenience method for quick hacking and access\nto classical tools is\nappropriate.",
        "api_signature": "to_density_matrix(self, massive)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/circuit_state_fn.py"
    },
    {
        "api_name": "to_matrix",
        "full_api_name": "CircuitStateFn.to_matrix",
        "api_description": "",
        "api_signature": "to_matrix(self, massive)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/circuit_state_fn.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "CircuitStateFn.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/circuit_state_fn.py"
    },
    {
        "api_name": "assign_parameters",
        "full_api_name": "CircuitStateFn.assign_parameters",
        "api_description": "",
        "api_signature": "assign_parameters(self, param_dict)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/circuit_state_fn.py"
    },
    {
        "api_name": "eval",
        "full_api_name": "CircuitStateFn.eval",
        "api_description": "",
        "api_signature": "eval(self, front)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/circuit_state_fn.py"
    },
    {
        "api_name": "to_circuit",
        "full_api_name": "CircuitStateFn.to_circuit",
        "api_description": "Return QuantumCircuit representing StateFn",
        "api_signature": "to_circuit(self, meas)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/circuit_state_fn.py"
    },
    {
        "api_name": "to_circuit_op",
        "full_api_name": "CircuitStateFn.to_circuit_op",
        "api_description": "Return ``StateFnCircuit`` corresponding to this StateFn.",
        "api_signature": "to_circuit_op(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/circuit_state_fn.py"
    },
    {
        "api_name": "to_instruction",
        "full_api_name": "CircuitStateFn.to_instruction",
        "api_description": "Return Instruction corresponding to primitive.",
        "api_signature": "to_instruction(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/circuit_state_fn.py"
    },
    {
        "api_name": "sample",
        "full_api_name": "CircuitStateFn.sample",
        "api_description": "Sample the state function as a normalized probability distribution. Returns dict of\nbitstrings in order of probability, with values being probability.",
        "api_signature": "sample(self, shots, massive, reverse_endianness)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/circuit_state_fn.py"
    },
    {
        "api_name": "reduce",
        "full_api_name": "CircuitStateFn.reduce",
        "api_description": "",
        "api_signature": "reduce(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/circuit_state_fn.py"
    },
    {
        "api_name": "_expand_dim",
        "full_api_name": "CircuitStateFn._expand_dim",
        "api_description": "",
        "api_signature": "_expand_dim(self, num_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/circuit_state_fn.py"
    },
    {
        "api_name": "permute",
        "full_api_name": "CircuitStateFn.permute",
        "api_description": "Permute the qubits of the circuit.\n\nArgs:\n    permutation: A list defining where each qubit should be permuted. The qubit at index\n        j of the circuit should be permuted to position permutation[j].\n\nReturns:\n    A new CircuitStateFn containing the permuted circuit.",
        "api_signature": "permute(self, permutation)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/circuit_state_fn.py"
    },
    {
        "api_name": "__init_subclass__",
        "full_api_name": "StateFn.__init_subclass__",
        "api_description": "",
        "api_signature": "__init_subclass__(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/state_fn.py"
    },
    {
        "api_name": "__new__",
        "full_api_name": "StateFn.__new__",
        "api_description": "A factory method to produce the correct type of StateFn subclass\nbased on the primitive passed in. Primitive, coeff, and is_measurement arguments\nare passed into subclass's init() as-is automatically by new().\n\nArgs:\n    primitive: The primitive which defines the behavior of the underlying State function.\n    coeff: A coefficient by which the state function is multiplied.\n    is_measurement: Whether the StateFn is a measurement operator\n\nReturns:\n    The appropriate StateFn subclass for ``primitive``.\n\nRaises:\n    TypeError: Unsupported primitive type passed.",
        "api_signature": "__new__(cls, primitive, coeff, is_measurement)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/state_fn.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "StateFn.__init__",
        "api_description": "Args:\n    primitive: The primitive which defines the behavior of the underlying State function.\n    coeff: A coefficient by which the state function is multiplied.\n    is_measurement: Whether the StateFn is a measurement operator",
        "api_signature": "__init__(self, primitive, coeff, is_measurement)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/state_fn.py"
    },
    {
        "api_name": "primitive",
        "full_api_name": "StateFn.primitive",
        "api_description": "The primitive which defines the behavior of the underlying State function.",
        "api_signature": "primitive(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/state_fn.py"
    },
    {
        "api_name": "coeff",
        "full_api_name": "StateFn.coeff",
        "api_description": "A coefficient by which the state function is multiplied.",
        "api_signature": "coeff(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/state_fn.py"
    },
    {
        "api_name": "is_measurement",
        "full_api_name": "StateFn.is_measurement",
        "api_description": "Whether the StateFn object is a measurement Operator.",
        "api_signature": "is_measurement(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/state_fn.py"
    },
    {
        "api_name": "settings",
        "full_api_name": "StateFn.settings",
        "api_description": "Return settings.",
        "api_signature": "settings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/state_fn.py"
    },
    {
        "api_name": "primitive_strings",
        "full_api_name": "StateFn.primitive_strings",
        "api_description": "",
        "api_signature": "primitive_strings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/state_fn.py"
    },
    {
        "api_name": "num_qubits",
        "full_api_name": "StateFn.num_qubits",
        "api_description": "",
        "api_signature": "num_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/state_fn.py"
    },
    {
        "api_name": "add",
        "full_api_name": "StateFn.add",
        "api_description": "",
        "api_signature": "add(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/state_fn.py"
    },
    {
        "api_name": "adjoint",
        "full_api_name": "StateFn.adjoint",
        "api_description": "",
        "api_signature": "adjoint(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/state_fn.py"
    },
    {
        "api_name": "_expand_dim",
        "full_api_name": "StateFn._expand_dim",
        "api_description": "",
        "api_signature": "_expand_dim(self, num_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/state_fn.py"
    },
    {
        "api_name": "permute",
        "full_api_name": "StateFn.permute",
        "api_description": "Permute the qubits of the state function.\n\nArgs:\n    permutation: A list defining where each qubit should be permuted. The qubit at index\n        j of the circuit should be permuted to position permutation[j].\n\nReturns:\n    A new StateFn containing the permuted primitive.",
        "api_signature": "permute(self, permutation)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/state_fn.py"
    },
    {
        "api_name": "equals",
        "full_api_name": "StateFn.equals",
        "api_description": "",
        "api_signature": "equals(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/state_fn.py"
    },
    {
        "api_name": "mul",
        "full_api_name": "StateFn.mul",
        "api_description": "",
        "api_signature": "mul(self, scalar)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/state_fn.py"
    },
    {
        "api_name": "tensor",
        "full_api_name": "StateFn.tensor",
        "api_description": "Return tensor product between self and other, overloaded by ``^``.\nNote: You must be conscious of Qiskit's big-endian bit printing\nconvention. Meaning, Plus.tensor(Zero)\nproduces a \\|+\u27e9 on qubit 0 and a \\|0\u27e9 on qubit 1, or \\|+\u27e9\u2a02\\|0\u27e9, but\nwould produce a QuantumCircuit like\n\n    \\|0\u27e9--\n    \\|+\u27e9--\n\nBecause Terra prints circuits and results with qubit 0\nat the end of the string or circuit.\n\nArgs:\n    other: The ``OperatorBase`` to tensor product with self.\n\nReturns:\n    An ``OperatorBase`` equivalent to the tensor product of self and other.",
        "api_signature": "tensor(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/state_fn.py"
    },
    {
        "api_name": "tensorpower",
        "full_api_name": "StateFn.tensorpower",
        "api_description": "",
        "api_signature": "tensorpower(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/state_fn.py"
    },
    {
        "api_name": "_expand_shorter_operator_and_permute",
        "full_api_name": "StateFn._expand_shorter_operator_and_permute",
        "api_description": "",
        "api_signature": "_expand_shorter_operator_and_permute(self, other, permutation)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/state_fn.py"
    },
    {
        "api_name": "to_matrix",
        "full_api_name": "StateFn.to_matrix",
        "api_description": "",
        "api_signature": "to_matrix(self, massive)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/state_fn.py"
    },
    {
        "api_name": "to_density_matrix",
        "full_api_name": "StateFn.to_density_matrix",
        "api_description": "Return matrix representing product of StateFn evaluated on pairs of basis states.\nOverridden by child classes.\n\nArgs:\n    massive: Whether to allow large conversions, e.g. creating a matrix representing\n        over 16 qubits.\n\nReturns:\n    The NumPy array representing the density matrix of the State function.\n\nRaises:\n    ValueError: If massive is set to False, and exponentially large computation is needed.",
        "api_signature": "to_density_matrix(self, massive)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/state_fn.py"
    },
    {
        "api_name": "compose",
        "full_api_name": "StateFn.compose",
        "api_description": "Composition (Linear algebra-style: A@B(x) = A(B(x))) is not well defined for states\nin the binary function model, but is well defined for measurements.\n\nArgs:\n    other: The Operator to compose with self.\n    permutation: ``List[int]`` which defines permutation on other operator.\n    front: If front==True, return ``other.compose(self)``.\n\nReturns:\n    An Operator equivalent to the function composition of self and other.\n\nRaises:\n    ValueError: If self is not a measurement, it cannot be composed from the right.",
        "api_signature": "compose(self, other, permutation, front)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/state_fn.py"
    },
    {
        "api_name": "power",
        "full_api_name": "StateFn.power",
        "api_description": "Compose with Self Multiple Times, undefined for StateFns.\n\nArgs:\n    exponent: The number of times to compose self with self.\n\nRaises:\n    ValueError: This function is not defined for StateFns.",
        "api_signature": "power(self, exponent)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/state_fn.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "StateFn.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/state_fn.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "StateFn.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/state_fn.py"
    },
    {
        "api_name": "eval",
        "full_api_name": "StateFn.eval",
        "api_description": "",
        "api_signature": "eval(self, front)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/state_fn.py"
    },
    {
        "api_name": "parameters",
        "full_api_name": "StateFn.parameters",
        "api_description": "",
        "api_signature": "parameters(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/state_fn.py"
    },
    {
        "api_name": "assign_parameters",
        "full_api_name": "StateFn.assign_parameters",
        "api_description": "",
        "api_signature": "assign_parameters(self, param_dict)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/state_fn.py"
    },
    {
        "api_name": "reduce",
        "full_api_name": "StateFn.reduce",
        "api_description": "",
        "api_signature": "reduce(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/state_fn.py"
    },
    {
        "api_name": "traverse",
        "full_api_name": "StateFn.traverse",
        "api_description": "Apply the convert_fn to the internal primitive if the primitive is an Operator (as in\nthe case of ``OperatorStateFn``). Otherwise do nothing. Used by converters.\n\nArgs:\n    convert_fn: The function to apply to the internal OperatorBase.\n    coeff: A coefficient to multiply by after applying convert_fn.\n        If it is None, self.coeff is used instead.\n\nReturns:\n    The converted StateFn.",
        "api_signature": "traverse(self, convert_fn, coeff)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/state_fn.py"
    },
    {
        "api_name": "to_matrix_op",
        "full_api_name": "StateFn.to_matrix_op",
        "api_description": "Return a ``VectorStateFn`` for this ``StateFn``.\n\nArgs:\n    massive: Whether to allow large conversions, e.g. creating a matrix representing\n        over 16 qubits.\n\nReturns:\n    A VectorStateFn equivalent to self.",
        "api_signature": "to_matrix_op(self, massive)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/state_fn.py"
    },
    {
        "api_name": "to_circuit_op",
        "full_api_name": "StateFn.to_circuit_op",
        "api_description": "Returns a ``CircuitOp`` equivalent to this Operator.",
        "api_signature": "to_circuit_op(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/state_fn.py"
    },
    {
        "api_name": "sample",
        "full_api_name": "StateFn.sample",
        "api_description": "Sample the state function as a normalized probability distribution. Returns dict of\nbitstrings in order of probability, with values being probability.\n\nArgs:\n    shots: The number of samples to take to approximate the State function.\n    massive: Whether to allow large conversions, e.g. creating a matrix representing\n        over 16 qubits.\n    reverse_endianness: Whether to reverse the endianness of the bitstrings in the return\n        dict to match Terra's big-endianness.\n\nReturns:\n    A dict containing pairs sampled strings from the State function and sampling\n    frequency divided by shots.",
        "api_signature": "sample(self, shots, massive, reverse_endianness)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/state_fns/state_fn.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QFIBase.__init__",
        "api_description": "Args:\n    qfi_method: The method used to compute the state/probability gradient. Can be either\n        a :class:`CircuitQFI` instance or one of the following pre-defined strings\n        ``'lin_comb_full'``, ``'overlap_diag'``` or ``'overlap_block_diag'```.\nRaises:\n    ValueError: if ``qfi_method`` is neither a ``CircuitQFI`` object nor one of the\n        predefined strings.",
        "api_signature": "__init__(self, qfi_method)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/qfi_base.py"
    },
    {
        "api_name": "qfi_method",
        "full_api_name": "QFIBase.qfi_method",
        "api_description": "Returns ``CircuitQFI``.\n\nReturns:\n    ``CircuitQFI``.",
        "api_signature": "qfi_method(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/qfi_base.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "DerivativeBase.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/derivative_base.py"
    },
    {
        "api_name": "convert",
        "full_api_name": "DerivativeBase.convert",
        "api_description": "Args:\n    operator: The operator we are taking the gradient, Hessian or QFI of\n    params: The parameters we are taking the gradient, Hessian or QFI with respect to.\n\nReturns:\n    An operator whose evaluation yields the gradient, Hessian or QFI.\n\nRaises:\n    ValueError: If ``params`` contains a parameter not present in ``operator``.",
        "api_signature": "convert(self, operator, params)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/derivative_base.py"
    },
    {
        "api_name": "gradient_wrapper",
        "full_api_name": "DerivativeBase.gradient_wrapper",
        "api_description": "Get a callable function which provides the respective gradient, Hessian or QFI for given\nparameter values. This callable can be used as gradient function for optimizers.\n\nArgs:\n    operator: The operator for which we want to get the gradient, Hessian or QFI.\n    bind_params: The operator parameters to which the parameter values are assigned.\n    grad_params: The parameters with respect to which we are taking the gradient, Hessian\n        or QFI. If grad_params = None, then grad_params = bind_params\n    backend: The quantum backend or QuantumInstance to use to evaluate the gradient,\n        Hessian or QFI.\n    expectation: The expectation converter to be used. If none is set then\n        `PauliExpectation()` is used.\n\nReturns:\n    Function to compute a gradient, Hessian or QFI. The function\n    takes an iterable as argument which holds the parameter values.",
        "api_signature": "gradient_wrapper(self, operator, bind_params, grad_params, backend, expectation)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/derivative_base.py"
    },
    {
        "api_name": "gradient_fn",
        "full_api_name": "DerivativeBase.gradient_fn",
        "api_description": "",
        "api_signature": "gradient_fn(p_values)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/derivative_base.py"
    },
    {
        "api_name": "parameter_expression_grad",
        "full_api_name": "DerivativeBase.parameter_expression_grad",
        "api_description": "Get the derivative of a parameter expression w.r.t. the given parameter.\n\nArgs:\n    param_expr: The Parameter Expression for which we compute the derivative\n    param: Parameter w.r.t. which we want to take the derivative\n\nReturns:\n    ParameterExpression representing the gradient of param_expr w.r.t. param",
        "api_signature": "parameter_expression_grad(param_expr, param)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/derivative_base.py"
    },
    {
        "api_name": "_erase_operator_coeffs",
        "full_api_name": "DerivativeBase._erase_operator_coeffs",
        "api_description": "This method traverses an input operator and deletes all of the coefficients\n\nArgs:\n    operator: An operator type object.\n\nReturns:\n    An operator which is equal to the input operator but whose coefficients\n    have all been set to 1.0\n\nRaises:\n    TypeError: If unknown operator type is reached.",
        "api_signature": "_erase_operator_coeffs(cls, operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/derivative_base.py"
    },
    {
        "api_name": "_factor_coeffs_out_of_composed_op",
        "full_api_name": "DerivativeBase._factor_coeffs_out_of_composed_op",
        "api_description": "Factor all coefficients of ComposedOp out into a single global coefficient.\n\nPart of the automatic differentiation logic inside of Gradient and Hessian\ncounts on the fact that no product or chain rules need to be computed between\noperators or coefficients within a ComposedOp. To ensure this condition is met,\nthis function traverses an operator and replaces each ComposedOp with an equivalent\nComposedOp, but where all coefficients have been factored out and placed onto the\nComposedOp. Note that this cannot be done properly if an OperatorMeasurement contains\na SummedOp as it's primitive.\n\nArgs:\n    operator: The operator whose coefficients are being re-organized\n\nReturns:\n    An operator equivalent to the input operator, but whose coefficients have been\n    reorganized\n\nRaises:\n    ValueError: If an element within a ComposedOp has a primitive of type ListOp,\n                then it is not possible to factor all coefficients out of the ComposedOp.",
        "api_signature": "_factor_coeffs_out_of_composed_op(cls, operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/derivative_base.py"
    },
    {
        "api_name": "_coeff_derivative",
        "full_api_name": "_coeff_derivative",
        "api_description": "",
        "api_signature": "_coeff_derivative(coeff, param)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/derivative_base.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QFI.__init__",
        "api_description": "",
        "api_signature": "__init__(self, qfi_method)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/qfi.py"
    },
    {
        "api_name": "convert",
        "full_api_name": "QFI.convert",
        "api_description": "Args:\n    operator: The operator corresponding to the quantum state \\|\u03c8(\u03c9)\u3009for which we compute\n        the QFI\n    params: The parameters we are computing the QFI wrt: \u03c9\n        If not explicitly passed, they are inferred from the operator and sorted by name.\n\nReturns:\n    ListOp[ListOp] where the operator at position k,l corresponds to QFI_kl\n\nRaises:\n    ValueError: If operator is not parameterized.",
        "api_signature": "convert(self, operator, params)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/qfi.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "NaturalGradient.__init__",
        "api_description": "Args:\n    grad_method: The method used to compute the state gradient. Can be either\n        ``'param_shift'`` or ``'lin_comb'`` or ``'fin_diff'``.\n    qfi_method: The method used to compute the QFI. Can be either\n        ``'lin_comb_full'`` or ``'overlap_block_diag'`` or ``'overlap_diag'``.\n    regularization: Use the following regularization with a least square method to solve the\n        underlying system of linear equations\n        Can be either None or ``'ridge'`` or ``'lasso'`` or ``'perturb_diag'``\n        ``'ridge'`` and ``'lasso'`` use an automatic optimal parameter search\n        If regularization is None but the metric is ill-conditioned or singular then\n        a least square solver is used without regularization\n    kwargs (dict): Optional parameters for a CircuitGradient",
        "api_signature": "__init__(self, grad_method, qfi_method, regularization)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/natural_gradient.py"
    },
    {
        "api_name": "convert",
        "full_api_name": "NaturalGradient.convert",
        "api_description": "Args:\n    operator: The operator we are taking the gradient of.\n    params: The parameters we are taking the gradient with respect to. If not explicitly\n        passed, they are inferred from the operator and sorted by name.\n\nReturns:\n    An operator whose evaluation yields the NaturalGradient.\n\nRaises:\n    TypeError: If ``operator`` does not represent an expectation value or the quantum\n        state is not ``CircuitStateFn``.\n    ValueError: If ``params`` contains a parameter not present in ``operator``.\n    ValueError: If ``operator`` is not parameterized.",
        "api_signature": "convert(self, operator, params)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/natural_gradient.py"
    },
    {
        "api_name": "combo_fn",
        "full_api_name": "NaturalGradient.combo_fn",
        "api_description": "",
        "api_signature": "combo_fn(x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/natural_gradient.py"
    },
    {
        "api_name": "nat_grad_combo_fn",
        "full_api_name": "NaturalGradient.nat_grad_combo_fn",
        "api_description": "Natural Gradient Function Implementation.\n\nArgs:\n    x: Iterable consisting of Gradient, Quantum Fisher Information.\n    regularization: Regularization method.\n\nReturns:\n    Natural Gradient.\n\nRaises:\n    ValueError: If the gradient has imaginary components that are non-negligible.",
        "api_signature": "nat_grad_combo_fn(x, regularization)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/natural_gradient.py"
    },
    {
        "api_name": "qfi_method",
        "full_api_name": "NaturalGradient.qfi_method",
        "api_description": "Returns ``CircuitQFI``.\n\nReturns: ``CircuitQFI``.",
        "api_signature": "qfi_method(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/natural_gradient.py"
    },
    {
        "api_name": "regularization",
        "full_api_name": "NaturalGradient.regularization",
        "api_description": "Returns the regularization option.\n\nReturns: the regularization option.",
        "api_signature": "regularization(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/natural_gradient.py"
    },
    {
        "api_name": "_reg_term_search",
        "full_api_name": "NaturalGradient._reg_term_search",
        "api_description": "This method implements a search for a regularization parameter lambda by finding for the\ncorner of the L-curve.\nMore explicitly, one has to evaluate a suitable lambda by finding a compromise between\nthe error in the solution and the norm of the regularization.\nThis function implements a method presented in\n`A simple algorithm to find the L-curve corner in the regularization of inverse problems\n <https://arxiv.org/pdf/1608.04571.pdf>`\n\nArgs:\n    metric: See (1) and (2).\n    gradient: See (1) and (2).\n    reg_method: Given the metric, gradient and lambda the regularization method must return\n        ``x_lambda`` - see (2).\n    lambda1: Left starting point for L-curve corner search.\n    lambda4: Right starting point for L-curve corner search.\n    tol: Termination threshold.\n\nReturns:\n    Regularization coefficient which is the solution to the regularization inverse problem.",
        "api_signature": "_reg_term_search(metric, gradient, reg_method, lambda1, lambda4, tol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/natural_gradient.py"
    },
    {
        "api_name": "_get_curvature",
        "full_api_name": "NaturalGradient._get_curvature",
        "api_description": "Calculate Menger curvature\n\nMenger, K. (1930).  Untersuchungen  \u0308uber Allgemeine Metrik. Math. Ann.,103(1), 466\u2013501\n\nArgs:\n    ``x_lambda: [[x_lambdaj], [x_lambdak], [x_lambdal]]``\n        ``lambdaj < lambdak < lambdal``\n\nReturns:\n    Menger Curvature",
        "api_signature": "_get_curvature(x_lambda)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/natural_gradient.py"
    },
    {
        "api_name": "get_lambda2_lambda3",
        "full_api_name": "NaturalGradient.get_lambda2_lambda3",
        "api_description": "",
        "api_signature": "get_lambda2_lambda3(lambda1, lambda4)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/natural_gradient.py"
    },
    {
        "api_name": "_ridge",
        "full_api_name": "NaturalGradient._ridge",
        "api_description": "Ridge Regression with automatic search for a good regularization term lambda\nx_lambda = arg min{||Ax-C||^2 + lambda*||x||_2^2} (3)\n`Scikit Learn Ridge Regression\n<https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.Ridge.html>`\n\nArgs:\n    metric: See (1) and (2).\n    gradient: See (1) and (2).\n    lambda_ : regularization parameter used if auto_search = False\n    lambda1: left starting point for L-curve corner search\n    lambda4: right starting point for L-curve corner search\n    tol_search: termination threshold for regularization parameter search\n    fit_intercept: if True calculate intercept\n    normalize: ignored if fit_intercept=False, if True normalize A for regression\n    copy_a: if True A is copied, else overwritten\n    max_iter: max. number of iterations if solver is CG\n    tol: precision of the regression solution\n    solver: solver {\u2018auto\u2019, \u2018svd\u2019, \u2018cholesky\u2019, \u2018lsqr\u2019, \u2018sparse_cg\u2019, \u2018sag\u2019, \u2018saga\u2019}\n    random_state: seed for the pseudo random number generator used when data is shuffled\n\nReturns:\n   regularization coefficient, solution to the regularization inverse problem\n\nRaises:\n    MissingOptionalLibraryError: scikit-learn not installed",
        "api_signature": "_ridge(metric, gradient, lambda_, lambda1, lambda4, tol_search, fit_intercept, normalize, copy_a, max_iter, tol, solver, random_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/natural_gradient.py"
    },
    {
        "api_name": "reg_method",
        "full_api_name": "NaturalGradient.reg_method",
        "api_description": "",
        "api_signature": "reg_method(a, c, alpha)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/natural_gradient.py"
    },
    {
        "api_name": "_lasso",
        "full_api_name": "NaturalGradient._lasso",
        "api_description": "Lasso Regression with automatic search for a good regularization term lambda\nx_lambda = arg min{||Ax-C||^2/(2*n_samples) + lambda*||x||_1} (4)\n`Scikit Learn Lasso Regression\n<https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.Lasso.html>`\n\nArgs:\n    metric: Matrix of size mxn.\n    gradient: Vector of size m.\n    lambda_ : regularization parameter used if auto_search = False\n    lambda1: left starting point for L-curve corner search\n    lambda4: right starting point for L-curve corner search\n    tol_search: termination threshold for regularization parameter search\n    fit_intercept: if True calculate intercept\n    normalize: ignored if fit_intercept=False, if True normalize A for regression\n    precompute: If True compute and use Gram matrix to speed up calculations.\n                                     Gram matrix can also be given explicitly\n    copy_a: if True A is copied, else overwritten\n    max_iter: max. number of iterations if solver is CG\n    tol: precision of the regression solution\n    warm_start: if True reuse solution from previous fit as initialization\n    positive: if True force positive coefficients\n    random_state: seed for the pseudo random number generator used when data is shuffled\n    selection: {'cyclic', 'random'}\n\nReturns:\n    regularization coefficient, solution to the regularization inverse problem\n\nRaises:\n    MissingOptionalLibraryError: scikit-learn not installed",
        "api_signature": "_lasso(metric, gradient, lambda_, lambda1, lambda4, tol_search, fit_intercept, normalize, precompute, copy_a, max_iter, tol, warm_start, positive, random_state, selection)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/natural_gradient.py"
    },
    {
        "api_name": "reg_method",
        "full_api_name": "NaturalGradient.reg_method",
        "api_description": "",
        "api_signature": "reg_method(a, c, alpha)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/natural_gradient.py"
    },
    {
        "api_name": "_regularized_sle_solver",
        "full_api_name": "NaturalGradient._regularized_sle_solver",
        "api_description": "Solve a linear system of equations with a regularization method and automatic lambda fitting\n\nArgs:\n    metric: Matrix of size mxn.\n    gradient: Vector of size m.\n    regularization: Regularization scheme to be used: 'ridge', 'lasso',\n        'perturb_diag_elements' or 'perturb_diag'\n    lambda1: left starting point for L-curve corner search (for 'ridge' and 'lasso')\n    lambda4: right starting point for L-curve corner search (for 'ridge' and 'lasso')\n    alpha: perturbation coefficient for 'perturb_diag_elements' and 'perturb_diag'\n    tol_norm_x: tolerance for the norm of x\n    tol_cond_a: tolerance for the condition number of A\n\nReturns:\n    solution to the regularized system of linear equations",
        "api_signature": "_regularized_sle_solver(metric, gradient, regularization, lambda1, lambda4, alpha, tol_norm_x, tol_cond_a)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/natural_gradient.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Hessian.__init__",
        "api_description": "",
        "api_signature": "__init__(self, hess_method)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/hessian.py"
    },
    {
        "api_name": "convert",
        "full_api_name": "Hessian.convert",
        "api_description": "Args:\n    operator: The operator for which we compute the Hessian\n    params: The parameters we are computing the Hessian with respect to\n            Either give directly the tuples/list of tuples for which the second order\n            derivative is to be computed or give a list of parameters to build the\n            full Hessian for those parameters. If not explicitly passed, the full Hessian is\n            constructed. The parameters are then inferred from the operator and sorted by\n            name.\n\nReturns:\n    OperatorBase: An operator whose evaluation yields the Hessian",
        "api_signature": "convert(self, operator, params)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/hessian.py"
    },
    {
        "api_name": "get_hessian",
        "full_api_name": "Hessian.get_hessian",
        "api_description": "Get the Hessian for the given operator w.r.t. the given parameters\n\nArgs:\n    operator: Operator w.r.t. which we take the Hessian.\n    params: Parameters w.r.t. which we compute the Hessian. If not explicitly passed,\n        the full Hessian is constructed. The parameters are then inferred from the operator\n        and sorted by name.\n\nReturns:\n    Operator which represents the gradient w.r.t. the given params.\n\nRaises:\n    ValueError: If ``params`` contains a parameter not present in ``operator``.\n    ValueError: If ``operator`` is not parameterized.\n    OpflowError: If the coefficient of the operator could not be reduced to 1.\n    OpflowError: If the differentiation of a combo_fn\n                 requires JAX but the package is not installed.\n    TypeError: If the operator does not include a StateFn given by a quantum circuit\n    TypeError: If the parameters were given in an unsupported format.\n    Exception: Unintended code is reached\n    MissingOptionalLibraryError: jax not installed",
        "api_signature": "get_hessian(self, operator, params)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/hessian.py"
    },
    {
        "api_name": "is_coeff_c",
        "full_api_name": "Hessian.is_coeff_c",
        "api_description": "",
        "api_signature": "is_coeff_c(coeff, c)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/hessian.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Gradient.__init__",
        "api_description": "",
        "api_signature": "__init__(self, grad_method)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/gradient.py"
    },
    {
        "api_name": "convert",
        "full_api_name": "Gradient.convert",
        "api_description": "Args:\n    operator: The operator we are taking the gradient of.\n    params: The parameters we are taking the gradient with respect to. If not\n        explicitly passed, they are inferred from the operator and sorted by name.\n\nReturns:\n    An operator whose evaluation yields the Gradient.\n\nRaises:\n    ValueError: If ``params`` contains a parameter not present in ``operator``.\n    ValueError: If ``operator`` is not parameterized.",
        "api_signature": "convert(self, operator, params)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/gradient.py"
    },
    {
        "api_name": "get_gradient",
        "full_api_name": "Gradient.get_gradient",
        "api_description": "Get the gradient for the given operator w.r.t. the given parameters\n\nArgs:\n    operator: Operator w.r.t. which we take the gradient.\n    params: Parameters w.r.t. which we compute the gradient.\n\nReturns:\n    Operator which represents the gradient w.r.t. the given params.\n\nRaises:\n    ValueError: If ``params`` contains a parameter not present in ``operator``.\n    OpflowError: If the coefficient of the operator could not be reduced to 1.\n    OpflowError: If the differentiation of a combo_fn requires JAX but the package is not\n               installed.\n    TypeError: If the operator does not include a StateFn given by a quantum circuit\n    Exception: Unintended code is reached\n    MissingOptionalLibraryError: jax not installed",
        "api_signature": "get_gradient(self, operator, params)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/gradient.py"
    },
    {
        "api_name": "is_coeff_c",
        "full_api_name": "Gradient.is_coeff_c",
        "api_description": "",
        "api_signature": "is_coeff_c(coeff, c)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/gradient.py"
    },
    {
        "api_name": "is_coeff_c_abs",
        "full_api_name": "Gradient.is_coeff_c_abs",
        "api_description": "",
        "api_signature": "is_coeff_c_abs(coeff, c)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/gradient.py"
    },
    {
        "api_name": "chain_rule_combo_fn",
        "full_api_name": "Gradient.chain_rule_combo_fn",
        "api_description": "",
        "api_signature": "chain_rule_combo_fn(x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/gradient.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "GradientBase.__init__",
        "api_description": "Args:\n    grad_method: The method used to compute the state/probability gradient. Can be either\n                 ``'param_shift'`` or ``'lin_comb'`` or ``'fin_diff'``.\n                 Ignored for gradients w.r.t observable parameters.\n    kwargs (dict): Optional parameters for a CircuitGradient\n\nRaises:\n    ValueError: If method != ``fin_diff`` and ``epsilon`` is not None.",
        "api_signature": "__init__(self, grad_method)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/gradient_base.py"
    },
    {
        "api_name": "grad_method",
        "full_api_name": "GradientBase.grad_method",
        "api_description": "Returns ``CircuitGradient``.\n\nReturns:\n    ``CircuitGradient``.",
        "api_signature": "grad_method(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/gradient_base.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "HessianBase.__init__",
        "api_description": "Args:\n    hess_method: The method used to compute the state/probability gradient. Can be either\n                 ``'param_shift'`` or ``'lin_comb'`` or ``'fin_diff'``.\n                 Ignored for gradients w.r.t observable parameters.\n    kwargs (dict): Optional parameters for a CircuitGradient\n\nRaises:\n    ValueError: If method != ``fin_diff`` and ``epsilon`` is not None.",
        "api_signature": "__init__(self, hess_method)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/hessian_base.py"
    },
    {
        "api_name": "hess_method",
        "full_api_name": "HessianBase.hess_method",
        "api_description": "Returns ``CircuitGradient``.\n\nReturns:\n    ``CircuitGradient``.",
        "api_signature": "hess_method(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/hessian_base.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CircuitGradient.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/circuit_gradients/circuit_gradient.py"
    },
    {
        "api_name": "convert",
        "full_api_name": "CircuitGradient.convert",
        "api_description": "Args:\n    operator: The operator we are taking the gradient of\n    params: The parameters we are taking the gradient wrt: \u03c9\n            If a ParameterExpression, ParameterVector or List[ParameterExpression] is given,\n            then the 1st order derivative of the operator is calculated.\n            If a Tuple[ParameterExpression, ParameterExpression] or\n            List[Tuple[ParameterExpression, ParameterExpression]]\n            is given, then the 2nd order derivative of the operator is calculated.\n\nReturns:\n    An operator whose evaluation yields the Gradient.\n\nRaises:\n    ValueError: If ``params`` contains a parameter not present in ``operator``.",
        "api_signature": "convert(self, operator, params)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/circuit_gradients/circuit_gradient.py"
    },
    {
        "api_name": "_transpile_to_supported_operations",
        "full_api_name": "CircuitGradient._transpile_to_supported_operations",
        "api_description": "Transpile the given circuit into a gate set for which the gradients may be computed.\n\nArgs:\n    circuit: Quantum circuit to be transpiled into supported operations.\n    supported_gates: Set of quantum operations supported by a gradient method intended to\n                    be used on the quantum circuit.\n\nReturns:\n    Quantum circuit which is transpiled into supported operations.\n\nRaises:\n    QiskitError: when circuit transpiling fails.",
        "api_signature": "_transpile_to_supported_operations(circuit, supported_gates)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/circuit_gradients/circuit_gradient.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "LinComb.__init__",
        "api_description": "Args:\n    aux_meas_op: The operator that the auxiliary qubit is measured with respect to.\n        For ``aux_meas_op = Z`` we compute 2Re[(d\u03c9\u27e8\u03c8(\u03c9)|)O(\u03b8)|\u03c8(\u03c9)\u3009],\n        for ``aux_meas_op = -Y`` we compute 2Im[(d\u03c9\u27e8\u03c8(\u03c9)|)O(\u03b8)|\u03c8(\u03c9)\u3009], and\n        for ``aux_meas_op = Z - 1j * Y`` we compute 2(d\u03c9\u27e8\u03c8(\u03c9)|)O(\u03b8)|\u03c8(\u03c9)\u3009.\nRaises:\n    ValueError: If the provided auxiliary measurement operator is not supported.",
        "api_signature": "__init__(self, aux_meas_op)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/circuit_gradients/lin_comb.py"
    },
    {
        "api_name": "convert",
        "full_api_name": "LinComb.convert",
        "api_description": "Convert ``operator`` into an operator that represents the gradient w.r.t. ``params``.\n\nArgs:\n    operator: The operator we are taking the gradient of: \u27e8\u03c8(\u03c9)|O(\u03b8)|\u03c8(\u03c9)\u3009\n    params: The parameters we are taking the gradient wrt: \u03c9\n            If a ParameterExpression, ParameterVector or List[ParameterExpression] is given,\n            then the 1st order derivative of the operator is calculated.\n            If a Tuple[ParameterExpression, ParameterExpression] or\n            List[Tuple[ParameterExpression, ParameterExpression]]\n            is given, then the 2nd order derivative of the operator is calculated.\nReturns:\n    An operator corresponding to the gradient resp. Hessian. The order is in accordance with\n    the order of the given parameters.",
        "api_signature": "convert(self, operator, params)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/circuit_gradients/lin_comb.py"
    },
    {
        "api_name": "_prepare_operator",
        "full_api_name": "LinComb._prepare_operator",
        "api_description": "Traverse ``operator`` to get back the adapted operator representing the gradient.\n\nArgs:\n    operator: The operator we are taking the gradient of: \u27e8\u03c8(\u03c9)|O(\u03b8)|\u03c8(\u03c9)\u3009.\n    params: The parameters we are taking the gradient wrt: \u03c9.\n        If a ``ParameterExpression```, ``ParameterVector`` or ``List[ParameterExpression]``\n        is given, then the 1st order derivative of the operator is calculated.\n        If a ``Tuple[ParameterExpression, ParameterExpression]`` or\n        ``List[Tuple[ParameterExpression, ParameterExpression]]``\n        is given, then the 2nd order derivative of the operator is calculated.\nReturns:\n    The adapted operator.\n    Measurement operators are attached with an additional Z term acting\n    on an additional working qubit.\n    Quantum states - which must be given as circuits - are adapted. An additional\n    working qubit controls intercepting gates.\n    See e.g. [1].\n\nRaises:\n    ValueError: If ``operator`` does not correspond to an expectation value.\n    TypeError: If the ``StateFn`` corresponding to the quantum state could not be extracted\n               from ``operator``.\n    OpflowError: If third or higher order gradients are requested.\n\nReferences:\n    [1]: Evaluating analytic gradients on quantum hardware\n         Maria Schuld, Ville Bergholm, Christian Gogolin, Josh Izaac, and Nathan Killoran\n         Phys. Rev. A 99, 032331 \u2013 Published 21 March 2019",
        "api_signature": "_prepare_operator(self, operator, params)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/circuit_gradients/lin_comb.py"
    },
    {
        "api_name": "_grad_combo_fn",
        "full_api_name": "LinComb._grad_combo_fn",
        "api_description": "",
        "api_signature": "_grad_combo_fn(x, state_op)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/circuit_gradients/lin_comb.py"
    },
    {
        "api_name": "get_result",
        "full_api_name": "LinComb.get_result",
        "api_description": "",
        "api_signature": "get_result(item)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/circuit_gradients/lin_comb.py"
    },
    {
        "api_name": "_hess_combo_fn",
        "full_api_name": "LinComb._hess_combo_fn",
        "api_description": "",
        "api_signature": "_hess_combo_fn(x, state_op)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/circuit_gradients/lin_comb.py"
    },
    {
        "api_name": "get_result",
        "full_api_name": "LinComb.get_result",
        "api_description": "",
        "api_signature": "get_result(item)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/circuit_gradients/lin_comb.py"
    },
    {
        "api_name": "_gate_gradient_dict",
        "full_api_name": "LinComb._gate_gradient_dict",
        "api_description": "Given a parameterized gate U(theta) with derivative\ndU(theta)/dtheta = sum_ia_iU(theta)V_i.\nThis function returns a:=[a_0, ...] and V=[V_0, ...]\nSuppose U takes multiple parameters, i.e., U(theta^0, ... theta^k).\nThe returned coefficients and gates are ordered accordingly.\nOnly parameterized Qiskit gates are supported.\n\nArgs:\n    gate: The gate for which the derivative is being computed.\n\nReturns:\n    The coefficients and the gates used for the metric computation for each parameter of\n    the respective gates ``[([a^0], [V^0]) ..., ([a^k], [V^k])]``.\n\nRaises:\n    OpflowError: If the input gate is controlled by another state but '|1>^{\\otimes k}'\n    TypeError: If the input gate is not a supported parameterized gate.",
        "api_signature": "_gate_gradient_dict(gate)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/circuit_gradients/lin_comb.py"
    },
    {
        "api_name": "apply_grad_gate",
        "full_api_name": "LinComb.apply_grad_gate",
        "api_description": "Util function to apply a gradient gate for the linear combination of unitaries method.\nReplaces the ``gate`` instance in ``circuit`` with ``grad_gate`` using ``qr_superpos`` as\nsuperposition qubit. Also adds the appropriate sign-fix gates on the superposition qubit.\n\nArgs:\n    circuit (QuantumCircuit): The circuit in which to do the replacements.\n    gate (Gate): The gate instance to replace.\n    param_index (int): The index of the parameter in ``gate``.\n    grad_gate (Gate): A controlled gate encoding the gradient of ``gate``.\n    grad_coeff (float): A coefficient to the gradient component. Might not be one if the\n        gradient contains multiple summed terms.\n    qr_superpos (QuantumRegister): A ``QuantumRegister`` of size 1 contained in ``circuit``\n        that is used as control for ``grad_gate``.\n    open_ctrl (bool): If True use an open control for ``grad_gate`` instead of closed.\n    trim_after_grad_gate (bool): If True remove all gates after the ``grad_gate``. Can\n        be used to reduce the circuit depth in e.g. computing an overlap of gradients.\n\nReturns:\n    QuantumCircuit: A copy of the original circuit with the gradient gate added.\n\nRaises:\n    RuntimeError: If ``gate`` is not in ``circuit``.",
        "api_signature": "apply_grad_gate(circuit, gate, param_index, grad_gate, grad_coeff, qr_superpos, open_ctrl, trim_after_grad_gate)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/circuit_gradients/lin_comb.py"
    },
    {
        "api_name": "_aux_meas_basis_trafo",
        "full_api_name": "LinComb._aux_meas_basis_trafo",
        "api_description": "This function applies the necessary basis transformation to measure the quantum state in\na different basis -- given by the auxiliary measurement operator ``aux_meas_op``.\n\nArgs:\n    aux_meas_op: The auxiliary measurement operator defines the necessary measurement basis.\n    state: This operator represents the gradient or Hessian before the basis transformation.\n    state_op: The operator representing the quantum state for which we compute the gradient\n        or Hessian.\n    combo_fn: This ``combo_fn`` defines whether the target is a gradient or Hessian.\n\n\nReturns:\n    Operator representing the gradient or Hessian.\n\nRaises:\n    ValueError: If ``aux_meas_op`` is neither ``Z`` nor ``-Y`` nor ``Z - 1j * Y``.",
        "api_signature": "_aux_meas_basis_trafo(self, aux_meas_op, state, state_op, combo_fn)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/circuit_gradients/lin_comb.py"
    },
    {
        "api_name": "_gradient_states",
        "full_api_name": "LinComb._gradient_states",
        "api_description": "Generate the gradient states.\n\nArgs:\n    state_op: The operator representing the quantum state for which we compute the gradient.\n    meas_op: The operator representing the observable for which we compute the gradient.\n    target_params: The parameters we are taking the gradient wrt: \u03c9\n    open_ctrl: If True use an open control for ``grad_gate`` instead of closed.\n    trim_after_grad_gate: If True remove all gates after the ``grad_gate``. Can\n        be used to reduce the circuit depth in e.g. computing an overlap of gradients.\n\nReturns:\n    ListOp of StateFns as quantum circuits which are the states w.r.t. which we compute the\n    gradient. If a parameter appears multiple times, one circuit is created per\n    parameterized gates to compute the product rule.\n\nRaises:\n    QiskitError: If one of the circuits could not be constructed.\n    TypeError: If the operators is of unsupported type.\n    ValueError: If the auxiliary operator preparation fails.",
        "api_signature": "_gradient_states(self, state_op, meas_op, target_params, open_ctrl, trim_after_grad_gate)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/circuit_gradients/lin_comb.py"
    },
    {
        "api_name": "_hessian_states",
        "full_api_name": "LinComb._hessian_states",
        "api_description": "Generate the operator states whose evaluation returns the Hessian (items).\n\nArgs:\n    state_op: The operator representing the quantum state for which we compute the Hessian.\n    meas_op: The operator representing the observable for which we compute the gradient.\n    target_params: The parameters we are computing the Hessian wrt: \u03c9\n\nReturns:\n    Operators which give the Hessian. If a parameter appears multiple times, one circuit is\n    created per parameterized gates to compute the product rule.\n\nRaises:\n    QiskitError: If one of the circuits could not be constructed.\n    TypeError: If ``operator`` is of unsupported type.\n    ValueError: If the auxiliary operator preparation fails.",
        "api_signature": "_hessian_states(self, state_op, meas_op, target_params)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/circuit_gradients/lin_comb.py"
    },
    {
        "api_name": "_z_exp",
        "full_api_name": "_z_exp",
        "api_description": "Compute the sampling probabilities of the qubits after applying measurement on the\nauxiliary qubit.",
        "api_signature": "_z_exp(spmatrix)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/circuit_gradients/lin_comb.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ParamShift.__init__",
        "api_description": "Args:\n    analytic: If True use the parameter shift rule to compute analytic gradients,\n              else use a finite difference approach\n    epsilon: The offset size to use when computing finite difference gradients.\n             Ignored if analytic == True\n\nRaises:\n    ValueError: If method != ``fin_diff`` and ``epsilon`` is not None.",
        "api_signature": "__init__(self, analytic, epsilon)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/circuit_gradients/param_shift.py"
    },
    {
        "api_name": "analytic",
        "full_api_name": "ParamShift.analytic",
        "api_description": "Returns ``analytic`` flag.\n\nReturns:\n     ``analytic`` flag.",
        "api_signature": "analytic(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/circuit_gradients/param_shift.py"
    },
    {
        "api_name": "epsilon",
        "full_api_name": "ParamShift.epsilon",
        "api_description": "Returns ``epsilon``.\n\nReturns:\n    ``epsilon``.",
        "api_signature": "epsilon(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/circuit_gradients/param_shift.py"
    },
    {
        "api_name": "convert",
        "full_api_name": "ParamShift.convert",
        "api_description": "Args:\n    operator: The operator corresponding to our quantum state we are taking the\n              gradient of: |\u03c8(\u03c9)\u3009\n    params: The parameters we are taking the gradient wrt: \u03c9\n            If a ParameterExpression, ParameterVector or List[ParameterExpression] is given,\n            then the 1st order derivative of the operator is calculated.\n            If a Tuple[ParameterExpression, ParameterExpression] or\n            List[Tuple[ParameterExpression, ParameterExpression]]\n            is given, then the 2nd order derivative of the operator is calculated.\n\nReturns:\n    An operator corresponding to the gradient resp. Hessian. The order is in accordance with\n    the order of the given parameters.\n\nRaises:\n    OpflowError: If the parameters are given in an invalid format.",
        "api_signature": "convert(self, operator, params)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/circuit_gradients/param_shift.py"
    },
    {
        "api_name": "_parameter_shift",
        "full_api_name": "ParamShift._parameter_shift",
        "api_description": "Args:\n    operator: The operator containing circuits we are taking the derivative of.\n    params: The parameters (\u03c9) we are taking the derivative with respect to. If\n            a ParameterVector is provided, each parameter will be shifted.\n\nReturns:\n    param_shifted_op: An operator object which evaluates to the respective gradients.\n\nRaises:\n    ValueError: If the given parameters do not occur in the provided operator\n    TypeError: If the operator has more than one circuit representing the quantum state",
        "api_signature": "_parameter_shift(self, operator, params)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/circuit_gradients/param_shift.py"
    },
    {
        "api_name": "_prob_combo_fn",
        "full_api_name": "ParamShift._prob_combo_fn",
        "api_description": "Implement the combo_fn used to evaluate probability gradients\n\nArgs:\n    x: Output of an operator evaluation\n    shift_constant: Shifting constant factor needed for proper rescaling\n\nReturns:\n    Array representing the probability gradients w.r.t. the given operator and parameters\n\nRaises:\n    TypeError: if ``x`` is not DictStateFn, VectorStateFn or their list.",
        "api_signature": "_prob_combo_fn(x, shift_constant)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/circuit_gradients/param_shift.py"
    },
    {
        "api_name": "get_primitives",
        "full_api_name": "ParamShift.get_primitives",
        "api_description": "",
        "api_signature": "get_primitives(item)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/circuit_gradients/param_shift.py"
    },
    {
        "api_name": "_replace_operator_circuit",
        "full_api_name": "ParamShift._replace_operator_circuit",
        "api_description": "Replace a circuit element in an operator with a single element given as circuit\n\nArgs:\n    operator: Operator for which the circuit representing the quantum state shall be\n              replaced\n    circuit: Circuit which shall replace the circuit in the given operator\n\nReturns:\n    Operator with replaced circuit quantum state function",
        "api_signature": "_replace_operator_circuit(operator, circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/circuit_gradients/param_shift.py"
    },
    {
        "api_name": "get_unique_circuits",
        "full_api_name": "ParamShift.get_unique_circuits",
        "api_description": "Traverse the operator and return all unique circuits\n\nArgs:\n    operator: An operator that potentially includes QuantumCircuits\n\nReturns:\n    A list of all unique quantum circuits that appear in the operator",
        "api_signature": "get_unique_circuits(cls, operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/circuit_gradients/param_shift.py"
    },
    {
        "api_name": "get_circuit",
        "full_api_name": "ParamShift.get_circuit",
        "api_description": "",
        "api_signature": "get_circuit(op)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/circuit_gradients/param_shift.py"
    },
    {
        "api_name": "unroll_operator",
        "full_api_name": "ParamShift.unroll_operator",
        "api_description": "Traverse the operator and return all OperatorBase objects flattened\n   into a single list. This is used as a subroutine to extract all\n   circuits within a large composite operator.\n\nArgs:\n    operator: An OperatorBase type object\n\nReturns:\n    A single flattened list of all OperatorBase objects within the\n    input operator",
        "api_signature": "unroll_operator(cls, operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/circuit_gradients/param_shift.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "OverlapDiag.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/circuit_qfis/overlap_diag.py"
    },
    {
        "api_name": "convert",
        "full_api_name": "OverlapDiag.convert",
        "api_description": "Args:\n    operator: The operator corresponding to the quantum state :math:`|\\psi(\\omega)\\rangle`\n        for which we compute the QFI.\n    params: The parameters :math:`\\omega` with respect to which we are computing the QFI.\n\nReturns:\n    A ``ListOp[ListOp]`` where the operator at position ``[k][l]`` corresponds to the matrix\n    element :math:`k, l` of the QFI.\n\nRaises:\n    NotImplementedError: If ``operator`` is neither ``CircuitOp`` nor ``CircuitStateFn``.",
        "api_signature": "convert(self, operator, params)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/circuit_qfis/overlap_diag.py"
    },
    {
        "api_name": "_diagonal_approx",
        "full_api_name": "OverlapDiag._diagonal_approx",
        "api_description": "Args:\n    operator: The operator corresponding to the quantum state |\u03c8(\u03c9)\u3009for which we compute\n        the QFI\n    params: The parameters we are computing the QFI wrt: \u03c9\n\nReturns:\n    ListOp where the operator at position k corresponds to QFI_k,k\n\nRaises:\n    NotImplementedError: If a circuit is found such that one parameter controls multiple\n                         gates, or one gate contains multiple parameters.\n    TypeError: If a circuit is found that includes more than one parameter as they are\n               currently not supported for the overlap diagonal QFI method.",
        "api_signature": "_diagonal_approx(self, operator, params)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/circuit_qfis/overlap_diag.py"
    },
    {
        "api_name": "_partition_circuit",
        "full_api_name": "_partition_circuit",
        "api_description": "",
        "api_signature": "_partition_circuit(circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/circuit_qfis/overlap_diag.py"
    },
    {
        "api_name": "apply_node_op",
        "full_api_name": "apply_node_op",
        "api_description": "",
        "api_signature": "apply_node_op(node, dag, back)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/circuit_qfis/overlap_diag.py"
    },
    {
        "api_name": "_get_generators",
        "full_api_name": "_get_generators",
        "api_description": "",
        "api_signature": "_get_generators(params, circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/circuit_qfis/overlap_diag.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "LinCombFull.__init__",
        "api_description": "Args:\n    aux_meas_op: The operator that the auxiliary qubit is measured with respect to.\n        For ``aux_meas_op = Z`` we compute 4Re[(d\u03c9\u27e8\u03c8(\u03c9)|)O(\u03b8)|\u03c8(\u03c9)\u3009],\n        for ``aux_meas_op = -Y`` we compute 4Im[(d\u03c9\u27e8\u03c8(\u03c9)|)O(\u03b8)|\u03c8(\u03c9)\u3009], and\n        for ``aux_meas_op = Z - 1j * Y`` we compute 4(d\u03c9\u27e8\u03c8(\u03c9)|)O(\u03b8)|\u03c8(\u03c9)\u3009.\n    phase_fix: Whether or not to compute and add the additional phase fix term\n        Re[(d\u03c9\u27e8<\u03c8(\u03c9)|)|\u03c8(\u03c9)><\u03c8(\u03c9)|(d\u03c9|\u03c8(\u03c9))>].\nRaises:\n    ValueError: If the provided auxiliary measurement operator is not supported.",
        "api_signature": "__init__(self, aux_meas_op, phase_fix)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/circuit_qfis/lin_comb_full.py"
    },
    {
        "api_name": "convert",
        "full_api_name": "LinCombFull.convert",
        "api_description": "Args:\n    operator: The operator corresponding to the quantum state :math:`|\\psi(\\omega)\\rangle`\n        for which we compute the QFI.\n    params: The parameters :math:`\\omega` with respect to which we are computing the QFI.\nReturns:\n    A ``ListOp[ListOp]`` where the operator at position ``[k][l]`` corresponds to the matrix\n    element :math:`k, l` of the QFI.\n\nRaises:\n    TypeError: If ``operator`` is an unsupported type.",
        "api_signature": "convert(self, operator, params)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/circuit_qfis/lin_comb_full.py"
    },
    {
        "api_name": "phase_fix_combo_fn",
        "full_api_name": "LinCombFull.phase_fix_combo_fn",
        "api_description": "",
        "api_signature": "phase_fix_combo_fn(x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/circuit_qfis/lin_comb_full.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "OverlapBlockDiag.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/circuit_qfis/overlap_block_diag.py"
    },
    {
        "api_name": "convert",
        "full_api_name": "OverlapBlockDiag.convert",
        "api_description": "Args:\n    operator: The operator corresponding to the quantum state :math:`|\\psi(\\omega)\\rangle`\n        for which we compute the QFI.\n    params: The parameters :math:`\\omega` with respect to which we are computing the QFI.\n\nReturns:\n    A ``ListOp[ListOp]`` where the operator at position ``[k][l]`` corresponds to the matrix\n    element :math:`k, l` of the QFI.\n\nRaises:\n    NotImplementedError: If ``operator`` is neither ``CircuitOp`` nor ``CircuitStateFn``.",
        "api_signature": "convert(self, operator, params)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/circuit_qfis/overlap_block_diag.py"
    },
    {
        "api_name": "_block_diag_approx",
        "full_api_name": "OverlapBlockDiag._block_diag_approx",
        "api_description": "Args:\n    operator: The operator corresponding to the quantum state :math:`|\\psi(\\omega)\\rangle`\n        for which we compute the QFI.\n    params: The parameters :math:`\\omega` with respect to which we are computing the QFI.\n\nReturns:\n    A ``ListOp[ListOp]`` where the operator at position ``[k][l]`` corresponds to the matrix\n    element :math:`k, l` of the QFI.\n\nRaises:\n    NotImplementedError: If a circuit is found such that one parameter controls multiple\n        gates, or one gate contains multiple parameters.\n    OpflowError: If there are more than one parameter.",
        "api_signature": "_block_diag_approx(self, operator, params)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/circuit_qfis/overlap_block_diag.py"
    },
    {
        "api_name": "get_parameter_expression",
        "full_api_name": "OverlapBlockDiag.get_parameter_expression",
        "api_description": "",
        "api_signature": "get_parameter_expression(circuit, param)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/circuit_qfis/overlap_block_diag.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CircuitQFI.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/circuit_qfis/circuit_qfi.py"
    },
    {
        "api_name": "convert",
        "full_api_name": "CircuitQFI.convert",
        "api_description": "Args:\n    operator: The operator corresponding to the quantum state :math:`|\\psi(\\omega)\\rangle`\n        for which we compute the QFI.\n    params: The parameters :math:`\\omega` with respect to which we are computing the QFI.\n\nReturns:\n    An operator whose evaluation yields the QFI metric tensor.\n\nRaises:\n    ValueError: If ``params`` contains a parameter not present in ``operator``.",
        "api_signature": "convert(self, operator, params)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/gradients/circuit_qfis/circuit_qfi.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "DictToCircuitSum.__init__",
        "api_description": "Args:\n    traverse: Whether to recurse down into Operators with internal sub-operators for\n        conversion.\n    convert_dicts: Whether to convert VectorStateFn.\n    convert_vectors: Whether to convert DictStateFns.",
        "api_signature": "__init__(self, traverse, convert_dicts, convert_vectors)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/converters/dict_to_circuit_sum.py"
    },
    {
        "api_name": "convert",
        "full_api_name": "DictToCircuitSum.convert",
        "api_description": "Convert the Operator to ``CircuitStateFns``, recursively if ``traverse`` is True.\n\nArgs:\n    operator: The Operator to convert\n\nReturns:\n    The converted Operator.",
        "api_signature": "convert(self, operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/converters/dict_to_circuit_sum.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PauliBasisChange.__init__",
        "api_description": "Args:\n    destination_basis: The Pauli into the basis of which the operators\n        will be converted. If None is specified, the destination basis will be the\n        diagonal ({I, Z}^n) basis requiring only single qubit rotations.\n    traverse: If true and the operator passed into convert contains sub-Operators,\n        such as ListOp, traverse the Operator and apply the conversion to every\n        applicable sub-operator within it.\n    replacement_fn: A function specifying what to do with the basis-change\n        ``CircuitOp`` and destination ``PauliOp`` when converting an Operator and\n        replacing converted values. By default, this will be\n\n            1) For StateFns (or Measurements): replacing the StateFn with\n               ComposedOp(StateFn(d), c) where c is the conversion circuit and d is the\n               destination Pauli, so the overall beginning and ending operators are\n               equivalent.\n\n            2) For non-StateFn Operators: replacing the origin p with c\u00b7d\u00b7c\u2020, where c\n               is the conversion circuit and d is the destination, so the overall\n               beginning and ending operators are equivalent.",
        "api_signature": "__init__(self, destination_basis, traverse, replacement_fn)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/converters/pauli_basis_change.py"
    },
    {
        "api_name": "destination",
        "full_api_name": "PauliBasisChange.destination",
        "api_description": "The destination ``PauliOp``, or ``None`` if using the default destination, the diagonal\nbasis.",
        "api_signature": "destination(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/converters/pauli_basis_change.py"
    },
    {
        "api_name": "destination",
        "full_api_name": "PauliBasisChange.destination",
        "api_description": "The destination ``PauliOp``, or ``None`` if using the default destination, the diagonal\nbasis.",
        "api_signature": "destination(self, dest)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/converters/pauli_basis_change.py"
    },
    {
        "api_name": "convert",
        "full_api_name": "PauliBasisChange.convert",
        "api_description": "Given a ``PauliOp``, or an Operator containing ``PauliOps`` if ``_traverse`` is True,\nconverts each Pauli into the basis specified by self._destination and a\nbasis-change-circuit, calls ``replacement_fn`` with these two Operators, and replaces\nthe ``PauliOps`` with the output of ``replacement_fn``. For example, for the built-in\n``operator_replacement_fn`` below, each PauliOp p will be replaced by the composition\nof the basis-change Clifford ``CircuitOp`` c with the destination PauliOp d and c\u2020,\nsuch that p = c\u00b7d\u00b7c\u2020, up to global phase.\n\nArgs:\n    operator: The Operator to convert.\n\nReturns:\n    The converted Operator.",
        "api_signature": "convert(self, operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/converters/pauli_basis_change.py"
    },
    {
        "api_name": "measurement_replacement_fn",
        "full_api_name": "PauliBasisChange.measurement_replacement_fn",
        "api_description": "A built-in convenience replacement function which produces measurements\nisomorphic to an ``OperatorStateFn`` measurement holding the origin ``PauliOp``.\n\nArgs:\n    cob_instr_op: The basis-change ``CircuitOp``.\n    dest_pauli_op: The destination Pauli type operator.\n\nReturns:\n    The ``~StateFn @ CircuitOp`` composition equivalent to a measurement by the original\n    ``PauliOp``.",
        "api_signature": "measurement_replacement_fn(cob_instr_op, dest_pauli_op)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/converters/pauli_basis_change.py"
    },
    {
        "api_name": "statefn_replacement_fn",
        "full_api_name": "PauliBasisChange.statefn_replacement_fn",
        "api_description": "A built-in convenience replacement function which produces state functions\nisomorphic to an ``OperatorStateFn`` state function holding the origin ``PauliOp``.\n\nArgs:\n    cob_instr_op: The basis-change ``CircuitOp``.\n    dest_pauli_op: The destination Pauli type operator.\n\nReturns:\n    The ``~CircuitOp @ StateFn`` composition equivalent to a state function defined by the\n    original ``PauliOp``.",
        "api_signature": "statefn_replacement_fn(cob_instr_op, dest_pauli_op)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/converters/pauli_basis_change.py"
    },
    {
        "api_name": "operator_replacement_fn",
        "full_api_name": "PauliBasisChange.operator_replacement_fn",
        "api_description": "A built-in convenience replacement function which produces Operators\nisomorphic to the origin ``PauliOp``.\n\nArgs:\n    cob_instr_op: The basis-change ``CircuitOp``.\n    dest_pauli_op: The destination ``PauliOp``.\n\nReturns:\n    The ``~CircuitOp @ PauliOp @ CircuitOp`` composition isomorphic to the\n    original ``PauliOp``.",
        "api_signature": "operator_replacement_fn(cob_instr_op, dest_pauli_op)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/converters/pauli_basis_change.py"
    },
    {
        "api_name": "get_tpb_pauli",
        "full_api_name": "PauliBasisChange.get_tpb_pauli",
        "api_description": "Gets the Pauli (not ``PauliOp``!) whose diagonalizing single-qubit rotations is a\nsuperset of the diagonalizing single-qubit rotations for each of the Paulis in\n``list_op``. TPB stands for `Tensor Product Basis`.\n\nArgs:\n     list_op: the :class:`ListOp` whose TPB Pauli to return.\n\nReturns:\n     The TBP Pauli.",
        "api_signature": "get_tpb_pauli(self, list_op)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/converters/pauli_basis_change.py"
    },
    {
        "api_name": "get_diagonal_pauli_op",
        "full_api_name": "PauliBasisChange.get_diagonal_pauli_op",
        "api_description": "Get the diagonal ``PualiOp`` to which ``pauli_op`` could be rotated with only\nsingle-qubit operations.\n\nArgs:\n    pauli_op: The ``PauliOp`` whose diagonal to compute.\n\nReturns:\n    The diagonal ``PauliOp``.",
        "api_signature": "get_diagonal_pauli_op(self, pauli_op)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/converters/pauli_basis_change.py"
    },
    {
        "api_name": "get_diagonalizing_clifford",
        "full_api_name": "PauliBasisChange.get_diagonalizing_clifford",
        "api_description": "Construct a ``CircuitOp`` with only single-qubit gates which takes the eigenvectors\nof ``pauli`` to eigenvectors composed only of \\|0\u27e9 and \\|1\u27e9 tensor products. Equivalently,\nfinds the basis-change circuit to take ``pauli`` to a diagonal ``PauliOp`` composed only\nof Z and I tensor products.\n\nNote, underlying Pauli bits are in Qiskit endianness, so we need to reverse before we\nbegin composing with Operator flow.\n\nArgs:\n    pauli: the ``Pauli`` or ``PauliOp`` to whose diagonalizing circuit to compute.\n\nReturns:\n    The diagonalizing ``CircuitOp``.",
        "api_signature": "get_diagonalizing_clifford(self, pauli)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/converters/pauli_basis_change.py"
    },
    {
        "api_name": "pad_paulis_to_equal_length",
        "full_api_name": "PauliBasisChange.pad_paulis_to_equal_length",
        "api_description": "If ``pauli_op1`` and ``pauli_op2`` do not act over the same number of qubits, pad\nidentities to the end of the shorter of the two so they are of equal length. Padding is\napplied to the end of the Paulis. Note that the Terra represents Paulis in big-endian\norder, so this will appear as padding to the beginning of the Pauli x and z bit arrays.\n\nArgs:\n    pauli_op1: A pauli_op to possibly pad.\n    pauli_op2: A pauli_op to possibly pad.\n\nReturns:\n    A tuple containing the padded PauliOps.",
        "api_signature": "pad_paulis_to_equal_length(self, pauli_op1, pauli_op2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/converters/pauli_basis_change.py"
    },
    {
        "api_name": "construct_cnot_chain",
        "full_api_name": "PauliBasisChange.construct_cnot_chain",
        "api_description": "Construct a ``CircuitOp`` (or ``PauliOp`` if equal to the identity) which takes the\neigenvectors of ``diag_pauli_op1`` to the eigenvectors of ``diag_pauli_op2``,\nassuming both are diagonal (or performing this operation on their diagonalized Paulis\nimplicitly if not). This works by the insight that the eigenvalue of a diagonal Pauli's\neigenvector is equal to or -1 if the parity is 1 and 1 if the parity is 0, or\n1 - (2 * parity). Therefore, using CNOTs, we can write the parity of diag_pauli_op1's\nsignificant bits onto some qubit, and then write out that parity onto diag_pauli_op2's\nsignificant bits.\n\nArgs:\n    diag_pauli_op1: The origin ``PauliOp``.\n    diag_pauli_op2: The destination ``PauliOp``.\n\nReturn:\n    The ``PrimitiveOp`` performs the mapping.",
        "api_signature": "construct_cnot_chain(self, diag_pauli_op1, diag_pauli_op2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/converters/pauli_basis_change.py"
    },
    {
        "api_name": "get_cob_circuit",
        "full_api_name": "PauliBasisChange.get_cob_circuit",
        "api_description": "Construct an Operator which maps the +1 and -1 eigenvectors\nof the origin Pauli to the +1 and -1 eigenvectors of the destination Pauli. It does so by\n\n1) converting any \\|i+\u27e9 or \\|i+\u27e9 eigenvector bits in the origin to\n   \\|+\u27e9 and \\|-\u27e9 with S\u2020s, then\n\n2) converting any \\|+\u27e9 or \\|+\u27e9 eigenvector bits in the converted origin to\n   \\|0\u27e9 and \\|1\u27e9 with Hs, then\n\n3) writing the parity of the significant (Z-measured, rather than I)\n   bits in the origin to a single\n   \"origin anchor bit,\" using cnots, which will hold the parity of these bits,\n\n4) swapping the parity of the pauli anchor bit into a destination anchor bit using\n   a swap gate (only if they are different, if there are any bits which are significant\n   in both origin and dest, we set both anchors to one of these bits to avoid a swap).\n\n5) writing the parity of the destination anchor bit into the other significant bits\n   of the destination,\n\n6) converting the \\|0\u27e9 and \\|1\u27e9 significant eigenvector bits to \\|+\u27e9 and \\|-\u27e9 eigenvector\n   bits in the destination where the destination demands it\n   (e.g. pauli.x == true for a bit), using Hs 8) converting the \\|+\u27e9 and \\|-\u27e9\n   significant eigenvector bits to \\|i+\u27e9 and \\|i-\u27e9 eigenvector bits in the\n   destination where the destination demands it\n   (e.g. pauli.x == true and pauli.z == true for a bit), using Ss\n\nArgs:\n    origin: The ``Pauli`` or ``PauliOp`` to map.\n\nReturns:\n    A tuple of a ``PrimitiveOp`` which equals the basis change mapping and a ``PauliOp``\n    which equals the destination basis.\n\nRaises:\n    TypeError: Attempting to convert from non-Pauli origin.\n    ValueError: Attempting to change a non-identity Pauli to an identity Pauli, or vice\n        versa.",
        "api_signature": "get_cob_circuit(self, origin)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/converters/pauli_basis_change.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ConverterBase.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/converters/converter_base.py"
    },
    {
        "api_name": "convert",
        "full_api_name": "ConverterBase.convert",
        "api_description": "Accept the Operator and return the converted Operator\n\nArgs:\n    operator: The Operator to convert.\n\nReturns:\n    The converted Operator.",
        "api_signature": "convert(self, operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/converters/converter_base.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "AbelianGrouper.__init__",
        "api_description": "Args:\n    traverse: Whether to convert only the Operator passed to ``convert``, or traverse\n        down that Operator.",
        "api_signature": "__init__(self, traverse)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/converters/abelian_grouper.py"
    },
    {
        "api_name": "convert",
        "full_api_name": "AbelianGrouper.convert",
        "api_description": "Check if operator is a SummedOp, in which case covert it into a sum of mutually\ncommuting sums, or if the Operator contains sub-Operators and ``traverse`` is True,\nattempt to convert any sub-Operators.\n\nArgs:\n    operator: The Operator to attempt to convert.\n\nReturns:\n    The converted Operator.",
        "api_signature": "convert(self, operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/converters/abelian_grouper.py"
    },
    {
        "api_name": "group_subops",
        "full_api_name": "AbelianGrouper.group_subops",
        "api_description": "Given a ListOp, attempt to group into Abelian ListOps of the same type.\n\nArgs:\n    list_op: The Operator to group into Abelian groups\n\nReturns:\n    The grouped Operator.\n\nRaises:\n    OpflowError: If any of list_op's sub-ops is not ``PauliOp``.",
        "api_signature": "group_subops(cls, list_op)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/converters/abelian_grouper.py"
    },
    {
        "api_name": "_anti_commutation_graph",
        "full_api_name": "AbelianGrouper._anti_commutation_graph",
        "api_description": "Create edges (i, j) if i and j are not commutable.\n\nNote:\n    This method is applicable to only PauliOps.\n\nArgs:\n    ops: operators\n\nReturns:\n    A list of pairs of indices of the operators that are not commutable",
        "api_signature": "_anti_commutation_graph(ops)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/converters/abelian_grouper.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "TwoQubitReduction.__init__",
        "api_description": "Args:\n    num_particles: number of particles, if it is a list,\n                   the first number is alpha and the second number if beta.",
        "api_signature": "__init__(self, num_particles)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/converters/two_qubit_reduction.py"
    },
    {
        "api_name": "convert",
        "full_api_name": "TwoQubitReduction.convert",
        "api_description": "Converts the Operator to tapered one by Z2 symmetries.\n\nArgs:\n    operator: the operator\nReturns:\n    A new operator whose qubit number is reduced by 2.",
        "api_signature": "convert(self, operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/converters/two_qubit_reduction.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CircuitSampler.__init__",
        "api_description": "Args:\n    backend: The quantum backend or QuantumInstance to use to sample the circuits.\n    statevector: If backend is a statevector backend, whether to replace the\n        CircuitStateFns with DictStateFns (from the counts) or VectorStateFns (from the\n        statevector). ``None`` will set this argument automatically based on the backend.\n    attach_results: Whether to attach the data from the backend ``Results`` object for\n        a given ``CircuitStateFn``` to an ``execution_results`` field added the converted\n        ``DictStateFn`` or ``VectorStateFn``.\n    param_qobj: Whether to use Aer's parameterized Qobj capability to avoid re-assembling\n        the circuits.\n    caching: The caching strategy. Can be `'last'` (default) to store the last operator\n        that was converted, set to `'all'` to cache all processed operators.\n\nRaises:\n    ValueError: Set statevector or param_qobj True when not supported by backend.",
        "api_signature": "__init__(self, backend, statevector, param_qobj, attach_results, caching)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/converters/circuit_sampler.py"
    },
    {
        "api_name": "_check_quantum_instance_and_modes_consistent",
        "full_api_name": "CircuitSampler._check_quantum_instance_and_modes_consistent",
        "api_description": "Checks whether the statevector and param_qobj settings are compatible with the\nbackend\n\nRaises:\n    ValueError: statevector or param_qobj are True when not supported by backend.",
        "api_signature": "_check_quantum_instance_and_modes_consistent(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/converters/circuit_sampler.py"
    },
    {
        "api_name": "quantum_instance",
        "full_api_name": "CircuitSampler.quantum_instance",
        "api_description": "Returns the quantum instance.\n\nReturns:\n     The QuantumInstance used by the CircuitSampler",
        "api_signature": "quantum_instance(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/converters/circuit_sampler.py"
    },
    {
        "api_name": "quantum_instance",
        "full_api_name": "CircuitSampler.quantum_instance",
        "api_description": "Sets the QuantumInstance.\n\nRaises:\n    ValueError: statevector or param_qobj are True when not supported by backend.",
        "api_signature": "quantum_instance(self, quantum_instance)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/converters/circuit_sampler.py"
    },
    {
        "api_name": "convert",
        "full_api_name": "CircuitSampler.convert",
        "api_description": "Converts the Operator to one in which the CircuitStateFns are replaced by\nDictStateFns or VectorStateFns. Extracts the CircuitStateFns out of the Operator,\ncaches them, calls ``sample_circuits`` below to get their converted replacements,\nand replaces the CircuitStateFns in operator with the replacement StateFns.\n\nArgs:\n    operator: The Operator to convert\n    params: A dictionary mapping parameters to either single binding values or lists of\n        binding values.\n\nReturns:\n    The converted Operator with CircuitStateFns replaced by DictStateFns or VectorStateFns.\nRaises:\n    OpflowError: if extracted circuits are empty.",
        "api_signature": "convert(self, operator, params)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/converters/circuit_sampler.py"
    },
    {
        "api_name": "replace_circuits_with_dicts",
        "full_api_name": "CircuitSampler.replace_circuits_with_dicts",
        "api_description": "",
        "api_signature": "replace_circuits_with_dicts(operator, param_index)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/converters/circuit_sampler.py"
    },
    {
        "api_name": "clear_cache",
        "full_api_name": "CircuitSampler.clear_cache",
        "api_description": "Clear the cache of sampled operator expressions.",
        "api_signature": "clear_cache(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/converters/circuit_sampler.py"
    },
    {
        "api_name": "_extract_circuitstatefns",
        "full_api_name": "CircuitSampler._extract_circuitstatefns",
        "api_description": "Recursively extract the ``CircuitStateFns`` contained in operator into the\n``_circuit_ops_cache`` field.",
        "api_signature": "_extract_circuitstatefns(self, operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/converters/circuit_sampler.py"
    },
    {
        "api_name": "sample_circuits",
        "full_api_name": "CircuitSampler.sample_circuits",
        "api_description": "Samples the CircuitStateFns and returns a dict associating their ``id()`` values to their\nreplacement DictStateFn or VectorStateFn. If param_bindings is provided,\nthe CircuitStateFns are broken into their parameterizations, and a list of StateFns is\nreturned in the dict for each circuit ``id()``. Note that param_bindings is provided here\nin a different format than in ``convert``, and lists of parameters within the dict is not\nsupported, and only binding dicts which are valid to be passed into Terra can be included\nin this list.\n\nArgs:\n    circuit_sfns: The list of CircuitStateFns to sample.\n    param_bindings: The parameterizations to bind to each CircuitStateFn.\n\nReturns:\n    The dictionary mapping ids of the CircuitStateFns to their replacement StateFns.\nRaises:\n    OpflowError: if extracted circuits are empty.",
        "api_signature": "sample_circuits(self, circuit_sfns, param_bindings)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/converters/circuit_sampler.py"
    },
    {
        "api_name": "_build_aer_params",
        "full_api_name": "CircuitSampler._build_aer_params",
        "api_description": "",
        "api_signature": "_build_aer_params(self, circuit, building_param_tables, input_params)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/converters/circuit_sampler.py"
    },
    {
        "api_name": "resolve_param",
        "full_api_name": "CircuitSampler.resolve_param",
        "api_description": "",
        "api_signature": "resolve_param(inst_param)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/converters/circuit_sampler.py"
    },
    {
        "api_name": "_prepare_parameterized_run_config",
        "full_api_name": "CircuitSampler._prepare_parameterized_run_config",
        "api_description": "",
        "api_signature": "_prepare_parameterized_run_config(self, param_bindings)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/converters/circuit_sampler.py"
    },
    {
        "api_name": "_clean_parameterized_run_config",
        "full_api_name": "CircuitSampler._clean_parameterized_run_config",
        "api_description": "",
        "api_signature": "_clean_parameterized_run_config(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/converters/circuit_sampler.py"
    },
    {
        "api_name": "_filter_params",
        "full_api_name": "_filter_params",
        "api_description": "Remove all parameters from ``param_dict`` that are not in ``circuit``.",
        "api_signature": "_filter_params(circuit, param_dict)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/converters/circuit_sampler.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "StarAlgebraMixin.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/mixins/star_algebra.py"
    },
    {
        "api_name": "mul",
        "full_api_name": "StarAlgebraMixin.mul",
        "api_description": "Return scalar multiplication of self and other, overloaded by `*`.",
        "api_signature": "mul(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/mixins/star_algebra.py"
    },
    {
        "api_name": "__mul__",
        "full_api_name": "StarAlgebraMixin.__mul__",
        "api_description": "",
        "api_signature": "__mul__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/mixins/star_algebra.py"
    },
    {
        "api_name": "_multiply",
        "full_api_name": "StarAlgebraMixin._multiply",
        "api_description": "",
        "api_signature": "_multiply(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/mixins/star_algebra.py"
    },
    {
        "api_name": "add",
        "full_api_name": "StarAlgebraMixin.add",
        "api_description": "Return Operator addition of self and other, overloaded by `+`.",
        "api_signature": "add(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/mixins/star_algebra.py"
    },
    {
        "api_name": "__add__",
        "full_api_name": "StarAlgebraMixin.__add__",
        "api_description": "",
        "api_signature": "__add__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/mixins/star_algebra.py"
    },
    {
        "api_name": "__radd__",
        "full_api_name": "StarAlgebraMixin.__radd__",
        "api_description": "",
        "api_signature": "__radd__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/mixins/star_algebra.py"
    },
    {
        "api_name": "__sub__",
        "full_api_name": "StarAlgebraMixin.__sub__",
        "api_description": "",
        "api_signature": "__sub__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/mixins/star_algebra.py"
    },
    {
        "api_name": "__rsub__",
        "full_api_name": "StarAlgebraMixin.__rsub__",
        "api_description": "",
        "api_signature": "__rsub__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/mixins/star_algebra.py"
    },
    {
        "api_name": "compose",
        "full_api_name": "StarAlgebraMixin.compose",
        "api_description": "Overloads the matrix multiplication operator `@` for self and other.\n`Compose` computes operator composition between self and other (linear algebra-style:\nA@B(x) = A(B(x))).",
        "api_signature": "compose(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/mixins/star_algebra.py"
    },
    {
        "api_name": "power",
        "full_api_name": "StarAlgebraMixin.power",
        "api_description": "Return Operator composed with self multiple times, overloaded by ``**``.",
        "api_signature": "power(self, exponent)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/mixins/star_algebra.py"
    },
    {
        "api_name": "__matmul__",
        "full_api_name": "StarAlgebraMixin.__matmul__",
        "api_description": "",
        "api_signature": "__matmul__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/mixins/star_algebra.py"
    },
    {
        "api_name": "__pow__",
        "full_api_name": "StarAlgebraMixin.__pow__",
        "api_description": "",
        "api_signature": "__pow__(self, exponent)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/mixins/star_algebra.py"
    },
    {
        "api_name": "adjoint",
        "full_api_name": "StarAlgebraMixin.adjoint",
        "api_description": "Returns the complex conjugate transpose (dagger) of self.adjoint\n\nReturns:\n    An operator equivalent to self's adjoint.",
        "api_signature": "adjoint(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/mixins/star_algebra.py"
    },
    {
        "api_name": "__invert__",
        "full_api_name": "StarAlgebraMixin.__invert__",
        "api_description": "Overload unary `~` to return Operator adjoint.",
        "api_signature": "__invert__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/mixins/star_algebra.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "TensorMixin.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/mixins/tensor.py"
    },
    {
        "api_name": "__xor__",
        "full_api_name": "TensorMixin.__xor__",
        "api_description": "",
        "api_signature": "__xor__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/mixins/tensor.py"
    },
    {
        "api_name": "__rxor__",
        "full_api_name": "TensorMixin.__rxor__",
        "api_description": "",
        "api_signature": "__rxor__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/mixins/tensor.py"
    },
    {
        "api_name": "tensor",
        "full_api_name": "TensorMixin.tensor",
        "api_description": "Return tensor product between self and other, overloaded by ``^``.",
        "api_signature": "tensor(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/mixins/tensor.py"
    },
    {
        "api_name": "tensorpower",
        "full_api_name": "TensorMixin.tensorpower",
        "api_description": "Return tensor product with self multiple times, overloaded by ``^``.",
        "api_signature": "tensorpower(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/opflow/mixins/tensor.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "InstructionScheduleMap.__init__",
        "api_description": "Initialize a circuit instruction to schedule mapper instance.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instruction_schedule_map.py"
    },
    {
        "api_name": "has_custom_gate",
        "full_api_name": "InstructionScheduleMap.has_custom_gate",
        "api_description": "Return ``True`` if the map has user provided instruction.",
        "api_signature": "has_custom_gate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instruction_schedule_map.py"
    },
    {
        "api_name": "instructions",
        "full_api_name": "InstructionScheduleMap.instructions",
        "api_description": "Return all instructions which have definitions.\n\nBy default, these are typically the basis gates along with other instructions such as\nmeasure and reset.\n\nReturns:\n    The names of all the circuit instructions which have Schedule definitions in this.",
        "api_signature": "instructions(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instruction_schedule_map.py"
    },
    {
        "api_name": "qubits_with_instruction",
        "full_api_name": "InstructionScheduleMap.qubits_with_instruction",
        "api_description": "Return a list of the qubits for which the given instruction is defined. Single qubit\ninstructions return a flat list, and multiqubit instructions return a list of ordered\ntuples.\n\nArgs:\n    instruction: The name of the circuit instruction.\n\nReturns:\n    Qubit indices which have the given instruction defined. This is a list of tuples if the\n    instruction has an arity greater than 1, or a flat list of ints otherwise.\n\nRaises:\n    PulseError: If the instruction is not found.",
        "api_signature": "qubits_with_instruction(self, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instruction_schedule_map.py"
    },
    {
        "api_name": "qubit_instructions",
        "full_api_name": "InstructionScheduleMap.qubit_instructions",
        "api_description": "Return a list of the instruction names that are defined by the backend for the given\nqubit or qubits.\n\nArgs:\n    qubits: A qubit index, or a list or tuple of indices.\n\nReturns:\n    All the instructions which are defined on the qubits.\n\n    For 1 qubit, all the 1Q instructions defined. For multiple qubits, all the instructions\n    which apply to that whole set of qubits (e.g. ``qubits=[0, 1]`` may return ``['cx']``).",
        "api_signature": "qubit_instructions(self, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instruction_schedule_map.py"
    },
    {
        "api_name": "has",
        "full_api_name": "InstructionScheduleMap.has",
        "api_description": "Is the instruction defined for the given qubits?\n\nArgs:\n    instruction: The instruction for which to look.\n    qubits: The specific qubits for the instruction.\n\nReturns:\n    True iff the instruction is defined.",
        "api_signature": "has(self, instruction, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instruction_schedule_map.py"
    },
    {
        "api_name": "assert_has",
        "full_api_name": "InstructionScheduleMap.assert_has",
        "api_description": "Error if the given instruction is not defined.\n\nArgs:\n    instruction: The instruction for which to look.\n    qubits: The specific qubits for the instruction.\n\nRaises:\n    PulseError: If the instruction is not defined on the qubits.",
        "api_signature": "assert_has(self, instruction, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instruction_schedule_map.py"
    },
    {
        "api_name": "get",
        "full_api_name": "InstructionScheduleMap.get",
        "api_description": "Return the defined :py:class:`~qiskit.pulse.Schedule` or\n:py:class:`~qiskit.pulse.ScheduleBlock` for the given instruction on the given qubits.\n\nIf all keys are not specified this method returns schedule with unbound parameters.\n\nArgs:\n    instruction: Name of the instruction or the instruction itself.\n    qubits: The qubits for the instruction.\n    *params: Command parameters for generating the output schedule.\n    **kwparams: Keyworded command parameters for generating the schedule.\n\nReturns:\n    The Schedule defined for the input.",
        "api_signature": "get(self, instruction, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instruction_schedule_map.py"
    },
    {
        "api_name": "_get_calibration_entry",
        "full_api_name": "InstructionScheduleMap._get_calibration_entry",
        "api_description": "Return the :class:`.CalibrationEntry` without generating schedule.\n\nWhen calibration entry is un-parsed Pulse Qobj, this returns calibration\nwithout parsing it. :meth:`CalibrationEntry.get_schedule` method\nmust be manually called with assigned parameters to get corresponding pulse schedule.\n\nThis method is expected be directly used internally by the V2 backend converter\nfor faster loading of the backend calibrations.\n\nArgs:\n    instruction: Name of the instruction or the instruction itself.\n    qubits: The qubits for the instruction.\n\nReturns:\n    The calibration entry.",
        "api_signature": "_get_calibration_entry(self, instruction, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instruction_schedule_map.py"
    },
    {
        "api_name": "add",
        "full_api_name": "InstructionScheduleMap.add",
        "api_description": "Add a new known instruction for the given qubits and its mapping to a pulse schedule.\n\nArgs:\n    instruction: The name of the instruction to add.\n    qubits: The qubits which the instruction applies to.\n    schedule: The Schedule that implements the given instruction.\n    arguments: List of parameter names to create a parameter-bound schedule from the\n        associated gate instruction. If :py:meth:`get` is called with arguments rather\n        than keyword arguments, this parameter list is used to map the input arguments to\n        parameter objects stored in the target schedule.\n\nRaises:\n    PulseError: If the qubits are provided as an empty iterable.",
        "api_signature": "add(self, instruction, qubits, schedule, arguments)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instruction_schedule_map.py"
    },
    {
        "api_name": "_add",
        "full_api_name": "InstructionScheduleMap._add",
        "api_description": "A method to resister calibration entry.\n\n.. note::\n\n    This is internal fast-path function, and caller must ensure\n    the entry is properly formatted. This function may be used by other programs\n    that load backend calibrations to create Qiskit representation of it.\n\nArgs:\n    instruction_name: Name of instruction.\n    qubits: List of qubits that this calibration is applied.\n    entry: Calibration entry to register.\n\n:meta public:",
        "api_signature": "_add(self, instruction_name, qubits, entry)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instruction_schedule_map.py"
    },
    {
        "api_name": "remove",
        "full_api_name": "InstructionScheduleMap.remove",
        "api_description": "Remove the given instruction from the listing of instructions defined in self.\n\nArgs:\n    instruction: The name of the instruction to add.\n    qubits: The qubits which the instruction applies to.",
        "api_signature": "remove(self, instruction, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instruction_schedule_map.py"
    },
    {
        "api_name": "pop",
        "full_api_name": "InstructionScheduleMap.pop",
        "api_description": "Remove and return the defined schedule for the given instruction on the given\nqubits.\n\nArgs:\n    instruction: Name of the instruction.\n    qubits: The qubits for the instruction.\n    *params: Command parameters for generating the output schedule.\n    **kwparams: Keyworded command parameters for generating the schedule.\n\nReturns:\n    The Schedule defined for the input.",
        "api_signature": "pop(self, instruction, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instruction_schedule_map.py"
    },
    {
        "api_name": "get_parameters",
        "full_api_name": "InstructionScheduleMap.get_parameters",
        "api_description": "Return the list of parameters taken by the given instruction on the given qubits.\n\nArgs:\n    instruction: Name of the instruction.\n    qubits: The qubits for the instruction.\n\nReturns:\n    The names of the parameters required by the instruction.",
        "api_signature": "get_parameters(self, instruction, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instruction_schedule_map.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "InstructionScheduleMap.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instruction_schedule_map.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "InstructionScheduleMap.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instruction_schedule_map.py"
    },
    {
        "api_name": "_to_tuple",
        "full_api_name": "_to_tuple",
        "api_description": "Return the input as a tuple.\n\nArgs:\n    values: An integer, or iterable of integers.\n\nReturns:\n    The input values as a sorted tuple.",
        "api_signature": "_to_tuple(values)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instruction_schedule_map.py"
    },
    {
        "api_name": "_get_instruction_string",
        "full_api_name": "_get_instruction_string",
        "api_description": "",
        "api_signature": "_get_instruction_string(inst)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instruction_schedule_map.py"
    },
    {
        "api_name": "format_meas_map",
        "full_api_name": "format_meas_map",
        "api_description": "Return a mapping from qubit label to measurement group given the nested list meas_map returned\nby a backend configuration. (Qubits can not always be measured independently.) Sorts the\nmeasurement group for consistency.\n\nArgs:\n    meas_map: Groups of qubits that get measured together, for example: [[0, 1], [2, 3, 4]]\nReturns:\n    Measure map in map format",
        "api_signature": "format_meas_map(meas_map)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/utils.py"
    },
    {
        "api_name": "format_parameter_value",
        "full_api_name": "format_parameter_value",
        "api_description": "Convert ParameterExpression into the most suitable data type.\n\nArgs:\n    operand: Operand value in arbitrary data type including ParameterExpression.\n    decimal: Number of digit to round returned value.\n\nReturns:\n    Value casted to non-parameter data type, when possible.",
        "api_signature": "format_parameter_value(operand, decimal)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/utils.py"
    },
    {
        "api_name": "instruction_duration_validation",
        "full_api_name": "instruction_duration_validation",
        "api_description": "Validate instruction duration.\n\nArgs:\n    duration: Instruction duration value to validate.\n\nRaises:\n    UnassignedDurationError: When duration is unassigned.\n    QiskitError: When invalid duration is assigned.",
        "api_signature": "instruction_duration_validation(duration)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/utils.py"
    },
    {
        "api_name": "define",
        "full_api_name": "CalibrationEntry.define",
        "api_description": "Attach definition to the calibration entry.\n\nArgs:\n    definition: Definition of this entry.\n    user_provided: If this entry is defined by user.\n        If the flag is set, this calibration may appear in the wire format\n        as an inline calibration, to override the backend instruction set architecture.",
        "api_signature": "define(self, definition, user_provided)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/calibration_entries.py"
    },
    {
        "api_name": "get_signature",
        "full_api_name": "CalibrationEntry.get_signature",
        "api_description": "Return signature object associated with entry definition.\n\nReturns:\n    Signature object.",
        "api_signature": "get_signature(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/calibration_entries.py"
    },
    {
        "api_name": "get_schedule",
        "full_api_name": "CalibrationEntry.get_schedule",
        "api_description": "Generate schedule from entry definition.\n\nIf the pulse program is templated with :class:`.Parameter` objects,\nyou can provide corresponding parameter values for this method\nto get a particular pulse program with assigned parameters.\n\nArgs:\n    args: Command parameters.\n    kwargs: Command keyword parameters.\n\nReturns:\n    Pulse schedule with assigned parameters.",
        "api_signature": "get_schedule(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/calibration_entries.py"
    },
    {
        "api_name": "user_provided",
        "full_api_name": "CalibrationEntry.user_provided",
        "api_description": "Return if this entry is user defined.",
        "api_signature": "user_provided(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/calibration_entries.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ScheduleDef.__init__",
        "api_description": "Define an empty entry.\n\nArgs:\n    arguments: User provided argument names for this entry, if parameterized.\n\nRaises:\n    PulseError: When `arguments` is not a sequence of string.",
        "api_signature": "__init__(self, arguments)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/calibration_entries.py"
    },
    {
        "api_name": "user_provided",
        "full_api_name": "ScheduleDef.user_provided",
        "api_description": "",
        "api_signature": "user_provided(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/calibration_entries.py"
    },
    {
        "api_name": "_parse_argument",
        "full_api_name": "ScheduleDef._parse_argument",
        "api_description": "Generate signature from program and user provided argument names.",
        "api_signature": "_parse_argument(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/calibration_entries.py"
    },
    {
        "api_name": "define",
        "full_api_name": "ScheduleDef.define",
        "api_description": "",
        "api_signature": "define(self, definition, user_provided)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/calibration_entries.py"
    },
    {
        "api_name": "get_signature",
        "full_api_name": "ScheduleDef.get_signature",
        "api_description": "",
        "api_signature": "get_signature(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/calibration_entries.py"
    },
    {
        "api_name": "get_schedule",
        "full_api_name": "ScheduleDef.get_schedule",
        "api_description": "",
        "api_signature": "get_schedule(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/calibration_entries.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "ScheduleDef.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/calibration_entries.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "ScheduleDef.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/calibration_entries.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CallableDef.__init__",
        "api_description": "Define an empty entry.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/calibration_entries.py"
    },
    {
        "api_name": "user_provided",
        "full_api_name": "CallableDef.user_provided",
        "api_description": "",
        "api_signature": "user_provided(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/calibration_entries.py"
    },
    {
        "api_name": "define",
        "full_api_name": "CallableDef.define",
        "api_description": "",
        "api_signature": "define(self, definition, user_provided)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/calibration_entries.py"
    },
    {
        "api_name": "get_signature",
        "full_api_name": "CallableDef.get_signature",
        "api_description": "",
        "api_signature": "get_signature(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/calibration_entries.py"
    },
    {
        "api_name": "get_schedule",
        "full_api_name": "CallableDef.get_schedule",
        "api_description": "",
        "api_signature": "get_schedule(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/calibration_entries.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "CallableDef.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/calibration_entries.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "CallableDef.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/calibration_entries.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PulseQobjDef.__init__",
        "api_description": "Define an empty entry.\n\nArgs:\n    arguments: User provided argument names for this entry, if parameterized.\n    converter: Optional. Qobj to Qiskit converter.\n    name: Name of schedule.",
        "api_signature": "__init__(self, arguments, converter, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/calibration_entries.py"
    },
    {
        "api_name": "_build_schedule",
        "full_api_name": "PulseQobjDef._build_schedule",
        "api_description": "Build pulse schedule from cmd-def sequence.",
        "api_signature": "_build_schedule(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/calibration_entries.py"
    },
    {
        "api_name": "define",
        "full_api_name": "PulseQobjDef.define",
        "api_description": "",
        "api_signature": "define(self, definition, user_provided)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/calibration_entries.py"
    },
    {
        "api_name": "get_signature",
        "full_api_name": "PulseQobjDef.get_signature",
        "api_description": "",
        "api_signature": "get_signature(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/calibration_entries.py"
    },
    {
        "api_name": "get_schedule",
        "full_api_name": "PulseQobjDef.get_schedule",
        "api_description": "",
        "api_signature": "get_schedule(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/calibration_entries.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "PulseQobjDef.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/calibration_entries.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "PulseQobjDef.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/calibration_entries.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PulseError.__init__",
        "api_description": "Set the error message.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/exceptions.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "PulseError.__str__",
        "api_description": "Return the message.",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/exceptions.py"
    },
    {
        "api_name": "_compile_lazy_circuit_before",
        "full_api_name": "_compile_lazy_circuit_before",
        "api_description": "Decorator thats schedules and calls the lazily compiled circuit before\nexecuting the decorated builder method.",
        "api_signature": "_compile_lazy_circuit_before(function)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "wrapper",
        "full_api_name": "wrapper",
        "api_description": "",
        "api_signature": "wrapper(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "_requires_backend",
        "full_api_name": "_requires_backend",
        "api_description": "Decorator a function to raise if it is called without a builder with a\nset backend.",
        "api_signature": "_requires_backend(function)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "wrapper",
        "full_api_name": "wrapper",
        "api_description": "",
        "api_signature": "wrapper(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "_PulseBuilder.__init__",
        "api_description": "Initialize the builder context.\n\n.. note::\n    At some point we may consider incorporating the builder into\n    the :class:`~qiskit.pulse.Schedule` class. However, the risk of\n    this is tying the user interface to the intermediate\n    representation. For now we avoid this at the cost of some code\n    duplication.\n\nArgs:\n    backend (Backend): Input backend to use in\n        builder. If not set certain functionality will be unavailable.\n    block: Initital ``ScheduleBlock`` to build on.\n    name: Name of pulse program to be built.\n    default_alignment: Default scheduling alignment for builder.\n        One of ``left``, ``right``, ``sequential`` or an instance of\n        :class:`~qiskit.pulse.transforms.alignments.AlignmentKind` subclass.\n    default_transpiler_settings: Default settings for the transpiler.\n    default_circuit_scheduler_settings: Default settings for the\n        circuit to pulse scheduler.\n\nRaises:\n    PulseError: When invalid ``default_alignment`` or `block` is specified.",
        "api_signature": "__init__(self, backend, block, name, default_alignment, default_transpiler_settings, default_circuit_scheduler_settings)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "__enter__",
        "full_api_name": "_PulseBuilder.__enter__",
        "api_description": "Enter this builder context and yield either the supplied schedule\nor the schedule created for the user.\n\nReturns:\n    The schedule that the builder will build on.",
        "api_signature": "__enter__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "__exit__",
        "full_api_name": "_PulseBuilder.__exit__",
        "api_description": "Exit the builder context and compile the built pulse program.",
        "api_signature": "__exit__(self, exc_type, exc_val, exc_tb)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "backend",
        "full_api_name": "_PulseBuilder.backend",
        "api_description": "Returns the builder backend if set.\n\nReturns:\n    Optional[Backend]: The builder's backend.",
        "api_signature": "backend(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "push_context",
        "full_api_name": "_PulseBuilder.push_context",
        "api_description": "Push new context to the stack.",
        "api_signature": "push_context(self, alignment)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "pop_context",
        "full_api_name": "_PulseBuilder.pop_context",
        "api_description": "Pop the last context from the stack.",
        "api_signature": "pop_context(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "get_context",
        "full_api_name": "_PulseBuilder.get_context",
        "api_description": "Get current context.\n\nNotes:\n    New instruction can be added by `.append_subroutine` or `.append_instruction` method.\n    Use above methods rather than directly accessing to the current context.",
        "api_signature": "get_context(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "num_qubits",
        "full_api_name": "_PulseBuilder.num_qubits",
        "api_description": "Get the number of qubits in the backend.",
        "api_signature": "num_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "transpiler_settings",
        "full_api_name": "_PulseBuilder.transpiler_settings",
        "api_description": "The builder's transpiler settings.",
        "api_signature": "transpiler_settings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "transpiler_settings",
        "full_api_name": "_PulseBuilder.transpiler_settings",
        "api_description": "",
        "api_signature": "transpiler_settings(self, settings)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "circuit_scheduler_settings",
        "full_api_name": "_PulseBuilder.circuit_scheduler_settings",
        "api_description": "The builder's circuit to pulse scheduler settings.",
        "api_signature": "circuit_scheduler_settings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "circuit_scheduler_settings",
        "full_api_name": "_PulseBuilder.circuit_scheduler_settings",
        "api_description": "",
        "api_signature": "circuit_scheduler_settings(self, settings)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "compile",
        "full_api_name": "_PulseBuilder.compile",
        "api_description": "Compile and output the built pulse program.",
        "api_signature": "compile(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "_compile_lazy_circuit",
        "full_api_name": "_PulseBuilder._compile_lazy_circuit",
        "api_description": "Call a context QuantumCircuit (lazy circuit) and append the output pulse schedule\nto the builder's context schedule.\n\nNote that the lazy circuit is not stored as a call instruction.",
        "api_signature": "_compile_lazy_circuit(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "_compile_circuit",
        "full_api_name": "_PulseBuilder._compile_circuit",
        "api_description": "Take a QuantumCircuit and output the pulse schedule associated with the circuit.",
        "api_signature": "_compile_circuit(self, circ)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "_new_circuit",
        "full_api_name": "_PulseBuilder._new_circuit",
        "api_description": "Create a new circuit for lazy circuit scheduling.",
        "api_signature": "_new_circuit(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "append_instruction",
        "full_api_name": "_PulseBuilder.append_instruction",
        "api_description": "Add an instruction to the builder's context schedule.\n\nArgs:\n    instruction: Instruction to append.",
        "api_signature": "append_instruction(self, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "append_reference",
        "full_api_name": "_PulseBuilder.append_reference",
        "api_description": "Add external program as a :class:`~qiskit.pulse.instructions.Reference` instruction.\n\nArgs:\n    name: Name of subroutine.\n    extra_keys: Assistance keys to uniquely specify the subroutine.",
        "api_signature": "append_reference(self, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "append_subroutine",
        "full_api_name": "_PulseBuilder.append_subroutine",
        "api_description": "Append a :class:`ScheduleBlock` to the builder's context schedule.\n\nThis operation doesn't create a reference. Subroutine is directly\nappended to current context schedule.\n\nArgs:\n    subroutine: ScheduleBlock to append to the current context block.\n\nRaises:\n    PulseError: When subroutine is not Schedule nor ScheduleBlock.",
        "api_signature": "append_subroutine(self, subroutine)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "call_subroutine",
        "full_api_name": "_PulseBuilder.call_subroutine",
        "api_description": "Call a schedule or circuit defined outside of the current scope.\n\nThe ``subroutine`` is appended to the context schedule as a call instruction.\nThis logic just generates a convenient program representation in the compiler.\nThus, this doesn't affect execution of inline subroutines.\nSee :class:`~pulse.instructions.Call` for more details.\n\nArgs:\n    subroutine: Target schedule or circuit to append to the current context.\n    name: Name of subroutine if defined.\n    value_dict: Parameter object and assigned value mapping. This is more precise way to\n        identify a parameter since mapping is managed with unique object id rather than\n        name. Especially there is any name collision in a parameter table.\n    kw_params: Parameter values to bind to the target subroutine\n        with string parameter names. If there are parameter name overlapping,\n        these parameters are updated with the same assigned value.\n\nRaises:\n    PulseError:\n        - When input subroutine is not valid data format.",
        "api_signature": "call_subroutine(self, subroutine, name, value_dict)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "_",
        "full_api_name": "_PulseBuilder._",
        "api_description": "",
        "api_signature": "_(self, target_block, name, value_dict)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "_",
        "full_api_name": "_PulseBuilder._",
        "api_description": "",
        "api_signature": "_(self, target_schedule, name, value_dict)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "_",
        "full_api_name": "_PulseBuilder._",
        "api_description": "",
        "api_signature": "_(self, target_circuit, name, value_dict)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "call_gate",
        "full_api_name": "_PulseBuilder.call_gate",
        "api_description": "Call the circuit ``gate`` in the pulse program.\n\nThe qubits are assumed to be defined on physical qubits.\n\nIf ``lazy == True`` this circuit will extend a lazily constructed\nquantum circuit. When an operation occurs that breaks the underlying\ncircuit scheduling assumptions such as adding a pulse instruction or\nchanging the alignment context the circuit will be\ntranspiled and scheduled into pulses with the current active settings.\n\nArgs:\n    gate: Gate to call.\n    qubits: Qubits to call gate on.\n    lazy: If false the circuit will be transpiled and pulse scheduled\n        immediately. Otherwise, it will extend the active lazy circuit\n        as defined above.",
        "api_signature": "call_gate(self, gate, qubits, lazy)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "_call_gate",
        "full_api_name": "_PulseBuilder._call_gate",
        "api_description": "",
        "api_signature": "_call_gate(self, gate, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "_naive_typecast_schedule",
        "full_api_name": "_PulseBuilder._naive_typecast_schedule",
        "api_description": "",
        "api_signature": "_naive_typecast_schedule(schedule)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "get_dt",
        "full_api_name": "_PulseBuilder.get_dt",
        "api_description": "Retrieve dt differently based on the type of Backend",
        "api_signature": "get_dt(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "build",
        "full_api_name": "build",
        "api_description": "Create a context manager for launching the imperative pulse builder DSL.\n\nTo enter a building context and starting building a pulse program:\n\n.. code-block::\n\n    from qiskit import execute, pulse\n    from qiskit.providers.fake_provider import FakeOpenPulse2Q\n\n    backend = FakeOpenPulse2Q()\n\n    d0 = pulse.DriveChannel(0)\n\n    with pulse.build() as pulse_prog:\n        pulse.play(pulse.Constant(100, 0.5), d0)\n\n\nWhile the output program ``pulse_prog`` cannot be executed as we are using\na mock backend. If a real backend is being used, executing the program is\ndone with:\n\n.. code-block:: python\n\n    qiskit.execute(pulse_prog, backend)\n\nArgs:\n    backend (Backend): A Qiskit backend. If not supplied certain\n        builder functionality will be unavailable.\n    schedule: A pulse ``ScheduleBlock`` in which your pulse program will be built.\n    name: Name of pulse program to be built.\n    default_alignment: Default scheduling alignment for builder.\n        One of ``left``, ``right``, ``sequential`` or an alignment context.\n    default_transpiler_settings: Default settings for the transpiler.\n    default_circuit_scheduler_settings: Default settings for the\n        circuit to pulse scheduler.\n\nReturns:\n    A new builder context which has the active builder initialized.",
        "api_signature": "build(backend, schedule, name, default_alignment, default_transpiler_settings, default_circuit_scheduler_settings)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "_active_builder",
        "full_api_name": "_active_builder",
        "api_description": "Get the active builder in the active context.\n\nReturns:\n    The active active builder in this context.\n\nRaises:\n    exceptions.NoActiveBuilder: If a pulse builder function is called\n    outside of a builder context.",
        "api_signature": "_active_builder()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "active_backend",
        "full_api_name": "active_backend",
        "api_description": "Get the backend of the currently active builder context.\n\nReturns:\n    Backend: The active backend in the currently active\n        builder context.\n\nRaises:\n    exceptions.BackendNotSet: If the builder does not have a backend set.",
        "api_signature": "active_backend()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "append_schedule",
        "full_api_name": "append_schedule",
        "api_description": "Call a schedule by appending to the active builder's context block.\n\nArgs:\n    schedule: Schedule or ScheduleBlock to append.",
        "api_signature": "append_schedule(schedule)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "append_instruction",
        "full_api_name": "append_instruction",
        "api_description": "Append an instruction to the active builder's context schedule.\n\nExamples:\n\n.. code-block::\n\n    from qiskit import pulse\n\n    d0 = pulse.DriveChannel(0)\n\n    with pulse.build() as pulse_prog:\n        pulse.builder.append_instruction(pulse.Delay(10, d0))\n\n    print(pulse_prog.instructions)\n\n.. parsed-literal::\n\n    ((0, Delay(10, DriveChannel(0))),)",
        "api_signature": "append_instruction(instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "num_qubits",
        "full_api_name": "num_qubits",
        "api_description": "Return number of qubits in the currently active backend.\n\nExamples:\n\n.. code-block::\n\n    from qiskit import pulse\n    from qiskit.providers.fake_provider import FakeOpenPulse2Q\n\n    backend = FakeOpenPulse2Q()\n\n    with pulse.build(backend):\n        print(pulse.num_qubits())\n\n.. parsed-literal::\n\n   2\n\n.. note:: Requires the active builder context to have a backend set.",
        "api_signature": "num_qubits()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "seconds_to_samples",
        "full_api_name": "seconds_to_samples",
        "api_description": "Obtain the number of samples that will elapse in ``seconds`` on the\nactive backend.\n\nRounds down.\n\nArgs:\n    seconds: Time in seconds to convert to samples.\n\nReturns:\n    The number of samples for the time to elapse",
        "api_signature": "seconds_to_samples(seconds)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "samples_to_seconds",
        "full_api_name": "samples_to_seconds",
        "api_description": "Obtain the time in seconds that will elapse for the input number of\nsamples on the active backend.\n\nArgs:\n    samples: Number of samples to convert to time in seconds.\n\nReturns:\n    The time that elapses in ``samples``.",
        "api_signature": "samples_to_seconds(samples)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "qubit_channels",
        "full_api_name": "qubit_channels",
        "api_description": "Returns the set of channels associated with a qubit.\n\nExamples:\n\n.. code-block::\n\n    from qiskit import pulse\n    from qiskit.providers.fake_provider import FakeOpenPulse2Q\n\n    backend = FakeOpenPulse2Q()\n\n    with pulse.build(backend):\n        print(pulse.qubit_channels(0))\n\n.. parsed-literal::\n\n   {MeasureChannel(0), ControlChannel(0), DriveChannel(0), AcquireChannel(0), ControlChannel(1)}\n\n.. note:: Requires the active builder context to have a backend set.\n\n.. note:: A channel may still be associated with another qubit in this list\n    such as in the case where significant crosstalk exists.",
        "api_signature": "qubit_channels(qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "get_qubit_channels_v2",
        "full_api_name": "get_qubit_channels_v2",
        "api_description": "Return a list of channels which operate on the given ``qubit``.\nReturns:\n    List of ``Channel``\\s operated on my the given ``qubit``.",
        "api_signature": "get_qubit_channels_v2(backend, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "_qubits_to_channels",
        "full_api_name": "_qubits_to_channels",
        "api_description": "Returns the unique channels of the input qubits.",
        "api_signature": "_qubits_to_channels()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "active_transpiler_settings",
        "full_api_name": "active_transpiler_settings",
        "api_description": "Return the current active builder context's transpiler settings.\n\nExamples:\n\n.. code-block::\n\n    from qiskit import pulse\n    from qiskit.providers.fake_provider import FakeOpenPulse2Q\n\n    backend = FakeOpenPulse2Q()\n\n    transpiler_settings = {'optimization_level': 3}\n\n    with pulse.build(backend,\n                     default_transpiler_settings=transpiler_settings):\n        print(pulse.active_transpiler_settings())\n\n.. parsed-literal::\n\n    {'optimization_level': 3}",
        "api_signature": "active_transpiler_settings()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "active_circuit_scheduler_settings",
        "full_api_name": "active_circuit_scheduler_settings",
        "api_description": "Return the current active builder context's circuit scheduler settings.\n\nExamples:\n\n.. code-block::\n\n    from qiskit import pulse\n    from qiskit.providers.fake_provider import FakeOpenPulse2Q\n\n    backend = FakeOpenPulse2Q()\n\n    circuit_scheduler_settings = {'method': 'alap'}\n\n    with pulse.build(\n            backend,\n            default_circuit_scheduler_settings=circuit_scheduler_settings):\n        print(pulse.active_circuit_scheduler_settings())\n\n.. parsed-literal::\n\n   {'method': 'alap'}",
        "api_signature": "active_circuit_scheduler_settings()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "align_left",
        "full_api_name": "align_left",
        "api_description": "Left alignment pulse scheduling context.\n\nPulse instructions within this context are scheduled as early as possible\nby shifting them left to the earliest available time.\n\nExamples:\n\n.. code-block::\n\n    from qiskit import pulse\n\n    d0 = pulse.DriveChannel(0)\n    d1 = pulse.DriveChannel(1)\n\n    with pulse.build() as pulse_prog:\n        with pulse.align_left():\n            # this pulse will start at t=0\n            pulse.play(pulse.Constant(100, 1.0), d0)\n            # this pulse will start at t=0\n            pulse.play(pulse.Constant(20, 1.0), d1)\n    pulse_prog = pulse.transforms.block_to_schedule(pulse_prog)\n\n    assert pulse_prog.ch_start_time(d0) == pulse_prog.ch_start_time(d1)\n\nYields:\n    None",
        "api_signature": "align_left()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "align_right",
        "full_api_name": "align_right",
        "api_description": "Right alignment pulse scheduling context.\n\nPulse instructions within this context are scheduled as late as possible\nby shifting them right to the latest available time.\n\nExamples:\n\n.. code-block::\n\n    from qiskit import pulse\n\n    d0 = pulse.DriveChannel(0)\n    d1 = pulse.DriveChannel(1)\n\n    with pulse.build() as pulse_prog:\n        with pulse.align_right():\n            # this pulse will start at t=0\n            pulse.play(pulse.Constant(100, 1.0), d0)\n            # this pulse will start at t=80\n            pulse.play(pulse.Constant(20, 1.0), d1)\n    pulse_prog = pulse.transforms.block_to_schedule(pulse_prog)\n\n    assert pulse_prog.ch_stop_time(d0) == pulse_prog.ch_stop_time(d1)\n\nYields:\n    None",
        "api_signature": "align_right()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "align_sequential",
        "full_api_name": "align_sequential",
        "api_description": "Sequential alignment pulse scheduling context.\n\nPulse instructions within this context are scheduled sequentially in time\nsuch that no two instructions will be played at the same time.\n\nExamples:\n\n.. code-block::\n\n    from qiskit import pulse\n\n    d0 = pulse.DriveChannel(0)\n    d1 = pulse.DriveChannel(1)\n\n    with pulse.build() as pulse_prog:\n        with pulse.align_sequential():\n            # this pulse will start at t=0\n            pulse.play(pulse.Constant(100, 1.0), d0)\n            # this pulse will also start at t=100\n            pulse.play(pulse.Constant(20, 1.0), d1)\n    pulse_prog = pulse.transforms.block_to_schedule(pulse_prog)\n\n    assert pulse_prog.ch_stop_time(d0) == pulse_prog.ch_start_time(d1)\n\nYields:\n    None",
        "api_signature": "align_sequential()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "align_equispaced",
        "full_api_name": "align_equispaced",
        "api_description": "Equispaced alignment pulse scheduling context.\n\nPulse instructions within this context are scheduled with the same interval spacing such that\nthe total length of the context block is ``duration``.\nIf the total free ``duration`` cannot be evenly divided by the number of instructions\nwithin the context, the modulo is split and then prepended and appended to\nthe returned schedule. Delay instructions are automatically inserted in between pulses.\n\nThis context is convenient to write a schedule for periodical dynamic decoupling or\nthe Hahn echo sequence.\n\nExamples:\n\n.. plot::\n   :include-source:\n\n    from qiskit import pulse\n\n    d0 = pulse.DriveChannel(0)\n    x90 = pulse.Gaussian(10, 0.1, 3)\n    x180 = pulse.Gaussian(10, 0.2, 3)\n\n    with pulse.build() as hahn_echo:\n        with pulse.align_equispaced(duration=100):\n            pulse.play(x90, d0)\n            pulse.play(x180, d0)\n            pulse.play(x90, d0)\n\n    hahn_echo.draw()\n\nArgs:\n    duration: Duration of this context. This should be larger than the schedule duration.\n\nYields:\n    None\n\nNotes:\n    The scheduling is performed for sub-schedules within the context rather than\n    channel-wise. If you want to apply the equispaced context for each channel,\n    you should use the context independently for channels.",
        "api_signature": "align_equispaced(duration)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "align_func",
        "full_api_name": "align_func",
        "api_description": "Callback defined alignment pulse scheduling context.\n\nPulse instructions within this context are scheduled at the location specified by\narbitrary callback function `position` that takes integer index and returns\nthe associated fractional location within [0, 1].\nDelay instruction is automatically inserted in between pulses.\n\nThis context may be convenient to write a schedule of arbitrary dynamical decoupling\nsequences such as Uhrig dynamical decoupling.\n\nExamples:\n\n.. plot::\n   :include-source:\n\n    import numpy as np\n    from qiskit import pulse\n\n    d0 = pulse.DriveChannel(0)\n    x90 = pulse.Gaussian(10, 0.1, 3)\n    x180 = pulse.Gaussian(10, 0.2, 3)\n\n    def udd10_pos(j):\n        return np.sin(np.pi*j/(2*10 + 2))**2\n\n    with pulse.build() as udd_sched:\n        pulse.play(x90, d0)\n        with pulse.align_func(duration=300, func=udd10_pos):\n            for _ in range(10):\n                pulse.play(x180, d0)\n        pulse.play(x90, d0)\n\n    udd_sched.draw()\n\nArgs:\n    duration: Duration of context. This should be larger than the schedule duration.\n    func: A function that takes an index of sub-schedule and returns the\n        fractional coordinate of of that sub-schedule.\n        The returned value should be defined within [0, 1].\n        The pulse index starts from 1.\n\nYields:\n    None\n\nNotes:\n    The scheduling is performed for sub-schedules within the context rather than\n    channel-wise. If you want to apply the numerical context for each channel,\n    you need to apply the context independently to channels.",
        "api_signature": "align_func(duration, func)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "general_transforms",
        "full_api_name": "general_transforms",
        "api_description": "Arbitrary alignment transformation defined by a subclass instance of\n:class:`~qiskit.pulse.transforms.alignments.AlignmentKind`.\n\nArgs:\n    alignment_context: Alignment context instance that defines schedule transformation.\n\nYields:\n    None\n\nRaises:\n    PulseError: When input ``alignment_context`` is not ``AlignmentKind`` subclasses.",
        "api_signature": "general_transforms(alignment_context)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "transpiler_settings",
        "full_api_name": "transpiler_settings",
        "api_description": "Set the currently active transpiler settings for this context.\n\nExamples:\n\n.. code-block::\n\n    from qiskit import pulse\n    from qiskit.providers.fake_provider import FakeOpenPulse2Q\n\n    backend = FakeOpenPulse2Q()\n\n    with pulse.build(backend):\n        print(pulse.active_transpiler_settings())\n        with pulse.transpiler_settings(optimization_level=3):\n            print(pulse.active_transpiler_settings())\n\n.. parsed-literal::\n\n    {}\n    {'optimization_level': 3}",
        "api_signature": "transpiler_settings()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "circuit_scheduler_settings",
        "full_api_name": "circuit_scheduler_settings",
        "api_description": "Set the currently active circuit scheduler settings for this context.\n\nExamples:\n\n.. code-block::\n\n    from qiskit import pulse\n    from qiskit.providers.fake_provider import FakeOpenPulse2Q\n\n    backend = FakeOpenPulse2Q()\n\n    with pulse.build(backend):\n        print(pulse.active_circuit_scheduler_settings())\n        with pulse.circuit_scheduler_settings(method='alap'):\n            print(pulse.active_circuit_scheduler_settings())\n\n.. parsed-literal::\n\n   {}\n   {'method': 'alap'}",
        "api_signature": "circuit_scheduler_settings()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "phase_offset",
        "full_api_name": "phase_offset",
        "api_description": "Shift the phase of input channels on entry into context and undo on exit.\n\nExamples:\n\n.. code-block::\n\n    import math\n\n    from qiskit import pulse\n\n    d0 = pulse.DriveChannel(0)\n\n    with pulse.build() as pulse_prog:\n        with pulse.phase_offset(math.pi, d0):\n            pulse.play(pulse.Constant(10, 1.0), d0)\n\n    assert len(pulse_prog.instructions) == 3\n\nArgs:\n    phase: Amount of phase offset in radians.\n    channels: Channels to offset phase of.\n\nYields:\n    None",
        "api_signature": "phase_offset(phase)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "frequency_offset",
        "full_api_name": "frequency_offset",
        "api_description": "Shift the frequency of inputs channels on entry into context and undo on exit.\n\nExamples:\n\n.. code-block:: python\n    :emphasize-lines: 7, 16\n\n    from qiskit import pulse\n\n    d0 = pulse.DriveChannel(0)\n\n    with pulse.build(backend) as pulse_prog:\n        # shift frequency by 1GHz\n        with pulse.frequency_offset(1e9, d0):\n            pulse.play(pulse.Constant(10, 1.0), d0)\n\n    assert len(pulse_prog.instructions) == 3\n\n    with pulse.build(backend) as pulse_prog:\n        # Shift frequency by 1GHz.\n        # Undo accumulated phase in the shifted frequency frame\n        # when exiting the context.\n        with pulse.frequency_offset(1e9, d0, compensate_phase=True):\n            pulse.play(pulse.Constant(10, 1.0), d0)\n\n    assert len(pulse_prog.instructions) == 4\n\nArgs:\n    frequency: Amount of frequency offset in Hz.\n    channels: Channels to offset frequency of.\n    compensate_phase: Compensate for accumulated phase accumulated with\n        respect to the channels' frame at its initial frequency.\n\nYields:\n    None",
        "api_signature": "frequency_offset(frequency)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "drive_channel",
        "full_api_name": "drive_channel",
        "api_description": "Return ``DriveChannel`` for ``qubit`` on the active builder backend.\n\nExamples:\n\n.. code-block::\n\n    from qiskit import pulse\n    from qiskit.providers.fake_provider import FakeOpenPulse2Q\n\n    backend = FakeOpenPulse2Q()\n\n    with pulse.build(backend):\n        assert pulse.drive_channel(0) == pulse.DriveChannel(0)\n\n.. note:: Requires the active builder context to have a backend set.",
        "api_signature": "drive_channel(qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "measure_channel",
        "full_api_name": "measure_channel",
        "api_description": "Return ``MeasureChannel`` for ``qubit`` on the active builder backend.\n\nExamples:\n\n.. code-block::\n\n    from qiskit import pulse\n    from qiskit.providers.fake_provider import FakeOpenPulse2Q\n\n    backend = FakeOpenPulse2Q()\n\n    with pulse.build(backend):\n        assert pulse.measure_channel(0) == pulse.MeasureChannel(0)\n\n.. note:: Requires the active builder context to have a backend set.",
        "api_signature": "measure_channel(qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "acquire_channel",
        "full_api_name": "acquire_channel",
        "api_description": "Return ``AcquireChannel`` for ``qubit`` on the active builder backend.\n\nExamples:\n\n.. code-block::\n\n    from qiskit import pulse\n    from qiskit.providers.fake_provider import FakeOpenPulse2Q\n\n    backend = FakeOpenPulse2Q()\n\n    with pulse.build(backend):\n        assert pulse.acquire_channel(0) == pulse.AcquireChannel(0)\n\n.. note:: Requires the active builder context to have a backend set.",
        "api_signature": "acquire_channel(qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "control_channels",
        "full_api_name": "control_channels",
        "api_description": "Return ``ControlChannel`` for ``qubit`` on the active builder backend.\n\nReturn the secondary drive channel for the given qubit -- typically\nutilized for controlling multi-qubit interactions.\n\nExamples:\n\n.. code-block::\n\n    from qiskit import pulse\n    from qiskit.providers.fake_provider import FakeOpenPulse2Q\n\n    backend = FakeOpenPulse2Q()\n    with pulse.build(backend):\n        assert pulse.control_channels(0, 1) == [pulse.ControlChannel(0)]\n\n.. note:: Requires the active builder context to have a backend set.\n\nArgs:\n  qubits: Tuple or list of ordered qubits of the form\n    `(control_qubit, target_qubit)`.\n\nReturns:\n    List of control channels associated with the supplied ordered list\n    of qubits.",
        "api_signature": "control_channels()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "delay",
        "full_api_name": "delay",
        "api_description": "Delay on a ``channel`` for a ``duration``.\n\nExamples:\n\n.. code-block::\n\n    from qiskit import pulse\n\n    d0 = pulse.DriveChannel(0)\n\n    with pulse.build() as pulse_prog:\n        pulse.delay(10, d0)\n\nArgs:\n    duration: Number of cycles to delay for on ``channel``.\n    channel: Channel to delay on.\n    name: Name of the instruction.",
        "api_signature": "delay(duration, channel, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "play",
        "full_api_name": "play",
        "api_description": "Play a ``pulse`` on a ``channel``.\n\nExamples:\n\n.. code-block::\n\n    from qiskit import pulse\n\n    d0 = pulse.DriveChannel(0)\n\n    with pulse.build() as pulse_prog:\n        pulse.play(pulse.Constant(10, 1.0), d0)\n\nArgs:\n    pulse: Pulse to play.\n    channel: Channel to play pulse on.\n    name: Name of the pulse.",
        "api_signature": "play(pulse, channel, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "acquire",
        "full_api_name": "acquire",
        "api_description": "Acquire for a ``duration`` on a ``channel`` and store the result\nin a ``register``.\n\nExamples:\n\n.. code-block::\n\n    from qiskit import pulse\n\n    acq0 = pulse.AcquireChannel(0)\n    mem0 = pulse.MemorySlot(0)\n\n    with pulse.build() as pulse_prog:\n        pulse.acquire(100, acq0, mem0)\n\n        # measurement metadata\n        kernel = pulse.configuration.Kernel('linear_discriminator')\n        pulse.acquire(100, acq0, mem0, kernel=kernel)\n\n.. note:: The type of data acquire will depend on the execution ``meas_level``.\n\nArgs:\n    duration: Duration to acquire data for\n    qubit_or_channel: Either the qubit to acquire data for or the specific\n        :class:`~qiskit.pulse.channels.AcquireChannel` to acquire on.\n    register: Location to store measured result.\n    metadata: Additional metadata for measurement. See\n        :class:`~qiskit.pulse.instructions.Acquire` for more information.\n\nRaises:\n    exceptions.PulseError: If the register type is not supported.",
        "api_signature": "acquire(duration, qubit_or_channel, register)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "set_frequency",
        "full_api_name": "set_frequency",
        "api_description": "Set the ``frequency`` of a pulse ``channel``.\n\nExamples:\n\n.. code-block::\n\n    from qiskit import pulse\n\n    d0 = pulse.DriveChannel(0)\n\n    with pulse.build() as pulse_prog:\n        pulse.set_frequency(1e9, d0)\n\nArgs:\n    frequency: Frequency in Hz to set channel to.\n    channel: Channel to set frequency of.\n    name: Name of the instruction.",
        "api_signature": "set_frequency(frequency, channel, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "shift_frequency",
        "full_api_name": "shift_frequency",
        "api_description": "Shift the ``frequency`` of a pulse ``channel``.\n\nExamples:\n\n.. code-block:: python\n    :emphasize-lines: 6\n\n    from qiskit import pulse\n\n    d0 = pulse.DriveChannel(0)\n\n    with pulse.build() as pulse_prog:\n        pulse.shift_frequency(1e9, d0)\n\nArgs:\n    frequency: Frequency in Hz to shift channel frequency by.\n    channel: Channel to shift frequency of.\n    name: Name of the instruction.",
        "api_signature": "shift_frequency(frequency, channel, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "set_phase",
        "full_api_name": "set_phase",
        "api_description": "Set the ``phase`` of a pulse ``channel``.\n\nExamples:\n\n.. code-block:: python\n    :emphasize-lines: 8\n\n    import math\n\n    from qiskit import pulse\n\n    d0 = pulse.DriveChannel(0)\n\n    with pulse.build() as pulse_prog:\n        pulse.set_phase(math.pi, d0)\n\nArgs:\n    phase: Phase in radians to set channel carrier signal to.\n    channel: Channel to set phase of.\n    name: Name of the instruction.",
        "api_signature": "set_phase(phase, channel, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "shift_phase",
        "full_api_name": "shift_phase",
        "api_description": "Shift the ``phase`` of a pulse ``channel``.\n\nExamples:\n\n.. code-block::\n\n    import math\n\n    from qiskit import pulse\n\n    d0 = pulse.DriveChannel(0)\n\n    with pulse.build() as pulse_prog:\n        pulse.shift_phase(math.pi, d0)\n\nArgs:\n    phase: Phase in radians to shift channel carrier signal by.\n    channel: Channel to shift phase of.\n    name: Name of the instruction.",
        "api_signature": "shift_phase(phase, channel, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "snapshot",
        "full_api_name": "snapshot",
        "api_description": "Simulator snapshot.\n\nExamples:\n\n.. code-block::\n\n    from qiskit import pulse\n\n    with pulse.build() as pulse_prog:\n        pulse.snapshot('first', 'statevector')\n\nArgs:\n    label: Label for snapshot.\n    snapshot_type: Type of snapshot.",
        "api_signature": "snapshot(label, snapshot_type)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "call",
        "full_api_name": "call",
        "api_description": "Call the subroutine within the currently active builder context with arbitrary\nparameters which will be assigned to the target program.\n\n.. note::\n\n    If the ``target`` program is a :class:`.ScheduleBlock`, then a :class:`.Reference`\n    instruction will be created and appended to the current context.\n    The ``target`` program will be immediately assigned to the current scope as a subroutine.\n    If the ``target`` program is :class:`.Schedule`, it will be wrapped by the\n    :class:`.Call` instruction and appended to the current context to avoid\n    a mixed representation of :class:`.ScheduleBlock` and :class:`.Schedule`.\n    If the ``target`` program is a :class:`.QuantumCircuit` it will be scheduled\n    and the new :class:`.Schedule` will be added as a :class:`.Call` instruction.\n\nExamples:\n\n    1. Calling a schedule block (recommended)\n\n    .. code-block::\n\n        from qiskit import circuit, pulse\n        from qiskit.providers.fake_provider import FakeBogotaV2\n\n        backend = FakeBogotaV2()\n\n        with pulse.build() as x_sched:\n            pulse.play(pulse.Gaussian(160, 0.1, 40), pulse.DriveChannel(0))\n\n        with pulse.build() as pulse_prog:\n            pulse.call(x_sched)\n\n        print(pulse_prog)\n\n    .. parsed-literal::\n\n        ScheduleBlock(\n            ScheduleBlock(\n                Play(\n                    Gaussian(duration=160, amp=(0.1+0j), sigma=40),\n                    DriveChannel(0)\n                ),\n                name=\"block0\",\n                transform=AlignLeft()\n            ),\n            name=\"block1\",\n            transform=AlignLeft()\n        )\n\n    The actual program is stored in the reference table attached to the schedule.\n\n    .. code-block::\n\n        print(pulse_prog.references)\n\n    .. parsed-literal::\n\n        ReferenceManager:\n          - ('block0', '634b3b50bd684e26a673af1fbd2d6c81'): ScheduleBlock(Play(Gaussian(...\n\n    In addition, you can call a parameterized target program with parameter assignment.\n\n    .. code-block::\n\n        amp = circuit.Parameter(\"amp\")\n\n        with pulse.build() as subroutine:\n            pulse.play(pulse.Gaussian(160, amp, 40), pulse.DriveChannel(0))\n\n        with pulse.build() as pulse_prog:\n            pulse.call(subroutine, amp=0.1)\n            pulse.call(subroutine, amp=0.3)\n\n        print(pulse_prog)\n\n    .. parsed-literal::\n\n        ScheduleBlock(\n            ScheduleBlock(\n                Play(\n                    Gaussian(duration=160, amp=(0.1+0j), sigma=40),\n                    DriveChannel(0)\n                ),\n                name=\"block2\",\n                transform=AlignLeft()\n            ),\n            ScheduleBlock(\n                Play(\n                    Gaussian(duration=160, amp=(0.3+0j), sigma=40),\n                    DriveChannel(0)\n                ),\n                name=\"block2\",\n                transform=AlignLeft()\n            ),\n            name=\"block3\",\n            transform=AlignLeft()\n        )\n\n    If there is a name collision between parameters, you can distinguish them by specifying\n    each parameter object in a python dictionary. For example,\n\n    .. code-block::\n\n        amp1 = circuit.Parameter('amp')\n        amp2 = circuit.Parameter('amp')\n\n        with pulse.build() as subroutine:\n            pulse.play(pulse.Gaussian(160, amp1, 40), pulse.DriveChannel(0))\n            pulse.play(pulse.Gaussian(160, amp2, 40), pulse.DriveChannel(1))\n\n        with pulse.build() as pulse_prog:\n            pulse.call(subroutine, value_dict={amp1: 0.1, amp2: 0.3})\n\n        print(pulse_prog)\n\n    .. parsed-literal::\n\n        ScheduleBlock(\n            ScheduleBlock(\n                Play(Gaussian(duration=160, amp=(0.1+0j), sigma=40), DriveChannel(0)),\n                Play(Gaussian(duration=160, amp=(0.3+0j), sigma=40), DriveChannel(1)),\n                name=\"block4\",\n                transform=AlignLeft()\n            ),\n            name=\"block5\",\n            transform=AlignLeft()\n        )\n\n    2. Calling a schedule\n\n    .. code-block::\n\n        x_sched = backend.instruction_schedule_map.get(\"x\", (0,))\n\n        with pulse.build(backend) as pulse_prog:\n            pulse.call(x_sched)\n\n        print(pulse_prog)\n\n    .. parsed-literal::\n\n        ScheduleBlock(\n            Call(\n                Schedule(\n                    (\n                        0,\n                        Play(\n                            Drag(\n                                duration=160,\n                                amp=(0.18989731546729305+0j),\n                                sigma=40,\n                                beta=-1.201258305015517,\n                                name='drag_86a8'\n                            ),\n                            DriveChannel(0),\n                            name='drag_86a8'\n                        )\n                    ),\n                    name=\"x\"\n                ),\n                name='x'\n            ),\n            name=\"block6\",\n            transform=AlignLeft()\n        )\n\n    Currently, the backend calibrated gates are provided in the form of :class:`~.Schedule`.\n    The parameter assignment mechanism is available also for schedules.\n    However, the called schedule is not treated as a reference.\n\n    3. Calling a quantum circuit\n\n    .. code-block::\n\n        backend = FakeBogotaV2()\n\n        qc = circuit.QuantumCircuit(1)\n        qc.x(0)\n\n        with pulse.build(backend) as pulse_prog:\n            pulse.call(qc)\n\n        print(pulse_prog)\n\n    .. parsed-literal::\n\n        ScheduleBlock(\n            Call(\n                Schedule(\n                    (\n                        0,\n                        Play(\n                            Drag(\n                                duration=160,\n                                amp=(0.18989731546729305+0j),\n                                sigma=40,\n                                beta=-1.201258305015517,\n                                name='drag_86a8'\n                            ),\n                            DriveChannel(0),\n                            name='drag_86a8'\n                        )\n                    ),\n                    name=\"circuit-87\"\n                ),\n                name='circuit-87'\n            ),\n            name=\"block7\",\n            transform=AlignLeft()\n        )\n\n    .. warning::\n\n        Calling a circuit from a schedule is not encouraged. Currently, the Qiskit execution model\n        is migrating toward the pulse gate model, where schedules are attached to\n        circuits through the :meth:`.QuantumCircuit.add_calibration` method.\n\nArgs:\n    target: Target circuit or pulse schedule to call.\n    name: Optional. A unique name of subroutine if defined. When the name is explicitly\n        provided, one cannot call different schedule blocks with the same name.\n    value_dict: Optional. Parameters assigned to the ``target`` program.\n        If this dictionary is provided, the ``target`` program is copied and\n        then stored in the main built schedule and its parameters are assigned to the given values.\n        This dictionary is keyed on :class:`~.Parameter` objects,\n        allowing parameter name collision to be avoided.\n    kw_params: Alternative way to provide parameters.\n        Since this is keyed on the string parameter name,\n        the parameters having the same name are all updated together.\n        If you want to avoid name collision, use ``value_dict`` with :class:`~.Parameter`\n        objects instead.",
        "api_signature": "call(target, name, value_dict)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "reference",
        "full_api_name": "reference",
        "api_description": "Refer to undefined subroutine by string keys.\n\nA :class:`~qiskit.pulse.instructions.Reference` instruction is implicitly created\nand a schedule can be separately registered to the reference at a later stage.\n\n.. code-block:: python\n\n    from qiskit import pulse\n\n    with pulse.build() as main_prog:\n        pulse.reference(\"x_gate\", \"q0\")\n\n    with pulse.build() as subroutine:\n        pulse.play(pulse.Gaussian(160, 0.1, 40), pulse.DriveChannel(0))\n\n    main_prog.assign_references(subroutine_dict={(\"x_gate\", \"q0\"): subroutine})\n\nArgs:\n    name: Name of subroutine.\n    extra_keys: Helper keys to uniquely specify the subroutine.",
        "api_signature": "reference(name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "barrier",
        "full_api_name": "barrier",
        "api_description": "Barrier directive for a set of channels and qubits.\n\nThis directive prevents the compiler from moving instructions across\nthe barrier. Consider the case where we want to enforce that one pulse\nhappens after another on separate channels, this can be done with:\n\n.. code-block::\n\n    from qiskit import pulse\n    from qiskit.providers.fake_provider import FakeOpenPulse2Q\n\n    backend = FakeOpenPulse2Q()\n\n    d0 = pulse.DriveChannel(0)\n    d1 = pulse.DriveChannel(1)\n\n    with pulse.build(backend) as barrier_pulse_prog:\n        pulse.play(pulse.Constant(10, 1.0), d0)\n        pulse.barrier(d0, d1)\n        pulse.play(pulse.Constant(10, 1.0), d1)\n\nOf course this could have been accomplished with:\n\n.. code-block::\n\n    from qiskit.pulse import transforms\n\n    with pulse.build(backend) as aligned_pulse_prog:\n        with pulse.align_sequential():\n            pulse.play(pulse.Constant(10, 1.0), d0)\n            pulse.play(pulse.Constant(10, 1.0), d1)\n\n    barrier_pulse_prog = transforms.target_qobj_transform(barrier_pulse_prog)\n    aligned_pulse_prog = transforms.target_qobj_transform(aligned_pulse_prog)\n\n    assert barrier_pulse_prog == aligned_pulse_prog\n\nThe barrier allows the pulse compiler to take care of more advanced\nscheduling alignment operations across channels. For example\nin the case where we are calling an outside circuit or schedule and\nwant to align a pulse at the end of one call:\n\n.. code-block::\n\n    import math\n\n    d0 = pulse.DriveChannel(0)\n\n    with pulse.build(backend) as pulse_prog:\n        with pulse.align_right():\n            pulse.x(1)\n            # Barrier qubit 1 and d0.\n            pulse.barrier(1, d0)\n            # Due to barrier this will play before the gate on qubit 1.\n            pulse.play(pulse.Constant(10, 1.0), d0)\n            # This will end at the same time as the pulse above due to\n            # the barrier.\n            pulse.x(1)\n\n.. note:: Requires the active builder context to have a backend set if\n    qubits are barriered on.\n\nArgs:\n    channels_or_qubits: Channels or qubits to barrier.\n    name: Name for the barrier",
        "api_signature": "barrier()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "macro",
        "full_api_name": "macro",
        "api_description": "Wrap a Python function and activate the parent builder context at calling time.\n\nThis enables embedding Python functions as builder macros. This generates a new\n:class:`pulse.Schedule` that is embedded in the parent builder context with\nevery call of the decorated macro function. The decorated macro function will\nbehave as if the function code was embedded inline in the parent builder context\nafter parameter substitution.\n\n\nExamples:\n\n.. plot::\n   :include-source:\n\n    from qiskit import pulse\n\n    @pulse.macro\n    def measure(qubit: int):\n        pulse.play(pulse.GaussianSquare(16384, 256, 15872), pulse.measure_channel(qubit))\n        mem_slot = pulse.MemorySlot(qubit)\n        pulse.acquire(16384, pulse.acquire_channel(qubit), mem_slot)\n\n        return mem_slot\n\n    with pulse.build(backend=backend) as sched:\n        mem_slot = measure(0)\n        print(f\"Qubit measured into {mem_slot}\")\n\n    sched.draw()\n\n\nArgs:\n    func: The Python function to enable as a builder macro. There are no\n        requirements on the signature of the function, any calls to pulse\n        builder methods will be added to builder context the wrapped function\n        is called from.\n\nReturns:\n    Callable: The wrapped ``func``.",
        "api_signature": "macro(func)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "wrapper",
        "full_api_name": "wrapper",
        "api_description": "",
        "api_signature": "wrapper()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "measure",
        "full_api_name": "measure",
        "api_description": "Measure a qubit within the currently active builder context.\n\nAt the pulse level a measurement is composed of both a stimulus pulse and\nan acquisition instruction which tells the systems measurement unit to\nacquire data and process it. We provide this measurement macro to automate\nthe process for you, but if desired full control is still available with\n:func:`acquire` and :func:`play`.\n\nTo use the measurement it is as simple as specifying the qubit you wish to\nmeasure:\n\n.. code-block::\n\n    from qiskit import pulse\n    from qiskit.providers.fake_provider import FakeOpenPulse2Q\n\n    backend = FakeOpenPulse2Q()\n\n    qubit = 0\n\n    with pulse.build(backend) as pulse_prog:\n        # Do something to the qubit.\n        qubit_drive_chan = pulse.drive_channel(0)\n        pulse.play(pulse.Constant(100, 1.0), qubit_drive_chan)\n        # Measure the qubit.\n        reg = pulse.measure(qubit)\n\nFor now it is not possible to do much with the handle to ``reg`` but in the\nfuture we will support using this handle to a result register to build\nup ones program. It is also possible to supply this register:\n\n.. code-block::\n\n    with pulse.build(backend) as pulse_prog:\n        pulse.play(pulse.Constant(100, 1.0), qubit_drive_chan)\n        # Measure the qubit.\n        mem0 = pulse.MemorySlot(0)\n        reg = pulse.measure(qubit, mem0)\n\n    assert reg == mem0\n\n.. note:: Requires the active builder context to have a backend set.\n\nArgs:\n    qubits: Physical qubit to measure.\n    registers: Register to store result in. If not selected the current\n        behavior is to return the :class:`MemorySlot` with the same\n        index as ``qubit``. This register will be returned.\nReturns:\n    The ``register`` the qubit measurement result will be stored in.",
        "api_signature": "measure(qubits, registers)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "measure_all",
        "full_api_name": "measure_all",
        "api_description": "Measure all qubits within the currently active builder context.\n\nA simple macro function to measure all of the qubits in the device at the\nsame time. This is useful for handling device ``meas_map`` and single\nmeasurement constraints.\n\nExamples:\n\n.. code-block::\n\n    from qiskit import pulse\n    from qiskit.providers.fake_provider import FakeOpenPulse2Q\n\n    backend = FakeOpenPulse2Q()\n\n    with pulse.build(backend) as pulse_prog:\n        # Measure all qubits and return associated registers.\n        regs = pulse.measure_all()\n\n.. note::\n    Requires the active builder context to have a backend set.\n\nReturns:\n    The ``register``\\s the qubit measurement results will be stored in.",
        "api_signature": "measure_all()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "delay_qubits",
        "full_api_name": "delay_qubits",
        "api_description": "Insert delays on all of the :class:`channels.Channel`\\s that correspond\nto the input ``qubits`` at the same time.\n\nExamples:\n\n.. code-block::\n\n    from qiskit import pulse\n    from qiskit.providers.fake_provider import FakeOpenPulse3Q\n\n    backend = FakeOpenPulse3Q()\n\n    with pulse.build(backend) as pulse_prog:\n        # Delay for 100 cycles on qubits 0, 1 and 2.\n        regs = pulse.delay_qubits(100, 0, 1, 2)\n\n.. note:: Requires the active builder context to have a backend set.\n\nArgs:\n    duration: Duration to delay for.\n    qubits: Physical qubits to delay on. Delays will be inserted based on\n        the channels returned by :func:`pulse.qubit_channels`.",
        "api_signature": "delay_qubits(duration)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "call_gate",
        "full_api_name": "call_gate",
        "api_description": "Call a gate and lazily schedule it to its corresponding\npulse instruction.\n\n.. note::\n    Calling gates directly within the pulse builder namespace will be\n    deprecated in the future in favor of tight integration with a circuit\n    builder interface which is under development.\n\nExamples:\n\n.. code-block::\n\n    from qiskit import pulse\n    from qiskit.pulse import builder\n    from qiskit.circuit.library import standard_gates as gates\n    from qiskit.providers.fake_provider import FakeOpenPulse2Q\n\n    backend = FakeOpenPulse2Q()\n\n    with pulse.build(backend) as pulse_prog:\n        builder.call_gate(gates.CXGate(), (0, 1))\n\nWe can see the role of the transpiler in scheduling gates by optimizing\naway two consecutive CNOT gates:\n\n.. code-block::\n\n    with pulse.build(backend) as pulse_prog:\n        with pulse.transpiler_settings(optimization_level=3):\n            builder.call_gate(gates.CXGate(), (0, 1))\n            builder.call_gate(gates.CXGate(), (0, 1))\n\n    assert pulse_prog == pulse.Schedule()\n\n.. note:: If multiple gates are called in a row they may be optimized by\n    the transpiler, depending on the\n    :func:`pulse.active_transpiler_settings``.\n\n.. note:: Requires the active builder context to have a backend set.\n\nArgs:\n    gate: Circuit gate instance to call.\n    qubits: Qubits to call gate on.\n    lazy: If ``false`` the gate will be compiled immediately, otherwise\n        it will be added onto a lazily evaluated quantum circuit to be\n        compiled when the builder is forced to by a circuit assumption\n        being broken, such as the inclusion of a pulse instruction or\n        new alignment context.",
        "api_signature": "call_gate(gate, qubits, lazy)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "cx",
        "full_api_name": "cx",
        "api_description": "Call a :class:`~qiskit.circuit.library.standard_gates.CXGate` on the\ninput physical qubits.\n\n.. note::\n    Calling gates directly within the pulse builder namespace will be\n    deprecated in the future in favor of tight integration with a circuit\n    builder interface which is under development.\n\nExamples:\n\n.. code-block::\n\n    from qiskit import pulse\n    from qiskit.providers.fake_provider import FakeOpenPulse2Q\n\n    backend = FakeOpenPulse2Q()\n\n    with pulse.build(backend) as pulse_prog:\n        pulse.cx(0, 1)",
        "api_signature": "cx(control, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "u1",
        "full_api_name": "u1",
        "api_description": "Call a :class:`~qiskit.circuit.library.standard_gates.U1Gate` on the\ninput physical qubit.\n\n.. note::\n    Calling gates directly within the pulse builder namespace will be\n    deprecated in the future in favor of tight integration with a circuit\n    builder interface which is under development.\n\nExamples:\n\n.. code-block::\n\n    import math\n\n    from qiskit import pulse\n    from qiskit.providers.fake_provider import FakeOpenPulse2Q\n\n    backend = FakeOpenPulse2Q()\n\n    with pulse.build(backend) as pulse_prog:\n        pulse.u1(math.pi, 1)",
        "api_signature": "u1(theta, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "u2",
        "full_api_name": "u2",
        "api_description": "Call a :class:`~qiskit.circuit.library.standard_gates.U2Gate` on the\ninput physical qubit.\n\n.. note::\n    Calling gates directly within the pulse builder namespace will be\n    deprecated in the future in favor of tight integration with a circuit\n    builder interface which is under development.\n\nExamples:\n\n.. code-block::\n\n    import math\n\n    from qiskit import pulse\n    from qiskit.providers.fake_provider import FakeOpenPulse2Q\n\n    backend = FakeOpenPulse2Q()\n\n    with pulse.build(backend) as pulse_prog:\n        pulse.u2(0, math.pi, 1)",
        "api_signature": "u2(phi, lam, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "u3",
        "full_api_name": "u3",
        "api_description": "Call a :class:`~qiskit.circuit.library.standard_gates.U3Gate` on the\ninput physical qubit.\n\n.. note::\n    Calling gates directly within the pulse builder namespace will be\n    deprecated in the future in favor of tight integration with a circuit\n    builder interface which is under development.\n\nExamples:\n\n.. code-block::\n\n    import math\n\n    from qiskit import pulse\n    from qiskit.providers.fake_provider import FakeOpenPulse2Q\n\n    backend = FakeOpenPulse2Q()\n\n    with pulse.build(backend) as pulse_prog:\n        pulse.u3(math.pi, 0, math.pi, 1)",
        "api_signature": "u3(theta, phi, lam, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "x",
        "full_api_name": "x",
        "api_description": "Call a :class:`~qiskit.circuit.library.standard_gates.XGate` on the\ninput physical qubit.\n\n.. note::\n    Calling gates directly within the pulse builder namespace will be\n    deprecated in the future in favor of tight integration with a circuit\n    builder interface which is under development.\n\nExamples:\n\n.. code-block::\n\n    from qiskit import pulse\n    from qiskit.providers.fake_provider import FakeOpenPulse2Q\n\n    backend = FakeOpenPulse2Q()\n\n    with pulse.build(backend) as pulse_prog:\n        pulse.x(0)",
        "api_signature": "x(qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "unassigned",
        "full_api_name": "ReferenceManager.unassigned",
        "api_description": "Get the keys of unassigned references.\n\nReturns:\n    Tuple of reference keys.",
        "api_signature": "unassigned(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/reference_manager.py"
    },
    {
        "api_name": "__setitem__",
        "full_api_name": "ReferenceManager.__setitem__",
        "api_description": "",
        "api_signature": "__setitem__(self, key, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/reference_manager.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "ReferenceManager.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/reference_manager.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "ReferenceManager.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/reference_manager.py"
    },
    {
        "api_name": "measure",
        "full_api_name": "measure",
        "api_description": "Return a schedule which measures the requested qubits according to the given\ninstruction mapping and measure map, or by using the defaults provided by the backend.\n\n.. note::\n    This function internally dispatches schedule generation logic depending on input backend model.\n    For the :class:`.BackendV1`, it considers conventional :class:`.InstructionScheduleMap`\n    and utilizes the backend calibration defined for a group of qubits in the `meas_map`.\n    For the :class:`.BackendV2`, it assembles calibrations of single qubit measurement\n    defined in the backend target to build a composite measurement schedule for `qubits`.\n\nBy default, the measurement results for each qubit are trivially mapped to the qubit\nindex. This behavior is overridden by qubit_mem_slots. For instance, to measure\nqubit 0 into MemorySlot(1), qubit_mem_slots can be provided as {0: 1}.\n\nArgs:\n    qubits: List of qubits to be measured.\n    backend (Union[Backend, BaseBackend]): A backend instance, which contains\n        hardware-specific data required for scheduling.\n    inst_map: Mapping of circuit operations to pulse schedules. If None, defaults to the\n              ``instruction_schedule_map`` of ``backend``.\n    meas_map: List of sets of qubits that must be measured together. If None, defaults to\n              the ``meas_map`` of ``backend``.\n    qubit_mem_slots: Mapping of measured qubit index to classical bit index.\n    measure_name: Name of the measurement schedule.\n\nReturns:\n    A measurement schedule corresponding to the inputs provided.",
        "api_signature": "measure(qubits, backend, inst_map, meas_map, qubit_mem_slots, measure_name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/macros.py"
    },
    {
        "api_name": "_measure_v1",
        "full_api_name": "_measure_v1",
        "api_description": "Return a schedule which measures the requested qubits according to the given\ninstruction mapping and measure map, or by using the defaults provided by the backendV1.\n\nArgs:\n    qubits: List of qubits to be measured.\n    backend (Union[Backend, BaseBackend]): A backend instance, which contains\n        hardware-specific data required for scheduling.\n    inst_map: Mapping of circuit operations to pulse schedules. If None, defaults to the\n              ``instruction_schedule_map`` of ``backend``.\n    meas_map: List of sets of qubits that must be measured together. If None, defaults to\n              the ``meas_map`` of ``backend``.\n    qubit_mem_slots: Mapping of measured qubit index to classical bit index.\n    measure_name: Name of the measurement schedule.\nReturns:\n    A measurement schedule corresponding to the inputs provided.\nRaises:\n    PulseError: If both ``inst_map`` or ``meas_map``, and ``backend`` is None.",
        "api_signature": "_measure_v1(qubits, inst_map, meas_map, qubit_mem_slots, measure_name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/macros.py"
    },
    {
        "api_name": "_measure_v2",
        "full_api_name": "_measure_v2",
        "api_description": "Return a schedule which measures the requested qubits according to the given\ntarget and measure map, or by using the defaults provided by the backendV2.\n\nArgs:\n    qubits: List of qubits to be measured.\n    target: The :class:`~.Target` representing the target backend.\n    meas_map: List of sets of qubits that must be measured together.\n    qubit_mem_slots: Mapping of measured qubit index to classical bit index.\n    measure_name: Name of the measurement schedule.\n\nReturns:\n    A measurement schedule corresponding to the inputs provided.",
        "api_signature": "_measure_v2(qubits, target, meas_map, qubit_mem_slots, measure_name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/macros.py"
    },
    {
        "api_name": "measure_all",
        "full_api_name": "measure_all",
        "api_description": "Return a Schedule which measures all qubits of the given backend.\n\nArgs:\n    backend (Union[Backend, BaseBackend]): A backend instance, which contains\n        hardware-specific data required for scheduling.\n\nReturns:\n    A schedule corresponding to the inputs provided.",
        "api_signature": "measure_all(backend)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/macros.py"
    },
    {
        "api_name": "_schedule_remapping_memory_slot",
        "full_api_name": "_schedule_remapping_memory_slot",
        "api_description": "A helper function to overwrite MemorySlot index of :class:`.Acquire` instruction.\n\nArgs:\n    schedule: A measurement schedule.\n    qubit_mem_slots: Mapping of measured qubit index to classical bit index.\n\nReturns:\n    A measurement schedule with new memory slot index.",
        "api_signature": "_schedule_remapping_memory_slot(schedule, qubit_mem_slots)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/macros.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PulseExpression.__init__",
        "api_description": "Create new evaluator.\n\nArgs:\n    source: Expression of equation to evaluate.\n    partial_binding: Allow partial bind of parameters.\n\nRaises:\n    PulseError: When invalid string is specified.",
        "api_signature": "__init__(self, source, partial_binding)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parser.py"
    },
    {
        "api_name": "params",
        "full_api_name": "PulseExpression.params",
        "api_description": "Get parameters.\n\nReturns:\n    A list of parameters in sorted order.",
        "api_signature": "params(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parser.py"
    },
    {
        "api_name": "__call__",
        "full_api_name": "PulseExpression.__call__",
        "api_description": "Evaluate the expression with the given values of the expression's parameters.\n\nArgs:\n    *args: Variable length parameter list.\n    **kwargs: Arbitrary parameters.\n\nReturns:\n    Evaluated value.\n\nRaises:\n    PulseError: When parameters are not bound.",
        "api_signature": "__call__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parser.py"
    },
    {
        "api_name": "_match_ops",
        "full_api_name": "PulseExpression._match_ops",
        "api_description": "Helper method to apply operators.\n\nArgs:\n    opr: Operator of node.\n    opr_dict: Mapper from ast to operator.\n    *args: Arguments supplied to operator.\n\nReturns:\n    Evaluated value.\n\nRaises:\n    PulseError: When unsupported operation is specified.",
        "api_signature": "_match_ops(opr, opr_dict)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parser.py"
    },
    {
        "api_name": "visit_Expression",
        "full_api_name": "PulseExpression.visit_Expression",
        "api_description": "Evaluate children nodes of expression.\n\nArgs:\n    node: Expression to evaluate.\n\nReturns:\n    Evaluated value.",
        "api_signature": "visit_Expression(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parser.py"
    },
    {
        "api_name": "visit_Constant",
        "full_api_name": "PulseExpression.visit_Constant",
        "api_description": "Return constant value as it is.\n\nArgs:\n    node: Constant.\n\nReturns:\n    Input node.",
        "api_signature": "visit_Constant(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parser.py"
    },
    {
        "api_name": "visit_Name",
        "full_api_name": "PulseExpression.visit_Name",
        "api_description": "Evaluate name and return ast.Constant if it is bound.\n\nArgs:\n    node: Name to evaluate.\n\nReturns:\n    Evaluated value.\n\nRaises:\n    PulseError: When parameter value is not a number.",
        "api_signature": "visit_Name(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parser.py"
    },
    {
        "api_name": "visit_UnaryOp",
        "full_api_name": "PulseExpression.visit_UnaryOp",
        "api_description": "Evaluate unary operation and return ast.Constant if operand is bound.\n\nArgs:\n    node: Unary operation to evaluate.\n\nReturns:\n    Evaluated value.",
        "api_signature": "visit_UnaryOp(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parser.py"
    },
    {
        "api_name": "visit_BinOp",
        "full_api_name": "PulseExpression.visit_BinOp",
        "api_description": "Evaluate binary operation and return ast.Constant if operands are bound.\n\nArgs:\n    node: Binary operation to evaluate.\n\nReturns:\n    Evaluated value.",
        "api_signature": "visit_BinOp(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parser.py"
    },
    {
        "api_name": "visit_Call",
        "full_api_name": "PulseExpression.visit_Call",
        "api_description": "Evaluate function and return ast.Constant if all arguments are bound.\n\nArgs:\n    node: Function to evaluate.\n\nReturns:\n    Evaluated value.\n\nRaises:\n    PulseError: When unsupported or unsafe function is specified.",
        "api_signature": "visit_Call(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parser.py"
    },
    {
        "api_name": "generic_visit",
        "full_api_name": "PulseExpression.generic_visit",
        "api_description": "",
        "api_signature": "generic_visit(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parser.py"
    },
    {
        "api_name": "parse_string_expr",
        "full_api_name": "parse_string_expr",
        "api_description": "Safe parsing of string expression.\n\nArgs:\n    source: String expression to parse.\n    partial_binding: Allow partial bind of parameters.\n\nReturns:\n    PulseExpression: Returns a expression object.\n\nExample:\n\n    expr = 'P1 + P2 + P3'\n    parsed_expr = parse_string_expr(expr, partial_binding=True)\n\n    # create new PulseExpression\n    bound_two = parsed_expr(P1=1, P2=2)\n    # evaluate expression\n    value1 = bound_two(P3=3)\n    value2 = bound_two(P3=4)\n    value3 = bound_two(P3=5)",
        "api_signature": "parse_string_expr(source, partial_binding)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parser.py"
    },
    {
        "api_name": "_assert_nested_dict_equal",
        "full_api_name": "_assert_nested_dict_equal",
        "api_description": "",
        "api_signature": "_assert_nested_dict_equal(a, b)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/configuration.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Kernel.__init__",
        "api_description": "Create new kernel.\n\nArgs:\n    name: Name of kernel to be used\n    params: Any settings for kerneling.",
        "api_signature": "__init__(self, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/configuration.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "Kernel.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/configuration.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "Kernel.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/configuration.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Discriminator.__init__",
        "api_description": "Create new discriminator.\n\nArgs:\n    name: Name of discriminator to be used\n    params: Any settings for discrimination.",
        "api_signature": "__init__(self, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/configuration.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "Discriminator.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/configuration.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "Discriminator.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/configuration.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "LoRange.__init__",
        "api_description": "",
        "api_signature": "__init__(self, lower_bound, upper_bound)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/configuration.py"
    },
    {
        "api_name": "includes",
        "full_api_name": "LoRange.includes",
        "api_description": "Whether `lo_freq` is within the `LoRange`.\n\nArgs:\n    lo_freq: LO frequency to be validated\n\nReturns:\n    bool: True if lo_freq is included in this range, otherwise False",
        "api_signature": "includes(self, lo_freq)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/configuration.py"
    },
    {
        "api_name": "lower_bound",
        "full_api_name": "LoRange.lower_bound",
        "api_description": "Lower bound of the LO range",
        "api_signature": "lower_bound(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/configuration.py"
    },
    {
        "api_name": "upper_bound",
        "full_api_name": "LoRange.upper_bound",
        "api_description": "Upper bound of the LO range",
        "api_signature": "upper_bound(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/configuration.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "LoRange.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/configuration.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "LoRange.__eq__",
        "api_description": "Two LO ranges are the same if they are of the same type, and\nhave the same frequency range\n\nArgs:\n    other (LoRange): other LoRange\n\nReturns:\n    bool: are self and other equal.",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/configuration.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "LoConfig.__init__",
        "api_description": "Lo channel configuration data structure.\n\nArgs:\n    channel_los: Dictionary of mappings from configurable channel to lo\n    lo_ranges: Dictionary of mappings to be enforced from configurable channel to `LoRange`\n\nRaises:\n    PulseError: If channel is not configurable or set lo is out of range.",
        "api_signature": "__init__(self, channel_los, lo_ranges)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/configuration.py"
    },
    {
        "api_name": "add_lo",
        "full_api_name": "LoConfig.add_lo",
        "api_description": "Add a lo mapping for a channel.",
        "api_signature": "add_lo(self, channel, freq)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/configuration.py"
    },
    {
        "api_name": "add_lo_range",
        "full_api_name": "LoConfig.add_lo_range",
        "api_description": "Add lo range to configuration.\n\nArgs:\n    channel: Channel to add lo range for\n    lo_range: Lo range to add",
        "api_signature": "add_lo_range(self, channel, lo_range)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/configuration.py"
    },
    {
        "api_name": "check_lo",
        "full_api_name": "LoConfig.check_lo",
        "api_description": "Check that lo is valid for channel.\n\nArgs:\n    channel: Channel to validate lo for\n    freq: lo frequency\nRaises:\n    PulseError: If freq is outside of channels range",
        "api_signature": "check_lo(self, channel, freq)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/configuration.py"
    },
    {
        "api_name": "channel_lo",
        "full_api_name": "LoConfig.channel_lo",
        "api_description": "Return channel lo.\n\nArgs:\n    channel: Channel to get lo for\nRaises:\n    PulseError: If channel is not configured\nReturns:\n    Lo of supplied channel if present",
        "api_signature": "channel_lo(self, channel)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/configuration.py"
    },
    {
        "api_name": "qubit_los",
        "full_api_name": "LoConfig.qubit_los",
        "api_description": "Returns dictionary mapping qubit channels (DriveChannel) to los.",
        "api_signature": "qubit_los(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/configuration.py"
    },
    {
        "api_name": "meas_los",
        "full_api_name": "LoConfig.meas_los",
        "api_description": "Returns dictionary mapping measure channels (MeasureChannel) to los.",
        "api_signature": "meas_los(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/configuration.py"
    },
    {
        "api_name": "visit",
        "full_api_name": "NodeVisitor.visit",
        "api_description": "Visit a node.",
        "api_signature": "visit(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parameter_manager.py"
    },
    {
        "api_name": "_get_visitor",
        "full_api_name": "NodeVisitor._get_visitor",
        "api_description": "A helper function to recursively investigate superclass visitor method.",
        "api_signature": "_get_visitor(self, node_class)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parameter_manager.py"
    },
    {
        "api_name": "visit_ScheduleBlock",
        "full_api_name": "NodeVisitor.visit_ScheduleBlock",
        "api_description": "Visit ``ScheduleBlock``. Recursively visit context blocks and overwrite.\n\n.. note:: ``ScheduleBlock`` can have parameters in blocks and its alignment.",
        "api_signature": "visit_ScheduleBlock(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parameter_manager.py"
    },
    {
        "api_name": "visit_Schedule",
        "full_api_name": "NodeVisitor.visit_Schedule",
        "api_description": "Visit ``Schedule``. Recursively visit schedule children and overwrite.",
        "api_signature": "visit_Schedule(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parameter_manager.py"
    },
    {
        "api_name": "generic_visit",
        "full_api_name": "NodeVisitor.generic_visit",
        "api_description": "Called if no explicit visitor function exists for a node.",
        "api_signature": "generic_visit(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parameter_manager.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ParameterSetter.__init__",
        "api_description": "",
        "api_signature": "__init__(self, param_map)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parameter_manager.py"
    },
    {
        "api_name": "visit_ScheduleBlock",
        "full_api_name": "ParameterSetter.visit_ScheduleBlock",
        "api_description": "Visit ``ScheduleBlock``. Recursively visit context blocks and overwrite.\n\n.. note:: ``ScheduleBlock`` can have parameters in blocks and its alignment.",
        "api_signature": "visit_ScheduleBlock(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parameter_manager.py"
    },
    {
        "api_name": "visit_Schedule",
        "full_api_name": "ParameterSetter.visit_Schedule",
        "api_description": "Visit ``Schedule``. Recursively visit schedule children and overwrite.",
        "api_signature": "visit_Schedule(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parameter_manager.py"
    },
    {
        "api_name": "visit_AlignmentKind",
        "full_api_name": "ParameterSetter.visit_AlignmentKind",
        "api_description": "Assign parameters to block's ``AlignmentKind`` specification.",
        "api_signature": "visit_AlignmentKind(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parameter_manager.py"
    },
    {
        "api_name": "visit_Call",
        "full_api_name": "ParameterSetter.visit_Call",
        "api_description": "Assign parameters to ``Call`` instruction.\n\n.. note:: ``Call`` instruction has a special parameter handling logic.\n    This instruction separately keeps program, i.e. parametrized schedule,\n    and bound parameters until execution. The parameter assignment operation doesn't\n    immediately override its operand data.",
        "api_signature": "visit_Call(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parameter_manager.py"
    },
    {
        "api_name": "visit_Instruction",
        "full_api_name": "ParameterSetter.visit_Instruction",
        "api_description": "Assign parameters to general pulse instruction.\n\n.. note:: All parametrized object should be stored in the operands.\n    Otherwise parameter cannot be detected.",
        "api_signature": "visit_Instruction(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parameter_manager.py"
    },
    {
        "api_name": "visit_Channel",
        "full_api_name": "ParameterSetter.visit_Channel",
        "api_description": "Assign parameters to ``Channel`` object.",
        "api_signature": "visit_Channel(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parameter_manager.py"
    },
    {
        "api_name": "visit_ParametricPulse",
        "full_api_name": "ParameterSetter.visit_ParametricPulse",
        "api_description": "Assign parameters to ``ParametricPulse`` object.",
        "api_signature": "visit_ParametricPulse(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parameter_manager.py"
    },
    {
        "api_name": "visit_SymbolicPulse",
        "full_api_name": "ParameterSetter.visit_SymbolicPulse",
        "api_description": "Assign parameters to ``SymbolicPulse`` object.",
        "api_signature": "visit_SymbolicPulse(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parameter_manager.py"
    },
    {
        "api_name": "visit_Waveform",
        "full_api_name": "ParameterSetter.visit_Waveform",
        "api_description": "Assign parameters to ``Waveform`` object.\n\n.. node:: No parameter can be assigned to ``Waveform`` object.",
        "api_signature": "visit_Waveform(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parameter_manager.py"
    },
    {
        "api_name": "generic_visit",
        "full_api_name": "ParameterSetter.generic_visit",
        "api_description": "Assign parameters to object that doesn't belong to Qiskit Pulse module.",
        "api_signature": "generic_visit(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parameter_manager.py"
    },
    {
        "api_name": "_assign_parameter_expression",
        "full_api_name": "ParameterSetter._assign_parameter_expression",
        "api_description": "A helper function to assign parameter value to parameter expression.",
        "api_signature": "_assign_parameter_expression(self, param_expr)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parameter_manager.py"
    },
    {
        "api_name": "_update_parameter_manager",
        "full_api_name": "ParameterSetter._update_parameter_manager",
        "api_description": "A helper function to update parameter manager of pulse program.",
        "api_signature": "_update_parameter_manager(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parameter_manager.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ParameterGetter.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parameter_manager.py"
    },
    {
        "api_name": "visit_ScheduleBlock",
        "full_api_name": "ParameterGetter.visit_ScheduleBlock",
        "api_description": "Visit ``ScheduleBlock``. Recursively visit context blocks and search parameters.\n\n.. note:: ``ScheduleBlock`` can have parameters in blocks and its alignment.",
        "api_signature": "visit_ScheduleBlock(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parameter_manager.py"
    },
    {
        "api_name": "visit_Schedule",
        "full_api_name": "ParameterGetter.visit_Schedule",
        "api_description": "Visit ``Schedule``. Recursively visit schedule children and search parameters.",
        "api_signature": "visit_Schedule(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parameter_manager.py"
    },
    {
        "api_name": "visit_AlignmentKind",
        "full_api_name": "ParameterGetter.visit_AlignmentKind",
        "api_description": "Get parameters from block's ``AlignmentKind`` specification.",
        "api_signature": "visit_AlignmentKind(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parameter_manager.py"
    },
    {
        "api_name": "visit_Call",
        "full_api_name": "ParameterGetter.visit_Call",
        "api_description": "Get parameters from ``Call`` instruction.\n\n.. note:: ``Call`` instruction has a special parameter handling logic.\n    This instruction separately keeps parameters and program.",
        "api_signature": "visit_Call(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parameter_manager.py"
    },
    {
        "api_name": "visit_Instruction",
        "full_api_name": "ParameterGetter.visit_Instruction",
        "api_description": "Get parameters from general pulse instruction.\n\n.. note:: All parametrized object should be stored in the operands.\n    Otherwise, parameter cannot be detected.",
        "api_signature": "visit_Instruction(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parameter_manager.py"
    },
    {
        "api_name": "visit_Channel",
        "full_api_name": "ParameterGetter.visit_Channel",
        "api_description": "Get parameters from ``Channel`` object.",
        "api_signature": "visit_Channel(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parameter_manager.py"
    },
    {
        "api_name": "visit_ParametricPulse",
        "full_api_name": "ParameterGetter.visit_ParametricPulse",
        "api_description": "Get parameters from ``ParametricPulse`` object.",
        "api_signature": "visit_ParametricPulse(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parameter_manager.py"
    },
    {
        "api_name": "visit_SymbolicPulse",
        "full_api_name": "ParameterGetter.visit_SymbolicPulse",
        "api_description": "Get parameters from ``SymbolicPulse`` object.",
        "api_signature": "visit_SymbolicPulse(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parameter_manager.py"
    },
    {
        "api_name": "visit_Waveform",
        "full_api_name": "ParameterGetter.visit_Waveform",
        "api_description": "Get parameters from ``Waveform`` object.\n\n.. node:: No parameter can be assigned to ``Waveform`` object.",
        "api_signature": "visit_Waveform(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parameter_manager.py"
    },
    {
        "api_name": "generic_visit",
        "full_api_name": "ParameterGetter.generic_visit",
        "api_description": "Get parameters from object that doesn't belong to Qiskit Pulse module.",
        "api_signature": "generic_visit(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parameter_manager.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ParameterManager.__init__",
        "api_description": "Create new parameter table for pulse programs.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parameter_manager.py"
    },
    {
        "api_name": "parameters",
        "full_api_name": "ParameterManager.parameters",
        "api_description": "Parameters which determine the schedule behavior.",
        "api_signature": "parameters(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parameter_manager.py"
    },
    {
        "api_name": "clear",
        "full_api_name": "ParameterManager.clear",
        "api_description": "Remove the parameters linked to this manager.",
        "api_signature": "clear(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parameter_manager.py"
    },
    {
        "api_name": "is_parameterized",
        "full_api_name": "ParameterManager.is_parameterized",
        "api_description": "Return True iff the instruction is parameterized.",
        "api_signature": "is_parameterized(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parameter_manager.py"
    },
    {
        "api_name": "get_parameters",
        "full_api_name": "ParameterManager.get_parameters",
        "api_description": "Get parameter object bound to this schedule by string name.\n\nBecause different ``Parameter`` objects can have the same name,\nthis method returns a list of ``Parameter`` s for the provided name.\n\nArgs:\n    parameter_name: Name of parameter.\n\nReturns:\n    Parameter objects that have corresponding name.",
        "api_signature": "get_parameters(self, parameter_name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parameter_manager.py"
    },
    {
        "api_name": "assign_parameters",
        "full_api_name": "ParameterManager.assign_parameters",
        "api_description": "Modify and return program data with parameters assigned according to the input.\n\nArgs:\n    pulse_program: Arbitrary pulse program associated with this manager instance.\n    value_dict: A mapping from Parameters to either numeric values or another\n        Parameter expression.\n\nReturns:\n    Updated program data.",
        "api_signature": "assign_parameters(self, pulse_program, value_dict)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parameter_manager.py"
    },
    {
        "api_name": "update_parameter_table",
        "full_api_name": "ParameterManager.update_parameter_table",
        "api_description": "A helper function to update parameter table with given data node.\n\nArgs:\n    new_node: A new data node to be added.",
        "api_signature": "update_parameter_table(self, new_node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parameter_manager.py"
    },
    {
        "api_name": "__new__",
        "full_api_name": "Channel.__new__",
        "api_description": "",
        "api_signature": "__new__(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/channels.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Channel.__init__",
        "api_description": "Channel class.\n\nArgs:\n    index: Index of channel.",
        "api_signature": "__init__(self, index)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/channels.py"
    },
    {
        "api_name": "index",
        "full_api_name": "Channel.index",
        "api_description": "Return the index of this channel. The index is a label for a control signal line\ntypically mapped trivially to a qubit index. For instance, ``DriveChannel(0)`` labels\nthe signal line driving the qubit labeled with index 0.",
        "api_signature": "index(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/channels.py"
    },
    {
        "api_name": "_validate_index",
        "full_api_name": "Channel._validate_index",
        "api_description": "Raise a PulseError if the channel index is invalid, namely, if it's not a positive\ninteger.\n\nRaises:\n    PulseError: If ``index`` is not a nonnegative integer.",
        "api_signature": "_validate_index(self, index)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/channels.py"
    },
    {
        "api_name": "parameters",
        "full_api_name": "Channel.parameters",
        "api_description": "Parameters which determine the channel index.",
        "api_signature": "parameters(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/channels.py"
    },
    {
        "api_name": "is_parameterized",
        "full_api_name": "Channel.is_parameterized",
        "api_description": "Return True iff the channel is parameterized.",
        "api_signature": "is_parameterized(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/channels.py"
    },
    {
        "api_name": "name",
        "full_api_name": "Channel.name",
        "api_description": "Return the shorthand alias for this channel, which is based on its type and index.",
        "api_signature": "name(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/channels.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "Channel.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/channels.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "Channel.__eq__",
        "api_description": "Return True iff self and other are equal, specifically, iff they have the same type\nand the same index.\n\nArgs:\n    other: The channel to compare to this channel.\n\nReturns:\n    True iff equal.",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/channels.py"
    },
    {
        "api_name": "__hash__",
        "full_api_name": "Channel.__hash__",
        "api_description": "",
        "api_signature": "__hash__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/channels.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SnapshotChannel.__init__",
        "api_description": "Create new snapshot channel.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/channels.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Schedule.__init__",
        "api_description": "Create an empty schedule.\n\nArgs:\n    *schedules: Child Schedules of this parent Schedule. May either be passed as\n                the list of schedules, or a list of ``(start_time, schedule)`` pairs.\n    name: Name of this schedule. Defaults to an autogenerated string if not provided.\n    metadata: Arbitrary key value metadata to associate with the schedule. This gets\n        stored as free-form data in a dict in the\n        :attr:`~qiskit.pulse.Schedule.metadata` attribute. It will not be directly\n        used in the schedule.\nRaises:\n    TypeError: if metadata is not a dict.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "initialize_from",
        "full_api_name": "Schedule.initialize_from",
        "api_description": "Create new schedule object with metadata of another schedule object.\n\nArgs:\n    other_program: Qiskit program that provides metadata to new object.\n    name: Name of new schedule. Name of ``schedule`` is used by default.\n\nReturns:\n    New schedule object with name and metadata.\n\nRaises:\n    PulseError: When `other_program` does not provide necessary information.",
        "api_signature": "initialize_from(cls, other_program, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "name",
        "full_api_name": "Schedule.name",
        "api_description": "Name of this Schedule",
        "api_signature": "name(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "metadata",
        "full_api_name": "Schedule.metadata",
        "api_description": "The user provided metadata associated with the schedule.\n\nUser provided ``dict`` of metadata for the schedule.\nThe metadata contents do not affect the semantics of the program\nbut are used to influence the execution of the schedule. It is expected\nto be passed between all transforms of the schedule and that providers\nwill associate any schedule metadata with the results it returns from the\nexecution of that schedule.",
        "api_signature": "metadata(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "metadata",
        "full_api_name": "Schedule.metadata",
        "api_description": "Update the schedule metadata",
        "api_signature": "metadata(self, metadata)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "timeslots",
        "full_api_name": "Schedule.timeslots",
        "api_description": "Time keeping attribute.",
        "api_signature": "timeslots(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "duration",
        "full_api_name": "Schedule.duration",
        "api_description": "Duration of this schedule.",
        "api_signature": "duration(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "start_time",
        "full_api_name": "Schedule.start_time",
        "api_description": "Starting time of this schedule.",
        "api_signature": "start_time(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "stop_time",
        "full_api_name": "Schedule.stop_time",
        "api_description": "Stopping time of this schedule.",
        "api_signature": "stop_time(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "channels",
        "full_api_name": "Schedule.channels",
        "api_description": "Returns channels that this schedule uses.",
        "api_signature": "channels(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "children",
        "full_api_name": "Schedule.children",
        "api_description": "Return the child schedule components of this ``Schedule`` in the\norder they were added to the schedule.\n\nNotes:\n    Nested schedules are returned as-is. If you want to collect only instructions,\n    use py:meth:`~Schedule.instructions` instead.\n\nReturns:\n    A tuple, where each element is a two-tuple containing the initial\n    scheduled time of each ``NamedValue`` and the component\n    itself.",
        "api_signature": "children(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "instructions",
        "full_api_name": "Schedule.instructions",
        "api_description": "Get the time-ordered instructions from self.",
        "api_signature": "instructions(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "key",
        "full_api_name": "Schedule.key",
        "api_description": "",
        "api_signature": "key(time_inst_pair)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "parameters",
        "full_api_name": "Schedule.parameters",
        "api_description": "Parameters which determine the schedule behavior.",
        "api_signature": "parameters(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "ch_duration",
        "full_api_name": "Schedule.ch_duration",
        "api_description": "Return the time of the end of the last instruction over the supplied channels.\n\nArgs:\n    *channels: Channels within ``self`` to include.",
        "api_signature": "ch_duration(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "ch_start_time",
        "full_api_name": "Schedule.ch_start_time",
        "api_description": "Return the time of the start of the first instruction over the supplied channels.\n\nArgs:\n    *channels: Channels within ``self`` to include.",
        "api_signature": "ch_start_time(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "ch_stop_time",
        "full_api_name": "Schedule.ch_stop_time",
        "api_description": "Return maximum start time over supplied channels.\n\nArgs:\n    *channels: Channels within ``self`` to include.",
        "api_signature": "ch_stop_time(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "_instructions",
        "full_api_name": "Schedule._instructions",
        "api_description": "Iterable for flattening Schedule tree.\n\nArgs:\n    time: Shifted time due to parent.\n\nYields:\n    Iterable[Tuple[int, Instruction]]: Tuple containing the time each\n        :class:`~qiskit.pulse.Instruction`\n        starts at and the flattened :class:`~qiskit.pulse.Instruction` s.",
        "api_signature": "_instructions(self, time)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "shift",
        "full_api_name": "Schedule.shift",
        "api_description": "Return a schedule shifted forward by ``time``.\n\nArgs:\n    time: Time to shift by.\n    name: Name of the new schedule. Defaults to the name of self.\n    inplace: Perform operation inplace on this schedule. Otherwise\n        return a new ``Schedule``.",
        "api_signature": "shift(self, time, name, inplace)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "_immutable_shift",
        "full_api_name": "Schedule._immutable_shift",
        "api_description": "Return a new schedule shifted forward by `time`.\n\nArgs:\n    time: Time to shift by\n    name: Name of the new schedule if call was mutable. Defaults to name of self",
        "api_signature": "_immutable_shift(self, time, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "_mutable_shift",
        "full_api_name": "Schedule._mutable_shift",
        "api_description": "Return this schedule shifted forward by `time`.\n\nArgs:\n    time: Time to shift by\n\nRaises:\n    PulseError: if ``time`` is not an integer.",
        "api_signature": "_mutable_shift(self, time)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "insert",
        "full_api_name": "Schedule.insert",
        "api_description": "Return a new schedule with ``schedule`` inserted into ``self`` at ``start_time``.\n\nArgs:\n    start_time: Time to insert the schedule.\n    schedule: Schedule to insert.\n    name: Name of the new schedule. Defaults to the name of self.\n    inplace: Perform operation inplace on this schedule. Otherwise\n        return a new ``Schedule``.",
        "api_signature": "insert(self, start_time, schedule, name, inplace)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "_mutable_insert",
        "full_api_name": "Schedule._mutable_insert",
        "api_description": "Mutably insert `schedule` into `self` at `start_time`.\n\nArgs:\n    start_time: Time to insert the second schedule.\n    schedule: Schedule to mutably insert.",
        "api_signature": "_mutable_insert(self, start_time, schedule)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "_immutable_insert",
        "full_api_name": "Schedule._immutable_insert",
        "api_description": "Return a new schedule with ``schedule`` inserted into ``self`` at ``start_time``.\nArgs:\n    start_time: Time to insert the schedule.\n    schedule: Schedule to insert.\n    name: Name of the new ``Schedule``. Defaults to name of ``self``.",
        "api_signature": "_immutable_insert(self, start_time, schedule, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "append",
        "full_api_name": "Schedule.append",
        "api_description": "Return a new schedule with ``schedule`` inserted at the maximum time over\nall channels shared between ``self`` and ``schedule``.\n\n.. math::\n\n    t = \\textrm{max}(\\texttt{x.stop_time} |\\texttt{x} \\in\n        \\texttt{self.channels} \\cap \\texttt{schedule.channels})\n\nArgs:\n    schedule: Schedule to be appended.\n    name: Name of the new ``Schedule``. Defaults to name of ``self``.\n    inplace: Perform operation inplace on this schedule. Otherwise\n        return a new ``Schedule``.",
        "api_signature": "append(self, schedule, name, inplace)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "filter",
        "full_api_name": "Schedule.filter",
        "api_description": "Return a new ``Schedule`` with only the instructions from this ``Schedule`` which pass\nthough the provided filters; i.e. an instruction will be retained iff every function in\n``filter_funcs`` returns ``True``, the instruction occurs on a channel type contained in\n``channels``, the instruction type is contained in ``instruction_types``, and the period\nover which the instruction operates is *fully* contained in one specified in\n``time_ranges`` or ``intervals``.\n\nIf no arguments are provided, ``self`` is returned.\n\nArgs:\n    filter_funcs: A list of Callables which take a (int, Union['Schedule', Instruction])\n        tuple and return a bool.\n    channels: For example, ``[DriveChannel(0), AcquireChannel(0)]``.\n    instruction_types: For example, ``[PulseInstruction, AcquireInstruction]``.\n    time_ranges: For example, ``[(0, 5), (6, 10)]``.\n    intervals: For example, ``[(0, 5), (6, 10)]``.\n    check_subroutine: Set `True` to individually filter instructions inside of a subroutine\n        defined by the :py:class:`~qiskit.pulse.instructions.Call` instruction.",
        "api_signature": "filter(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "exclude",
        "full_api_name": "Schedule.exclude",
        "api_description": "Return a ``Schedule`` with only the instructions from this Schedule *failing*\nat least one of the provided filters.\nThis method is the complement of py:meth:`~self.filter`, so that::\n\n    self.filter(args) | self.exclude(args) == self\n\nArgs:\n    filter_funcs: A list of Callables which take a (int, Union['Schedule', Instruction])\n        tuple and return a bool.\n    channels: For example, ``[DriveChannel(0), AcquireChannel(0)]``.\n    instruction_types: For example, ``[PulseInstruction, AcquireInstruction]``.\n    time_ranges: For example, ``[(0, 5), (6, 10)]``.\n    intervals: For example, ``[(0, 5), (6, 10)]``.\n    check_subroutine: Set `True` to individually filter instructions inside of a subroutine\n        defined by the :py:class:`~qiskit.pulse.instructions.Call` instruction.",
        "api_signature": "exclude(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "_add_timeslots",
        "full_api_name": "Schedule._add_timeslots",
        "api_description": "Update all time tracking within this schedule based on the given schedule.\n\nArgs:\n    time: The time to insert the schedule into self.\n    schedule: The schedule to insert into self.\n\nRaises:\n    PulseError: If timeslots overlap or an invalid start time is provided.",
        "api_signature": "_add_timeslots(self, time, schedule)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "_remove_timeslots",
        "full_api_name": "Schedule._remove_timeslots",
        "api_description": "Delete the timeslots if present for the respective schedule component.\n\nArgs:\n    time: The time to remove the timeslots for the ``schedule`` component.\n    schedule: The schedule to insert into self.\n\nRaises:\n    PulseError: If timeslots overlap or an invalid start time is provided.",
        "api_signature": "_remove_timeslots(self, time, schedule)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "_replace_timeslots",
        "full_api_name": "Schedule._replace_timeslots",
        "api_description": "Replace the timeslots of ``old`` if present with the timeslots of ``new``.\n\nArgs:\n    time: The time to remove the timeslots for the ``schedule`` component.\n    old: Instruction to replace.\n    new: Instruction to replace with.",
        "api_signature": "_replace_timeslots(self, time, old, new)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "_renew_timeslots",
        "full_api_name": "Schedule._renew_timeslots",
        "api_description": "Regenerate timeslots based on current instructions.",
        "api_signature": "_renew_timeslots(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "replace",
        "full_api_name": "Schedule.replace",
        "api_description": "Return a ``Schedule`` with the ``old`` instruction replaced with a ``new``\ninstruction.\n\nThe replacement matching is based on an instruction equality check.\n\n.. code-block::\n\n    from qiskit import pulse\n\n    d0 = pulse.DriveChannel(0)\n\n    sched = pulse.Schedule()\n\n    old = pulse.Play(pulse.Constant(100, 1.0), d0)\n    new = pulse.Play(pulse.Constant(100, 0.1), d0)\n\n    sched += old\n\n    sched = sched.replace(old, new)\n\n    assert sched == pulse.Schedule(new)\n\nOnly matches at the top-level of the schedule tree. If you wish to\nperform this replacement over all instructions in the schedule tree.\nFlatten the schedule prior to running::\n\n.. code-block::\n\n    sched = pulse.Schedule()\n\n    sched += pulse.Schedule(old)\n\n    sched = sched.flatten()\n\n    sched = sched.replace(old, new)\n\n    assert sched == pulse.Schedule(new)\n\nArgs:\n    old: Instruction to replace.\n    new: Instruction to replace with.\n    inplace: Replace instruction by mutably modifying this ``Schedule``.\n\nReturns:\n    The modified schedule with ``old`` replaced by ``new``.\n\nRaises:\n    PulseError: If the ``Schedule`` after replacements will has a timing overlap.",
        "api_signature": "replace(self, old, new, inplace)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "is_parameterized",
        "full_api_name": "Schedule.is_parameterized",
        "api_description": "Return True iff the instruction is parameterized.",
        "api_signature": "is_parameterized(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "assign_parameters",
        "full_api_name": "Schedule.assign_parameters",
        "api_description": "Assign the parameters in this schedule according to the input.\n\nArgs:\n    value_dict: A mapping from Parameters to either numeric values or another\n        Parameter expression.\n    inplace: Set ``True`` to override this instance with new parameter.\n\nReturns:\n    Schedule with updated parameters.",
        "api_signature": "assign_parameters(self, value_dict, inplace)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "get_parameters",
        "full_api_name": "Schedule.get_parameters",
        "api_description": "Get parameter object bound to this schedule by string name.\n\nBecause different ``Parameter`` objects can have the same name,\nthis method returns a list of ``Parameter`` s for the provided name.\n\nArgs:\n    parameter_name: Name of parameter.\n\nReturns:\n    Parameter objects that have corresponding name.",
        "api_signature": "get_parameters(self, parameter_name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "__len__",
        "full_api_name": "Schedule.__len__",
        "api_description": "Return number of instructions in the schedule.",
        "api_signature": "__len__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "__add__",
        "full_api_name": "Schedule.__add__",
        "api_description": "Return a new schedule with ``other`` inserted within ``self`` at ``start_time``.",
        "api_signature": "__add__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "__or__",
        "full_api_name": "Schedule.__or__",
        "api_description": "Return a new schedule which is the union of `self` and `other`.",
        "api_signature": "__or__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "__lshift__",
        "full_api_name": "Schedule.__lshift__",
        "api_description": "Return a new schedule which is shifted forward by ``time``.",
        "api_signature": "__lshift__(self, time)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "Schedule.__eq__",
        "api_description": "Test if two Schedule are equal.\n\nEquality is checked by verifying there is an equal instruction at every time\nin ``other`` for every instruction in this ``Schedule``.\n\n.. warning::\n\n    This does not check for logical equivalency. Ie.,\n\n    ```python\n    >>> Delay(10, DriveChannel(0)) + Delay(10, DriveChannel(0))\n        == Delay(20, DriveChannel(0))\n    False\n    ```",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "Schedule.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "_require_schedule_conversion",
        "full_api_name": "_require_schedule_conversion",
        "api_description": "A method decorator to convert schedule block to pulse schedule.\n\nThis conversation is performed for backward compatibility only if all durations are assigned.",
        "api_signature": "_require_schedule_conversion(function)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "wrapper",
        "full_api_name": "wrapper",
        "api_description": "",
        "api_signature": "wrapper(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ScheduleBlock.__init__",
        "api_description": "Create an empty schedule block.\n\nArgs:\n    name: Name of this schedule. Defaults to an autogenerated string if not provided.\n    metadata: Arbitrary key value metadata to associate with the schedule. This gets\n        stored as free-form data in a dict in the\n        :attr:`~qiskit.pulse.ScheduleBlock.metadata` attribute. It will not be directly\n        used in the schedule.\n    alignment_context (AlignmentKind): ``AlignmentKind`` instance that manages\n        scheduling of instructions in this block.\n\nRaises:\n    TypeError: if metadata is not a dict.",
        "api_signature": "__init__(self, name, metadata, alignment_context)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "initialize_from",
        "full_api_name": "ScheduleBlock.initialize_from",
        "api_description": "Create new schedule object with metadata of another schedule object.\n\nArgs:\n    other_program: Qiskit program that provides metadata to new object.\n    name: Name of new schedule. Name of ``block`` is used by default.\n\nReturns:\n    New block object with name and metadata.\n\nRaises:\n    PulseError: When ``other_program`` does not provide necessary information.",
        "api_signature": "initialize_from(cls, other_program, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "name",
        "full_api_name": "ScheduleBlock.name",
        "api_description": "Return name of this schedule",
        "api_signature": "name(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "metadata",
        "full_api_name": "ScheduleBlock.metadata",
        "api_description": "The user provided metadata associated with the schedule.\n\nUser provided ``dict`` of metadata for the schedule.\nThe metadata contents do not affect the semantics of the program\nbut are used to influence the execution of the schedule. It is expected\nto be passed between all transforms of the schedule and that providers\nwill associate any schedule metadata with the results it returns from the\nexecution of that schedule.",
        "api_signature": "metadata(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "metadata",
        "full_api_name": "ScheduleBlock.metadata",
        "api_description": "Update the schedule metadata",
        "api_signature": "metadata(self, metadata)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "alignment_context",
        "full_api_name": "ScheduleBlock.alignment_context",
        "api_description": "Return alignment instance that allocates block component to generate schedule.",
        "api_signature": "alignment_context(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "is_schedulable",
        "full_api_name": "ScheduleBlock.is_schedulable",
        "api_description": "Return ``True`` if all durations are assigned.",
        "api_signature": "is_schedulable(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "duration",
        "full_api_name": "ScheduleBlock.duration",
        "api_description": "Duration of this schedule block.",
        "api_signature": "duration(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "channels",
        "full_api_name": "ScheduleBlock.channels",
        "api_description": "Returns channels that this schedule block uses.",
        "api_signature": "channels(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "instructions",
        "full_api_name": "ScheduleBlock.instructions",
        "api_description": "Get the time-ordered instructions from self.",
        "api_signature": "instructions(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "blocks",
        "full_api_name": "ScheduleBlock.blocks",
        "api_description": "Get the block elements added to self.\n\n.. note::\n\n    The sequence of elements is returned in order of addition. Because the first element is\n    schedule first, e.g. FIFO, the returned sequence is roughly time-ordered.\n    However, in the parallel alignment context, especially in\n    the as-late-as-possible scheduling, or :class:`.AlignRight` context,\n    the actual timing of when the instructions are issued is unknown until\n    the :class:`.ScheduleBlock` is scheduled and converted into a :class:`.Schedule`.",
        "api_signature": "blocks(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "parameters",
        "full_api_name": "ScheduleBlock.parameters",
        "api_description": "Return unassigned parameters with raw names.",
        "api_signature": "parameters(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "scoped_parameters",
        "full_api_name": "ScheduleBlock.scoped_parameters",
        "api_description": "Return unassigned parameters with scoped names.\n\n.. note::\n\n    If a parameter is defined within a nested scope,\n    it is prefixed with all parent-scope names with the delimiter string,\n    which is \"::\". If a reference key of the scope consists of\n    multiple key strings, it will be represented by a single string joined with \",\".\n    For example, \"root::xgate,q0::amp\" for the parameter \"amp\" defined in the\n    reference specified by the key strings (\"xgate\", \"q0\").",
        "api_signature": "scoped_parameters(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "references",
        "full_api_name": "ScheduleBlock.references",
        "api_description": "Return a reference manager of the current scope.",
        "api_signature": "references(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "ch_duration",
        "full_api_name": "ScheduleBlock.ch_duration",
        "api_description": "Return the time of the end of the last instruction over the supplied channels.\n\nArgs:\n    *channels: Channels within ``self`` to include.",
        "api_signature": "ch_duration(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "append",
        "full_api_name": "ScheduleBlock.append",
        "api_description": "Return a new schedule block with ``block`` appended to the context block.\nThe execution time is automatically assigned when the block is converted into schedule.\n\nArgs:\n    block: ScheduleBlock to be appended.\n    name: Name of the new ``Schedule``. Defaults to name of ``self``.\n    inplace: Perform operation inplace on this schedule. Otherwise,\n        return a new ``Schedule``.\n\nReturns:\n    Schedule block with appended schedule.\n\nRaises:\n    PulseError: When invalid schedule type is specified.",
        "api_signature": "append(self, block, name, inplace)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "filter",
        "full_api_name": "ScheduleBlock.filter",
        "api_description": "Return a new ``ScheduleBlock`` with only the instructions from this ``ScheduleBlock``\nwhich pass though the provided filters; i.e. an instruction will be retained if\nevery function in ``filter_funcs`` returns ``True``, the instruction occurs on\na channel type contained in ``channels``, and the instruction type is contained\nin ``instruction_types``.\n\n.. warning::\n    Because ``ScheduleBlock`` is not aware of the execution time of\n    the context instructions, filtering out some instructions may\n    change the execution time of the remaining instructions.\n\nIf no arguments are provided, ``self`` is returned.\n\nArgs:\n    filter_funcs: A list of Callables which take a ``Instruction`` and return a bool.\n    channels: For example, ``[DriveChannel(0), AcquireChannel(0)]``.\n    instruction_types: For example, ``[PulseInstruction, AcquireInstruction]``.\n    check_subroutine: Set `True` to individually filter instructions inside a subroutine\n        defined by the :py:class:`~qiskit.pulse.instructions.Call` instruction.\n\nReturns:\n    ``ScheduleBlock`` consisting of instructions that matches with filtering condition.",
        "api_signature": "filter(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "exclude",
        "full_api_name": "ScheduleBlock.exclude",
        "api_description": "Return a new ``ScheduleBlock`` with only the instructions from this ``ScheduleBlock``\n*failing* at least one of the provided filters.\nThis method is the complement of py:meth:`~self.filter`, so that::\n\n    self.filter(args) + self.exclude(args) == self in terms of instructions included.\n\n.. warning::\n    Because ``ScheduleBlock`` is not aware of the execution time of\n    the context instructions, excluding some instructions may\n    change the execution time of the remaining instructions.\n\nArgs:\n    filter_funcs: A list of Callables which take a ``Instruction`` and return a bool.\n    channels: For example, ``[DriveChannel(0), AcquireChannel(0)]``.\n    instruction_types: For example, ``[PulseInstruction, AcquireInstruction]``.\n    check_subroutine: Set `True` to individually filter instructions inside of a subroutine\n        defined by the :py:class:`~qiskit.pulse.instructions.Call` instruction.\n\nReturns:\n    ``ScheduleBlock`` consisting of instructions that do not match with\n    at least one of filtering conditions.",
        "api_signature": "exclude(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "replace",
        "full_api_name": "ScheduleBlock.replace",
        "api_description": "Return a ``ScheduleBlock`` with the ``old`` component replaced with a ``new``\ncomponent.\n\nArgs:\n    old: Schedule block component to replace.\n    new: Schedule block component to replace with.\n    inplace: Replace instruction by mutably modifying this ``ScheduleBlock``.\n\nReturns:\n    The modified schedule block with ``old`` replaced by ``new``.",
        "api_signature": "replace(self, old, new, inplace)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "is_parameterized",
        "full_api_name": "ScheduleBlock.is_parameterized",
        "api_description": "Return True iff the instruction is parameterized.",
        "api_signature": "is_parameterized(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "is_referenced",
        "full_api_name": "ScheduleBlock.is_referenced",
        "api_description": "Return True iff the current schedule block contains reference to subroutine.",
        "api_signature": "is_referenced(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "assign_parameters",
        "full_api_name": "ScheduleBlock.assign_parameters",
        "api_description": "Assign the parameters in this schedule according to the input.\n\nArgs:\n    value_dict: A mapping from Parameters to either numeric values or another\n        Parameter expression.\n    inplace: Set ``True`` to override this instance with new parameter.\n\nReturns:\n    Schedule with updated parameters.\n\nRaises:\n    PulseError: When the block is nested into another block.",
        "api_signature": "assign_parameters(self, value_dict, inplace)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "assign_references",
        "full_api_name": "ScheduleBlock.assign_references",
        "api_description": "Assign schedules to references.\n\nIt is only capable of assigning a schedule block to immediate references\nwhich are directly referred within the current scope.\nLet's see following example:\n\n.. code-block:: python\n\n    from qiskit import pulse\n\n    with pulse.build() as subroutine:\n        pulse.delay(10, pulse.DriveChannel(0))\n\n    with pulse.build() as sub_prog:\n        pulse.reference(\"A\")\n\n    with pulse.build() as main_prog:\n        pulse.reference(\"B\")\n\nIn above example, the ``main_prog`` can refer to the subroutine \"root::B\" and the\nreference of \"B\" to program \"A\", i.e., \"B::A\", is not defined in the root namespace.\nThis prevents breaking the reference \"root::B::A\" by the assignment of \"root::B\".\nFor example, if a user could indirectly assign \"root::B::A\" from the root program,\none can later assign another program to \"root::B\" that doesn't contain \"A\" within it.\nIn this situation, a reference \"root::B::A\" would still live in\nthe reference manager of the root.\nHowever, the subroutine \"root::B::A\" would no longer be used in the actual pulse program.\nTo assign subroutine \"A\" to ``nested_prog`` as a nested subprogram of ``main_prog``,\nyou must first assign \"A\" of the ``sub_prog``,\nand then assign the ``sub_prog`` to the ``main_prog``.\n\n.. code-block:: python\n\n    sub_prog.assign_references({(\"A\", ): nested_prog}, inplace=True)\n    main_prog.assign_references({(\"B\", ): sub_prog}, inplace=True)\n\nAlternatively, you can also write\n\n.. code-block:: python\n\n    main_prog.assign_references({(\"B\", ): sub_prog}, inplace=True)\n    main_prog.references[(\"B\", )].assign_references({\"A\": nested_prog}, inplace=True)\n\nHere :attr:`.references` returns a dict-like object, and you can\nmutably update the nested reference of the particular subroutine.\n\n.. note::\n\n    Assigned programs are deep-copied to prevent an unexpected update.\n\nArgs:\n    subroutine_dict: A mapping from reference key to schedule block of the subroutine.\n    inplace: Set ``True`` to override this instance with new subroutine.\n\nReturns:\n    Schedule block with assigned subroutine.\n\nRaises:\n    PulseError: When reference key is not defined in the current scope.",
        "api_signature": "assign_references(self, subroutine_dict, inplace)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "get_parameters",
        "full_api_name": "ScheduleBlock.get_parameters",
        "api_description": "Get parameter object bound to this schedule by string name.\n\nNote that we can define different parameter objects with the same name,\nbecause these different objects are identified by their unique uuid.\nFor example,\n\n.. code-block:: python\n\n    from qiskit import pulse, circuit\n\n    amp1 = circuit.Parameter(\"amp\")\n    amp2 = circuit.Parameter(\"amp\")\n\n    with pulse.build() as sub_prog:\n        pulse.play(pulse.Constant(100, amp1), pulse.DriveChannel(0))\n\n    with pulse.build() as main_prog:\n        pulse.call(sub_prog, name=\"sub\")\n        pulse.play(pulse.Constant(100, amp2), pulse.DriveChannel(0))\n\n    main_prog.get_parameters(\"amp\")\n\nThis returns a list of two parameters ``amp1`` and ``amp2``.\n\nArgs:\n    parameter_name: Name of parameter.\n\nReturns:\n    Parameter objects that have corresponding name.",
        "api_signature": "get_parameters(self, parameter_name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "search_parameters",
        "full_api_name": "ScheduleBlock.search_parameters",
        "api_description": "Search parameter with regular expression.\n\nThis method looks for the scope-aware parameters.\nFor example,\n\n.. code-block:: python\n\n    from qiskit import pulse, circuit\n\n    amp1 = circuit.Parameter(\"amp\")\n    amp2 = circuit.Parameter(\"amp\")\n\n    with pulse.build() as sub_prog:\n        pulse.play(pulse.Constant(100, amp1), pulse.DriveChannel(0))\n\n    with pulse.build() as main_prog:\n        pulse.call(sub_prog, name=\"sub\")\n        pulse.play(pulse.Constant(100, amp2), pulse.DriveChannel(0))\n\n    main_prog.search_parameters(\"root::sub::amp\")\n\nThis finds ``amp1`` with scoped name \"root::sub::amp\".\n\nArgs:\n    parameter_regex: Regular expression for scoped parameter name.\n\nReturns:\n    Parameter objects that have corresponding name.",
        "api_signature": "search_parameters(self, parameter_regex)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "__len__",
        "full_api_name": "ScheduleBlock.__len__",
        "api_description": "Return number of instructions in the schedule.",
        "api_signature": "__len__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "ScheduleBlock.__eq__",
        "api_description": "Test if two ScheduleBlocks are equal.\n\nEquality is checked by verifying there is an equal instruction at every time\nin ``other`` for every instruction in this ``ScheduleBlock``. This check is\nperformed by converting the instruction representation into directed acyclic graph,\nin which execution order of every instruction is evaluated correctly across all channels.\nAlso ``self`` and ``other`` should have the same alignment context.\n\n.. warning::\n\n    This does not check for logical equivalency. Ie.,\n\n    ```python\n    >>> Delay(10, DriveChannel(0)) + Delay(10, DriveChannel(0))\n        == Delay(20, DriveChannel(0))\n    False\n    ```",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "ScheduleBlock.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "__add__",
        "full_api_name": "ScheduleBlock.__add__",
        "api_description": "Return a new schedule with ``other`` inserted within ``self`` at ``start_time``.",
        "api_signature": "__add__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "_common_method",
        "full_api_name": "_common_method",
        "api_description": "A function decorator to attach the function to specified classes as a method.\n\n.. note:: For developer: A method attached through this decorator may hurt readability\n    of the codebase, because the method may not be detected by a code editor.\n    Thus, this decorator should be used to a limited extent, i.e. huge helper method.\n    By using this decorator wisely, we can reduce code maintenance overhead without\n    losing readability of the codebase.",
        "api_signature": "_common_method()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "decorator",
        "full_api_name": "decorator",
        "api_description": "",
        "api_signature": "decorator(method)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "wrapper",
        "full_api_name": "wrapper",
        "api_description": "",
        "api_signature": "wrapper()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "draw",
        "full_api_name": "draw",
        "api_description": "Plot the schedule.\n\nArgs:\n    style: Stylesheet options. This can be dictionary or preset stylesheet classes. See\n        :py:class:`~qiskit.visualization.pulse_v2.stylesheets.IQXStandard`,\n        :py:class:`~qiskit.visualization.pulse_v2.stylesheets.IQXSimple`, and\n        :py:class:`~qiskit.visualization.pulse_v2.stylesheets.IQXDebugging` for details of\n        preset stylesheets.\n    backend (Optional[BaseBackend]): Backend object to play the input pulse program.\n        If provided, the plotter may use to make the visualization hardware aware.\n    time_range: Set horizontal axis limit. Tuple `(tmin, tmax)`.\n    time_unit: The unit of specified time range either `dt` or `ns`.\n        The unit of `ns` is available only when `backend` object is provided.\n    disable_channels: A control property to show specific pulse channel.\n        Pulse channel instances provided as a list are not shown in the output image.\n    show_snapshot: Show snapshot instructions.\n    show_framechange: Show frame change instructions. The frame change represents\n        instructions that modulate phase or frequency of pulse channels.\n    show_waveform_info: Show additional information about waveforms such as their name.\n    show_barrier: Show barrier lines.\n    plotter: Name of plotter API to generate an output image.\n        One of following APIs should be specified::\n\n            mpl2d: Matplotlib API for 2D image generation.\n                Matplotlib API to generate 2D image. Charts are placed along y axis with\n                vertical offset. This API takes matplotlib.axes.Axes as ``axis`` input.\n\n        ``axis`` and ``style`` kwargs may depend on the plotter.\n    axis: Arbitrary object passed to the plotter. If this object is provided,\n        the plotters use a given ``axis`` instead of internally initializing\n        a figure object. This object format depends on the plotter.\n        See plotter argument for details.\n\nReturns:\n    Visualization output data.\n    The returned data type depends on the ``plotter``.\n    If matplotlib family is specified, this will be a ``matplotlib.pyplot.Figure`` data.",
        "api_signature": "draw(self, style, backend, time_range, time_unit, disable_channels, show_snapshot, show_framechange, show_waveform_info, show_barrier, plotter, axis)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "_interval_index",
        "full_api_name": "_interval_index",
        "api_description": "Find the index of an interval.\n\nArgs:\n    intervals: A sorted list of non-overlapping Intervals.\n    interval: The interval for which the index into intervals will be found.\n\nReturns:\n    The index of the interval.\n\nRaises:\n    PulseError: If the interval does not exist.",
        "api_signature": "_interval_index(intervals, interval)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "_locate_interval_index",
        "full_api_name": "_locate_interval_index",
        "api_description": "Using binary search on start times, find an interval.\n\nArgs:\n    intervals: A sorted list of non-overlapping Intervals.\n    interval: The interval for which the index into intervals will be found.\n    index: A running tally of the index, for recursion. The user should not pass a value.\n\nReturns:\n    The index into intervals that new_interval would be inserted to maintain\n    a sorted list of intervals.",
        "api_signature": "_locate_interval_index(intervals, interval, index)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "_find_insertion_index",
        "full_api_name": "_find_insertion_index",
        "api_description": "Using binary search on start times, return the index into `intervals` where the new interval\nbelongs, or raise an error if the new interval overlaps with any existing ones.\nArgs:\n    intervals: A sorted list of non-overlapping Intervals.\n    new_interval: The interval for which the index into intervals will be found.\nReturns:\n    The index into intervals that new_interval should be inserted to maintain a sorted list\n    of intervals.\nRaises:\n    PulseError: If new_interval overlaps with the given intervals.",
        "api_signature": "_find_insertion_index(intervals, new_interval)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "_overlaps",
        "full_api_name": "_overlaps",
        "api_description": "Return True iff first and second overlap.\nNote: first.stop may equal second.start, since Interval stop times are exclusive.",
        "api_signature": "_overlaps(first, second)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "_check_nonnegative_timeslot",
        "full_api_name": "_check_nonnegative_timeslot",
        "api_description": "Test that a channel has no negative timeslots.\n\nRaises:\n    PulseError: If a channel timeslot is negative.",
        "api_signature": "_check_nonnegative_timeslot(timeslots)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "_get_timeslots",
        "full_api_name": "_get_timeslots",
        "api_description": "Generate timeslots from given schedule component.\n\nArgs:\n    schedule: Input schedule component.\n\nRaises:\n    PulseError: When invalid schedule type is specified.",
        "api_signature": "_get_timeslots(schedule)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "_get_references",
        "full_api_name": "_get_references",
        "api_description": "Recursively get reference instructions in the current scope.\n\nArgs:\n    block_elms: List of schedule block elements to investigate.\n\nReturns:\n    A set of unique reference instructions.",
        "api_signature": "_get_references(block_elms)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "_collect_scoped_parameters",
        "full_api_name": "_collect_scoped_parameters",
        "api_description": "A helper function to collect parameters from all references in scope-aware fashion.\n\nParameter object is renamed with attached scope information but its UUID is remained.\nThis means object is treated identically on the assignment logic.\nThis function returns a dictionary of all parameters existing in the target program\nincluding its reference, which is keyed on the unique identifier consisting of\nscoped parameter name and parameter object UUID.\n\nThis logic prevents parameter clash in the different scope.\nFor example, when two parameter objects with the same UUID exist in different references,\nboth of them appear in the output dictionary, even though they are technically the same object.\nThis feature is particularly convenient to search parameter object with associated scope.\n\nArgs:\n    schedule: Schedule to get parameters.\n    current_scope: Name of scope where schedule exist.\n    filter_regex: Optional. Compiled regex to sort parameter by name.\n\nReturns:\n    A dictionary of scoped parameter objects.",
        "api_signature": "_collect_scoped_parameters(schedule, current_scope, filter_regex)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "filter_instructions",
        "full_api_name": "filter_instructions",
        "api_description": "A catch-TypeError function which will only get called if none of the other decorated\nfunctions, namely handle_schedule() and handle_scheduleblock(), handle the type passed.",
        "api_signature": "filter_instructions(sched, filters, negate, recurse_subroutines)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/filters.py"
    },
    {
        "api_name": "handle_schedule",
        "full_api_name": "handle_schedule",
        "api_description": "A filtering function that takes a schedule and returns a schedule consisting of\nfiltered instructions.\n\nArgs:\n    sched: A pulse schedule to be filtered.\n    filters: List of callback functions that take an instruction and return boolean.\n    negate: Set `True` to accept an instruction if a filter function returns `False`.\n        Otherwise the instruction is accepted when the filter function returns `False`.\n    recurse_subroutines: Set `True` to individually filter instructions inside of a subroutine\n        defined by the :py:class:`~qiskit.pulse.instructions.Call` instruction.\n\nReturns:\n    Filtered pulse schedule.",
        "api_signature": "handle_schedule(sched, filters, negate, recurse_subroutines)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/filters.py"
    },
    {
        "api_name": "handle_scheduleblock",
        "full_api_name": "handle_scheduleblock",
        "api_description": "A filtering function that takes a schedule_block and returns a schedule_block consisting of\nfiltered instructions.\n\nArgs:\n    sched_blk: A pulse schedule_block to be filtered.\n    filters: List of callback functions that take an instruction and return boolean.\n    negate: Set `True` to accept an instruction if a filter function returns `False`.\n        Otherwise the instruction is accepted when the filter function returns `False`.\n    recurse_subroutines: Set `True` to individually filter instructions inside of a subroutine\n        defined by the :py:class:`~qiskit.pulse.instructions.Call` instruction.\n\nReturns:\n    Filtered pulse schedule_block.",
        "api_signature": "handle_scheduleblock(sched_blk, filters, negate, recurse_subroutines)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/filters.py"
    },
    {
        "api_name": "apply_filters_to_insts_in_scheblk",
        "full_api_name": "apply_filters_to_insts_in_scheblk",
        "api_description": "",
        "api_signature": "apply_filters_to_insts_in_scheblk(blk)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/filters.py"
    },
    {
        "api_name": "composite_filter",
        "full_api_name": "composite_filter",
        "api_description": "A helper function to generate a list of filter functions based on\ntypical elements to be filtered.\n\nArgs:\n    channels: For example, ``[DriveChannel(0), AcquireChannel(0)]``.\n    instruction_types (Optional[Iterable[Type[qiskit.pulse.Instruction]]]): For example,\n        ``[PulseInstruction, AcquireInstruction]``.\n    time_ranges: For example, ``[(0, 5), (6, 10)]``.\n    intervals: For example, ``[(0, 5), (6, 10)]``.\n\nReturns:\n    List of filtering functions.",
        "api_signature": "composite_filter(channels, instruction_types, time_ranges, intervals)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/filters.py"
    },
    {
        "api_name": "with_channels",
        "full_api_name": "with_channels",
        "api_description": "Channel filter generator.\n\nArgs:\n    channels: List of channels to filter.\n\nReturns:\n    A callback function to filter channels.",
        "api_signature": "with_channels(channels)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/filters.py"
    },
    {
        "api_name": "channel_filter",
        "full_api_name": "channel_filter",
        "api_description": "A catch-TypeError function which will only get called if none of the other decorated\nfunctions, namely handle_numpyndarray() and handle_instruction(), handle the type passed.",
        "api_signature": "channel_filter(time_inst)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/filters.py"
    },
    {
        "api_name": "handle_numpyndarray",
        "full_api_name": "handle_numpyndarray",
        "api_description": "Filter channel.\n\nArgs:\n    time_inst (numpy.ndarray([int, Instruction])): Time\n\nReturns:\n    If instruction matches with condition.",
        "api_signature": "handle_numpyndarray(time_inst)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/filters.py"
    },
    {
        "api_name": "handle_instruction",
        "full_api_name": "handle_instruction",
        "api_description": "Filter channel.\n\nArgs:\n    inst: Instruction\n\nReturns:\n    If instruction matches with condition.",
        "api_signature": "handle_instruction(inst)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/filters.py"
    },
    {
        "api_name": "with_instruction_types",
        "full_api_name": "with_instruction_types",
        "api_description": "Instruction type filter generator.\n\nArgs:\n    types: List of instruction types to filter.\n\nReturns:\n    A callback function to filter instructions.",
        "api_signature": "with_instruction_types(types)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/filters.py"
    },
    {
        "api_name": "instruction_filter",
        "full_api_name": "instruction_filter",
        "api_description": "A catch-TypeError function which will only get called if none of the other decorated\nfunctions, namely handle_numpyndarray() and handle_instruction(), handle the type passed.",
        "api_signature": "instruction_filter(time_inst)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/filters.py"
    },
    {
        "api_name": "handle_numpyndarray",
        "full_api_name": "handle_numpyndarray",
        "api_description": "Filter instruction.\n\nArgs:\n    time_inst (numpy.ndarray([int, Instruction])): Time\n\nReturns:\n    If instruction matches with condition.",
        "api_signature": "handle_numpyndarray(time_inst)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/filters.py"
    },
    {
        "api_name": "handle_instruction",
        "full_api_name": "handle_instruction",
        "api_description": "Filter instruction.\n\nArgs:\n    inst: Instruction\n\nReturns:\n    If instruction matches with condition.",
        "api_signature": "handle_instruction(inst)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/filters.py"
    },
    {
        "api_name": "with_intervals",
        "full_api_name": "with_intervals",
        "api_description": "Interval filter generator.\n\nArgs:\n    ranges: List of intervals ``[t0, t1]`` to filter.\n\nReturns:\n    A callback function to filter intervals.",
        "api_signature": "with_intervals(ranges)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/filters.py"
    },
    {
        "api_name": "interval_filter",
        "full_api_name": "interval_filter",
        "api_description": "Filter interval.\nArgs:\n    time_inst (Tuple[int, Instruction]): Time\n\nReturns:\n    If instruction matches with condition.",
        "api_signature": "interval_filter(time_inst)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/filters.py"
    },
    {
        "api_name": "_if_scalar_cast_to_list",
        "full_api_name": "_if_scalar_cast_to_list",
        "api_description": "A helper function to create python list of input arguments.\n\nArgs:\n    to_list: Arbitrary object can be converted into a python list.\n\nReturns:\n    Python list of input object.",
        "api_signature": "_if_scalar_cast_to_list(to_list)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/filters.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Delay.__init__",
        "api_description": "Create a new delay instruction.\n\nNo other instruction may be scheduled within a ``Delay``.\n\nArgs:\n    duration: Length of time of the delay in terms of dt.\n    channel: The channel that will have the delay.\n    name: Name of the delay for display purposes.",
        "api_signature": "__init__(self, duration, channel, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/delay.py"
    },
    {
        "api_name": "channel",
        "full_api_name": "Delay.channel",
        "api_description": "Return the :py:class:`~qiskit.pulse.channels.Channel` that this instruction is\nscheduled on.",
        "api_signature": "channel(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/delay.py"
    },
    {
        "api_name": "channels",
        "full_api_name": "Delay.channels",
        "api_description": "Returns the channels that this schedule uses.",
        "api_signature": "channels(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/delay.py"
    },
    {
        "api_name": "duration",
        "full_api_name": "Delay.duration",
        "api_description": "Duration of this instruction.",
        "api_signature": "duration(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/delay.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Acquire.__init__",
        "api_description": "Create a new Acquire instruction.\n\nArgs:\n    duration: Length of time to acquire data in terms of dt.\n    channel: The channel that will acquire data.\n    mem_slot: The classical memory slot in which to store the classified readout result.\n    reg_slot: The fast-access register slot in which to store the classified readout\n              result for fast feedback.\n    kernel: A ``Kernel`` for integrating raw data.\n    discriminator: A ``Discriminator`` for discriminating kerneled IQ data into 0/1\n                   results.\n    name: Name of the instruction for display purposes.",
        "api_signature": "__init__(self, duration, channel, mem_slot, reg_slot, kernel, discriminator, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/acquire.py"
    },
    {
        "api_name": "_validate",
        "full_api_name": "Acquire._validate",
        "api_description": "Called after initialization to validate instruction data.\n\nRaises:\n    PulseError: If the input ``channel`` is not type :class:`AcquireChannel`.\n    PulseError: If the input ``mem_slot`` is not type :class:`MemorySlot`.\n    PulseError: If the input ``reg_slot`` is not type :class:`RegisterSlot`.\n    PulseError: When memory slot and register slot are both empty.",
        "api_signature": "_validate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/acquire.py"
    },
    {
        "api_name": "channel",
        "full_api_name": "Acquire.channel",
        "api_description": "Return the :py:class:`~qiskit.pulse.channels.Channel` that this instruction is\nscheduled on.",
        "api_signature": "channel(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/acquire.py"
    },
    {
        "api_name": "channels",
        "full_api_name": "Acquire.channels",
        "api_description": "Returns the channels that this schedule uses.",
        "api_signature": "channels(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/acquire.py"
    },
    {
        "api_name": "duration",
        "full_api_name": "Acquire.duration",
        "api_description": "Duration of this instruction.",
        "api_signature": "duration(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/acquire.py"
    },
    {
        "api_name": "kernel",
        "full_api_name": "Acquire.kernel",
        "api_description": "Return kernel settings.",
        "api_signature": "kernel(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/acquire.py"
    },
    {
        "api_name": "discriminator",
        "full_api_name": "Acquire.discriminator",
        "api_description": "Return discrimination settings.",
        "api_signature": "discriminator(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/acquire.py"
    },
    {
        "api_name": "acquire",
        "full_api_name": "Acquire.acquire",
        "api_description": "Acquire channel to acquire data. The ``AcquireChannel`` index maps trivially to\nqubit index.",
        "api_signature": "acquire(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/acquire.py"
    },
    {
        "api_name": "mem_slot",
        "full_api_name": "Acquire.mem_slot",
        "api_description": "The classical memory slot which will store the classified readout result.",
        "api_signature": "mem_slot(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/acquire.py"
    },
    {
        "api_name": "reg_slot",
        "full_api_name": "Acquire.reg_slot",
        "api_description": "The fast-access register slot which will store the classified readout result for\nfast-feedback computation.",
        "api_signature": "reg_slot(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/acquire.py"
    },
    {
        "api_name": "is_parameterized",
        "full_api_name": "Acquire.is_parameterized",
        "api_description": "Return True iff the instruction is parameterized.",
        "api_signature": "is_parameterized(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/acquire.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "Acquire.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/acquire.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SetFrequency.__init__",
        "api_description": "Creates a new set channel frequency instruction.\n\nArgs:\n    frequency: New frequency of the channel in Hz.\n    channel: The channel this instruction operates on.\n    name: Name of this set channel frequency instruction.",
        "api_signature": "__init__(self, frequency, channel, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/frequency.py"
    },
    {
        "api_name": "_validate",
        "full_api_name": "SetFrequency._validate",
        "api_description": "Called after initialization to validate instruction data.\n\nRaises:\n    PulseError: If the input ``channel`` is not type :class:`PulseChannel`.",
        "api_signature": "_validate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/frequency.py"
    },
    {
        "api_name": "frequency",
        "full_api_name": "SetFrequency.frequency",
        "api_description": "New frequency.",
        "api_signature": "frequency(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/frequency.py"
    },
    {
        "api_name": "channel",
        "full_api_name": "SetFrequency.channel",
        "api_description": "Return the :py:class:`~qiskit.pulse.channels.Channel` that this instruction is\nscheduled on.",
        "api_signature": "channel(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/frequency.py"
    },
    {
        "api_name": "channels",
        "full_api_name": "SetFrequency.channels",
        "api_description": "Returns the channels that this schedule uses.",
        "api_signature": "channels(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/frequency.py"
    },
    {
        "api_name": "duration",
        "full_api_name": "SetFrequency.duration",
        "api_description": "Duration of this instruction.",
        "api_signature": "duration(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/frequency.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ShiftFrequency.__init__",
        "api_description": "Creates a new shift frequency instruction.\n\nArgs:\n    frequency: Frequency shift of the channel in Hz.\n    channel: The channel this instruction operates on.\n    name: Name of this set channel frequency instruction.",
        "api_signature": "__init__(self, frequency, channel, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/frequency.py"
    },
    {
        "api_name": "_validate",
        "full_api_name": "ShiftFrequency._validate",
        "api_description": "Called after initialization to validate instruction data.\n\nRaises:\n    PulseError: If the input ``channel`` is not type :class:`PulseChannel`.",
        "api_signature": "_validate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/frequency.py"
    },
    {
        "api_name": "frequency",
        "full_api_name": "ShiftFrequency.frequency",
        "api_description": "Frequency shift from the set frequency.",
        "api_signature": "frequency(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/frequency.py"
    },
    {
        "api_name": "channel",
        "full_api_name": "ShiftFrequency.channel",
        "api_description": "Return the :py:class:`~qiskit.pulse.channels.Channel` that this instruction is\nscheduled on.",
        "api_signature": "channel(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/frequency.py"
    },
    {
        "api_name": "channels",
        "full_api_name": "ShiftFrequency.channels",
        "api_description": "Returns the channels that this schedule uses.",
        "api_signature": "channels(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/frequency.py"
    },
    {
        "api_name": "duration",
        "full_api_name": "ShiftFrequency.duration",
        "api_description": "Duration of this instruction.",
        "api_signature": "duration(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/frequency.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Reference.__init__",
        "api_description": "Create new reference.\n\nArgs:\n    name: Name of subroutine.\n    extra_keys: Optional. A set of string keys that may be necessary to\n        refer to a particular subroutine. For example, when we use\n        \"sx\" as a name to refer to the subroutine of an sx pulse,\n        this name might be used among schedules for different qubits.\n        In this example, you may specify \"q0\" in the extra keys\n        to distinguish the sx schedule for qubit 0 from others.\n        The user can use an arbitrary number of extra string keys to\n        uniquely determine the subroutine.",
        "api_signature": "__init__(self, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/reference.py"
    },
    {
        "api_name": "_validate",
        "full_api_name": "Reference._validate",
        "api_description": "Called after initialization to validate instruction data.\n\nRaises:\n    PulseError: When a key is not a string.\n    PulseError: When a key in ``ref_keys`` contains the scope delimiter.",
        "api_signature": "_validate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/reference.py"
    },
    {
        "api_name": "ref_keys",
        "full_api_name": "Reference.ref_keys",
        "api_description": "Returns unique key of the subroutine.",
        "api_signature": "ref_keys(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/reference.py"
    },
    {
        "api_name": "duration",
        "full_api_name": "Reference.duration",
        "api_description": "Duration of this instruction.",
        "api_signature": "duration(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/reference.py"
    },
    {
        "api_name": "channels",
        "full_api_name": "Reference.channels",
        "api_description": "Returns the channels that this schedule uses.",
        "api_signature": "channels(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/reference.py"
    },
    {
        "api_name": "parameters",
        "full_api_name": "Reference.parameters",
        "api_description": "Parameters which determine the instruction behavior.",
        "api_signature": "parameters(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/reference.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "Reference.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/reference.py"
    },
    {
        "api_name": "duration",
        "full_api_name": "Directive.duration",
        "api_description": "Duration of this instruction.",
        "api_signature": "duration(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/directives.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "RelativeBarrier.__init__",
        "api_description": "Create a relative barrier directive.\n\nThe barrier directive blocks instructions within the same schedule\nas the barrier on channels contained within this barrier from moving\nthrough the barrier in time.\n\nArgs:\n    channels: The channel that the barrier applies to.\n    name: Name of the directive for display purposes.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/directives.py"
    },
    {
        "api_name": "channels",
        "full_api_name": "RelativeBarrier.channels",
        "api_description": "Returns the channels that this schedule uses.",
        "api_signature": "channels(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/directives.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "RelativeBarrier.__eq__",
        "api_description": "Verify two barriers are equivalent.",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/directives.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "TimeBlockade.__init__",
        "api_description": "Create a time blockade directive.\n\nArgs:\n    duration: Length of time of the occupation in terms of dt.\n    channel: The channel that will be the occupied.\n    name: Name of the time blockade for display purposes.",
        "api_signature": "__init__(self, duration, channel, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/directives.py"
    },
    {
        "api_name": "_validate",
        "full_api_name": "TimeBlockade._validate",
        "api_description": "Called after initialization to validate instruction data.\n\nRaises:\n    PulseError: If the input ``duration`` is not integer value.",
        "api_signature": "_validate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/directives.py"
    },
    {
        "api_name": "channel",
        "full_api_name": "TimeBlockade.channel",
        "api_description": "Return the :py:class:`~qiskit.pulse.channels.Channel` that this instruction is\nscheduled on.",
        "api_signature": "channel(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/directives.py"
    },
    {
        "api_name": "channels",
        "full_api_name": "TimeBlockade.channels",
        "api_description": "Returns the channels that this schedule uses.",
        "api_signature": "channels(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/directives.py"
    },
    {
        "api_name": "duration",
        "full_api_name": "TimeBlockade.duration",
        "api_description": "Duration of this instruction.",
        "api_signature": "duration(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/directives.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Play.__init__",
        "api_description": "Create a new pulse instruction.\n\nArgs:\n    pulse: A pulse waveform description, such as\n           :py:class:`~qiskit.pulse.library.Waveform`.\n    channel: The channel to which the pulse is applied.\n    name: Name of the instruction for display purposes. Defaults to ``pulse.name``.",
        "api_signature": "__init__(self, pulse, channel, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/play.py"
    },
    {
        "api_name": "_validate",
        "full_api_name": "Play._validate",
        "api_description": "Called after initialization to validate instruction data.\n\nRaises:\n    PulseError: If pulse is not a Pulse type.\n    PulseError: If the input ``channel`` is not type :class:`PulseChannel`.",
        "api_signature": "_validate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/play.py"
    },
    {
        "api_name": "pulse",
        "full_api_name": "Play.pulse",
        "api_description": "A description of the samples that will be played.",
        "api_signature": "pulse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/play.py"
    },
    {
        "api_name": "channel",
        "full_api_name": "Play.channel",
        "api_description": "Return the :py:class:`~qiskit.pulse.channels.Channel` that this instruction is\nscheduled on.",
        "api_signature": "channel(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/play.py"
    },
    {
        "api_name": "channels",
        "full_api_name": "Play.channels",
        "api_description": "Returns the channels that this schedule uses.",
        "api_signature": "channels(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/play.py"
    },
    {
        "api_name": "duration",
        "full_api_name": "Play.duration",
        "api_description": "Duration of this instruction.",
        "api_signature": "duration(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/play.py"
    },
    {
        "api_name": "parameters",
        "full_api_name": "Play.parameters",
        "api_description": "Parameters which determine the instruction behavior.",
        "api_signature": "parameters(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/play.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ShiftPhase.__init__",
        "api_description": "Instantiate a shift phase instruction, increasing the output signal phase on ``channel``\nby ``phase`` [radians].\n\nArgs:\n    phase: The rotation angle in radians.\n    channel: The channel this instruction operates on.\n    name: Display name for this instruction.",
        "api_signature": "__init__(self, phase, channel, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/phase.py"
    },
    {
        "api_name": "_validate",
        "full_api_name": "ShiftPhase._validate",
        "api_description": "Called after initialization to validate instruction data.\n\nRaises:\n    PulseError: If the input ``channel`` is not type :class:`PulseChannel`.",
        "api_signature": "_validate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/phase.py"
    },
    {
        "api_name": "phase",
        "full_api_name": "ShiftPhase.phase",
        "api_description": "Return the rotation angle enacted by this instruction in radians.",
        "api_signature": "phase(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/phase.py"
    },
    {
        "api_name": "channel",
        "full_api_name": "ShiftPhase.channel",
        "api_description": "Return the :py:class:`~qiskit.pulse.channels.Channel` that this instruction is\nscheduled on.",
        "api_signature": "channel(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/phase.py"
    },
    {
        "api_name": "channels",
        "full_api_name": "ShiftPhase.channels",
        "api_description": "Returns the channels that this schedule uses.",
        "api_signature": "channels(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/phase.py"
    },
    {
        "api_name": "duration",
        "full_api_name": "ShiftPhase.duration",
        "api_description": "Duration of this instruction.",
        "api_signature": "duration(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/phase.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SetPhase.__init__",
        "api_description": "Instantiate a set phase instruction, setting the output signal phase on ``channel``\nto ``phase`` [radians].\n\nArgs:\n    phase: The rotation angle in radians.\n    channel: The channel this instruction operates on.\n    name: Display name for this instruction.",
        "api_signature": "__init__(self, phase, channel, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/phase.py"
    },
    {
        "api_name": "_validate",
        "full_api_name": "SetPhase._validate",
        "api_description": "Called after initialization to validate instruction data.\n\nRaises:\n    PulseError: If the input ``channel`` is not type :class:`PulseChannel`.",
        "api_signature": "_validate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/phase.py"
    },
    {
        "api_name": "phase",
        "full_api_name": "SetPhase.phase",
        "api_description": "Return the rotation angle enacted by this instruction in radians.",
        "api_signature": "phase(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/phase.py"
    },
    {
        "api_name": "channel",
        "full_api_name": "SetPhase.channel",
        "api_description": "Return the :py:class:`~qiskit.pulse.channels.Channel` that this instruction is\nscheduled on.",
        "api_signature": "channel(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/phase.py"
    },
    {
        "api_name": "channels",
        "full_api_name": "SetPhase.channels",
        "api_description": "Returns the channels that this schedule uses.",
        "api_signature": "channels(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/phase.py"
    },
    {
        "api_name": "duration",
        "full_api_name": "SetPhase.duration",
        "api_description": "Duration of this instruction.",
        "api_signature": "duration(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/phase.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Snapshot.__init__",
        "api_description": "Create new snapshot.\n\nArgs:\n    label: Snapshot label which is used to identify the snapshot in the output.\n    snapshot_type: Type of snapshot, e.g., \u201cstate\u201d (take a snapshot of the quantum state).\n                   The types of snapshots offered are defined by the simulator used.\n    name: Snapshot name which defaults to ``label``. This parameter is only for display\n          purposes and is not taken into account during comparison.",
        "api_signature": "__init__(self, label, snapshot_type, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/snapshot.py"
    },
    {
        "api_name": "_validate",
        "full_api_name": "Snapshot._validate",
        "api_description": "Called after initialization to validate instruction data.\n\nRaises:\n    PulseError: If snapshot label is invalid.",
        "api_signature": "_validate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/snapshot.py"
    },
    {
        "api_name": "label",
        "full_api_name": "Snapshot.label",
        "api_description": "Label of snapshot.",
        "api_signature": "label(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/snapshot.py"
    },
    {
        "api_name": "type",
        "full_api_name": "Snapshot.type",
        "api_description": "Type of snapshot.",
        "api_signature": "type(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/snapshot.py"
    },
    {
        "api_name": "channel",
        "full_api_name": "Snapshot.channel",
        "api_description": "Return the :py:class:`~qiskit.pulse.channels.Channel` that this instruction is\nscheduled on; trivially, a ``SnapshotChannel``.",
        "api_signature": "channel(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/snapshot.py"
    },
    {
        "api_name": "channels",
        "full_api_name": "Snapshot.channels",
        "api_description": "Returns the channels that this schedule uses.",
        "api_signature": "channels(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/snapshot.py"
    },
    {
        "api_name": "duration",
        "full_api_name": "Snapshot.duration",
        "api_description": "Duration of this instruction.",
        "api_signature": "duration(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/snapshot.py"
    },
    {
        "api_name": "is_parameterized",
        "full_api_name": "Snapshot.is_parameterized",
        "api_description": "Return True iff the instruction is parameterized.",
        "api_signature": "is_parameterized(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/snapshot.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Call.__init__",
        "api_description": "Define new subroutine.\n\n.. note:: Inline subroutine is mutable. This requires special care for modification.\n\nArgs:\n    subroutine (Union[Schedule, ScheduleBlock]): A program subroutine to be referred to.\n    value_dict: Mapping of parameter object to assigned value.\n    name: Unique ID of this subroutine. If not provided, this is generated based on\n        the subroutine name.\n\nRaises:\n    PulseError: If subroutine is not valid data format.",
        "api_signature": "__init__(self, subroutine, value_dict, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/call.py"
    },
    {
        "api_name": "duration",
        "full_api_name": "Call.duration",
        "api_description": "Duration of this instruction.",
        "api_signature": "duration(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/call.py"
    },
    {
        "api_name": "channels",
        "full_api_name": "Call.channels",
        "api_description": "Returns the channels that this schedule uses.",
        "api_signature": "channels(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/call.py"
    },
    {
        "api_name": "subroutine",
        "full_api_name": "Call.subroutine",
        "api_description": "Return attached subroutine.\n\nReturns:\n    program (Union[Schedule, ScheduleBlock]): The program referenced by the call.",
        "api_signature": "subroutine(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/call.py"
    },
    {
        "api_name": "assigned_subroutine",
        "full_api_name": "Call.assigned_subroutine",
        "api_description": "Returns this subroutine with the parameters assigned.\n\n.. note:: This function may be often called internally for class equality check\n    despite its overhead of parameter assignment.\n    The subroutine with parameter assigned is cached based on ``.argument`` hash.\n    Once this argument is updated, new assigned instance will be returned.\n    Note that this update is not mutable operation.\n\nReturns:\n    program (Union[Schedule, ScheduleBlock]): Attached program.",
        "api_signature": "assigned_subroutine(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/call.py"
    },
    {
        "api_name": "parameters",
        "full_api_name": "Call.parameters",
        "api_description": "Unassigned parameters which determine the instruction behavior.",
        "api_signature": "parameters(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/call.py"
    },
    {
        "api_name": "arguments",
        "full_api_name": "Call.arguments",
        "api_description": "Parameters dictionary to be assigned to subroutine.",
        "api_signature": "arguments(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/call.py"
    },
    {
        "api_name": "arguments",
        "full_api_name": "Call.arguments",
        "api_description": "Set new arguments.\n\nArgs:\n    new_arguments: Dictionary of new parameter value mapping to update.\n\nRaises:\n    PulseError: When new arguments doesn't match with existing arguments.",
        "api_signature": "arguments(self, new_arguments)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/call.py"
    },
    {
        "api_name": "_get_arg_hash",
        "full_api_name": "Call._get_arg_hash",
        "api_description": "A helper function to generate hash of parameters.",
        "api_signature": "_get_arg_hash(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/call.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "Call.__eq__",
        "api_description": "Check if this instruction is equal to the `other` instruction.\n\nInstructions are equal if they share the same type, operands, and channels.",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/call.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "Call.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/call.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Instruction.__init__",
        "api_description": "Instruction initializer.\n\nArgs:\n    operands: The argument list.\n    name: Optional display name for this instruction.",
        "api_signature": "__init__(self, operands, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/instruction.py"
    },
    {
        "api_name": "_validate",
        "full_api_name": "Instruction._validate",
        "api_description": "Called after initialization to validate instruction data.\n\nRaises:\n    PulseError: If the input ``channels`` are not all of type :class:`Channel`.",
        "api_signature": "_validate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/instruction.py"
    },
    {
        "api_name": "name",
        "full_api_name": "Instruction.name",
        "api_description": "Name of this instruction.",
        "api_signature": "name(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/instruction.py"
    },
    {
        "api_name": "id",
        "full_api_name": "Instruction.id",
        "api_description": "Unique identifier for this instruction.",
        "api_signature": "id(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/instruction.py"
    },
    {
        "api_name": "operands",
        "full_api_name": "Instruction.operands",
        "api_description": "Return instruction operands.",
        "api_signature": "operands(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/instruction.py"
    },
    {
        "api_name": "channels",
        "full_api_name": "Instruction.channels",
        "api_description": "Returns the channels that this schedule uses.",
        "api_signature": "channels(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/instruction.py"
    },
    {
        "api_name": "start_time",
        "full_api_name": "Instruction.start_time",
        "api_description": "Relative begin time of this instruction.",
        "api_signature": "start_time(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/instruction.py"
    },
    {
        "api_name": "stop_time",
        "full_api_name": "Instruction.stop_time",
        "api_description": "Relative end time of this instruction.",
        "api_signature": "stop_time(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/instruction.py"
    },
    {
        "api_name": "duration",
        "full_api_name": "Instruction.duration",
        "api_description": "Duration of this instruction.",
        "api_signature": "duration(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/instruction.py"
    },
    {
        "api_name": "_children",
        "full_api_name": "Instruction._children",
        "api_description": "Instruction has no child nodes.",
        "api_signature": "_children(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/instruction.py"
    },
    {
        "api_name": "instructions",
        "full_api_name": "Instruction.instructions",
        "api_description": "Iterable for getting instructions from Schedule tree.",
        "api_signature": "instructions(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/instruction.py"
    },
    {
        "api_name": "ch_duration",
        "full_api_name": "Instruction.ch_duration",
        "api_description": "Return duration of the supplied channels in this Instruction.\n\nArgs:\n    *channels: Supplied channels",
        "api_signature": "ch_duration(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/instruction.py"
    },
    {
        "api_name": "ch_start_time",
        "full_api_name": "Instruction.ch_start_time",
        "api_description": "Return minimum start time for supplied channels.\n\nArgs:\n    *channels: Supplied channels",
        "api_signature": "ch_start_time(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/instruction.py"
    },
    {
        "api_name": "ch_stop_time",
        "full_api_name": "Instruction.ch_stop_time",
        "api_description": "Return maximum start time for supplied channels.\n\nArgs:\n    *channels: Supplied channels",
        "api_signature": "ch_stop_time(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/instruction.py"
    },
    {
        "api_name": "_instructions",
        "full_api_name": "Instruction._instructions",
        "api_description": "Iterable for flattening Schedule tree.\n\nArgs:\n    time: Shifted time of this node due to parent\n\nYields:\n    Tuple[int, Union['Schedule, 'Instruction']]: Tuple of the form\n        (start_time, instruction).",
        "api_signature": "_instructions(self, time)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/instruction.py"
    },
    {
        "api_name": "shift",
        "full_api_name": "Instruction.shift",
        "api_description": "Return a new schedule shifted forward by `time`.\n\nArgs:\n    time: Time to shift by\n    name: Name of the new schedule. Defaults to name of self\n\nReturns:\n    Schedule: The shifted schedule.",
        "api_signature": "shift(self, time, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/instruction.py"
    },
    {
        "api_name": "insert",
        "full_api_name": "Instruction.insert",
        "api_description": "Return a new :class:`~qiskit.pulse.Schedule` with ``schedule`` inserted within\n``self`` at ``start_time``.\n\nArgs:\n    start_time: Time to insert the schedule schedule\n    schedule (Union['Schedule', 'Instruction']): Schedule or instruction to insert\n    name: Name of the new schedule. Defaults to name of self\n\nReturns:\n    Schedule: A new schedule with ``schedule`` inserted with this instruction at t=0.",
        "api_signature": "insert(self, start_time, schedule, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/instruction.py"
    },
    {
        "api_name": "append",
        "full_api_name": "Instruction.append",
        "api_description": "Return a new :class:`~qiskit.pulse.Schedule` with ``schedule`` inserted at the\nmaximum time over all channels shared between ``self`` and ``schedule``.\n\nArgs:\n    schedule (Union['Schedule', 'Instruction']): Schedule or instruction to be appended\n    name: Name of the new schedule. Defaults to name of self\n\nReturns:\n    Schedule: A new schedule with ``schedule`` a this instruction at t=0.",
        "api_signature": "append(self, schedule, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/instruction.py"
    },
    {
        "api_name": "parameters",
        "full_api_name": "Instruction.parameters",
        "api_description": "Parameters which determine the instruction behavior.",
        "api_signature": "parameters(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/instruction.py"
    },
    {
        "api_name": "_get_parameters_recursive",
        "full_api_name": "Instruction._get_parameters_recursive",
        "api_description": "",
        "api_signature": "_get_parameters_recursive(obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/instruction.py"
    },
    {
        "api_name": "is_parameterized",
        "full_api_name": "Instruction.is_parameterized",
        "api_description": "Return True iff the instruction is parameterized.",
        "api_signature": "is_parameterized(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/instruction.py"
    },
    {
        "api_name": "draw",
        "full_api_name": "Instruction.draw",
        "api_description": "Plot the instruction.\n\nArgs:\n    dt: Time interval of samples\n    style (Optional[SchedStyle]): A style sheet to configure plot appearance\n    filename: Name required to save pulse image\n    interp_method: A function for interpolation\n    scale: Relative visual scaling of waveform amplitudes\n    plot_all: Plot empty channels\n    plot_range: A tuple of time range to plot\n    interactive: When set true show the circuit in a new window\n        (this depends on the matplotlib backend being used supporting this)\n    table: Draw event table for supported instructions\n    label: Label individual instructions\n    framechange: Add framechange indicators\n    channels: A list of channel names to plot\n\nReturns:\n    matplotlib.figure: A matplotlib figure object of the pulse schedule",
        "api_signature": "draw(self, dt, style, filename, interp_method, scale, plot_all, plot_range, interactive, table, label, framechange, channels)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/instruction.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "Instruction.__eq__",
        "api_description": "Check if this Instruction is equal to the `other` instruction.\n\nEquality is determined by the instruction sharing the same operands and channels.",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/instruction.py"
    },
    {
        "api_name": "__hash__",
        "full_api_name": "Instruction.__hash__",
        "api_description": "",
        "api_signature": "__hash__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/instruction.py"
    },
    {
        "api_name": "__add__",
        "full_api_name": "Instruction.__add__",
        "api_description": "Return a new schedule with `other` inserted within `self` at `start_time`.\n\nArgs:\n    other (Union['Schedule', 'Instruction']): Schedule or instruction to be appended\n\nReturns:\n    Schedule: A new schedule with ``schedule`` appended after this instruction at t=0.",
        "api_signature": "__add__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/instruction.py"
    },
    {
        "api_name": "__or__",
        "full_api_name": "Instruction.__or__",
        "api_description": "Return a new schedule which is the union of `self` and `other`.\n\nArgs:\n    other (Union['Schedule', 'Instruction']): Schedule or instruction to union with\n\nReturns:\n    Schedule: A new schedule with ``schedule`` inserted with this instruction at t=0",
        "api_signature": "__or__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/instruction.py"
    },
    {
        "api_name": "__lshift__",
        "full_api_name": "Instruction.__lshift__",
        "api_description": "Return a new schedule which is shifted forward by `time`.\n\nReturns:\n    Schedule: The shifted schedule",
        "api_signature": "__lshift__(self, time)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/instruction.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "Instruction.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/instruction.py"
    },
    {
        "api_name": "constant",
        "full_api_name": "constant",
        "api_description": "Continuous constant pulse.\n\nArgs:\n    times: Times to output pulse for.\n    amp: Complex pulse amplitude.",
        "api_signature": "constant(times, amp)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/continuous.py"
    },
    {
        "api_name": "zero",
        "full_api_name": "zero",
        "api_description": "Continuous zero pulse.\n\nArgs:\n    times: Times to output pulse for.",
        "api_signature": "zero(times)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/continuous.py"
    },
    {
        "api_name": "square",
        "full_api_name": "square",
        "api_description": "Continuous square wave.\n\nArgs:\n    times: Times to output wave for.\n    amp: Pulse amplitude. Wave range is [-amp, amp].\n    freq: Pulse frequency. units of 1/dt.\n    phase: Pulse phase.",
        "api_signature": "square(times, amp, freq, phase)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/continuous.py"
    },
    {
        "api_name": "sawtooth",
        "full_api_name": "sawtooth",
        "api_description": "Continuous sawtooth wave.\n\nArgs:\n    times: Times to output wave for.\n    amp: Pulse amplitude. Wave range is [-amp, amp].\n    freq: Pulse frequency. units of 1/dt.\n    phase: Pulse phase.",
        "api_signature": "sawtooth(times, amp, freq, phase)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/continuous.py"
    },
    {
        "api_name": "triangle",
        "full_api_name": "triangle",
        "api_description": "Continuous triangle wave.\n\nArgs:\n    times: Times to output wave for.\n    amp: Pulse amplitude. Wave range is [-amp, amp].\n    freq: Pulse frequency. units of 1/dt.\n    phase: Pulse phase.",
        "api_signature": "triangle(times, amp, freq, phase)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/continuous.py"
    },
    {
        "api_name": "cos",
        "full_api_name": "cos",
        "api_description": "Continuous cosine wave.\n\nArgs:\n    times: Times to output wave for.\n    amp: Pulse amplitude.\n    freq: Pulse frequency, units of 1/dt.\n    phase: Pulse phase.",
        "api_signature": "cos(times, amp, freq, phase)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/continuous.py"
    },
    {
        "api_name": "sin",
        "full_api_name": "sin",
        "api_description": "Continuous cosine wave.\n\nArgs:\n    times: Times to output wave for.\n    amp: Pulse amplitude.\n    freq: Pulse frequency, units of 1/dt.\n    phase: Pulse phase.",
        "api_signature": "sin(times, amp, freq, phase)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/continuous.py"
    },
    {
        "api_name": "_fix_gaussian_width",
        "full_api_name": "_fix_gaussian_width",
        "api_description": "Enforce that the supplied gaussian pulse is zeroed at a specific width.\n\nThis is achieved by subtracting $\\Omega_g(center \\pm zeroed_width/2)$ from all samples.\n\namp: Pulse amplitude at `center`.\ncenter: Center (mean) of pulse.\nsigma: Standard deviation of pulse.\nzeroed_width: Subtract baseline from gaussian pulses to make sure\n    $\\Omega_g(center \\pm zeroed_width/2)=0$ is satisfied. This is used to avoid\n    large discontinuities at the start of a gaussian pulse. If unsupplied,\n    defaults to $2*(center + 1)$ such that $\\Omega_g(-1)=0$ and $\\Omega_g(2*(center + 1))=0$.\nrescale_amp: If True the pulse will be rescaled so that $\\Omega_g(center)=amp$.\nret_scale_factor: Return amplitude scale factor.",
        "api_signature": "_fix_gaussian_width(gaussian_samples, amp, center, sigma, zeroed_width, rescale_amp, ret_scale_factor)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/continuous.py"
    },
    {
        "api_name": "gaussian",
        "full_api_name": "gaussian",
        "api_description": "Continuous unnormalized gaussian pulse.\n\nIntegrated area under curve is $\\Omega_g(amp, sigma) = amp \\times np.sqrt(2\\pi \\sigma^2)$\n\nArgs:\n    times: Times to output pulse for.\n    amp: Pulse amplitude at `center`. If `zeroed_width` is set pulse amplitude at center\n        will be $amp-\\Omega_g(center \\pm zeroed_width/2)$ unless `rescale_amp` is set,\n        in which case all samples will be rescaled such that the center\n        amplitude will be `amp`.\n    center: Center (mean) of pulse.\n    sigma: Width (standard deviation) of pulse.\n    zeroed_width: Subtract baseline from gaussian pulses to make sure\n        $\\Omega_g(center \\pm zeroed_width/2)=0$ is satisfied. This is used to avoid\n        large discontinuities at the start of a gaussian pulse.\n    rescale_amp: If `zeroed_width` is not `None` and `rescale_amp=True` the pulse will\n        be rescaled so that $\\Omega_g(center)=amp$.\n    ret_x: Return centered and standard deviation normalized pulse location.\n           $x=(times-center)/sigma.",
        "api_signature": "gaussian(times, amp, center, sigma, zeroed_width, rescale_amp, ret_x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/continuous.py"
    },
    {
        "api_name": "gaussian_deriv",
        "full_api_name": "gaussian_deriv",
        "api_description": "Continuous unnormalized gaussian derivative pulse.\n\nArgs:\n    times: Times to output pulse for.\n    amp: Pulse amplitude at `center`.\n    center: Center (mean) of pulse.\n    sigma: Width (standard deviation) of pulse.\n    ret_gaussian: Return gaussian with which derivative was taken with.\n    zeroed_width: Subtract baseline of pulse to make sure\n        $\\Omega_g(center \\pm zeroed_width/2)=0$ is satisfied. This is used to avoid\n        large discontinuities at the start of a pulse.\n    rescale_amp: If `zeroed_width` is not `None` and `rescale_amp=True` the pulse will\n        be rescaled so that $\\Omega_g(center)=amp$.",
        "api_signature": "gaussian_deriv(times, amp, center, sigma, ret_gaussian, zeroed_width, rescale_amp)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/continuous.py"
    },
    {
        "api_name": "_fix_sech_width",
        "full_api_name": "_fix_sech_width",
        "api_description": "Enforce that the supplied sech pulse is zeroed at a specific width.\n\nThis is achieved by subtracting $\\Omega_g(center \\pm zeroed_width/2)$ from all samples.\n\namp: Pulse amplitude at `center`.\ncenter: Center (mean) of pulse.\nsigma: Standard deviation of pulse.\nzeroed_width: Subtract baseline from sech pulses to make sure\n    $\\Omega_g(center \\pm zeroed_width/2)=0$ is satisfied. This is used to avoid\n    large discontinuities at the start of a sech pulse. If unsupplied,\n    defaults to $2*(center + 1)$ such that $\\Omega_g(-1)=0$ and $\\Omega_g(2*(center + 1))=0$.\nrescale_amp: If True the pulse will be rescaled so that $\\Omega_g(center)=amp$.\nret_scale_factor: Return amplitude scale factor.",
        "api_signature": "_fix_sech_width(sech_samples, amp, center, sigma, zeroed_width, rescale_amp, ret_scale_factor)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/continuous.py"
    },
    {
        "api_name": "sech_fn",
        "full_api_name": "sech_fn",
        "api_description": "Hyperbolic secant function",
        "api_signature": "sech_fn(x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/continuous.py"
    },
    {
        "api_name": "sech",
        "full_api_name": "sech",
        "api_description": "Continuous unnormalized sech pulse.\n\nArgs:\n    times: Times to output pulse for.\n    amp: Pulse amplitude at `center`.\n    center: Center (mean) of pulse.\n    sigma: Width (standard deviation) of pulse.\n    zeroed_width: Subtract baseline from pulse to make sure\n        $\\Omega_g(center \\pm zeroed_width/2)=0$ is satisfied. This is used to avoid\n        large discontinuities at the start and end of the pulse.\n    rescale_amp: If `zeroed_width` is not `None` and `rescale_amp=True` the pulse will\n        be rescaled so that $\\Omega_g(center)=amp$.\n    ret_x: Return centered and standard deviation normalized pulse location.\n        $x=(times-center)/sigma$.",
        "api_signature": "sech(times, amp, center, sigma, zeroed_width, rescale_amp, ret_x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/continuous.py"
    },
    {
        "api_name": "sech_deriv",
        "full_api_name": "sech_deriv",
        "api_description": "Continuous unnormalized sech derivative pulse.\n\nArgs:\n    times: Times to output pulse for.\n    amp: Pulse amplitude at `center`.\n    center: Center (mean) of pulse.\n    sigma: Width (standard deviation) of pulse.\n    ret_sech: Return sech with which derivative was taken with.",
        "api_signature": "sech_deriv(times, amp, center, sigma, ret_sech)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/continuous.py"
    },
    {
        "api_name": "gaussian_square",
        "full_api_name": "gaussian_square",
        "api_description": "Continuous gaussian square pulse.\n\nArgs:\n    times: Times to output pulse for.\n    amp: Pulse amplitude.\n    center: Center of the square pulse component.\n    square_width: Width of the square pulse component.\n    sigma: Standard deviation of Gaussian rise/fall portion of the pulse.\n    zeroed_width: Subtract baseline of gaussian square pulse\n        to enforce $\\OmegaSquare(center \\pm zeroed_width/2)=0$.\n\nRaises:\n    PulseError: if zeroed_width is not compatible with square_width.",
        "api_signature": "gaussian_square(times, amp, center, square_width, sigma, zeroed_width)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/continuous.py"
    },
    {
        "api_name": "drag",
        "full_api_name": "drag",
        "api_description": "Continuous Y-only correction DRAG pulse for standard nonlinear oscillator (SNO) [1].\n\n[1] Gambetta, J. M., Motzoi, F., Merkel, S. T. & Wilhelm, F. K.\n    Analytic control methods for high-fidelity unitary operations\n    in a weakly nonlinear oscillator. Phys. Rev. A 83, 012308 (2011).\n\nArgs:\n    times: Times to output pulse for.\n    amp: Pulse amplitude at `center`.\n    center: Center (mean) of pulse.\n    sigma: Width (standard deviation) of pulse.\n    beta: Y correction amplitude. For the SNO this is $\\beta=-\\frac{\\lambda_1^2}{4\\Delta_2}$.\n        Where $\\lambds_1$ is the relative coupling strength between the first excited and second\n        excited states and $\\Delta_2$ is the detuning between the respective excited states.\n    zeroed_width: Subtract baseline of drag pulse to make sure\n        $\\Omega_g(center \\pm zeroed_width/2)=0$ is satisfied. This is used to avoid\n        large discontinuities at the start of a drag pulse.\n    rescale_amp: If `zeroed_width` is not `None` and `rescale_amp=True` the pulse will\n        be rescaled so that $\\Omega_g(center)=amp$.",
        "api_signature": "drag(times, amp, center, sigma, beta, zeroed_width, rescale_amp)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/continuous.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Pulse.__init__",
        "api_description": "Abstract base class for pulses\nArgs:\n    duration: Duration of the pulse\n    name: Optional name for the pulse\n    limit_amplitude: If ``True``, then limit the amplitude of the waveform to 1.\n                     The default value of ``None`` causes the flag value to be\n                     derived from :py:attr:`~limit_amplitude` which is ``True``\n                     by default but may be set by the user to disable amplitude\n                     checks globally.",
        "api_signature": "__init__(self, duration, name, limit_amplitude)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/pulse.py"
    },
    {
        "api_name": "id",
        "full_api_name": "Pulse.id",
        "api_description": "Unique identifier for this pulse.",
        "api_signature": "id(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/pulse.py"
    },
    {
        "api_name": "parameters",
        "full_api_name": "Pulse.parameters",
        "api_description": "Return a dictionary containing the pulse's parameters.",
        "api_signature": "parameters(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/pulse.py"
    },
    {
        "api_name": "is_parameterized",
        "full_api_name": "Pulse.is_parameterized",
        "api_description": "Return True iff the instruction is parameterized.",
        "api_signature": "is_parameterized(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/pulse.py"
    },
    {
        "api_name": "draw",
        "full_api_name": "Pulse.draw",
        "api_description": "Plot the interpolated envelope of pulse.\n\nArgs:\n    style: Stylesheet options. This can be dictionary or preset stylesheet classes. See\n        :py:class:`~qiskit.visualization.pulse_v2.stylesheets.IQXStandard`,\n        :py:class:`~qiskit.visualization.pulse_v2.stylesheets.IQXSimple`, and\n        :py:class:`~qiskit.visualization.pulse_v2.stylesheets.IQXDebugging` for details of\n        preset stylesheets.\n    backend (Optional[BaseBackend]): Backend object to play the input pulse program.\n        If provided, the plotter may use to make the visualization hardware aware.\n    time_range: Set horizontal axis limit. Tuple ``(tmin, tmax)``.\n    time_unit: The unit of specified time range either ``dt`` or ``ns``.\n        The unit of ``ns`` is available only when ``backend`` object is provided.\n    show_waveform_info: Show waveform annotations, i.e. name, of waveforms.\n        Set ``True`` to show additional information about waveforms.\n    plotter: Name of plotter API to generate an output image.\n        One of following APIs should be specified::\n\n            mpl2d: Matplotlib API for 2D image generation.\n                Matplotlib API to generate 2D image. Charts are placed along y axis with\n                vertical offset. This API takes matplotlib.axes.Axes as `axis` input.\n\n        `axis` and `style` kwargs may depend on the plotter.\n    axis: Arbitrary object passed to the plotter. If this object is provided,\n        the plotters use a given ``axis`` instead of internally initializing\n        a figure object. This object format depends on the plotter.\n        See plotter argument for details.\n\nReturns:\n    Visualization output data.\n    The returned data type depends on the ``plotter``.\n    If matplotlib family is specified, this will be a ``matplotlib.pyplot.Figure`` data.",
        "api_signature": "draw(self, style, backend, time_range, time_unit, show_waveform_info, plotter, axis)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/pulse.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "Pulse.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/pulse.py"
    },
    {
        "api_name": "__hash__",
        "full_api_name": "Pulse.__hash__",
        "api_description": "",
        "api_signature": "__hash__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/pulse.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "Pulse.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/pulse.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ParametricPulse.__init__",
        "api_description": "Create a parametric pulse and validate the input parameters.\n\nArgs:\n    duration: Pulse length in terms of the sampling period `dt`.\n    name: Display name for this pulse envelope.\n    limit_amplitude: If ``True``, then limit the amplitude of the\n                     waveform to 1. The default is ``True`` and the\n                     amplitude is constrained to 1.",
        "api_signature": "__init__(self, duration, name, limit_amplitude)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/parametric_pulses.py"
    },
    {
        "api_name": "get_waveform",
        "full_api_name": "ParametricPulse.get_waveform",
        "api_description": "Return a Waveform with samples filled according to the formula that the pulse\nrepresents and the parameter values it contains.",
        "api_signature": "get_waveform(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/parametric_pulses.py"
    },
    {
        "api_name": "validate_parameters",
        "full_api_name": "ParametricPulse.validate_parameters",
        "api_description": "Validate parameters.\n\nRaises:\n    PulseError: If the parameters passed are not valid.",
        "api_signature": "validate_parameters(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/parametric_pulses.py"
    },
    {
        "api_name": "is_parameterized",
        "full_api_name": "ParametricPulse.is_parameterized",
        "api_description": "Return True iff the instruction is parameterized.",
        "api_signature": "is_parameterized(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/parametric_pulses.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "ParametricPulse.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/parametric_pulses.py"
    },
    {
        "api_name": "__hash__",
        "full_api_name": "ParametricPulse.__hash__",
        "api_description": "",
        "api_signature": "__hash__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/parametric_pulses.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Gaussian.__init__",
        "api_description": "Initialize the gaussian pulse.\n\nArgs:\n    duration: Pulse length in terms of the sampling period `dt`.\n    amp: The amplitude of the Gaussian envelope.\n    sigma: A measure of how wide or narrow the Gaussian peak is; described mathematically\n           in the class docstring.\n    name: Display name for this pulse envelope.\n    limit_amplitude: If ``True``, then limit the amplitude of the\n                     waveform to 1. The default is ``True`` and the\n                     amplitude is constrained to 1.",
        "api_signature": "__init__(self, duration, amp, sigma, name, limit_amplitude)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/parametric_pulses.py"
    },
    {
        "api_name": "amp",
        "full_api_name": "Gaussian.amp",
        "api_description": "The Gaussian amplitude.",
        "api_signature": "amp(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/parametric_pulses.py"
    },
    {
        "api_name": "sigma",
        "full_api_name": "Gaussian.sigma",
        "api_description": "The Gaussian standard deviation of the pulse width.",
        "api_signature": "sigma(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/parametric_pulses.py"
    },
    {
        "api_name": "get_waveform",
        "full_api_name": "Gaussian.get_waveform",
        "api_description": "",
        "api_signature": "get_waveform(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/parametric_pulses.py"
    },
    {
        "api_name": "validate_parameters",
        "full_api_name": "Gaussian.validate_parameters",
        "api_description": "",
        "api_signature": "validate_parameters(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/parametric_pulses.py"
    },
    {
        "api_name": "parameters",
        "full_api_name": "Gaussian.parameters",
        "api_description": "",
        "api_signature": "parameters(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/parametric_pulses.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "Gaussian.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/parametric_pulses.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "GaussianSquare.__init__",
        "api_description": "Initialize the gaussian square pulse.\n\nArgs:\n    duration: Pulse length in terms of the sampling period `dt`.\n    amp: The amplitude of the Gaussian and of the square pulse.\n    sigma: A measure of how wide or narrow the Gaussian risefall is; see the class\n           docstring for more details.\n    width: The duration of the embedded square pulse.\n    risefall_sigma_ratio: The ratio of each risefall duration to sigma.\n    name: Display name for this pulse envelope.\n    limit_amplitude: If ``True``, then limit the amplitude of the\n                     waveform to 1. The default is ``True`` and the\n                     amplitude is constrained to 1.\n\nRaises:\n    PulseError: If the parameters passed are not valid.",
        "api_signature": "__init__(self, duration, amp, sigma, width, risefall_sigma_ratio, name, limit_amplitude)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/parametric_pulses.py"
    },
    {
        "api_name": "amp",
        "full_api_name": "GaussianSquare.amp",
        "api_description": "The Gaussian amplitude.",
        "api_signature": "amp(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/parametric_pulses.py"
    },
    {
        "api_name": "sigma",
        "full_api_name": "GaussianSquare.sigma",
        "api_description": "The Gaussian standard deviation of the pulse width.",
        "api_signature": "sigma(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/parametric_pulses.py"
    },
    {
        "api_name": "risefall_sigma_ratio",
        "full_api_name": "GaussianSquare.risefall_sigma_ratio",
        "api_description": "The duration of each risefall in terms of sigma.",
        "api_signature": "risefall_sigma_ratio(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/parametric_pulses.py"
    },
    {
        "api_name": "width",
        "full_api_name": "GaussianSquare.width",
        "api_description": "The width of the square portion of the pulse.",
        "api_signature": "width(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/parametric_pulses.py"
    },
    {
        "api_name": "get_waveform",
        "full_api_name": "GaussianSquare.get_waveform",
        "api_description": "",
        "api_signature": "get_waveform(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/parametric_pulses.py"
    },
    {
        "api_name": "validate_parameters",
        "full_api_name": "GaussianSquare.validate_parameters",
        "api_description": "",
        "api_signature": "validate_parameters(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/parametric_pulses.py"
    },
    {
        "api_name": "parameters",
        "full_api_name": "GaussianSquare.parameters",
        "api_description": "",
        "api_signature": "parameters(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/parametric_pulses.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "GaussianSquare.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/parametric_pulses.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Drag.__init__",
        "api_description": "Initialize the drag pulse.\n\nArgs:\n    duration: Pulse length in terms of the sampling period `dt`.\n    amp: The amplitude of the Drag envelope.\n    sigma: A measure of how wide or narrow the Gaussian peak is; described mathematically\n           in the class docstring.\n    beta: The correction amplitude.\n    name: Display name for this pulse envelope.\n    limit_amplitude: If ``True``, then limit the amplitude of the\n                     waveform to 1. The default is ``True`` and the\n                     amplitude is constrained to 1.",
        "api_signature": "__init__(self, duration, amp, sigma, beta, name, limit_amplitude)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/parametric_pulses.py"
    },
    {
        "api_name": "amp",
        "full_api_name": "Drag.amp",
        "api_description": "The Gaussian amplitude.",
        "api_signature": "amp(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/parametric_pulses.py"
    },
    {
        "api_name": "sigma",
        "full_api_name": "Drag.sigma",
        "api_description": "The Gaussian standard deviation of the pulse width.",
        "api_signature": "sigma(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/parametric_pulses.py"
    },
    {
        "api_name": "beta",
        "full_api_name": "Drag.beta",
        "api_description": "The weighing factor for the Gaussian derivative component of the waveform.",
        "api_signature": "beta(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/parametric_pulses.py"
    },
    {
        "api_name": "get_waveform",
        "full_api_name": "Drag.get_waveform",
        "api_description": "",
        "api_signature": "get_waveform(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/parametric_pulses.py"
    },
    {
        "api_name": "validate_parameters",
        "full_api_name": "Drag.validate_parameters",
        "api_description": "",
        "api_signature": "validate_parameters(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/parametric_pulses.py"
    },
    {
        "api_name": "parameters",
        "full_api_name": "Drag.parameters",
        "api_description": "",
        "api_signature": "parameters(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/parametric_pulses.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "Drag.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/parametric_pulses.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Constant.__init__",
        "api_description": "Initialize the constant-valued pulse.\n\nArgs:\n    duration: Pulse length in terms of the sampling period `dt`.\n    amp: The amplitude of the constant square pulse.\n    name: Display name for this pulse envelope.\n    limit_amplitude: If ``True``, then limit the amplitude of the\n                     waveform to 1. The default is ``True`` and the\n                     amplitude is constrained to 1.",
        "api_signature": "__init__(self, duration, amp, name, limit_amplitude)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/parametric_pulses.py"
    },
    {
        "api_name": "amp",
        "full_api_name": "Constant.amp",
        "api_description": "The constant value amplitude.",
        "api_signature": "amp(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/parametric_pulses.py"
    },
    {
        "api_name": "get_waveform",
        "full_api_name": "Constant.get_waveform",
        "api_description": "",
        "api_signature": "get_waveform(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/parametric_pulses.py"
    },
    {
        "api_name": "validate_parameters",
        "full_api_name": "Constant.validate_parameters",
        "api_description": "",
        "api_signature": "validate_parameters(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/parametric_pulses.py"
    },
    {
        "api_name": "parameters",
        "full_api_name": "Constant.parameters",
        "api_description": "",
        "api_signature": "parameters(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/parametric_pulses.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "Constant.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/parametric_pulses.py"
    },
    {
        "api_name": "_is_parameterized",
        "full_api_name": "_is_parameterized",
        "api_description": "Shorthand for a frequently checked predicate. ParameterExpressions cannot be\nvalidated until they are numerically assigned.",
        "api_signature": "_is_parameterized(value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/parametric_pulses.py"
    },
    {
        "api_name": "_lifted_gaussian",
        "full_api_name": "_lifted_gaussian",
        "api_description": "Helper function that returns a lifted Gaussian symbolic equation.\n\nFor :math:`\\sigma=` ``sigma`` the symbolic equation will be\n\n.. math::\n\n    f(x) = \\exp\\left(-\\frac12 \\left(\\frac{x - \\mu}{\\sigma}\\right)^2 \\right),\n\nwith the center :math:`\\mu=` ``duration/2``.\nThen, each output sample :math:`y` is modified according to:\n\n.. math::\n\n    y \\mapsto \\frac{y-y^*}{1.0-y^*},\n\nwhere :math:`y^*` is the value of the un-normalized Gaussian at the endpoints of the pulse.\nThis sets the endpoints to :math:`0` while preserving the amplitude at the center,\ni.e. :math:`y` is set to :math:`1.0`.\n\nArgs:\n    t: Symbol object representing time.\n    center: Symbol or expression representing the middle point of the samples.\n    t_zero: The value of t at which the pulse is lowered to 0.\n    sigma: Symbol or expression representing Gaussian sigma.\n\nReturns:\n    Symbolic equation.",
        "api_signature": "_lifted_gaussian(t, center, t_zero, sigma)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/symbolic_pulses.py"
    },
    {
        "api_name": "_is_amplitude_valid",
        "full_api_name": "_is_amplitude_valid",
        "api_description": "A helper function to validate maximum amplitude limit.\n\nResult is cached for better performance.\n\nArgs:\n    envelope_lam: The SymbolicPulse's lambdified envelope_lam expression.\n    time: The SymbolicPulse's time array, given as a tuple for hashability.\n    fargs: The arguments for the lambdified envelope_lam, as given by `_get_expression_args`,\n        except for the time array.\n\nReturns:\n    Return True if no sample point exceeds 1.0 in absolute value.",
        "api_signature": "_is_amplitude_valid(envelope_lam, time)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/symbolic_pulses.py"
    },
    {
        "api_name": "_get_expression_args",
        "full_api_name": "_get_expression_args",
        "api_description": "A helper function to get argument to evaluate expression.\n\nArgs:\n    expr: Symbolic expression to evaluate.\n    params: Dictionary of parameter, which is a superset of expression arguments.\n\nReturns:\n    Arguments passed to the lambdified expression.\n\nRaises:\n    PulseError: When a free symbol value is not defined in the pulse instance parameters.",
        "api_signature": "_get_expression_args(expr, params)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/symbolic_pulses.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "LambdifiedExpression.__init__",
        "api_description": "Create new descriptor.\n\nArgs:\n    attribute: Name of attribute of :class:`.SymbolicPulse` that returns\n        the target expression to evaluate.",
        "api_signature": "__init__(self, attribute)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/symbolic_pulses.py"
    },
    {
        "api_name": "__get__",
        "full_api_name": "LambdifiedExpression.__get__",
        "api_description": "",
        "api_signature": "__get__(self, instance, owner)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/symbolic_pulses.py"
    },
    {
        "api_name": "__set__",
        "full_api_name": "LambdifiedExpression.__set__",
        "api_description": "",
        "api_signature": "__set__(self, instance, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/symbolic_pulses.py"
    },
    {
        "api_name": "_wrapped_lamb",
        "full_api_name": "LambdifiedExpression._wrapped_lamb",
        "api_description": "",
        "api_signature": "_wrapped_lamb()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/symbolic_pulses.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SymbolicPulse.__init__",
        "api_description": "Create a parametric pulse.\n\nArgs:\n    pulse_type: Display name of this pulse shape.\n    duration: Duration of pulse.\n    parameters: Dictionary of pulse parameters that defines the pulse envelope.\n    name: Display name for this particular pulse envelope.\n    limit_amplitude: If ``True``, then limit the absolute value of the amplitude of the\n        waveform to 1. The default is ``True`` and the amplitude is constrained to 1.\n    envelope: Pulse envelope expression.\n    constraints: Pulse parameter constraint expression.\n    valid_amp_conditions: Extra conditions to skip a full-waveform check for the\n        amplitude limit. If this condition is not met, then the validation routine\n        will investigate the full-waveform and raise an error when the amplitude norm\n        of any data point exceeds 1.0. If not provided, the validation always\n        creates a full-waveform.\n\nRaises:\n    PulseError: When not all parameters are listed in the attribute :attr:`PARAM_DEF`.",
        "api_signature": "__init__(self, pulse_type, duration, parameters, name, limit_amplitude, envelope, constraints, valid_amp_conditions)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/symbolic_pulses.py"
    },
    {
        "api_name": "__getattr__",
        "full_api_name": "SymbolicPulse.__getattr__",
        "api_description": "",
        "api_signature": "__getattr__(self, item)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/symbolic_pulses.py"
    },
    {
        "api_name": "pulse_type",
        "full_api_name": "SymbolicPulse.pulse_type",
        "api_description": "Return display name of the pulse shape.",
        "api_signature": "pulse_type(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/symbolic_pulses.py"
    },
    {
        "api_name": "envelope",
        "full_api_name": "SymbolicPulse.envelope",
        "api_description": "Return symbolic expression for the pulse envelope.",
        "api_signature": "envelope(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/symbolic_pulses.py"
    },
    {
        "api_name": "constraints",
        "full_api_name": "SymbolicPulse.constraints",
        "api_description": "Return symbolic expression for the pulse parameter constraints.",
        "api_signature": "constraints(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/symbolic_pulses.py"
    },
    {
        "api_name": "valid_amp_conditions",
        "full_api_name": "SymbolicPulse.valid_amp_conditions",
        "api_description": "Return symbolic expression for the pulse amplitude constraints.",
        "api_signature": "valid_amp_conditions(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/symbolic_pulses.py"
    },
    {
        "api_name": "get_waveform",
        "full_api_name": "SymbolicPulse.get_waveform",
        "api_description": "Return a Waveform with samples filled according to the formula that the pulse\nrepresents and the parameter values it contains.\n\nSince the returned array is a discretized time series of the continuous function,\nthis method uses a midpoint sampler. For ``duration``, return:\n\n.. math::\n\n    \\{f(t+0.5) \\in \\mathbb{C} | t \\in \\mathbb{Z} \\wedge  0<=t<\\texttt{duration}\\}\n\nReturns:\n    A waveform representation of this pulse.\n\nRaises:\n    PulseError: When parameters are not assigned.\n    PulseError: When expression for pulse envelope is not assigned.",
        "api_signature": "get_waveform(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/symbolic_pulses.py"
    },
    {
        "api_name": "validate_parameters",
        "full_api_name": "SymbolicPulse.validate_parameters",
        "api_description": "Validate parameters.\n\nRaises:\n    PulseError: If the parameters passed are not valid.",
        "api_signature": "validate_parameters(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/symbolic_pulses.py"
    },
    {
        "api_name": "is_parameterized",
        "full_api_name": "SymbolicPulse.is_parameterized",
        "api_description": "Return True iff the instruction is parameterized.",
        "api_signature": "is_parameterized(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/symbolic_pulses.py"
    },
    {
        "api_name": "parameters",
        "full_api_name": "SymbolicPulse.parameters",
        "api_description": "",
        "api_signature": "parameters(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/symbolic_pulses.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "SymbolicPulse.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/symbolic_pulses.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "SymbolicPulse.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/symbolic_pulses.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ScalableSymbolicPulse.__init__",
        "api_description": "Create a scalable symbolic pulse.\n\nArgs:\n    pulse_type: Display name of this pulse shape.\n    duration: Duration of pulse.\n    amp: The magnitude of the complex amplitude of the pulse.\n    angle: The phase of the complex amplitude of the pulse.\n    parameters: Dictionary of pulse parameters that defines the pulse envelope.\n    name: Display name for this particular pulse envelope.\n    limit_amplitude: If ``True``, then limit the absolute value of the amplitude of the\n        waveform to 1. The default is ``True`` and the amplitude is constrained to 1.\n    envelope: Pulse envelope expression.\n    constraints: Pulse parameter constraint expression.\n    valid_amp_conditions: Extra conditions to skip a full-waveform check for the\n        amplitude limit. If this condition is not met, then the validation routine\n        will investigate the full-waveform and raise an error when the amplitude norm\n        of any data point exceeds 1.0. If not provided, the validation always\n        creates a full-waveform.\n\nRaises:\n    PulseError: If both `amp` is complex and `angle` is not `None` or 0.",
        "api_signature": "__init__(self, pulse_type, duration, amp, angle, parameters, name, limit_amplitude, envelope, constraints, valid_amp_conditions)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/symbolic_pulses.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "ScalableSymbolicPulse.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/symbolic_pulses.py"
    },
    {
        "api_name": "__instancecheck__",
        "full_api_name": "_PulseType.__instancecheck__",
        "api_description": "",
        "api_signature": "__instancecheck__(cls, instance)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/symbolic_pulses.py"
    },
    {
        "api_name": "__getattr__",
        "full_api_name": "_PulseType.__getattr__",
        "api_description": "",
        "api_signature": "__getattr__(cls, item)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/symbolic_pulses.py"
    },
    {
        "api_name": "__new__",
        "full_api_name": "Gaussian.__new__",
        "api_description": "Create new pulse instance.\n\nArgs:\n    duration: Pulse length in terms of the sampling period `dt`.\n    amp: The magnitude of the amplitude of the Gaussian envelope.\n            Complex amp support is deprecated.\n    sigma: A measure of how wide or narrow the Gaussian peak is; described mathematically\n           in the class docstring.\n    angle: The angle of the complex amplitude of the Gaussian envelope. Default value 0.\n    name: Display name for this pulse envelope.\n    limit_amplitude: If ``True``, then limit the amplitude of the\n        waveform to 1. The default is ``True`` and the amplitude is constrained to 1.\n\nReturns:\n    ScalableSymbolicPulse instance.",
        "api_signature": "__new__(cls, duration, amp, sigma, angle, name, limit_amplitude)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/symbolic_pulses.py"
    },
    {
        "api_name": "__new__",
        "full_api_name": "GaussianSquare.__new__",
        "api_description": "Create new pulse instance.\n\nArgs:\n    duration: Pulse length in terms of the sampling period `dt`.\n    amp: The magnitude of the amplitude of the Gaussian and square pulse.\n            Complex amp support is deprecated.\n    sigma: A measure of how wide or narrow the Gaussian risefall is; see the class\n           docstring for more details.\n    width: The duration of the embedded square pulse.\n    angle: The angle of the complex amplitude of the pulse. Default value 0.\n    risefall_sigma_ratio: The ratio of each risefall duration to sigma.\n    name: Display name for this pulse envelope.\n    limit_amplitude: If ``True``, then limit the amplitude of the\n        waveform to 1. The default is ``True`` and the amplitude is constrained to 1.\n\nReturns:\n    ScalableSymbolicPulse instance.\n\nRaises:\n    PulseError: When width and risefall_sigma_ratio are both empty or both non-empty.",
        "api_signature": "__new__(cls, duration, amp, sigma, width, angle, risefall_sigma_ratio, name, limit_amplitude)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/symbolic_pulses.py"
    },
    {
        "api_name": "GaussianSquareDrag",
        "full_api_name": "GaussianSquareDrag",
        "api_description": "A square pulse with a Drag shaped rise and fall\n\nThis pulse shape is similar to :class:`~.GaussianSquare` but uses\n:class:`~.Drag` for its rise and fall instead of :class:`~.Gaussian`. The\naddition of the DRAG component of the rise and fall is sometimes helpful in\nsuppressing the spectral content of the pulse at frequencies near to, but\nslightly offset from, the fundamental frequency of the drive. When there is\na spectator qubit close in frequency to the fundamental frequency,\nsuppressing the drive at the spectator's frequency can help avoid unwanted\nexcitation of the spectator.\n\nExactly one of the ``risefall_sigma_ratio`` and ``width`` parameters has to be specified.\n\nIf ``risefall_sigma_ratio`` is not ``None`` and ``width`` is ``None``:\n\n.. math::\n\n    \\text{risefall} &= \\text{risefall_sigma_ratio} \\times \\text{sigma}\\\\\n    \\text{width} &= \\text{duration} - 2 \\times \\text{risefall}\n\nIf ``width`` is not None and ``risefall_sigma_ratio`` is None:\n\n.. math:: \\text{risefall} = \\frac{\\text{duration} - \\text{width}}{2}\n\nGaussian :math:`g(x, c, \u03c3)` and lifted gaussian :math:`g'(x, c, \u03c3)` curves\ncan be written as:\n\n.. math::\n\n    g(x, c, \u03c3) &= \\exp\\Bigl(-\\frac12 \\frac{(x - c)^2}{\u03c3^2}\\Bigr)\\\\\n    g'(x, c, \u03c3) &= \\frac{g(x, c, \u03c3)-g(-1, c, \u03c3)}{1-g(-1, c, \u03c3)}\n\nFrom these, the lifted DRAG curve :math:`d'(x, c, \u03c3, \u03b2)` can be written as\n\n.. math::\n\n    d'(x, c, \u03c3, \u03b2) = g'(x, c, \u03c3) \\times \\Bigl(1 + 1j \\times \u03b2 \\times            \\Bigl(-\\frac{x - c}{\u03c3^2}\\Bigr)\\Bigr)\n\nThe lifted gaussian square drag pulse :math:`f'(x)` is defined as:\n\n.. math::\n\n    f'(x) &= \\begin{cases}            \\text{A} \\times d'(x, \\text{risefall}, \\text{sigma}, \\text{beta})                & x < \\text{risefall}\\\\\n        \\text{A}                & \\text{risefall} \\le x < \\text{risefall} + \\text{width}\\\\\n        \\text{A} \\times \\times d'(                    x - (\\text{risefall} + \\text{width}),                    \\text{risefall},                    \\text{sigma},                    \\text{beta}                )                & \\text{risefall} + \\text{width} \\le x        \\end{cases}\\\\\n\nwhere :math:`\\text{A} = \\text{amp} \\times\n\\exp\\left(i\\times\\text{angle}\\right)`.\n\nArgs:\n    duration: Pulse length in terms of the sampling period `dt`.\n    amp: The amplitude of the DRAG rise and fall and of the square pulse.\n    sigma: A measure of how wide or narrow the DRAG risefall is; see the class\n           docstring for more details.\n    beta: The DRAG correction amplitude.\n    width: The duration of the embedded square pulse.\n    angle: The angle in radians of the complex phase factor uniformly\n        scaling the pulse. Default value 0.\n    risefall_sigma_ratio: The ratio of each risefall duration to sigma.\n    name: Display name for this pulse envelope.\n    limit_amplitude: If ``True``, then limit the amplitude of the\n        waveform to 1. The default is ``True`` and the amplitude is constrained to 1.\n\nReturns:\n    ScalableSymbolicPulse instance.\n\nRaises:\n    PulseError: When width and risefall_sigma_ratio are both empty or both non-empty.",
        "api_signature": "GaussianSquareDrag(duration, amp, sigma, beta, width, angle, risefall_sigma_ratio, name, limit_amplitude)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/symbolic_pulses.py"
    },
    {
        "api_name": "gaussian_square_echo",
        "full_api_name": "gaussian_square_echo",
        "api_description": "An echoed Gaussian square pulse with an active tone overlaid on it.\n\nThe Gaussian Square Echo pulse is composed of three pulses. First, a Gaussian Square pulse\n:math:`f_{echo}(x)` with amplitude ``amp`` and phase ``angle`` playing for half duration,\nfollowed by a second Gaussian Square pulse :math:`-f_{echo}(x)` with opposite amplitude\nand same phase playing for the rest of the duration. Third a Gaussian Square pulse\n:math:`f_{active}(x)` with amplitude ``active_amp`` and phase ``active_angle``\nplaying for the entire duration. The Gaussian Square Echo pulse :math:`g_e()`\ncan be written as:\n\n.. math::\n\n    g_e(x) &= \\begin{cases}            f_{\\text{active}} + f_{\\text{echo}}(x)                & x < \\frac{\\text{duration}}{2}\\\\\n        f_{\\text{active}} - f_{\\text{echo}}(x)                & \\frac{\\text{duration}}{2} < x        \\end{cases}\\\\\n\nOne case where this pulse can be used is when implementing a direct CNOT gate with\na cross-resonance superconducting qubit architecture. When applying this pulse to\nthe target qubit, the active portion can be used to cancel IX terms from the\ncross-resonance drive while the echo portion can reduce the impact of a static ZZ coupling.\n\nExactly one of the ``risefall_sigma_ratio`` and ``width`` parameters has to be specified.\n\nIf ``risefall_sigma_ratio`` is not ``None`` and ``width`` is ``None``:\n\n.. math::\n\n    \\text{risefall} &= \\text{risefall_sigma_ratio} \\times \\text{sigma}\\\\\n    \\text{width} &= \\text{duration} - 2 \\times \\text{risefall}\n\nIf ``width`` is not None and ``risefall_sigma_ratio`` is None:\n\n.. math:: \\text{risefall} = \\frac{\\text{duration} - \\text{width}}{2}\n\nReferences:\n    1. |citation1|_\n\n    .. _citation1: https://iopscience.iop.org/article/10.1088/2058-9565/abe519\n\n    .. |citation1| replace:: *Jurcevic, P., Javadi-Abhari, A., Bishop, L. S.,\n        Lauer, I., Bogorin, D. F., Brink, M., Capelluto, L., G{\"u}nl{\"u}k, O.,\n        Itoko, T., Kanazawa, N. & others\n        Demonstration of quantum volume 64 on a superconducting quantum\n        computing system. (Section V)*\nArgs:\n    duration: Pulse length in terms of the sampling period `dt`.\n    amp: The amplitude of the rise and fall and of the echoed pulse.\n    sigma: A measure of how wide or narrow the risefall is; see the class\n           docstring for more details.\n    width: The duration of the embedded square pulse.\n    angle: The angle in radians of the complex phase factor uniformly\n        scaling the echoed pulse. Default value 0.\n    active_amp: The amplitude of the active pulse.\n    active_angle: The angle in radian of the complex phase factor uniformly\n        scaling the active pulse. Default value 0.\n    risefall_sigma_ratio: The ratio of each risefall duration to sigma.\n    name: Display name for this pulse envelope.\n    limit_amplitude: If ``True``, then limit the amplitude of the\n        waveform to 1. The default is ``True`` and the amplitude is constrained to 1.\nReturns:\n    ScalableSymbolicPulse instance.\nRaises:\n    PulseError: When width and risefall_sigma_ratio are both empty or both non-empty.",
        "api_signature": "gaussian_square_echo(duration, amp, sigma, width, angle, active_amp, active_angle, risefall_sigma_ratio, name, limit_amplitude)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/symbolic_pulses.py"
    },
    {
        "api_name": "GaussianDeriv",
        "full_api_name": "GaussianDeriv",
        "api_description": "An unnormalized Gaussian derivative pulse.\n\nThe Gaussian function is centered around the halfway point of the pulse,\nand the envelope of the pulse is given by:\n\n.. math::\n\n    f(x) = -\\text{A}\\frac{x-\\mu}{\\text{sigma}^{2}}\\exp\n        \\left[-\\left(\\frac{x-\\mu}{2\\text{sigma}}\\right)^{2}\\right]  ,  0 <= x < duration\n\nwhere :math:`\\text{A} = \\text{amp} \\times\\exp\\left(i\\times\\text{angle}\\right)`,\nand :math:`\\mu=\\text{duration}/2`.\n\nArgs:\n    duration: Pulse length in terms of the sampling period `dt`.\n    amp: The magnitude of the amplitude of the pulse\n        (the value of the corresponding Gaussian at the midpoint `duration`/2).\n    sigma: A measure of how wide or narrow the corresponding Gaussian peak is in terms of `dt`;\n        described mathematically in the class docstring.\n    angle: The angle in radians of the complex phase factor uniformly\n        scaling the pulse. Default value 0.\n    name: Display name for this pulse envelope.\n    limit_amplitude: If ``True``, then limit the amplitude of the\n        waveform to 1. The default is ``True`` and the amplitude is constrained to 1.\n\nReturns:\n    ScalableSymbolicPulse instance.",
        "api_signature": "GaussianDeriv(duration, amp, sigma, angle, name, limit_amplitude)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/symbolic_pulses.py"
    },
    {
        "api_name": "__new__",
        "full_api_name": "Drag.__new__",
        "api_description": "Create new pulse instance.\n\nArgs:\n    duration: Pulse length in terms of the sampling period `dt`.\n    amp: The magnitude of the amplitude of the DRAG envelope.\n            Complex amp support is deprecated.\n    sigma: A measure of how wide or narrow the Gaussian peak is; described mathematically\n           in the class docstring.\n    beta: The correction amplitude.\n    angle: The angle of the complex amplitude of the DRAG envelope. Default value 0.\n    name: Display name for this pulse envelope.\n    limit_amplitude: If ``True``, then limit the amplitude of the\n        waveform to 1. The default is ``True`` and the amplitude is constrained to 1.\n\nReturns:\n    ScalableSymbolicPulse instance.",
        "api_signature": "__new__(cls, duration, amp, sigma, beta, angle, name, limit_amplitude)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/symbolic_pulses.py"
    },
    {
        "api_name": "__new__",
        "full_api_name": "Constant.__new__",
        "api_description": "Create new pulse instance.\n\nArgs:\n    duration: Pulse length in terms of the sampling period `dt`.\n    amp: The magnitude of the amplitude of the square envelope.\n            Complex amp support is deprecated.\n    angle: The angle of the complex amplitude of the square envelope. Default value 0.\n    name: Display name for this pulse envelope.\n    limit_amplitude: If ``True``, then limit the amplitude of the\n        waveform to 1. The default is ``True`` and the amplitude is constrained to 1.\n\nReturns:\n    ScalableSymbolicPulse instance.",
        "api_signature": "__new__(cls, duration, amp, angle, name, limit_amplitude)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/symbolic_pulses.py"
    },
    {
        "api_name": "Sin",
        "full_api_name": "Sin",
        "api_description": "A sinusoidal pulse.\n\nThe envelope of the pulse is given by:\n\n.. math::\n\n    f(x) = \\text{A}\\sin\\left(2\\pi\\text{freq}x+\\text{phase}\\right)  ,  0 <= x < duration\n\nwhere :math:`\\text{A} = \\text{amp} \\times\\exp\\left(i\\times\\text{angle}\\right)`.\n\nArgs:\n    duration: Pulse length in terms of the sampling period `dt`.\n    amp: The magnitude of the amplitude of the sinusoidal wave. Wave range is [-`amp`,`amp`].\n    phase: The phase of the sinusoidal wave (note that this is not equivalent to the angle of\n        the complex amplitude)\n    freq: The frequency of the sinusoidal wave, in terms of 1 over sampling period.\n        If not provided defaults to a single cycle (i.e :math:'\\frac{1}{\\text{duration}}').\n        The frequency is limited to the range :math:`\\left(0,0.5\\right]` (the Nyquist frequency).\n    angle: The angle in radians of the complex phase factor uniformly\n        scaling the pulse. Default value 0.\n    name: Display name for this pulse envelope.\n    limit_amplitude: If ``True``, then limit the amplitude of the\n        waveform to 1. The default is ``True`` and the amplitude is constrained to 1.\n\nReturns:\n    ScalableSymbolicPulse instance.",
        "api_signature": "Sin(duration, amp, phase, freq, angle, name, limit_amplitude)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/symbolic_pulses.py"
    },
    {
        "api_name": "Cos",
        "full_api_name": "Cos",
        "api_description": "A cosine pulse.\n\nThe envelope of the pulse is given by:\n\n.. math::\n\n    f(x) = \\text{A}\\cos\\left(2\\pi\\text{freq}x+\\text{phase}\\right)  ,  0 <= x < duration\n\nwhere :math:`\\text{A} = \\text{amp} \\times\\exp\\left(i\\times\\text{angle}\\right)`.\n\nArgs:\n    duration: Pulse length in terms of the sampling period `dt`.\n    amp: The magnitude of the amplitude of the cosine wave. Wave range is [-`amp`,`amp`].\n    phase: The phase of the cosine wave (note that this is not equivalent to the angle\n        of the complex amplitude).\n    freq: The frequency of the cosine wave, in terms of 1 over sampling period.\n        If not provided defaults to a single cycle (i.e :math:'\\frac{1}{\\text{duration}}').\n        The frequency is limited to the range :math:`\\left(0,0.5\\right]` (the Nyquist frequency).\n    angle: The angle in radians of the complex phase factor uniformly\n        scaling the pulse. Default value 0.\n    name: Display name for this pulse envelope.\n    limit_amplitude: If ``True``, then limit the amplitude of the\n        waveform to 1. The default is ``True`` and the amplitude is constrained to 1.\n\nReturns:\n    ScalableSymbolicPulse instance.",
        "api_signature": "Cos(duration, amp, phase, freq, angle, name, limit_amplitude)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/symbolic_pulses.py"
    },
    {
        "api_name": "Sawtooth",
        "full_api_name": "Sawtooth",
        "api_description": "A sawtooth pulse.\n\nThe envelope of the pulse is given by:\n\n.. math::\n\n    f(x) = 2\\text{A}\\left[g\\left(x\\right)-\n        \\lfloor g\\left(x\\right)+\\frac{1}{2}\\rfloor\\right]\n\nwhere :math:`\\text{A} = \\text{amp} \\times\\exp\\left(i\\times\\text{angle}\\right)`,\n:math:`g\\left(x\\right)=x\\times\\text{freq}+\\frac{\\text{phase}}{2\\pi}`,\nand :math:`\\lfloor ...\\rfloor` is the floor operation.\n\nArgs:\n    duration: Pulse length in terms of the sampling period `dt`.\n    amp: The magnitude of the amplitude of the sawtooth wave. Wave range is [-`amp`,`amp`].\n    phase: The phase of the sawtooth wave (note that this is not equivalent to the angle\n        of the complex amplitude)\n    freq: The frequency of the sawtooth wave, in terms of 1 over sampling period.\n        If not provided defaults to a single cycle (i.e :math:'\\frac{1}{\\text{duration}}').\n        The frequency is limited to the range :math:`\\left(0,0.5\\right]` (the Nyquist frequency).\n    angle: The angle in radians of the complex phase factor uniformly\n        scaling the pulse. Default value 0.\n    name: Display name for this pulse envelope.\n    limit_amplitude: If ``True``, then limit the amplitude of the\n        waveform to 1. The default is ``True`` and the amplitude is constrained to 1.\n\nReturns:\n    ScalableSymbolicPulse instance.",
        "api_signature": "Sawtooth(duration, amp, phase, freq, angle, name, limit_amplitude)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/symbolic_pulses.py"
    },
    {
        "api_name": "Triangle",
        "full_api_name": "Triangle",
        "api_description": "A triangle wave pulse.\n\nThe envelope of the pulse is given by:\n\n.. math::\n\n    f(x) = \\text{A}\\left[\\text{sawtooth}\\left(x\\right)\\right]  ,  0 <= x < duration\n\nwhere :math:`\\text{A} = \\text{amp} \\times\\exp\\left(i\\times\\text{angle}\\right)`,\nand :math:`\\text{sawtooth}\\left(x\\right)` is a sawtooth wave with the same frequency\nas the triangle wave, but a phase shifted by :math:`\\frac{\\pi}{2}`.\n\nArgs:\n    duration: Pulse length in terms of the sampling period `dt`.\n    amp: The magnitude of the amplitude of the triangle wave. Wave range is [-`amp`,`amp`].\n    phase: The phase of the triangle wave (note that this is not equivalent to the angle\n        of the complex amplitude)\n    freq: The frequency of the triangle wave, in terms of 1 over sampling period.\n        If not provided defaults to a single cycle (i.e :math:'\\frac{1}{\\text{duration}}').\n        The frequency is limited to the range :math:`\\left(0,0.5\\right]` (the Nyquist frequency).\n    angle: The angle in radians of the complex phase factor uniformly\n        scaling the pulse. Default value 0.\n    name: Display name for this pulse envelope.\n    limit_amplitude: If ``True``, then limit the amplitude of the\n        waveform to 1. The default is ``True`` and the amplitude is constrained to 1.\n\nReturns:\n    ScalableSymbolicPulse instance.",
        "api_signature": "Triangle(duration, amp, phase, freq, angle, name, limit_amplitude)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/symbolic_pulses.py"
    },
    {
        "api_name": "Square",
        "full_api_name": "Square",
        "api_description": "A square wave pulse.\n\nThe envelope of the pulse is given by:\n\n.. math::\n\n    f(x) = \\text{A}\\text{sign}\\left[\\sin\n        \\left(2\\pi x\\times\\text{freq}+\\text{phase}\\right)\\right]  ,  0 <= x < duration\n\nwhere :math:`\\text{A} = \\text{amp} \\times\\exp\\left(i\\times\\text{angle}\\right)`,\nand :math:`\\text{sign}`\nis the sign function with the convention :math:`\\text{sign}\\left(0\\right)=1`.\n\nArgs:\n    duration: Pulse length in terms of the sampling period `dt`.\n    amp: The magnitude of the amplitude of the square wave. Wave range is [-`amp`,`amp`].\n    phase: The phase of the square wave (note that this is not equivalent to the angle of\n        the complex amplitude).\n    freq: The frequency of the square wave, in terms of 1 over sampling period.\n        If not provided defaults to a single cycle (i.e :math:'\\frac{1}{\\text{duration}}').\n        The frequency is limited to the range :math:`\\left(0,0.5\\right]` (the Nyquist frequency).\n    angle: The angle in radians of the complex phase factor uniformly\n        scaling the pulse. Default value 0.\n    name: Display name for this pulse envelope.\n    limit_amplitude: If ``True``, then limit the amplitude of the\n        waveform to 1. The default is ``True`` and the amplitude is constrained to 1.\n\nReturns:\n    ScalableSymbolicPulse instance.",
        "api_signature": "Square(duration, amp, phase, freq, angle, name, limit_amplitude)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/symbolic_pulses.py"
    },
    {
        "api_name": "Sech",
        "full_api_name": "Sech",
        "api_description": "An unnormalized sech pulse.\n\nThe sech function is centered around the halfway point of the pulse,\nand the envelope of the pulse is given by:\n\n.. math::\n\n    f(x) = \\text{A}\\text{sech}\\left(\n        \\frac{x-\\mu}{\\text{sigma}}\\right)  ,  0 <= x < duration\n\nwhere :math:`\\text{A} = \\text{amp} \\times\\exp\\left(i\\times\\text{angle}\\right)`,\nand :math:`\\mu=\\text{duration}/2`.\n\nIf `zero_ends` is set to `True`, the output `y` is modified:\n.. math::\n\n    y\\left(x\\right) \\mapsto \\text{A}\\frac{y-y^{*}}{\\text{A}-y^{*}},\n\nwhere :math:`y^{*}` is the value of :math:`y` at the endpoints (at :math:`x=-1\nand :math:`x=\\text{duration}+1`). This shifts the endpoints value to zero, while also\nrescaling to preserve the amplitude at `:math:`\\text{duration}/2``.\n\nArgs:\n    duration: Pulse length in terms of the sampling period `dt`.\n    amp: The magnitude of the amplitude of the pulse (the value at the midpoint `duration`/2).\n    sigma: A measure of how wide or narrow the sech peak is in terms of `dt`;\n        described mathematically in the class docstring.\n    angle: The angle in radians of the complex phase factor uniformly\n        scaling the pulse. Default value 0.\n    name: Display name for this pulse envelope.\n    zero_ends: If True, zeros the ends at x = -1, x = `duration` + 1,\n        but rescales to preserve `amp`. Default value True.\n    limit_amplitude: If ``True``, then limit the amplitude of the\n        waveform to 1. The default is ``True`` and the amplitude is constrained to 1.\n\nReturns:\n    ScalableSymbolicPulse instance.",
        "api_signature": "Sech(duration, amp, sigma, angle, name, zero_ends, limit_amplitude)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/symbolic_pulses.py"
    },
    {
        "api_name": "SechDeriv",
        "full_api_name": "SechDeriv",
        "api_description": "An unnormalized sech derivative pulse.\n\nThe sech function is centered around the halfway point of the pulse, and the envelope of the\npulse is given by:\n\n.. math::\n\n    f(x) = \\text{A}\\frac{d}{dx}\\left[\\text{sech}\n        \\left(\\frac{x-\\mu}{\\text{sigma}}\\right)\\right]  ,  0 <= x < duration\n\nwhere :math:`\\text{A} = \\text{amp} \\times\\exp\\left(i\\times\\text{angle}\\right)`,\n:math:`\\mu=\\text{duration}/2`, and :math:`d/dx` is a derivative with respect to `x`.\n\nArgs:\n    duration: Pulse length in terms of the sampling period `dt`.\n    amp: The magnitude of the amplitude of the pulse (the value of the corresponding sech\n        function at the midpoint `duration`/2).\n    sigma: A measure of how wide or narrow the corresponding sech peak is, in terms of `dt`;\n        described mathematically in the class docstring.\n    angle: The angle in radians of the complex phase factor uniformly\n        scaling the pulse. Default value 0.\n    name: Display name for this pulse envelope.\n    limit_amplitude: If ``True``, then limit the amplitude of the\n        waveform to 1. The default is ``True`` and the amplitude is constrained to 1.\n\nReturns:\n    ScalableSymbolicPulse instance.",
        "api_signature": "SechDeriv(duration, amp, sigma, angle, name, limit_amplitude)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/symbolic_pulses.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Waveform.__init__",
        "api_description": "Create new sample pulse command.\n\nArgs:\n    samples: Complex array of the samples in the pulse envelope.\n    name: Unique name to identify the pulse.\n    epsilon: Pulse sample norm tolerance for clipping.\n        If any sample's norm exceeds unity by less than or equal to epsilon\n        it will be clipped to unit norm. If the sample\n        norm is greater than 1+epsilon an error will be raised.\n    limit_amplitude: Passed to parent Pulse",
        "api_signature": "__init__(self, samples, name, epsilon, limit_amplitude)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/waveform.py"
    },
    {
        "api_name": "samples",
        "full_api_name": "Waveform.samples",
        "api_description": "Return sample values.",
        "api_signature": "samples(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/waveform.py"
    },
    {
        "api_name": "_clip",
        "full_api_name": "Waveform._clip",
        "api_description": "If samples are within epsilon of unit norm, clip sample by reducing norm by (1-epsilon).\n\nIf difference is greater than epsilon error is raised.\n\nArgs:\n    samples: Complex array of the samples in the pulse envelope.\n    epsilon: Pulse sample norm tolerance for clipping.\n        If any sample's norm exceeds unity by less than or equal to epsilon\n        it will be clipped to unit norm. If the sample\n        norm is greater than 1+epsilon an error will be raised.\n\nReturns:\n    Clipped pulse samples.\n\nRaises:\n    PulseError: If there exists a pulse sample with a norm greater than 1+epsilon.",
        "api_signature": "_clip(self, samples, epsilon)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/waveform.py"
    },
    {
        "api_name": "is_parameterized",
        "full_api_name": "Waveform.is_parameterized",
        "api_description": "Return True iff the instruction is parameterized.",
        "api_signature": "is_parameterized(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/waveform.py"
    },
    {
        "api_name": "parameters",
        "full_api_name": "Waveform.parameters",
        "api_description": "Return a dictionary containing the pulse's parameters.",
        "api_signature": "parameters(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/waveform.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "Waveform.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/waveform.py"
    },
    {
        "api_name": "__hash__",
        "full_api_name": "Waveform.__hash__",
        "api_description": "",
        "api_signature": "__hash__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/waveform.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "Waveform.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/waveform.py"
    },
    {
        "api_name": "constant",
        "full_api_name": "constant",
        "api_description": "Generates constant-sampled :class:`~qiskit.pulse.library.Waveform`.\n\nFor :math:`A=` ``amp``, samples from the function:\n\n.. math::\n\n    f(x) = A\n\nArgs:\n    duration: Duration of pulse. Must be greater than zero.\n    amp: Complex pulse amplitude.\n    name: Name of pulse.",
        "api_signature": "constant(duration, amp, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/discrete.py"
    },
    {
        "api_name": "zero",
        "full_api_name": "zero",
        "api_description": "Generates zero-sampled :class:`~qiskit.pulse.library.Waveform`.\n\nSamples from the function:\n\n.. math::\n\n    f(x) = 0\n\nArgs:\n    duration: Duration of pulse. Must be greater than zero.\n    name: Name of pulse.",
        "api_signature": "zero(duration, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/discrete.py"
    },
    {
        "api_name": "square",
        "full_api_name": "square",
        "api_description": "Generates square wave :class:`~qiskit.pulse.library.Waveform`.\n\nFor :math:`A=` ``amp``, :math:`T=` ``period``, and :math:`\\phi=` ``phase``,\napplies the `midpoint` sampling strategy to generate a discrete pulse sampled from\nthe continuous function:\n\n.. math::\n\n    f(x) = A \\text{sign}\\left[ \\sin\\left(\\frac{2 \\pi x}{T} + 2\\phi\\right) \\right]\n\nwith the convention :math:`\\text{sign}(0) = 1`.\n\n\nArgs:\n    duration: Duration of pulse. Must be greater than zero.\n    amp: Pulse amplitude. Wave range is :math:`[-` ``amp`` :math:`,` ``amp`` :math:`]`.\n    freq: Pulse frequency, units of 1./dt. If ``None`` defaults to 1./duration.\n    phase: Pulse phase.\n    name: Name of pulse.",
        "api_signature": "square(duration, amp, freq, phase, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/discrete.py"
    },
    {
        "api_name": "sawtooth",
        "full_api_name": "sawtooth",
        "api_description": "Generates sawtooth wave :class:`~qiskit.pulse.library.Waveform`.\n\nFor :math:`A=` ``amp``, :math:`T=` ``period``, and :math:`\\phi=` ``phase``,\napplies the `midpoint` sampling strategy to generate a discrete pulse sampled from\nthe continuous function:\n\n.. math::\n\n    f(x) = 2 A \\left( g(x) - \\left\\lfloor \\frac{1}{2} + g(x) \\right\\rfloor\\right)\n\nwhere :math:`g(x) = x/T + \\phi/\\pi`.\n\nArgs:\n    duration: Duration of pulse. Must be greater than zero.\n    amp: Pulse amplitude. Wave range is :math:`[-` ``amp`` :math:`,` ``amp`` :math:`]`.\n    freq: Pulse frequency, units of 1./dt. If ``None`` defaults to 1./duration.\n    phase: Pulse phase.\n    name: Name of pulse.\n\nExample:\n    .. plot::\n       :include-source:\n\n       import matplotlib.pyplot as plt\n       from qiskit.pulse.library import sawtooth\n       import numpy as np\n\n       duration = 100\n       amp = 1\n       freq = 1 / duration\n       sawtooth_wave = np.real(sawtooth(duration, amp, freq).samples)\n       plt.plot(range(duration), sawtooth_wave)\n       plt.show()",
        "api_signature": "sawtooth(duration, amp, freq, phase, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/discrete.py"
    },
    {
        "api_name": "triangle",
        "full_api_name": "triangle",
        "api_description": "Generates triangle wave :class:`~qiskit.pulse.library.Waveform`.\n\nFor :math:`A=` ``amp``, :math:`T=` ``period``, and :math:`\\phi=` ``phase``,\napplies the `midpoint` sampling strategy to generate a discrete pulse sampled from\nthe continuous function:\n\n.. math::\n\n    f(x) = A \\left(-2\\left|\\text{sawtooth}(x, A, T, \\phi)\\right| + 1\\right)\n\nThis a non-sinusoidal wave with linear ramping.\n\nArgs:\n    duration: Duration of pulse. Must be greater than zero.\n    amp: Pulse amplitude. Wave range is :math:`[-` ``amp`` :math:`,` ``amp`` :math:`]`.\n    freq: Pulse frequency, units of 1./dt. If ``None`` defaults to 1./duration.\n    phase: Pulse phase.\n    name: Name of pulse.\n\nExample:\n    .. plot::\n       :include-source:\n\n       import matplotlib.pyplot as plt\n       from qiskit.pulse.library import triangle\n       import numpy as np\n\n       duration = 100\n       amp = 1\n       freq = 1 / duration\n       triangle_wave = np.real(triangle(duration, amp, freq).samples)\n       plt.plot(range(duration), triangle_wave)\n       plt.show()",
        "api_signature": "triangle(duration, amp, freq, phase, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/discrete.py"
    },
    {
        "api_name": "cos",
        "full_api_name": "cos",
        "api_description": "Generates cosine wave :class:`~qiskit.pulse.library.Waveform`.\n\nFor :math:`A=` ``amp``, :math:`\\omega=` ``freq``, and :math:`\\phi=` ``phase``,\napplies the `midpoint` sampling strategy to generate a discrete pulse sampled from\nthe continuous function:\n\n.. math::\n\n    f(x) = A \\cos(2 \\pi \\omega x + \\phi)\n\nArgs:\n    duration: Duration of pulse. Must be greater than zero.\n    amp: Pulse amplitude.\n    freq: Pulse frequency, units of 1/dt. If ``None`` defaults to single cycle.\n    phase: Pulse phase.\n    name: Name of pulse.",
        "api_signature": "cos(duration, amp, freq, phase, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/discrete.py"
    },
    {
        "api_name": "sin",
        "full_api_name": "sin",
        "api_description": "Generates sine wave :class:`~qiskit.pulse.library.Waveform`.\n\nFor :math:`A=` ``amp``, :math:`\\omega=` ``freq``, and :math:`\\phi=` ``phase``,\napplies the `midpoint` sampling strategy to generate a discrete pulse sampled from\nthe continuous function:\n\n.. math::\n\n    f(x) = A \\sin(2 \\pi \\omega x + \\phi)\n\nArgs:\n    duration: Duration of pulse. Must be greater than zero.\n    amp: Pulse amplitude.\n    freq: Pulse frequency, units of 1/dt. If ``None`` defaults to single cycle.\n    phase: Pulse phase.\n    name: Name of pulse.",
        "api_signature": "sin(duration, amp, freq, phase, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/discrete.py"
    },
    {
        "api_name": "gaussian",
        "full_api_name": "gaussian",
        "api_description": "Generates unnormalized gaussian :class:`~qiskit.pulse.library.Waveform`.\n\nFor :math:`A=` ``amp`` and :math:`\\sigma=` ``sigma``, applies the ``midpoint`` sampling strategy\nto generate a discrete pulse sampled from the continuous function:\n\n.. math::\n\n    f(x) = A\\exp\\left(\\left(\\frac{x - \\mu}{2\\sigma}\\right)^2 \\right),\n\nwith the center :math:`\\mu=` ``duration/2``.\n\nIf ``zero_ends==True``, each output sample :math:`y` is modified according to:\n\n.. math::\n\n    y \\mapsto A\\frac{y-y^*}{A-y^*},\n\nwhere :math:`y^*` is the value of the endpoint samples. This sets the endpoints\nto :math:`0` while preserving the amplitude at the center. If :math:`A=y^*`,\n:math:`y` is set to :math:`1`. By default, the endpoints are at ``x = -1, x = duration + 1``.\n\nIntegrated area under the full curve is ``amp * np.sqrt(2*np.pi*sigma**2)``\n\nArgs:\n    duration: Duration of pulse. Must be greater than zero.\n    amp: Pulse amplitude at ``duration/2``.\n    sigma: Width (standard deviation) of pulse.\n    name: Name of pulse.\n    zero_ends: If True, zero ends at ``x = -1, x = duration + 1``, but rescale to preserve amp.",
        "api_signature": "gaussian(duration, amp, sigma, name, zero_ends)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/discrete.py"
    },
    {
        "api_name": "gaussian_deriv",
        "full_api_name": "gaussian_deriv",
        "api_description": "Generates unnormalized gaussian derivative :class:`~qiskit.pulse.library.Waveform`.\n\nFor :math:`A=` ``amp`` and :math:`\\sigma=` ``sigma`` applies the `midpoint` sampling strategy\nto generate a discrete pulse sampled from the continuous function:\n\n.. math::\n\n    f(x) = -A\\frac{(x - \\mu)}{\\sigma^2}\\exp\n        \\left(-\\frac{1}{2}\\left(\\frac{x - \\mu}{\\sigma}\\right)^2 \\right)\n\ni.e. the derivative of the Gaussian function, with center :math:`\\mu=` ``duration/2``.\n\nArgs:\n    duration: Duration of pulse. Must be greater than zero.\n    amp: Pulse amplitude of corresponding Gaussian at the pulse center (``duration/2``).\n    sigma: Width (standard deviation) of pulse.\n    name: Name of pulse.",
        "api_signature": "gaussian_deriv(duration, amp, sigma, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/discrete.py"
    },
    {
        "api_name": "sech",
        "full_api_name": "sech",
        "api_description": "Generates unnormalized sech :class:`~qiskit.pulse.library.Waveform`.\n\nFor :math:`A=` ``amp`` and :math:`\\sigma=` ``sigma``, applies the ``midpoint`` sampling strategy\nto generate a discrete pulse sampled from the continuous function:\n\n.. math::\n\n    f(x) = A\\text{sech}\\left(\\frac{x-\\mu}{\\sigma} \\right)\n\nwith the center :math:`\\mu=` ``duration/2``.\n\nIf ``zero_ends==True``, each output sample :math:`y` is modified according to:\n\n.. math::\n\n    y \\mapsto A\\frac{y-y^*}{A-y^*},\n\nwhere :math:`y^*` is the value of the endpoint samples. This sets the endpoints\nto :math:`0` while preserving the amplitude at the center. If :math:`A=y^*`,\n:math:`y` is set to :math:`1`. By default, the endpoints are at ``x = -1, x = duration + 1``.\n\nArgs:\n    duration: Duration of pulse. Must be greater than zero.\n    amp: Pulse amplitude at `duration/2`.\n    sigma: Width (standard deviation) of pulse.\n    name: Name of pulse.\n    zero_ends: If True, zero ends at ``x = -1, x = duration + 1``, but rescale to preserve amp.",
        "api_signature": "sech(duration, amp, sigma, name, zero_ends)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/discrete.py"
    },
    {
        "api_name": "sech_deriv",
        "full_api_name": "sech_deriv",
        "api_description": "Generates unnormalized sech derivative :class:`~qiskit.pulse.library.Waveform`.\n\nFor :math:`A=` ``amp``, :math:`\\sigma=` ``sigma``, and center :math:`\\mu=` ``duration/2``,\napplies the `midpoint` sampling strategy to generate a discrete pulse sampled from\nthe continuous function:\n\n.. math::\n    f(x) = \\frac{d}{dx}\\left[A\\text{sech}\\left(\\frac{x-\\mu}{\\sigma} \\right)\\right],\n\ni.e. the derivative of :math:`\\text{sech}`.\n\nArgs:\n    duration: Duration of pulse. Must be greater than zero.\n    amp: Pulse amplitude at `center`.\n    sigma: Width (standard deviation) of pulse.\n    name: Name of pulse.",
        "api_signature": "sech_deriv(duration, amp, sigma, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/discrete.py"
    },
    {
        "api_name": "gaussian_square",
        "full_api_name": "gaussian_square",
        "api_description": "Generates gaussian square :class:`~qiskit.pulse.library.Waveform`.\n\nFor :math:`d=` ``duration``, :math:`A=` ``amp``, :math:`\\sigma=` ``sigma``,\nand :math:`r=` ``risefall``, applies the ``midpoint`` sampling strategy to\ngenerate a discrete pulse sampled from the continuous function:\n\n.. math::\n\n    f(x) = \\begin{cases}\n                g(x - r) ) & x\\leq r \\\\\n                A & r\\leq x\\leq d-r \\\\\n                g(x - (d - r)) & d-r\\leq x\n            \\end{cases}\n\nwhere :math:`g(x)` is the Gaussian function sampled from in :meth:`gaussian`\nwith :math:`A=` ``amp``, :math:`\\mu=1`, and :math:`\\sigma=` ``sigma``. I.e.\n:math:`f(x)` represents a square pulse with smooth Gaussian edges.\n\nIf ``zero_ends == True``, the samples for the Gaussian ramps are remapped as in\n:meth:`gaussian`.\n\nArgs:\n    duration: Duration of pulse. Must be greater than zero.\n    amp: Pulse amplitude.\n    sigma: Width (standard deviation) of Gaussian rise/fall portion of the pulse.\n    risefall: Number of samples over which pulse rise and fall happen. Width of\n        square portion of pulse will be ``duration-2*risefall``.\n    width: The duration of the embedded square pulse. Only one of ``width`` or ``risefall``\n           should be specified as the functional form requires\n           ``width = duration - 2 * risefall``.\n    name: Name of pulse.\n    zero_ends: If True, zero ends at ``x = -1, x = duration + 1``, but rescale to preserve amp.\n\nRaises:\n    PulseError: If ``risefall`` and ``width`` arguments are inconsistent or not enough info.",
        "api_signature": "gaussian_square(duration, amp, sigma, risefall, width, name, zero_ends)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/discrete.py"
    },
    {
        "api_name": "drag",
        "full_api_name": "drag",
        "api_description": "Generates Y-only correction DRAG :class:`~qiskit.pulse.library.Waveform` for standard nonlinear\noscillator (SNO) [1].\n\nFor :math:`A=` ``amp``, :math:`\\sigma=` ``sigma``, and :math:`\\beta=` ``beta``, applies the\n``midpoint`` sampling strategy to generate a discrete pulse sampled from the\ncontinuous function:\n\n.. math::\n\n    f(x) = g(x) + i \\beta h(x),\n\nwhere :math:`g(x)` is the function sampled in :meth:`gaussian`, and :math:`h(x)`\nis the function sampled in :meth:`gaussian_deriv`.\n\nIf ``zero_ends == True``, the samples from :math:`g(x)` are remapped as in :meth:`gaussian`.\n\nReferences:\n    1. |citation1|_\n\n    .. _citation1: http://dx.doi.org/10.1103/PhysRevA.83.012308\n\n    .. |citation1| replace:: *Gambetta, J. M., Motzoi, F., Merkel, S. T. & Wilhelm, F. K.\n       \"Analytic control methods for high-fidelity unitary operations\n       in a weakly nonlinear oscillator.\" Phys. Rev. A 83, 012308 (2011).*\n\nArgs:\n    duration: Duration of pulse. Must be greater than zero.\n    amp: Pulse amplitude at center  ``duration/2``.\n    sigma: Width (standard deviation) of pulse.\n    beta: Y correction amplitude. For the SNO this is\n          :math:`\\beta=-\\frac{\\lambda_1^2}{4\\Delta_2}`. Where :math:`\\lambda_1` is the\n          relative coupling strength between the first excited and second excited states\n          and :math:`\\Delta_2` is the detuning between the respective excited states.\n    name: Name of pulse.\n    zero_ends: If True, zero ends at ``x = -1, x = duration + 1``, but rescale to preserve amp.",
        "api_signature": "drag(duration, amp, sigma, beta, name, zero_ends)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/discrete.py"
    },
    {
        "api_name": "functional_pulse",
        "full_api_name": "functional_pulse",
        "api_description": "A decorator for generating Waveform from python callable.\n\nArgs:\n    func: A function describing pulse envelope.\n\nRaises:\n    PulseError: when invalid function is specified.",
        "api_signature": "functional_pulse(func)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/samplers/decorators.py"
    },
    {
        "api_name": "to_pulse",
        "full_api_name": "to_pulse",
        "api_description": "Return Waveform.",
        "api_signature": "to_pulse(duration)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/samplers/decorators.py"
    },
    {
        "api_name": "_update_annotations",
        "full_api_name": "_update_annotations",
        "api_description": "Update annotations of discretized continuous pulse function with duration.\n\nArgs:\n    discretized_pulse: Discretized decorated continuous pulse.",
        "api_signature": "_update_annotations(discretized_pulse)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/samplers/decorators.py"
    },
    {
        "api_name": "_update_docstring",
        "full_api_name": "_update_docstring",
        "api_description": "Update annotations of discretized continuous pulse function.\n\nArgs:\n    discretized_pulse: Discretized decorated continuous pulse.\n    sampler_inst: Applied sampler.",
        "api_signature": "_update_docstring(discretized_pulse, sampler_inst)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/samplers/decorators.py"
    },
    {
        "api_name": "sampler",
        "full_api_name": "sampler",
        "api_description": "Sampler decorator base method.\n\nSamplers are used for converting an continuous function to a discretized pulse.\n\nThey operate on a function with the signature:\n    `def f(times: np.ndarray, *args, **kwargs) -> np.ndarray`\nWhere `times` is a numpy array of floats with length n_times and the output array\nis a complex numpy array with length n_times. The output of the decorator is an\ninstance of `FunctionalPulse` with signature:\n    `def g(duration: int, *args, **kwargs) -> Waveform`\n\nNote if your continuous pulse function outputs a `complex` scalar rather than a\n`np.ndarray`, you should first vectorize it before applying a sampler.\n\n\nThis class implements the sampler boilerplate for the sampler.\n\nArgs:\n    sample_function: A sampler function to be decorated.",
        "api_signature": "sampler(sample_function)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/samplers/decorators.py"
    },
    {
        "api_name": "generate_sampler",
        "full_api_name": "generate_sampler",
        "api_description": "Return a decorated sampler function.",
        "api_signature": "generate_sampler(continuous_pulse)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/samplers/decorators.py"
    },
    {
        "api_name": "call_sampler",
        "full_api_name": "call_sampler",
        "api_description": "Replace the call to the continuous function with a call to the sampler applied\nto the analytic pulse function.",
        "api_signature": "call_sampler(duration)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/samplers/decorators.py"
    },
    {
        "api_name": "left",
        "full_api_name": "left",
        "api_description": "Left sampling strategy decorator.\n\nSee `pulse.samplers.sampler` for more information.\n\nFor `duration`, return:\n    $$\\{f(t) \\in \\mathbb{C} | t \\in \\mathbb{Z} \\wedge  0<=t<\\texttt{duration}\\}$$\n\nArgs:\n    continuous_pulse: To sample.",
        "api_signature": "left(continuous_pulse)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/samplers/decorators.py"
    },
    {
        "api_name": "right",
        "full_api_name": "right",
        "api_description": "Right sampling strategy decorator.\n\nSee `pulse.samplers.sampler` for more information.\n\nFor `duration`, return:\n    $$\\{f(t) \\in \\mathbb{C} | t \\in \\mathbb{Z} \\wedge  0<t<=\\texttt{duration}\\}$$\n\nArgs:\n    continuous_pulse: To sample.",
        "api_signature": "right(continuous_pulse)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/samplers/decorators.py"
    },
    {
        "api_name": "midpoint",
        "full_api_name": "midpoint",
        "api_description": "Midpoint sampling strategy decorator.\n\nSee `pulse.samplers.sampler` for more information.\n\nFor `duration`, return:\n    $$\\{f(t+0.5) \\in \\mathbb{C} | t \\in \\mathbb{Z} \\wedge  0<=t<\\texttt{duration}\\}$$\n\nArgs:\n    continuous_pulse: To sample.",
        "api_signature": "midpoint(continuous_pulse)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/samplers/decorators.py"
    },
    {
        "api_name": "left_sample",
        "full_api_name": "left_sample",
        "api_description": "Left sample a continuous function.\n\nArgs:\n    continuous_pulse: Continuous pulse function to sample.\n    duration: Duration to sample for.\n    *args: Continuous pulse function args.\n    **kwargs: Continuous pulse function kwargs.",
        "api_signature": "left_sample(continuous_pulse, duration)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/samplers/strategies.py"
    },
    {
        "api_name": "right_sample",
        "full_api_name": "right_sample",
        "api_description": "Sampling strategy for decorator.\n\nArgs:\n    continuous_pulse: Continuous pulse function to sample.\n    duration: Duration to sample for.\n    *args: Continuous pulse function args.\n    **kwargs: Continuous pulse function kwargs.",
        "api_signature": "right_sample(continuous_pulse, duration)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/samplers/strategies.py"
    },
    {
        "api_name": "midpoint_sample",
        "full_api_name": "midpoint_sample",
        "api_description": "Sampling strategy for decorator.\n\nArgs:\n    continuous_pulse: Continuous pulse function to sample.\n    duration: Duration to sample for.\n    *args: Continuous pulse function args.\n    **kwargs: Continuous pulse function kwargs.",
        "api_signature": "midpoint_sample(continuous_pulse, duration)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/samplers/strategies.py"
    },
    {
        "api_name": "target_qobj_transform",
        "full_api_name": "target_qobj_transform",
        "api_description": "A basic pulse program transformation for OpenPulse API execution.\n\nArgs:\n    sched: Input program to transform.\n    remove_directives: Set `True` to remove compiler directives.\n\nReturns:\n    Transformed program for execution.",
        "api_signature": "target_qobj_transform(sched, remove_directives)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/base_transforms.py"
    },
    {
        "api_name": "_format_schedule_component",
        "full_api_name": "_format_schedule_component",
        "api_description": "A helper function to convert instructions into list of instructions.",
        "api_signature": "_format_schedule_component(sched)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/base_transforms.py"
    },
    {
        "api_name": "block_to_schedule",
        "full_api_name": "block_to_schedule",
        "api_description": "Convert ``ScheduleBlock`` to ``Schedule``.\n\nArgs:\n    block: A ``ScheduleBlock`` to convert.\n\nReturns:\n    Scheduled pulse program.\n\nRaises:\n    UnassignedDurationError: When any instruction duration is not assigned.\n    PulseError: When the alignment context duration is shorter than the schedule duration.\n\n.. note:: This transform may insert barriers in between contexts.",
        "api_signature": "block_to_schedule(block)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/canonicalization.py"
    },
    {
        "api_name": "compress_pulses",
        "full_api_name": "compress_pulses",
        "api_description": "Optimization pass to replace identical pulses.\n\nArgs:\n    schedules: Schedules to compress.\n\nReturns:\n    Compressed schedules.",
        "api_signature": "compress_pulses(schedules)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/canonicalization.py"
    },
    {
        "api_name": "flatten",
        "full_api_name": "flatten",
        "api_description": "Flatten (inline) any called nodes into a Schedule tree with no nested children.\n\nArgs:\n    program: Pulse program to remove nested structure.\n\nReturns:\n    Flatten pulse program.\n\nRaises:\n    PulseError: When invalid data format is given.",
        "api_signature": "flatten(program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/canonicalization.py"
    },
    {
        "api_name": "inline_subroutines",
        "full_api_name": "inline_subroutines",
        "api_description": "Recursively remove call instructions and inline the respective subroutine instructions.\n\nAssigned parameter values, which are stored in the parameter table, are also applied.\nThe subroutine is copied before the parameter assignment to avoid mutation problem.\n\nArgs:\n    program: A program which may contain the subroutine, i.e. ``Call`` instruction.\n\nReturns:\n    A schedule without subroutine.\n\nRaises:\n    PulseError: When input program is not valid data format.",
        "api_signature": "inline_subroutines(program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/canonicalization.py"
    },
    {
        "api_name": "_inline_schedule",
        "full_api_name": "_inline_schedule",
        "api_description": "A helper function to inline subroutine of schedule.\n\n.. note:: If subroutine is ``ScheduleBlock`` it is converted into Schedule to get ``t0``.",
        "api_signature": "_inline_schedule(schedule)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/canonicalization.py"
    },
    {
        "api_name": "_inline_block",
        "full_api_name": "_inline_block",
        "api_description": "A helper function to inline subroutine of schedule block.\n\n.. note:: If subroutine is ``Schedule`` the function raises an error.",
        "api_signature": "_inline_block(block)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/canonicalization.py"
    },
    {
        "api_name": "remove_directives",
        "full_api_name": "remove_directives",
        "api_description": "Remove directives.\n\nArgs:\n    schedule: A schedule to remove compiler directives.\n\nReturns:\n    A schedule without directives.",
        "api_signature": "remove_directives(schedule)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/canonicalization.py"
    },
    {
        "api_name": "remove_trivial_barriers",
        "full_api_name": "remove_trivial_barriers",
        "api_description": "Remove trivial barriers with 0 or 1 channels.\n\nArgs:\n    schedule: A schedule to remove trivial barriers.\n\nReturns:\n    schedule: A schedule without trivial barriers",
        "api_signature": "remove_trivial_barriers(schedule)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/canonicalization.py"
    },
    {
        "api_name": "filter_func",
        "full_api_name": "filter_func",
        "api_description": "",
        "api_signature": "filter_func(inst)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/canonicalization.py"
    },
    {
        "api_name": "align_measures",
        "full_api_name": "align_measures",
        "api_description": "Return new schedules where measurements occur at the same physical time.\n\nThis transformation will align the first :class:`.Acquire` on\nevery channel to occur at the same time.\n\nMinimum measurement wait time (to allow for calibration pulses) is enforced\nand may be set with ``max_calibration_duration``.\n\nBy default only instructions containing a :class:`.AcquireChannel` or :class:`.MeasureChannel`\nwill be shifted. If you wish to keep the relative timing of all instructions in the schedule set\n``align_all=True``.\n\nThis method assumes that ``MeasureChannel(i)`` and ``AcquireChannel(i)``\ncorrespond to the same qubit and the acquire/play instructions\nshould be shifted together on these channels.\n\n.. code-block::\n\n    from qiskit import pulse\n    from qiskit.pulse import transforms\n\n    d0 = pulse.DriveChannel(0)\n    m0 = pulse.MeasureChannel(0)\n    a0 = pulse.AcquireChannel(0)\n    mem0 = pulse.MemorySlot(0)\n\n    sched = pulse.Schedule()\n    sched.append(pulse.Play(pulse.Constant(10, 0.5), d0), inplace=True)\n    sched.append(pulse.Play(pulse.Constant(10, 1.), m0).shift(sched.duration), inplace=True)\n    sched.append(pulse.Acquire(20, a0, mem0).shift(sched.duration), inplace=True)\n\n    sched_shifted = sched << 20\n\n    aligned_sched, aligned_sched_shifted = transforms.align_measures([sched, sched_shifted])\n\n    assert aligned_sched == aligned_sched_shifted\n\nIf it is desired to only shift acquisition and measurement stimulus instructions\nset the flag ``align_all=False``:\n\n.. code-block::\n\n    aligned_sched, aligned_sched_shifted = transforms.align_measures(\n        [sched, sched_shifted],\n        align_all=False,\n    )\n\n    assert aligned_sched != aligned_sched_shifted\n\n\nArgs:\n    schedules: Collection of schedules to be aligned together\n    inst_map: Mapping of circuit operations to pulse schedules\n    cal_gate: The name of the gate to inspect for the calibration time\n    max_calibration_duration: If provided, inst_map and cal_gate will be ignored\n    align_time: If provided, this will be used as final align time.\n    align_all: Shift all instructions in the schedule such that they maintain\n        their relative alignment with the shifted acquisition instruction.\n        If ``False`` only the acquisition and measurement pulse instructions\n        will be shifted.\nReturns:\n    The input list of schedules transformed to have their measurements aligned.\n\nRaises:\n    PulseError: If the provided alignment time is negative.",
        "api_signature": "align_measures(schedules, inst_map, cal_gate, max_calibration_duration, align_time, align_all)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/canonicalization.py"
    },
    {
        "api_name": "get_first_acquire_times",
        "full_api_name": "get_first_acquire_times",
        "api_description": "Return a list of first acquire times for each schedule.",
        "api_signature": "get_first_acquire_times(schedules)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/canonicalization.py"
    },
    {
        "api_name": "get_max_calibration_duration",
        "full_api_name": "get_max_calibration_duration",
        "api_description": "Return the time needed to allow for readout discrimination calibration pulses.",
        "api_signature": "get_max_calibration_duration(inst_map, cal_gate)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/canonicalization.py"
    },
    {
        "api_name": "add_implicit_acquires",
        "full_api_name": "add_implicit_acquires",
        "api_description": "Return a new schedule with implicit acquires from the measurement mapping replaced by\nexplicit ones.\n\n.. warning:: Since new acquires are being added, Memory Slots will be set to match the\n             qubit index. This may overwrite your specification.\n\nArgs:\n    schedule: Schedule to be aligned.\n    meas_map: List of lists of qubits that are measured together.\n\nReturns:\n    A ``Schedule`` with the additional acquisition instructions.",
        "api_signature": "add_implicit_acquires(schedule, meas_map)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/canonicalization.py"
    },
    {
        "api_name": "pad",
        "full_api_name": "pad",
        "api_description": "Pad the input Schedule with ``Delay``s on all unoccupied timeslots until\n``schedule.duration`` or ``until`` if not ``None``.\n\nArgs:\n    schedule: Schedule to pad.\n    channels: Channels to pad. Defaults to all channels in\n        ``schedule`` if not provided. If the supplied channel is not a member\n        of ``schedule`` it will be added.\n    until: Time to pad until. Defaults to ``schedule.duration`` if not provided.\n    inplace: Pad this schedule by mutating rather than returning a new schedule.\n    pad_with: Pulse ``Instruction`` subclass to be used for padding.\n        Default to :class:`~qiskit.pulse.instructions.Delay` instruction.\n\nReturns:\n    The padded schedule.\n\nRaises:\n    PulseError: When non pulse instruction is set to `pad_with`.",
        "api_signature": "pad(schedule, channels, until, inplace, pad_with)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/canonicalization.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "AlignmentKind.__init__",
        "api_description": "Create new context.",
        "api_signature": "__init__(self, context_params)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/alignments.py"
    },
    {
        "api_name": "align",
        "full_api_name": "AlignmentKind.align",
        "api_description": "Reallocate instructions according to the policy.\n\nOnly top-level sub-schedules are aligned. If sub-schedules are nested,\nnested schedules are not recursively aligned.\n\nArgs:\n    schedule: Schedule to align.\n\nReturns:\n    Schedule with reallocated instructions.",
        "api_signature": "align(self, schedule)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/alignments.py"
    },
    {
        "api_name": "is_sequential",
        "full_api_name": "AlignmentKind.is_sequential",
        "api_description": "Return ``True`` if this is sequential alignment context.\n\nThis information is used to evaluate DAG equivalency of two :class:`.ScheduleBlock`s.\nWhen the context has two pulses in different channels,\na sequential context subtype intends to return following scheduling outcome.\n\n.. parsed-literal::\n\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    D0: \u2524 pulse1 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    D1: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 pulse2 \u251c\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nOn the other hand, parallel context with ``is_sequential=False`` returns\n\n.. parsed-literal::\n\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    D0: \u2524 pulse1 \u251c\n        \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n    D1: \u2524 pulse2 \u251c\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nAll subclasses must implement this method according to scheduling strategy.",
        "api_signature": "is_sequential(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/alignments.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "AlignmentKind.__eq__",
        "api_description": "Check equality of two transforms.",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/alignments.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "AlignmentKind.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/alignments.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "AlignLeft.__init__",
        "api_description": "Create new left-justified context.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/alignments.py"
    },
    {
        "api_name": "is_sequential",
        "full_api_name": "AlignLeft.is_sequential",
        "api_description": "",
        "api_signature": "is_sequential(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/alignments.py"
    },
    {
        "api_name": "align",
        "full_api_name": "AlignLeft.align",
        "api_description": "Reallocate instructions according to the policy.\n\nOnly top-level sub-schedules are aligned. If sub-schedules are nested,\nnested schedules are not recursively aligned.\n\nArgs:\n    schedule: Schedule to align.\n\nReturns:\n    Schedule with reallocated instructions.",
        "api_signature": "align(self, schedule)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/alignments.py"
    },
    {
        "api_name": "_push_left_append",
        "full_api_name": "AlignLeft._push_left_append",
        "api_description": "Return ``this`` with ``other`` inserted at the maximum time over\nall channels shared between ```this`` and ``other``.\n\nArgs:\n    this: Input schedule to which ``other`` will be inserted.\n    other: Other schedule to insert.\n\nReturns:\n    Push left appended schedule.",
        "api_signature": "_push_left_append(this, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/alignments.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "AlignRight.__init__",
        "api_description": "Create new right-justified context.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/alignments.py"
    },
    {
        "api_name": "is_sequential",
        "full_api_name": "AlignRight.is_sequential",
        "api_description": "",
        "api_signature": "is_sequential(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/alignments.py"
    },
    {
        "api_name": "align",
        "full_api_name": "AlignRight.align",
        "api_description": "Reallocate instructions according to the policy.\n\nOnly top-level sub-schedules are aligned. If sub-schedules are nested,\nnested schedules are not recursively aligned.\n\nArgs:\n    schedule: Schedule to align.\n\nReturns:\n    Schedule with reallocated instructions.",
        "api_signature": "align(self, schedule)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/alignments.py"
    },
    {
        "api_name": "_push_right_prepend",
        "full_api_name": "AlignRight._push_right_prepend",
        "api_description": "Return ``this`` with ``other`` inserted at the latest possible time\nsuch that ``other`` ends before it overlaps with any of ``this``.\n\nIf required ``this`` is shifted  to start late enough so that there is room\nto insert ``other``.\n\nArgs:\n   this: Input schedule to which ``other`` will be inserted.\n   other: Other schedule to insert.\n\nReturns:\n   Push right prepended schedule.",
        "api_signature": "_push_right_prepend(this, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/alignments.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "AlignSequential.__init__",
        "api_description": "Create new sequential context.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/alignments.py"
    },
    {
        "api_name": "is_sequential",
        "full_api_name": "AlignSequential.is_sequential",
        "api_description": "",
        "api_signature": "is_sequential(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/alignments.py"
    },
    {
        "api_name": "align",
        "full_api_name": "AlignSequential.align",
        "api_description": "Reallocate instructions according to the policy.\n\nOnly top-level sub-schedules are aligned. If sub-schedules are nested,\nnested schedules are not recursively aligned.\n\nArgs:\n    schedule: Schedule to align.\n\nReturns:\n    Schedule with reallocated instructions.",
        "api_signature": "align(self, schedule)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/alignments.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "AlignEquispaced.__init__",
        "api_description": "Create new equispaced context.\n\nArgs:\n    duration: Duration of this context. This should be larger than the schedule duration.\n        If the specified duration is shorter than the schedule duration,\n        no alignment is performed and the input schedule is just returned.\n        This duration can be parametrized.",
        "api_signature": "__init__(self, duration)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/alignments.py"
    },
    {
        "api_name": "is_sequential",
        "full_api_name": "AlignEquispaced.is_sequential",
        "api_description": "",
        "api_signature": "is_sequential(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/alignments.py"
    },
    {
        "api_name": "duration",
        "full_api_name": "AlignEquispaced.duration",
        "api_description": "Return context duration.",
        "api_signature": "duration(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/alignments.py"
    },
    {
        "api_name": "align",
        "full_api_name": "AlignEquispaced.align",
        "api_description": "Reallocate instructions according to the policy.\n\nOnly top-level sub-schedules are aligned. If sub-schedules are nested,\nnested schedules are not recursively aligned.\n\nArgs:\n    schedule: Schedule to align.\n\nReturns:\n    Schedule with reallocated instructions.",
        "api_signature": "align(self, schedule)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/alignments.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "AlignFunc.__init__",
        "api_description": "Create new equispaced context.\n\nArgs:\n    duration: Duration of this context. This should be larger than the schedule duration.\n        If the specified duration is shorter than the schedule duration,\n        no alignment is performed and the input schedule is just returned.\n        This duration can be parametrized.\n    func: A function that takes an index of sub-schedule and returns the\n        fractional coordinate of of that sub-schedule. The returned value should be\n        defined within [0, 1]. The pulse index starts from 1.",
        "api_signature": "__init__(self, duration, func)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/alignments.py"
    },
    {
        "api_name": "is_sequential",
        "full_api_name": "AlignFunc.is_sequential",
        "api_description": "",
        "api_signature": "is_sequential(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/alignments.py"
    },
    {
        "api_name": "duration",
        "full_api_name": "AlignFunc.duration",
        "api_description": "Return context duration.",
        "api_signature": "duration(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/alignments.py"
    },
    {
        "api_name": "func",
        "full_api_name": "AlignFunc.func",
        "api_description": "Return context alignment function.",
        "api_signature": "func(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/alignments.py"
    },
    {
        "api_name": "align",
        "full_api_name": "AlignFunc.align",
        "api_description": "Reallocate instructions according to the policy.\n\nOnly top-level sub-schedules are aligned. If sub-schedules are nested,\nnested schedules are not recursively aligned.\n\nArgs:\n    schedule: Schedule to align.\n\nReturns:\n    Schedule with reallocated instructions.",
        "api_signature": "align(self, schedule)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/alignments.py"
    },
    {
        "api_name": "block_to_dag",
        "full_api_name": "block_to_dag",
        "api_description": "Convert schedule block instruction into DAG.\n\n``ScheduleBlock`` can be represented as a DAG as needed.\nFor example, equality of two programs are efficiently checked on DAG representation.\n\n.. code-block:: python\n\n    with pulse.build() as sched1:\n        with pulse.align_left():\n            pulse.play(my_gaussian0, pulse.DriveChannel(0))\n            pulse.shift_phase(1.57, pulse.DriveChannel(2))\n            pulse.play(my_gaussian1, pulse.DriveChannel(1))\n\n    with pulse.build() as sched2:\n        with pulse.align_left():\n            pulse.shift_phase(1.57, pulse.DriveChannel(2))\n            pulse.play(my_gaussian1, pulse.DriveChannel(1))\n            pulse.play(my_gaussian0, pulse.DriveChannel(0))\n\nHere the ``sched1 `` and ``sched2`` are different implementations of the same program,\nbut it is difficult to confirm on the list representation.\n\nAnother example is instruction optimization.\n\n.. code-block:: python\n\n    with pulse.build() as sched:\n        with pulse.align_left():\n            pulse.shift_phase(1.57, pulse.DriveChannel(1))\n            pulse.play(my_gaussian0, pulse.DriveChannel(0))\n            pulse.shift_phase(-1.57, pulse.DriveChannel(1))\n\nIn above program two ``shift_phase`` instructions can be cancelled out because\nthey are consecutive on the same drive channel.\nThis can be easily found on the DAG representation.\n\nArgs:\n    block (\"ScheduleBlock\"): A schedule block to be converted.\n\nReturns:\n    Instructions in DAG representation.\n\nRaises:\n    PulseError: When the context is invalid subclass.",
        "api_signature": "block_to_dag(block)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/dag.py"
    },
    {
        "api_name": "_sequential_allocation",
        "full_api_name": "_sequential_allocation",
        "api_description": "A helper function to create a DAG of a sequential alignment context.",
        "api_signature": "_sequential_allocation(block)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/dag.py"
    },
    {
        "api_name": "_parallel_allocation",
        "full_api_name": "_parallel_allocation",
        "api_description": "A helper function to create a DAG of a parallel alignment context.",
        "api_signature": "_parallel_allocation(block)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/dag.py"
    },
    {
        "api_name": "marginal_counts",
        "full_api_name": "marginal_counts",
        "api_description": "Marginalize counts from an experiment over some indices of interest.\n\nArgs:\n    result: result to be marginalized\n        (a Result object or a dict(str, int) of counts).\n    indices: The bit positions of interest\n        to marginalize over. If ``None`` (default), do not marginalize at all.\n    inplace: Default: False. Operates on the original Result\n        argument if True, leading to loss of original Job Result.\n        It has no effect if ``result`` is a dict.\n    format_marginal: Default: False. If True, takes the output of\n        marginalize and formats it with placeholders between cregs and\n        for non-indices.\n    marginalize_memory: If True, then also marginalize the memory field (if present).\n        If False, remove the memory field from the result.\n        If None, leave the memory field as is.\n\nReturns:\n    Result or dict(str, int): A Result object or a dictionary with\n        the observed counts, marginalized to only account for frequency\n        of observations of bits of interest.\n\nRaises:\n    QiskitError: in case of invalid indices to marginalize over.",
        "api_signature": "marginal_counts(result, indices, inplace, format_marginal, marginalize_memory)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/utils.py"
    },
    {
        "api_name": "_adjust_creg_sizes",
        "full_api_name": "_adjust_creg_sizes",
        "api_description": "Helper to reduce creg_sizes to match indices",
        "api_signature": "_adjust_creg_sizes(creg_sizes, indices)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/utils.py"
    },
    {
        "api_name": "marginal_memory",
        "full_api_name": "marginal_memory",
        "api_description": "Marginalize shot memory\n\nThis function is multithreaded and will launch a thread pool with threads equal to the number\nof CPUs by default. You can tune the number of threads with the ``RAYON_NUM_THREADS``\nenvironment variable. For example, setting ``RAYON_NUM_THREADS=4`` would limit the thread pool\nto 4 threads.\n\nArgs:\n    memory: The input memory list, this is either a list of hexadecimal strings to be marginalized\n        representing measure level 2 memory or a numpy array representing level 0 measurement\n        memory (single or avg) or level 1 measurement memory (single or avg).\n    indices: The bit positions of interest to marginalize over. If\n        ``None`` (default), do not marginalize at all.\n    int_return: If set to ``True`` the output will be a list of integers.\n        By default the return type is a bit string. This and ``hex_return``\n        are mutually exclusive and can not be specified at the same time. This option only has an\n        effect with memory level 2.\n    hex_return: If set to ``True`` the output will be a list of hexadecimal\n        strings. By default the return type is a bit string. This and\n        ``int_return`` are mutually exclusive and can not be specified\n        at the same time. This option only has an effect with memory level 2.\n    avg_data: If a 2 dimensional numpy array is passed in for ``memory`` this can be set to\n        ``True`` to indicate it's a avg level 0 data instead of level 1\n        single data.\n    parallel_threshold: The number of elements in ``memory`` to start running in multiple\n        threads. If ``len(memory)`` is >= this value, the function will run in multiple\n        threads. By default this is set to 1000.\n\nReturns:\n    marginal_memory: The list of marginalized memory\n\nRaises:\n    ValueError: if both ``int_return`` and ``hex_return`` are set to ``True``",
        "api_signature": "marginal_memory(memory, indices, int_return, hex_return, avg_data, parallel_threshold)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/utils.py"
    },
    {
        "api_name": "marginal_distribution",
        "full_api_name": "marginal_distribution",
        "api_description": "Marginalize counts from an experiment over some indices of interest.\n\nUnlike :func:`~.marginal_counts` this function respects the order of\nthe input ``indices``. If the input ``indices`` list is specified then the order\nthe bit indices are specified will be the output order of the bitstrings\nin the marginalized output.\n\nArgs:\n    counts: result to be marginalized\n    indices: The bit positions of interest\n        to marginalize over. If ``None`` (default), do not marginalize at all.\n    format_marginal: Default: False. If True, takes the output of\n        marginalize and formats it with placeholders between cregs and\n        for non-indices.\nReturns:\n    dict(str, int): A marginalized dictionary\nRaises:\n    QiskitError: If any value in ``indices`` is invalid or the ``counts`` dict\n    is invalid.",
        "api_signature": "marginal_distribution(counts, indices, format_marginal)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/utils.py"
    },
    {
        "api_name": "_marginalize",
        "full_api_name": "_marginalize",
        "api_description": "Get the marginal counts for the given set of indices",
        "api_signature": "_marginalize(counts, indices)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/utils.py"
    },
    {
        "api_name": "_format_marginal",
        "full_api_name": "_format_marginal",
        "api_description": "Take the output of marginalize and add placeholders for\nmultiple cregs and non-indices.",
        "api_signature": "_format_marginal(counts, marg_counts, indices)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/utils.py"
    },
    {
        "api_name": "_remove_space_underscore",
        "full_api_name": "_remove_space_underscore",
        "api_description": "Removes all spaces and underscores from bitstring",
        "api_signature": "_remove_space_underscore(bitstring)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/utils.py"
    },
    {
        "api_name": "sampled_expectation_value",
        "full_api_name": "sampled_expectation_value",
        "api_description": "Computes expectation value from a sampled distribution\n\nNote that passing a raw dict requires bit-string keys.\n\nParameters:\n    dist (Counts or QuasiDistribution or ProbDistribution or dict): Input sampled distribution\n    oper (str or Pauli or PauliOp or PauliSumOp or SparsePauliOp): The operator for\n                                                                   the observable\n\nReturns:\n    float: The expectation value\nRaises:\n    QiskitError: if the input distribution or operator is an invalid type",
        "api_signature": "sampled_expectation_value(dist, oper)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/sampled_expval.py"
    },
    {
        "api_name": "_hex_to_bin",
        "full_api_name": "_hex_to_bin",
        "api_description": "Convert hexadecimal readouts (memory) to binary readouts.",
        "api_signature": "_hex_to_bin(hexstring)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/postprocess.py"
    },
    {
        "api_name": "_bin_to_hex",
        "full_api_name": "_bin_to_hex",
        "api_description": "Convert bitstring readouts (memory) to hexadecimal readouts.",
        "api_signature": "_bin_to_hex(bitstring)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/postprocess.py"
    },
    {
        "api_name": "_pad_zeros",
        "full_api_name": "_pad_zeros",
        "api_description": "If the bitstring is truncated, pad extra zeros to make its\nlength equal to memory_slots",
        "api_signature": "_pad_zeros(bitstring, memory_slots)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/postprocess.py"
    },
    {
        "api_name": "_separate_bitstring",
        "full_api_name": "_separate_bitstring",
        "api_description": "Separate a bitstring according to the registers defined in the result header.",
        "api_signature": "_separate_bitstring(bitstring, creg_sizes)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/postprocess.py"
    },
    {
        "api_name": "format_counts_memory",
        "full_api_name": "format_counts_memory",
        "api_description": "Format a single bitstring (memory) from a single shot experiment.\n\n- The hexadecimals are expanded to bitstrings\n\n- Spaces are inserted at register divisions.\n\nArgs:\n    shot_memory (str): result of a single experiment.\n    header (dict): the experiment header dictionary containing\n        useful information for postprocessing. creg_sizes\n        are a nested list where the inner element is a list\n        of creg name, creg size pairs. memory_slots is an integers\n        specifying the number of total memory_slots in the experiment.\n\nReturns:\n    dict: a formatted memory",
        "api_signature": "format_counts_memory(shot_memory, header)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/postprocess.py"
    },
    {
        "api_name": "_list_to_complex_array",
        "full_api_name": "_list_to_complex_array",
        "api_description": "Convert nested list of shape (..., 2) to complex numpy array with shape (...)\n\nArgs:\n    complex_list (list): List to convert.\n\nReturns:\n    np.ndarray: Complex numpy array\n\nRaises:\n    QiskitError: If inner most array of input nested list is not of length 2.",
        "api_signature": "_list_to_complex_array(complex_list)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/postprocess.py"
    },
    {
        "api_name": "format_level_0_memory",
        "full_api_name": "format_level_0_memory",
        "api_description": "Format an experiment result memory object for measurement level 0.\n\nArgs:\n    memory (list): Memory from experiment with `meas_level==1`. `avg` or\n        `single` will be inferred from shape of result memory.\n\nReturns:\n    np.ndarray: Measurement level 0 complex numpy array\n\nRaises:\n    QiskitError: If the returned numpy array does not have 2 (avg) or 3 (single)\n        indices.",
        "api_signature": "format_level_0_memory(memory)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/postprocess.py"
    },
    {
        "api_name": "format_level_1_memory",
        "full_api_name": "format_level_1_memory",
        "api_description": "Format an experiment result memory object for measurement level 1.\n\nArgs:\n    memory (list): Memory from experiment with `meas_level==1`. `avg` or\n        `single` will be inferred from shape of result memory.\n\nReturns:\n    np.ndarray: Measurement level 1 complex numpy array\n\nRaises:\n    QiskitError: If the returned numpy array does not have 1 (avg) or 2 (single)\n        indices.",
        "api_signature": "format_level_1_memory(memory)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/postprocess.py"
    },
    {
        "api_name": "format_level_2_memory",
        "full_api_name": "format_level_2_memory",
        "api_description": "Format an experiment result memory object for measurement level 2.\n\nArgs:\n    memory (list): Memory from experiment with `meas_level==2` and `memory==True`.\n    header (dict): the experiment header dictionary containing\n        useful information for postprocessing.\n\nReturns:\n    list[str]: List of bitstrings",
        "api_signature": "format_level_2_memory(memory, header)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/postprocess.py"
    },
    {
        "api_name": "format_counts",
        "full_api_name": "format_counts",
        "api_description": "Format a single experiment result coming from backend to present\nto the Qiskit user.\n\nArgs:\n    counts (dict): counts histogram of multiple shots\n    header (dict): the experiment header dictionary containing\n        useful information for postprocessing.\n\nReturns:\n    dict: a formatted counts",
        "api_signature": "format_counts(counts, header)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/postprocess.py"
    },
    {
        "api_name": "format_statevector",
        "full_api_name": "format_statevector",
        "api_description": "Format statevector coming from the backend to present to the Qiskit user.\n\nArgs:\n    vec (list): a list of [re, im] complex numbers.\n    decimals (int): the number of decimals in the statevector.\n        If None, no rounding is done.\n\nReturns:\n    list[complex]: a list of python complex numbers.",
        "api_signature": "format_statevector(vec, decimals)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/postprocess.py"
    },
    {
        "api_name": "format_unitary",
        "full_api_name": "format_unitary",
        "api_description": "Format unitary coming from the backend to present to the Qiskit user.\n\nArgs:\n    mat (list[list]): a list of list of [re, im] complex numbers\n    decimals (int): the number of decimals in the statevector.\n        If None, no rounding is done.\n\nReturns:\n    list[list[complex]]: a matrix of complex numbers",
        "api_signature": "format_unitary(mat, decimals)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/postprocess.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ResultError.__init__",
        "api_description": "",
        "api_signature": "__init__(self, error)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/exceptions.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "ResultError.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/exceptions.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ExperimentResultData.__init__",
        "api_description": "Initialize an ExperimentalResult Data class\n\nArgs:\n    counts (dict): A dictionary where the keys are the result in\n        hexadecimal as string of the format \"0xff\" and the value\n        is the number of counts for that result\n    snapshots (dict): A dictionary where the key is the snapshot\n        slot and the value is a dictionary of the snapshots for\n        that slot.\n    memory (list): A list of results per shot if the run had\n        memory enabled\n    statevector (list or numpy.array): A list or numpy array of the\n        statevector result\n    unitary (list or numpy.array): A list or numpy array of the\n        unitary result\n    kwargs (any): additional data key-value pairs.",
        "api_signature": "__init__(self, counts, snapshots, memory, statevector, unitary)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/models.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "ExperimentResultData.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/models.py"
    },
    {
        "api_name": "to_dict",
        "full_api_name": "ExperimentResultData.to_dict",
        "api_description": "Return a dictionary format representation of the ExperimentResultData\n\nReturns:\n    dict: The dictionary form of the ExperimentResultData",
        "api_signature": "to_dict(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/models.py"
    },
    {
        "api_name": "from_dict",
        "full_api_name": "ExperimentResultData.from_dict",
        "api_description": "Create a new ExperimentResultData object from a dictionary.\n\nArgs:\n    data (dict): A dictionary representing the ExperimentResultData to\n                 create. It will be in the same format as output by\n                 :meth:`to_dict`\nReturns:\n    ExperimentResultData: The ``ExperimentResultData`` object from the\n                          input dictionary.",
        "api_signature": "from_dict(cls, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/models.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ExperimentResult.__init__",
        "api_description": "Initialize an ExperimentResult object.\n\nArgs:\n    shots(int or tuple): if an integer the number of shots or if a\n        tuple the starting and ending shot for this data\n    success (bool): True if the experiment was successful\n    data (ExperimentResultData): The data for the experiment's\n        result\n    meas_level (int): Measurement result level\n    status (str): The status of the experiment\n    seed (int): The seed used for simulation (if run on a simulator)\n    meas_return (str): The type of measurement returned\n    header (qiskit.qobj.QobjExperimentHeader): A free form dictionary\n        header for the experiment\n    kwargs: Arbitrary extra fields\n\nRaises:\n    QiskitError: If meas_return or meas_level are not valid values",
        "api_signature": "__init__(self, shots, success, data, meas_level, status, seed, meas_return, header)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/models.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "ExperimentResult.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/models.py"
    },
    {
        "api_name": "__getattr__",
        "full_api_name": "ExperimentResult.__getattr__",
        "api_description": "",
        "api_signature": "__getattr__(self, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/models.py"
    },
    {
        "api_name": "to_dict",
        "full_api_name": "ExperimentResult.to_dict",
        "api_description": "Return a dictionary format representation of the ExperimentResult\n\nReturns:\n    dict: The dictionary form of the ExperimentResult",
        "api_signature": "to_dict(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/models.py"
    },
    {
        "api_name": "from_dict",
        "full_api_name": "ExperimentResult.from_dict",
        "api_description": "Create a new ExperimentResult object from a dictionary.\n\nArgs:\n    data (dict): A dictionary representing the ExperimentResult to\n                 create. It will be in the same format as output by\n                 :meth:`to_dict`\n\nReturns:\n    ExperimentResult: The ``ExperimentResult`` object from the input\n                      dictionary.",
        "api_signature": "from_dict(cls, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/models.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Counts.__init__",
        "api_description": "Build a counts object\n\nArgs:\n    data (dict): The dictionary input for the counts. Where the keys\n        represent a measured classical value and the value is an\n        integer the number of shots with that result.\n        The keys can be one of several formats:\n\n             * A hexadecimal string of the form ``'0x4a'``\n             * A bit string prefixed with ``0b`` for example ``'0b1011'``\n             * A bit string formatted across register and memory slots.\n               For example, ``'00 10'``.\n             * A dit string, for example ``'02'``. Note for objects created\n               with dit strings the ``creg_sizes`` and ``memory_slots``\n               kwargs don't work and :meth:`hex_outcomes` and\n               :meth:`int_outcomes` also do not work.\n\n    time_taken (float): The duration of the experiment that generated\n        the counts in seconds.\n    creg_sizes (list): a nested list where the inner element is a list\n        of tuples containing both the classical register name and\n        classical register size. For example,\n        ``[('c_reg', 2), ('my_creg', 4)]``.\n    memory_slots (int): The number of total ``memory_slots`` in the\n        experiment.\nRaises:\n    TypeError: If the input key type is not an ``int`` or ``str``.\n    QiskitError: If a dit string key is input with ``creg_sizes`` and/or\n        ``memory_slots``.",
        "api_signature": "__init__(self, data, time_taken, creg_sizes, memory_slots)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/counts.py"
    },
    {
        "api_name": "most_frequent",
        "full_api_name": "Counts.most_frequent",
        "api_description": "Return the most frequent count\n\nReturns:\n    str: The bit string for the most frequent result\nRaises:\n    QiskitError: when there is >1 count with the same max counts, or\n        an empty object.",
        "api_signature": "most_frequent(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/counts.py"
    },
    {
        "api_name": "hex_outcomes",
        "full_api_name": "Counts.hex_outcomes",
        "api_description": "Return a counts dictionary with hexadecimal string keys\n\nReturns:\n    dict: A dictionary with the keys as hexadecimal strings instead of\n        bitstrings\nRaises:\n    QiskitError: If the Counts object contains counts for dit strings",
        "api_signature": "hex_outcomes(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/counts.py"
    },
    {
        "api_name": "int_outcomes",
        "full_api_name": "Counts.int_outcomes",
        "api_description": "Build a counts dictionary with integer keys instead of count strings\n\nReturns:\n    dict: A dictionary with the keys as integers instead of bitstrings\nRaises:\n    QiskitError: If the Counts object contains counts for dit strings",
        "api_signature": "int_outcomes(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/counts.py"
    },
    {
        "api_name": "_remove_space_underscore",
        "full_api_name": "Counts._remove_space_underscore",
        "api_description": "Removes all spaces and underscores from bitstring",
        "api_signature": "_remove_space_underscore(bitstring)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/counts.py"
    },
    {
        "api_name": "shots",
        "full_api_name": "Counts.shots",
        "api_description": "Return the number of shots",
        "api_signature": "shots(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/counts.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Result.__init__",
        "api_description": "",
        "api_signature": "__init__(self, backend_name, backend_version, qobj_id, job_id, success, results, date, status, header)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/result.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "Result.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/result.py"
    },
    {
        "api_name": "to_dict",
        "full_api_name": "Result.to_dict",
        "api_description": "Return a dictionary format representation of the Result\n\nReturns:\n    dict: The dictionary form of the Result",
        "api_signature": "to_dict(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/result.py"
    },
    {
        "api_name": "__getattr__",
        "full_api_name": "Result.__getattr__",
        "api_description": "",
        "api_signature": "__getattr__(self, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/result.py"
    },
    {
        "api_name": "from_dict",
        "full_api_name": "Result.from_dict",
        "api_description": "Create a new ExperimentResultData object from a dictionary.\n\nArgs:\n    data (dict): A dictionary representing the Result to create. It\n                 will be in the same format as output by\n                 :meth:`to_dict`.\nReturns:\n    Result: The ``Result`` object from the input dictionary.",
        "api_signature": "from_dict(cls, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/result.py"
    },
    {
        "api_name": "data",
        "full_api_name": "Result.data",
        "api_description": "Get the raw data for an experiment.\n\nNote this data will be a single classical and quantum register and in a\nformat required by the results schema. We recommend that most users use\nthe get_xxx method, and the data will be post-processed for the data type.\n\nArgs:\n    experiment (str or QuantumCircuit or Schedule or int or None): the index of the\n        experiment. Several types are accepted for convenience::\n        * str: the name of the experiment.\n        * QuantumCircuit: the name of the circuit instance will be used.\n        * Schedule: the name of the schedule instance will be used.\n        * int: the position of the experiment.\n        * None: if there is only one experiment, returns it.\n\nReturns:\n    dict: A dictionary of results data for an experiment. The data\n    depends on the backend it ran on and the settings of `meas_level`,\n    `meas_return` and `memory`.\n\n    OpenQASM backends return a dictionary of dictionary with the key\n    'counts' and  with the counts, with the second dictionary keys\n    containing a string in hex format (``0x123``) and values equal to\n    the number of times this outcome was measured.\n\n    Statevector backends return a dictionary with key 'statevector' and\n    values being a list[list[complex components]] list of 2^num_qubits\n    complex amplitudes. Where each complex number is represented as a 2\n    entry list for each component. For example, a list of\n    [0.5+1j, 0-1j] would be represented as [[0.5, 1], [0, -1]].\n\n    Unitary backends return a dictionary with key 'unitary' and values\n    being a list[list[list[complex components]]] list of\n    2^num_qubits x 2^num_qubits complex amplitudes in a two entry list for\n    each component. For example if the amplitude is\n    [[0.5+0j, 0-1j], ...] the value returned will be\n    [[[0.5, 0], [0, -1]], ...].\n\n    The simulator backends also have an optional key 'snapshots' which\n    returns a dict of snapshots specified by the simulator backend.\n    The value is of the form dict[slot: dict[str: array]]\n    where the keys are the requested snapshot slots, and the values are\n    a dictionary of the snapshots.\n\nRaises:\n    QiskitError: if data for the experiment could not be retrieved.",
        "api_signature": "data(self, experiment)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/result.py"
    },
    {
        "api_name": "get_memory",
        "full_api_name": "Result.get_memory",
        "api_description": "Get the sequence of memory states (readouts) for each shot\nThe data from the experiment is a list of format\n['00000', '01000', '10100', '10100', '11101', '11100', '00101', ..., '01010']\n\nArgs:\n    experiment (str or QuantumCircuit or Schedule or int or None): the index of the\n        experiment, as specified by ``data()``.\n\nReturns:\n    List[str] or np.ndarray: Either the list of each outcome, formatted according to\n    registers in circuit or a complex numpy np.ndarray with shape:\n\n        ============  =============  =====\n        `meas_level`  `meas_return`  shape\n        ============  =============  =====\n        0             `single`       np.ndarray[shots, memory_slots, memory_slot_size]\n        0             `avg`          np.ndarray[memory_slots, memory_slot_size]\n        1             `single`       np.ndarray[shots, memory_slots]\n        1             `avg`          np.ndarray[memory_slots]\n        2             `memory=True`  list\n        ============  =============  =====\n\nRaises:\n    QiskitError: if there is no memory data for the circuit.",
        "api_signature": "get_memory(self, experiment)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/result.py"
    },
    {
        "api_name": "get_counts",
        "full_api_name": "Result.get_counts",
        "api_description": "Get the histogram data of an experiment.\n\nArgs:\n    experiment (str or QuantumCircuit or Schedule or int or None): the index of the\n        experiment, as specified by ``data([experiment])``.\n\nReturns:\n    dict[str, int] or list[dict[str, int]]: a dictionary or a list of\n    dictionaries. A dictionary has the counts for each qubit with\n    the keys containing a string in binary format and separated\n    according to the registers in circuit (e.g. ``0100 1110``).\n    The string is little-endian (cr[0] on the right hand side).\n\nRaises:\n    QiskitError: if there are no counts for the experiment.",
        "api_signature": "get_counts(self, experiment)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/result.py"
    },
    {
        "api_name": "get_statevector",
        "full_api_name": "Result.get_statevector",
        "api_description": "Get the final statevector of an experiment.\n\nArgs:\n    experiment (str or QuantumCircuit or Schedule or int or None): the index of the\n        experiment, as specified by ``data()``.\n    decimals (int): the number of decimals in the statevector.\n        If None, does not round.\n\nReturns:\n    list[complex]: list of 2^num_qubits complex amplitudes.\n\nRaises:\n    QiskitError: if there is no statevector for the experiment.",
        "api_signature": "get_statevector(self, experiment, decimals)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/result.py"
    },
    {
        "api_name": "get_unitary",
        "full_api_name": "Result.get_unitary",
        "api_description": "Get the final unitary of an experiment.\n\nArgs:\n    experiment (str or QuantumCircuit or Schedule or int or None): the index of the\n        experiment, as specified by ``data()``.\n    decimals (int): the number of decimals in the unitary.\n        If None, does not round.\n\nReturns:\n    list[list[complex]]: list of 2^num_qubits x 2^num_qubits complex\n        amplitudes.\n\nRaises:\n    QiskitError: if there is no unitary for the experiment.",
        "api_signature": "get_unitary(self, experiment, decimals)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/result.py"
    },
    {
        "api_name": "_get_experiment",
        "full_api_name": "Result._get_experiment",
        "api_description": "Return a single experiment result from a given key.\n\nArgs:\n    key (str or QuantumCircuit or Schedule or int or None): the index of the\n        experiment, as specified by ``data()``.\n\nReturns:\n    ExperimentResult: the results for an experiment.\n\nRaises:\n    QiskitError: if there is no data for the experiment, or an unhandled\n        error occurred while fetching the data.",
        "api_signature": "_get_experiment(self, key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/result.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QuasiDistribution.__init__",
        "api_description": "Builds a quasiprobability distribution object.\n\n.. note::\n\n    The quasiprobability values might include floating-point errors.\n    ``QuasiDistribution.__repr__`` rounds using :meth:`numpy.round`\n    and the parameter ``ndigits`` can be manipulated with the\n    class attribute ``__ndigits__``. The default is ``15``.\n\nParameters:\n    data (dict): Input quasiprobability data. Where the keys\n        represent a measured classical value and the value is a\n        float for the quasiprobability of that result.\n        The keys can be one of several formats:\n\n            * A hexadecimal string of the form ``\"0x4a\"``\n            * A bit string e.g. ``'0b1011'`` or ``\"01011\"``\n            * An integer\n\n    shots (int): Number of shots the distribution was derived from.\n    stddev_upper_bound (float): An upper bound for the standard deviation\n\nRaises:\n    TypeError: If the input keys are not a string or int\n    ValueError: If the string format of the keys is incorrect",
        "api_signature": "__init__(self, data, shots, stddev_upper_bound)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/distributions/quasi.py"
    },
    {
        "api_name": "nearest_probability_distribution",
        "full_api_name": "QuasiDistribution.nearest_probability_distribution",
        "api_description": "Takes a quasiprobability distribution and maps\nit to the closest probability distribution as defined by\nthe L2-norm.\n\nParameters:\n    return_distance (bool): Return the L2 distance between distributions.\n\nReturns:\n    ProbDistribution: Nearest probability distribution.\n    float: Euclidean (L2) distance of distributions.\n\nNotes:\n    Method from Smolin et al., Phys. Rev. Lett. 108, 070502 (2012).",
        "api_signature": "nearest_probability_distribution(self, return_distance)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/distributions/quasi.py"
    },
    {
        "api_name": "binary_probabilities",
        "full_api_name": "QuasiDistribution.binary_probabilities",
        "api_description": "Build a quasi-probabilities dictionary with binary string keys\n\nParameters:\n    num_bits (int): number of bits in the binary bitstrings (leading\n        zeros will be padded). If None, a default value will be used.\n        If keys are given as integers or strings with binary or hex prefix,\n        the default value will be derived from the largest key present.\n        If keys are given as bitstrings without prefix,\n        the default value will be derived from the largest key length.\n\nReturns:\n    dict: A dictionary where the keys are binary strings in the format\n        ``\"0110\"``",
        "api_signature": "binary_probabilities(self, num_bits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/distributions/quasi.py"
    },
    {
        "api_name": "hex_probabilities",
        "full_api_name": "QuasiDistribution.hex_probabilities",
        "api_description": "Build a quasi-probabilities dictionary with hexadecimal string keys\n\nReturns:\n    dict: A dictionary where the keys are hexadecimal strings in the\n        format ``\"0x1a\"``",
        "api_signature": "hex_probabilities(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/distributions/quasi.py"
    },
    {
        "api_name": "stddev_upper_bound",
        "full_api_name": "QuasiDistribution.stddev_upper_bound",
        "api_description": "Return an upper bound on standard deviation of expval estimator.",
        "api_signature": "stddev_upper_bound(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/distributions/quasi.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "QuasiDistribution.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/distributions/quasi.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ProbDistribution.__init__",
        "api_description": "Builds a probability distribution object.\n\nArgs:\n    data (dict): Input probability data. Where the keys\n        represent a measured classical value and the value is a\n        float for the probability of that result.\n        The keys can be one of several formats:\n\n            * A hexadecimal string of the form ``\"0x4a\"``\n            * A bit string e.g. ``'0b1011'`` or ``\"01011\"``\n            * An integer\n\n    shots (int): Number of shots the distribution was derived from.\n\nRaises:\n    TypeError: If the input keys are not a string or int\n    ValueError: If the string format of the keys is incorrect",
        "api_signature": "__init__(self, data, shots)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/distributions/probability.py"
    },
    {
        "api_name": "binary_probabilities",
        "full_api_name": "ProbDistribution.binary_probabilities",
        "api_description": "Build a probabilities dictionary with binary string keys\n\nParameters:\n    num_bits (int): number of bits in the binary bitstrings (leading\n        zeros will be padded). If None, a default value will be used.\n        If keys are given as integers or strings with binary or hex prefix,\n        the default value will be derived from the largest key present.\n        If keys are given as bitstrings without prefix,\n        the default value will be derived from the largest key length.\n\nReturns:\n    dict: A dictionary where the keys are binary strings in the format\n        ``\"0110\"``",
        "api_signature": "binary_probabilities(self, num_bits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/distributions/probability.py"
    },
    {
        "api_name": "hex_probabilities",
        "full_api_name": "ProbDistribution.hex_probabilities",
        "api_description": "Build a probabilities dictionary with hexadecimal string keys\n\nReturns:\n    dict: A dictionary where the keys are hexadecimal strings in the\n        format ``\"0x1a\"``",
        "api_signature": "hex_probabilities(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/distributions/probability.py"
    },
    {
        "api_name": "z_diagonal",
        "full_api_name": "z_diagonal",
        "api_description": "Return the diagonal for the operator :math:`Z^\\otimes n`",
        "api_signature": "z_diagonal(dim, dtype)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/mitigation/utils.py"
    },
    {
        "api_name": "expval_with_stddev",
        "full_api_name": "expval_with_stddev",
        "api_description": "Compute expectation value and standard deviation.\nArgs:\n    coeffs: array of diagonal operator coefficients.\n    probs: array of measurement probabilities.\n    shots: total number of shots to obtain probabilities.\nReturns:\n    tuple: (expval, stddev) expectation value and standard deviation.",
        "api_signature": "expval_with_stddev(coeffs, probs, shots)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/mitigation/utils.py"
    },
    {
        "api_name": "stddev",
        "full_api_name": "stddev",
        "api_description": "Calculate stddev dict",
        "api_signature": "stddev(probs, shots)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/mitigation/utils.py"
    },
    {
        "api_name": "str2diag",
        "full_api_name": "str2diag",
        "api_description": "Transform diagonal from a string to a numpy array",
        "api_signature": "str2diag(string)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/mitigation/utils.py"
    },
    {
        "api_name": "counts_to_vector",
        "full_api_name": "counts_to_vector",
        "api_description": "Transforms Counts to a probability vector",
        "api_signature": "counts_to_vector(counts, num_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/mitigation/utils.py"
    },
    {
        "api_name": "remap_qubits",
        "full_api_name": "remap_qubits",
        "api_description": "Remapping the qubits",
        "api_signature": "remap_qubits(vec, num_qubits, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/mitigation/utils.py"
    },
    {
        "api_name": "marganalize_counts",
        "full_api_name": "marganalize_counts",
        "api_description": "Marginalization of the Counts. Verify that number of clbits equals to the number of qubits.",
        "api_signature": "marganalize_counts(counts, qubit_index, qubits, clbits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/mitigation/utils.py"
    },
    {
        "api_name": "counts_probability_vector",
        "full_api_name": "counts_probability_vector",
        "api_description": "Compute a probability vector for all count outcomes.\n\nArgs:\n    counts: counts object\n    qubit_index: For each qubit, its index in the mitigator qubits list\n    qubits: qubits the count bitstrings correspond to.\n    clbits: Optional, marginalize counts to just these bits.\n\nRaises:\n    QiskitError: if qubits and clbits kwargs are not valid.\n\nReturns:\n    np.ndarray: a probability vector for all count outcomes.\n    int: Number of shots in the counts",
        "api_signature": "counts_probability_vector(counts, qubit_index, qubits, clbits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/mitigation/utils.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CorrelatedReadoutMitigator.__init__",
        "api_description": "Initialize a CorrelatedReadoutMitigator\n\nArgs:\n    assignment_matrix: readout error assignment matrix.\n    qubits: Optional, the measured physical qubits for mitigation.\n\nRaises:\n    QiskitError: matrix size does not agree with number of qubits",
        "api_signature": "__init__(self, assignment_matrix, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/mitigation/correlated_readout_mitigator.py"
    },
    {
        "api_name": "settings",
        "full_api_name": "CorrelatedReadoutMitigator.settings",
        "api_description": "Return settings.",
        "api_signature": "settings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/mitigation/correlated_readout_mitigator.py"
    },
    {
        "api_name": "expectation_value",
        "full_api_name": "CorrelatedReadoutMitigator.expectation_value",
        "api_description": "Compute the mitigated expectation value of a diagonal observable.\n\nThis computes the mitigated estimator of\n:math:`\\langle O \\rangle = \\mbox{Tr}[\\rho. O]` of a diagonal observable\n:math:`O = \\sum_{x\\in\\{0, 1\\}^n} O(x)|x\\rangle\\!\\langle x|`.\n\nArgs:\n    data: Counts object\n    diagonal: Optional, the vector of diagonal values for summing the\n              expectation value. If ``None`` the default value is\n              :math:`[1, -1]^\\otimes n`.\n    qubits: Optional, the measured physical qubits the count\n            bitstrings correspond to. If None qubits are assumed to be\n            :math:`[0, ..., n-1]`.\n    clbits: Optional, if not None marginalize counts to the specified bits.\n    shots: the number of shots.\n\nReturns:\n    (float, float): the expectation value and an upper bound of the standard deviation.\n\nAdditional Information:\n    The diagonal observable :math:`O` is input using the ``diagonal`` kwarg as\n    a list or Numpy array :math:`[O(0), ..., O(2^n -1)]`. If no diagonal is specified\n    the diagonal of the Pauli operator\n    :math`O = \\mbox{diag}(Z^{\\otimes n}) = [1, -1]^{\\otimes n}` is used.\n    The ``clbits`` kwarg is used to marginalize the input counts dictionary\n    over the specified bit-values, and the ``qubits`` kwarg is used to specify\n    which physical qubits these bit-values correspond to as\n    ``circuit.measure(qubits, clbits)``.",
        "api_signature": "expectation_value(self, data, diagonal, qubits, clbits, shots)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/mitigation/correlated_readout_mitigator.py"
    },
    {
        "api_name": "quasi_probabilities",
        "full_api_name": "CorrelatedReadoutMitigator.quasi_probabilities",
        "api_description": "Compute mitigated quasi probabilities value.\n\nArgs:\n    data: counts object\n    qubits: qubits the count bitstrings correspond to.\n    clbits: Optional, marginalize counts to just these bits.\n    shots: Optional, the total number of shots, if None shots will\n        be calculated as the sum of all counts.\n\nReturns:\n    QuasiDistribution: A dictionary containing pairs of [output, mean] where \"output\"\n        is the key in the dictionaries,\n        which is the length-N bitstring of a measured standard basis state,\n        and \"mean\" is the mean of non-zero quasi-probability estimates.",
        "api_signature": "quasi_probabilities(self, data, qubits, clbits, shots)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/mitigation/correlated_readout_mitigator.py"
    },
    {
        "api_name": "mitigation_matrix",
        "full_api_name": "CorrelatedReadoutMitigator.mitigation_matrix",
        "api_description": "Return the readout mitigation matrix for the specified qubits.\n\nThe mitigation matrix :math:`A^{-1}` is defined as the inverse of the\n:meth:`assignment_matrix` :math:`A`.\n\nArgs:\n    qubits: Optional, qubits being measured.\n\nReturns:\n    np.ndarray: the measurement error mitigation matrix :math:`A^{-1}`.",
        "api_signature": "mitigation_matrix(self, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/mitigation/correlated_readout_mitigator.py"
    },
    {
        "api_name": "assignment_matrix",
        "full_api_name": "CorrelatedReadoutMitigator.assignment_matrix",
        "api_description": "Return the readout assignment matrix for specified qubits.\n\nThe assignment matrix is the stochastic matrix :math:`A` which assigns\na noisy readout probability distribution to an ideal input\nreadout distribution: :math:`P(i|j) = \\langle i | A | j \\rangle`.\n\nArgs:\n    qubits: Optional, qubits being measured.\n\nReturns:\n    np.ndarray: the assignment matrix A.",
        "api_signature": "assignment_matrix(self, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/mitigation/correlated_readout_mitigator.py"
    },
    {
        "api_name": "_keep_indexes",
        "full_api_name": "CorrelatedReadoutMitigator._keep_indexes",
        "api_description": "",
        "api_signature": "_keep_indexes(qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/mitigation/correlated_readout_mitigator.py"
    },
    {
        "api_name": "_compute_gamma",
        "full_api_name": "CorrelatedReadoutMitigator._compute_gamma",
        "api_description": "Compute gamma for N-qubit mitigation",
        "api_signature": "_compute_gamma(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/mitigation/correlated_readout_mitigator.py"
    },
    {
        "api_name": "stddev_upper_bound",
        "full_api_name": "CorrelatedReadoutMitigator.stddev_upper_bound",
        "api_description": "Return an upper bound on standard deviation of expval estimator.\n\nArgs:\n    shots: Number of shots used for expectation value measurement.\n\nReturns:\n    float: the standard deviation upper bound.",
        "api_signature": "stddev_upper_bound(self, shots)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/mitigation/correlated_readout_mitigator.py"
    },
    {
        "api_name": "qubits",
        "full_api_name": "CorrelatedReadoutMitigator.qubits",
        "api_description": "The device qubits for this mitigator",
        "api_signature": "qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/mitigation/correlated_readout_mitigator.py"
    },
    {
        "api_name": "quasi_probabilities",
        "full_api_name": "BaseReadoutMitigator.quasi_probabilities",
        "api_description": "Convert counts to a dictionary of quasi-probabilities\n\nArgs:\n    data: Counts to be mitigated.\n    qubits: the physical qubits measured to obtain the counts clbits.\n        If None these are assumed to be qubits [0, ..., N-1]\n        for N-bit counts.\n    clbits: Optional, marginalize counts to just these bits.\n    shots: Optional, the total number of shots, if None shots will\n        be calculated as the sum of all counts.\n\nReturns:\n    QuasiDistribution: A dictionary containing pairs of [output, mean] where \"output\"\n        is the key in the dictionaries,\n        which is the length-N bitstring of a measured standard basis state,\n        and \"mean\" is the mean of non-zero quasi-probability estimates.",
        "api_signature": "quasi_probabilities(self, data, qubits, clbits, shots)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/mitigation/base_readout_mitigator.py"
    },
    {
        "api_name": "expectation_value",
        "full_api_name": "BaseReadoutMitigator.expectation_value",
        "api_description": "Calculate the expectation value of a diagonal Hermitian operator.\n\nArgs:\n    data: Counts object to be mitigated.\n    diagonal: the diagonal operator. This may either be specified\n              as a string containing I,Z,0,1 characters, or as a\n              real valued 1D array_like object supplying the full diagonal,\n              or as a dictionary, or as Callable.\n    qubits: the physical qubits measured to obtain the counts clbits.\n            If None these are assumed to be qubits [0, ..., N-1]\n            for N-bit counts.\n    clbits: Optional, marginalize counts to just these bits.\n    shots: Optional, the total number of shots, if None shots will\n        be calculated as the sum of all counts.\n\nReturns:\n    The mean and an upper bound of the standard deviation of operator\n    expectation value calculated from the current counts.",
        "api_signature": "expectation_value(self, data, diagonal, qubits, clbits, shots)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/mitigation/base_readout_mitigator.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "LocalReadoutMitigator.__init__",
        "api_description": "Initialize a LocalReadoutMitigator\n\nArgs:\n    assignment_matrices: Optional, list of single-qubit readout error assignment matrices.\n    qubits: Optional, the measured physical qubits for mitigation.\n    backend: Optional, backend name.\n\nRaises:\n    QiskitError: matrices sizes do not agree with number of qubits",
        "api_signature": "__init__(self, assignment_matrices, qubits, backend)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/mitigation/local_readout_mitigator.py"
    },
    {
        "api_name": "settings",
        "full_api_name": "LocalReadoutMitigator.settings",
        "api_description": "Return settings.",
        "api_signature": "settings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/mitigation/local_readout_mitigator.py"
    },
    {
        "api_name": "expectation_value",
        "full_api_name": "LocalReadoutMitigator.expectation_value",
        "api_description": "Compute the mitigated expectation value of a diagonal observable.\n\nThis computes the mitigated estimator of\n:math:`\\langle O \\rangle = \\mbox{Tr}[\\rho. O]` of a diagonal observable\n:math:`O = \\sum_{x\\in\\{0, 1\\}^n} O(x)|x\\rangle\\!\\langle x|`.\n\nArgs:\n    data: Counts object\n    diagonal: Optional, the vector of diagonal values for summing the\n              expectation value. If ``None`` the default value is\n              :math:`[1, -1]^\\otimes n`.\n    qubits: Optional, the measured physical qubits the count\n            bitstrings correspond to. If None qubits are assumed to be\n            :math:`[0, ..., n-1]`.\n    clbits: Optional, if not None marginalize counts to the specified bits.\n    shots: the number of shots.\n\nReturns:\n    (float, float): the expectation value and an upper bound of the standard deviation.\n\nAdditional Information:\n    The diagonal observable :math:`O` is input using the ``diagonal`` kwarg as\n    a list or Numpy array :math:`[O(0), ..., O(2^n -1)]`. If no diagonal is specified\n    the diagonal of the Pauli operator\n    :math`O = \\mbox{diag}(Z^{\\otimes n}) = [1, -1]^{\\otimes n}` is used.\n    The ``clbits`` kwarg is used to marginalize the input counts dictionary\n    over the specified bit-values, and the ``qubits`` kwarg is used to specify\n    which physical qubits these bit-values correspond to as\n    ``circuit.measure(qubits, clbits)``.",
        "api_signature": "expectation_value(self, data, diagonal, qubits, clbits, shots)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/mitigation/local_readout_mitigator.py"
    },
    {
        "api_name": "quasi_probabilities",
        "full_api_name": "LocalReadoutMitigator.quasi_probabilities",
        "api_description": "Compute mitigated quasi probabilities value.\n\nArgs:\n    data: counts object\n    qubits: qubits the count bitstrings correspond to.\n    clbits: Optional, marginalize counts to just these bits.\n    shots: Optional, the total number of shots, if None shots will\n        be calculated as the sum of all counts.\n\nReturns:\n    QuasiDistribution: A dictionary containing pairs of [output, mean] where \"output\"\n        is the key in the dictionaries,\n        which is the length-N bitstring of a measured standard basis state,\n        and \"mean\" is the mean of non-zero quasi-probability estimates.\n\nRaises:\n    QiskitError: if qubit and clbit kwargs are not valid.",
        "api_signature": "quasi_probabilities(self, data, qubits, clbits, shots)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/mitigation/local_readout_mitigator.py"
    },
    {
        "api_name": "mitigation_matrix",
        "full_api_name": "LocalReadoutMitigator.mitigation_matrix",
        "api_description": "Return the measurement mitigation matrix for the specified qubits.\n\nThe mitigation matrix :math:`A^{-1}` is defined as the inverse of the\n:meth:`assignment_matrix` :math:`A`.\n\nArgs:\n    qubits: Optional, qubits being measured for operator expval.\n            if a single int is given, it is assumed to be the index\n            of the qubit in self._qubits\n\nReturns:\n    np.ndarray: the measurement error mitigation matrix :math:`A^{-1}`.",
        "api_signature": "mitigation_matrix(self, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/mitigation/local_readout_mitigator.py"
    },
    {
        "api_name": "assignment_matrix",
        "full_api_name": "LocalReadoutMitigator.assignment_matrix",
        "api_description": "Return the measurement assignment matrix for specified qubits.\n\nThe assignment matrix is the stochastic matrix :math:`A` which assigns\na noisy measurement probability distribution to an ideal input\nmeasurement distribution: :math:`P(i|j) = \\langle i | A | j \\rangle`.\n\nArgs:\n    qubits: Optional, qubits being measured for operator expval.\n\nReturns:\n    np.ndarray: the assignment matrix A.",
        "api_signature": "assignment_matrix(self, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/mitigation/local_readout_mitigator.py"
    },
    {
        "api_name": "_compute_gamma",
        "full_api_name": "LocalReadoutMitigator._compute_gamma",
        "api_description": "Compute gamma for N-qubit mitigation",
        "api_signature": "_compute_gamma(self, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/mitigation/local_readout_mitigator.py"
    },
    {
        "api_name": "stddev_upper_bound",
        "full_api_name": "LocalReadoutMitigator.stddev_upper_bound",
        "api_description": "Return an upper bound on standard deviation of expval estimator.\n\nArgs:\n    shots: Number of shots used for expectation value measurement.\n    qubits: qubits being measured for operator expval.\n\nReturns:\n    float: the standard deviation upper bound.",
        "api_signature": "stddev_upper_bound(self, shots, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/mitigation/local_readout_mitigator.py"
    },
    {
        "api_name": "_from_backend",
        "full_api_name": "LocalReadoutMitigator._from_backend",
        "api_description": "Calculates amats from backend properties readout_error",
        "api_signature": "_from_backend(self, backend, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/mitigation/local_readout_mitigator.py"
    },
    {
        "api_name": "qubits",
        "full_api_name": "LocalReadoutMitigator.qubits",
        "api_description": "The device qubits for this mitigator",
        "api_signature": "qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/mitigation/local_readout_mitigator.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BasicPrinter.__init__",
        "api_description": "Args:\n    stream (io.TextIOBase): the stream that the output will be written to.\n    indent (str): the string to use as a single indentation level.\n    chain_else_if (bool): If ``True``, then constructs of the form::\n\n            if (x == 0) {\n                // ...\n            } else {\n                if (x == 1) {\n                    // ...\n                } else {\n                    // ...\n                }\n            }\n\n        will be collapsed into the equivalent but flatter::\n\n            if (x == 0) {\n                // ...\n            } else if (x == 1) {\n                // ...\n            } else {\n                // ...\n            }\n\n        This collapsed form may have less support on backends, so it is turned off by\n        default.  While the output of this printer is always unambiguous, using ``else``\n        without immediately opening an explicit scope with ``{ }`` in nested contexts can\n        cause issues, in the general case, which is why it is sometimes less supported.",
        "api_signature": "__init__(self, stream)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "visit",
        "full_api_name": "BasicPrinter.visit",
        "api_description": "Visit this node of the AST, printing it out to the stream in this class instance.\n\nNormally, you will want to call this function on a complete :obj:`~qiskit.qasm3.ast.Program`\nnode, to print out a complete program to the stream.  The visit can start from any node,\nhowever, if you want to build up a file bit-by-bit manually.\n\nArgs:\n    node (ASTNode): the node to convert to OpenQASM 3 and write out to the stream.\n\nRaises:\n    RuntimeError: if an AST node is encountered that the visitor is unable to parse.  This\n        typically means that the given AST was malformed.",
        "api_signature": "visit(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_start_line",
        "full_api_name": "BasicPrinter._start_line",
        "api_description": "",
        "api_signature": "_start_line(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_end_statement",
        "full_api_name": "BasicPrinter._end_statement",
        "api_description": "",
        "api_signature": "_end_statement(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_end_line",
        "full_api_name": "BasicPrinter._end_line",
        "api_description": "",
        "api_signature": "_end_line(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_write_statement",
        "full_api_name": "BasicPrinter._write_statement",
        "api_description": "",
        "api_signature": "_write_statement(self, line)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_sequence",
        "full_api_name": "BasicPrinter._visit_sequence",
        "api_description": "",
        "api_signature": "_visit_sequence(self, nodes)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_Program",
        "full_api_name": "BasicPrinter._visit_Program",
        "api_description": "",
        "api_signature": "_visit_Program(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_Header",
        "full_api_name": "BasicPrinter._visit_Header",
        "api_description": "",
        "api_signature": "_visit_Header(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_Version",
        "full_api_name": "BasicPrinter._visit_Version",
        "api_description": "",
        "api_signature": "_visit_Version(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_Include",
        "full_api_name": "BasicPrinter._visit_Include",
        "api_description": "",
        "api_signature": "_visit_Include(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_Pragma",
        "full_api_name": "BasicPrinter._visit_Pragma",
        "api_description": "",
        "api_signature": "_visit_Pragma(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_CalibrationGrammarDeclaration",
        "full_api_name": "BasicPrinter._visit_CalibrationGrammarDeclaration",
        "api_description": "",
        "api_signature": "_visit_CalibrationGrammarDeclaration(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_FloatType",
        "full_api_name": "BasicPrinter._visit_FloatType",
        "api_description": "",
        "api_signature": "_visit_FloatType(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_IntType",
        "full_api_name": "BasicPrinter._visit_IntType",
        "api_description": "",
        "api_signature": "_visit_IntType(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_BitType",
        "full_api_name": "BasicPrinter._visit_BitType",
        "api_description": "",
        "api_signature": "_visit_BitType(self, _node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_BitArrayType",
        "full_api_name": "BasicPrinter._visit_BitArrayType",
        "api_description": "",
        "api_signature": "_visit_BitArrayType(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_StringifyAndPray",
        "full_api_name": "BasicPrinter._visit_StringifyAndPray",
        "api_description": "",
        "api_signature": "_visit_StringifyAndPray(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_Identifier",
        "full_api_name": "BasicPrinter._visit_Identifier",
        "api_description": "",
        "api_signature": "_visit_Identifier(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_SubscriptedIdentifier",
        "full_api_name": "BasicPrinter._visit_SubscriptedIdentifier",
        "api_description": "",
        "api_signature": "_visit_SubscriptedIdentifier(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_Constant",
        "full_api_name": "BasicPrinter._visit_Constant",
        "api_description": "",
        "api_signature": "_visit_Constant(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_Range",
        "full_api_name": "BasicPrinter._visit_Range",
        "api_description": "",
        "api_signature": "_visit_Range(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_IndexSet",
        "full_api_name": "BasicPrinter._visit_IndexSet",
        "api_description": "",
        "api_signature": "_visit_IndexSet(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_QuantumMeasurement",
        "full_api_name": "BasicPrinter._visit_QuantumMeasurement",
        "api_description": "",
        "api_signature": "_visit_QuantumMeasurement(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_QuantumMeasurementAssignment",
        "full_api_name": "BasicPrinter._visit_QuantumMeasurementAssignment",
        "api_description": "",
        "api_signature": "_visit_QuantumMeasurementAssignment(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_QuantumReset",
        "full_api_name": "BasicPrinter._visit_QuantumReset",
        "api_description": "",
        "api_signature": "_visit_QuantumReset(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_QuantumDelay",
        "full_api_name": "BasicPrinter._visit_QuantumDelay",
        "api_description": "",
        "api_signature": "_visit_QuantumDelay(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_IntegerLiteral",
        "full_api_name": "BasicPrinter._visit_IntegerLiteral",
        "api_description": "",
        "api_signature": "_visit_IntegerLiteral(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_BooleanLiteral",
        "full_api_name": "BasicPrinter._visit_BooleanLiteral",
        "api_description": "",
        "api_signature": "_visit_BooleanLiteral(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_BitstringLiteral",
        "full_api_name": "BasicPrinter._visit_BitstringLiteral",
        "api_description": "",
        "api_signature": "_visit_BitstringLiteral(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_DurationLiteral",
        "full_api_name": "BasicPrinter._visit_DurationLiteral",
        "api_description": "",
        "api_signature": "_visit_DurationLiteral(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_Designator",
        "full_api_name": "BasicPrinter._visit_Designator",
        "api_description": "",
        "api_signature": "_visit_Designator(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_Unary",
        "full_api_name": "BasicPrinter._visit_Unary",
        "api_description": "",
        "api_signature": "_visit_Unary(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_Binary",
        "full_api_name": "BasicPrinter._visit_Binary",
        "api_description": "",
        "api_signature": "_visit_Binary(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_Cast",
        "full_api_name": "BasicPrinter._visit_Cast",
        "api_description": "",
        "api_signature": "_visit_Cast(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_ClassicalDeclaration",
        "full_api_name": "BasicPrinter._visit_ClassicalDeclaration",
        "api_description": "",
        "api_signature": "_visit_ClassicalDeclaration(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_AssignmentStatement",
        "full_api_name": "BasicPrinter._visit_AssignmentStatement",
        "api_description": "",
        "api_signature": "_visit_AssignmentStatement(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_IODeclaration",
        "full_api_name": "BasicPrinter._visit_IODeclaration",
        "api_description": "",
        "api_signature": "_visit_IODeclaration(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_QuantumDeclaration",
        "full_api_name": "BasicPrinter._visit_QuantumDeclaration",
        "api_description": "",
        "api_signature": "_visit_QuantumDeclaration(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_AliasStatement",
        "full_api_name": "BasicPrinter._visit_AliasStatement",
        "api_description": "",
        "api_signature": "_visit_AliasStatement(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_QuantumGateModifier",
        "full_api_name": "BasicPrinter._visit_QuantumGateModifier",
        "api_description": "",
        "api_signature": "_visit_QuantumGateModifier(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_QuantumGateCall",
        "full_api_name": "BasicPrinter._visit_QuantumGateCall",
        "api_description": "",
        "api_signature": "_visit_QuantumGateCall(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_QuantumBarrier",
        "full_api_name": "BasicPrinter._visit_QuantumBarrier",
        "api_description": "",
        "api_signature": "_visit_QuantumBarrier(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_ProgramBlock",
        "full_api_name": "BasicPrinter._visit_ProgramBlock",
        "api_description": "",
        "api_signature": "_visit_ProgramBlock(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_ReturnStatement",
        "full_api_name": "BasicPrinter._visit_ReturnStatement",
        "api_description": "",
        "api_signature": "_visit_ReturnStatement(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_QuantumArgument",
        "full_api_name": "BasicPrinter._visit_QuantumArgument",
        "api_description": "",
        "api_signature": "_visit_QuantumArgument(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_QuantumGateSignature",
        "full_api_name": "BasicPrinter._visit_QuantumGateSignature",
        "api_description": "",
        "api_signature": "_visit_QuantumGateSignature(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_QuantumGateDefinition",
        "full_api_name": "BasicPrinter._visit_QuantumGateDefinition",
        "api_description": "",
        "api_signature": "_visit_QuantumGateDefinition(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_CalibrationDefinition",
        "full_api_name": "BasicPrinter._visit_CalibrationDefinition",
        "api_description": "",
        "api_signature": "_visit_CalibrationDefinition(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_BreakStatement",
        "full_api_name": "BasicPrinter._visit_BreakStatement",
        "api_description": "",
        "api_signature": "_visit_BreakStatement(self, _node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_ContinueStatement",
        "full_api_name": "BasicPrinter._visit_ContinueStatement",
        "api_description": "",
        "api_signature": "_visit_ContinueStatement(self, _node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_BranchingStatement",
        "full_api_name": "BasicPrinter._visit_BranchingStatement",
        "api_description": "",
        "api_signature": "_visit_BranchingStatement(self, node, chained)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_ForLoopStatement",
        "full_api_name": "BasicPrinter._visit_ForLoopStatement",
        "api_description": "",
        "api_signature": "_visit_ForLoopStatement(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_WhileLoopStatement",
        "full_api_name": "BasicPrinter._visit_WhileLoopStatement",
        "api_description": "",
        "api_signature": "_visit_WhileLoopStatement(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_SwitchStatement",
        "full_api_name": "BasicPrinter._visit_SwitchStatement",
        "api_description": "",
        "api_signature": "_visit_SwitchStatement(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_DefaultCase",
        "full_api_name": "BasicPrinter._visit_DefaultCase",
        "api_description": "",
        "api_signature": "_visit_DefaultCase(self, _node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Pragma.__init__",
        "api_description": "",
        "api_signature": "__init__(self, content)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CalibrationGrammarDeclaration.__init__",
        "api_description": "",
        "api_signature": "__init__(self, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Program.__init__",
        "api_description": "",
        "api_signature": "__init__(self, header, statements)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Header.__init__",
        "api_description": "",
        "api_signature": "__init__(self, version, includes)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Include.__init__",
        "api_description": "",
        "api_signature": "__init__(self, filename)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Version.__init__",
        "api_description": "",
        "api_signature": "__init__(self, version_number)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "IntType.__init__",
        "api_description": "",
        "api_signature": "__init__(self, size)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BitArrayType.__init__",
        "api_description": "",
        "api_signature": "__init__(self, size)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "StringifyAndPray.__init__",
        "api_description": "",
        "api_signature": "__init__(self, obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Range.__init__",
        "api_description": "",
        "api_signature": "__init__(self, start, end, step)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Identifier.__init__",
        "api_description": "",
        "api_signature": "__init__(self, string)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SubscriptedIdentifier.__init__",
        "api_description": "",
        "api_signature": "__init__(self, string, subscript)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "IntegerLiteral.__init__",
        "api_description": "",
        "api_signature": "__init__(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BooleanLiteral.__init__",
        "api_description": "",
        "api_signature": "__init__(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BitstringLiteral.__init__",
        "api_description": "",
        "api_signature": "__init__(self, value, width)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "DurationLiteral.__init__",
        "api_description": "",
        "api_signature": "__init__(self, value, unit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "__init__",
        "api_description": "",
        "api_signature": "__init__(self, op, operand)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "__init__",
        "api_description": "",
        "api_signature": "__init__(self, op, left, right)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Cast.__init__",
        "api_description": "",
        "api_signature": "__init__(self, type, operand)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "IndexSet.__init__",
        "api_description": "",
        "api_signature": "__init__(self, values)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QuantumMeasurement.__init__",
        "api_description": "",
        "api_signature": "__init__(self, identifierList)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QuantumMeasurementAssignment.__init__",
        "api_description": "",
        "api_signature": "__init__(self, identifier, quantumMeasurement)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Designator.__init__",
        "api_description": "",
        "api_signature": "__init__(self, expression)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ClassicalDeclaration.__init__",
        "api_description": "",
        "api_signature": "__init__(self, type_, identifier, initializer)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "AssignmentStatement.__init__",
        "api_description": "",
        "api_signature": "__init__(self, lvalue, rvalue)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QuantumDeclaration.__init__",
        "api_description": "",
        "api_signature": "__init__(self, identifier, designator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "AliasStatement.__init__",
        "api_description": "",
        "api_signature": "__init__(self, identifier, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QuantumGateModifier.__init__",
        "api_description": "",
        "api_signature": "__init__(self, modifier, argument)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QuantumGateCall.__init__",
        "api_description": "",
        "api_signature": "__init__(self, quantumGateName, indexIdentifierList, parameters, modifiers)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QuantumBarrier.__init__",
        "api_description": "",
        "api_signature": "__init__(self, indexIdentifierList)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QuantumReset.__init__",
        "api_description": "",
        "api_signature": "__init__(self, identifier)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QuantumDelay.__init__",
        "api_description": "",
        "api_signature": "__init__(self, duration, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ProgramBlock.__init__",
        "api_description": "",
        "api_signature": "__init__(self, statements)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ReturnStatement.__init__",
        "api_description": "",
        "api_signature": "__init__(self, expression)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QuantumGateSignature.__init__",
        "api_description": "",
        "api_signature": "__init__(self, name, qargList, params)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QuantumGateDefinition.__init__",
        "api_description": "",
        "api_signature": "__init__(self, quantumGateSignature, quantumBlock)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SubroutineDefinition.__init__",
        "api_description": "",
        "api_signature": "__init__(self, identifier, subroutineBlock, arguments)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CalibrationDefinition.__init__",
        "api_description": "",
        "api_signature": "__init__(self, name, identifierList, calibrationArgumentList)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BranchingStatement.__init__",
        "api_description": "",
        "api_signature": "__init__(self, condition, true_body, false_body)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ForLoopStatement.__init__",
        "api_description": "",
        "api_signature": "__init__(self, indexset, parameter, body)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "WhileLoopStatement.__init__",
        "api_description": "",
        "api_signature": "__init__(self, condition, body)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "IODeclaration.__init__",
        "api_description": "",
        "api_signature": "__init__(self, modifier, type_, identifier)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SwitchStatement.__init__",
        "api_description": "",
        "api_signature": "__init__(self, target, cases)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "dumps",
        "full_api_name": "dumps",
        "api_description": "Serialize a :class:`~qiskit.circuit.QuantumCircuit` object in an OpenQASM 3 string.\n\nArgs:\n    circuit (QuantumCircuit): Circuit to serialize.\n    **kwargs: Arguments for the :obj:`.Exporter` constructor.\n\nReturns:\n    str: The OpenQASM 3 serialization",
        "api_signature": "dumps(circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/__init__.py"
    },
    {
        "api_name": "dump",
        "full_api_name": "dump",
        "api_description": "Serialize a :class:`~qiskit.circuit.QuantumCircuit` object as an OpenQASM 3 stream to\nfile-like object.\n\nArgs:\n    circuit (QuantumCircuit): Circuit to serialize.\n    stream (TextIOBase): stream-like object to dump the OpenQASM 3 serialization\n    **kwargs: Arguments for the :obj:`.Exporter` constructor.",
        "api_signature": "dump(circuit, stream)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/__init__.py"
    },
    {
        "api_name": "load",
        "full_api_name": "load",
        "api_description": "Load an OpenQASM 3 program from the file ``filename``.\n\nArgs:\n    filename: the filename to load the program from.\n\nReturns:\n    QuantumCircuit: a circuit representation of the OpenQASM 3 program.\n\nRaises:\n    QASM3ImporterError: if the OpenQASM 3 file is invalid, or cannot be represented by a\n        :class:`.QuantumCircuit`.",
        "api_signature": "load(filename)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/__init__.py"
    },
    {
        "api_name": "loads",
        "full_api_name": "loads",
        "api_description": "Load an OpenQASM 3 program from the given string.\n\nArgs:\n    program: the OpenQASM 3 program.\n\nReturns:\n    QuantumCircuit: a circuit representation of the OpenQASM 3 program.\n\nRaises:\n    QASM3ImporterError: if the OpenQASM 3 file is invalid, or cannot be represented by a\n        :class:`.QuantumCircuit`.",
        "api_signature": "loads(program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/__init__.py"
    },
    {
        "api_name": "_escape_invalid_identifier",
        "full_api_name": "_escape_invalid_identifier",
        "api_description": "",
        "api_signature": "_escape_invalid_identifier(name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Exporter.__init__",
        "api_description": "Args:\n    includes: the filenames that should be emitted as includes.  These files will be parsed\n        for gates, and any objects dumped from this exporter will use those definitions\n        where possible.\n    basis_gates: the basic defined gate set of the backend.\n    disable_constants: if ``True``, always emit floating-point constants for numeric\n        parameter values.  If ``False`` (the default), then values close to multiples of\n        OpenQASM 3 constants (``pi``, ``euler``, and ``tau``) will be emitted in terms of those\n        constants instead, potentially improving accuracy in the output.\n    alias_classical_registers: If ``True``, then bits may be contained in more than one\n        register.  If so, the registers will be emitted using \"alias\" definitions, which\n        might not be well supported by consumers of OpenQASM 3.\n\n        .. seealso::\n            Parameter ``allow_aliasing``\n                A value for ``allow_aliasing`` overrides any value given here, and\n                supersedes this parameter.\n    allow_aliasing: If ``True``, then bits may be contained in more than one register.  If\n        so, the registers will be emitted using \"alias\" definitions, which might not be\n        well supported by consumers of OpenQASM 3.  Defaults to ``False`` or the value of\n        ``alias_classical_registers``.\n\n        .. versionadded:: 0.25.0\n    indent: the indentation string to use for each level within an indented block.  Can be\n        set to the empty string to disable indentation.\n    experimental: any experimental features to enable during the export.  See\n        :class:`ExperimentalFeatures` for more details.",
        "api_signature": "__init__(self, includes, basis_gates, disable_constants, alias_classical_registers, allow_aliasing, indent, experimental)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "dumps",
        "full_api_name": "Exporter.dumps",
        "api_description": "Convert the circuit to OpenQASM 3, returning the result as a string.",
        "api_signature": "dumps(self, circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "dump",
        "full_api_name": "Exporter.dump",
        "api_description": "Convert the circuit to OpenQASM 3, dumping the result to a file or text stream.",
        "api_signature": "dump(self, circuit, stream)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "GlobalNamespace.__init__",
        "api_description": "",
        "api_signature": "__init__(self, includelist, basis_gates)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "__setitem__",
        "full_api_name": "GlobalNamespace.__setitem__",
        "api_description": "",
        "api_signature": "__setitem__(self, name_str, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "__getitem__",
        "full_api_name": "GlobalNamespace.__getitem__",
        "api_description": "",
        "api_signature": "__getitem__(self, key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "__iter__",
        "full_api_name": "GlobalNamespace.__iter__",
        "api_description": "",
        "api_signature": "__iter__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "__contains__",
        "full_api_name": "GlobalNamespace.__contains__",
        "api_description": "",
        "api_signature": "__contains__(self, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "register",
        "full_api_name": "GlobalNamespace.register",
        "api_description": "Register an instruction in the namespace",
        "api_signature": "register(self, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QASM3Builder.__init__",
        "api_description": "",
        "api_signature": "__init__(self, quantumcircuit, includeslist, basis_gates, disable_constants, allow_aliasing, experimental)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "_unique_name",
        "full_api_name": "QASM3Builder._unique_name",
        "api_description": "",
        "api_signature": "_unique_name(self, prefix, scope)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "_register_gate",
        "full_api_name": "QASM3Builder._register_gate",
        "api_description": "",
        "api_signature": "_register_gate(self, gate)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "_register_opaque",
        "full_api_name": "QASM3Builder._register_opaque",
        "api_description": "",
        "api_signature": "_register_opaque(self, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "_register_variable",
        "full_api_name": "QASM3Builder._register_variable",
        "api_description": "Register a variable in the symbol table for the given scope, returning the name that\nshould be used to refer to the variable.  The same name will be returned by subsequent calls\nto :meth:`_lookup_variable` within the same scope.\n\nIf ``name`` is given explicitly, it must not already be defined in the scope.",
        "api_signature": "_register_variable(self, variable, scope, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "_reserve_variable_name",
        "full_api_name": "QASM3Builder._reserve_variable_name",
        "api_description": "Reserve a variable name in the given scope, raising a :class:`.QASM3ExporterError` if\nthe name is already in use.\n\nThis is useful for autogenerated names that the exporter itself reserves when dealing with\nobjects that have no standard Terra object backing them.\n\nReturns the same identifier, for convenience in chaining.",
        "api_signature": "_reserve_variable_name(self, name, scope)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "_lookup_variable",
        "full_api_name": "QASM3Builder._lookup_variable",
        "api_description": "Lookup a Terra object within the current context, and return the name that should be used\nto represent it in OpenQASM 3 programmes.",
        "api_signature": "_lookup_variable(self, variable)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "build_header",
        "full_api_name": "QASM3Builder.build_header",
        "api_description": "Builds a Header",
        "api_signature": "build_header(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "build_program",
        "full_api_name": "QASM3Builder.build_program",
        "api_description": "Builds a Program",
        "api_signature": "build_program(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "hoist_declarations",
        "full_api_name": "QASM3Builder.hoist_declarations",
        "api_description": "Walks the definitions in gates/instructions to make a list of gates to declare.",
        "api_signature": "hoist_declarations(self, instructions)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "global_scope",
        "full_api_name": "QASM3Builder.global_scope",
        "api_description": "Return the global circuit scope that is used as the basis of the full program.  If\n``assert_=True``, then this raises :obj:`.QASM3ExporterError` if the current context is not\nthe global one.",
        "api_signature": "global_scope(self, assert_)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "current_scope",
        "full_api_name": "QASM3Builder.current_scope",
        "api_description": "Return the current circuit scope.",
        "api_signature": "current_scope(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "current_context",
        "full_api_name": "QASM3Builder.current_context",
        "api_description": "Return the current context (list of scopes).",
        "api_signature": "current_context(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "push_scope",
        "full_api_name": "QASM3Builder.push_scope",
        "api_description": "Push a new scope (like a ``for`` or ``while`` loop body) onto the current context\nstack.",
        "api_signature": "push_scope(self, circuit, qubits, clbits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "pop_scope",
        "full_api_name": "QASM3Builder.pop_scope",
        "api_description": "Pop the current scope (like a ``for`` or ``while`` loop body) off the current context\nstack.",
        "api_signature": "pop_scope(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "push_context",
        "full_api_name": "QASM3Builder.push_context",
        "api_description": "Push a new context (like for a ``gate`` or ``def`` body) onto the stack.",
        "api_signature": "push_context(self, outer_context)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "pop_context",
        "full_api_name": "QASM3Builder.pop_context",
        "api_description": "Pop the current context (like for a ``gate`` or ``def`` body) onto the stack.",
        "api_signature": "pop_context(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "build_includes",
        "full_api_name": "QASM3Builder.build_includes",
        "api_description": "Builds a list of included files.",
        "api_signature": "build_includes(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "build_global_statements",
        "full_api_name": "QASM3Builder.build_global_statements",
        "api_description": "Get a list of the statements that form the global scope of the program.",
        "api_signature": "build_global_statements(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "build_definitions",
        "full_api_name": "QASM3Builder.build_definitions",
        "api_description": "Builds all the definition.",
        "api_signature": "build_definitions(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "build_opaque_definition",
        "full_api_name": "QASM3Builder.build_opaque_definition",
        "api_description": "Builds an Opaque gate definition as a CalibrationDefinition",
        "api_signature": "build_opaque_definition(self, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "build_gate_definition",
        "full_api_name": "QASM3Builder.build_gate_definition",
        "api_description": "Builds a QuantumGateDefinition",
        "api_signature": "build_gate_definition(self, gate)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "build_gate_signature",
        "full_api_name": "QASM3Builder.build_gate_signature",
        "api_description": "Builds a QuantumGateSignature",
        "api_signature": "build_gate_signature(self, gate)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "build_parameter_declarations",
        "full_api_name": "QASM3Builder.build_parameter_declarations",
        "api_description": "Builds lists of the input, output and standard variables used in this program.",
        "api_signature": "build_parameter_declarations(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "build_classical_declarations",
        "full_api_name": "QASM3Builder.build_classical_declarations",
        "api_description": "Extend the global classical declarations with AST nodes declaring all the classical bits\nand registers.\n\nThe behaviour of this function depends on the setting ``allow_aliasing``. If this\nis ``True``, then the output will be in the same form as the output of\n:meth:`.build_classical_declarations`, with the registers being aliases.  If ``False``, it\nwill instead return a :obj:`.ast.ClassicalDeclaration` for each classical register, and one\nfor the loose :obj:`.Clbit` instances, and will raise :obj:`QASM3ExporterError` if any\nregisters overlap.",
        "api_signature": "build_classical_declarations(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "build_quantum_declarations",
        "full_api_name": "QASM3Builder.build_quantum_declarations",
        "api_description": "Return a list of AST nodes declaring all the qubits in the current scope, and all the\nalias declarations for these qubits.",
        "api_signature": "build_quantum_declarations(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "build_aliases",
        "full_api_name": "QASM3Builder.build_aliases",
        "api_description": "Return a list of alias declarations for the given registers.  The registers can be either\nclassical or quantum.",
        "api_signature": "build_aliases(self, registers)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "build_quantum_instructions",
        "full_api_name": "QASM3Builder.build_quantum_instructions",
        "api_description": "Builds a list of call statements",
        "api_signature": "build_quantum_instructions(self, instructions)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "build_if_statement",
        "full_api_name": "QASM3Builder.build_if_statement",
        "api_description": "Build an :obj:`.IfElseOp` into a :obj:`.ast.BranchingStatement`.",
        "api_signature": "build_if_statement(self, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "build_switch_statement",
        "full_api_name": "QASM3Builder.build_switch_statement",
        "api_description": "Build a :obj:`.SwitchCaseOp` into a :class:`.ast.SwitchStatement`.",
        "api_signature": "build_switch_statement(self, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "case",
        "full_api_name": "QASM3Builder.case",
        "api_description": "",
        "api_signature": "case(values, case_block)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "build_while_loop",
        "full_api_name": "QASM3Builder.build_while_loop",
        "api_description": "Build a :obj:`.WhileLoopOp` into a :obj:`.ast.WhileLoopStatement`.",
        "api_signature": "build_while_loop(self, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "build_for_loop",
        "full_api_name": "QASM3Builder.build_for_loop",
        "api_description": "Build a :obj:`.ForLoopOp` into a :obj:`.ast.ForLoopStatement`.",
        "api_signature": "build_for_loop(self, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "build_expression",
        "full_api_name": "QASM3Builder.build_expression",
        "api_description": "Build an expression.",
        "api_signature": "build_expression(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "build_delay",
        "full_api_name": "QASM3Builder.build_delay",
        "api_description": "Build a built-in delay statement.",
        "api_signature": "build_delay(self, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "build_integer",
        "full_api_name": "QASM3Builder.build_integer",
        "api_description": "Build an integer literal, raising a :obj:`.QASM3ExporterError` if the input is not\nactually an\ninteger.",
        "api_signature": "build_integer(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "build_program_block",
        "full_api_name": "QASM3Builder.build_program_block",
        "api_description": "Builds a ProgramBlock",
        "api_signature": "build_program_block(self, instructions)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "_rebind_scoped_parameters",
        "full_api_name": "QASM3Builder._rebind_scoped_parameters",
        "api_description": "If the input is a :class:`.ParameterExpression`, rebind any internal\n:class:`.Parameter`\\ s so that their names match their names in the scope.  Other inputs\nare returned unchanged.",
        "api_signature": "_rebind_scoped_parameters(self, expression)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "build_gate_call",
        "full_api_name": "QASM3Builder.build_gate_call",
        "api_description": "Builds a QuantumGateCall",
        "api_signature": "build_gate_call(self, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "_infer_variable_declaration",
        "full_api_name": "_infer_variable_declaration",
        "api_description": "Attempt to infer what type a parameter should be declared as to work with a circuit.\n\nThis is very simplistic; it assumes all parameters are real numbers that need to be input to the\nprogram, unless one is used as a loop variable, in which case it shouldn't be declared at all,\nbecause the ``for`` loop declares it implicitly (per the Qiskit/QSS reading of the OpenQASM\nspec at Qiskit/openqasm@8ee55ec).\n\n.. note::\n\n    This is a hack around not having a proper type system implemented in Terra, and really this\n    whole function should be removed in favour of proper symbol-table building and lookups.\n    This function is purely to try and hack the parameters for ``for`` loops into the exporter\n    for now.\n\nArgs:\n    circuit: The global-scope circuit, which is the base of the exported program.\n    parameter: The parameter to infer the type of.\n    parameter_name: The name of the parameter to use in the declaration.\n\nReturns:\n    A suitable :obj:`.ast.ClassicalDeclaration` node, or, if the parameter should *not* be\n    declared, then ``None``.",
        "api_signature": "_infer_variable_declaration(circuit, parameter, parameter_name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "is_loop_variable",
        "full_api_name": "is_loop_variable",
        "api_description": "Recurse into the instructions a parameter is used in, checking at every level if it is\nused as the loop variable of a ``for`` loop.",
        "api_signature": "is_loop_variable(circuit, parameter)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "_lift_condition",
        "full_api_name": "_lift_condition",
        "api_description": "",
        "api_signature": "_lift_condition(condition)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "_ExprBuilder.__init__",
        "api_description": "",
        "api_signature": "__init__(self, lookup)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "visit_var",
        "full_api_name": "_ExprBuilder.visit_var",
        "api_description": "",
        "api_signature": "visit_var()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "visit_value",
        "full_api_name": "_ExprBuilder.visit_value",
        "api_description": "",
        "api_signature": "visit_value()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "visit_cast",
        "full_api_name": "_ExprBuilder.visit_cast",
        "api_description": "",
        "api_signature": "visit_cast()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "visit_unary",
        "full_api_name": "_ExprBuilder.visit_unary",
        "api_description": "",
        "api_signature": "visit_unary()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "visit_binary",
        "full_api_name": "_ExprBuilder.visit_binary",
        "api_description": "",
        "api_signature": "visit_binary()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Layout.__init__",
        "api_description": "construct a Layout from a bijective dictionary, mapping\nvirtual qubits to physical qubits",
        "api_signature": "__init__(self, input_dict)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/layout.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "Layout.__repr__",
        "api_description": "Representation of a Layout",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/layout.py"
    },
    {
        "api_name": "from_dict",
        "full_api_name": "Layout.from_dict",
        "api_description": "Populates a Layout from a dictionary.\n\nThe dictionary must be a bijective mapping between\nvirtual qubits (tuple) and physical qubits (int).\n\nArgs:\n    input_dict (dict):\n        e.g.::\n\n        {(QuantumRegister(3, 'qr'), 0): 0,\n         (QuantumRegister(3, 'qr'), 1): 1,\n         (QuantumRegister(3, 'qr'), 2): 2}\n\n        Can be written more concisely as follows:\n\n        * virtual to physical::\n\n            {qr[0]: 0,\n             qr[1]: 1,\n             qr[2]: 2}\n\n        * physical to virtual::\n\n            {0: qr[0],\n             1: qr[1],\n             2: qr[2]}",
        "api_signature": "from_dict(self, input_dict)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/layout.py"
    },
    {
        "api_name": "order_based_on_type",
        "full_api_name": "Layout.order_based_on_type",
        "api_description": "decides which one is physical/virtual based on the type. Returns (virtual, physical)",
        "api_signature": "order_based_on_type(value1, value2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/layout.py"
    },
    {
        "api_name": "__getitem__",
        "full_api_name": "Layout.__getitem__",
        "api_description": "",
        "api_signature": "__getitem__(self, item)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/layout.py"
    },
    {
        "api_name": "__contains__",
        "full_api_name": "Layout.__contains__",
        "api_description": "",
        "api_signature": "__contains__(self, item)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/layout.py"
    },
    {
        "api_name": "__setitem__",
        "full_api_name": "Layout.__setitem__",
        "api_description": "",
        "api_signature": "__setitem__(self, key, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/layout.py"
    },
    {
        "api_name": "_set_type_checked_item",
        "full_api_name": "Layout._set_type_checked_item",
        "api_description": "",
        "api_signature": "_set_type_checked_item(self, virtual, physical)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/layout.py"
    },
    {
        "api_name": "__delitem__",
        "full_api_name": "Layout.__delitem__",
        "api_description": "",
        "api_signature": "__delitem__(self, key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/layout.py"
    },
    {
        "api_name": "__len__",
        "full_api_name": "Layout.__len__",
        "api_description": "",
        "api_signature": "__len__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/layout.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "Layout.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/layout.py"
    },
    {
        "api_name": "copy",
        "full_api_name": "Layout.copy",
        "api_description": "Returns a copy of a Layout instance.",
        "api_signature": "copy(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/layout.py"
    },
    {
        "api_name": "add",
        "full_api_name": "Layout.add",
        "api_description": "Adds a map element between `bit` and `physical_bit`. If `physical_bit` is not\ndefined, `bit` will be mapped to a new physical bit.\n\nArgs:\n    virtual_bit (tuple): A (qu)bit. For example, (QuantumRegister(3, 'qr'), 2).\n    physical_bit (int): A physical bit. For example, 3.",
        "api_signature": "add(self, virtual_bit, physical_bit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/layout.py"
    },
    {
        "api_name": "add_register",
        "full_api_name": "Layout.add_register",
        "api_description": "Adds at the end physical_qubits that map each bit in reg.\n\nArgs:\n    reg (Register): A (qu)bit Register. For example, QuantumRegister(3, 'qr').",
        "api_signature": "add_register(self, reg)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/layout.py"
    },
    {
        "api_name": "get_registers",
        "full_api_name": "Layout.get_registers",
        "api_description": "Returns the registers in the layout [QuantumRegister(2, 'qr0'), QuantumRegister(3, 'qr1')]\nReturns:\n    Set: A set of Registers in the layout",
        "api_signature": "get_registers(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/layout.py"
    },
    {
        "api_name": "get_virtual_bits",
        "full_api_name": "Layout.get_virtual_bits",
        "api_description": "Returns the dictionary where the keys are virtual (qu)bits and the\nvalues are physical (qu)bits.",
        "api_signature": "get_virtual_bits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/layout.py"
    },
    {
        "api_name": "get_physical_bits",
        "full_api_name": "Layout.get_physical_bits",
        "api_description": "Returns the dictionary where the keys are physical (qu)bits and the\nvalues are virtual (qu)bits.",
        "api_signature": "get_physical_bits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/layout.py"
    },
    {
        "api_name": "swap",
        "full_api_name": "Layout.swap",
        "api_description": "Swaps the map between left and right.\n\nArgs:\n    left (tuple or int): Item to swap with right.\n    right (tuple or int): Item to swap with left.\nRaises:\n    LayoutError: If left and right have not the same type.",
        "api_signature": "swap(self, left, right)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/layout.py"
    },
    {
        "api_name": "combine_into_edge_map",
        "full_api_name": "Layout.combine_into_edge_map",
        "api_description": "Combines self and another_layout into an \"edge map\".\n\nFor example::\n\n      self       another_layout  resulting edge map\n   qr_1 -> 0        0 <- q_2         qr_1 -> q_2\n   qr_2 -> 2        2 <- q_1         qr_2 -> q_1\n   qr_3 -> 3        3 <- q_0         qr_3 -> q_0\n\nThe edge map is used to compose dags via, for example, compose.\n\nArgs:\n    another_layout (Layout): The other layout to combine.\nReturns:\n    dict: A \"edge map\".\nRaises:\n    LayoutError: another_layout can be bigger than self, but not smaller.\n        Otherwise, raises.",
        "api_signature": "combine_into_edge_map(self, another_layout)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/layout.py"
    },
    {
        "api_name": "reorder_bits",
        "full_api_name": "Layout.reorder_bits",
        "api_description": "Given an ordered list of bits, reorder them according to this layout.\n\nThe list of bits must exactly match the virtual bits in this layout.\n\nArgs:\n    bits (list[Bit]): the bits to reorder.\n\nReturns:\n    List: ordered bits.",
        "api_signature": "reorder_bits(self, bits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/layout.py"
    },
    {
        "api_name": "generate_trivial_layout",
        "full_api_name": "Layout.generate_trivial_layout",
        "api_description": "Creates a trivial (\"one-to-one\") Layout with the registers and qubits in `regs`.\n\nArgs:\n    *regs (Registers, Qubits): registers and qubits to include in the layout.\nReturns:\n    Layout: A layout with all the `regs` in the given order.",
        "api_signature": "generate_trivial_layout()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/layout.py"
    },
    {
        "api_name": "from_intlist",
        "full_api_name": "Layout.from_intlist",
        "api_description": "Converts a list of integers to a Layout\nmapping virtual qubits (index of the list) to\nphysical qubits (the list values).\n\nArgs:\n    int_list (list): A list of integers.\n    *qregs (QuantumRegisters): The quantum registers to apply\n        the layout to.\nReturns:\n    Layout: The corresponding Layout object.\nRaises:\n    LayoutError: Invalid input layout.",
        "api_signature": "from_intlist(int_list)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/layout.py"
    },
    {
        "api_name": "from_qubit_list",
        "full_api_name": "Layout.from_qubit_list",
        "api_description": "Populates a Layout from a list containing virtual\nqubits, Qubit or None.\n\nArgs:\n    qubit_list (list):\n        e.g.: [qr[0], None, qr[2], qr[3]]\n    *qregs (QuantumRegisters): The quantum registers to apply\n        the layout to.\nReturns:\n    Layout: the corresponding Layout object\nRaises:\n    LayoutError: If the elements are not Qubit or None",
        "api_signature": "from_qubit_list(qubit_list)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/layout.py"
    },
    {
        "api_name": "initial_virtual_layout",
        "full_api_name": "TranspileLayout.initial_virtual_layout",
        "api_description": "Return a :class:`.Layout` object for the initial layout.\n\nThis returns a mapping of virtual :class:`~.Qubit` objects in the input\ncircuit to the physical qubit selected during layout. This is analogous\nto the :attr:`.initial_layout` attribute.\n\nArgs:\n    filter_ancillas: If set to ``True`` only qubits in the input circuit\n        will be in the returned layout. Any ancilla qubits added to the\n        output circuit will be filtered from the returned object.\nReturns:\n    A layout object mapping the input circuit's :class:`~.Qubit`\n    objects to the selected physical qubits.",
        "api_signature": "initial_virtual_layout(self, filter_ancillas)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/layout.py"
    },
    {
        "api_name": "initial_index_layout",
        "full_api_name": "TranspileLayout.initial_index_layout",
        "api_description": "Generate an initial layout as an array of integers\n\nArgs:\n    filter_ancillas: If set to ``True`` any ancilla qubits added\n        to the transpiler will not be included in the output.\n\nReturn:\n    A layout array that maps a position in the array to its new position in the output\n    circuit.",
        "api_signature": "initial_index_layout(self, filter_ancillas)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/layout.py"
    },
    {
        "api_name": "routing_permutation",
        "full_api_name": "TranspileLayout.routing_permutation",
        "api_description": "Generate a final layout as an array of integers\n\nIf there is no :attr:`.final_layout` attribute present then that indicates\nthere was no output permutation caused by routing or other transpiler\ntransforms. In this case the function will return a list of ``[0, 1, 2, .., n]``\nto indicate this\n\nReturns:\n    A layout array that maps a position in the array to its new position in the output\n    circuit",
        "api_signature": "routing_permutation(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/layout.py"
    },
    {
        "api_name": "final_index_layout",
        "full_api_name": "TranspileLayout.final_index_layout",
        "api_description": "Generate the final layout as an array of integers\n\nThis method will generate an array of final positions for each qubit in the output circuit.\nFor example, if you had an input circuit like::\n\n    qc = QuantumCircuit(3)\n    qc.h(0)\n    qc.cx(0, 1)\n    qc.cx(0, 2)\n\nand the output from the transpiler was::\n\n    tqc = QuantumCircuit(3)\n    qc.h(2)\n    qc.cx(2, 1)\n    qc.swap(0, 1)\n    qc.cx(2, 1)\n\nthen the return from this function would be a list of::\n\n    [2, 0, 1]\n\nbecause qubit 0 in the original circuit's final state is on qubit 3 in the output circuit,\nqubit 1 in the original circuit's final state is on qubit 0, and qubit 2's final state is\non qubit. The output list length will be as wide as the input circuit's number of qubits,\nas the output list from this method is for tracking the permutation of qubits in the\noriginal circuit caused by the transpiler.\n\nArgs:\n    filter_ancillas: If set to ``False`` any ancillas allocated in the output circuit will be\n        included in the layout.\n\nReturns:\n    A list of final positions for each input circuit qubit",
        "api_signature": "final_index_layout(self, filter_ancillas)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/layout.py"
    },
    {
        "api_name": "final_virtual_layout",
        "full_api_name": "TranspileLayout.final_virtual_layout",
        "api_description": "Generate the final layout as a :class:`.Layout` object\n\nThis method will generate an array of final positions for each qubit in the output circuit.\nFor example, if you had an input circuit like::\n\n    qc = QuantumCircuit(3)\n    qc.h(0)\n    qc.cx(0, 1)\n    qc.cx(0, 2)\n\nand the output from the transpiler was::\n\n    tqc = QuantumCircuit(3)\n    qc.h(2)\n    qc.cx(2, 1)\n    qc.swap(0, 1)\n    qc.cx(2, 1)\n\nthen the return from this function would be a layout object::\n\n    Layout({\n        qc.qubits[0]: 2,\n        qc.qubits[1]: 0,\n        qc.qubits[2]: 1,\n    })\n\nbecause qubit 0 in the original circuit's final state is on qubit 3 in the output circuit,\nqubit 1 in the original circuit's final state is on qubit 0, and qubit 2's final state is\non qubit. The output list length will be as wide as the input circuit's number of qubits,\nas the output list from this method is for tracking the permutation of qubits in the\noriginal circuit caused by the transpiler.\n\nArgs:\n    filter_ancillas: If set to ``False`` any ancillas allocated in the output circuit will be\n        included in the layout.\n\nReturns:\n    A layout object mapping to the final positions for each qubit",
        "api_signature": "final_virtual_layout(self, filter_ancillas)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/layout.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CouplingMap.__init__",
        "api_description": "Create coupling graph. By default, the generated coupling has no nodes.\n\nArgs:\n    couplinglist (list or None): An initial coupling graph, specified as\n        an adjacency list containing couplings, e.g. [[0,1], [0,2], [1,2]].\n        It is required that nodes are contiguously indexed starting at 0.\n        Missed nodes will be added as isolated nodes in the coupling map.\n    description (str): A string to describe the coupling map.",
        "api_signature": "__init__(self, couplinglist, description)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/coupling.py"
    },
    {
        "api_name": "size",
        "full_api_name": "CouplingMap.size",
        "api_description": "Return the number of physical qubits in this graph.",
        "api_signature": "size(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/coupling.py"
    },
    {
        "api_name": "get_edges",
        "full_api_name": "CouplingMap.get_edges",
        "api_description": "Gets the list of edges in the coupling graph.\n\nReturns:\n    Tuple(int,int): Each edge is a pair of physical qubits.",
        "api_signature": "get_edges(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/coupling.py"
    },
    {
        "api_name": "__iter__",
        "full_api_name": "CouplingMap.__iter__",
        "api_description": "",
        "api_signature": "__iter__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/coupling.py"
    },
    {
        "api_name": "add_physical_qubit",
        "full_api_name": "CouplingMap.add_physical_qubit",
        "api_description": "Add a physical qubit to the coupling graph as a node.\n\nphysical_qubit (int): An integer representing a physical qubit.\n\nRaises:\n    CouplingError: if trying to add duplicate qubit",
        "api_signature": "add_physical_qubit(self, physical_qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/coupling.py"
    },
    {
        "api_name": "add_edge",
        "full_api_name": "CouplingMap.add_edge",
        "api_description": "Add directed edge to coupling graph.\n\nsrc (int): source physical qubit\ndst (int): destination physical qubit",
        "api_signature": "add_edge(self, src, dst)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/coupling.py"
    },
    {
        "api_name": "physical_qubits",
        "full_api_name": "CouplingMap.physical_qubits",
        "api_description": "Returns a sorted list of physical_qubits",
        "api_signature": "physical_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/coupling.py"
    },
    {
        "api_name": "is_connected",
        "full_api_name": "CouplingMap.is_connected",
        "api_description": "Test if the graph is connected.\n\nReturn True if connected, False otherwise",
        "api_signature": "is_connected(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/coupling.py"
    },
    {
        "api_name": "neighbors",
        "full_api_name": "CouplingMap.neighbors",
        "api_description": "Return the nearest neighbors of a physical qubit.\n\nDirectionality matters, i.e. a neighbor must be reachable\nby going one hop in the direction of an edge.",
        "api_signature": "neighbors(self, physical_qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/coupling.py"
    },
    {
        "api_name": "distance_matrix",
        "full_api_name": "CouplingMap.distance_matrix",
        "api_description": "Return the distance matrix for the coupling map.\n\nFor any qubits where there isn't a path available between them the value\nin this position of the distance matrix will be ``math.inf``.",
        "api_signature": "distance_matrix(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/coupling.py"
    },
    {
        "api_name": "compute_distance_matrix",
        "full_api_name": "CouplingMap.compute_distance_matrix",
        "api_description": "Compute the full distance matrix on pairs of nodes.\n\nThe distance map self._dist_matrix is computed from the graph using\nall_pairs_shortest_path_length. This is normally handled internally\nby the :attr:`~qiskit.transpiler.CouplingMap.distance_matrix`\nattribute or the :meth:`~qiskit.transpiler.CouplingMap.distance` method\nbut can be called if you're accessing the distance matrix outside of\nthose or want to pre-generate it.",
        "api_signature": "compute_distance_matrix(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/coupling.py"
    },
    {
        "api_name": "distance",
        "full_api_name": "CouplingMap.distance",
        "api_description": "Returns the undirected distance between physical_qubit1 and physical_qubit2.\n\nArgs:\n    physical_qubit1 (int): A physical qubit\n    physical_qubit2 (int): Another physical qubit\n\nReturns:\n    int: The undirected distance\n\nRaises:\n    CouplingError: if the qubits do not exist in the CouplingMap",
        "api_signature": "distance(self, physical_qubit1, physical_qubit2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/coupling.py"
    },
    {
        "api_name": "shortest_undirected_path",
        "full_api_name": "CouplingMap.shortest_undirected_path",
        "api_description": "Returns the shortest undirected path between physical_qubit1 and physical_qubit2.\n\nArgs:\n    physical_qubit1 (int): A physical qubit\n    physical_qubit2 (int): Another physical qubit\nReturns:\n    List: The shortest undirected path\nRaises:\n    CouplingError: When there is no path between physical_qubit1, physical_qubit2.",
        "api_signature": "shortest_undirected_path(self, physical_qubit1, physical_qubit2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/coupling.py"
    },
    {
        "api_name": "is_symmetric",
        "full_api_name": "CouplingMap.is_symmetric",
        "api_description": "Test if the graph is symmetric.\n\nReturn True if symmetric, False otherwise",
        "api_signature": "is_symmetric(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/coupling.py"
    },
    {
        "api_name": "make_symmetric",
        "full_api_name": "CouplingMap.make_symmetric",
        "api_description": "Convert uni-directional edges into bi-directional.",
        "api_signature": "make_symmetric(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/coupling.py"
    },
    {
        "api_name": "_check_symmetry",
        "full_api_name": "CouplingMap._check_symmetry",
        "api_description": "Calculates symmetry\n\nReturns:\n    Bool: True if symmetric, False otherwise",
        "api_signature": "_check_symmetry(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/coupling.py"
    },
    {
        "api_name": "reduce",
        "full_api_name": "CouplingMap.reduce",
        "api_description": "Returns a reduced coupling map that\ncorresponds to the subgraph of qubits\nselected in the mapping.\n\nArgs:\n    mapping (list): A mapping of reduced qubits to device\n        qubits.\n    check_if_connected (bool): if True, checks that the reduced\n        coupling map is connected.\n\nReturns:\n    CouplingMap: A reduced coupling_map for the selected qubits.\n\nRaises:\n    CouplingError: Reduced coupling map must be connected.",
        "api_signature": "reduce(self, mapping, check_if_connected)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/coupling.py"
    },
    {
        "api_name": "from_full",
        "full_api_name": "CouplingMap.from_full",
        "api_description": "Return a fully connected coupling map on n qubits.",
        "api_signature": "from_full(cls, num_qubits, bidirectional)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/coupling.py"
    },
    {
        "api_name": "from_line",
        "full_api_name": "CouplingMap.from_line",
        "api_description": "Return a coupling map of n qubits connected in a line.",
        "api_signature": "from_line(cls, num_qubits, bidirectional)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/coupling.py"
    },
    {
        "api_name": "from_ring",
        "full_api_name": "CouplingMap.from_ring",
        "api_description": "Return a coupling map of n qubits connected to each of their neighbors in a ring.",
        "api_signature": "from_ring(cls, num_qubits, bidirectional)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/coupling.py"
    },
    {
        "api_name": "from_grid",
        "full_api_name": "CouplingMap.from_grid",
        "api_description": "Return a coupling map of qubits connected on a grid of num_rows x num_columns.",
        "api_signature": "from_grid(cls, num_rows, num_columns, bidirectional)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/coupling.py"
    },
    {
        "api_name": "from_heavy_hex",
        "full_api_name": "CouplingMap.from_heavy_hex",
        "api_description": "Return a heavy hexagon graph coupling map.\n\nA heavy hexagon graph is described in:\n\nhttps://journals.aps.org/prx/abstract/10.1103/PhysRevX.10.011022\n\nArgs:\n    distance (int): The code distance for the generated heavy hex\n        graph. The value for distance can be any odd positive integer.\n        The distance relates to the number of qubits by:\n        :math:`n = \\frac{5d^2 - 2d - 1}{2}` where :math:`n` is the\n        number of qubits and :math:`d` is the ``distance`` parameter.\n    bidirectional (bool): Whether the edges in the output coupling\n        graph are bidirectional or not. By default this is set to\n        ``True``\nReturns:\n    CouplingMap: A heavy hex coupling graph",
        "api_signature": "from_heavy_hex(cls, distance, bidirectional)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/coupling.py"
    },
    {
        "api_name": "from_heavy_square",
        "full_api_name": "CouplingMap.from_heavy_square",
        "api_description": "Return a heavy square graph coupling map.\n\nA heavy square graph is described in:\n\nhttps://journals.aps.org/prx/abstract/10.1103/PhysRevX.10.011022\n\nArgs:\n    distance (int): The code distance for the generated heavy square\n        graph. The value for distance can be any odd positive integer.\n        The distance relates to the number of qubits by:\n        :math:`n = 3d^2 - 2d` where :math:`n` is the\n        number of qubits and :math:`d` is the ``distance`` parameter.\n    bidirectional (bool): Whether the edges in the output coupling\n        graph are bidirectional or not. By default this is set to\n        ``True``\nReturns:\n    CouplingMap: A heavy square coupling graph",
        "api_signature": "from_heavy_square(cls, distance, bidirectional)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/coupling.py"
    },
    {
        "api_name": "from_hexagonal_lattice",
        "full_api_name": "CouplingMap.from_hexagonal_lattice",
        "api_description": "Return a hexagonal lattice graph coupling map.\n\nArgs:\n    rows (int): The number of rows to generate the graph with.\n    cols (int): The number of columns to generate the graph with.\n    bidirectional (bool): Whether the edges in the output coupling\n        graph are bidirectional or not. By default this is set to\n        ``True``\nReturns:\n    CouplingMap: A hexagonal lattice coupling graph",
        "api_signature": "from_hexagonal_lattice(cls, rows, cols, bidirectional)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/coupling.py"
    },
    {
        "api_name": "largest_connected_component",
        "full_api_name": "CouplingMap.largest_connected_component",
        "api_description": "Return a set of qubits in the largest connected component.",
        "api_signature": "largest_connected_component(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/coupling.py"
    },
    {
        "api_name": "connected_components",
        "full_api_name": "CouplingMap.connected_components",
        "api_description": "Separate a :Class:`~.CouplingMap` into subgraph :class:`~.CouplingMap`\nfor each connected component.\n\nThe connected components of a :class:`~.CouplingMap` are the subgraphs\nthat are not part of any larger subgraph. For example, if you had a\ncoupling map that looked like::\n\n    0 --> 1   4 --> 5 ---> 6 --> 7\n    |     |\n    |     |\n    V     V\n    2 --> 3\n\nthen the connected components of that graph are the subgraphs::\n\n    0 --> 1\n    |     |\n    |     |\n    V     V\n    2 --> 3\n\nand::\n\n    4 --> 5 ---> 6 --> 7\n\nFor a connected :class:`~.CouplingMap` object there is only a single connected\ncomponent, the entire :class:`~.CouplingMap`.\n\nThis method will return a list of :class:`~.CouplingMap` objects, one for each connected\ncomponent in this :class:`~.CouplingMap`. The data payload of each node in the\n:attr:`~.CouplingMap.graph` attribute will contain the qubit number in the original\ngraph. This will enables mapping the qubit index in a component subgraph to\nthe original qubit in the combined :class:`~.CouplingMap`. For example::\n\n    from qiskit.transpiler import CouplingMap\n\n    cmap = CouplingMap([[0, 1], [1, 2], [2, 0], [3, 4], [4, 5], [5, 3]])\n    component_cmaps = cmap.connected_components()\n    print(component_cmaps[1].graph[0])\n\nwill print ``3`` as index ``0`` in the second component is qubit 3 in the original cmap.\n\nReturns:\n    list: A list of :class:`~.CouplingMap` objects for each connected\n        components. The order of this list is deterministic but\n        implementation specific and shouldn't be relied upon as\n        part of the API.",
        "api_signature": "connected_components(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/coupling.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "CouplingMap.__str__",
        "api_description": "Return a string representation of the coupling graph.",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/coupling.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "CouplingMap.__eq__",
        "api_description": "Check if the graph in ``other`` has the same node labels and edges as the graph in\n``self``.\n\nThis function assumes that the graphs in :class:`.CouplingMap` instances are connected.\n\nArgs:\n    other (CouplingMap): The other coupling map.\n\nReturns:\n    bool: Whether or not other is isomorphic to self.",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/coupling.py"
    },
    {
        "api_name": "draw",
        "full_api_name": "CouplingMap.draw",
        "api_description": "Draws the coupling map.\n\nThis function calls the :func:`~rustworkx.visualization.graphviz_draw` function from the\n``rustworkx`` package to draw the :class:`CouplingMap` object.\n\nReturns:\n    PIL.Image: Drawn coupling map.",
        "api_signature": "draw(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/coupling.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "FencedObject.__init__",
        "api_description": "",
        "api_signature": "__init__(self, instance, attributes_to_fence)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/fencedobjs.py"
    },
    {
        "api_name": "__getattribute__",
        "full_api_name": "FencedObject.__getattribute__",
        "api_description": "",
        "api_signature": "__getattribute__(self, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/fencedobjs.py"
    },
    {
        "api_name": "__getitem__",
        "full_api_name": "FencedObject.__getitem__",
        "api_description": "",
        "api_signature": "__getitem__(self, key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/fencedobjs.py"
    },
    {
        "api_name": "__setitem__",
        "full_api_name": "FencedObject.__setitem__",
        "api_description": "",
        "api_signature": "__setitem__(self, key, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/fencedobjs.py"
    },
    {
        "api_name": "_check_if_fenced",
        "full_api_name": "FencedObject._check_if_fenced",
        "api_description": "Checks if the attribute name is in the list of attributes to protect. If so, raises\nTranspilerError.\n\nArgs:\n    name (string): the attribute name to check\n\nRaises:\n    TranspilerError: when name is the list of attributes to protect.",
        "api_signature": "_check_if_fenced(self, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/fencedobjs.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "FencedPropertySet.__init__",
        "api_description": "",
        "api_signature": "__init__(self, property_set_instance)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/fencedobjs.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "FencedDAGCircuit.__init__",
        "api_description": "",
        "api_signature": "__init__(self, dag_circuit_instance)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/fencedobjs.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PassManagerConfig.__init__",
        "api_description": "Initialize a PassManagerConfig object\n\nArgs:\n    initial_layout (Layout): Initial position of virtual qubits on\n        physical qubits.\n    basis_gates (list): List of basis gate names to unroll to.\n    inst_map (InstructionScheduleMap): Mapping object that maps gate to schedule.\n    coupling_map (CouplingMap): Directed graph represented a coupling\n        map.\n    layout_method (str): the pass to use for choosing initial qubit\n        placement. This will be the plugin name if an external layout stage\n        plugin is being used.\n    routing_method (str): the pass to use for routing qubits on the\n        architecture. This will be a plugin name if an external routing stage\n        plugin is being used.\n    translation_method (str): the pass to use for translating gates to\n        basis_gates. This will be a plugin name if an external translation stage\n        plugin is being used.\n    scheduling_method (str): the pass to use for scheduling instructions. This will\n        be a plugin name if an external scheduling stage plugin is being used.\n    instruction_durations (InstructionDurations): Dictionary of duration\n        (in dt) for each instruction.\n    backend_properties (BackendProperties): Properties returned by a\n        backend, including information on gate errors, readout errors,\n        qubit coherence times, etc.\n    approximation_degree (float): heuristic dial used for circuit approximation\n        (1.0=no approximation, 0.0=maximal approximation)\n    seed_transpiler (int): Sets random seed for the stochastic parts of\n        the transpiler.\n    timing_constraints (TimingConstraints): Hardware time alignment restrictions.\n    unitary_synthesis_method (str): The string method to use for the\n        :class:`~qiskit.transpiler.passes.UnitarySynthesis` pass. Will\n        search installed plugins for a valid method. You can see a list of\n        installed plugins with :func:`.unitary_synthesis_plugin_names`.\n    target (Target): The backend target\n    hls_config (HLSConfig): An optional configuration class to use for\n        :class:`~qiskit.transpiler.passes.HighLevelSynthesis` pass.\n        Specifies how to synthesize various high-level objects.\n    init_method (str): The plugin name for the init stage plugin to use\n    optimization_method (str): The plugin name for the optimization stage plugin\n        to use.",
        "api_signature": "__init__(self, initial_layout, basis_gates, inst_map, coupling_map, layout_method, routing_method, translation_method, scheduling_method, instruction_durations, backend_properties, approximation_degree, seed_transpiler, timing_constraints, unitary_synthesis_method, unitary_synthesis_plugin_config, target, hls_config, init_method, optimization_method)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passmanager_config.py"
    },
    {
        "api_name": "from_backend",
        "full_api_name": "PassManagerConfig.from_backend",
        "api_description": "Construct a configuration based on a backend and user input.\n\nThis method automatically gererates a PassManagerConfig object based on the backend's\nfeatures. User options can be used to overwrite the configuration.\n\nArgs:\n    backend (BackendV1): The backend that provides the configuration.\n    pass_manager_options: User-defined option-value pairs.\n\nReturns:\n    PassManagerConfig: The configuration generated based on the arguments.\n\nRaises:\n    AttributeError: If the backend does not support a `configuration()` method.",
        "api_signature": "from_backend(cls, backend, _skip_target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passmanager_config.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "PassManagerConfig.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passmanager_config.py"
    },
    {
        "api_name": "append",
        "full_api_name": "RunningPassManager.append",
        "api_description": "Append a passes to the schedule of passes.\n\nArgs:\n    passes: A set of passes (a pass set) to be added to schedule. A pass set is a list of\n        passes that are controlled by the same flow controller. If a single pass is\n        provided, the pass set will only have that pass a single element.\n        It is also possible to append a :class:`.BaseFlowController` instance and\n        the rest of the parameter will be ignored.\n    flow_controller_conditions: Dictionary of control flow plugins.\n        Following built-in controllers are available by default:\n\n        * do_while: The passes repeat until the callable returns False.\n        * condition: The passes run only if the callable returns True.",
        "api_signature": "append(self, passes)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/runningpassmanager.py"
    },
    {
        "api_name": "run",
        "full_api_name": "RunningPassManager.run",
        "api_description": "Run all the passes on a QuantumCircuit\n\nArgs:\n    circuit: Circuit to transform via all the registered passes.\n    output_name: The output circuit name. If not given, the same as the input circuit.\n    callback: A callback function that will be called after each pass execution.\n\nReturns:\n    QuantumCircuit: Transformed circuit.",
        "api_signature": "run(self, circuit, output_name, callback)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/runningpassmanager.py"
    },
    {
        "api_name": "_replace_error",
        "full_api_name": "_replace_error",
        "api_description": "",
        "api_signature": "_replace_error(meth)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/runningpassmanager.py"
    },
    {
        "api_name": "wrapper",
        "full_api_name": "wrapper",
        "api_description": "",
        "api_signature": "wrapper()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/runningpassmanager.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CouplingError.__init__",
        "api_description": "Set the error message.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/exceptions.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "CouplingError.__str__",
        "api_description": "Return the message.",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/exceptions.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "LayoutError.__init__",
        "api_description": "Set the error message.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/exceptions.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "LayoutError.__str__",
        "api_description": "Return the message.",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/exceptions.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "InstructionDurations.__init__",
        "api_description": "",
        "api_signature": "__init__(self, instruction_durations, dt)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/instruction_durations.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "InstructionDurations.__str__",
        "api_description": "Return a string representation of all stored durations.",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/instruction_durations.py"
    },
    {
        "api_name": "from_backend",
        "full_api_name": "InstructionDurations.from_backend",
        "api_description": "Construct an :class:`InstructionDurations` object from the backend.\n\nArgs:\n    backend: backend from which durations (gate lengths) and dt are extracted.\n\nReturns:\n    InstructionDurations: The InstructionDurations constructed from backend.\n\nRaises:\n    TranspilerError: If dt and dtm is different in the backend.",
        "api_signature": "from_backend(cls, backend)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/instruction_durations.py"
    },
    {
        "api_name": "update",
        "full_api_name": "InstructionDurations.update",
        "api_description": "Update self with inst_durations (inst_durations overwrite self).\n\nArgs:\n    inst_durations: Instruction durations to be merged into self (overwriting self).\n    dt: Sampling duration in seconds of the target backend.\n\nReturns:\n    InstructionDurations: The updated InstructionDurations.\n\nRaises:\n    TranspilerError: If the format of instruction_durations is invalid.",
        "api_signature": "update(self, inst_durations, dt)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/instruction_durations.py"
    },
    {
        "api_name": "get",
        "full_api_name": "InstructionDurations.get",
        "api_description": "Get the duration of the instruction with the name, qubits, and parameters.\n\nSome instructions may have a parameter dependent duration.\n\nArgs:\n    inst: An instruction or its name to be queried.\n    qubits: Qubit indices that the instruction acts on.\n    unit: The unit of duration to be returned. It must be 's' or 'dt'.\n    parameters: The value of the parameters of the desired instruction.\n\nReturns:\n    float|int: The duration of the instruction on the qubits.\n\nRaises:\n    TranspilerError: No duration is defined for the instruction.",
        "api_signature": "get(self, inst, qubits, unit, parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/instruction_durations.py"
    },
    {
        "api_name": "_get",
        "full_api_name": "InstructionDurations._get",
        "api_description": "Get the duration of the instruction with the name, qubits, and parameters.",
        "api_signature": "_get(self, name, qubits, to_unit, parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/instruction_durations.py"
    },
    {
        "api_name": "_convert_unit",
        "full_api_name": "InstructionDurations._convert_unit",
        "api_description": "",
        "api_signature": "_convert_unit(self, duration, from_unit, to_unit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/instruction_durations.py"
    },
    {
        "api_name": "units_used",
        "full_api_name": "InstructionDurations.units_used",
        "api_description": "Get the set of all units used in this instruction durations.\n\nReturns:\n    Set of units used in this instruction durations.",
        "api_signature": "units_used(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/instruction_durations.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PassManager.__init__",
        "api_description": "Initialize an empty pass manager object.\n\nArgs:\n    passes: A pass set to be added to the pass manager schedule.\n    max_iteration: The maximum number of iterations the schedule will be looped if the\n        condition is not met.",
        "api_signature": "__init__(self, passes, max_iteration)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py"
    },
    {
        "api_name": "_passmanager_frontend",
        "full_api_name": "PassManager._passmanager_frontend",
        "api_description": "",
        "api_signature": "_passmanager_frontend(self, input_program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py"
    },
    {
        "api_name": "_passmanager_backend",
        "full_api_name": "PassManager._passmanager_backend",
        "api_description": "",
        "api_signature": "_passmanager_backend(self, passmanager_ir, in_program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py"
    },
    {
        "api_name": "append",
        "full_api_name": "PassManager.append",
        "api_description": "Append a Pass Set to the schedule of passes.\n\nArgs:\n    passes: A set of passes (a pass set) to be added to schedule. A pass set is a list of\n        passes that are controlled by the same flow controller. If a single pass is\n        provided, the pass set will only have that pass a single element.\n        It is also possible to append a :class:`.BaseFlowController` instance and\n        the rest of the parameter will be ignored.\n    max_iteration: max number of iterations of passes.\n    flow_controller_conditions: Dictionary of control flow plugins.\n        Following built-in controllers are available by default:\n\n        * do_while: The passes repeat until the callable returns False.  Corresponds to\n          :class:`.DoWhileController`.\n        * condition: The passes run only if the callable returns True.  Corresponds to\n          :class:`.ConditionalController`.\n\n        In general, you have more control simply by creating the controller you want and\n        passing it to :meth:`append`.\n\nRaises:\n    TranspilerError: if a pass in passes is not a proper pass.",
        "api_signature": "append(self, passes, max_iteration)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py"
    },
    {
        "api_name": "replace",
        "full_api_name": "PassManager.replace",
        "api_description": "Replace a particular pass in the scheduler.\n\nArgs:\n    index: Pass index to replace, based on the position in passes().\n    passes: A pass set to be added to the pass manager schedule.\n    max_iteration: max number of iterations of passes.\n    flow_controller_conditions: Dictionary of control flow plugins.\n        See :meth:`qiskit.transpiler.PassManager.append` for details.",
        "api_signature": "replace(self, index, passes, max_iteration)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py"
    },
    {
        "api_name": "remove",
        "full_api_name": "PassManager.remove",
        "api_description": "",
        "api_signature": "remove(self, index)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py"
    },
    {
        "api_name": "__getitem__",
        "full_api_name": "PassManager.__getitem__",
        "api_description": "",
        "api_signature": "__getitem__(self, index)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py"
    },
    {
        "api_name": "__add__",
        "full_api_name": "PassManager.__add__",
        "api_description": "",
        "api_signature": "__add__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py"
    },
    {
        "api_name": "to_flow_controller",
        "full_api_name": "PassManager.to_flow_controller",
        "api_description": "",
        "api_signature": "to_flow_controller(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py"
    },
    {
        "api_name": "run",
        "full_api_name": "PassManager.run",
        "api_description": "Run all the passes on the specified ``circuits``.\n\nArgs:\n    circuits: Circuit(s) to transform via all the registered passes.\n    output_name: The output circuit name. If ``None``, it will be set to the same as the\n        input circuit name.\n    callback: A callback function that will be called after each pass execution. The\n        function will be called with 5 keyword arguments::\n\n            pass_ (Pass): the pass being run\n            dag (DAGCircuit): the dag output of the pass\n            time (float): the time to execute the pass\n            property_set (PropertySet): the property set\n            count (int): the index for the pass execution\n\n        .. note::\n\n            Beware that the keyword arguments here are different to those used by the\n            generic :class:`.BasePassManager`.  This pass manager will translate those\n            arguments into the form described above.\n\n        The exact arguments pass expose the internals of the pass\n        manager and are subject to change as the pass manager internals\n        change. If you intend to reuse a callback function over\n        multiple releases be sure to check that the arguments being\n        passed are the same.\n\n        To use the callback feature you define a function that will\n        take in kwargs dict and access the variables. For example::\n\n            def callback_func(**kwargs):\n                pass_ = kwargs['pass_']\n                dag = kwargs['dag']\n                time = kwargs['time']\n                property_set = kwargs['property_set']\n                count = kwargs['count']\n                ...\n\nReturns:\n    The transformed circuit(s).",
        "api_signature": "run(self, circuits, output_name, callback)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py"
    },
    {
        "api_name": "draw",
        "full_api_name": "PassManager.draw",
        "api_description": "Draw the pass manager.\n\nThis function needs `pydot <https://github.com/erocarrera/pydot>`__, which in turn needs\n`Graphviz <https://www.graphviz.org/>`__ to be installed.\n\nArgs:\n    filename (str): file path to save image to.\n    style (dict): keys are the pass classes and the values are the colors to make them. An\n        example can be seen in the DEFAULT_STYLE. An ordered dict can be used to ensure\n        a priority coloring when pass falls into multiple categories. Any values not\n        included in the provided dict will be filled in from the default dict.\n    raw (bool): If ``True``, save the raw Dot output instead of the image.\n\nReturns:\n    Optional[PassManager]: an in-memory representation of the pass manager, or ``None``\n    if no image was generated or `Pillow <https://pypi.org/project/Pillow/>`__\n    is not installed.\n\nRaises:\n    ImportError: when nxpd or pydot not installed.",
        "api_signature": "draw(self, filename, style, raw)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py"
    },
    {
        "api_name": "passes",
        "full_api_name": "PassManager.passes",
        "api_description": "Return a list structure of the appended passes and its options.\n\nReturns:\n    A list of pass sets, as defined in ``append()``.",
        "api_signature": "passes(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "StagedPassManager.__init__",
        "api_description": "Initialize a new StagedPassManager object\n\nArgs:\n    stages (Iterable[str]): An optional list of stages to use for this\n        instance. If this is not specified the default stages list\n        ``['init', 'layout', 'routing', 'translation', 'optimization', 'scheduling']`` is\n        used. After instantiation, the final list will be immutable and stored as tuple.\n        If a stage is provided multiple times (i.e. at diferent relative positions), the\n        associated passes, including pre and post, will run once per declaration.\n    kwargs: The initial :class:`~.PassManager` values for any stages\n        defined in ``stages``. If a argument is not defined the\n        stages will default to ``None`` indicating an empty/undefined\n        stage.\n\nRaises:\n    AttributeError: If a stage in the input keyword arguments is not defined.\n    ValueError: If an invalid stage name is specified.",
        "api_signature": "__init__(self, stages)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py"
    },
    {
        "api_name": "_validate_stages",
        "full_api_name": "StagedPassManager._validate_stages",
        "api_description": "",
        "api_signature": "_validate_stages(self, stages)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py"
    },
    {
        "api_name": "_validate_init_kwargs",
        "full_api_name": "StagedPassManager._validate_init_kwargs",
        "api_description": "",
        "api_signature": "_validate_init_kwargs(self, kwargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py"
    },
    {
        "api_name": "stages",
        "full_api_name": "StagedPassManager.stages",
        "api_description": "Pass manager stages",
        "api_signature": "stages(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py"
    },
    {
        "api_name": "expanded_stages",
        "full_api_name": "StagedPassManager.expanded_stages",
        "api_description": "Expanded Pass manager stages including ``pre_`` and ``post_`` phases.",
        "api_signature": "expanded_stages(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py"
    },
    {
        "api_name": "_generate_expanded_stages",
        "full_api_name": "StagedPassManager._generate_expanded_stages",
        "api_description": "",
        "api_signature": "_generate_expanded_stages(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py"
    },
    {
        "api_name": "_update_passmanager",
        "full_api_name": "StagedPassManager._update_passmanager",
        "api_description": "",
        "api_signature": "_update_passmanager(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py"
    },
    {
        "api_name": "__setattr__",
        "full_api_name": "StagedPassManager.__setattr__",
        "api_description": "",
        "api_signature": "__setattr__(self, attr, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py"
    },
    {
        "api_name": "append",
        "full_api_name": "StagedPassManager.append",
        "api_description": "",
        "api_signature": "append(self, passes, max_iteration)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py"
    },
    {
        "api_name": "replace",
        "full_api_name": "StagedPassManager.replace",
        "api_description": "",
        "api_signature": "replace(self, index, passes, max_iteration)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py"
    },
    {
        "api_name": "remove",
        "full_api_name": "StagedPassManager.remove",
        "api_description": "",
        "api_signature": "remove(self, index)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py"
    },
    {
        "api_name": "__getitem__",
        "full_api_name": "StagedPassManager.__getitem__",
        "api_description": "",
        "api_signature": "__getitem__(self, index)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py"
    },
    {
        "api_name": "__len__",
        "full_api_name": "StagedPassManager.__len__",
        "api_description": "",
        "api_signature": "__len__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py"
    },
    {
        "api_name": "__setitem__",
        "full_api_name": "StagedPassManager.__setitem__",
        "api_description": "",
        "api_signature": "__setitem__(self, index, item)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py"
    },
    {
        "api_name": "__add__",
        "full_api_name": "StagedPassManager.__add__",
        "api_description": "",
        "api_signature": "__add__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py"
    },
    {
        "api_name": "passes",
        "full_api_name": "StagedPassManager.passes",
        "api_description": "",
        "api_signature": "passes(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py"
    },
    {
        "api_name": "run",
        "full_api_name": "StagedPassManager.run",
        "api_description": "",
        "api_signature": "run(self, circuits, output_name, callback)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py"
    },
    {
        "api_name": "draw",
        "full_api_name": "StagedPassManager.draw",
        "api_description": "Draw the staged pass manager.",
        "api_signature": "draw(self, filename, style, raw)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py"
    },
    {
        "api_name": "_replace_error",
        "full_api_name": "_replace_error",
        "api_description": "",
        "api_signature": "_replace_error(meth)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py"
    },
    {
        "api_name": "wrapper",
        "full_api_name": "wrapper",
        "api_description": "",
        "api_signature": "wrapper()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py"
    },
    {
        "api_name": "_legacy_style_callback",
        "full_api_name": "_legacy_style_callback",
        "api_description": "",
        "api_signature": "_legacy_style_callback(callback)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py"
    },
    {
        "api_name": "_wrapped_callable",
        "full_api_name": "_wrapped_callable",
        "api_description": "",
        "api_signature": "_wrapped_callable(task, passmanager_ir, property_set, running_time, count)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py"
    },
    {
        "api_name": "_legacy_build_flow_controller",
        "full_api_name": "_legacy_build_flow_controller",
        "api_description": "A legacy method to build flow controller with keyword arguments.\n\nArgs:\n    tasks: A list of tasks fed into custom flow controllers.\n    options: Option for flow controllers.\n    flow_controller_conditions: Callables keyed on the alias of the flow controller.\n\nReturns:\n    A built controller.",
        "api_signature": "_legacy_build_flow_controller(tasks, options)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "TimingConstraints.__init__",
        "api_description": "Initialize a TimingConstraints object\n\nArgs:\n    granularity: An integer value representing minimum pulse gate\n        resolution in units of ``dt``. A user-defined pulse gate should have\n        duration of a multiple of this granularity value.\n    min_length: An integer value representing minimum pulse gate\n        length in units of ``dt``. A user-defined pulse gate should be longer\n        than this length.\n    pulse_alignment: An integer value representing a time resolution of gate\n        instruction starting time. Gate instruction should start at time which\n        is a multiple of the alignment value.\n    acquire_alignment: An integer value representing a time resolution of measure\n        instruction starting time. Measure instruction should start at time which\n        is a multiple of the alignment value.\n\nNotes:\n    This information will be provided by the backend configuration.\n\nRaises:\n    TranspilerError: When any invalid constraint value is passed.",
        "api_signature": "__init__(self, granularity, min_length, pulse_alignment, acquire_alignment)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/timing_constraints.py"
    },
    {
        "api_name": "__call__",
        "full_api_name": "MetaPass.__call__",
        "api_description": "",
        "api_signature": "__call__(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/basepasses.py"
    },
    {
        "api_name": "_freeze_init_parameters",
        "full_api_name": "MetaPass._freeze_init_parameters",
        "api_description": "",
        "api_signature": "_freeze_init_parameters(class_, args, kwargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/basepasses.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BasePass.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/basepasses.py"
    },
    {
        "api_name": "__hash__",
        "full_api_name": "BasePass.__hash__",
        "api_description": "",
        "api_signature": "__hash__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/basepasses.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "BasePass.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/basepasses.py"
    },
    {
        "api_name": "run",
        "full_api_name": "BasePass.run",
        "api_description": "Run a pass on the DAGCircuit. This is implemented by the pass developer.\n\nArgs:\n    dag: the dag on which the pass is run.\n\nRaises:\n    NotImplementedError: when this is left unimplemented for a pass.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/basepasses.py"
    },
    {
        "api_name": "is_transformation_pass",
        "full_api_name": "BasePass.is_transformation_pass",
        "api_description": "Check if the pass is a transformation pass.\n\nIf the pass is a TransformationPass, that means that the pass can manipulate the DAG,\nbut cannot modify the property set (but it can be read).",
        "api_signature": "is_transformation_pass(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/basepasses.py"
    },
    {
        "api_name": "is_analysis_pass",
        "full_api_name": "BasePass.is_analysis_pass",
        "api_description": "Check if the pass is an analysis pass.\n\nIf the pass is an AnalysisPass, that means that the pass can analyze the DAG and write\nthe results of that analysis in the property set. Modifications on the DAG are not allowed\nby this kind of pass.",
        "api_signature": "is_analysis_pass(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/basepasses.py"
    },
    {
        "api_name": "__call__",
        "full_api_name": "BasePass.__call__",
        "api_description": "Runs the pass on circuit.\n\nArgs:\n    circuit: The dag on which the pass is run.\n    property_set: Input/output property set. An analysis pass\n        might change the property set in-place.\n\nReturns:\n    If on transformation pass, the resulting QuantumCircuit.\n    If analysis pass, the input circuit.",
        "api_signature": "__call__(self, circuit, property_set)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/basepasses.py"
    },
    {
        "api_name": "execute",
        "full_api_name": "TransformationPass.execute",
        "api_description": "",
        "api_signature": "execute(self, passmanager_ir, state, callback)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/basepasses.py"
    },
    {
        "api_name": "update_status",
        "full_api_name": "TransformationPass.update_status",
        "api_description": "",
        "api_signature": "update_status(self, state, run_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/basepasses.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "InstructionProperties.__init__",
        "api_description": "Create a new ``InstructionProperties`` object\n\nArgs:\n    duration: The duration, in seconds, of the instruction on the\n        specified set of qubits\n    error: The average error rate for the instruction on the specified\n        set of qubits.\n    calibration: The pulse representation of the instruction.",
        "api_signature": "__init__(self, duration, error, calibration)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "calibration",
        "full_api_name": "InstructionProperties.calibration",
        "api_description": "The pulse representation of the instruction.\n\n.. note::\n\n    This attribute always returns a Qiskit pulse program, but it is internally\n    wrapped by the :class:`.CalibrationEntry` to manage unbound parameters\n    and to uniformly handle different data representation,\n    for example, un-parsed Pulse Qobj JSON that a backend provider may provide.\n\n    This value can be overridden through the property setter in following manner.\n    When you set either :class:`.Schedule` or :class:`.ScheduleBlock` this is\n    always treated as a user-defined (custom) calibration and\n    the transpiler may automatically attach the calibration data to the output circuit.\n    This calibration data may appear in the wire format as an inline calibration,\n    which may further update the backend standard instruction set architecture.\n\n    If you are a backend provider who provides a default calibration data\n    that is not needed to be attached to the transpiled quantum circuit,\n    you can directly set :class:`.CalibrationEntry` instance to this attribute,\n    in which you should set :code:`user_provided=False` when you define\n    calibration data for the entry. End users can still intentionally utilize\n    the calibration data, for example, to run pulse-level simulation of the circuit.\n    However, such entry doesn't appear in the wire format, and backend must\n    use own definition to compile the circuit down to the execution format.",
        "api_signature": "calibration(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "calibration",
        "full_api_name": "InstructionProperties.calibration",
        "api_description": "",
        "api_signature": "calibration(self, calibration)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "InstructionProperties.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Target.__init__",
        "api_description": "Create a new Target object\n\nArgs:\n    description (str): An optional string to describe the Target.\n    num_qubits (int): An optional int to specify the number of qubits\n        the backend target has. If not set it will be implicitly set\n        based on the qargs when :meth:`~qiskit.Target.add_instruction`\n        is called. Note this must be set if the backend target is for a\n        noiseless simulator that doesn't have constraints on the\n        instructions so the transpiler knows how many qubits are\n        available.\n    dt (float): The system time resolution of input signals in seconds\n    granularity (int): An integer value representing minimum pulse gate\n        resolution in units of ``dt``. A user-defined pulse gate should\n        have duration of a multiple of this granularity value.\n    min_length (int): An integer value representing minimum pulse gate\n        length in units of ``dt``. A user-defined pulse gate should be\n        longer than this length.\n    pulse_alignment (int): An integer value representing a time\n        resolution of gate instruction starting time. Gate instruction\n        should start at time which is a multiple of the alignment\n        value.\n    acquire_alignment (int): An integer value representing a time\n        resolution of measure instruction starting time. Measure\n        instruction should start at time which is a multiple of the\n        alignment value.\n    qubit_properties (list): A list of :class:`~.QubitProperties`\n        objects defining the characteristics of each qubit on the\n        target device. If specified the length of this list must match\n        the number of qubits in the target, where the index in the list\n        matches the qubit number the properties are defined for. If some\n        qubits don't have properties available you can set that entry to\n        ``None``\n    concurrent_measurements(list): A list of sets of qubits that must be\n        measured together. This must be provided\n        as a nested list like [[0, 1], [2, 3, 4]].\n    ValueError: If both ``num_qubits`` and ``qubit_properties`` are both\n    defined and the value of ``num_qubits`` differs from the length of\n    ``qubit_properties``.",
        "api_signature": "__init__(self, description, num_qubits, dt, granularity, min_length, pulse_alignment, acquire_alignment, qubit_properties, concurrent_measurements)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "add_instruction",
        "full_api_name": "Target.add_instruction",
        "api_description": "Add a new instruction to the :class:`~qiskit.transpiler.Target`\n\nAs ``Target`` objects are strictly additive this is the primary method\nfor modifying a ``Target``. Typically you will use this to fully populate\na ``Target`` before using it in :class:`~qiskit.providers.BackendV2`. For\nexample::\n\n    from qiskit.circuit.library import CXGate\n    from qiskit.transpiler import Target, InstructionProperties\n\n    target = Target()\n    cx_properties = {\n        (0, 1): None,\n        (1, 0): None,\n        (0, 2): None,\n        (2, 0): None,\n        (0, 3): None,\n        (2, 3): None,\n        (3, 0): None,\n        (3, 2): None\n    }\n    target.add_instruction(CXGate(), cx_properties)\n\nWill add a :class:`~qiskit.circuit.library.CXGate` to the target with no\nproperties (duration, error, etc) with the coupling edge list:\n``(0, 1), (1, 0), (0, 2), (2, 0), (0, 3), (2, 3), (3, 0), (3, 2)``. If\nthere are properties available for the instruction you can replace the\n``None`` value in the properties dictionary with an\n:class:`~qiskit.transpiler.InstructionProperties` object. This pattern\nis repeated for each :class:`~qiskit.circuit.Instruction` the target\nsupports.\n\nArgs:\n    instruction (qiskit.circuit.Instruction): The operation object to add to the map. If it's\n        paramerterized any value of the parameter can be set. Optionally for variable width\n        instructions (such as control flow operations such as :class:`~.ForLoop` or\n        :class:`~MCXGate`) you can specify the class. If the class is specified than the\n        ``name`` argument must be specified. When a class is used the gate is treated as global\n        and not having any properties set.\n    properties (dict): A dictionary of qarg entries to an\n        :class:`~qiskit.transpiler.InstructionProperties` object for that\n        instruction implementation on the backend. Properties are optional\n        for any instruction implementation, if there are no\n        :class:`~qiskit.transpiler.InstructionProperties` available for the\n        backend the value can be None. If there are no constraints on the\n        instruction (as in a noisless/ideal simulation) this can be set to\n        ``{None, None}`` which will indicate it runs on all qubits (or all\n        available permutations of qubits for multi-qubit gates). The first\n        ``None`` indicates it applies to all qubits and the second ``None``\n        indicates there are no\n        :class:`~qiskit.transpiler.InstructionProperties` for the\n        instruction. By default, if properties is not set it is equivalent to\n        passing ``{None: None}``.\n    name (str): An optional name to use for identifying the instruction. If not\n        specified the :attr:`~qiskit.circuit.Instruction.name` attribute\n        of ``gate`` will be used. All gates in the ``Target`` need unique\n        names. Backends can differentiate between different\n        parameterizations of a single gate by providing a unique name for\n        each (e.g. `\"rx30\"`, `\"rx60\", ``\"rx90\"`` similar to the example in the\n        documentation for the :class:`~qiskit.transpiler.Target` class).\nRaises:\n    AttributeError: If gate is already in map\n    TranspilerError: If an operation class is passed in for ``instruction`` and no name\n        is specified or ``properties`` is set.",
        "api_signature": "add_instruction(self, instruction, properties, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "update_instruction_properties",
        "full_api_name": "Target.update_instruction_properties",
        "api_description": "Update the property object for an instruction qarg pair already in the Target\n\nArgs:\n    instruction (str): The instruction name to update\n    qargs (tuple): The qargs to update the properties of\n    properties (InstructionProperties): The properties to set for this instruction\nRaises:\n    KeyError: If ``instruction`` or ``qarg`` are not in the target",
        "api_signature": "update_instruction_properties(self, instruction, qargs, properties)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "update_from_instruction_schedule_map",
        "full_api_name": "Target.update_from_instruction_schedule_map",
        "api_description": "Update the target from an instruction schedule map.\n\nIf the input instruction schedule map contains new instructions not in\nthe target they will be added. However, if it contains additional qargs\nfor an existing instruction in the target it will error.\n\nArgs:\n    inst_map (InstructionScheduleMap): The instruction\n    inst_name_map (dict): An optional dictionary that maps any\n        instruction name in ``inst_map`` to an instruction object.\n        If not provided, instruction is pulled from the standard Qiskit gates,\n        and finally custom gate instance is created with schedule name.\n    error_dict (dict): A dictionary of errors of the form::\n\n        {gate_name: {qarg: error}}\n\n    for example::\n\n        {'rx': {(0, ): 1.4e-4, (1, ): 1.2e-4}}\n\n    For each entry in the ``inst_map`` if ``error_dict`` is defined\n    a when updating the ``Target`` the error value will be pulled from\n    this dictionary. If one is not found in ``error_dict`` then\n    ``None`` will be used.",
        "api_signature": "update_from_instruction_schedule_map(self, inst_map, inst_name_map, error_dict)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "qargs",
        "full_api_name": "Target.qargs",
        "api_description": "The set of qargs in the target.",
        "api_signature": "qargs(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "qargs_for_operation_name",
        "full_api_name": "Target.qargs_for_operation_name",
        "api_description": "Get the qargs for a given operation name\n\nArgs:\n   operation (str): The operation name to get qargs for\nReturns:\n    set: The set of qargs the gate instance applies to.",
        "api_signature": "qargs_for_operation_name(self, operation)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "durations",
        "full_api_name": "Target.durations",
        "api_description": "Get an InstructionDurations object from the target\n\nReturns:\n    InstructionDurations: The instruction duration represented in the\n        target",
        "api_signature": "durations(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "timing_constraints",
        "full_api_name": "Target.timing_constraints",
        "api_description": "Get an :class:`~qiskit.transpiler.TimingConstraints` object from the target\n\nReturns:\n    TimingConstraints: The timing constraints represented in the Target",
        "api_signature": "timing_constraints(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "instruction_schedule_map",
        "full_api_name": "Target.instruction_schedule_map",
        "api_description": "Return an :class:`~qiskit.pulse.InstructionScheduleMap` for the\ninstructions in the target with a pulse schedule defined.\n\nReturns:\n    InstructionScheduleMap: The instruction schedule map for the\n    instructions in this target with a pulse schedule defined.",
        "api_signature": "instruction_schedule_map(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "operation_from_name",
        "full_api_name": "Target.operation_from_name",
        "api_description": "Get the operation class object for a given name\n\nArgs:\n    instruction (str): The instruction name to get the\n        :class:`~qiskit.circuit.Instruction` instance for\nReturns:\n    qiskit.circuit.Instruction: The Instruction instance corresponding to the\n    name. This also can also be the class for globally defined variable with\n    operations.",
        "api_signature": "operation_from_name(self, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "operations_for_qargs",
        "full_api_name": "Target.operations_for_qargs",
        "api_description": "Get the operation class object for a specified qargs tuple\n\nArgs:\n    qargs (tuple): A qargs tuple of the qubits to get the gates that apply\n        to it. For example, ``(0,)`` will return the set of all\n        instructions that apply to qubit 0. If set to ``None`` this will\n        return any globally defined operations in the target.\nReturns:\n    list: The list of :class:`~qiskit.circuit.Instruction` instances\n    that apply to the specified qarg. This may also be a class if\n    a variable width operation is globally defined.\n\nRaises:\n    KeyError: If qargs is not in target",
        "api_signature": "operations_for_qargs(self, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "operation_names_for_qargs",
        "full_api_name": "Target.operation_names_for_qargs",
        "api_description": "Get the operation names for a specified qargs tuple\n\nArgs:\n    qargs (tuple): A qargs tuple of the qubits to get the gates that apply\n        to it. For example, ``(0,)`` will return the set of all\n        instructions that apply to qubit 0. If set to ``None`` this will\n        return the names for any globally defined operations in the target.\nReturns:\n    set: The set of operation names that apply to the specified\n    `qargs``.\n\nRaises:\n    KeyError: If qargs is not in target",
        "api_signature": "operation_names_for_qargs(self, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "instruction_supported",
        "full_api_name": "Target.instruction_supported",
        "api_description": "Return whether the instruction (operation + qubits) is supported by the target\n\nArgs:\n    operation_name (str): The name of the operation for the instruction. Either\n        this or ``operation_class`` must be specified, if both are specified\n        ``operation_class`` will take priority and this argument will be ignored.\n    qargs (tuple): The tuple of qubit indices for the instruction. If this is\n        not specified then this method will return ``True`` if the specified\n        operation is supported on any qubits. The typical application will\n        always have this set (otherwise it's the same as just checking if the\n        target contains the operation). Normally you would not set this argument\n        if you wanted to check more generally that the target supports an operation\n        with the ``parameters`` on any qubits.\n    operation_class (Type[qiskit.circuit.Instruction]): The operation class to check whether\n        the target supports a particular operation by class rather\n        than by name. This lookup is more expensive as it needs to\n        iterate over all operations in the target instead of just a\n        single lookup. If this is specified it will supersede the\n        ``operation_name`` argument. The typical use case for this\n        operation is to check whether a specific variant of an operation\n        is supported on the backend. For example, if you wanted to\n        check whether a :class:`~.RXGate` was supported on a specific\n        qubit with a fixed angle. That fixed angle variant will\n        typically have a name different than the object's\n        :attr:`~.Instruction.name` attribute (``\"rx\"``) in the target.\n        This can be used to check if any instances of the class are\n        available in such a case.\n    parameters (list): A list of parameters to check if the target\n        supports them on the specified qubits. If the instruction\n        supports the parameter values specified in the list on the\n        operation and qargs specified this will return ``True`` but\n        if the parameters are not supported on the specified\n        instruction it will return ``False``. If this argument is not\n        specified this method will return ``True`` if the instruction\n        is supported independent of the instruction parameters. If\n        specified with any :class:`~.Parameter` objects in the list,\n        that entry will be treated as supporting any value, however parameter names\n        will not be checked (for example if an operation in the target\n        is listed as parameterized with ``\"theta\"`` and ``\"phi\"`` is\n        passed into this function that will return ``True``). For\n        example, if called with::\n\n            parameters = [Parameter(\"theta\")]\n            target.instruction_supported(\"rx\", (0,), parameters=parameters)\n\n        will return ``True`` if an :class:`~.RXGate` is suporrted on qubit 0\n        that will accept any parameter. If you need to check for a fixed numeric\n        value parameter this argument is typically paired with the ``operation_class``\n        argument. For example::\n\n            target.instruction_supported(\"rx\", (0,), RXGate, parameters=[pi / 4])\n\n        will return ``True`` if an RXGate(pi/4) exists on qubit 0.\n\nReturns:\n    bool: Returns ``True`` if the instruction is supported and ``False`` if it isn't.",
        "api_signature": "instruction_supported(self, operation_name, qargs, operation_class, parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "check_obj_params",
        "full_api_name": "Target.check_obj_params",
        "api_description": "",
        "api_signature": "check_obj_params(parameters, obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "has_calibration",
        "full_api_name": "Target.has_calibration",
        "api_description": "Return whether the instruction (operation + qubits) defines a calibration.\n\nArgs:\n    operation_name: The name of the operation for the instruction.\n    qargs: The tuple of qubit indices for the instruction.\n\nReturns:\n    Returns ``True`` if the calibration is supported and ``False`` if it isn't.",
        "api_signature": "has_calibration(self, operation_name, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "get_calibration",
        "full_api_name": "Target.get_calibration",
        "api_description": "Get calibrated pulse schedule for the instruction.\n\nIf calibration is templated with parameters, one can also provide those values\nto build a schedule with assigned parameters.\n\nArgs:\n    operation_name: The name of the operation for the instruction.\n    qargs: The tuple of qubit indices for the instruction.\n    args: Parameter values to build schedule if any.\n    kwargs: Parameter values with name to build schedule if any.\n\nReturns:\n    Calibrated pulse schedule of corresponding instruction.",
        "api_signature": "get_calibration(self, operation_name, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "operation_names",
        "full_api_name": "Target.operation_names",
        "api_description": "Get the operation names in the target.",
        "api_signature": "operation_names(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "operations",
        "full_api_name": "Target.operations",
        "api_description": "Get the operation class objects in the target.",
        "api_signature": "operations(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "instructions",
        "full_api_name": "Target.instructions",
        "api_description": "Get the list of tuples ``(:class:`~qiskit.circuit.Instruction`, (qargs))``\nfor the target\n\nFor globally defined variable width operations the tuple will be of the form\n``(class, None)`` where class is the actual operation class that\nis globally defined.",
        "api_signature": "instructions(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "instruction_properties",
        "full_api_name": "Target.instruction_properties",
        "api_description": "Get the instruction properties for a specific instruction tuple\n\nThis method is to be used in conjunction with the\n:attr:`~qiskit.transpiler.Target.instructions` attribute of a\n:class:`~qiskit.transpiler.Target` object. You can use this method to quickly\nget the instruction properties for an element of\n:attr:`~qiskit.transpiler.Target.instructions` by using the index in that list.\nHowever, if you're not working with :attr:`~qiskit.transpiler.Target.instructions`\ndirectly it is likely more efficient to access the target directly via the name\nand qubits to get the instruction properties. For example, if\n:attr:`~qiskit.transpiler.Target.instructions` returned::\n\n    [(XGate(), (0,)), (XGate(), (1,))]\n\nyou could get the properties of the ``XGate`` on qubit 1 with::\n\n    props = target.instruction_properties(1)\n\nbut just accessing it directly via the name would be more efficient::\n\n    props = target['x'][(1,)]\n\n(assuming the ``XGate``'s canonical name in the target is ``'x'``)\nThis is especially true for larger targets as this will scale worse with the number\nof instruction tuples in a target.\n\nArgs:\n    index (int): The index of the instruction tuple from the\n        :attr:`~qiskit.transpiler.Target.instructions` attribute. For, example\n        if you want the properties from the third element in\n        :attr:`~qiskit.transpiler.Target.instructions` you would set this to be ``2``.\nReturns:\n    InstructionProperties: The instruction properties for the specified instruction tuple",
        "api_signature": "instruction_properties(self, index)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "_build_coupling_graph",
        "full_api_name": "Target._build_coupling_graph",
        "api_description": "",
        "api_signature": "_build_coupling_graph(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "build_coupling_map",
        "full_api_name": "Target.build_coupling_map",
        "api_description": "Get a :class:`~qiskit.transpiler.CouplingMap` from this target.\n\nIf there is a mix of two qubit operations that have a connectivity\nconstraint and those that are globally defined this will also return\n``None`` because the globally connectivity means there is no constraint\non the target. If you wish to see the constraints of the two qubit\noperations that have constraints you should use the ``two_q_gate``\nargument to limit the output to the gates which have a constraint.\n\nArgs:\n    two_q_gate (str): An optional gate name for a two qubit gate in\n        the Target to generate the coupling map for. If specified the\n        output coupling map will only have edges between qubits where\n        this gate is present.\n    filter_idle_qubits (bool): If set to ``True`` the output :class:`~.CouplingMap`\n        will remove any qubits that don't have any operations defined in the\n        target. Note that using this argument will result in an output\n        :class:`~.CouplingMap` object which has holes in its indices\n        which might differ from the assumptions of the class. The typical use\n        case of this argument is to be paired with with\n        :meth:`.CouplingMap.connected_components` which will handle the holes\n        as expected.\nReturns:\n    CouplingMap: The :class:`~qiskit.transpiler.CouplingMap` object\n        for this target. If there are no connectivity constraints in\n        the target this will return ``None``.\n\nRaises:\n    ValueError: If a non-two qubit gate is passed in for ``two_q_gate``.\n    IndexError: If an Instruction not in the Target is passed in for\n        ``two_q_gate``.",
        "api_signature": "build_coupling_map(self, two_q_gate, filter_idle_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "_filter_coupling_graph",
        "full_api_name": "Target._filter_coupling_graph",
        "api_description": "",
        "api_signature": "_filter_coupling_graph(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "physical_qubits",
        "full_api_name": "Target.physical_qubits",
        "api_description": "Returns a sorted list of physical_qubits",
        "api_signature": "physical_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "get_non_global_operation_names",
        "full_api_name": "Target.get_non_global_operation_names",
        "api_description": "Return the non-global operation names for the target\n\nThe non-global operations are those in the target which don't apply\non all qubits (for single qubit operations) or all multiqubit qargs\n(for multi-qubit operations).\n\nArgs:\n    strict_direction (bool): If set to ``True`` the multi-qubit\n        operations considered as non-global respect the strict\n        direction (or order of qubits in the qargs is signifcant). For\n        example, if ``cx`` is defined on ``(0, 1)`` and ``ecr`` is\n        defined over ``(1, 0)`` by default neither would be considered\n        non-global, but if ``strict_direction`` is set ``True`` both\n        ``cx`` and ``ecr`` would be returned.\n\nReturns:\n    List[str]: A list of operation names for operations that aren't global in this target",
        "api_signature": "get_non_global_operation_names(self, strict_direction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "aquire_alignment",
        "full_api_name": "Target.aquire_alignment",
        "api_description": "Alias of deprecated name. This will be removed.",
        "api_signature": "aquire_alignment(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "aquire_alignment",
        "full_api_name": "Target.aquire_alignment",
        "api_description": "Alias of deprecated name. This will be removed.",
        "api_signature": "aquire_alignment(self, new_value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "__iter__",
        "full_api_name": "Target.__iter__",
        "api_description": "",
        "api_signature": "__iter__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "__getitem__",
        "full_api_name": "Target.__getitem__",
        "api_description": "",
        "api_signature": "__getitem__(self, key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "__len__",
        "full_api_name": "Target.__len__",
        "api_description": "",
        "api_signature": "__len__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "__contains__",
        "full_api_name": "Target.__contains__",
        "api_description": "",
        "api_signature": "__contains__(self, item)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "keys",
        "full_api_name": "Target.keys",
        "api_description": "",
        "api_signature": "keys(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "values",
        "full_api_name": "Target.values",
        "api_description": "",
        "api_signature": "values(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "items",
        "full_api_name": "Target.items",
        "api_description": "",
        "api_signature": "items(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "Target.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "from_configuration",
        "full_api_name": "Target.from_configuration",
        "api_description": "Create a target object from the individual global configuration\n\nPrior to the creation of the :class:`~.Target` class, the constraints\nof a backend were represented by a collection of different objects\nwhich combined represent a subset of the information contained in\nthe :class:`~.Target`. This function provides a simple interface\nto convert those separate objects to a :class:`~.Target`.\n\nThis constructor will use the input from ``basis_gates``, ``num_qubits``,\nand ``coupling_map`` to build a base model of the backend and the\n``instruction_durations``, ``backend_properties``, and ``inst_map`` inputs\nare then queried (in that order) based on that model to look up the properties\nof each instruction and qubit. If there is an inconsistency between the inputs\nany extra or conflicting information present in ``instruction_durations``,\n``backend_properties``, or ``inst_map`` will be ignored.\n\nArgs:\n    basis_gates: The list of basis gate names for the backend. For the\n        target to be created these names must either be in the output\n        from :func:~.get_standard_gate_name_mapping` or present in the\n        specified ``custom_name_mapping`` argument.\n    num_qubits: The number of qubits supported on the backend.\n    coupling_map: The coupling map representing connectivity constraints\n        on the backend. If specified all gates from ``basis_gates`` will\n        be supported on all qubits (or pairs of qubits).\n    inst_map: The instruction schedule map representing the pulse\n       :class:`~.Schedule` definitions for each instruction. If this\n       is specified ``coupling_map`` must be specified. The\n       ``coupling_map`` is used as the source of truth for connectivity\n       and if ``inst_map`` is used the schedule is looked up based\n       on the instuctions from the pair of ``basis_gates`` and\n       ``coupling_map``. If you want to define a custom gate for\n       a particular qubit or qubit pair, you can manually build :class:`.Target`.\n    backend_properties: The :class:`~.BackendProperties` object which is\n        used for instruction properties and qubit properties.\n        If specified and instruction properties are intended to be used\n        then the ``coupling_map`` argument must be specified. This is\n        only used to lookup error rates and durations (unless\n        ``instruction_durations`` is specified which would take\n        precedence) for instructions specified via ``coupling_map`` and\n        ``basis_gates``.\n    instruction_durations: Optional instruction durations for instructions. If specified\n        it will take priority for setting the ``duration`` field in the\n        :class:`~InstructionProperties` objects for the instructions in the target.\n    concurrent_measurements(list): A list of sets of qubits that must be\n        measured together. This must be provided\n        as a nested list like [[0, 1], [2, 3, 4]].\n    dt: The system time resolution of input signals in seconds\n    timing_constraints: Optional timing constraints to include in the\n        :class:`~.Target`\n    custom_name_mapping: An optional dictionary that maps custom gate/operation names in\n        ``basis_gates`` to an :class:`~.Operation` object representing that\n        gate/operation. By default most standard gates names are mapped to the\n        standard gate object from :mod:`qiskit.circuit.library` this only needs\n        to be specified if the input ``basis_gates`` defines gates in names outside\n        that set.\n\nReturns:\n    Target: the target built from the input configuration\n\nRaises:\n    TranspilerError: If the input basis gates contain > 2 qubits and ``coupling_map`` is\n    specified.\n    KeyError: If no mapping is available for a specified ``basis_gate``.",
        "api_signature": "from_configuration(cls, basis_gates, num_qubits, coupling_map, inst_map, backend_properties, instruction_durations, concurrent_measurements, dt, timing_constraints, custom_name_mapping)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "target_to_backend_properties",
        "full_api_name": "target_to_backend_properties",
        "api_description": "Convert a :class:`~.Target` object into a legacy :class:`~.BackendProperties`",
        "api_signature": "target_to_backend_properties(target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "_has_control_flow",
        "full_api_name": "_has_control_flow",
        "api_description": "",
        "api_signature": "_has_control_flow(property_set)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/common.py"
    },
    {
        "api_name": "_without_control_flow",
        "full_api_name": "_without_control_flow",
        "api_description": "",
        "api_signature": "_without_control_flow(property_set)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/common.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "_InvalidControlFlowForBackend.__init__",
        "api_description": "",
        "api_signature": "__init__(self, basis_gates, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/common.py"
    },
    {
        "api_name": "message",
        "full_api_name": "_InvalidControlFlowForBackend.message",
        "api_description": "Create an error message for the given property set.",
        "api_signature": "message(self, property_set)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/common.py"
    },
    {
        "api_name": "condition",
        "full_api_name": "_InvalidControlFlowForBackend.condition",
        "api_description": "Checkable condition for the given property set.",
        "api_signature": "condition(self, property_set)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/common.py"
    },
    {
        "api_name": "generate_control_flow_options_check",
        "full_api_name": "generate_control_flow_options_check",
        "api_description": "Generate a pass manager that, when run on a DAG that contains control flow, fails with an\nerror message explaining the invalid options, and what could be used instead.\n\nReturns:\n    PassManager: a pass manager that populates the ``contains_x`` properties for each of the\n    control-flow operations, and raises an error if any of the given options do not support\n    control flow, but a circuit with control flow is given.",
        "api_signature": "generate_control_flow_options_check(layout_method, routing_method, translation_method, optimization_method, scheduling_method, basis_gates, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/common.py"
    },
    {
        "api_name": "generate_error_on_control_flow",
        "full_api_name": "generate_error_on_control_flow",
        "api_description": "Get a pass manager that always raises an error if control flow is present in a given\ncircuit.",
        "api_signature": "generate_error_on_control_flow(message)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/common.py"
    },
    {
        "api_name": "if_has_control_flow_else",
        "full_api_name": "if_has_control_flow_else",
        "api_description": "Generate a pass manager that will run the passes in ``if_present`` if the given circuit\nhas control-flow operations in it, and those in ``if_absent`` if it doesn't.",
        "api_signature": "if_has_control_flow_else(if_present, if_absent)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/common.py"
    },
    {
        "api_name": "generate_unroll_3q",
        "full_api_name": "generate_unroll_3q",
        "api_description": "Generate an unroll >3q :class:`~qiskit.transpiler.PassManager`\n\nArgs:\n    target (Target): the :class:`~.Target` object representing the backend\n    basis_gates (list): A list of str gate names that represent the basis\n        gates on the backend target\n    approximation_degree (Optional[float]): The heuristic approximation degree to\n        use. Can be between 0 and 1.\n    unitary_synthesis_method (str): The unitary synthesis method to use. You can see\n        a list of installed plugins with :func:`.unitary_synthesis_plugin_names`.\n    unitary_synthesis_plugin_config (dict): The optional dictionary plugin\n        configuration, this is plugin specific refer to the specified plugin's\n        documentation for how to use.\n    hls_config (HLSConfig): An optional configuration class to use for\n            :class:`~qiskit.transpiler.passes.HighLevelSynthesis` pass.\n            Specifies how to synthesize various high-level objects.\n\nReturns:\n    PassManager: The unroll 3q or more pass manager",
        "api_signature": "generate_unroll_3q(target, basis_gates, approximation_degree, unitary_synthesis_method, unitary_synthesis_plugin_config, hls_config)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/common.py"
    },
    {
        "api_name": "generate_embed_passmanager",
        "full_api_name": "generate_embed_passmanager",
        "api_description": "Generate a layout embedding :class:`~qiskit.transpiler.PassManager`\n\nThis is used to generate a :class:`~qiskit.transpiler.PassManager` object\nthat can be used to expand and apply an initial layout to a circuit\n\nArgs:\n    coupling_map (Union[CouplingMap, Target): The coupling map for the backend to embed\n        the circuit to.\nReturns:\n    PassManager: The embedding passmanager that assumes the layout property\n        set has been set in earlier stages",
        "api_signature": "generate_embed_passmanager(coupling_map)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/common.py"
    },
    {
        "api_name": "_layout_not_perfect",
        "full_api_name": "_layout_not_perfect",
        "api_description": "Return ``True`` if the first attempt at layout has been checked and found to be imperfect.\nIn this case, perfection means \"does not require any swap routing\".",
        "api_signature": "_layout_not_perfect(property_set)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/common.py"
    },
    {
        "api_name": "_apply_post_layout_condition",
        "full_api_name": "_apply_post_layout_condition",
        "api_description": "",
        "api_signature": "_apply_post_layout_condition(property_set)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/common.py"
    },
    {
        "api_name": "generate_routing_passmanager",
        "full_api_name": "generate_routing_passmanager",
        "api_description": "Generate a routing :class:`~qiskit.transpiler.PassManager`\n\nArgs:\n    routing_pass (TransformationPass): The pass which will perform the\n        routing\n    target (Target): the :class:`~.Target` object representing the backend\n    coupling_map (CouplingMap): The coupling map of the backend to route\n        for\n    vf2_call_limit (int): The internal call limit for the vf2 post layout\n        pass. If this is ``None`` or ``0`` the vf2 post layout will not be\n        run.\n    backend_properties (BackendProperties): Properties of a backend to\n        synthesize for (e.g. gate fidelities).\n    seed_transpiler (int): Sets random seed for the stochastic parts of\n        the transpiler.\n    check_trivial (bool): If set to true this will condition running the\n        :class:`~.VF2PostLayout` pass after routing on whether a trivial\n        layout was tried and was found to not be perfect. This is only\n        needed if the constructed pass manager runs :class:`~.TrivialLayout`\n        as a first layout attempt and uses it if it's a perfect layout\n        (as is the case with preset pass manager level 1).\n    use_barrier_before_measurement (bool): If true (the default) the\n        :class:`~.BarrierBeforeFinalMeasurements` transpiler pass will be run prior to the\n        specified pass in the ``routing_pass`` argument.\n    vf2_max_trials (int): The maximum number of trials to run VF2 when\n        evaluating the vf2 post layout\n        pass. If this is ``None`` or ``0`` the vf2 post layout will not be run.\nReturns:\n    PassManager: The routing pass manager",
        "api_signature": "generate_routing_passmanager(routing_pass, target, coupling_map, vf2_call_limit, backend_properties, seed_transpiler, check_trivial, use_barrier_before_measurement, vf2_max_trials)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/common.py"
    },
    {
        "api_name": "_run_post_layout_condition",
        "full_api_name": "_run_post_layout_condition",
        "api_description": "",
        "api_signature": "_run_post_layout_condition(property_set)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/common.py"
    },
    {
        "api_name": "_swap_condition",
        "full_api_name": "_swap_condition",
        "api_description": "",
        "api_signature": "_swap_condition(property_set)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/common.py"
    },
    {
        "api_name": "generate_pre_op_passmanager",
        "full_api_name": "generate_pre_op_passmanager",
        "api_description": "Generate a pre-optimization loop :class:`~qiskit.transpiler.PassManager`\n\nThis pass manager will check to ensure that directionality from the coupling\nmap is respected\n\nArgs:\n    target (Target): the :class:`~.Target` object representing the backend\n    coupling_map (CouplingMap): The coupling map to use\n    remove_reset_in_zero (bool): If ``True`` include the remove reset in\n        zero pass in the generated PassManager\nReturns:\n    PassManager: The pass manager",
        "api_signature": "generate_pre_op_passmanager(target, coupling_map, remove_reset_in_zero)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/common.py"
    },
    {
        "api_name": "_direction_condition",
        "full_api_name": "_direction_condition",
        "api_description": "",
        "api_signature": "_direction_condition(property_set)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/common.py"
    },
    {
        "api_name": "generate_translation_passmanager",
        "full_api_name": "generate_translation_passmanager",
        "api_description": "Generate a basis translation :class:`~qiskit.transpiler.PassManager`\n\nArgs:\n    target (Target): the :class:`~.Target` object representing the backend\n    basis_gates (list): A list of str gate names that represent the basis\n        gates on the backend target\n    method (str): The basis translation method to use\n    approximation_degree (Optional[float]): The heuristic approximation degree to\n        use. Can be between 0 and 1.\n    coupling_map (CouplingMap): the coupling map of the backend\n        in case synthesis is done on a physical circuit. The\n        directionality of the coupling_map will be taken into\n        account if pulse_optimize is True/None and natural_direction\n        is True/None.\n    unitary_synthesis_plugin_config (dict): The optional dictionary plugin\n        configuration, this is plugin specific refer to the specified plugin's\n        documentation for how to use.\n    backend_props (BackendProperties): Properties of a backend to\n        synthesize for (e.g. gate fidelities).\n    unitary_synthesis_method (str): The unitary synthesis method to use. You can\n        see a list of installed plugins with :func:`.unitary_synthesis_plugin_names`.\n    hls_config (HLSConfig): An optional configuration class to use for\n        :class:`~qiskit.transpiler.passes.HighLevelSynthesis` pass.\n        Specifies how to synthesize various high-level objects.\n\nReturns:\n    PassManager: The basis translation pass manager\n\nRaises:\n    TranspilerError: If the ``method`` kwarg is not a valid value",
        "api_signature": "generate_translation_passmanager(target, basis_gates, method, approximation_degree, coupling_map, backend_props, unitary_synthesis_method, unitary_synthesis_plugin_config, hls_config)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/common.py"
    },
    {
        "api_name": "generate_scheduling",
        "full_api_name": "generate_scheduling",
        "api_description": "Generate a post optimization scheduling :class:`~qiskit.transpiler.PassManager`\n\nArgs:\n    instruction_durations (dict): The dictionary of instruction durations\n    scheduling_method (str): The scheduling method to use, can either be\n        ``'asap'``/``'as_soon_as_possible'`` or\n        ``'alap'``/``'as_late_as_possible'``\n    timing_constraints (TimingConstraints): Hardware time alignment restrictions.\n    inst_map (InstructionScheduleMap): Mapping object that maps gate to schedule.\n    target (Target): The :class:`~.Target` object representing the backend\n\nReturns:\n    PassManager: The scheduling pass manager\n\nRaises:\n    TranspilerError: If the ``scheduling_method`` kwarg is not a valid value",
        "api_signature": "generate_scheduling(instruction_durations, scheduling_method, timing_constraints, inst_map, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/common.py"
    },
    {
        "api_name": "_contains_delay",
        "full_api_name": "_contains_delay",
        "api_description": "",
        "api_signature": "_contains_delay(property_set)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/common.py"
    },
    {
        "api_name": "_require_alignment",
        "full_api_name": "_require_alignment",
        "api_description": "",
        "api_signature": "_require_alignment(property_set)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/common.py"
    },
    {
        "api_name": "get_vf2_call_limit",
        "full_api_name": "get_vf2_call_limit",
        "api_description": "Get the vf2 call limit for vf2 based layout passes.",
        "api_signature": "get_vf2_call_limit(optimization_level, layout_method, initial_layout)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/common.py"
    },
    {
        "api_name": "get_vf2_limits",
        "full_api_name": "get_vf2_limits",
        "api_description": "Get the VF2 limits for VF2-based layout passes.\n\nReturns:\n    VF2Limits: An namedtuple with optional elements\n    ``call_limit`` and ``max_trials``.",
        "api_signature": "get_vf2_limits(optimization_level, layout_method, initial_layout)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/common.py"
    },
    {
        "api_name": "level_0_pass_manager",
        "full_api_name": "level_0_pass_manager",
        "api_description": "Level 0 pass manager: no explicit optimization other than mapping to backend.\n\nThis pass manager applies the user-given initial layout. If none is given, a trivial\nlayout consisting of mapping the i-th virtual qubit to the i-th physical qubit is used.\nAny unused physical qubit is allocated as ancilla space.\n\nThe pass manager then unrolls the circuit to the desired basis, and transforms the\ncircuit to match the coupling map.\n\nArgs:\n    pass_manager_config: configuration of the pass manager.\n\nReturns:\n    a level 0 pass manager.\n\nRaises:\n    TranspilerError: if the passmanager config is invalid.",
        "api_signature": "level_0_pass_manager(pass_manager_config)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/level0.py"
    },
    {
        "api_name": "pass_manager",
        "full_api_name": "PassManagerStagePlugin.pass_manager",
        "api_description": "This method is designed to return a :class:`~.PassManager` for the stage this implements\n\nArgs:\n    pass_manager_config: A configuration object that defines all the target device\n        specifications and any user specified options to :func:`~.transpile` or\n        :func:`~.generate_preset_pass_manager`\n    optimization_level: The optimization level of the transpilation, if set this\n        should be used to set values for any tunable parameters to trade off runtime\n        for potential optimization. Valid values should be ``0``, ``1``, ``2``, or ``3``\n        and the higher the number the more optimization is expected.",
        "api_signature": "pass_manager(self, pass_manager_config, optimization_level)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/plugin.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PassManagerStagePluginManager.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/plugin.py"
    },
    {
        "api_name": "get_passmanager_stage",
        "full_api_name": "PassManagerStagePluginManager.get_passmanager_stage",
        "api_description": "Get a stage",
        "api_signature": "get_passmanager_stage(self, stage_name, plugin_name, pm_config, optimization_level)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/plugin.py"
    },
    {
        "api_name": "_build_pm",
        "full_api_name": "PassManagerStagePluginManager._build_pm",
        "api_description": "",
        "api_signature": "_build_pm(self, stage_obj, stage_name, plugin_name, pm_config, optimization_level)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/plugin.py"
    },
    {
        "api_name": "list_stage_plugins",
        "full_api_name": "list_stage_plugins",
        "api_description": "Get a list of installed plugins for a stage.\n\nArgs:\n    stage_name: The stage name to get the plugin names for\n\nReturns:\n    plugins: The list of installed plugin names for the specified stages\n\nRaises:\n   TranspilerError: If an invalid stage name is specified.",
        "api_signature": "list_stage_plugins(stage_name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/plugin.py"
    },
    {
        "api_name": "passmanager_stage_plugins",
        "full_api_name": "passmanager_stage_plugins",
        "api_description": "Return a dict with, for each stage name, the class type of the plugin.\n\nThis function is useful for getting more information about a plugin:\n\n.. code-block:: python\n\n    from qiskit.transpiler.preset_passmanagers.plugin import passmanager_stage_plugins\n    routing_plugins = passmanager_stage_plugins('routing')\n    basic_plugin = routing_plugins['basic']\n    help(basic_plugin)\n\n.. code-block:: text\n\n    Help on BasicSwapPassManager in module ...preset_passmanagers.builtin_plugins object:\n\n    class BasicSwapPassManager(...preset_passmanagers.plugin.PassManagerStagePlugin)\n     |  Plugin class for routing stage with :class:`~.BasicSwap`\n     |\n     |  Method resolution order:\n     |      BasicSwapPassManager\n     |      ...preset_passmanagers.plugin.PassManagerStagePlugin\n     |      abc.ABC\n     |      builtins.object\n     ...\n\nArgs:\n    stage: The stage name to get\n\nReturns:\n    dict: the key is the name of the plugin and the value is the class type for each.\n\nRaises:\n   TranspilerError: If an invalid stage name is specified.",
        "api_signature": "passmanager_stage_plugins(stage)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/plugin.py"
    },
    {
        "api_name": "pass_manager",
        "full_api_name": "DefaultInitPassManager.pass_manager",
        "api_description": "",
        "api_signature": "pass_manager(self, pass_manager_config, optimization_level)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/builtin_plugins.py"
    },
    {
        "api_name": "pass_manager",
        "full_api_name": "BasisTranslatorPassManager.pass_manager",
        "api_description": "",
        "api_signature": "pass_manager(self, pass_manager_config, optimization_level)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/builtin_plugins.py"
    },
    {
        "api_name": "pass_manager",
        "full_api_name": "UnrollerPassManager.pass_manager",
        "api_description": "",
        "api_signature": "pass_manager(self, pass_manager_config, optimization_level)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/builtin_plugins.py"
    },
    {
        "api_name": "pass_manager",
        "full_api_name": "UnitarySynthesisPassManager.pass_manager",
        "api_description": "",
        "api_signature": "pass_manager(self, pass_manager_config, optimization_level)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/builtin_plugins.py"
    },
    {
        "api_name": "pass_manager",
        "full_api_name": "BasicSwapPassManager.pass_manager",
        "api_description": "Build routing stage PassManager.",
        "api_signature": "pass_manager(self, pass_manager_config, optimization_level)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/builtin_plugins.py"
    },
    {
        "api_name": "pass_manager",
        "full_api_name": "StochasticSwapPassManager.pass_manager",
        "api_description": "Build routing stage PassManager.",
        "api_signature": "pass_manager(self, pass_manager_config, optimization_level)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/builtin_plugins.py"
    },
    {
        "api_name": "pass_manager",
        "full_api_name": "LookaheadSwapPassManager.pass_manager",
        "api_description": "Build routing stage PassManager.",
        "api_signature": "pass_manager(self, pass_manager_config, optimization_level)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/builtin_plugins.py"
    },
    {
        "api_name": "pass_manager",
        "full_api_name": "SabreSwapPassManager.pass_manager",
        "api_description": "Build routing stage PassManager.",
        "api_signature": "pass_manager(self, pass_manager_config, optimization_level)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/builtin_plugins.py"
    },
    {
        "api_name": "pass_manager",
        "full_api_name": "NoneRoutingPassManager.pass_manager",
        "api_description": "Build routing stage PassManager.",
        "api_signature": "pass_manager(self, pass_manager_config, optimization_level)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/builtin_plugins.py"
    },
    {
        "api_name": "pass_manager",
        "full_api_name": "OptimizationPassManager.pass_manager",
        "api_description": "Build pass manager for optimization stage.",
        "api_signature": "pass_manager(self, pass_manager_config, optimization_level)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/builtin_plugins.py"
    },
    {
        "api_name": "_opt_control",
        "full_api_name": "OptimizationPassManager._opt_control",
        "api_description": "",
        "api_signature": "_opt_control(property_set)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/builtin_plugins.py"
    },
    {
        "api_name": "_opt_control",
        "full_api_name": "OptimizationPassManager._opt_control",
        "api_description": "",
        "api_signature": "_opt_control(property_set)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/builtin_plugins.py"
    },
    {
        "api_name": "_unroll_condition",
        "full_api_name": "OptimizationPassManager._unroll_condition",
        "api_description": "",
        "api_signature": "_unroll_condition(property_set)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/builtin_plugins.py"
    },
    {
        "api_name": "pass_manager",
        "full_api_name": "AlapSchedulingPassManager.pass_manager",
        "api_description": "Build scheduling stage PassManager",
        "api_signature": "pass_manager(self, pass_manager_config, optimization_level)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/builtin_plugins.py"
    },
    {
        "api_name": "pass_manager",
        "full_api_name": "AsapSchedulingPassManager.pass_manager",
        "api_description": "Build scheduling stage PassManager",
        "api_signature": "pass_manager(self, pass_manager_config, optimization_level)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/builtin_plugins.py"
    },
    {
        "api_name": "pass_manager",
        "full_api_name": "DefaultSchedulingPassManager.pass_manager",
        "api_description": "Build scheduling stage PassManager",
        "api_signature": "pass_manager(self, pass_manager_config, optimization_level)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/builtin_plugins.py"
    },
    {
        "api_name": "pass_manager",
        "full_api_name": "DefaultLayoutPassManager.pass_manager",
        "api_description": "",
        "api_signature": "pass_manager(self, pass_manager_config, optimization_level)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/builtin_plugins.py"
    },
    {
        "api_name": "_choose_layout_condition",
        "full_api_name": "DefaultLayoutPassManager._choose_layout_condition",
        "api_description": "",
        "api_signature": "_choose_layout_condition(property_set)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/builtin_plugins.py"
    },
    {
        "api_name": "_layout_not_perfect",
        "full_api_name": "DefaultLayoutPassManager._layout_not_perfect",
        "api_description": "Return ``True`` if the first attempt at layout has been checked and found to be\nimperfect.  In this case, perfection means \"does not require any swap routing\".",
        "api_signature": "_layout_not_perfect(property_set)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/builtin_plugins.py"
    },
    {
        "api_name": "_vf2_match_not_found",
        "full_api_name": "DefaultLayoutPassManager._vf2_match_not_found",
        "api_description": "",
        "api_signature": "_vf2_match_not_found(property_set)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/builtin_plugins.py"
    },
    {
        "api_name": "_swap_mapped",
        "full_api_name": "DefaultLayoutPassManager._swap_mapped",
        "api_description": "",
        "api_signature": "_swap_mapped(property_set)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/builtin_plugins.py"
    },
    {
        "api_name": "pass_manager",
        "full_api_name": "TrivialLayoutPassManager.pass_manager",
        "api_description": "",
        "api_signature": "pass_manager(self, pass_manager_config, optimization_level)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/builtin_plugins.py"
    },
    {
        "api_name": "_choose_layout_condition",
        "full_api_name": "TrivialLayoutPassManager._choose_layout_condition",
        "api_description": "",
        "api_signature": "_choose_layout_condition(property_set)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/builtin_plugins.py"
    },
    {
        "api_name": "pass_manager",
        "full_api_name": "DenseLayoutPassManager.pass_manager",
        "api_description": "",
        "api_signature": "pass_manager(self, pass_manager_config, optimization_level)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/builtin_plugins.py"
    },
    {
        "api_name": "_choose_layout_condition",
        "full_api_name": "DenseLayoutPassManager._choose_layout_condition",
        "api_description": "",
        "api_signature": "_choose_layout_condition(property_set)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/builtin_plugins.py"
    },
    {
        "api_name": "pass_manager",
        "full_api_name": "NoiseAdaptiveLayoutPassManager.pass_manager",
        "api_description": "",
        "api_signature": "pass_manager(self, pass_manager_config, optimization_level)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/builtin_plugins.py"
    },
    {
        "api_name": "_choose_layout_condition",
        "full_api_name": "NoiseAdaptiveLayoutPassManager._choose_layout_condition",
        "api_description": "",
        "api_signature": "_choose_layout_condition(property_set)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/builtin_plugins.py"
    },
    {
        "api_name": "pass_manager",
        "full_api_name": "SabreLayoutPassManager.pass_manager",
        "api_description": "",
        "api_signature": "pass_manager(self, pass_manager_config, optimization_level)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/builtin_plugins.py"
    },
    {
        "api_name": "_choose_layout_condition",
        "full_api_name": "SabreLayoutPassManager._choose_layout_condition",
        "api_description": "",
        "api_signature": "_choose_layout_condition(property_set)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/builtin_plugins.py"
    },
    {
        "api_name": "_swap_mapped",
        "full_api_name": "SabreLayoutPassManager._swap_mapped",
        "api_description": "",
        "api_signature": "_swap_mapped(property_set)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/builtin_plugins.py"
    },
    {
        "api_name": "level_3_pass_manager",
        "full_api_name": "level_3_pass_manager",
        "api_description": "Level 3 pass manager: heavy optimization by noise adaptive qubit mapping and\ngate cancellation using commutativity rules and unitary synthesis.\n\nThis pass manager applies the user-given initial layout. If none is given, a search\nfor a perfect layout (i.e. one that satisfies all 2-qubit interactions) is conducted.\nIf no such layout is found, and device calibration information is available, the\ncircuit is mapped to the qubits with best readouts and to CX gates with highest fidelity.\n\nThe pass manager then transforms the circuit to match the coupling constraints.\nIt is then unrolled to the basis, and any flipped cx directions are fixed.\nFinally, optimizations in the form of commutative gate cancellation, resynthesis\nof two-qubit unitary blocks, and redundant reset removal are performed.\n\nArgs:\n    pass_manager_config: configuration of the pass manager.\n\nReturns:\n    a level 3 pass manager.\n\nRaises:\n    TranspilerError: if the passmanager config is invalid.",
        "api_signature": "level_3_pass_manager(pass_manager_config)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/level3.py"
    },
    {
        "api_name": "level_1_pass_manager",
        "full_api_name": "level_1_pass_manager",
        "api_description": "Level 1 pass manager: light optimization by simple adjacent gate collapsing.\n\nThis pass manager applies the user-given initial layout. If none is given,\nand a trivial layout (i-th virtual -> i-th physical) makes the circuit fit\nthe coupling map, that is used.\nOtherwise, the circuit is mapped to the most densely connected coupling subgraph,\nand swaps are inserted to map. Any unused physical qubit is allocated as ancilla space.\nThe pass manager then unrolls the circuit to the desired basis, and transforms the\ncircuit to match the coupling map. Finally, optimizations in the form of adjacent\ngate collapse and redundant reset removal are performed.\n\nArgs:\n    pass_manager_config: configuration of the pass manager.\n\nReturns:\n    a level 1 pass manager.\n\nRaises:\n    TranspilerError: if the passmanager config is invalid.",
        "api_signature": "level_1_pass_manager(pass_manager_config)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/level1.py"
    },
    {
        "api_name": "generate_preset_pass_manager",
        "full_api_name": "generate_preset_pass_manager",
        "api_description": "Generate a preset :class:`~.PassManager`\n\nThis function is used to quickly generate a preset pass manager. A preset pass\nmanager are the default pass managers used by the :func:`~.transpile`\nfunction. This function provides a convenient and simple method to construct\na standalone :class:`~.PassManager` object that mirrors what the transpile\n\n\nArgs:\n    optimization_level (int): The optimization level to generate a\n        :class:`~.PassManager` for. This can be 0, 1, 2, or 3. Higher\n        levels generate more optimized circuits, at the expense of\n        longer transpilation time:\n\n            * 0: no optimization\n            * 1: light optimization\n            * 2: heavy optimization\n            * 3: even heavier optimization\n\n    backend (Backend): An optional backend object which can be used as the\n        source of the default values for the ``basis_gates``, ``inst_map``,\n        ``couplig_map``, ``backend_properties``, ``instruction_durations``,\n        ``timing_constraints``, and ``target``. If any of those other arguments\n        are specified in addition to ``backend`` they will take precedence\n        over the value contained in the backend.\n    target (Target): The :class:`~.Target` representing a backend compilation\n        target. The following attributes will be inferred from this\n        argument if they are not set: ``coupling_map``, ``basis_gates``,\n        ``instruction_durations``, ``inst_map``, ``timing_constraints``\n        and ``backend_properties``.\n    basis_gates (list): List of basis gate names to unroll to\n        (e.g: ``['u1', 'u2', 'u3', 'cx']``).\n    inst_map (InstructionScheduleMap): Mapping object that maps gate to schedules.\n        If any user defined calibration is found in the map and this is used in a\n        circuit, transpiler attaches the custom gate definition to the circuit.\n        This enables one to flexibly override the low-level instruction\n        implementation.\n    coupling_map (CouplingMap): Directed graph represented a coupling\n        map.\n    instruction_durations (InstructionDurations): Dictionary of duration\n        (in dt) for each instruction.\n    timing_constraints (TimingConstraints): Hardware time alignment restrictions.\n    initial_layout (Layout): Initial position of virtual qubits on\n        physical qubits.\n    layout_method (str): The :class:`~.Pass` to use for choosing initial qubit\n        placement. Valid choices are ``'trivial'``, ``'dense'``, ``'noise_adaptive'``,\n        and, ``'sabre'`` representing :class:`~.TrivialLayout`, :class:`~DenseLayout`,\n        :class:`~.NoiseAdaptiveLayout`, :class:`~.SabreLayout` respectively. This can also\n        be the external plugin name to use for the ``layout`` stage of the output\n        :class:`~.StagedPassManager`. You can see a list of installed plugins by using\n        :func:`~.list_stage_plugins` with ``\"layout\"`` for the ``stage_name`` argument.\n    routing_method (str): The pass to use for routing qubits on the\n        architecture. Valid choices are ``'basic'``, ``'lookahead'``, ``'stochastic'``,\n        ``'sabre'``, and ``'none'`` representing :class:`~.BasicSwap`,\n        :class:`~.LookaheadSwap`, :class:`~.StochasticSwap`, :class:`~.SabreSwap`, and\n        erroring if routing is required respectively. This can also be the external plugin\n        name to use for the ``routing`` stage of the output :class:`~.StagedPassManager`.\n        You can see a list of installed plugins by using :func:`~.list_stage_plugins` with\n        ``\"routing\"`` for the ``stage_name`` argument.\n    translation_method (str): The method to use for translating gates to\n        basis gates. Valid choices ``'unroller'``, ``'translator'``, ``'synthesis'``\n        representing :class:`~.Unroller`, :class:`~.BasisTranslator`, and\n        :class:`~.UnitarySynthesis` respectively. This can also be the external plugin\n        name to use for the ``translation`` stage of the output :class:`~.StagedPassManager`.\n        You can see a list of installed plugins by using :func:`~.list_stage_plugins` with\n        ``\"translation\"`` for the ``stage_name`` argument.\n    scheduling_method (str): The pass to use for scheduling instructions. Valid choices\n        are ``'alap'`` and ``'asap'``. This can also be the external plugin name to use\n        for the ``scheduling`` stage of the output :class:`~.StagedPassManager`. You can\n        see a list of installed plugins by using :func:`~.list_stage_plugins` with\n        ``\"scheduling\"`` for the ``stage_name`` argument.\n    backend_properties (BackendProperties): Properties returned by a\n        backend, including information on gate errors, readout errors,\n        qubit coherence times, etc.\n    approximation_degree (float): Heuristic dial used for circuit approximation\n        (1.0=no approximation, 0.0=maximal approximation).\n    seed_transpiler (int): Sets random seed for the stochastic parts of\n        the transpiler.\n    unitary_synthesis_method (str): The name of the unitary synthesis\n        method to use. By default ``'default'`` is used. You can see a list of\n        installed plugins with :func:`.unitary_synthesis_plugin_names`.\n    unitary_synthesis_plugin_config (dict): An optional configuration dictionary\n        that will be passed directly to the unitary synthesis plugin. By\n        default this setting will have no effect as the default unitary\n        synthesis method does not take custom configuration. This should\n        only be necessary when a unitary synthesis plugin is specified with\n        the ``unitary_synthesis`` argument. As this is custom for each\n        unitary synthesis plugin refer to the plugin documentation for how\n        to use this option.\n    hls_config (HLSConfig): An optional configuration class :class:`~.HLSConfig`\n        that will be passed directly to :class:`~.HighLevelSynthesis` transformation pass.\n        This configuration class allows to specify for various high-level objects\n        the lists of synthesis algorithms and their parameters.\n    init_method (str): The plugin name to use for the ``init`` stage of\n        the output :class:`~.StagedPassManager`. By default an external\n        plugin is not used. You can see a list of installed plugins by\n        using :func:`~.list_stage_plugins` with ``\"init\"`` for the stage\n        name argument.\n    optimization_method (str): The plugin name to use for the\n        ``optimization`` stage of the output\n        :class:`~.StagedPassManager`. By default an external\n        plugin is not used. You can see a list of installed plugins by\n        using :func:`~.list_stage_plugins` with ``\"optimization\"`` for the\n        ``stage_name`` argument.\n\nReturns:\n    StagedPassManager: The preset pass manager for the given options\n\nRaises:\n    ValueError: if an invalid value for ``optimization_level`` is passed in.",
        "api_signature": "generate_preset_pass_manager(optimization_level, backend, target, basis_gates, inst_map, coupling_map, instruction_durations, backend_properties, timing_constraints, initial_layout, layout_method, routing_method, translation_method, scheduling_method, approximation_degree, seed_transpiler, unitary_synthesis_method, unitary_synthesis_plugin_config, hls_config, init_method, optimization_method)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/__init__.py"
    },
    {
        "api_name": "level_2_pass_manager",
        "full_api_name": "level_2_pass_manager",
        "api_description": "Level 2 pass manager: medium optimization by initial layout selection and\ngate cancellation using commutativity rules.\n\nThis pass manager applies the user-given initial layout. If none is given, a search\nfor a perfect layout (i.e. one that satisfies all 2-qubit interactions) is conducted.\nIf no such layout is found, qubits are laid out on the most densely connected subset\nwhich also exhibits the best gate fidelities.\n\nThe pass manager then transforms the circuit to match the coupling constraints.\nIt is then unrolled to the basis, and any flipped cx directions are fixed.\nFinally, optimizations in the form of commutative gate cancellation and redundant\nreset removal are performed.\n\nArgs:\n    pass_manager_config: configuration of the pass manager.\n\nReturns:\n    a level 2 pass manager.\n\nRaises:\n    TranspilerError: if the passmanager config is invalid.",
        "api_signature": "level_2_pass_manager(pass_manager_config)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/level2.py"
    },
    {
        "api_name": "map_blocks",
        "full_api_name": "map_blocks",
        "api_description": "Use the ``dag_mapping`` function to replace the blocks of a :class:`.ControlFlowOp` with new\nones.  Each block will be automatically converted to a :class:`.DAGCircuit` and then returned\nto a :class:`.QuantumCircuit`.",
        "api_signature": "map_blocks(dag_mapping, op)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/control_flow.py"
    },
    {
        "api_name": "trivial_recurse",
        "full_api_name": "trivial_recurse",
        "api_description": "Decorator that causes :class:`.BasePass.run` to iterate over all control-flow nodes,\nreplacing their operations with a new :class:`.ControlFlowOp` whose blocks have all had\n:class`.BasePass.run` called on them.\n\nThis is only suitable for simple run calls that store no state between calls, do not need\ncircuit-specific information feeding into them (such as via a :class:`.PropertySet`), and will\nsafely do nothing to control-flow operations that are in the DAG.\n\nIf slightly finer control is needed on when the control-flow operations are modified, one can\nuse :func:`map_blocks` as::\n\n    if isinstance(node.op, ControlFlowOp):\n        node.op = map_blocks(self.run, node.op)\n\nfrom with :meth:`.BasePass.run`.",
        "api_signature": "trivial_recurse(method)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/control_flow.py"
    },
    {
        "api_name": "out",
        "full_api_name": "out",
        "api_description": "",
        "api_signature": "out(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/control_flow.py"
    },
    {
        "api_name": "bound_wrapped_method",
        "full_api_name": "bound_wrapped_method",
        "api_description": "",
        "api_signature": "bound_wrapped_method(dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/control_flow.py"
    },
    {
        "api_name": "run",
        "full_api_name": "RemoveBarriers.run",
        "api_description": "Run the RemoveBarriers pass on `dag`.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/remove_barriers.py"
    },
    {
        "api_name": "_calc_final_ops",
        "full_api_name": "RemoveFinalMeasurements._calc_final_ops",
        "api_description": "",
        "api_signature": "_calc_final_ops(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/remove_final_measurements.py"
    },
    {
        "api_name": "run",
        "full_api_name": "RemoveFinalMeasurements.run",
        "api_description": "Run the RemoveFinalMeasurements pass on `dag`.\n\nArgs:\n    dag (DAGCircuit): the DAG to be optimized.\n\nReturns:\n    DAGCircuit: the optimized DAG.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/remove_final_measurements.py"
    },
    {
        "api_name": "run",
        "full_api_name": "BarrierBeforeFinalMeasurements.run",
        "api_description": "Run the BarrierBeforeFinalMeasurements pass on `dag`.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/barrier_before_final_measurements.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Error.__init__",
        "api_description": "Error pass.\n\nArgs:\n    msg (str | Callable[[PropertySet], str]): Error message, if not provided a generic error\n        will be used.  This can be either a raw string, or a callback function that accepts\n        the current ``property_set`` and returns the desired message.\n    action (str): the action to perform. Default: 'raise'. The options are:\n      * 'raise': Raises a `TranspilerError` exception with msg\n      * 'warn': Raises a non-fatal warning with msg\n      * 'log': logs in `logging.getLogger(__name__)`\n\nRaises:\n    TranspilerError: if action is not valid.",
        "api_signature": "__init__(self, msg, action)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/error.py"
    },
    {
        "api_name": "run",
        "full_api_name": "Error.run",
        "api_description": "Run the Error pass on `dag`.",
        "api_signature": "run(self, _)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/error.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "GatesInBasis.__init__",
        "api_description": "Initialize the GatesInBasis pass.\n\nArgs:\n    basis_gates (list): The list of strings representing the set of basis gates.\n    target (Target): The target representing the backend. If specified\n        this will be used instead of the ``basis_gates`` parameter",
        "api_signature": "__init__(self, basis_gates, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/gates_basis.py"
    },
    {
        "api_name": "run",
        "full_api_name": "GatesInBasis.run",
        "api_description": "Run the GatesInBasis pass on `dag`.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/gates_basis.py"
    },
    {
        "api_name": "_visit_target",
        "full_api_name": "GatesInBasis._visit_target",
        "api_description": "",
        "api_signature": "_visit_target(dag, wire_map)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/gates_basis.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ContainsInstruction.__init__",
        "api_description": "ContainsInstruction initializer.\n\nArgs:\n    instruction_name (str | Iterable[str]): The instruction or instructions to check are in\n        the DAG. The output in the property set is set to ``contains_`` prefixed on each\n        value for this parameter.\n    recurse (bool): if ``True`` (default), then recurse into control-flow operations.",
        "api_signature": "__init__(self, instruction_name, recurse)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/contains_instruction.py"
    },
    {
        "api_name": "run",
        "full_api_name": "ContainsInstruction.run",
        "api_description": "Run the ContainsInstruction pass on dag.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/contains_instruction.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CheckMap.__init__",
        "api_description": "CheckMap initializer.\n\nArgs:\n    coupling_map (Union[CouplingMap, Target]): Directed graph representing a coupling map.\n    property_set_field (str): An optional string to specify the property set field to\n        store the result of the check. If not default the result is stored in\n        ``\"is_swap_mapped\"``.",
        "api_signature": "__init__(self, coupling_map, property_set_field)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/check_map.py"
    },
    {
        "api_name": "run",
        "full_api_name": "CheckMap.run",
        "api_description": "Run the CheckMap pass on `dag`.\n\nIf `dag` is mapped to `coupling_map`, the property\n`is_swap_mapped` is set to True (or to False otherwise).\n\nArgs:\n    dag (DAGCircuit): DAG to map.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/check_map.py"
    },
    {
        "api_name": "_recurse",
        "full_api_name": "CheckMap._recurse",
        "api_description": "",
        "api_signature": "_recurse(self, dag, wire_map)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/check_map.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "UnrollForLoops.__init__",
        "api_description": "Things like `for x in {0, 3, 4} {rx(x) qr[1];}` will turn into\n`rx(0) qr[1]; rx(3) qr[1]; rx(4) qr[1];`.\n\n.. note::\n    The ``UnrollForLoops`` unrolls only one level of block depth. No inner loop will\n    be considered by ``max_target_depth``.\n\nArgs:\n    max_target_depth (int): Optional. Checks if the unrolled block is over a particular\n        subcircuit depth. To disable the check, use ``-1`` (Default).",
        "api_signature": "__init__(self, max_target_depth)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/unroll_forloops.py"
    },
    {
        "api_name": "run",
        "full_api_name": "UnrollForLoops.run",
        "api_description": "Run the UnrollForLoops pass on `dag`.\n\nArgs:\n    dag (DAGCircuit): the directed acyclic graph to run on.\n\nReturns:\n    DAGCircuit: Transformed DAG.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/unroll_forloops.py"
    },
    {
        "api_name": "_body_contains_continue_or_break",
        "full_api_name": "_body_contains_continue_or_break",
        "api_description": "Checks if a circuit contains ``continue``s or ``break``s. Conditional bodies are inspected.",
        "api_signature": "_body_contains_continue_or_break(circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/unroll_forloops.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "FixedPoint.__init__",
        "api_description": "FixedPoint initializer.\n\nArgs:\n    property_to_check (str): The property to check if a fixed point was reached.",
        "api_signature": "__init__(self, property_to_check)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/fixed_point.py"
    },
    {
        "api_name": "run",
        "full_api_name": "FixedPoint.run",
        "api_description": "Run the FixedPoint pass on `dag`.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/fixed_point.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "MinimumPoint.__init__",
        "api_description": "Initialize an instance of this pass\n\nArgs:\n    property_set_list (list): A list of property set keys that will\n        be used to evaluate the local minimum. The values of these\n        property set keys will be used as a tuple for comparison\n    prefix (str): The prefix to use for the property set key that is used\n        for tracking previous evaluations\n    backtrack_depth (int): The maximum number of entries to store. If\n        this number is reached and the next iteration doesn't have\n        a decrease in the number of values the minimum of the previous\n        n will be set as the output dag and ``minimum_point`` will be set to\n        ``True`` in the property set",
        "api_signature": "__init__(self, property_set_list, prefix, backtrack_depth)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/minimum_point.py"
    },
    {
        "api_name": "run",
        "full_api_name": "MinimumPoint.run",
        "api_description": "Run the MinimumPoint pass on `dag`.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/minimum_point.py"
    },
    {
        "api_name": "_block_to_matrix",
        "full_api_name": "_block_to_matrix",
        "api_description": "The function converts any sequence of operations between two qubits into a matrix\nthat can be utilized to create a gate or a unitary.\n\nArgs:\n    block (List(DAGOpNode)): A block of operations on two qubits.\n    block_index_map (dict(Qubit, int)): The mapping of the qubit indices in the main circuit.\n\nReturns:\n    NDArray: Matrix representation of the block of operations.",
        "api_signature": "_block_to_matrix(block, block_index_map)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/block_to_matrix.py"
    },
    {
        "api_name": "_run_inner",
        "full_api_name": "ConvertConditionsToIfOps._run_inner",
        "api_description": "Run the pass on one :class:`.DAGCircuit`, mutating it.  Returns ``True`` if the circuit\nwas modified and ``False`` if not.",
        "api_signature": "_run_inner(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/convert_conditions_to_if_ops.py"
    },
    {
        "api_name": "run",
        "full_api_name": "ConvertConditionsToIfOps.run",
        "api_description": "",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/convert_conditions_to_if_ops.py"
    },
    {
        "api_name": "run",
        "full_api_name": "MergeAdjacentBarriers.run",
        "api_description": "Run the MergeAdjacentBarriers pass on `dag`.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/merge_adjacent_barriers.py"
    },
    {
        "api_name": "_collect_potential_merges",
        "full_api_name": "MergeAdjacentBarriers._collect_potential_merges",
        "api_description": "Return the potential merges.\n\nReturns a dict of DAGOpNode: (Barrier, [DAGOpNode]) objects, where the barrier needs to be\ninserted where the corresponding index DAGOpNode appears in the main DAG, in replacement of\nthe listed DAGOpNodes.",
        "api_signature": "_collect_potential_merges(dag, barriers)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/merge_adjacent_barriers.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CheckGateDirection.__init__",
        "api_description": "CheckGateDirection initializer.\n\nArgs:\n    coupling_map (CouplingMap): Directed graph representing a coupling map.\n    target (Target): The backend target to use for this pass. If this is specified\n        it will be used instead of the coupling map",
        "api_signature": "__init__(self, coupling_map, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/check_gate_direction.py"
    },
    {
        "api_name": "_coupling_map_visit",
        "full_api_name": "CheckGateDirection._coupling_map_visit",
        "api_description": "",
        "api_signature": "_coupling_map_visit(self, dag, wire_map, edges)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/check_gate_direction.py"
    },
    {
        "api_name": "_target_visit",
        "full_api_name": "CheckGateDirection._target_visit",
        "api_description": "",
        "api_signature": "_target_visit(self, dag, wire_map)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/check_gate_direction.py"
    },
    {
        "api_name": "run",
        "full_api_name": "CheckGateDirection.run",
        "api_description": "Run the CheckGateDirection pass on `dag`.\n\nIf `dag` is mapped and the direction is correct the property\n`is_direction_mapped` is set to True (or to False otherwise).\n\nArgs:\n    dag (DAGCircuit): DAG to check.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/check_gate_direction.py"
    },
    {
        "api_name": "_swap_node_qargs",
        "full_api_name": "_swap_node_qargs",
        "api_description": "",
        "api_signature": "_swap_node_qargs(node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/gate_direction.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "GateDirection.__init__",
        "api_description": "GateDirection pass.\n\nArgs:\n    coupling_map (CouplingMap): Directed graph represented a coupling map.\n    target (Target): The backend target to use for this pass. If this is specified\n        it will be used instead of the coupling map",
        "api_signature": "__init__(self, coupling_map, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/gate_direction.py"
    },
    {
        "api_name": "_rzx_dag",
        "full_api_name": "GateDirection._rzx_dag",
        "api_description": "",
        "api_signature": "_rzx_dag(parameter)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/gate_direction.py"
    },
    {
        "api_name": "_rxx_dag",
        "full_api_name": "GateDirection._rxx_dag",
        "api_description": "",
        "api_signature": "_rxx_dag(parameter)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/gate_direction.py"
    },
    {
        "api_name": "_ryy_dag",
        "full_api_name": "GateDirection._ryy_dag",
        "api_description": "",
        "api_signature": "_ryy_dag(parameter)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/gate_direction.py"
    },
    {
        "api_name": "_rzz_dag",
        "full_api_name": "GateDirection._rzz_dag",
        "api_description": "",
        "api_signature": "_rzz_dag(parameter)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/gate_direction.py"
    },
    {
        "api_name": "_run_coupling_map",
        "full_api_name": "GateDirection._run_coupling_map",
        "api_description": "",
        "api_signature": "_run_coupling_map(self, dag, wire_map, edges)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/gate_direction.py"
    },
    {
        "api_name": "_run_target",
        "full_api_name": "GateDirection._run_target",
        "api_description": "",
        "api_signature": "_run_target(self, dag, wire_map)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/gate_direction.py"
    },
    {
        "api_name": "run",
        "full_api_name": "GateDirection.run",
        "api_description": "Run the GateDirection pass on `dag`.\n\nFlips the cx nodes to match the directed coupling map. Modifies the\ninput dag.\n\nArgs:\n    dag (DAGCircuit): DAG to map.\n\nReturns:\n    DAGCircuit: The rearranged dag for the coupling map\n\nRaises:\n    TranspilerError: If the circuit cannot be mapped just by flipping the\n        cx nodes.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/gate_direction.py"
    },
    {
        "api_name": "run",
        "full_api_name": "DAGFixedPoint.run",
        "api_description": "Run the DAGFixedPoint pass on `dag`.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/dag_fixed_point.py"
    },
    {
        "api_name": "run",
        "full_api_name": "Width.run",
        "api_description": "Run the Width pass on `dag`.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/analysis/width.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ResourceEstimation.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/analysis/resource_estimation.py"
    },
    {
        "api_name": "run",
        "full_api_name": "ResourceEstimation.run",
        "api_description": "Run the ResourceEstimation pass on `dag`.",
        "api_signature": "run(self, _)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/analysis/resource_estimation.py"
    },
    {
        "api_name": "run",
        "full_api_name": "DAGLongestPath.run",
        "api_description": "Run the DAGLongestPath pass on `dag`.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/analysis/dag_longest_path.py"
    },
    {
        "api_name": "run",
        "full_api_name": "NumQubits.run",
        "api_description": "Run the NumQubits pass on `dag`.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/analysis/num_qubits.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CountOps.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/analysis/count_ops.py"
    },
    {
        "api_name": "run",
        "full_api_name": "CountOps.run",
        "api_description": "Run the CountOps pass on `dag`.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/analysis/count_ops.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Size.__init__",
        "api_description": "Args:\n    recurse: whether to allow recursion into control flow.  If this is ``False`` (default),\n        the pass will throw an error when control flow is present, to avoid returning a\n        number with little meaning.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/analysis/size.py"
    },
    {
        "api_name": "run",
        "full_api_name": "Size.run",
        "api_description": "Run the Size pass on `dag`.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/analysis/size.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Depth.__init__",
        "api_description": "Args:\n    recurse: whether to allow recursion into control flow.  If this is ``False`` (default),\n        the pass will throw an error when control flow is present, to avoid returning a\n        number with little meaning.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/analysis/depth.py"
    },
    {
        "api_name": "run",
        "full_api_name": "Depth.run",
        "api_description": "Run the Depth pass on `dag`.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/analysis/depth.py"
    },
    {
        "api_name": "run",
        "full_api_name": "CountOpsLongestPath.run",
        "api_description": "Run the CountOpsLongestPath pass on `dag`.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/analysis/count_ops_longest_path.py"
    },
    {
        "api_name": "run",
        "full_api_name": "NumTensorFactors.run",
        "api_description": "Run the NumTensorFactors pass on `dag`.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/analysis/num_tensor_factors.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "FullAncillaAllocation.__init__",
        "api_description": "FullAncillaAllocation initializer.\n\nArgs:\n    coupling_map (Union[CouplingMap, Target]): directed graph representing a coupling map.",
        "api_signature": "__init__(self, coupling_map)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/full_ancilla_allocation.py"
    },
    {
        "api_name": "run",
        "full_api_name": "FullAncillaAllocation.run",
        "api_description": "Run the FullAncillaAllocation pass on `dag`.\n\nExtend the layout with new (physical qubit, virtual qubit) pairs.\nThe dag signals which virtual qubits are already in the circuit.\nThis pass will allocate new virtual qubits such that no collision occurs\n(i.e. Layout bijectivity is preserved)\n\nThe coupling_map and layout together determine which physical qubits are free.\n\nArgs:\n    dag (DAGCircuit): circuit to analyze\n\nReturns:\n    DAGCircuit: returns the same dag circuit, unmodified\n\nRaises:\n    TranspilerError: If there is not layout in the property set or not set at init time.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/full_ancilla_allocation.py"
    },
    {
        "api_name": "validate_layout",
        "full_api_name": "FullAncillaAllocation.validate_layout",
        "api_description": "Checks if all the qregs in layout_qregs already exist in dag_qregs. Otherwise, raise.",
        "api_signature": "validate_layout(layout_qubits, dag_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/full_ancilla_allocation.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "VF2Layout.__init__",
        "api_description": "Initialize a ``VF2Layout`` pass instance\n\nArgs:\n    coupling_map (CouplingMap): Directed graph representing a coupling map.\n    strict_direction (bool): If True, considers the direction of the coupling map.\n                             Default is False.\n    seed (int): Sets the seed of the PRNG. -1 Means no node shuffling.\n    call_limit (int): The number of state visits to attempt in each execution of\n        VF2.\n    time_limit (float): The total time limit in seconds to run ``VF2Layout``\n    properties (BackendProperties): The backend properties for the backend. If\n        :meth:`~qiskit.providers.models.BackendProperties.readout_error` is available\n        it is used to score the layout.\n    max_trials (int): The maximum number of trials to run VF2 to find\n        a layout. If this is not specified the number of trials will be limited\n        based on the number of edges in the interaction graph or the coupling graph\n        (whichever is larger) if no other limits are set. If set to a value <= 0 no\n        limit on the number of trials will be set.\n    target (Target): A target representing the backend device to run ``VF2Layout`` on.\n        If specified it will supersede a set value for ``properties`` and\n        ``coupling_map``.\n\nRaises:\n    TypeError: At runtime, if neither ``coupling_map`` or ``target`` are provided.",
        "api_signature": "__init__(self, coupling_map, strict_direction, seed, call_limit, time_limit, properties, max_trials, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/vf2_layout.py"
    },
    {
        "api_name": "run",
        "full_api_name": "VF2Layout.run",
        "api_description": "run the layout method",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/vf2_layout.py"
    },
    {
        "api_name": "mapping_to_layout",
        "full_api_name": "VF2Layout.mapping_to_layout",
        "api_description": "",
        "api_signature": "mapping_to_layout(layout_mapping)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/vf2_layout.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "TrivialLayout.__init__",
        "api_description": "TrivialLayout initializer.\n\nArgs:\n    coupling_map (Union[CouplingMap, Target]): directed graph representing a coupling map.\n\nRaises:\n    TranspilerError: if invalid options",
        "api_signature": "__init__(self, coupling_map)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/trivial_layout.py"
    },
    {
        "api_name": "run",
        "full_api_name": "TrivialLayout.run",
        "api_description": "Run the TrivialLayout pass on `dag`.\n\nArgs:\n    dag (DAGCircuit): DAG to find layout for.\n\nRaises:\n    TranspilerError: if dag wider than the target backend",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/trivial_layout.py"
    },
    {
        "api_name": "run_pass_over_connected_components",
        "full_api_name": "run_pass_over_connected_components",
        "api_description": "Run a transpiler pass inner function over mapped components.",
        "api_signature": "run_pass_over_connected_components(dag, components_source, run_func)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/disjoint_utils.py"
    },
    {
        "api_name": "map_components",
        "full_api_name": "map_components",
        "api_description": "Returns a map where the key is the index of each connected component in cmap_components and\nthe value is a list of indices from dag_components which should be placed onto it.",
        "api_signature": "map_components(dag_components, cmap_components)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/disjoint_utils.py"
    },
    {
        "api_name": "split_barriers",
        "full_api_name": "split_barriers",
        "api_description": "Mutate an input dag to split barriers into single qubit barriers.",
        "api_signature": "split_barriers(dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/disjoint_utils.py"
    },
    {
        "api_name": "combine_barriers",
        "full_api_name": "combine_barriers",
        "api_description": "Mutate input dag to combine barriers with UUID labels into a single barrier.",
        "api_signature": "combine_barriers(dag, retain_uuid)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/disjoint_utils.py"
    },
    {
        "api_name": "require_layout_isolated_to_component",
        "full_api_name": "require_layout_isolated_to_component",
        "api_description": "Check that the layout of the dag does not require connectivity across connected components\nin the CouplingMap\n\nArgs:\n    dag: DAGCircuit to check.\n    components_source: Target to check against.\n\nRaises:\n    TranspilerError: Chosen layout is not valid for the target disjoint connectivity.",
        "api_signature": "require_layout_isolated_to_component(dag, components_source)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/disjoint_utils.py"
    },
    {
        "api_name": "separate_dag",
        "full_api_name": "separate_dag",
        "api_description": "Separate a dag circuit into it's connected components.",
        "api_signature": "separate_dag(dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/disjoint_utils.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CustomSolver.__init__",
        "api_description": "",
        "api_signature": "__init__(self, call_limit, time_limit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/_csp_custom_solver.py"
    },
    {
        "api_name": "limit_reached",
        "full_api_name": "CustomSolver.limit_reached",
        "api_description": "Checks if a limit is reached.",
        "api_signature": "limit_reached(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/_csp_custom_solver.py"
    },
    {
        "api_name": "getSolution",
        "full_api_name": "CustomSolver.getSolution",
        "api_description": "Wrap RecursiveBacktrackingSolver.getSolution to add the limits.",
        "api_signature": "getSolution(self, domains, constraints, vconstraints)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/_csp_custom_solver.py"
    },
    {
        "api_name": "recursiveBacktracking",
        "full_api_name": "CustomSolver.recursiveBacktracking",
        "api_description": "Like ``constraint.RecursiveBacktrackingSolver.recursiveBacktracking`` but\nlimited in the amount of calls by ``self.call_limit``",
        "api_signature": "recursiveBacktracking(self, solutions, domains, vconstraints, assignments, single)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/_csp_custom_solver.py"
    },
    {
        "api_name": "run",
        "full_api_name": "EnlargeWithAncilla.run",
        "api_description": "Run the EnlargeWithAncilla pass on `dag`.\n\nArgs:\n    dag (DAGCircuit): DAG to extend.\n\nReturns:\n    DAGCircuit: An extended DAG.\n\nRaises:\n    TranspilerError: If there is not layout in the property set or not set at init time.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/enlarge_with_ancilla.py"
    },
    {
        "api_name": "run",
        "full_api_name": "ApplyLayout.run",
        "api_description": "Run the ApplyLayout pass on `dag`.\n\nArgs:\n    dag (DAGCircuit): DAG to map.\n\nReturns:\n    DAGCircuit: A mapped DAG (with physical qubits).\n\nRaises:\n    TranspilerError: if no layout is found in `property_set` or no full physical qubits.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/apply_layout.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SabreLayout.__init__",
        "api_description": "SabreLayout initializer.\n\nArgs:\n    coupling_map (Union[CouplingMap, Target]): directed graph representing a coupling map.\n    routing_pass (BasePass): the routing pass to use while iterating.\n        If specified this pass operates as an :class:`~.AnalysisPass` and\n        will only populate the ``layout`` field in the property set and\n        the input dag is returned unmodified. This argument is mutually\n        exclusive with the ``swap_trials`` and the ``layout_trials``\n        arguments and if this is specified at the same time as either\n        argument an error will be raised.\n    seed (int): seed for setting a random first trial layout.\n    max_iterations (int): number of forward-backward iterations.\n    swap_trials (int): The number of trials to run of\n        :class:`~.SabreSwap` for each iteration. This is equivalent to\n        the ``trials`` argument on :class:`~.SabreSwap`. If this is not\n        specified (and ``routing_pass`` isn't set) by default the number\n        of physical CPUs on your local system will be used. For\n        reproducibility between environments it is best to set this\n        to an explicit number because the output will potentially depend\n        on the number of trials run. This option is mutually exclusive\n        with the ``routing_pass`` argument and an error will be raised\n        if both are used.\n    layout_trials (int): The number of random seed trials to run\n        layout with. When > 1 the trial that resuls in the output with\n        the fewest swap gates will be selected. If this is not specified\n        (and ``routing_pass`` is not set) then the number of local\n        physical CPUs will be used as the default value. This option is\n        mutually exclusive with the ``routing_pass`` argument and an error\n        will be raised if both are used.\n    skip_routing (bool): If this is set ``True`` and ``routing_pass`` is not used\n        then routing will not be applied to the output circuit.  Only the layout\n        will be returned in the property set. This is a tradeoff to run custom\n        routing with multiple layout trials, as using this option will cause\n        SabreLayout to run the routing stage internally but not use that result.\n\nRaises:\n    TranspilerError: If both ``routing_pass`` and ``swap_trials`` or\n    both ``routing_pass`` and ``layout_trials`` are specified",
        "api_signature": "__init__(self, coupling_map, routing_pass, seed, max_iterations, swap_trials, layout_trials, skip_routing)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/sabre_layout.py"
    },
    {
        "api_name": "run",
        "full_api_name": "SabreLayout.run",
        "api_description": "Run the SabreLayout pass on `dag`.\n\nArgs:\n    dag (DAGCircuit): DAG to find layout for.\n\nReturns:\n   DAGCircuit: The output dag if swap mapping was run\n    (otherwise the input dag is returned unmodified).\n\nRaises:\n    TranspilerError: if dag wider than self.coupling_map",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/sabre_layout.py"
    },
    {
        "api_name": "_inner_run",
        "full_api_name": "SabreLayout._inner_run",
        "api_description": "",
        "api_signature": "_inner_run(self, dag, coupling_map, starting_layouts)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/sabre_layout.py"
    },
    {
        "api_name": "_ancilla_allocation_no_pass_manager",
        "full_api_name": "SabreLayout._ancilla_allocation_no_pass_manager",
        "api_description": "Run the ancilla-allocation and -enlargment passes on the DAG chained onto our\n``property_set``, skipping the DAG-to-circuit conversion cost of using a ``PassManager``.",
        "api_signature": "_ancilla_allocation_no_pass_manager(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/sabre_layout.py"
    },
    {
        "api_name": "_layout_and_route_passmanager",
        "full_api_name": "SabreLayout._layout_and_route_passmanager",
        "api_description": "Return a passmanager for a full layout and routing.\n\nWe use a factory to remove potential statefulness of passes.",
        "api_signature": "_layout_and_route_passmanager(self, initial_layout)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/sabre_layout.py"
    },
    {
        "api_name": "_compose_layouts",
        "full_api_name": "SabreLayout._compose_layouts",
        "api_description": "Return the real final_layout resulting from the composition\nof an initial_layout with the final_layout reported by a pass.\n\nThe routing passes internally start with a trivial layout, as the\nlayout gets applied to the circuit prior to running them. So the\n\"final_layout\" they report must be amended to account for the actual\ninitial_layout that was selected.",
        "api_signature": "_compose_layouts(self, initial_layout, pass_final_layout, qregs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/sabre_layout.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "NoiseAdaptiveLayout.__init__",
        "api_description": "NoiseAdaptiveLayout initializer.\n\nArgs:\n    backend_prop (Union[BackendProperties, Target]): backend properties object\n    coupling_map (CouplingMap): Optional. To filter the backend_prop qubits/gates.\n        This parameter is ignored if :class:`.Target` is provided in ``backend_prop``.\n        That method is preferred.\n\nRaises:\n    TranspilerError: if invalid options",
        "api_signature": "__init__(self, backend_prop, coupling_map)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/noise_adaptive_layout.py"
    },
    {
        "api_name": "_initialize_backend_prop",
        "full_api_name": "NoiseAdaptiveLayout._initialize_backend_prop",
        "api_description": "Extract readout and CNOT errors and compute swap costs.",
        "api_signature": "_initialize_backend_prop(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/noise_adaptive_layout.py"
    },
    {
        "api_name": "_qarg_to_id",
        "full_api_name": "NoiseAdaptiveLayout._qarg_to_id",
        "api_description": "Convert qarg with name and value to an integer id.",
        "api_signature": "_qarg_to_id(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/noise_adaptive_layout.py"
    },
    {
        "api_name": "_create_program_graph",
        "full_api_name": "NoiseAdaptiveLayout._create_program_graph",
        "api_description": "Program graph has virtual qubits as nodes.\n\nTwo nodes have an edge if the corresponding virtual qubits\nparticipate in a 2-qubit gate. The edge is weighted by the\nnumber of CNOTs between the pair.",
        "api_signature": "_create_program_graph(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/noise_adaptive_layout.py"
    },
    {
        "api_name": "_select_next_edge",
        "full_api_name": "NoiseAdaptiveLayout._select_next_edge",
        "api_description": "Select the next edge.\n\nIf there is an edge with one endpoint mapped, return it.\nElse return in the first edge",
        "api_signature": "_select_next_edge(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/noise_adaptive_layout.py"
    },
    {
        "api_name": "_select_best_remaining_cx",
        "full_api_name": "NoiseAdaptiveLayout._select_best_remaining_cx",
        "api_description": "Select best remaining CNOT in the hardware for the next program edge.",
        "api_signature": "_select_best_remaining_cx(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/noise_adaptive_layout.py"
    },
    {
        "api_name": "_select_best_remaining_qubit",
        "full_api_name": "NoiseAdaptiveLayout._select_best_remaining_qubit",
        "api_description": "Select the best remaining hardware qubit for the next program qubit.",
        "api_signature": "_select_best_remaining_qubit(self, prog_qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/noise_adaptive_layout.py"
    },
    {
        "api_name": "run",
        "full_api_name": "NoiseAdaptiveLayout.run",
        "api_description": "Run the NoiseAdaptiveLayout pass on `dag`.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/noise_adaptive_layout.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Layout2qDistance.__init__",
        "api_description": "Layout2qDistance initializer.\n\nArgs:\n    coupling_map (Union[CouplingMap, Target]): Directed graph represented a coupling map.\n    property_name (str): The property name to save the score. Default: layout_score",
        "api_signature": "__init__(self, coupling_map, property_name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/layout_2q_distance.py"
    },
    {
        "api_name": "run",
        "full_api_name": "Layout2qDistance.run",
        "api_description": "Run the Layout2qDistance pass on `dag`.\nArgs:\n    dag (DAGCircuit): DAG to evaluate.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/layout_2q_distance.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CSPLayout.__init__",
        "api_description": "If possible, chooses a Layout as a CSP, using backtracking.\n\nIf not possible, does not set the layout property. In all the cases,\nthe property `CSPLayout_stop_reason` will be added with one of the\nfollowing values:\n\n* solution found: If a perfect layout was found.\n* nonexistent solution: If no perfect layout was found and every combination was checked.\n* call limit reached: If no perfect layout was found and the call limit was reached.\n* time limit reached: If no perfect layout was found and the time limit was reached.\n\nArgs:\n    coupling_map (Union[CouplingMap, Target]): Directed graph representing a coupling map.\n    strict_direction (bool): If True, considers the direction of the coupling map.\n                             Default is False.\n    seed (int): Sets the seed of the PRNG.\n    call_limit (int): Amount of times that\n        ``constraint.RecursiveBacktrackingSolver.recursiveBacktracking`` will be called.\n        None means no call limit. Default: 1000.\n    time_limit (int): Amount of seconds that the pass will try to find a solution.\n        None means no time limit. Default: 10 seconds.",
        "api_signature": "__init__(self, coupling_map, strict_direction, seed, call_limit, time_limit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/csp_layout.py"
    },
    {
        "api_name": "run",
        "full_api_name": "CSPLayout.run",
        "api_description": "run the layout method",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/csp_layout.py"
    },
    {
        "api_name": "constraint",
        "full_api_name": "CSPLayout.constraint",
        "api_description": "",
        "api_signature": "constraint(control, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/csp_layout.py"
    },
    {
        "api_name": "constraint",
        "full_api_name": "CSPLayout.constraint",
        "api_description": "",
        "api_signature": "constraint(control, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/csp_layout.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "DenseLayout.__init__",
        "api_description": "DenseLayout initializer.\n\nArgs:\n    coupling_map (Coupling): directed graph representing a coupling map.\n    backend_prop (BackendProperties): backend properties object\n    target (Target): A target representing the target backend.",
        "api_signature": "__init__(self, coupling_map, backend_prop, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/dense_layout.py"
    },
    {
        "api_name": "run",
        "full_api_name": "DenseLayout.run",
        "api_description": "Run the DenseLayout pass on `dag`.\n\nPick a convenient layout depending on the best matching\nqubit connectivity, and set the property `layout`.\n\nArgs:\n    dag (DAGCircuit): DAG to find layout for.\n\nRaises:\n    TranspilerError: if dag wider than self.coupling_map",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/dense_layout.py"
    },
    {
        "api_name": "_inner_run",
        "full_api_name": "DenseLayout._inner_run",
        "api_description": "",
        "api_signature": "_inner_run(self, dag, coupling_map)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/dense_layout.py"
    },
    {
        "api_name": "_best_subset",
        "full_api_name": "DenseLayout._best_subset",
        "api_description": "Computes the qubit mapping with the best connectivity.\n\nArgs:\n    num_qubits (int): Number of subset qubits to consider.\n\nReturns:\n    ndarray: Array of qubits to use for best connectivity mapping.",
        "api_signature": "_best_subset(self, num_qubits, num_meas, num_cx, coupling_map)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/dense_layout.py"
    },
    {
        "api_name": "_build_error_matrix",
        "full_api_name": "_build_error_matrix",
        "api_description": "",
        "api_signature": "_build_error_matrix(num_qubits, qubit_map, target, coupling_map, backend_prop)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/dense_layout.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SabrePreLayout.__init__",
        "api_description": "SabrePreLayout initializer.\n\nThe pass works by augmenting the coupling map with more and more \"extra\" edges\nuntil VF2 succeeds to find a perfect graph isomorphism. More precisely, the\naugmented coupling map contains edges between nodes that are within a given\ndistance ``d`` in the original coupling map, and the value of ``d`` is increased\nuntil an isomorphism is found.\n\nIntuitively, a better layout involves fewer extra edges. The pass also optionally\nminimizes the number of extra edges involved in the layout until a local minimum\nis found. This involves removing extra edges and running VF2 to see if an\nisomorphism still exists.\n\nArgs:\n    coupling_map (Union[CouplingMap, Target]): directed graph representing the\n        original coupling map or a target modelling the backend (including its\n        connectivity).\n    max_distance (int): the maximum distance to consider for augmented coupling maps.\n    error_rate (float): the error rate to assign to the \"extra\" edges. A non-zero\n        error rate prioritizes VF2 to choose original edges over extra edges.\n    max_trials_vf2 (int): specifies the maximum number of VF2 trials. A larger number\n        allows VF2 to explore more layouts, eventually choosing the one with the smallest\n        error rate.\n    call_limit_vf2 (int): limits each call to VF2 by bounding the number of VF2 state visits.\n    improve_layout (bool): whether to improve the layout by minimizing the number of\n        extra edges involved. This might be time-consuming as this requires additional\n        VF2 calls.\n\nRaises:\n    TranspilerError: At runtime, if neither ``coupling_map`` or ``target`` are provided.",
        "api_signature": "__init__(self, coupling_map, max_distance, error_rate, max_trials_vf2, call_limit_vf2, improve_layout)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/sabre_pre_layout.py"
    },
    {
        "api_name": "run",
        "full_api_name": "SabrePreLayout.run",
        "api_description": "Run the SabrePreLayout pass on `dag`.\n\nThe discovered starting layout is written to the property set\nvalue ``sabre_starting_layouts``.\n\nArgs:\n    dag (DAGCircuit): DAG to create starting layout for.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/sabre_pre_layout.py"
    },
    {
        "api_name": "_add_extra_edges",
        "full_api_name": "SabrePreLayout._add_extra_edges",
        "api_description": "Augments the coupling map with extra edges that connect nodes ``distance``\napart in the original graph. The extra edges are assigned errors allowing VF2\nto prioritize real edges over extra edges.",
        "api_signature": "_add_extra_edges(self, distance)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/sabre_pre_layout.py"
    },
    {
        "api_name": "_get_extra_edges_used",
        "full_api_name": "SabrePreLayout._get_extra_edges_used",
        "api_description": "Returns the set of extra edges involved in the layout.",
        "api_signature": "_get_extra_edges_used(self, dag, layout)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/sabre_pre_layout.py"
    },
    {
        "api_name": "_find_layout",
        "full_api_name": "SabrePreLayout._find_layout",
        "api_description": "Checks if there is a layout for a given set of edges.",
        "api_signature": "_find_layout(self, dag, edges)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/sabre_pre_layout.py"
    },
    {
        "api_name": "_minimize_extra_edges",
        "full_api_name": "SabrePreLayout._minimize_extra_edges",
        "api_description": "Minimizes the set of extra edges involved in the layout. This iteratively\nremoves extra edges from the coupling map and uses VF2 to check if a layout\nstill exists. This is reasonably efficiently as it only looks for a local\nminimum.",
        "api_signature": "_minimize_extra_edges(self, dag, starting_layout)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/sabre_pre_layout.py"
    },
    {
        "api_name": "build_interaction_graph",
        "full_api_name": "build_interaction_graph",
        "api_description": "Build an interaction graph from a dag.",
        "api_signature": "build_interaction_graph(dag, strict_direction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/vf2_utils.py"
    },
    {
        "api_name": "_visit",
        "full_api_name": "_visit",
        "api_description": "",
        "api_signature": "_visit(dag, weight, wire_map)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/vf2_utils.py"
    },
    {
        "api_name": "build_edge_list",
        "full_api_name": "build_edge_list",
        "api_description": "Generate an edge list for scoring.",
        "api_signature": "build_edge_list(im_graph)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/vf2_utils.py"
    },
    {
        "api_name": "build_bit_list",
        "full_api_name": "build_bit_list",
        "api_description": "Generate a bit list for scoring.",
        "api_signature": "build_bit_list(im_graph, bit_map)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/vf2_utils.py"
    },
    {
        "api_name": "score_layout",
        "full_api_name": "score_layout",
        "api_description": "Score a layout given an average error map.",
        "api_signature": "score_layout(avg_error_map, layout_mapping, bit_map, _reverse_bit_map, im_graph, strict_direction, run_in_parallel, edge_list, bit_list)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/vf2_utils.py"
    },
    {
        "api_name": "build_average_error_map",
        "full_api_name": "build_average_error_map",
        "api_description": "Build an average error map used for scoring layouts pre-basis translation.",
        "api_signature": "build_average_error_map(target, properties, coupling_map)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/vf2_utils.py"
    },
    {
        "api_name": "shuffle_coupling_graph",
        "full_api_name": "shuffle_coupling_graph",
        "api_description": "Create a shuffled coupling graph from a coupling map.",
        "api_signature": "shuffle_coupling_graph(coupling_map, seed, strict_direction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/vf2_utils.py"
    },
    {
        "api_name": "map_free_qubits",
        "full_api_name": "map_free_qubits",
        "api_description": "Add any free nodes to a layout.",
        "api_signature": "map_free_qubits(free_nodes, partial_layout, num_physical_qubits, reverse_bit_map, avg_error_map)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/vf2_utils.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SetLayout.__init__",
        "api_description": "SetLayout initializer.\n\nArgs:\n    layout (Layout or List[int]): the layout to set. It can be:\n\n        * a :class:`Layout` instance: sets that layout.\n        * a list of integers: takes the index in the list as the physical position in which the\n          virtual qubit is going to be mapped.",
        "api_signature": "__init__(self, layout)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/set_layout.py"
    },
    {
        "api_name": "run",
        "full_api_name": "SetLayout.run",
        "api_description": "Run the SetLayout pass on ``dag``.\n\nArgs:\n    dag (DAGCircuit): DAG to map.\n\nReturns:\n    DAGCircuit: the original DAG.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/set_layout.py"
    },
    {
        "api_name": "_target_match",
        "full_api_name": "_target_match",
        "api_description": "",
        "api_signature": "_target_match(node_a, node_b)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/vf2_post_layout.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "VF2PostLayout.__init__",
        "api_description": "Initialize a ``VF2PostLayout`` pass instance\n\nArgs:\n    target (Target): A target representing the backend device to run ``VF2PostLayout`` on.\n        If specified it will supersede a set value for ``properties`` and\n        ``coupling_map``.\n    coupling_map (CouplingMap): Directed graph representing a coupling map.\n    properties (BackendProperties): The backend properties for the backend. If\n        :meth:`~qiskit.providers.models.BackendProperties.readout_error` is available\n        it is used to score the layout.\n    seed (int): Sets the seed of the PRNG. -1 Means no node shuffling.\n    call_limit (int): The number of state visits to attempt in each execution of\n        VF2.\n    time_limit (float): The total time limit in seconds to run ``VF2PostLayout``\n    strict_direction (bool): Whether the pass is configured to follow\n        the strict direction in the coupling graph. If this is set to\n        false, the pass will treat any edge in the coupling graph as\n        a weak edge and the interaction graph will be undirected. For\n        the purposes of evaluating layouts the avg error rate for\n        each qubit and 2q link will be used. This enables the pass to be\n        run prior to basis translation and work with any 1q and 2q operations.\n        However, if ``strict_direction=True`` the pass expects the input\n        :class:`~.DAGCircuit` object to :meth:`~.VF2PostLayout.run` to be in\n        the target set of instructions.\n    max_trials (int): The maximum number of trials to run VF2 to find\n        a layout. A value of ``0`` (the default) means 'unlimited'.\n\nRaises:\n    TypeError: At runtime, if neither ``coupling_map`` or ``target`` are provided.",
        "api_signature": "__init__(self, target, coupling_map, properties, seed, call_limit, time_limit, strict_direction, max_trials)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/vf2_post_layout.py"
    },
    {
        "api_name": "run",
        "full_api_name": "VF2PostLayout.run",
        "api_description": "run the layout method",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/vf2_post_layout.py"
    },
    {
        "api_name": "_score_layout",
        "full_api_name": "VF2PostLayout._score_layout",
        "api_description": "",
        "api_signature": "_score_layout(self, layout, bit_map, reverse_bit_map, im_graph)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/vf2_post_layout.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Unroller.__init__",
        "api_description": "Unroller initializer.\n\nArgs:\n    basis (list[str] or None): Target basis names to unroll to, e.g. `['u3', 'cx']` . If\n        None, does not unroll any gate.\n    target (Target):  The :class:`~.Target` representing the target backend, if both\n        ``basis`` and this are specified then this argument will take\n        precedence and ``basis`` will be ignored.",
        "api_signature": "__init__(self, basis, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/basis/unroller.py"
    },
    {
        "api_name": "run",
        "full_api_name": "Unroller.run",
        "api_description": "Run the Unroller pass on `dag`.\n\nArgs:\n    dag (DAGCircuit): input dag\n\nRaises:\n    QiskitError: if unable to unroll given the basis due to undefined\n    decomposition rules (such as a bad basis) or excessive recursion.\n\nReturns:\n    DAGCircuit: output unrolled dag",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/basis/unroller.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "UnrollCustomDefinitions.__init__",
        "api_description": "Unrolls instructions with custom definitions.\n\nArgs:\n    equivalence_library (EquivalenceLibrary): The equivalence library\n        which will be used by the BasisTranslator pass. (Instructions in\n        this library will not be unrolled by this pass.)\n    basis_gates (Optional[list[str]]): Target basis names to unroll to, e.g. `['u3', 'cx']`.\n        Ignored if ``target`` is also specified.\n    target (Optional[Target]): The :class:`~.Target` object corresponding to the compilation\n        target. When specified, any argument specified for ``basis_gates`` is ignored.\n     min_qubits (int): The minimum number of qubits for operations in the input\n         dag to translate.",
        "api_signature": "__init__(self, equivalence_library, basis_gates, target, min_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/basis/unroll_custom_definitions.py"
    },
    {
        "api_name": "run",
        "full_api_name": "UnrollCustomDefinitions.run",
        "api_description": "Run the UnrollCustomDefinitions pass on `dag`.\n\nArgs:\n    dag (DAGCircuit): input dag\n\nRaises:\n    QiskitError: if unable to unroll given the basis due to undefined\n    decomposition rules (such as a bad basis) or excessive recursion.\n\nReturns:\n    DAGCircuit: output unrolled dag",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/basis/unroll_custom_definitions.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BasisTranslator.__init__",
        "api_description": "Initialize a BasisTranslator instance.\n\nArgs:\n    equivalence_library (EquivalenceLibrary): The equivalence library\n        which will be used by the BasisTranslator pass. (Instructions in\n        this library will not be unrolled by this pass.)\n    target_basis (list[str]): Target basis names to unroll to, e.g. `['u3', 'cx']`.\n    target (Target): The backend compilation target\n    min_qubits (int): The minimum number of qubits for operations in the input\n        dag to translate.",
        "api_signature": "__init__(self, equivalence_library, target_basis, target, min_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/basis/basis_translator.py"
    },
    {
        "api_name": "run",
        "full_api_name": "BasisTranslator.run",
        "api_description": "Translate an input DAGCircuit to the target basis.\n\nArgs:\n    dag (DAGCircuit): input dag\n\nRaises:\n    TranspilerError: if the target basis cannot be reached\n\nReturns:\n    DAGCircuit: translated circuit.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/basis/basis_translator.py"
    },
    {
        "api_name": "apply_translation",
        "full_api_name": "BasisTranslator.apply_translation",
        "api_description": "",
        "api_signature": "apply_translation(dag, wire_map)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/basis/basis_translator.py"
    },
    {
        "api_name": "_replace_node",
        "full_api_name": "BasisTranslator._replace_node",
        "api_description": "",
        "api_signature": "_replace_node(self, dag, node, instr_map)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/basis/basis_translator.py"
    },
    {
        "api_name": "_extract_basis",
        "full_api_name": "BasisTranslator._extract_basis",
        "api_description": "",
        "api_signature": "_extract_basis(self, circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/basis/basis_translator.py"
    },
    {
        "api_name": "_",
        "full_api_name": "BasisTranslator._",
        "api_description": "",
        "api_signature": "_(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/basis/basis_translator.py"
    },
    {
        "api_name": "_",
        "full_api_name": "BasisTranslator._",
        "api_description": "",
        "api_signature": "_(self, circ)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/basis/basis_translator.py"
    },
    {
        "api_name": "_extract_basis_target",
        "full_api_name": "BasisTranslator._extract_basis_target",
        "api_description": "",
        "api_signature": "_extract_basis_target(self, dag, qarg_indices, source_basis, qargs_local_source_basis)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/basis/basis_translator.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BasisSearchVisitor.__init__",
        "api_description": "",
        "api_signature": "__init__(self, graph, source_basis, target_basis)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/basis/basis_translator.py"
    },
    {
        "api_name": "discover_vertex",
        "full_api_name": "BasisSearchVisitor.discover_vertex",
        "api_description": "",
        "api_signature": "discover_vertex(self, v, score)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/basis/basis_translator.py"
    },
    {
        "api_name": "examine_edge",
        "full_api_name": "BasisSearchVisitor.examine_edge",
        "api_description": "",
        "api_signature": "examine_edge(self, edge)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/basis/basis_translator.py"
    },
    {
        "api_name": "edge_relaxed",
        "full_api_name": "BasisSearchVisitor.edge_relaxed",
        "api_description": "",
        "api_signature": "edge_relaxed(self, edge)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/basis/basis_translator.py"
    },
    {
        "api_name": "edge_cost",
        "full_api_name": "BasisSearchVisitor.edge_cost",
        "api_description": "Returns the cost of an edge.\n\nThis function computes the cost of this edge rule by summing\nthe costs of all gates in the rule equivalence circuit. In the\nend, we need to subtract the cost of the source since `dijkstra`\nwill later add it.",
        "api_signature": "edge_cost(self, edge_data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/basis/basis_translator.py"
    },
    {
        "api_name": "basis_transforms",
        "full_api_name": "BasisSearchVisitor.basis_transforms",
        "api_description": "Returns the gate basis transforms.",
        "api_signature": "basis_transforms(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/basis/basis_translator.py"
    },
    {
        "api_name": "_basis_search",
        "full_api_name": "_basis_search",
        "api_description": "Search for a set of transformations from source_basis to target_basis.\n\nArgs:\n    equiv_lib (EquivalenceLibrary): Source of valid translations\n    source_basis (Set[Tuple[gate_name: str, gate_num_qubits: int]]): Starting basis.\n    target_basis (Set[gate_name: str]): Target basis.\n\nReturns:\n    Optional[List[Tuple[gate, equiv_params, equiv_circuit]]]: List of (gate,\n        equiv_params, equiv_circuit) tuples tuples which, if applied in order\n        will map from source_basis to target_basis. Returns None if no path\n        was found.",
        "api_signature": "_basis_search(equiv_lib, source_basis, target_basis)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/basis/basis_translator.py"
    },
    {
        "api_name": "_compose_transforms",
        "full_api_name": "_compose_transforms",
        "api_description": "Compose a set of basis transforms into a set of replacements.\n\nArgs:\n    basis_transforms (List[Tuple[gate_name, params, equiv]]): List of\n        transforms to compose.\n    source_basis (Set[Tuple[gate_name: str, gate_num_qubits: int]]): Names\n        of gates which need to be translated.\n    source_dag (DAGCircuit): DAG with example gates from source_basis.\n        (Used to determine num_params for gate in source_basis.)\n\nReturns:\n    Dict[gate_name, Tuple(params, dag)]: Dictionary mapping between each gate\n        in source_basis and a DAGCircuit instance to replace it. Gates in\n        source_basis but not affected by basis_transforms will be included\n        as a key mapping to itself.",
        "api_signature": "_compose_transforms(basis_transforms, source_basis, source_dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/basis/basis_translator.py"
    },
    {
        "api_name": "_get_example_gates",
        "full_api_name": "_get_example_gates",
        "api_description": "",
        "api_signature": "_get_example_gates(source_dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/basis/basis_translator.py"
    },
    {
        "api_name": "recurse",
        "full_api_name": "recurse",
        "api_description": "",
        "api_signature": "recurse(dag, example_gates)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/basis/basis_translator.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Decompose.__init__",
        "api_description": "Decompose initializer.\n\nArgs:\n    gates_to_decompose: optional subset of gates to be decomposed,\n        identified by gate label, name or type. Defaults to all gates.",
        "api_signature": "__init__(self, gates_to_decompose)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/basis/decompose.py"
    },
    {
        "api_name": "run",
        "full_api_name": "Decompose.run",
        "api_description": "Run the Decompose pass on `dag`.\n\nArgs:\n    dag: input dag.\n\nReturns:\n    output dag where ``gate`` was expanded.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/basis/decompose.py"
    },
    {
        "api_name": "_should_decompose",
        "full_api_name": "Decompose._should_decompose",
        "api_description": "Call a decomposition pass on this circuit,\nto decompose one level (shallow decompose).",
        "api_signature": "_should_decompose(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/basis/decompose.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Unroll3qOrMore.__init__",
        "api_description": "Initialize the Unroll3qOrMore pass\n\nArgs:\n    target (Target): The target object representing the compilation\n        target. If specified any multiqubit instructions in the\n        circuit when the pass is run that are supported by the target\n        device will be left in place. If both this and ``basis_gates``\n        are specified only the target will be checked.\n    basis_gates (list): A list of basis gate names that the target\n        device supports. If specified any gate names in the circuit\n        which are present in this list will not be unrolled. If both\n        this and ``target`` are specified only the target will be used\n        for checking which gates are supported.",
        "api_signature": "__init__(self, target, basis_gates)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/basis/unroll_3q_or_more.py"
    },
    {
        "api_name": "run",
        "full_api_name": "Unroll3qOrMore.run",
        "api_description": "Run the Unroll3qOrMore pass on `dag`.\n\nArgs:\n    dag(DAGCircuit): input dag\nReturns:\n    DAGCircuit: output dag with maximum node degrees of 2\nRaises:\n    QiskitError: if a 3q+ gate is not decomposable",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/basis/unroll_3q_or_more.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "TranslateParameterizedGates.__init__",
        "api_description": "Args:\n    supported_gates: A list of suppported basis gates specified as string. If ``None``,\n        a ``target`` must be provided.\n    equivalence_library: The equivalence library to translate the gates. Defaults\n        to the equivalence library of all Qiskit standard gates.\n    target: A :class:`.Target` containing the supported operations. If ``None``,\n        ``supported_gates`` must be set. Note that this argument takes precedence over\n        ``supported_gates``, if both are set.\n\nRaises:\n    ValueError: If neither of ``supported_gates`` and ``target`` are passed.",
        "api_signature": "__init__(self, supported_gates, equivalence_library, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/basis/translate_parameterized.py"
    },
    {
        "api_name": "run",
        "full_api_name": "TranslateParameterizedGates.run",
        "api_description": "Run the transpiler pass.\n\nArgs:\n    dag: The DAG circuit in which the parameterized gates should be unrolled.\n\nReturns:\n    A DAG where the parameterized gates have been unrolled.\n\nRaises:\n    QiskitError: If the circuit cannot be unrolled.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/basis/translate_parameterized.py"
    },
    {
        "api_name": "_is_parameterized",
        "full_api_name": "_is_parameterized",
        "api_description": "",
        "api_signature": "_is_parameterized(op)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/basis/translate_parameterized.py"
    },
    {
        "api_name": "_is_supported",
        "full_api_name": "_is_supported",
        "api_description": "Check whether the node is supported.\n\nIf the target is provided, check using the target, otherwise the supported_gates are used.",
        "api_signature": "_is_supported(node, supported_gates, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/basis/translate_parameterized.py"
    },
    {
        "api_name": "_instruction_to_dag",
        "full_api_name": "_instruction_to_dag",
        "api_description": "",
        "api_signature": "_instruction_to_dag(op)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/basis/translate_parameterized.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CollectAndCollapse.__init__",
        "api_description": "Args:\n    collect_function (callable): a function that takes a DAG and returns a list\n        of \"collected\" blocks of nodes\n    collapse_function (callable): a function that takes a DAG and a list of\n        \"collected\" blocks, and consolidates each block.\n    do_commutative_analysis (bool): if True, exploits commutativity relations\n        between nodes.",
        "api_signature": "__init__(self, collect_function, collapse_function, do_commutative_analysis)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/collect_and_collapse.py"
    },
    {
        "api_name": "run",
        "full_api_name": "CollectAndCollapse.run",
        "api_description": "Run the CollectLinearFunctions pass on `dag`.\nArgs:\n    dag (DAGCircuit): the DAG to be optimized.\nReturns:\n    DAGCircuit: the optimized DAG.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/collect_and_collapse.py"
    },
    {
        "api_name": "collect_using_filter_function",
        "full_api_name": "collect_using_filter_function",
        "api_description": "Corresponds to an important block collection strategy that greedily collects\nmaximal blocks of nodes matching a given ``filter_function``.",
        "api_signature": "collect_using_filter_function(dag, filter_function, split_blocks, min_block_size, split_layers, collect_from_back)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/collect_and_collapse.py"
    },
    {
        "api_name": "collapse_to_operation",
        "full_api_name": "collapse_to_operation",
        "api_description": "Corresponds to an important block collapsing strategy that collapses every block\nto a specific object as specified by ``collapse_function``.",
        "api_signature": "collapse_to_operation(dag, blocks, collapse_function)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/collect_and_collapse.py"
    },
    {
        "api_name": "run",
        "full_api_name": "Collect1qRuns.run",
        "api_description": "Run the Collect1qBlocks pass on `dag`.\n\nThe blocks contain \"op\" nodes in topological order such that all gates\nin a block act on the same qubits and are adjacent in the circuit.\n\nAfter the execution, ``property_set['run_list']`` is set to a list of\ntuples of \"op\" node.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/collect_1q_runs.py"
    },
    {
        "api_name": "run",
        "full_api_name": "RemoveResetInZeroState.run",
        "api_description": "Run the RemoveResetInZeroState pass on `dag`.\n\nArgs:\n    dag (DAGCircuit): the DAG to be optimized.\n\nReturns:\n    DAGCircuit: the optimized DAG.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/remove_reset_in_zero_state.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CollectMultiQBlocks.__init__",
        "api_description": "",
        "api_signature": "__init__(self, max_block_size)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/collect_multiqubit_blocks.py"
    },
    {
        "api_name": "find_set",
        "full_api_name": "CollectMultiQBlocks.find_set",
        "api_description": "DSU function for finding root of set of items\nIf my parent is myself, I am the root. Otherwise we recursively\nfind the root for my parent. After that, we assign my parent to be\nmy root, saving recursion in the future.",
        "api_signature": "find_set(self, index)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/collect_multiqubit_blocks.py"
    },
    {
        "api_name": "union_set",
        "full_api_name": "CollectMultiQBlocks.union_set",
        "api_description": "DSU function for unioning two sets together\nFind the roots of each set. Then assign one to have the other\nas its parent, thus liking the sets.\nMerges smaller set into larger set in order to have better runtime",
        "api_signature": "union_set(self, set1, set2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/collect_multiqubit_blocks.py"
    },
    {
        "api_name": "run",
        "full_api_name": "CollectMultiQBlocks.run",
        "api_description": "Run the CollectMultiQBlocks pass on `dag`.\n\nThe blocks contain \"op\" nodes in topological sort order\nsuch that all gates in a block act on the same set of\nqubits and are adjacent in the circuit.\n\nThe blocks are built by examining predecessors and successors of\n\"cx\" gates in the circuit. u1, u2, u3, cx, id gates will be included.\n\nAfter the execution, ``property_set['block_list']`` is set to\na list of tuples of ``DAGNode`` objects",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/collect_multiqubit_blocks.py"
    },
    {
        "api_name": "collect_key",
        "full_api_name": "CollectMultiQBlocks.collect_key",
        "api_description": "special key function for topological ordering.\nHeuristic for this is to push all gates involving measurement\nor barriers, etc. as far back as possible (because they force\nblocks to end). After that, we process gates in order of lowest\nnumber of qubits acted on to largest number of qubits acted on\nbecause these have less chance of increasing the size of blocks\nThe key also processes all the non operation notes first so that\ninput nodes do not mess with the top sort of op nodes",
        "api_signature": "collect_key(x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/collect_multiqubit_blocks.py"
    },
    {
        "api_name": "_skip_node",
        "full_api_name": "CommutativeInverseCancellation._skip_node",
        "api_description": "Returns True if we should skip this node for the analysis.",
        "api_signature": "_skip_node(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/commutative_inverse_cancellation.py"
    },
    {
        "api_name": "run",
        "full_api_name": "CommutativeInverseCancellation.run",
        "api_description": "Run the CommutativeInverseCancellation pass on `dag`.\n\nArgs:\n    dag: the directed acyclic graph to run on.\n\nReturns:\n    DAGCircuit: Transformed DAG.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/commutative_inverse_cancellation.py"
    },
    {
        "api_name": "run",
        "full_api_name": "OptimizeSwapBeforeMeasure.run",
        "api_description": "Run the OptimizeSwapBeforeMeasure pass on `dag`.\n\nArgs:\n    dag (DAGCircuit): the DAG to be optimized.\n\nReturns:\n    DAGCircuit: the optimized DAG.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/optimize_swap_before_measure.py"
    },
    {
        "api_name": "run",
        "full_api_name": "OptimizeCliffords.run",
        "api_description": "Run the OptimizeCliffords pass on `dag`.\n\nArgs:\n    dag (DAGCircuit): the DAG to be optimized.\n\nReturns:\n    DAGCircuit: the optimized DAG.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/optimize_cliffords.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Optimize1qGatesDecomposition.__init__",
        "api_description": "Optimize1qGatesDecomposition initializer.\n\nArgs:\n    basis (list[str]): Basis gates to consider, e.g. `['u3', 'cx']`. For the effects\n        of this pass, the basis is the set intersection between the `basis` parameter\n        and the Euler basis. Ignored if ``target`` is also specified.\n    target (Optional[Target]): The :class:`~.Target` object corresponding to the compilation\n        target. When specified, any argument specified for ``basis_gates`` is ignored.",
        "api_signature": "__init__(self, basis, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/optimize_1q_decomposition.py"
    },
    {
        "api_name": "_build_error_map",
        "full_api_name": "Optimize1qGatesDecomposition._build_error_map",
        "api_description": "",
        "api_signature": "_build_error_map(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/optimize_1q_decomposition.py"
    },
    {
        "api_name": "_resynthesize_run",
        "full_api_name": "Optimize1qGatesDecomposition._resynthesize_run",
        "api_description": "Resynthesizes one 2x2 `matrix`, typically extracted via `dag.collect_1q_runs`.\n\nReturns the newly synthesized circuit in the indicated basis, or None\nif no synthesis routine applied.\n\nWhen multiple synthesis options are available, it prefers the one with lowest\nerror when the circuit is applied to `qubit`.",
        "api_signature": "_resynthesize_run(self, matrix, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/optimize_1q_decomposition.py"
    },
    {
        "api_name": "_gate_sequence_to_dag",
        "full_api_name": "Optimize1qGatesDecomposition._gate_sequence_to_dag",
        "api_description": "",
        "api_signature": "_gate_sequence_to_dag(self, best_synth_circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/optimize_1q_decomposition.py"
    },
    {
        "api_name": "_substitution_checks",
        "full_api_name": "Optimize1qGatesDecomposition._substitution_checks",
        "api_description": "Returns `True` when it is recommended to replace `old_run` with `new_circ` over `basis`.",
        "api_signature": "_substitution_checks(self, dag, old_run, new_circ, basis, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/optimize_1q_decomposition.py"
    },
    {
        "api_name": "run",
        "full_api_name": "Optimize1qGatesDecomposition.run",
        "api_description": "Run the Optimize1qGatesDecomposition pass on `dag`.\n\nArgs:\n    dag (DAGCircuit): the DAG to be optimized.\n\nReturns:\n    DAGCircuit: the optimized DAG.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/optimize_1q_decomposition.py"
    },
    {
        "api_name": "_error",
        "full_api_name": "Optimize1qGatesDecomposition._error",
        "api_description": "Calculate a rough error for a `circuit` that runs on a specific\n`qubit` of `target` (`circuit` can either be an OneQubitGateSequence\nfrom Rust or a list of DAGOPNodes).\n\nUse basis errors from target if available, otherwise use length\nof circuit as a weak proxy for error.",
        "api_signature": "_error(self, circuit, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/optimize_1q_decomposition.py"
    },
    {
        "api_name": "_possible_decomposers",
        "full_api_name": "_possible_decomposers",
        "api_description": "",
        "api_signature": "_possible_decomposers(basis_set)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/optimize_1q_decomposition.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CrosstalkAdaptiveSchedule.__init__",
        "api_description": "CrosstalkAdaptiveSchedule initializer.\n\nArgs:\n    backend_prop (BackendProperties): backend properties object\n    crosstalk_prop (dict): crosstalk properties object\n        crosstalk_prop[g1][g2] specifies the conditional error rate of\n        g1 when g1 and g2 are executed simultaneously.\n        g1 should be a two-qubit tuple of the form (x,y) where x and y are physical\n        qubit ids. g2 can be either two-qubit tuple (x,y) or single-qubit tuple (x).\n        We currently ignore crosstalk between pairs of single-qubit gates.\n        Gate pairs which are not specified are assumed to be crosstalk free.\n\n        Example::\n\n            crosstalk_prop = {(0, 1) : {(2, 3) : 0.2, (2) : 0.15},\n                                        (4, 5) : {(2, 3) : 0.1},\n                                        (2, 3) : {(0, 1) : 0.05, (4, 5): 0.05}}\n\n        The keys of the crosstalk_prop are tuples for ordered tuples for CX gates\n        e.g., (0, 1) corresponding to CX 0, 1 in the hardware.\n        Each key has an associated value dict which specifies the conditional error rates\n        with nearby gates e.g., ``(0, 1) : {(2, 3) : 0.2, (2) : 0.15}`` means that\n        CNOT 0, 1 has an error rate of 0.2 when it is executed in parallel with CNOT 2,3\n        and an error rate of 0.15 when it is executed in parallel with a single qubit\n        gate on qubit 2.\n    weight_factor (float): weight of gate error/crosstalk terms in the objective\n        :math:`weight_factor*fidelities + (1-weight_factor)*decoherence errors`.\n        Weight can be varied from 0 to 1, with 0 meaning that only decoherence\n        errors are optimized and 1 meaning that only crosstalk errors are optimized.\n        weight_factor should be tuned per application to get the best results.\n    measured_qubits (list): a list of qubits that will be measured in a particular circuit.\n        This arg need not be specified for circuits which already include measure gates.\n        The arg is useful when a subsequent module such as state_tomography_circuits\n        inserts the measure gates. If CrosstalkAdaptiveSchedule is made aware of those\n        measurements, it is included in the optimization.\n    target (Target): A target representing the target backend, if both\n        ``backend_prop`` and this are specified then this argument will take\n        precedence and ``coupling_map`` will be ignored.\nRaises:\n    ImportError: if unable to import z3 solver",
        "api_signature": "__init__(self, backend_prop, crosstalk_prop, weight_factor, measured_qubits, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/crosstalk_adaptive_schedule.py"
    },
    {
        "api_name": "powerset",
        "full_api_name": "CrosstalkAdaptiveSchedule.powerset",
        "api_description": "Finds the set of all subsets of the given iterable\nThis function is used to generate constraints for the Z3 optimization",
        "api_signature": "powerset(self, iterable)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/crosstalk_adaptive_schedule.py"
    },
    {
        "api_name": "parse_backend_properties",
        "full_api_name": "CrosstalkAdaptiveSchedule.parse_backend_properties",
        "api_description": "This function assumes that gate durations and coherence times\nare in seconds in backend.properties()\nThis function converts gate durations and coherence times to\nnanoseconds.",
        "api_signature": "parse_backend_properties(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/crosstalk_adaptive_schedule.py"
    },
    {
        "api_name": "cx_tuple",
        "full_api_name": "CrosstalkAdaptiveSchedule.cx_tuple",
        "api_description": "Representation for two-qubit gate\nNote: current implementation assumes that the CX error rates and\ncrosstalk behavior are independent of gate direction",
        "api_signature": "cx_tuple(self, gate)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/crosstalk_adaptive_schedule.py"
    },
    {
        "api_name": "singleq_tuple",
        "full_api_name": "CrosstalkAdaptiveSchedule.singleq_tuple",
        "api_description": "Representation for single-qubit gate",
        "api_signature": "singleq_tuple(self, gate)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/crosstalk_adaptive_schedule.py"
    },
    {
        "api_name": "gate_tuple",
        "full_api_name": "CrosstalkAdaptiveSchedule.gate_tuple",
        "api_description": "Representation for gate",
        "api_signature": "gate_tuple(self, gate)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/crosstalk_adaptive_schedule.py"
    },
    {
        "api_name": "assign_gate_id",
        "full_api_name": "CrosstalkAdaptiveSchedule.assign_gate_id",
        "api_description": "ID for each gate",
        "api_signature": "assign_gate_id(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/crosstalk_adaptive_schedule.py"
    },
    {
        "api_name": "extract_dag_overlap_sets",
        "full_api_name": "CrosstalkAdaptiveSchedule.extract_dag_overlap_sets",
        "api_description": "Gate A, B are overlapping if\nA is neither a descendant nor an ancestor of B.\nCurrently overlaps (A,B) are considered when A is a 2q gate and\nB is either 2q or 1q gate.",
        "api_signature": "extract_dag_overlap_sets(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/crosstalk_adaptive_schedule.py"
    },
    {
        "api_name": "is_significant_xtalk",
        "full_api_name": "CrosstalkAdaptiveSchedule.is_significant_xtalk",
        "api_description": "Given two conditional gate error rates\ncheck if there is high crosstalk by comparing with independent error rates.",
        "api_signature": "is_significant_xtalk(self, gate1, gate2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/crosstalk_adaptive_schedule.py"
    },
    {
        "api_name": "extract_crosstalk_relevant_sets",
        "full_api_name": "CrosstalkAdaptiveSchedule.extract_crosstalk_relevant_sets",
        "api_description": "Extract the set of program gates which potentially have crosstalk noise",
        "api_signature": "extract_crosstalk_relevant_sets(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/crosstalk_adaptive_schedule.py"
    },
    {
        "api_name": "create_z3_vars",
        "full_api_name": "CrosstalkAdaptiveSchedule.create_z3_vars",
        "api_description": "Setup the variables required for Z3 optimization",
        "api_signature": "create_z3_vars(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/crosstalk_adaptive_schedule.py"
    },
    {
        "api_name": "basic_bounds",
        "full_api_name": "CrosstalkAdaptiveSchedule.basic_bounds",
        "api_description": "Basic variable bounds for optimization",
        "api_signature": "basic_bounds(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/crosstalk_adaptive_schedule.py"
    },
    {
        "api_name": "scheduling_constraints",
        "full_api_name": "CrosstalkAdaptiveSchedule.scheduling_constraints",
        "api_description": "DAG scheduling constraints optimization\nSets overlap indicator variables",
        "api_signature": "scheduling_constraints(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/crosstalk_adaptive_schedule.py"
    },
    {
        "api_name": "fidelity_constraints",
        "full_api_name": "CrosstalkAdaptiveSchedule.fidelity_constraints",
        "api_description": "Set gate fidelity based on gate overlap conditions",
        "api_signature": "fidelity_constraints(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/crosstalk_adaptive_schedule.py"
    },
    {
        "api_name": "coherence_constraints",
        "full_api_name": "CrosstalkAdaptiveSchedule.coherence_constraints",
        "api_description": "Set decoherence errors based on qubit lifetimes",
        "api_signature": "coherence_constraints(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/crosstalk_adaptive_schedule.py"
    },
    {
        "api_name": "objective_function",
        "full_api_name": "CrosstalkAdaptiveSchedule.objective_function",
        "api_description": "Objective function is a weighted combination of gate errors and decoherence errors",
        "api_signature": "objective_function(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/crosstalk_adaptive_schedule.py"
    },
    {
        "api_name": "r2f",
        "full_api_name": "CrosstalkAdaptiveSchedule.r2f",
        "api_description": "Convert Z3 Real to Python float",
        "api_signature": "r2f(self, val)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/crosstalk_adaptive_schedule.py"
    },
    {
        "api_name": "extract_solution",
        "full_api_name": "CrosstalkAdaptiveSchedule.extract_solution",
        "api_description": "Extract gate start and finish times from Z3 solution",
        "api_signature": "extract_solution(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/crosstalk_adaptive_schedule.py"
    },
    {
        "api_name": "solve_optimization",
        "full_api_name": "CrosstalkAdaptiveSchedule.solve_optimization",
        "api_description": "Setup and solve a Z3 optimization for finding the best schedule",
        "api_signature": "solve_optimization(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/crosstalk_adaptive_schedule.py"
    },
    {
        "api_name": "check_dag_dependency",
        "full_api_name": "CrosstalkAdaptiveSchedule.check_dag_dependency",
        "api_description": "gate2 is a DAG dependent of gate1 if it is a descendant of gate1",
        "api_signature": "check_dag_dependency(self, gate1, gate2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/crosstalk_adaptive_schedule.py"
    },
    {
        "api_name": "check_xtalk_dependency",
        "full_api_name": "CrosstalkAdaptiveSchedule.check_xtalk_dependency",
        "api_description": "Check if two gates have a crosstalk dependency.\nWe do not consider crosstalk between pairs of single qubit gates.",
        "api_signature": "check_xtalk_dependency(self, t_1, t_2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/crosstalk_adaptive_schedule.py"
    },
    {
        "api_name": "filter_candidates",
        "full_api_name": "CrosstalkAdaptiveSchedule.filter_candidates",
        "api_description": "For a gate G and layer L,\nL is a candidate layer for G if no gate in L has a DAG dependency with G,\nand if Z3 allows gates in L and G to overlap.",
        "api_signature": "filter_candidates(self, candidates, layer, layer_id, triplet)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/crosstalk_adaptive_schedule.py"
    },
    {
        "api_name": "find_layer",
        "full_api_name": "CrosstalkAdaptiveSchedule.find_layer",
        "api_description": "Find the appropriate layer for a gate",
        "api_signature": "find_layer(self, layers, triplet)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/crosstalk_adaptive_schedule.py"
    },
    {
        "api_name": "generate_barriers",
        "full_api_name": "CrosstalkAdaptiveSchedule.generate_barriers",
        "api_description": "For each gate g, see if a barrier is required to serialize it with\nsome previously processed gate",
        "api_signature": "generate_barriers(self, layers)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/crosstalk_adaptive_schedule.py"
    },
    {
        "api_name": "create_updated_dag",
        "full_api_name": "CrosstalkAdaptiveSchedule.create_updated_dag",
        "api_description": "Given a set of layers and barriers, construct a new dag",
        "api_signature": "create_updated_dag(self, layers, barriers)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/crosstalk_adaptive_schedule.py"
    },
    {
        "api_name": "enforce_schedule_on_dag",
        "full_api_name": "CrosstalkAdaptiveSchedule.enforce_schedule_on_dag",
        "api_description": "Z3 outputs start times for each gate.\nSome gates need to be serialized to implement the Z3 schedule.\nThis function inserts barriers to implement those serializations",
        "api_signature": "enforce_schedule_on_dag(self, input_gate_times)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/crosstalk_adaptive_schedule.py"
    },
    {
        "api_name": "reset",
        "full_api_name": "CrosstalkAdaptiveSchedule.reset",
        "api_description": "Reset variables",
        "api_signature": "reset(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/crosstalk_adaptive_schedule.py"
    },
    {
        "api_name": "run",
        "full_api_name": "CrosstalkAdaptiveSchedule.run",
        "api_description": "Main scheduling function",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/crosstalk_adaptive_schedule.py"
    },
    {
        "api_name": "run",
        "full_api_name": "ResetAfterMeasureSimplification.run",
        "api_description": "Run the pass on a dag.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/reset_after_measure_simplification.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "TemplateOptimization.__init__",
        "api_description": "Args:\n    template_list (list[QuantumCircuit()]): list of the different template circuit to apply.\n    heuristics_backward_param (list[int]): [length, survivor] Those are the parameters for\n        applying heuristics on the backward part of the algorithm. This part of the\n        algorithm creates a tree of matching scenario. This tree grows exponentially. The\n        heuristics evaluates which scenarios have the longest match and keep only those.\n        The length is the interval in the tree for cutting it and survivor is the number\n        of scenarios that are kept. We advice to use l=3 and s=1 to have serious time\n        advantage. We remind that the heuristics implies losing a part of the maximal\n        matches. Check reference for more details.\n    heuristics_qubits_param (list[int]): [length] The heuristics for the qubit choice make\n        guesses from the dag dependency of the circuit in order to limit the number of\n        qubit configurations to explore. The length is the number of successors or not\n        predecessors that will be explored in the dag dependency of the circuit, each\n        qubits of the nodes are added to the set of authorized qubits. We advice to use\n        length=1. Check reference for more details.\n    user_cost_dict (Dict[str, int]): quantum cost dictionary passed to TemplateSubstitution\n        to configure its behavior. This will override any default values if None\n        is not given. The key is the name of the gate and the value its quantum cost.",
        "api_signature": "__init__(self, template_list, heuristics_qubits_param, heuristics_backward_param, user_cost_dict)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_optimization.py"
    },
    {
        "api_name": "run",
        "full_api_name": "TemplateOptimization.run",
        "api_description": "Args:\n    dag(DAGCircuit): DAG circuit.\nReturns:\n    DAGCircuit: optimized DAG circuit.\nRaises:\n    TranspilerError: If the template has not the right form or\n     if the output circuit acts differently as the input circuit.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_optimization.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CollectCliffords.__init__",
        "api_description": "CollectCliffords initializer.\n\nArgs:\n    do_commutative_analysis (bool): if True, exploits commutativity relations\n        between nodes.\n    split_blocks (bool): if True, splits collected blocks into sub-blocks\n        over disjoint qubit subsets.\n    min_block_size (int): specifies the minimum number of gates in the block\n        for the block to be collected.\n    split_layers (bool): if True, splits collected blocks into sub-blocks\n        over disjoint qubit subsets.\n    collect_from_back (bool): specifies if blocks should be collected started\n        from the end of the circuit.",
        "api_signature": "__init__(self, do_commutative_analysis, split_blocks, min_block_size, split_layers, collect_from_back)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/collect_cliffords.py"
    },
    {
        "api_name": "_is_clifford_gate",
        "full_api_name": "_is_clifford_gate",
        "api_description": "Specifies whether a node holds a clifford gate.",
        "api_signature": "_is_clifford_gate(node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/collect_cliffords.py"
    },
    {
        "api_name": "_collapse_to_clifford",
        "full_api_name": "_collapse_to_clifford",
        "api_description": "Specifies how to construct a ``Clifford`` from a quantum circuit (that must\nconsist of Clifford gates only).",
        "api_signature": "_collapse_to_clifford(circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/collect_cliffords.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "EchoRZXWeylDecomposition.__init__",
        "api_description": "EchoRZXWeylDecomposition pass.\n\nArgs:\n    instruction_schedule_map (InstructionScheduleMap): the mapping from circuit\n        :class:`~.circuit.Instruction` names and arguments to :class:`.Schedule`\\ s.\n    target (Target): The :class:`~.Target` representing the target backend, if both\n        ``instruction_schedule_map`` and this are specified then this argument will take\n        precedence and ``instruction_schedule_map`` will be ignored.",
        "api_signature": "__init__(self, instruction_schedule_map, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/echo_rzx_weyl_decomposition.py"
    },
    {
        "api_name": "_is_native",
        "full_api_name": "EchoRZXWeylDecomposition._is_native",
        "api_description": "Return the direction of the qubit pair that is native.",
        "api_signature": "_is_native(self, qubit_pair)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/echo_rzx_weyl_decomposition.py"
    },
    {
        "api_name": "_echo_rzx_dag",
        "full_api_name": "EchoRZXWeylDecomposition._echo_rzx_dag",
        "api_description": "Return the following circuit\n\n.. parsed-literal::\n\n         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\n    q_0: \u25240              \u251c\u2524 X \u251c\u25240               \u251c\u2524 X \u251c\n         \u2502  Rzx(theta/2) \u2502\u2514\u2500\u2500\u2500\u2518\u2502  Rzx(-theta/2) \u2502\u2514\u2500\u2500\u2500\u2518\n    q_1: \u25241              \u251c\u2500\u2500\u2500\u2500\u2500\u25241               \u251c\u2500\u2500\u2500\u2500\u2500\n         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
        "api_signature": "_echo_rzx_dag(theta)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/echo_rzx_weyl_decomposition.py"
    },
    {
        "api_name": "_reverse_echo_rzx_dag",
        "full_api_name": "EchoRZXWeylDecomposition._reverse_echo_rzx_dag",
        "api_description": "Return the following circuit\n\n.. parsed-literal::\n\n         \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\n    q_0: \u2524 H \u251c\u25241              \u251c\u2500\u2500\u2500\u2500\u2500\u25241               \u251c\u2524 H \u251c\u2500\u2500\u2500\u2500\u2500\n         \u251c\u2500\u2500\u2500\u2524\u2502  Rzx(theta/2) \u2502\u250c\u2500\u2500\u2500\u2510\u2502  Rzx(-theta/2) \u2502\u251c\u2500\u2500\u2500\u2524\u250c\u2500\u2500\u2500\u2510\n    q_1: \u2524 H \u251c\u25240              \u251c\u2524 X \u251c\u25240               \u251c\u2524 X \u251c\u2524 H \u251c\n         \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518",
        "api_signature": "_reverse_echo_rzx_dag(theta)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/echo_rzx_weyl_decomposition.py"
    },
    {
        "api_name": "run",
        "full_api_name": "EchoRZXWeylDecomposition.run",
        "api_description": "Run the EchoRZXWeylDecomposition pass on `dag`.\n\nRewrites two-qubit gates in an arbitrary circuit in terms of echoed cross-resonance\ngates by computing the Weyl decomposition of the corresponding unitary. Modifies the\ninput dag.\n\nArgs:\n    dag (DAGCircuit): DAG to rewrite.\n\nReturns:\n    DAGCircuit: The modified dag.\n\nRaises:\n    TranspilerError: If the circuit cannot be rewritten.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/echo_rzx_weyl_decomposition.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "InverseCancellation.__init__",
        "api_description": "Initialize InverseCancellation pass.\n\nArgs:\n    gates_to_cancel: list of gates to cancel\n\nRaises:\n    TranspilerError:\n        Initialization raises an error when the input is not a self-inverse gate\n        or a two-tuple of inverse gates.",
        "api_signature": "__init__(self, gates_to_cancel)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/inverse_cancellation.py"
    },
    {
        "api_name": "run",
        "full_api_name": "InverseCancellation.run",
        "api_description": "Run the InverseCancellation pass on `dag`.\n\nArgs:\n    dag: the directed acyclic graph to run on.\n\nReturns:\n    DAGCircuit: Transformed DAG.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/inverse_cancellation.py"
    },
    {
        "api_name": "_run_on_self_inverse",
        "full_api_name": "InverseCancellation._run_on_self_inverse",
        "api_description": "Run self-inverse gates on `dag`.\n\nArgs:\n    dag: the directed acyclic graph to run on.\n    self_inverse_gates: list of gates who cancel themeselves in pairs\n\nReturns:\n    DAGCircuit: Transformed DAG.",
        "api_signature": "_run_on_self_inverse(self, dag, self_inverse_gates)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/inverse_cancellation.py"
    },
    {
        "api_name": "_run_on_inverse_pairs",
        "full_api_name": "InverseCancellation._run_on_inverse_pairs",
        "api_description": "Run inverse gate pairs on `dag`.\n\nArgs:\n    dag: the directed acyclic graph to run on.\n    inverse_gate_pairs: list of gates with inverse angles that cancel each other.\n\nReturns:\n    DAGCircuit: Transformed DAG.",
        "api_signature": "_run_on_inverse_pairs(self, dag, inverse_gate_pairs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/inverse_cancellation.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CommutationAnalysis.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/commutation_analysis.py"
    },
    {
        "api_name": "run",
        "full_api_name": "CommutationAnalysis.run",
        "api_description": "Run the CommutationAnalysis pass on `dag`.\n\nRun the pass on the DAG, and write the discovered commutation relations\ninto the property_set.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/commutation_analysis.py"
    },
    {
        "api_name": "run",
        "full_api_name": "RemoveDiagonalGatesBeforeMeasure.run",
        "api_description": "Run the RemoveDiagonalGatesBeforeMeasure pass on `dag`.\n\nArgs:\n    dag (DAGCircuit): the DAG to be optimized.\n\nReturns:\n    DAGCircuit: the optimized DAG.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/remove_diagonal_gates_before_measure.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ConsolidateBlocks.__init__",
        "api_description": "ConsolidateBlocks initializer.\n\nIf `kak_basis_gate` is not `None` it will be used as the basis gate for KAK decomposition.\nOtherwise, if `basis_gates` is not `None` a basis gate will be chosen from this list.\nOtherwise the basis gate will be `CXGate`.\n\nArgs:\n    kak_basis_gate (Gate): Basis gate for KAK decomposition.\n    force_consolidate (bool): Force block consolidation.\n    basis_gates (List(str)): Basis gates from which to choose a KAK gate.\n    approximation_degree (float): a float between [0.0, 1.0]. Lower approximates more.\n    target (Target): The target object for the compilation target backend.",
        "api_signature": "__init__(self, kak_basis_gate, force_consolidate, basis_gates, approximation_degree, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/consolidate_blocks.py"
    },
    {
        "api_name": "run",
        "full_api_name": "ConsolidateBlocks.run",
        "api_description": "Run the ConsolidateBlocks pass on `dag`.\n\nIterate over each block and replace it with an equivalent Unitary\non the same wires.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/consolidate_blocks.py"
    },
    {
        "api_name": "_handle_control_flow_ops",
        "full_api_name": "ConsolidateBlocks._handle_control_flow_ops",
        "api_description": "This is similar to transpiler/passes/utils/control_flow.py except that the\ncollect blocks is redone for the control flow blocks.",
        "api_signature": "_handle_control_flow_ops(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/consolidate_blocks.py"
    },
    {
        "api_name": "_check_not_in_basis",
        "full_api_name": "ConsolidateBlocks._check_not_in_basis",
        "api_description": "",
        "api_signature": "_check_not_in_basis(self, dag, gate_name, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/consolidate_blocks.py"
    },
    {
        "api_name": "_block_qargs_to_indices",
        "full_api_name": "ConsolidateBlocks._block_qargs_to_indices",
        "api_description": "Map each qubit in block_qargs to its wire position among the block's wires.\nArgs:\n    block_qargs (list): list of qubits that a block acts on\n    global_index_map (dict): mapping from each qubit in the\n        circuit to its wire position within that circuit\nReturns:\n    dict: mapping from qarg to position in block",
        "api_signature": "_block_qargs_to_indices(self, dag, block_qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/consolidate_blocks.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "HoareOptimizer.__init__",
        "api_description": "Args:\n    size (int): size of gate cache, in number of gates\nRaises:\n    MissingOptionalLibraryError: if unable to import z3 solver",
        "api_signature": "__init__(self, size)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/hoare_opt.py"
    },
    {
        "api_name": "_gen_variable",
        "full_api_name": "HoareOptimizer._gen_variable",
        "api_description": "After each gate generate a new unique variable name for each of the\n    qubits, using scheme: 'q[id]_[gatenum]', e.g. q1_0 -> q1_1 -> q1_2,\n                                                  q2_0 -> q2_1\nArgs:\n    qubit (Qubit): qubit to generate new variable for\nReturns:\n    BoolRef: z3 variable of qubit state",
        "api_signature": "_gen_variable(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/hoare_opt.py"
    },
    {
        "api_name": "_initialize",
        "full_api_name": "HoareOptimizer._initialize",
        "api_description": "create boolean variables for each qubit and apply qb == 0 condition\nArgs:\n    dag (DAGCircuit): input DAG to get qubits from",
        "api_signature": "_initialize(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/hoare_opt.py"
    },
    {
        "api_name": "_add_postconditions",
        "full_api_name": "HoareOptimizer._add_postconditions",
        "api_description": "create boolean variables for each qubit the gate is applied to\n    and apply the relevant post conditions.\n    a gate rotating out of the z-basis will not have any valid\n    post-conditions, in which case the qubit state is unknown\nArgs:\n    gate (Gate): gate to inspect\n    ctrl_ones (BoolRef): z3 condition asserting all control qubits to 1\n    trgtqb (list((QuantumRegister, int))): list of target qubits\n    trgtvar (list(BoolRef)): z3 variables corresponding to latest state\n                             of target qubits",
        "api_signature": "_add_postconditions(self, gate, ctrl_ones, trgtqb, trgtvar)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/hoare_opt.py"
    },
    {
        "api_name": "_test_gate",
        "full_api_name": "HoareOptimizer._test_gate",
        "api_description": "use z3 sat solver to determine triviality of gate\nArgs:\n    gate (Gate): gate to inspect\n    ctrl_ones (BoolRef): z3 condition asserting all control qubits to 1\n    trgtvar (list(BoolRef)): z3 variables corresponding to latest state\n                             of target qubits\nReturns:\n    bool: if gate is trivial",
        "api_signature": "_test_gate(self, gate, ctrl_ones, trgtvar)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/hoare_opt.py"
    },
    {
        "api_name": "_remove_control",
        "full_api_name": "HoareOptimizer._remove_control",
        "api_description": "use z3 sat solver to determine if all control qubits are in 1 state,\n     and if so replace the Controlled - U by U.\nArgs:\n    gate (Gate): gate to inspect\n    ctrlvar (list(BoolRef)): z3 variables corresponding to latest state\n                             of control qubits\n    trgtvar (list(BoolRef)): z3 variables corresponding to latest state\n                             of target qubits\nReturns:\n    Tuple(bool, DAGCircuit, List)::\n      * bool:if controlled gate can be replaced.\n      * DAGCircuit: with U applied to the target qubits.\n      * List: with indices of target qubits.",
        "api_signature": "_remove_control(self, gate, ctrlvar, trgtvar)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/hoare_opt.py"
    },
    {
        "api_name": "_check_removal",
        "full_api_name": "HoareOptimizer._check_removal",
        "api_description": "",
        "api_signature": "_check_removal(self, ctrlvar)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/hoare_opt.py"
    },
    {
        "api_name": "_traverse_dag",
        "full_api_name": "HoareOptimizer._traverse_dag",
        "api_description": "traverse DAG in topological order\n    for each gate check: if any control is 0, or\n                         if triviality conditions are satisfied\n    if yes remove gate from dag\n    apply postconditions of gate\nArgs:\n    dag (DAGCircuit): input DAG to optimize in place",
        "api_signature": "_traverse_dag(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/hoare_opt.py"
    },
    {
        "api_name": "_remove_successive_identity",
        "full_api_name": "HoareOptimizer._remove_successive_identity",
        "api_description": "remove gates that have the same set of target qubits, follow each\n    other immediately on these target qubits, and combine to the\n    identity (consider sequences of length 2 for now)\nArgs:\n    dag (DAGCircuit): the directed acyclic graph to run on.\n    qubit (Qubit): qubit cache to inspect\n    from_idx (int): only gates whose indexes in the cache are larger\n                    than this value can be removed",
        "api_signature": "_remove_successive_identity(self, dag, qubit, from_idx)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/hoare_opt.py"
    },
    {
        "api_name": "_is_identity",
        "full_api_name": "HoareOptimizer._is_identity",
        "api_description": "determine whether the sequence of gates combines to the identity\n    (consider sequences of length 2 for now)\nArgs:\n    sequence (list(DAGOpNode)): gate sequence to inspect\nReturns:\n    bool: if gate sequence combines to identity",
        "api_signature": "_is_identity(self, sequence)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/hoare_opt.py"
    },
    {
        "api_name": "_seq_as_one",
        "full_api_name": "HoareOptimizer._seq_as_one",
        "api_description": "use z3 solver to determine if the gates in the sequence are either\n    all executed or none of them are executed, based on control qubits\n    (consider sequences of length 2 for now)\nArgs:\n    sequence (list(DAGOpNode)): gate sequence to inspect\nReturns:\n    bool: if gate sequence is only executed completely or not at all",
        "api_signature": "_seq_as_one(self, sequence)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/hoare_opt.py"
    },
    {
        "api_name": "_multigate_opt",
        "full_api_name": "HoareOptimizer._multigate_opt",
        "api_description": "Args:\n    dag (DAGCircuit): the directed acyclic graph to run on.\n    qubit (Qubit): qubit whose gate cache is to be optimized\n    max_idx (int): a value indicates a recursive call, optimize\n                   and remove gates up to this point in the cache\n    dnt_rec (list(int)): don't recurse on these qubit caches (again)",
        "api_signature": "_multigate_opt(self, dag, qubit, max_idx, dnt_rec)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/hoare_opt.py"
    },
    {
        "api_name": "_seperate_ctrl_trgt",
        "full_api_name": "HoareOptimizer._seperate_ctrl_trgt",
        "api_description": "Get the target qubits and control qubits if available,\nas well as their respective z3 variables.",
        "api_signature": "_seperate_ctrl_trgt(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/hoare_opt.py"
    },
    {
        "api_name": "_reset",
        "full_api_name": "HoareOptimizer._reset",
        "api_description": "Reset HoareOptimize internal state,\nso it can be run multiple times.",
        "api_signature": "_reset(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/hoare_opt.py"
    },
    {
        "api_name": "run",
        "full_api_name": "HoareOptimizer.run",
        "api_description": "Args:\n    dag (DAGCircuit): the directed acyclic graph to run on.\nReturns:\n    DAGCircuit: Transformed DAG.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/hoare_opt.py"
    },
    {
        "api_name": "run",
        "full_api_name": "Collect2qBlocks.run",
        "api_description": "Run the Collect2qBlocks pass on `dag`.\n\nThe blocks contain \"op\" nodes in topological order such that all gates\nin a block act on the same qubits and are adjacent in the circuit.\n\nAfter the execution, ``property_set['block_list']`` is set to a list of\ntuples of \"op\" node.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/collect_2q_blocks.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CollectLinearFunctions.__init__",
        "api_description": "CollectLinearFunctions initializer.\n\nArgs:\n    do_commutative_analysis (bool): if True, exploits commutativity relations\n        between nodes.\n    split_blocks (bool): if True, splits collected blocks into sub-blocks\n        over disjoint qubit subsets.\n    min_block_size (int): specifies the minimum number of gates in the block\n        for the block to be collected.\n    split_layers (bool): if True, splits collected blocks into sub-blocks\n        over disjoint qubit subsets.\n    collect_from_back (bool): specifies if blocks should be collected started\n        from the end of the circuit.",
        "api_signature": "__init__(self, do_commutative_analysis, split_blocks, min_block_size, split_layers, collect_from_back)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/collect_linear_functions.py"
    },
    {
        "api_name": "_is_linear_gate",
        "full_api_name": "_is_linear_gate",
        "api_description": "Specifies whether a node holds a linear gate.",
        "api_signature": "_is_linear_gate(node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/collect_linear_functions.py"
    },
    {
        "api_name": "_collapse_to_linear_function",
        "full_api_name": "_collapse_to_linear_function",
        "api_description": "Specifies how to construct a ``LinearFunction`` from a quantum circuit (that must\nconsist of linear gates only).",
        "api_signature": "_collapse_to_linear_function(circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/collect_linear_functions.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "NormalizeRXAngle.__init__",
        "api_description": "NormalizeRXAngle initializer.\n\nArgs:\n    target (Target): The :class:`~.Target` representing the target backend.\n        If the target contains SX and X calibrations, this pass will replace the\n        corresponding RX gates with SX and X gates.\n    resolution_in_radian (float): Resolution for RX rotation angle quantization.\n        If set to zero, this pass won't modify the rotation angles in the given DAG.\n        (=Provides aribitary-angle RX)",
        "api_signature": "__init__(self, target, resolution_in_radian)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/normalize_rx_angle.py"
    },
    {
        "api_name": "quantize_angles",
        "full_api_name": "NormalizeRXAngle.quantize_angles",
        "api_description": "Quantize the RX rotation angles by assigning the same value for the angles\nthat differ within a resolution provided by the user.\n\nArgs:\n    qubit (Qubit): This will be the dict key to access the list of quantized rotation angles.\n    original_angle (float): Original rotation angle, before quantization.\n\nReturns:\n    float: Quantized angle.",
        "api_signature": "quantize_angles(self, qubit, original_angle)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/normalize_rx_angle.py"
    },
    {
        "api_name": "run",
        "full_api_name": "NormalizeRXAngle.run",
        "api_description": "Run the NormalizeRXAngle pass on ``dag``.\n\nArgs:\n    dag (DAGCircuit): The DAG to be optimized.\n\nReturns:\n    DAGCircuit: A DAG with RX gate calibration.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/normalize_rx_angle.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CommutativeCancellation.__init__",
        "api_description": "CommutativeCancellation initializer.\n\nArgs:\n    basis_gates (list[str]): Basis gates to consider, e.g.\n        ``['u3', 'cx']``. For the effects of this pass, the basis is\n        the set intersection between the ``basis_gates`` parameter\n        and the gates in the dag.\n    target (Target): The :class:`~.Target` representing the target backend, if both\n        ``basis_gates`` and this are specified then this argument will take\n        precedence and ``basis_gates`` will be ignored.",
        "api_signature": "__init__(self, basis_gates, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/commutative_cancellation.py"
    },
    {
        "api_name": "run",
        "full_api_name": "CommutativeCancellation.run",
        "api_description": "Run the CommutativeCancellation pass on `dag`.\n\nArgs:\n    dag (DAGCircuit): the DAG to be optimized.\n\nReturns:\n    DAGCircuit: the optimized DAG.\n\nRaises:\n    TranspilerError: when the 1-qubit rotation gates are not found",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/commutative_cancellation.py"
    },
    {
        "api_name": "_handle_control_flow_ops",
        "full_api_name": "CommutativeCancellation._handle_control_flow_ops",
        "api_description": "This is similar to transpiler/passes/utils/control_flow.py except that the\ncommutation analysis is redone for the control flow blocks.",
        "api_signature": "_handle_control_flow_ops(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/commutative_cancellation.py"
    },
    {
        "api_name": "run",
        "full_api_name": "CXCancellation.run",
        "api_description": "Run the CXCancellation pass on `dag`.\n\nArgs:\n    dag (DAGCircuit): the directed acyclic graph to run on.\n\nReturns:\n    DAGCircuit: Transformed DAG.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/cx_cancellation.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Optimize1qGatesSimpleCommutation.__init__",
        "api_description": "Args:\n    basis (List[str]): See also `Optimize1qGatesDecomposition`.\n    run_to_completion (bool): If `True`, this pass retries until it is unable to do any more\n        work.  If `False`, it finds and performs one optimization, and for full optimization\n        the user is obligated to re-call the pass until the output stabilizes.\n    target (Target): The :class:`~.Target` representing the target backend, if both\n        ``basis`` and this are specified then this argument will take\n        precedence and ``basis`` will be ignored.",
        "api_signature": "__init__(self, basis, run_to_completion, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/optimize_1q_commutation.py"
    },
    {
        "api_name": "_find_adjoining_run",
        "full_api_name": "Optimize1qGatesSimpleCommutation._find_adjoining_run",
        "api_description": "Finds the run which abuts `run` from the front (or the rear if `front == False`), separated\nby a blocking node.\n\nReturns a pair of the abutting multi-qubit gate and the run which it separates from this\none. The next run can be the empty list `[]` if it is absent.",
        "api_signature": "_find_adjoining_run(dag, runs, run, front)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/optimize_1q_commutation.py"
    },
    {
        "api_name": "_commute_through",
        "full_api_name": "Optimize1qGatesSimpleCommutation._commute_through",
        "api_description": "Pulls `DAGOpNode`s from the front of `run` (or the back, if `front == False`) until it\nencounters a gate which does not commute with `blocker`.\n\nReturns a pair of lists whose concatenation is `run`.",
        "api_signature": "_commute_through(blocker, run, front)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/optimize_1q_commutation.py"
    },
    {
        "api_name": "_resynthesize",
        "full_api_name": "Optimize1qGatesSimpleCommutation._resynthesize",
        "api_description": "Synthesizes an efficient circuit from a sequence `run` of `DAGOpNode`s.\n\nNOTE: Returns None when resynthesis is not possible.",
        "api_signature": "_resynthesize(self, run, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/optimize_1q_commutation.py"
    },
    {
        "api_name": "_replace_subdag",
        "full_api_name": "Optimize1qGatesSimpleCommutation._replace_subdag",
        "api_description": "Replaces a nonempty sequence `old_run` of `DAGNode`s, assumed to be a complete chain in\n`dag`, with the circuit `new_circ`.",
        "api_signature": "_replace_subdag(dag, old_run, new_dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/optimize_1q_commutation.py"
    },
    {
        "api_name": "_step",
        "full_api_name": "Optimize1qGatesSimpleCommutation._step",
        "api_description": "Performs one full pass of optimization work.\n\nReturns True if `dag` changed, False if no work on `dag` was possible.",
        "api_signature": "_step(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/optimize_1q_commutation.py"
    },
    {
        "api_name": "run",
        "full_api_name": "Optimize1qGatesSimpleCommutation.run",
        "api_description": "Args:\n    dag (DAGCircuit): the DAG to be optimized.\n\nReturns:\n    DAGCircuit: the optimized DAG.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/optimize_1q_commutation.py"
    },
    {
        "api_name": "mov_list",
        "full_api_name": "mov_list",
        "api_description": "Replace `destination` in-place with `source`.",
        "api_signature": "mov_list(destination, source)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/optimize_1q_commutation.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Optimize1qGates.__init__",
        "api_description": "Optimize1qGates initializer.\n\nArgs:\n    basis (list[str]): Basis gates to consider, e.g. `['u3', 'cx']`. For the effects\n        of this pass, the basis is the set intersection between the `basis` parameter and\n        the set `{'u1','u2','u3', 'u', 'p'}`.\n    eps (float): EPS to check against\n    target (Target): The :class:`~.Target` representing the target backend, if both\n        ``basis`` and this are specified then this argument will take\n        precedence and ``basis`` will be ignored.",
        "api_signature": "__init__(self, basis, eps, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/optimize_1q_gates.py"
    },
    {
        "api_name": "run",
        "full_api_name": "Optimize1qGates.run",
        "api_description": "Run the Optimize1qGates pass on `dag`.\n\nArgs:\n    dag (DAGCircuit): the DAG to be optimized.\n\nReturns:\n    DAGCircuit: the optimized DAG.\n\nRaises:\n    TranspilerError: if YZY and ZYZ angles do not give same rotation matrix.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/optimize_1q_gates.py"
    },
    {
        "api_name": "compose_u3",
        "full_api_name": "Optimize1qGates.compose_u3",
        "api_description": "Return a triple theta, phi, lambda for the product.\n\nu3(theta, phi, lambda)\n   = u3(theta1, phi1, lambda1).u3(theta2, phi2, lambda2)\n   = Rz(phi1).Ry(theta1).Rz(lambda1+phi2).Ry(theta2).Rz(lambda2)\n   = Rz(phi1).Rz(phi').Ry(theta').Rz(lambda').Rz(lambda2)\n   = u3(theta', phi1 + phi', lambda2 + lambda')\n\nReturn theta, phi, lambda.",
        "api_signature": "compose_u3(theta1, phi1, lambda1, theta2, phi2, lambda2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/optimize_1q_gates.py"
    },
    {
        "api_name": "yzy_to_zyz",
        "full_api_name": "Optimize1qGates.yzy_to_zyz",
        "api_description": "Express a Y.Z.Y single qubit gate as a Z.Y.Z gate.\n\nSolve the equation\n\n.. math::\n\nRy(theta1).Rz(xi).Ry(theta2) = Rz(phi).Ry(theta).Rz(lambda)\n\nfor theta, phi, and lambda.\n\nReturn a solution theta, phi, and lambda.",
        "api_signature": "yzy_to_zyz(xi, theta1, theta2, eps)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/optimize_1q_gates.py"
    },
    {
        "api_name": "_split_runs_on_parameters",
        "full_api_name": "_split_runs_on_parameters",
        "api_description": "Finds runs containing parameterized gates and splits them into sequential\nruns excluding the parameterized gates.",
        "api_signature": "_split_runs_on_parameters(runs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/optimize_1q_gates.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ForwardMatch.__init__",
        "api_description": "Create a ForwardMatch class with necessary arguments.\nArgs:\n    circuit_dag_dep (DAGDependency): circuit in the dag dependency form.\n    template_dag_dep (DAGDependency): template in the dag dependency form.\n    node_id_c (int): index of the first gate matched in the circuit.\n    node_id_t (int): index of the first gate matched in the template.\n    qubits (list): list of considered qubits in the circuit.\n    clbits (list): list of considered clbits in the circuit.",
        "api_signature": "__init__(self, circuit_dag_dep, template_dag_dep, node_id_c, node_id_t, qubits, clbits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/forward_match.py"
    },
    {
        "api_name": "_init_successors_to_visit",
        "full_api_name": "ForwardMatch._init_successors_to_visit",
        "api_description": "Initialize the attribute list 'SuccessorsToVisit'",
        "api_signature": "_init_successors_to_visit(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/forward_match.py"
    },
    {
        "api_name": "_init_matched_with_circuit",
        "full_api_name": "ForwardMatch._init_matched_with_circuit",
        "api_description": "Initialize the attribute 'MatchedWith' in the template DAG dependency.",
        "api_signature": "_init_matched_with_circuit(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/forward_match.py"
    },
    {
        "api_name": "_init_matched_with_template",
        "full_api_name": "ForwardMatch._init_matched_with_template",
        "api_description": "Initialize the attribute 'MatchedWith' in the circuit DAG dependency.",
        "api_signature": "_init_matched_with_template(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/forward_match.py"
    },
    {
        "api_name": "_init_is_blocked_circuit",
        "full_api_name": "ForwardMatch._init_is_blocked_circuit",
        "api_description": "Initialize the attribute 'IsBlocked' in the circuit DAG dependency.",
        "api_signature": "_init_is_blocked_circuit(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/forward_match.py"
    },
    {
        "api_name": "_init_is_blocked_template",
        "full_api_name": "ForwardMatch._init_is_blocked_template",
        "api_description": "Initialize the attribute 'IsBlocked' in the template DAG dependency.",
        "api_signature": "_init_is_blocked_template(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/forward_match.py"
    },
    {
        "api_name": "_init_list_match",
        "full_api_name": "ForwardMatch._init_list_match",
        "api_description": "Initialize the list of matched nodes between the circuit and the template\nwith the first match found.",
        "api_signature": "_init_list_match(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/forward_match.py"
    },
    {
        "api_name": "_find_forward_candidates",
        "full_api_name": "ForwardMatch._find_forward_candidates",
        "api_description": "Find the candidate nodes to be matched in the template for a given node.\nArgs:\n    node_id_t (int): considered node id.",
        "api_signature": "_find_forward_candidates(self, node_id_t)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/forward_match.py"
    },
    {
        "api_name": "_init_matched_nodes",
        "full_api_name": "ForwardMatch._init_matched_nodes",
        "api_description": "Initialize the list of current matched nodes.",
        "api_signature": "_init_matched_nodes(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/forward_match.py"
    },
    {
        "api_name": "_get_node_forward",
        "full_api_name": "ForwardMatch._get_node_forward",
        "api_description": "Return a node from the matched_node_list for a given list id.\nArgs:\n    list_id (int): considered list id of the desired node.\n\nReturns:\n    DAGDepNode: DAGDepNode object corresponding to i-th node of the matched_node_list.",
        "api_signature": "_get_node_forward(self, list_id)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/forward_match.py"
    },
    {
        "api_name": "_remove_node_forward",
        "full_api_name": "ForwardMatch._remove_node_forward",
        "api_description": "Remove a node of the current matched list for a given list id.\nArgs:\n    list_id (int): considered list id of the desired node.",
        "api_signature": "_remove_node_forward(self, list_id)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/forward_match.py"
    },
    {
        "api_name": "_update_successor",
        "full_api_name": "ForwardMatch._update_successor",
        "api_description": "Return a node with an updated attribute 'SuccessorToVisit'.\nArgs:\n    node (DAGDepNode): current node.\n    successor_id (int): successor id to remove.\n\nReturns:\n    DAGOpNode or DAGOutNode: Node with updated attribute 'SuccessorToVisit'.",
        "api_signature": "_update_successor(self, node, successor_id)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/forward_match.py"
    },
    {
        "api_name": "_get_successors_to_visit",
        "full_api_name": "ForwardMatch._get_successors_to_visit",
        "api_description": "Return the successor for a given node and id.\nArgs:\n    node (DAGOpNode or DAGOutNode): current node.\n    list_id (int): id in the list for the successor to get.\n\nReturns:\n    int: id of the successor to get.",
        "api_signature": "_get_successors_to_visit(self, node, list_id)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/forward_match.py"
    },
    {
        "api_name": "_update_qarg_indices",
        "full_api_name": "ForwardMatch._update_qarg_indices",
        "api_description": "Change qubits indices of the current circuit node in order to\nbe comparable with the indices of the template qubits list.\nArgs:\n    qarg (list): list of qubits indices from the circuit for a given node.",
        "api_signature": "_update_qarg_indices(self, qarg)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/forward_match.py"
    },
    {
        "api_name": "_update_carg_indices",
        "full_api_name": "ForwardMatch._update_carg_indices",
        "api_description": "Change clbits indices of the current circuit node in order to\nbe comparable with the indices of the template qubits list.\nArgs:\n    carg (list): list of clbits indices from the circuit for a given node.",
        "api_signature": "_update_carg_indices(self, carg)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/forward_match.py"
    },
    {
        "api_name": "_is_same_op",
        "full_api_name": "ForwardMatch._is_same_op",
        "api_description": "Check if two instructions are the same.\nArgs:\n    node_circuit (DAGDepNode): node in the circuit.\n    node_template (DAGDepNode): node in the template.\nReturns:\n    bool: True if the same, False otherwise.",
        "api_signature": "_is_same_op(self, node_circuit, node_template)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/forward_match.py"
    },
    {
        "api_name": "_is_same_q_conf",
        "full_api_name": "ForwardMatch._is_same_q_conf",
        "api_description": "Check if the qubits configurations are compatible.\nArgs:\n    node_circuit (DAGDepNode): node in the circuit.\n    node_template (DAGDepNode): node in the template.\nReturns:\n    bool: True if possible, False otherwise.",
        "api_signature": "_is_same_q_conf(self, node_circuit, node_template)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/forward_match.py"
    },
    {
        "api_name": "_is_same_c_conf",
        "full_api_name": "ForwardMatch._is_same_c_conf",
        "api_description": "Check if the clbits configurations are compatible.\nArgs:\n    node_circuit (DAGDepNode): node in the circuit.\n    node_template (DAGDepNode): node in the template.\nReturns:\n    bool: True if possible, False otherwise.",
        "api_signature": "_is_same_c_conf(self, node_circuit, node_template)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/forward_match.py"
    },
    {
        "api_name": "run_forward_match",
        "full_api_name": "ForwardMatch.run_forward_match",
        "api_description": "Apply the forward match algorithm and returns the list of matches given an initial match\nand a circuit qubits configuration.",
        "api_signature": "run_forward_match(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/forward_match.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SubstitutionConfig.__init__",
        "api_description": "",
        "api_signature": "__init__(self, circuit_config, template_config, pred_block, qubit_config, template_dag_dep, clbit_config)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/template_substitution.py"
    },
    {
        "api_name": "has_parameters",
        "full_api_name": "SubstitutionConfig.has_parameters",
        "api_description": "Ensure that the template does not have parameters.",
        "api_signature": "has_parameters(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/template_substitution.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "TemplateSubstitution.__init__",
        "api_description": "Initialize TemplateSubstitution with necessary arguments.\nArgs:\n    max_matches (list): list of maximal matches obtained from the running\n     the template matching algorithm.\n    circuit_dag_dep (DAGDependency): circuit in the dag dependency form.\n    template_dag_dep (DAGDependency): template in the dag dependency form.\n    user_cost_dict (Optional[dict]): user provided cost dictionary that will override\n        the default cost dictionary.",
        "api_signature": "__init__(self, max_matches, circuit_dag_dep, template_dag_dep, user_cost_dict)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/template_substitution.py"
    },
    {
        "api_name": "_pred_block",
        "full_api_name": "TemplateSubstitution._pred_block",
        "api_description": "It returns the predecessors of a given part of the circuit.\nArgs:\n    circuit_sublist (list): list of the gates matched in the circuit.\n    index (int): Index of the group of matches.\nReturns:\n    list: List of predecessors of the current match circuit configuration.",
        "api_signature": "_pred_block(self, circuit_sublist, index)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/template_substitution.py"
    },
    {
        "api_name": "_quantum_cost",
        "full_api_name": "TemplateSubstitution._quantum_cost",
        "api_description": "Compare the two parts of the template and returns True if the quantum cost is reduced.\nArgs:\n    left (list): list of matched nodes in the template.\n    right (list): list of nodes to be replaced.\nReturns:\n    bool: True if the quantum cost is reduced",
        "api_signature": "_quantum_cost(self, left, right)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/template_substitution.py"
    },
    {
        "api_name": "_rules",
        "full_api_name": "TemplateSubstitution._rules",
        "api_description": "Set of rules to decide whether the match is to be substitute or not.\nArgs:\n    circuit_sublist (list): list of the gates matched in the circuit.\n    template_sublist (list): list of matched nodes in the template.\n    template_complement (list): list of gates not matched in the template.\nReturns:\n    bool: True if the match respects the given rule for replacement, False otherwise.",
        "api_signature": "_rules(self, circuit_sublist, template_sublist, template_complement)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/template_substitution.py"
    },
    {
        "api_name": "_template_inverse",
        "full_api_name": "TemplateSubstitution._template_inverse",
        "api_description": "The template circuit realizes the identity operator, then given the list of\nmatches in the template, it returns the inverse part of the template that\nwill be replaced.\nArgs:\n    template_list (list): list of all gates in the template.\n    template_sublist (list): list of the gates matched in the circuit.\n    template_complement  (list): list of gates not matched in the template.\nReturns:\n    list: the template inverse part that will substitute the circuit match.",
        "api_signature": "_template_inverse(self, template_list, template_sublist, template_complement)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/template_substitution.py"
    },
    {
        "api_name": "_substitution_sort",
        "full_api_name": "TemplateSubstitution._substitution_sort",
        "api_description": "Sort the substitution list.",
        "api_signature": "_substitution_sort(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/template_substitution.py"
    },
    {
        "api_name": "_permutation",
        "full_api_name": "TemplateSubstitution._permutation",
        "api_description": "Permute two groups of matches if first one has predecessors in the second one.\nReturns:\n    bool: True if the matches groups are in the right order, False otherwise.",
        "api_signature": "_permutation(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/template_substitution.py"
    },
    {
        "api_name": "_remove_impossible",
        "full_api_name": "TemplateSubstitution._remove_impossible",
        "api_description": "Remove matched groups if they both have predecessors in the other one, they are not\ncompatible.",
        "api_signature": "_remove_impossible(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/template_substitution.py"
    },
    {
        "api_name": "_substitution",
        "full_api_name": "TemplateSubstitution._substitution",
        "api_description": "From the list of maximal matches, it chooses which one will be used and gives the necessary\ndetails for each substitution(template inverse, predecessors of the match).",
        "api_signature": "_substitution(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/template_substitution.py"
    },
    {
        "api_name": "run_dag_opt",
        "full_api_name": "TemplateSubstitution.run_dag_opt",
        "api_description": "It runs the substitution algorithm and creates the optimized DAGCircuit().",
        "api_signature": "run_dag_opt(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/template_substitution.py"
    },
    {
        "api_name": "_attempt_bind",
        "full_api_name": "TemplateSubstitution._attempt_bind",
        "api_description": "Copies the template and attempts to bind any parameters,\ni.e. attempts to solve for a valid parameter assignment.\ntemplate_sublist and circuit_sublist match up to the\nassignment of the parameters. For example the template\n\n.. parsed-literal::\n\n         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    q_0: \u2524 P(-1.0*\u03b2) \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u25240       \u251c\n         \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u250c\u2500\u2534\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2534\u2500\u2510\u2502  CZ(\u03b2) \u2502\n    q_1: \u2524 P(-1.0*\u03b2) \u251c\u2524 X \u251c\u2524 P(\u03b2) \u251c\u2524 X \u251c\u25241       \u251c\n         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nshould only maximally match once in the circuit\n\n.. parsed-literal::\n\n         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    q_0: \u2524 P(-2) \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n         \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u250c\u2500\u2534\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2534\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    q_1: \u2524 P(-2) \u251c\u2524 X \u251c\u2524 P(2) \u251c\u2524 X \u251c\u2524 P(3) \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\n         \u2514\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2534\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2534\u2500\u2510\n    q_2: \u2500\u2524 P(3) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2524 P(3) \u251c\u2524 X \u251c\n          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518                          \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\n\nHowever, up until attempt bind is called, the soft matching\nwill have found two matches due to the parameters.\nThe first match can be satisfied with \u03b2=2. However, the\nsecond match would imply both \u03b2=3 and \u03b2=-3 which is impossible.\nAttempt bind detects inconsistencies by solving a system of equations\ngiven by the parameter expressions in the sub-template and the\nvalue of the parameters in the gates of the sub-circuit. If a\nsolution is found then the match is valid and the parameters\nare assigned. If not, None is returned.\n\nIn order to resolve the conflict of the same parameter names in the\ncircuit and template, each variable in the template sublist is\nre-assigned to a new dummy parameter with a completely separate name\nif it clashes with one that exists in an input circuit.\n\nArgs:\n    template_sublist (list): part of the matched template.\n    circuit_sublist (list): part of the matched circuit.\n\nReturns:\n    DAGDependency: A deep copy of the template with\n        the parameters bound. If no binding satisfies the\n        parameter constraints, returns None.",
        "api_signature": "_attempt_bind(self, template_sublist, circuit_sublist)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/template_substitution.py"
    },
    {
        "api_name": "dummy_parameter",
        "full_api_name": "TemplateSubstitution.dummy_parameter",
        "api_description": "",
        "api_signature": "dummy_parameter()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/template_substitution.py"
    },
    {
        "api_name": "_incr_num_parameters",
        "full_api_name": "TemplateSubstitution._incr_num_parameters",
        "api_description": "Checks if template substitution would increase the number of\nparameters in the circuit.",
        "api_signature": "_incr_num_parameters(self, template)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/template_substitution.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Match.__init__",
        "api_description": "Create a Match with necessary arguments.\nArgs:\n    match (list): list of a match.\n    qubit (list): list of qubits configuration.\n    clbit (list): list of clbits configuration.",
        "api_signature": "__init__(self, match, qubit, clbit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/maximal_matches.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "MaximalMatches.__init__",
        "api_description": "Initialize MaximalMatches with the necessary arguments.\nArgs:\n    template_matches (list): list of matches obtained from running the algorithm.",
        "api_signature": "__init__(self, template_matches)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/maximal_matches.py"
    },
    {
        "api_name": "run_maximal_matches",
        "full_api_name": "MaximalMatches.run_maximal_matches",
        "api_description": "Method that extracts and stores maximal matches in decreasing length order.",
        "api_signature": "run_maximal_matches(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/maximal_matches.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "TemplateMatching.__init__",
        "api_description": "Create a TemplateMatching object with necessary arguments.\nArgs:\n    circuit_dag_dep (QuantumCircuit): circuit.\n    template_dag_dep (QuantumCircuit): template.\n    heuristics_backward_param (list[int]): [length, survivor]\n    heuristics_qubits_param (list[int]): [length]",
        "api_signature": "__init__(self, circuit_dag_dep, template_dag_dep, heuristics_qubits_param, heuristics_backward_param)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/template_matching.py"
    },
    {
        "api_name": "_list_first_match_new",
        "full_api_name": "TemplateMatching._list_first_match_new",
        "api_description": "Returns the list of qubit for circuit given the first match, the unknown qubit are\nreplaced by -1.\nArgs:\n    node_circuit (DAGDepNode): First match node in the circuit.\n    node_template (DAGDepNode): First match node in the template.\n    n_qubits_t (int): number of qubit in the template.\n    n_clbits_t (int): number of classical bit in the template.\nReturns:\n    list: list of qubits to consider in circuit (with specific order).",
        "api_signature": "_list_first_match_new(self, node_circuit, node_template, n_qubits_t, n_clbits_t)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/template_matching.py"
    },
    {
        "api_name": "_sublist",
        "full_api_name": "TemplateMatching._sublist",
        "api_description": "Function that returns all possible combinations of a given length, considering an\nexcluded list of elements.\nArgs:\n    lst (list): list of qubits indices from the circuit.\n    exclude (list): list of qubits from the first matched circuit gate.\n    length (int): length of the list to be returned (number of template qubit -\n    number of qubit from the first matched template gate).\nYield:\n    iterator: Iterator of the possible lists.",
        "api_signature": "_sublist(self, lst, exclude, length)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/template_matching.py"
    },
    {
        "api_name": "_list_qubit_clbit_circuit",
        "full_api_name": "TemplateMatching._list_qubit_clbit_circuit",
        "api_description": "Function that returns the list of the circuit qubits and clbits give a permutation\nand an initial match.\nArgs:\n    list_first_match (list): list of qubits indices for the initial match.\n    permutation (list): possible permutation for the circuit qubit.\nReturns:\n    list: list of circuit qubit for the given permutation and initial match.",
        "api_signature": "_list_qubit_clbit_circuit(self, list_first_match, permutation)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/template_matching.py"
    },
    {
        "api_name": "_add_match",
        "full_api_name": "TemplateMatching._add_match",
        "api_description": "Method to add a match in list only if it is not already in it.\nIf the match is already in the list, the qubit configuration\nis append to the existing match.\nArgs:\n    backward_match_list (list): match from the backward part of the\n    algorithm.",
        "api_signature": "_add_match(self, backward_match_list)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/template_matching.py"
    },
    {
        "api_name": "_explore_circuit",
        "full_api_name": "TemplateMatching._explore_circuit",
        "api_description": "Explore the successors of the node_id_c (up to the given length).\nArgs:\n    node_id_c (int): first match id in the circuit.\n    node_id_t (int): first match id in the template.\n    n_qubits_t (int): number of qubits in the template.\n    length (int): length for exploration of the successors.\nReturns:\n    list: qubits configuration for the 'length' successors of node_id_c.",
        "api_signature": "_explore_circuit(self, node_id_c, node_id_t, n_qubits_t, length)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/template_matching.py"
    },
    {
        "api_name": "run_template_matching",
        "full_api_name": "TemplateMatching.run_template_matching",
        "api_description": "Run the complete algorithm for finding all maximal matches for the given template and\ncircuit. First it fixes the configuration of the circuit due to the first match.\nThen it explores all compatible qubit configurations of the circuit. For each\nqubit configurations, we apply first the Forward part of the algorithm  and then\nthe Backward part of the algorithm. The longest matches for the given configuration\nare stored. Finally, the list of stored matches is sorted.",
        "api_signature": "run_template_matching(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/template_matching.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Match.__init__",
        "api_description": "Create a Match class with necessary arguments.\nArgs:\n    match (list): list of matched gates.\n    qubit (list): list of qubits configuration.\n    clbit (list): list of clbits configuration.",
        "api_signature": "__init__(self, match, qubit, clbit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/backward_match.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "MatchingScenarios.__init__",
        "api_description": "Create a MatchingScenarios class with necessary arguments.\nArgs:\n    circuit_matched (list): list of matchedwith attributes in the circuit.\n    circuit_blocked (list): list of isblocked attributes in the circuit.\n    template_matched (list): list of matchedwith attributes in the template.\n    template_blocked (list): list of isblocked attributes in the template.\n    matches (list): list of matches.\n    counter (int): counter of the number of circuit gates already considered.",
        "api_signature": "__init__(self, circuit_matched, circuit_blocked, template_matched, template_blocked, matches, counter)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/backward_match.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "MatchingScenariosList.__init__",
        "api_description": "Create an empty MatchingScenariosList.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/backward_match.py"
    },
    {
        "api_name": "append_scenario",
        "full_api_name": "MatchingScenariosList.append_scenario",
        "api_description": "Append a scenario to the list.\nArgs:\n    matching (MatchingScenarios): a scenario of match.",
        "api_signature": "append_scenario(self, matching)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/backward_match.py"
    },
    {
        "api_name": "pop_scenario",
        "full_api_name": "MatchingScenariosList.pop_scenario",
        "api_description": "Pop the first scenario of the list.\nReturns:\n    MatchingScenarios: a scenario of match.",
        "api_signature": "pop_scenario(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/backward_match.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BackwardMatch.__init__",
        "api_description": "Create a ForwardMatch class with necessary arguments.\nArgs:\n    circuit_dag_dep (DAGDependency): circuit in the dag dependency form.\n    template_dag_dep (DAGDependency): template in the dag dependency form.\n    forward_matches (list): list of match obtained in the forward direction.\n    node_id_c (int): index of the first gate matched in the circuit.\n    node_id_t (int): index of the first gate matched in the template.\n    qubits (list): list of considered qubits in the circuit.\n    clbits (list): list of considered clbits in the circuit.\n    heuristics_backward_param (list): list that contains the two parameters for\n    applying the heuristics (length and survivor).",
        "api_signature": "__init__(self, circuit_dag_dep, template_dag_dep, forward_matches, node_id_c, node_id_t, qubits, clbits, heuristics_backward_param)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/backward_match.py"
    },
    {
        "api_name": "_gate_indices",
        "full_api_name": "BackwardMatch._gate_indices",
        "api_description": "Function which returns the list of gates that are not match and not\nblocked for the first scenario.\nReturns:\n    list: list of gate id.",
        "api_signature": "_gate_indices(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/backward_match.py"
    },
    {
        "api_name": "_find_backward_candidates",
        "full_api_name": "BackwardMatch._find_backward_candidates",
        "api_description": "Function which returns the list possible backward candidates in the template dag.\nArgs:\n    template_blocked (list): list of attributes isblocked in the template circuit.\n    matches (list): list of matches.\nReturns:\n    list: list of backward candidates (id).",
        "api_signature": "_find_backward_candidates(self, template_blocked, matches)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/backward_match.py"
    },
    {
        "api_name": "_update_qarg_indices",
        "full_api_name": "BackwardMatch._update_qarg_indices",
        "api_description": "Change qubits indices of the current circuit node in order to\nbe comparable the indices of the template qubits list.\nArgs:\n    qarg (list): list of qubits indices from the circuit for a given gate.\nReturns:\n    list: circuit indices update for qubits.",
        "api_signature": "_update_qarg_indices(self, qarg)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/backward_match.py"
    },
    {
        "api_name": "_update_carg_indices",
        "full_api_name": "BackwardMatch._update_carg_indices",
        "api_description": "Change clbits indices of the current circuit node in order to\nbe comparable the indices of the template qubits list.\nArgs:\n    carg (list): list of clbits indices from the circuit for a given gate.\nReturns:\n    list: circuit indices update for clbits.",
        "api_signature": "_update_carg_indices(self, carg)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/backward_match.py"
    },
    {
        "api_name": "_is_same_op",
        "full_api_name": "BackwardMatch._is_same_op",
        "api_description": "Check if two instructions are the same.\nArgs:\n    node_circuit (DAGDepNode): node in the circuit.\n    node_template (DAGDepNode): node in the template.\nReturns:\n    bool: True if the same, False otherwise.",
        "api_signature": "_is_same_op(self, node_circuit, node_template)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/backward_match.py"
    },
    {
        "api_name": "_is_same_q_conf",
        "full_api_name": "BackwardMatch._is_same_q_conf",
        "api_description": "Check if the qubits configurations are compatible.\nArgs:\n    node_circuit (DAGDepNode): node in the circuit.\n    node_template (DAGDepNode): node in the template.\n    qarg_circuit (list): qubits configuration for the Instruction in the circuit.\nReturns:\n    bool: True if possible, False otherwise.",
        "api_signature": "_is_same_q_conf(self, node_circuit, node_template, qarg_circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/backward_match.py"
    },
    {
        "api_name": "_is_same_c_conf",
        "full_api_name": "BackwardMatch._is_same_c_conf",
        "api_description": "Check if the clbits configurations are compatible.\nArgs:\n    node_circuit (DAGDepNode): node in the circuit.\n    node_template (DAGDepNode): node in the template.\n    carg_circuit (list): clbits configuration for the Instruction in the circuit.\nReturns:\n    bool: True if possible, False otherwise.",
        "api_signature": "_is_same_c_conf(self, node_circuit, node_template, carg_circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/backward_match.py"
    },
    {
        "api_name": "_init_matched_blocked_list",
        "full_api_name": "BackwardMatch._init_matched_blocked_list",
        "api_description": "Initialize the list of blocked and matchedwith attributes.\nReturns:\n    Tuple[list, list, list, list]:\n    First list contains the attributes matchedwith in the circuit,\n    second list contains the attributes isblocked in the circuit,\n    third list contains the attributes matchedwith in the template,\n    fourth list contains the attributes isblocked in the template.",
        "api_signature": "_init_matched_blocked_list(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/backward_match.py"
    },
    {
        "api_name": "_backward_heuristics",
        "full_api_name": "BackwardMatch._backward_heuristics",
        "api_description": "Heuristics to cut the tree in the backward match algorithm\nArgs:\n    gate_indices (list): list of candidates in the circuit.\n    length (int): depth for cutting the tree, cutting operation is repeated every length.\n    survivor (int): number of survivor branches.",
        "api_signature": "_backward_heuristics(self, gate_indices, length, survivor)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/backward_match.py"
    },
    {
        "api_name": "_backward_metrics",
        "full_api_name": "BackwardMatch._backward_metrics",
        "api_description": "Heuristics to cut the tree in the backward match algorithm.\nArgs:\n    scenario (MatchingScenarios): scenario for the given match.\nReturns:\n    int: length of the match for the given scenario.",
        "api_signature": "_backward_metrics(self, scenario)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/backward_match.py"
    },
    {
        "api_name": "run_backward_match",
        "full_api_name": "BackwardMatch.run_backward_match",
        "api_description": "Apply the forward match algorithm and returns the list of matches given an initial match\nand a circuit qubits configuration.",
        "api_signature": "run_backward_match(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/backward_match.py"
    },
    {
        "api_name": "supported",
        "full_api_name": "CalibrationBuilder.supported",
        "api_description": "Determine if a given node supports the calibration.\n\nArgs:\n    node_op: Target instruction object.\n    qubits: Integer qubit indices to check.\n\nReturns:\n    Return ``True`` is calibration can be provided.",
        "api_signature": "supported(self, node_op, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/calibration/base_builder.py"
    },
    {
        "api_name": "get_calibration",
        "full_api_name": "CalibrationBuilder.get_calibration",
        "api_description": "Gets the calibrated schedule for the given instruction and qubits.\n\nArgs:\n    node_op: Target instruction object.\n    qubits: Integer qubit indices to check.\n\nReturns:\n    Return Schedule of target gate instruction.",
        "api_signature": "get_calibration(self, node_op, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/calibration/base_builder.py"
    },
    {
        "api_name": "run",
        "full_api_name": "CalibrationBuilder.run",
        "api_description": "Run the calibration adder pass on `dag`.\n\nArgs:\n    dag: DAG to schedule.\n\nReturns:\n    A DAG with calibrations added to it.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/calibration/base_builder.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "RXCalibrationBuilder.__init__",
        "api_description": "Bootstrap single-pulse RX gate calibrations from the\n(hardware-calibrated) SX gate calibration.\n\nArgs:\n    target (Target): Should contain a SX calibration that will be\n    used for bootstrapping RX calibrations.",
        "api_signature": "__init__(self, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/calibration/rx_builder.py"
    },
    {
        "api_name": "supported",
        "full_api_name": "RXCalibrationBuilder.supported",
        "api_description": "Check if the calibration for SX gate exists and it's a single DRAG pulse.",
        "api_signature": "supported(self, node_op, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/calibration/rx_builder.py"
    },
    {
        "api_name": "get_calibration",
        "full_api_name": "RXCalibrationBuilder.get_calibration",
        "api_description": "Generate RX calibration for the rotation angle specified in node_op.",
        "api_signature": "get_calibration(self, node_op, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/calibration/rx_builder.py"
    },
    {
        "api_name": "_create_rx_sched",
        "full_api_name": "_create_rx_sched",
        "api_description": "Generates (and caches) pulse calibrations for RX gates.\nAssumes that the rotation angle is in [0, pi].",
        "api_signature": "_create_rx_sched(rx_angle, duration, amp, sigma, beta, channel)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/calibration/rx_builder.py"
    },
    {
        "api_name": "rzx_templates",
        "full_api_name": "rzx_templates",
        "api_description": "Convenience function to get the cost_dict and templates for template matching.\n\nArgs:\n    template_list: List of instruction names.\n\nReturns:\n    Decomposition templates and cost values.",
        "api_signature": "rzx_templates(template_list)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/calibration/rzx_templates.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PulseGates.__init__",
        "api_description": "Create new pass.\n\nArgs:\n    inst_map: Instruction schedule map that user may override.\n    target: The :class:`~.Target` representing the target backend, if both\n        ``inst_map`` and this are specified then it updates instructions\n        in the ``target`` with ``inst_map``.",
        "api_signature": "__init__(self, inst_map, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/calibration/pulse_gate.py"
    },
    {
        "api_name": "supported",
        "full_api_name": "PulseGates.supported",
        "api_description": "Determine if a given node supports the calibration.\n\nArgs:\n    node_op: Target instruction object.\n    qubits: Integer qubit indices to check.\n\nReturns:\n    Return ``True`` is calibration can be provided.",
        "api_signature": "supported(self, node_op, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/calibration/pulse_gate.py"
    },
    {
        "api_name": "get_calibration",
        "full_api_name": "PulseGates.get_calibration",
        "api_description": "Gets the calibrated schedule for the given instruction and qubits.\n\nArgs:\n    node_op: Target instruction object.\n    qubits: Integer qubit indices to check.\n\nReturns:\n    Return Schedule of target gate instruction.\n\nRaises:\n    TranspilerError: When node is parameterized and calibration is raw schedule object.",
        "api_signature": "get_calibration(self, node_op, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/calibration/pulse_gate.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "RZXCalibrationBuilder.__init__",
        "api_description": "Initializes a RZXGate calibration builder.\n\nArgs:\n    instruction_schedule_map: The :obj:`InstructionScheduleMap` object representing the\n        default pulse calibrations for the target backend\n    verbose: Set True to raise a user warning when RZX schedule cannot be built.\n    target: The :class:`~.Target` representing the target backend, if both\n         ``instruction_schedule_map`` and this are specified then this argument will take\n         precedence and ``instruction_schedule_map`` will be ignored.\n\nRaises:\n    QiskitError: Instruction schedule map is not provided.",
        "api_signature": "__init__(self, instruction_schedule_map, verbose, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/calibration/rzx_builder.py"
    },
    {
        "api_name": "supported",
        "full_api_name": "RZXCalibrationBuilder.supported",
        "api_description": "Determine if a given node supports the calibration.\n\nArgs:\n    node_op: Target instruction object.\n    qubits: Integer qubit indices to check.\n\nReturns:\n    Return ``True`` is calibration can be provided.",
        "api_signature": "supported(self, node_op, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/calibration/rzx_builder.py"
    },
    {
        "api_name": "rescale_cr_inst",
        "full_api_name": "RZXCalibrationBuilder.rescale_cr_inst",
        "api_description": "A builder macro to play stretched pulse.\n\nArgs:\n    instruction: The instruction from which to create a new shortened or lengthened pulse.\n    theta: desired angle, pi/2 is assumed to be the angle that the pulse in the given\n        play instruction implements.\n    sample_mult: All pulses must be a multiple of sample_mult.\n\nReturns:\n    Duration of stretched pulse.\n\nRaises:\n    QiskitError: if rotation angle is not assigned.",
        "api_signature": "rescale_cr_inst(instruction, theta, sample_mult)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/calibration/rzx_builder.py"
    },
    {
        "api_name": "get_calibration",
        "full_api_name": "RZXCalibrationBuilder.get_calibration",
        "api_description": "Builds the calibration schedule for the RZXGate(theta) with echos.\n\nArgs:\n    node_op: Instruction of the RZXGate(theta). I.e. params[0] is theta.\n    qubits: List of qubits for which to get the schedules. The first qubit is\n        the control and the second is the target.\n\nReturns:\n    schedule: The calibration schedule for the RZXGate(theta).\n\nRaises:\n    QiskitError: if rotation angle is not assigned.\n    QiskitError: If the control and target qubits cannot be identified.\n    CalibrationNotAvailable: RZX schedule cannot be built for input node.",
        "api_signature": "get_calibration(self, node_op, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/calibration/rzx_builder.py"
    },
    {
        "api_name": "get_calibration",
        "full_api_name": "RZXCalibrationBuilderNoEcho.get_calibration",
        "api_description": "Builds the calibration schedule for the RZXGate(theta) without echos.\n\nArgs:\n    node_op: Instruction of the RZXGate(theta). I.e. params[0] is theta.\n    qubits: List of qubits for which to get the schedules. The first qubit is\n        the control and the second is the target.\n\nReturns:\n    schedule: The calibration schedule for the RZXGate(theta).\n\nRaises:\n    QiskitError: if rotation angle is not assigned.\n    QiskitError: If the control and target qubits cannot be identified,\n        or the backend does not natively support the specified direction of the cx.\n    CalibrationNotAvailable: RZX schedule cannot be built for input node.",
        "api_signature": "get_calibration(self, node_op, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/calibration/rzx_builder.py"
    },
    {
        "api_name": "_filter_cr_tone",
        "full_api_name": "_filter_cr_tone",
        "api_description": "A helper function to filter pulses on control channels.",
        "api_signature": "_filter_cr_tone(time_inst_tup)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/calibration/rzx_builder.py"
    },
    {
        "api_name": "_filter_comp_tone",
        "full_api_name": "_filter_comp_tone",
        "api_description": "A helper function to filter pulses on drive channels.",
        "api_signature": "_filter_comp_tone(time_inst_tup)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/calibration/rzx_builder.py"
    },
    {
        "api_name": "_check_calibration_type",
        "full_api_name": "_check_calibration_type",
        "api_description": "A helper function to check type of CR calibration.\n\nArgs:\n    inst_sched_map: instruction schedule map of the backends\n    qubits: ordered tuple of qubits for cross resonance (q_control, q_target)\n\nReturns:\n    Filtered instructions and most-likely type of calibration.\n\nRaises:\n    QiskitError: Unknown calibration type is detected.",
        "api_signature": "_check_calibration_type(inst_sched_map, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/calibration/rzx_builder.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "LookaheadSwap.__init__",
        "api_description": "LookaheadSwap initializer.\n\nArgs:\n    coupling_map (Union[CouplingMap, Target]): CouplingMap of the target backend.\n    search_depth (int): lookahead tree depth when ranking best SWAP options.\n    search_width (int): lookahead tree width when ranking best SWAP options.\n    fake_run (bool): if true, it only pretend to do routing, i.e., no\n        swap is effectively added.",
        "api_signature": "__init__(self, coupling_map, search_depth, search_width, fake_run)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/lookahead_swap.py"
    },
    {
        "api_name": "run",
        "full_api_name": "LookaheadSwap.run",
        "api_description": "Run the LookaheadSwap pass on `dag`.\n\nArgs:\n    dag (DAGCircuit): the directed acyclic graph to be mapped\nReturns:\n    DAGCircuit: A dag mapped to be compatible with the coupling_map in\n        the property_set.\nRaises:\n    TranspilerError: if the coupling map or the layout are not\n    compatible with the DAG, or if the coupling_map=None",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/lookahead_swap.py"
    },
    {
        "api_name": "_search_forward_n_swaps",
        "full_api_name": "_search_forward_n_swaps",
        "api_description": "Search for SWAPs which allow for application of largest number of gates.\n\nArgs:\n    state (_SystemState): The ``namedtuple`` collection containing the state of the physical\n        system.  This includes the current layout, the coupling map, the canonical register and\n        the possible swaps available.\n    gates (list): Gates to be mapped.\n    depth (int): Number of SWAP layers to search before choosing a result.\n    width (int): Number of SWAPs to consider at each layer.\nReturns:\n    Optional(_Step): Describes the solution step found.  If ``None``, no swaps leading to an\n    improvement were found.",
        "api_signature": "_search_forward_n_swaps(state, gates, depth, width)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/lookahead_swap.py"
    },
    {
        "api_name": "_map_free_gates",
        "full_api_name": "_map_free_gates",
        "api_description": "Map all gates that can be executed with the current layout.\n\nArgs:\n    state (_SystemState): The physical characteristics of the system, including its current\n        layout and the coupling map.\n    gates (list): Gates to be mapped.\n\nReturns:\n    tuple:\n        mapped_gates (list): ops for gates that can be executed, mapped onto layout.\n        remaining_gates (list): gates that cannot be executed on the layout.",
        "api_signature": "_map_free_gates(state, gates)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/lookahead_swap.py"
    },
    {
        "api_name": "_calc_layout_distance",
        "full_api_name": "_calc_layout_distance",
        "api_description": "Return the sum of the distances of two-qubit pairs in each CNOT in gates\naccording to the layout and the coupling.",
        "api_signature": "_calc_layout_distance(gates, state, max_gates)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/lookahead_swap.py"
    },
    {
        "api_name": "_score_state_with_swap",
        "full_api_name": "_score_state_with_swap",
        "api_description": "Calculate the relative score for a given SWAP.\n\nReturns:\n    float: the score of the given swap.\n    Tuple[int, int]: the input swap that should be performed.\n    _SystemState: an updated system state with the new layout contained.",
        "api_signature": "_score_state_with_swap(swap, state, gates)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/lookahead_swap.py"
    },
    {
        "api_name": "_score_step",
        "full_api_name": "_score_step",
        "api_description": "Count the mapped two-qubit gates, less the number of added SWAPs.",
        "api_signature": "_score_step(step)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/lookahead_swap.py"
    },
    {
        "api_name": "_transform_gate_for_system",
        "full_api_name": "_transform_gate_for_system",
        "api_description": "Return op implementing a virtual gate on given layout.",
        "api_signature": "_transform_gate_for_system(gate, state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/lookahead_swap.py"
    },
    {
        "api_name": "_swap_ops_from_edge",
        "full_api_name": "_swap_ops_from_edge",
        "api_description": "Generate list of ops to implement a SWAP gate along a coupling edge.",
        "api_signature": "_swap_ops_from_edge(edge, state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/lookahead_swap.py"
    },
    {
        "api_name": "_first_op_node",
        "full_api_name": "_first_op_node",
        "api_description": "Get the first op node from a DAG.",
        "api_signature": "_first_op_node(dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/lookahead_swap.py"
    },
    {
        "api_name": "get_swap_map_dag",
        "full_api_name": "get_swap_map_dag",
        "api_description": "Get the circuit of swaps to go from from_layout to to_layout, and the physical qubits\n(integers) that the swap circuit should be applied on.",
        "api_signature": "get_swap_map_dag(dag, coupling_map, from_layout, to_layout, seed, trials)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/utils.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SabreSwap.__init__",
        "api_description": "SabreSwap initializer.\n\nArgs:\n    coupling_map (Union[CouplingMap, Target]): CouplingMap of the target backend.\n    heuristic (str): The type of heuristic to use when deciding best\n        swap strategy ('basic' or 'lookahead' or 'decay').\n    seed (int): random seed used to tie-break among candidate swaps.\n    fake_run (bool): if true, it only pretend to do routing, i.e., no\n        swap is effectively added.\n    trials (int): The number of seed trials to run sabre with. These will\n        be run in parallel (unless the PassManager is already running in\n        parallel). If not specified this defaults to the number of physical\n        CPUs on the local system. For reproducible results it is recommended\n        that you set this explicitly, as the output will be deterministic for\n        a fixed number of trials.\n\nRaises:\n    TranspilerError: If the specified heuristic is not valid.\n\nAdditional Information:\n\n    The search space of possible SWAPs on physical qubits is explored\n    by assigning a score to the layout that would result from each SWAP.\n    The goodness of a layout is evaluated based on how viable it makes\n    the remaining virtual gates that must be applied. A few heuristic\n    cost functions are supported\n\n    - 'basic':\n\n    The sum of distances for corresponding physical qubits of\n    interacting virtual qubits in the front_layer.\n\n    .. math::\n\n        H_{basic} = \\sum_{gate \\in F} D[\\pi(gate.q_1)][\\pi(gate.q2)]\n\n    - 'lookahead':\n\n    This is the sum of two costs: first is the same as the basic cost.\n    Second is the basic cost but now evaluated for the\n    extended set as well (i.e. :math:`|E|` number of upcoming successors to gates in\n    front_layer F). This is weighted by some amount EXTENDED_SET_WEIGHT (W) to\n    signify that upcoming gates are less important that the front_layer.\n\n    .. math::\n\n        H_{decay}=\\frac{1}{\\left|{F}\\right|}\\sum_{gate \\in F} D[\\pi(gate.q_1)][\\pi(gate.q2)]\n            + W*\\frac{1}{\\left|{E}\\right|} \\sum_{gate \\in E} D[\\pi(gate.q_1)][\\pi(gate.q2)]\n\n    - 'decay':\n\n    This is the same as 'lookahead', but the whole cost is multiplied by a\n    decay factor. This increases the cost if the SWAP that generated the\n    trial layout was recently used (i.e. it penalizes increase in depth).\n\n    .. math::\n\n        H_{decay} = max(decay(SWAP.q_1), decay(SWAP.q_2)) {\n            \\frac{1}{\\left|{F}\\right|} \\sum_{gate \\in F} D[\\pi(gate.q_1)][\\pi(gate.q2)]\\\\\n            + W *\\frac{1}{\\left|{E}\\right|} \\sum_{gate \\in E} D[\\pi(gate.q_1)][\\pi(gate.q2)]\n            }",
        "api_signature": "__init__(self, coupling_map, heuristic, seed, fake_run, trials)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/sabre_swap.py"
    },
    {
        "api_name": "run",
        "full_api_name": "SabreSwap.run",
        "api_description": "Run the SabreSwap pass on `dag`.\n\nArgs:\n    dag (DAGCircuit): the directed acyclic graph to be mapped.\nReturns:\n    DAGCircuit: A dag mapped to be compatible with the coupling_map.\nRaises:\n    TranspilerError: if the coupling map or the layout are not\n    compatible with the DAG, or if the coupling_map=None",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/sabre_swap.py"
    },
    {
        "api_name": "_build_sabre_dag",
        "full_api_name": "_build_sabre_dag",
        "api_description": "",
        "api_signature": "_build_sabre_dag(dag, num_physical_qubits, qubit_indices)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/sabre_swap.py"
    },
    {
        "api_name": "recurse",
        "full_api_name": "recurse",
        "api_description": "",
        "api_signature": "recurse(block, block_qubit_indices)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/sabre_swap.py"
    },
    {
        "api_name": "process_dag",
        "full_api_name": "process_dag",
        "api_description": "",
        "api_signature": "process_dag(block_dag, wire_map)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/sabre_swap.py"
    },
    {
        "api_name": "_apply_sabre_result",
        "full_api_name": "_apply_sabre_result",
        "api_description": "Apply the ``SabreResult`` to ``out_dag``, mutating it in place.  This function in effect\nperforms the :class:`.ApplyLayout` transpiler pass with ``initial_layout`` and the Sabre routing\nsimultaneously, though it assumes that ``out_dag`` has already been prepared as containing the\nright physical qubits.\n\nMutates ``out_dag`` in place and returns it.  Mutates ``initial_layout`` in place as scratch\nspace.\n\nArgs:\n    out_dag (DAGCircuit): the physical DAG that the output should be written to.\n    in_dag (DAGCircuit): the source of the nodes that are being routed.\n    sabre_result (tuple[SwapMap, Sequence[int], NodeBlockResults]): the result object from the\n        Rust run of the Sabre routing algorithm.\n    initial_layout (NLayout): a Rust-space mapping of virtual indices (i.e. those of the qubits\n        in ``in_dag``) to physical ones.\n    physical_qubits (list[Qubit]): an indexable sequence of :class:`.Qubit` objects representing\n        the physical qubits of the circuit.  Note that disjoint-coupling handling can mean that\n        these are not strictly a \"canonical physical register\" in order.\n    circuit_to_dag_dict (Mapping[int, DAGCircuit]): a mapping of the Python object identity\n        (as returned by :func:`id`) of a control-flow block :class:`.QuantumCircuit` to a\n        :class:`.DAGCircuit` that represents the same thing.",
        "api_signature": "_apply_sabre_result(out_dag, in_dag, sabre_result, initial_layout, physical_qubits, circuit_to_dag_dict)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/sabre_swap.py"
    },
    {
        "api_name": "empty_dag",
        "full_api_name": "empty_dag",
        "api_description": "",
        "api_signature": "empty_dag(block)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/sabre_swap.py"
    },
    {
        "api_name": "apply_swaps",
        "full_api_name": "apply_swaps",
        "api_description": "",
        "api_signature": "apply_swaps(dest_dag, swaps, layout)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/sabre_swap.py"
    },
    {
        "api_name": "recurse",
        "full_api_name": "recurse",
        "api_description": "The main recursive worker.  Mutates ``dest_dag`` and ``layout`` and returns them.\n\n``root_virtual_map`` is a mapping of the (virtual) qubit in ``source_dag`` to the index of\nthe virtual qubit in the root source DAG that it is bound to.",
        "api_signature": "recurse(dest_dag, source_dag, result, root_logical_map, layout)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/sabre_swap.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "LayoutTransformation.__init__",
        "api_description": "LayoutTransformation initializer.\n\nArgs:\n    coupling_map:\n        Directed graph representing a coupling map.\n\n    from_layout (Union[Layout, str]):\n        The starting layout of qubits onto physical qubits.\n        If the type is str, look up `property_set` when this pass runs.\n\n    to_layout (Union[Layout, str]):\n        The final layout of qubits on physical qubits.\n        If the type is str, look up `property_set` when this pass runs.\n\n    seed (Union[int, np.random.default_rng]):\n        Seed to use for random trials.\n\n    trials (int):\n        How many randomized trials to perform, taking the best circuit as output.",
        "api_signature": "__init__(self, coupling_map, from_layout, to_layout, seed, trials)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/layout_transformation.py"
    },
    {
        "api_name": "run",
        "full_api_name": "LayoutTransformation.run",
        "api_description": "Apply the specified partial permutation to the circuit.\n\nArgs:\n    dag (DAGCircuit): DAG to transform the layout of.\n\nReturns:\n    DAGCircuit: The DAG with transformed layout.\n\nRaises:\n    TranspilerError: if the coupling map or the layout are not compatible with the DAG.\n        Or if either of string from/to_layout is not found in `property_set`.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/layout_transformation.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BasicSwap.__init__",
        "api_description": "BasicSwap initializer.\n\nArgs:\n    coupling_map (Union[CouplingMap, Target]): Directed graph represented a coupling map.\n    fake_run (bool): if true, it only pretend to do routing, i.e., no\n        swap is effectively added.",
        "api_signature": "__init__(self, coupling_map, fake_run)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/basic_swap.py"
    },
    {
        "api_name": "run",
        "full_api_name": "BasicSwap.run",
        "api_description": "Run the BasicSwap pass on `dag`.\n\nArgs:\n    dag (DAGCircuit): DAG to map.\n\nReturns:\n    DAGCircuit: A mapped DAG.\n\nRaises:\n    TranspilerError: if the coupling map or the layout are not\n    compatible with the DAG, or if the coupling_map=None.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/basic_swap.py"
    },
    {
        "api_name": "_fake_run",
        "full_api_name": "BasicSwap._fake_run",
        "api_description": "Do a fake run the BasicSwap pass on `dag`.\n\nArgs:\n    dag (DAGCircuit): DAG to improve initial layout.\n\nReturns:\n    DAGCircuit: The same DAG.\n\nRaises:\n    TranspilerError: if the coupling map or the layout are not\n    compatible with the DAG.",
        "api_signature": "_fake_run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/basic_swap.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "StochasticSwap.__init__",
        "api_description": "StochasticSwap initializer.\n\nThe coupling map is a connected graph\n\nIf these are not satisfied, the behavior is undefined.\n\nArgs:\n    coupling_map (Union[CouplingMap, Target]): Directed graph representing a coupling\n        map.\n    trials (int): maximum number of iterations to attempt\n    seed (int): seed for random number generator\n    fake_run (bool): if true, it only pretend to do routing, i.e., no\n        swap is effectively added.\n    initial_layout (Layout): starting layout at beginning of pass.",
        "api_signature": "__init__(self, coupling_map, trials, seed, fake_run, initial_layout)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/stochastic_swap.py"
    },
    {
        "api_name": "run",
        "full_api_name": "StochasticSwap.run",
        "api_description": "Run the StochasticSwap pass on `dag`.\n\nArgs:\n    dag (DAGCircuit): DAG to map.\n\nReturns:\n    DAGCircuit: A mapped DAG.\n\nRaises:\n    TranspilerError: if the coupling map or the layout are not\n    compatible with the DAG, or if the coupling_map=None",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/stochastic_swap.py"
    },
    {
        "api_name": "_layer_permutation",
        "full_api_name": "StochasticSwap._layer_permutation",
        "api_description": "Find a swap circuit that implements a permutation for this layer.\n\nThe goal is to swap qubits such that qubits in the same two-qubit gates\nare adjacent.\n\nBased on S. Bravyi's algorithm.\n\nArgs:\n    layer_partition (list): The layer_partition is a list of (qu)bit\n        lists and each qubit is a tuple (qreg, index).\n    layout (Layout): The layout is a Layout object mapping virtual\n        qubits in the input circuit to physical qubits in the coupling\n        graph. It reflects the current positions of the data.\n    qubit_subset (list): The qubit_subset is the set of qubits in\n        the coupling graph that we have chosen to map into, as tuples\n        (Register, index).\n    coupling (CouplingMap): Directed graph representing a coupling map.\n        This coupling map should be one that was provided to the\n        stochastic mapper.\n    trials (int): Number of attempts the randomized algorithm makes.\n\nReturns:\n    Tuple: success_flag, best_circuit, best_depth, best_layout\n\nIf success_flag is True, then best_circuit contains a DAGCircuit with\nthe swap circuit, best_depth contains the depth of the swap circuit,\nand best_layout contains the new positions of the data qubits after the\nswap circuit has been applied.\n\nRaises:\n    TranspilerError: if anything went wrong.",
        "api_signature": "_layer_permutation(self, dag, layer_partition, layout, qubit_subset, coupling, trials)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/stochastic_swap.py"
    },
    {
        "api_name": "_layer_update",
        "full_api_name": "StochasticSwap._layer_update",
        "api_description": "Add swaps followed by the now mapped layer from the original circuit.\n\nArgs:\n    dag (DAGCircuit): The DAGCircuit object that the _mapper method is building\n    layer (DAGCircuit): A DAGCircuit layer from the original circuit\n    best_layout (Layout): layout returned from _layer_permutation\n    best_depth (int): depth returned from _layer_permutation\n    best_circuit (DAGCircuit): swap circuit returned from _layer_permutation",
        "api_signature": "_layer_update(self, dag, layer, best_layout, best_depth, best_circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/stochastic_swap.py"
    },
    {
        "api_name": "_mapper",
        "full_api_name": "StochasticSwap._mapper",
        "api_description": "Map a DAGCircuit onto a CouplingMap using swap gates.\n\nArgs:\n    circuit_graph (DAGCircuit): input DAG circuit\n    coupling_graph (CouplingMap): coupling graph to map onto\n    trials (int): number of trials.\n\nReturns:\n    DAGCircuit: object containing a circuit equivalent to\n        circuit_graph that respects couplings in coupling_graph\n\nRaises:\n    TranspilerError: if there was any error during the mapping\n        or with the parameters.",
        "api_signature": "_mapper(self, circuit_graph, coupling_graph, trials)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/stochastic_swap.py"
    },
    {
        "api_name": "_controlflow_layer_update",
        "full_api_name": "StochasticSwap._controlflow_layer_update",
        "api_description": "Updates the new dagcircuit with a routed control flow operation.\n\nArgs:\n   dagcircuit_output (DAGCircuit): dagcircuit that is being built with routed operations.\n   layer_dag (DAGCircuit): layer to route containing a single controlflow operation.\n   current_layout (Layout): current layout coming into this layer.\n   root_dag (DAGCircuit): root dag of pass\n\nReturns:\n   Layout: updated layout after this layer has been routed.\n\nRaises:\n    TranspilerError: if layer_dag does not contain a recognized ControlFlowOp.",
        "api_signature": "_controlflow_layer_update(self, dagcircuit_output, layer_dag, current_layout, root_dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/stochastic_swap.py"
    },
    {
        "api_name": "_new_seed",
        "full_api_name": "StochasticSwap._new_seed",
        "api_description": "Get a seed for a new RNG instance.",
        "api_signature": "_new_seed(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/stochastic_swap.py"
    },
    {
        "api_name": "_recursive_pass",
        "full_api_name": "StochasticSwap._recursive_pass",
        "api_description": "Get a new instance of this class to handle a recursive call for a control-flow block.\n\nEach pass starts with its own new seed, determined deterministically from our own.",
        "api_signature": "_recursive_pass(self, initial_layout)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/stochastic_swap.py"
    },
    {
        "api_name": "_controlflow_exhaustive_acyclic",
        "full_api_name": "_controlflow_exhaustive_acyclic",
        "api_description": "Return True if the entire control-flow operation represents a block that is guaranteed to be\nentered, and does not cycle back to the initial layout.",
        "api_signature": "_controlflow_exhaustive_acyclic(operation)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/stochastic_swap.py"
    },
    {
        "api_name": "_dag_from_block",
        "full_api_name": "_dag_from_block",
        "api_description": "Get a :class:`DAGCircuit` that represents the :class:`.QuantumCircuit` ``block`` embedded\nwithin the ``root_dag`` for full-width routing purposes.  This means that all the qubits are in\nthe output DAG, but only the necessary clbits and classical registers are.",
        "api_signature": "_dag_from_block(block, node, root_dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/stochastic_swap.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Commuting2qGateRouter.__init__",
        "api_description": "Args:\n    swap_strategy: An instance of a :class:`.SwapStrategy` that holds the swap layers\n        that are used, and the order in which to apply them, to map the instruction to\n        the hardware. If this field is not given if should be contained in the\n        property set of the pass. This allows other passes to determine the most\n        appropriate swap strategy at run-time.\n    edge_coloring: An optional edge coloring of the coupling map (I.e. no two edges that\n        share a node have the same color). If the edge coloring is given then the commuting\n        gates that can be simultaneously applied given the current qubit permutation are\n        grouped according to the edge coloring and applied according to this edge\n        coloring. Here, a color is an int which is used as the index to define and\n        access the groups of commuting gates that can be applied simultaneously.\n        If the edge coloring is not given then the sets will be built-up using a\n        greedy algorithm. The edge coloring is useful to position gates such as\n        ``RZZGate``\\s next to swap gates to exploit CX cancellations.",
        "api_signature": "__init__(self, swap_strategy, edge_coloring)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/commuting_2q_gate_routing/commuting_2q_gate_router.py"
    },
    {
        "api_name": "run",
        "full_api_name": "Commuting2qGateRouter.run",
        "api_description": "Run the pass by decomposing the nodes it applies on.\n\nArgs:\n    dag: The dag to which we will add swaps.\n\nReturns:\n    A dag where swaps have been added for the intended gate type.\n\nRaises:\n    TranspilerError: If the swap strategy was not given at init time and there is\n        no swap strategy in the property set.\n    TranspilerError: If the quantum circuit contains more than one qubit register.\n    TranspilerError: If there are qubits that are not contained in the quantum register.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/commuting_2q_gate_routing/commuting_2q_gate_router.py"
    },
    {
        "api_name": "_compose_non_swap_nodes",
        "full_api_name": "Commuting2qGateRouter._compose_non_swap_nodes",
        "api_description": "Add all the non-swap strategy nodes that we have accumulated up to now.\n\nThis method also resets the node accumulator to an empty dag.\n\nArgs:\n    layout: The current layout that keeps track of the swaps.\n    new_dag: The new dag that we are building up.\n    accumulator: A DAG to keep track of nodes that do not decompose\n        using swap strategies.\n\nReturns:\n    A new accumulator with the same registers as ``new_dag``.",
        "api_signature": "_compose_non_swap_nodes(self, accumulator, layout, new_dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/commuting_2q_gate_routing/commuting_2q_gate_router.py"
    },
    {
        "api_name": "_position_in_cmap",
        "full_api_name": "Commuting2qGateRouter._position_in_cmap",
        "api_description": "A helper function to track the movement of virtual qubits through the swaps.\n\nArgs:\n    j: The index of decision variable j (i.e. virtual qubit).\n    k: The index of decision variable k (i.e. virtual qubit).\n    layout: The current layout that takes into account previous swap gates.\n\nReturns:\n    The position in the coupling map of the virtual qubits j and k as a tuple.",
        "api_signature": "_position_in_cmap(self, dag, j, k, layout)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/commuting_2q_gate_routing/commuting_2q_gate_router.py"
    },
    {
        "api_name": "_build_sub_layers",
        "full_api_name": "Commuting2qGateRouter._build_sub_layers",
        "api_description": "A helper method to build-up sets of gates to simultaneously apply.\n\nThis is done with an edge coloring if the ``edge_coloring`` init argument was given or with\na greedy algorithm if not. With an edge coloring all gates on edges with the same color\nwill be applied simultaneously. These sublayers are applied in the order of their color,\nwhich is an int, in increasing color order.\n\nArgs:\n    current_layer: All gates in the current layer can be applied given the qubit ordering\n        of the current layout. However, not all gates in the current layer can be applied\n        simultaneously. This function creates sub-layers by building up sub-layers\n        of gates. All gates in a sub-layer can simultaneously be applied given the coupling\n        map and current qubit configuration.\n\nReturns:\n     A list of gate dicts that can be applied. The gates a position 0 are applied first.\n     A gate dict has the qubit tuple as key and the gate to apply as value.",
        "api_signature": "_build_sub_layers(self, current_layer)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/commuting_2q_gate_routing/commuting_2q_gate_router.py"
    },
    {
        "api_name": "_edge_coloring_build_sub_layers",
        "full_api_name": "Commuting2qGateRouter._edge_coloring_build_sub_layers",
        "api_description": "The edge coloring method of building sub-layers of commuting gates.",
        "api_signature": "_edge_coloring_build_sub_layers(self, current_layer)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/commuting_2q_gate_routing/commuting_2q_gate_router.py"
    },
    {
        "api_name": "_greedy_build_sub_layers",
        "full_api_name": "Commuting2qGateRouter._greedy_build_sub_layers",
        "api_description": "The greedy method of building sub-layers of commuting gates.",
        "api_signature": "_greedy_build_sub_layers(current_layer)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/commuting_2q_gate_routing/commuting_2q_gate_router.py"
    },
    {
        "api_name": "swap_decompose",
        "full_api_name": "Commuting2qGateRouter.swap_decompose",
        "api_description": "Take an instance of :class:`.Commuting2qBlock` and map it to the coupling map.\n\nThe mapping is done with the swap strategy.\n\nArgs:\n    dag: The dag which contains the :class:`.Commuting2qBlock` we route.\n    node: A node whose operation is a :class:`.Commuting2qBlock`.\n    current_layout: The layout before the swaps are applied. This function will\n        modify the layout so that subsequent gates can be properly composed on the dag.\n    swap_strategy: The swap strategy used to decompose the node.\n\nReturns:\n    A dag that is compatible with the coupling map where swap gates have been added\n    to map the gates in the :class:`.Commuting2qBlock` to the hardware.",
        "api_signature": "swap_decompose(self, dag, node, current_layout, swap_strategy)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/commuting_2q_gate_routing/commuting_2q_gate_router.py"
    },
    {
        "api_name": "_make_op_layers",
        "full_api_name": "Commuting2qGateRouter._make_op_layers",
        "api_description": "Creates layers of two-qubit gates based on the distance in the swap strategy.",
        "api_signature": "_make_op_layers(self, dag, op, layout, swap_strategy)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/commuting_2q_gate_routing/commuting_2q_gate_router.py"
    },
    {
        "api_name": "_check_edges",
        "full_api_name": "Commuting2qGateRouter._check_edges",
        "api_description": "Check if the swap strategy can create the required connectivity.\n\nArgs:\n    node: The dag node for which to check if the swap strategy provides enough connectivity.\n    swap_strategy: The swap strategy that is being used.\n\nRaises:\n    TranspilerError: If there is an edge that the swap strategy cannot accommodate\n        and if the pass has been configured to raise on such issues.",
        "api_signature": "_check_edges(self, dag, node, swap_strategy)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/commuting_2q_gate_routing/commuting_2q_gate_router.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Commuting2qBlock.__init__",
        "api_description": "Args:\n    node_block: A block of nodes that commute.\n\nRaises:\n    QiskitError: If the nodes in the node block do not apply to two-qubits.",
        "api_signature": "__init__(self, node_block)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/commuting_2q_gate_routing/commuting_2q_block.py"
    },
    {
        "api_name": "__iter__",
        "full_api_name": "Commuting2qBlock.__iter__",
        "api_description": "Iterate through the nodes in the block.",
        "api_signature": "__iter__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/commuting_2q_gate_routing/commuting_2q_block.py"
    },
    {
        "api_name": "run",
        "full_api_name": "FindCommutingPauliEvolutions.run",
        "api_description": "Check for :class:`.PauliEvolutionGate`s where the summands all commute.\n\nArgs:\n    The DAG circuit in which to look for the commuting evolutions.\n\nReturns:\n    The dag in which :class:`.PauliEvolutionGate`s made of commuting two-qubit Paulis\n    have been replaced with :class:`.Commuting2qBlocks`` gate instructions. These gates\n    contain nodes of two-qubit :class:`.PauliEvolutionGate`s.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/commuting_2q_gate_routing/pauli_2q_evolution_commutation.py"
    },
    {
        "api_name": "single_qubit_terms_only",
        "full_api_name": "FindCommutingPauliEvolutions.single_qubit_terms_only",
        "api_description": "Determine if the Paulis are made of single qubit terms only.\n\nArgs:\n    operator: The operator to check if it consists only of single qubit terms.\n\nReturns:\n    True if the operator consists of only single qubit terms (like ``IIX + IZI``),\n    and False otherwise.",
        "api_signature": "single_qubit_terms_only(operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/commuting_2q_gate_routing/pauli_2q_evolution_commutation.py"
    },
    {
        "api_name": "summands_commute",
        "full_api_name": "FindCommutingPauliEvolutions.summands_commute",
        "api_description": "Check if all summands in the evolved operator commute.\n\nArgs:\n    operator: The operator to check if all its summands commute.\n\nReturns:\n    True if all summands commute, False otherwise.",
        "api_signature": "summands_commute(operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/commuting_2q_gate_routing/pauli_2q_evolution_commutation.py"
    },
    {
        "api_name": "_pauli_to_edge",
        "full_api_name": "FindCommutingPauliEvolutions._pauli_to_edge",
        "api_description": "Convert a pauli to an edge.\n\nArgs:\n    pauli: A pauli that is converted to a string to find out where non-identity\n        Paulis are.\n\nReturns:\n    A tuple representing where the Paulis are. For example, the Pauli \"IZIZ\" will\n    return (0, 2) since virtual qubits 0 and 2 interact.\n\nRaises:\n    QiskitError: If the pauli does not exactly have two non-identity terms.",
        "api_signature": "_pauli_to_edge(pauli)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/commuting_2q_gate_routing/pauli_2q_evolution_commutation.py"
    },
    {
        "api_name": "_decompose_to_2q",
        "full_api_name": "FindCommutingPauliEvolutions._decompose_to_2q",
        "api_description": "Decompose the PauliSumOp into two-qubit.\n\nArgs:\n    dag: The dag needed to get access to qubits.\n    op: The operator with all the Pauli terms we need to apply.\n\nReturns:\n    A dag made of two-qubit :class:`.PauliEvolutionGate`.",
        "api_signature": "_decompose_to_2q(self, dag, op)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/commuting_2q_gate_routing/pauli_2q_evolution_commutation.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SwapStrategy.__init__",
        "api_description": "Args:\n    coupling_map: The coupling map the strategy is implemented for.\n    swap_layers: The swap layers of the strategy, specified as tuple of swap layers.\n        Each swap layer is a tuple of edges to which swaps are applied simultaneously.\n        Each swap is specified as an edge which is a tuple of two integers.\n\nRaises:\n    QiskitError: If the coupling map is not specified.\n    QiskitError: if the swap strategy is not valid. A swap strategy is valid if all\n        swap gates, specified as tuples, are contained in the edge set of the coupling map.\n        A swap strategy is also invalid if a layer has multiple swaps on the same qubit.",
        "api_signature": "__init__(self, coupling_map, swap_layers)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/commuting_2q_gate_routing/swap_strategy.py"
    },
    {
        "api_name": "from_line",
        "full_api_name": "SwapStrategy.from_line",
        "api_description": "Creates a swap strategy for a line graph with the specified number of SWAP layers.\n\nThis SWAP strategy will use the full line if instructed to do so (i.e. num_variables\nis None or equal to num_vertices). If instructed otherwise then the first num_variables\nnodes of the line will be used in the swap strategy.\n\nArgs:\n    line: A line given as a list of nodes, e.g. ``[0, 2, 3, 4]``.\n    num_swap_layers: Number of swap layers the swap manager should be initialized with.\n\nReturns:\n    A swap strategy that reaches full connectivity on a linear coupling map.\n\nRaises:\n    ValueError: If the ``num_swap_layers`` is negative.\n    ValueError: If the ``line`` has less than 2 elements and no swap strategy can be applied.",
        "api_signature": "from_line(cls, line, num_swap_layers)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/commuting_2q_gate_routing/swap_strategy.py"
    },
    {
        "api_name": "__len__",
        "full_api_name": "SwapStrategy.__len__",
        "api_description": "Return the length of the strategy as the number of layers.\n\nReturns:\n    The number of layers of the swap strategy.",
        "api_signature": "__len__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/commuting_2q_gate_routing/swap_strategy.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "SwapStrategy.__repr__",
        "api_description": "Representation of the swap strategy.\n\nReturns:\n    The representation of the swap strategy.",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/commuting_2q_gate_routing/swap_strategy.py"
    },
    {
        "api_name": "swap_layer",
        "full_api_name": "SwapStrategy.swap_layer",
        "api_description": "Return the layer of swaps at the given index.\n\nArgs:\n    idx: The index of the returned swap layer.\n\nReturns:\n    A copy of the swap layer at ``idx`` to avoid any unintentional modification to\n    the swap strategy.",
        "api_signature": "swap_layer(self, idx)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/commuting_2q_gate_routing/swap_strategy.py"
    },
    {
        "api_name": "distance_matrix",
        "full_api_name": "SwapStrategy.distance_matrix",
        "api_description": "A matrix describing when qubits become adjacent in the swap strategy.\n\nReturns:\n    The distance matrix for the SWAP strategy as an array that cannot be written to. Here,\n    the entry (i, j) corresponds to the number of SWAP layers that need to be applied to\n    obtain a connection between physical qubits i and j.",
        "api_signature": "distance_matrix(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/commuting_2q_gate_routing/swap_strategy.py"
    },
    {
        "api_name": "new_connections",
        "full_api_name": "SwapStrategy.new_connections",
        "api_description": "Returns the new connections obtained after applying the SWAP layer specified by idx, i.e.\na list of qubit pairs that are adjacent to one another after idx steps of the SWAP strategy.\n\nArgs:\n    idx: The index of the SWAP layer. 1 refers to the first SWAP layer whereas an ``idx``\n        of 0 will return the connections present in the original coupling map.\n\nReturns:\n    A list of edges representing the new qubit connections.",
        "api_signature": "new_connections(self, idx)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/commuting_2q_gate_routing/swap_strategy.py"
    },
    {
        "api_name": "_build_edges",
        "full_api_name": "SwapStrategy._build_edges",
        "api_description": "Build the possible edges that the swap strategy accommodates.",
        "api_signature": "_build_edges(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/commuting_2q_gate_routing/swap_strategy.py"
    },
    {
        "api_name": "possible_edges",
        "full_api_name": "SwapStrategy.possible_edges",
        "api_description": "Return the qubit connections that can be generated.\n\nReturns:\n    The qubit connections that can be accommodated by the swap strategy.",
        "api_signature": "possible_edges(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/commuting_2q_gate_routing/swap_strategy.py"
    },
    {
        "api_name": "missing_couplings",
        "full_api_name": "SwapStrategy.missing_couplings",
        "api_description": "Return the set of couplings that cannot be reached.\n\nReturns:\n    The couplings that cannot be reached as a set of Tuples of int. Here,\n    each int corresponds to a qubit in the coupling map.",
        "api_signature": "missing_couplings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/commuting_2q_gate_routing/swap_strategy.py"
    },
    {
        "api_name": "swapped_coupling_map",
        "full_api_name": "SwapStrategy.swapped_coupling_map",
        "api_description": "Returns the coupling map after applying ``idx`` swap layers of strategy.\n\nArgs:\n    idx: The number of swap layers to apply. For idx = 0, the original coupling\n        map is returned.\n\nReturns:\n    The swapped coupling map.",
        "api_signature": "swapped_coupling_map(self, idx)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/commuting_2q_gate_routing/swap_strategy.py"
    },
    {
        "api_name": "apply_swap_layer",
        "full_api_name": "SwapStrategy.apply_swap_layer",
        "api_description": "Permute the elements of ``list_to_swap`` based on layer indexed by ``idx``.\n\nArgs:\n    list_to_swap: The list of elements to swap.\n    idx: The index of the swap layer to apply.\n    inplace: A boolean which if set to True will modify the list inplace. By default\n        this value is False.\n\nReturns:\n    The list with swapped elements",
        "api_signature": "apply_swap_layer(self, list_to_swap, idx, inplace)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/commuting_2q_gate_routing/swap_strategy.py"
    },
    {
        "api_name": "inverse_composed_permutation",
        "full_api_name": "SwapStrategy.inverse_composed_permutation",
        "api_description": "Returns the inversed composed permutation of all swap layers applied up to layer\n``idx``. Permutations are represented by list of integers where the ith element\ncorresponds to the mapping of i under the permutation.\n\nArgs:\n    idx: The number of swap layers to apply.\n\nReturns:\n    The inversed permutation as a list of integer values.",
        "api_signature": "inverse_composed_permutation(self, idx)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/commuting_2q_gate_routing/swap_strategy.py"
    },
    {
        "api_name": "swap_permutation",
        "full_api_name": "swap_permutation",
        "api_description": "Given a circuit of swaps, apply them to the permutation (in-place).\n\nArgs:\n  swaps: param mapping: A mapping of Keys to Values, where the Keys are being swapped.\n  mapping: The permutation to have swaps applied to.\n  allow_missing_keys: Whether to allow swaps of missing keys in mapping.",
        "api_signature": "swap_permutation(swaps, mapping, allow_missing_keys)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/algorithms/util.py"
    },
    {
        "api_name": "permutation_circuit",
        "full_api_name": "permutation_circuit",
        "api_description": "Produce a circuit description of a list of swaps.\n    With a given permutation and permuter you can compute the swaps using the permuter function\n    then feed it into this circuit function to obtain a circuit description.\nArgs:\n  swaps: An iterable of swaps to perform.\nReturns:\n  A MappingCircuit with the circuit and a mapping of node to qubit in the circuit.",
        "api_signature": "permutation_circuit(swaps)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/algorithms/util.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ApproximateTokenSwapper.__init__",
        "api_description": "Construct an ApproximateTokenSwapping object.\n\nArgs:\n    graph: Undirected graph represented a coupling map.\n    seed: Seed to use for random trials.",
        "api_signature": "__init__(self, graph, seed)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/algorithms/token_swapper.py"
    },
    {
        "api_name": "distance",
        "full_api_name": "ApproximateTokenSwapper.distance",
        "api_description": "Compute the distance between two nodes in `graph`.",
        "api_signature": "distance(self, vertex0, vertex1)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/algorithms/token_swapper.py"
    },
    {
        "api_name": "permutation_circuit",
        "full_api_name": "ApproximateTokenSwapper.permutation_circuit",
        "api_description": "Perform an approximately optimal Token Swapping algorithm to implement the permutation.\n\nArgs:\n  permutation: The partial mapping to implement in swaps.\n  trials: The number of trials to try to perform the mapping. Minimize over the trials.\n\nReturns:\n  The circuit to implement the permutation",
        "api_signature": "permutation_circuit(self, permutation, trials)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/algorithms/token_swapper.py"
    },
    {
        "api_name": "map",
        "full_api_name": "ApproximateTokenSwapper.map",
        "api_description": "Perform an approximately optimal Token Swapping algorithm to implement the permutation.\n\nSupports partial mappings (i.e. not-permutations) for graphs with missing tokens.\n\nBased on the paper: Approximation and Hardness for Token Swapping by Miltzow et al. (2016)\nArXiV: https://arxiv.org/abs/1602.05150\nand generalization based on our own work.\n\nArgs:\n  mapping: The partial mapping to implement in swaps.\n  trials: The number of trials to try to perform the mapping. Minimize over the trials.\n  parallel_threshold: The number of nodes in the graph beyond which the algorithm\n        will use parallel processing\n\nReturns:\n  The swaps to implement the mapping",
        "api_signature": "map(self, mapping, trials, parallel_threshold)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/algorithms/token_swapper.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "LinearFunctionsSynthesis.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/linear_functions_synthesis.py"
    },
    {
        "api_name": "run",
        "full_api_name": "LinearFunctionsToPermutations.run",
        "api_description": "Run the LinearFunctionsToPermutations pass on `dag`.\nArgs:\n    dag: input dag.\nReturns:\n    Output dag with LinearFunctions synthesized.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/linear_functions_synthesis.py"
    },
    {
        "api_name": "_choose_kak_gate",
        "full_api_name": "_choose_kak_gate",
        "api_description": "Choose the first available 2q gate to use in the KAK decomposition.",
        "api_signature": "_choose_kak_gate(basis_gates)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/unitary_synthesis.py"
    },
    {
        "api_name": "_choose_euler_basis",
        "full_api_name": "_choose_euler_basis",
        "api_description": "Choose the first available 1q basis to use in the Euler decomposition.",
        "api_signature": "_choose_euler_basis(basis_gates)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/unitary_synthesis.py"
    },
    {
        "api_name": "_find_matching_euler_bases",
        "full_api_name": "_find_matching_euler_bases",
        "api_description": "Find matching available 1q basis to use in the Euler decomposition.",
        "api_signature": "_find_matching_euler_bases(target, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/unitary_synthesis.py"
    },
    {
        "api_name": "_choose_bases",
        "full_api_name": "_choose_bases",
        "api_description": "Find the matching basis string keys from the list of basis gates from the backend.",
        "api_signature": "_choose_bases(basis_gates, basis_dict)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/unitary_synthesis.py"
    },
    {
        "api_name": "_decomposer_2q_from_basis_gates",
        "full_api_name": "_decomposer_2q_from_basis_gates",
        "api_description": "",
        "api_signature": "_decomposer_2q_from_basis_gates(basis_gates, pulse_optimize, approximation_degree)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/unitary_synthesis.py"
    },
    {
        "api_name": "_error",
        "full_api_name": "_error",
        "api_description": "Calculate a rough error for a `circuit` that runs on specific\n`qubits` of `target`.\n\nUse basis errors from target if available, otherwise use length\nof circuit as a weak proxy for error.",
        "api_signature": "_error(circuit, target, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/unitary_synthesis.py"
    },
    {
        "api_name": "_preferred_direction",
        "full_api_name": "_preferred_direction",
        "api_description": "`decomposer2q` decomposes an SU(4) over `qubits`. A user sets `natural_direction`\nto indicate whether they prefer synthesis in a hardware-native direction.\nIf yes, we return the `preferred_direction` here. If no hardware direction is\npreferred, we raise an error (unless natural_direction is None).\nWe infer this from `coupling_map`, `gate_lengths`, `gate_errors`.\n\nReturns [0, 1] if qubits are correct in the hardware-native direction.\nReturns [1, 0] if qubits must be flipped to match hardware-native direction.",
        "api_signature": "_preferred_direction(decomposer2q, qubits, natural_direction, coupling_map, gate_lengths, gate_errors)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/unitary_synthesis.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "UnitarySynthesis.__init__",
        "api_description": "Synthesize unitaries over some basis gates.\n\nThis pass can approximate 2-qubit unitaries given some\ngate fidelities (either via ``backend_props`` or ``target``).\nMore approximation can be forced by setting a heuristic dial\n``approximation_degree``.\n\nArgs:\n    basis_gates (list[str]): List of gate names to target. If this is\n        not specified the ``target`` argument must be used. If both this\n        and the ``target`` are specified the value of ``target`` will\n        be used and this will be ignored.\n    approximation_degree (float): heuristic dial used for circuit approximation\n        (1.0=no approximation, 0.0=maximal approximation). Approximation can\n        make the synthesized circuit cheaper at the cost of straying from\n        the original unitary. If None, approximation is done based on gate fidelities.\n    coupling_map (CouplingMap): the coupling map of the backend\n        in case synthesis is done on a physical circuit. The\n        directionality of the coupling_map will be taken into\n        account if ``pulse_optimize`` is ``True``/``None`` and ``natural_direction``\n        is ``True``/``None``.\n    backend_props (BackendProperties): Properties of a backend to\n        synthesize for (e.g. gate fidelities).\n    pulse_optimize (bool): Whether to optimize pulses during\n        synthesis. A value of ``None`` will attempt it but fall\n        back if it does not succeed. A value of ``True`` will raise\n        an error if pulse-optimized synthesis does not succeed.\n    natural_direction (bool): Whether to apply synthesis considering\n        directionality of 2-qubit gates. Only applies when\n        ``pulse_optimize`` is ``True`` or ``None``. The natural direction is\n        determined by first checking to see whether the\n        coupling map is unidirectional.  If there is no\n        coupling map or the coupling map is bidirectional,\n        the gate direction with the shorter\n        duration from the backend properties will be used. If\n        set to True, and a natural direction can not be\n        determined, raises :class:`.TranspilerError`. If set to None, no\n        exception will be raised if a natural direction can\n        not be determined.\n    synth_gates (list[str]): List of gates to synthesize. If None and\n        ``pulse_optimize`` is False or None, default to\n        ``['unitary']``. If ``None`` and ``pulse_optimize == True``,\n        default to ``['unitary', 'swap']``\n    method (str): The unitary synthesis method plugin to use.\n    min_qubits: The minimum number of qubits in the unitary to synthesize. If this is set\n        and the unitary is less than the specified number of qubits it will not be\n        synthesized.\n    plugin_config: Optional extra configuration arguments (as a ``dict``)\n        which are passed directly to the specified unitary synthesis\n        plugin. By default, this will have no effect as the default\n        plugin has no extra arguments. Refer to the documentation of\n        your unitary synthesis plugin on how to use this.\n    target: The optional :class:`~.Target` for the target device the pass\n        is compiling for. If specified this will supersede the values\n        set for ``basis_gates``, ``coupling_map``, and ``backend_props``.",
        "api_signature": "__init__(self, basis_gates, approximation_degree, coupling_map, backend_props, pulse_optimize, natural_direction, synth_gates, method, min_qubits, plugin_config, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/unitary_synthesis.py"
    },
    {
        "api_name": "run",
        "full_api_name": "UnitarySynthesis.run",
        "api_description": "Run the UnitarySynthesis pass on ``dag``.\n\nArgs:\n    dag: input dag.\n\nReturns:\n    Output dag with UnitaryGates synthesized to target basis.\n\nRaises:\n    TranspilerError: if ``method`` was specified for the class and is not\n        found in the installed plugins list. The list of installed\n        plugins can be queried with\n        :func:`~qiskit.transpiler.passes.synthesis.plugin.unitary_synthesis_plugin_names`",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/unitary_synthesis.py"
    },
    {
        "api_name": "_run_main_loop",
        "full_api_name": "UnitarySynthesis._run_main_loop",
        "api_description": "Inner loop for the optimizer, after all DAG-independent set-up has been completed.",
        "api_signature": "_run_main_loop(self, dag, qubit_indices, plugin_method, plugin_kwargs, default_method, default_kwargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/unitary_synthesis.py"
    },
    {
        "api_name": "_build_gate_lengths",
        "full_api_name": "_build_gate_lengths",
        "api_description": "Builds a ``gate_lengths`` dictionary from either ``props`` (BackendV1)\nor ``target`` (BackendV2).\n\nThe dictionary has the form:\n{gate_name: {(qubits,): duration}}",
        "api_signature": "_build_gate_lengths(props, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/unitary_synthesis.py"
    },
    {
        "api_name": "_build_gate_errors",
        "full_api_name": "_build_gate_errors",
        "api_description": "Builds a ``gate_error`` dictionary from either ``props`` (BackendV1)\nor ``target`` (BackendV2).\n\nThe dictionary has the form:\n{gate_name: {(qubits,): error_rate}}",
        "api_signature": "_build_gate_errors(props, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/unitary_synthesis.py"
    },
    {
        "api_name": "_build_gate_lengths_by_qubit",
        "full_api_name": "_build_gate_lengths_by_qubit",
        "api_description": "Builds a `gate_lengths` dictionary from either `props` (BackendV1)\nor `target (BackendV2)`.\n\nThe dictionary has the form:\n{(qubits): [Gate, duration]}",
        "api_signature": "_build_gate_lengths_by_qubit(props, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/unitary_synthesis.py"
    },
    {
        "api_name": "_build_gate_errors_by_qubit",
        "full_api_name": "_build_gate_errors_by_qubit",
        "api_description": "Builds a `gate_error` dictionary from either `props` (BackendV1)\nor `target (BackendV2)`.\n\nThe dictionary has the form:\n{(qubits): [Gate, error]}",
        "api_signature": "_build_gate_errors_by_qubit(props, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/unitary_synthesis.py"
    },
    {
        "api_name": "supports_basis_gates",
        "full_api_name": "DefaultUnitarySynthesis.supports_basis_gates",
        "api_description": "",
        "api_signature": "supports_basis_gates(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/unitary_synthesis.py"
    },
    {
        "api_name": "supports_coupling_map",
        "full_api_name": "DefaultUnitarySynthesis.supports_coupling_map",
        "api_description": "",
        "api_signature": "supports_coupling_map(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/unitary_synthesis.py"
    },
    {
        "api_name": "supports_natural_direction",
        "full_api_name": "DefaultUnitarySynthesis.supports_natural_direction",
        "api_description": "",
        "api_signature": "supports_natural_direction(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/unitary_synthesis.py"
    },
    {
        "api_name": "supports_pulse_optimize",
        "full_api_name": "DefaultUnitarySynthesis.supports_pulse_optimize",
        "api_description": "",
        "api_signature": "supports_pulse_optimize(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/unitary_synthesis.py"
    },
    {
        "api_name": "supports_gate_lengths",
        "full_api_name": "DefaultUnitarySynthesis.supports_gate_lengths",
        "api_description": "",
        "api_signature": "supports_gate_lengths(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/unitary_synthesis.py"
    },
    {
        "api_name": "supports_gate_errors",
        "full_api_name": "DefaultUnitarySynthesis.supports_gate_errors",
        "api_description": "",
        "api_signature": "supports_gate_errors(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/unitary_synthesis.py"
    },
    {
        "api_name": "supports_gate_lengths_by_qubit",
        "full_api_name": "DefaultUnitarySynthesis.supports_gate_lengths_by_qubit",
        "api_description": "",
        "api_signature": "supports_gate_lengths_by_qubit(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/unitary_synthesis.py"
    },
    {
        "api_name": "supports_gate_errors_by_qubit",
        "full_api_name": "DefaultUnitarySynthesis.supports_gate_errors_by_qubit",
        "api_description": "",
        "api_signature": "supports_gate_errors_by_qubit(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/unitary_synthesis.py"
    },
    {
        "api_name": "max_qubits",
        "full_api_name": "DefaultUnitarySynthesis.max_qubits",
        "api_description": "",
        "api_signature": "max_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/unitary_synthesis.py"
    },
    {
        "api_name": "min_qubits",
        "full_api_name": "DefaultUnitarySynthesis.min_qubits",
        "api_description": "",
        "api_signature": "min_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/unitary_synthesis.py"
    },
    {
        "api_name": "supported_bases",
        "full_api_name": "DefaultUnitarySynthesis.supported_bases",
        "api_description": "",
        "api_signature": "supported_bases(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/unitary_synthesis.py"
    },
    {
        "api_name": "supports_target",
        "full_api_name": "DefaultUnitarySynthesis.supports_target",
        "api_description": "",
        "api_signature": "supports_target(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/unitary_synthesis.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "DefaultUnitarySynthesis.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/unitary_synthesis.py"
    },
    {
        "api_name": "_decomposer_2q_from_target",
        "full_api_name": "DefaultUnitarySynthesis._decomposer_2q_from_target",
        "api_description": "",
        "api_signature": "_decomposer_2q_from_target(self, target, qubits, approximation_degree)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/unitary_synthesis.py"
    },
    {
        "api_name": "_replace_parameterized_gate",
        "full_api_name": "DefaultUnitarySynthesis._replace_parameterized_gate",
        "api_description": "",
        "api_signature": "_replace_parameterized_gate(op)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/unitary_synthesis.py"
    },
    {
        "api_name": "is_supercontrolled",
        "full_api_name": "DefaultUnitarySynthesis.is_supercontrolled",
        "api_description": "",
        "api_signature": "is_supercontrolled(gate)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/unitary_synthesis.py"
    },
    {
        "api_name": "is_controlled",
        "full_api_name": "DefaultUnitarySynthesis.is_controlled",
        "api_description": "",
        "api_signature": "is_controlled(gate)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/unitary_synthesis.py"
    },
    {
        "api_name": "run",
        "full_api_name": "DefaultUnitarySynthesis.run",
        "api_description": "",
        "api_signature": "run(self, unitary)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/unitary_synthesis.py"
    },
    {
        "api_name": "_synth_su4",
        "full_api_name": "DefaultUnitarySynthesis._synth_su4",
        "api_description": "",
        "api_signature": "_synth_su4(self, su4_mat, decomposer2q, preferred_direction, approximation_degree)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/unitary_synthesis.py"
    },
    {
        "api_name": "max_qubits",
        "full_api_name": "UnitarySynthesisPlugin.max_qubits",
        "api_description": "Return the maximum number of qubits the unitary synthesis plugin supports.\n\nIf the size of the unitary to be synthesized exceeds this value the\n``default`` plugin will be used. If there is no upper bound return\n``None`` and all unitaries (``>= min_qubits`` if it's defined) will be\npassed to this plugin when it's enabled.",
        "api_signature": "max_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/plugin.py"
    },
    {
        "api_name": "min_qubits",
        "full_api_name": "UnitarySynthesisPlugin.min_qubits",
        "api_description": "Return the minimum number of qubits the unitary synthesis plugin supports.\n\nIf the size of the unitary to be synthesized is below this value the\n``default`` plugin will be used. If there is no lower bound return\n``None`` and all unitaries (``<= max_qubits`` if it's defined) will be\npassed to this plugin when it's enabled.",
        "api_signature": "min_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/plugin.py"
    },
    {
        "api_name": "supports_basis_gates",
        "full_api_name": "UnitarySynthesisPlugin.supports_basis_gates",
        "api_description": "Return whether the plugin supports taking ``basis_gates``\n\nIf this returns ``True`` the plugin's ``run()`` method will be\npassed a ``basis_gates`` kwarg with a list of gate names the target\nbackend supports. For example, ``['sx', 'x', 'cx', 'id', 'rz']``.",
        "api_signature": "supports_basis_gates(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/plugin.py"
    },
    {
        "api_name": "supports_coupling_map",
        "full_api_name": "UnitarySynthesisPlugin.supports_coupling_map",
        "api_description": "Return whether the plugin supports taking ``coupling_map``\n\nIf this returns ``True`` the plugin's ``run()`` method will receive\none kwarg ``coupling_map``. The ``coupling_map`` kwarg will be set to a\ntuple with the first element being a\n:class:`~qiskit.transpiler.CouplingMap` object representing the qubit\nconnectivity of the target backend, the second element will be a list\nof integers that represent the qubit indices in the coupling map that\nunitary is on. Note that if the target backend doesn't have a coupling\nmap set, the ``coupling_map`` kwarg's value will be ``(None, qubit_indices)``.",
        "api_signature": "supports_coupling_map(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/plugin.py"
    },
    {
        "api_name": "supports_natural_direction",
        "full_api_name": "UnitarySynthesisPlugin.supports_natural_direction",
        "api_description": "Return whether the plugin supports a toggle for considering\ndirectionality of 2-qubit gates as ``natural_direction``.\n\nRefer to the documentation for :class:`~qiskit.transpiler.passes.UnitarySynthesis`\nfor the possible values and meaning of these values.",
        "api_signature": "supports_natural_direction(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/plugin.py"
    },
    {
        "api_name": "supports_pulse_optimize",
        "full_api_name": "UnitarySynthesisPlugin.supports_pulse_optimize",
        "api_description": "Return whether the plugin supports a toggle to optimize pulses\nduring synthesis as ``pulse_optimize``.\n\nRefer to the documentation for :class:`~qiskit.transpiler.passes.UnitarySynthesis`\nfor the possible values and meaning of these values.",
        "api_signature": "supports_pulse_optimize(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/plugin.py"
    },
    {
        "api_name": "supports_gate_lengths_by_qubit",
        "full_api_name": "UnitarySynthesisPlugin.supports_gate_lengths_by_qubit",
        "api_description": "Return whether the plugin supports taking ``gate_lengths_by_qubit``\n\nThis differs from ``supports_gate_lengths``/``gate_lengths`` by using a different\nview of the same data. Instead of being keyed by gate name this is keyed by qubit\nand uses :class:`~.Gate` instances to represent gates (instead of gate names)\n\n``gate_lengths_by_qubit`` will be a dictionary in the form of\n``{(qubits,): [Gate, length]}``. For example::\n\n    {\n    (0,): [SXGate(): 0.0006149355812506126, RZGate(): 0.0],\n    (0, 1): [CXGate(): 0.012012477900732316]\n    }\n\nwhere the ``length`` value is in units of seconds.\n\nDo note that this dictionary might not be complete or could be empty\nas it depends on the target backend reporting gate lengths on every\ngate for each qubit.\n\nThis defaults to False",
        "api_signature": "supports_gate_lengths_by_qubit(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/plugin.py"
    },
    {
        "api_name": "supports_gate_errors_by_qubit",
        "full_api_name": "UnitarySynthesisPlugin.supports_gate_errors_by_qubit",
        "api_description": "Return whether the plugin supports taking ``gate_errors_by_qubit``\n\nThis differs from ``supports_gate_errors``/``gate_errors`` by using a different\nview of the same data. Instead of being keyed by gate name this is keyed by qubit\nand uses :class:`~.Gate` instances to represent gates (instead of gate names).\n\n``gate_errors_by_qubit`` will be a dictionary in the form of\n``{(qubits,): [Gate, error]}``. For example::\n\n    {\n    (0,): [SXGate(): 0.0006149355812506126, RZGate(): 0.0],\n    (0, 1): [CXGate(): 0.012012477900732316]\n    }\n\nDo note that this dictionary might not be complete or could be empty\nas it depends on the target backend reporting gate errors on every\ngate for each qubit. The gate error rates reported in ``gate_errors``\nare provided by the target device ``Backend`` object and the exact\nmeaning might be different depending on the backend.\n\nThis defaults to False",
        "api_signature": "supports_gate_errors_by_qubit(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/plugin.py"
    },
    {
        "api_name": "supports_gate_lengths",
        "full_api_name": "UnitarySynthesisPlugin.supports_gate_lengths",
        "api_description": "Return whether the plugin supports taking ``gate_lengths``\n\n``gate_lengths`` will be a dictionary in the form of\n``{gate_name: {(qubit_1, qubit_2): length}}``. For example::\n\n    {\n    'sx': {(0,): 0.0006149355812506126, (1,): 0.0006149355812506126},\n    'cx': {(0, 1): 0.012012477900732316, (1, 0): 5.191111111111111e-07}\n    }\n\nwhere the ``length`` value is in units of seconds.\n\nDo note that this dictionary might not be complete or could be empty\nas it depends on the target backend reporting gate lengths on every\ngate for each qubit.",
        "api_signature": "supports_gate_lengths(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/plugin.py"
    },
    {
        "api_name": "supports_gate_errors",
        "full_api_name": "UnitarySynthesisPlugin.supports_gate_errors",
        "api_description": "Return whether the plugin supports taking ``gate_errors``\n\n``gate_errors`` will be a dictionary in the form of\n``{gate_name: {(qubit_1, qubit_2): error}}``. For example::\n\n    {\n    'sx': {(0,): 0.0006149355812506126, (1,): 0.0006149355812506126},\n    'cx': {(0, 1): 0.012012477900732316, (1, 0): 5.191111111111111e-07}\n    }\n\nDo note that this dictionary might not be complete or could be empty\nas it depends on the target backend reporting gate errors on every\ngate for each qubit. The gate error rates reported in ``gate_errors``\nare provided by the target device ``Backend`` object and the exact\nmeaning might be different depending on the backend.",
        "api_signature": "supports_gate_errors(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/plugin.py"
    },
    {
        "api_name": "supported_bases",
        "full_api_name": "UnitarySynthesisPlugin.supported_bases",
        "api_description": "Returns a dictionary of supported bases for synthesis\n\nThis is expected to return a dictionary where the key is a string\nbasis and the value is a list of gate names that the basis works in.\nIf the synthesis method doesn't support multiple bases this should\nreturn ``None``. For example::\n\n    {\n        \"XZX\": [\"rz\", \"rx\"],\n        \"XYX\": [\"rx\", \"ry\"],\n    }\n\nIf a dictionary is returned by this method the run kwargs will be\npassed a parameter ``matched_basis`` which contains a list of the\nbasis strings (i.e. keys in the dictionary) which match the target basis\ngate set for the transpilation. If no entry in the dictionary matches\nthe target basis gate set then the ``matched_basis`` kwarg will be set\nto an empty list, and a plugin can choose how to deal with the target\nbasis gate set not matching the plugin's capabilities.",
        "api_signature": "supported_bases(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/plugin.py"
    },
    {
        "api_name": "supports_target",
        "full_api_name": "UnitarySynthesisPlugin.supports_target",
        "api_description": "Whether the plugin supports taking ``target`` as an option\n\n``target`` will be a :class:`~.Target` object representing the target\ndevice for the output of the synthesis pass.\n\nBy default this will be ``False`` since the plugin interface predates\nthe :class:`~.Target` class. If a plugin returns ``True`` for this\nattribute, it is expected that the plugin will use the\n:class:`~.Target` instead of the values passed if any of\n``supports_gate_lengths``, ``supports_gate_errors``,\n``supports_coupling_map``, and ``supports_basis_gates`` are set\n(although ideally all those parameters should contain duplicate\ninformation).",
        "api_signature": "supports_target(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/plugin.py"
    },
    {
        "api_name": "run",
        "full_api_name": "UnitarySynthesisPlugin.run",
        "api_description": "Run synthesis for the given unitary matrix\n\nArgs:\n    unitary (numpy.ndarray): The unitary matrix to synthesize to a\n        :class:`~qiskit.dagcircuit.DAGCircuit` object\n    options: The optional kwargs that are passed based on the output\n        the ``support_*`` methods on the class. Refer to the\n        documentation for these methods on\n        :class:`~qiskit.transpiler.passes.synthesis.plugin.UnitarySynthesisPlugin`\n        to see what the keys and values are.\n\nReturns:\n    DAGCircuit: The dag circuit representation of the unitary. Alternatively, you can return\n    a tuple of the form ``(dag, wires)`` where ``dag`` is the dag circuit representation of\n    the circuit representation of the unitary and ``wires`` is the mapping wires to use for\n    :meth:`qiskit.dagcircuit.DAGCircuit.substitute_node_with_dag`. If you return a tuple\n    and ``wires`` is ``None`` this will behave just as if only a\n    :class:`~qiskit.dagcircuit.DAGCircuit` was returned. Additionally if this returns\n    ``None`` no substitution will be made.",
        "api_signature": "run(self, unitary)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/plugin.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "UnitarySynthesisPluginManager.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/plugin.py"
    },
    {
        "api_name": "unitary_synthesis_plugin_names",
        "full_api_name": "unitary_synthesis_plugin_names",
        "api_description": "Return a list of installed unitary synthesis plugin names\n\nReturns:\n    list: A list of the installed unitary synthesis plugin names. The plugin names are valid\n    values for the :func:`~qiskit.compiler.transpile` kwarg ``unitary_synthesis_method``.",
        "api_signature": "unitary_synthesis_plugin_names()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/plugin.py"
    },
    {
        "api_name": "run",
        "full_api_name": "HighLevelSynthesisPlugin.run",
        "api_description": "Run synthesis for the given Operation.\n\nArgs:\n    high_level_object (Operation): The Operation to synthesize to a\n        :class:`~qiskit.dagcircuit.DAGCircuit` object.\n    coupling_map (CouplingMap): The coupling map of the backend\n        in case synthesis is done on a physical circuit.\n    target (Target): A target representing the target backend.\n    qubits (list): List of qubits over which the operation is defined\n        in case synthesis is done on a physical circuit.\n    options: Additional method-specific optional kwargs.\n\nReturns:\n    QuantumCircuit: The quantum circuit representation of the Operation\n        when successful, and ``None`` otherwise.",
        "api_signature": "run(self, high_level_object, coupling_map, target, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/plugin.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "HighLevelSynthesisPluginManager.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/plugin.py"
    },
    {
        "api_name": "method_names",
        "full_api_name": "HighLevelSynthesisPluginManager.method_names",
        "api_description": "Returns plugin methods for op_name.",
        "api_signature": "method_names(self, op_name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/plugin.py"
    },
    {
        "api_name": "method",
        "full_api_name": "HighLevelSynthesisPluginManager.method",
        "api_description": "Returns the plugin for ``op_name`` and ``method_name``.",
        "api_signature": "method(self, op_name, method_name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/plugin.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SolovayKitaev.__init__",
        "api_description": "Args:\n    recursion_degree: The recursion depth for the Solovay-Kitaev algorithm.\n        A larger recursion depth increases the accuracy and length of the\n        decomposition.\n    basic_approximations: The basic approximations for the finding the best discrete\n        decomposition at the root of the recursion. If a string, it specifies the ``.npy``\n        file to load the approximations from. If a dictionary, it contains\n        ``{label: SO(3)-matrix}`` pairs. If None, a default based on the H, T and Tdg gates\n        up to combinations of depth 10 is generated.",
        "api_signature": "__init__(self, recursion_degree, basic_approximations)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/solovay_kitaev_synthesis.py"
    },
    {
        "api_name": "run",
        "full_api_name": "SolovayKitaev.run",
        "api_description": "Run the ``SolovayKitaev`` pass on `dag`.\n\nArgs:\n    dag: The input dag.\n\nReturns:\n    Output dag with 1q gates synthesized in the discrete target basis.\n\nRaises:\n    TranspilerError: if a gates does not have to_matrix",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/solovay_kitaev_synthesis.py"
    },
    {
        "api_name": "max_qubits",
        "full_api_name": "SolovayKitaevSynthesis.max_qubits",
        "api_description": "Maximum number of supported qubits is ``1``.",
        "api_signature": "max_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/solovay_kitaev_synthesis.py"
    },
    {
        "api_name": "min_qubits",
        "full_api_name": "SolovayKitaevSynthesis.min_qubits",
        "api_description": "Minimum number of supported qubits is ``1``.",
        "api_signature": "min_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/solovay_kitaev_synthesis.py"
    },
    {
        "api_name": "supports_natural_direction",
        "full_api_name": "SolovayKitaevSynthesis.supports_natural_direction",
        "api_description": "The plugin does not support natural direction, it does not assume\nbidirectional two qubit gates.",
        "api_signature": "supports_natural_direction(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/solovay_kitaev_synthesis.py"
    },
    {
        "api_name": "supports_pulse_optimize",
        "full_api_name": "SolovayKitaevSynthesis.supports_pulse_optimize",
        "api_description": "The plugin does not support optimization of pulses.",
        "api_signature": "supports_pulse_optimize(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/solovay_kitaev_synthesis.py"
    },
    {
        "api_name": "supports_gate_lengths",
        "full_api_name": "SolovayKitaevSynthesis.supports_gate_lengths",
        "api_description": "The plugin does not support gate lengths.",
        "api_signature": "supports_gate_lengths(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/solovay_kitaev_synthesis.py"
    },
    {
        "api_name": "supports_gate_errors",
        "full_api_name": "SolovayKitaevSynthesis.supports_gate_errors",
        "api_description": "The plugin does not support gate errors.",
        "api_signature": "supports_gate_errors(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/solovay_kitaev_synthesis.py"
    },
    {
        "api_name": "supported_bases",
        "full_api_name": "SolovayKitaevSynthesis.supported_bases",
        "api_description": "The plugin does not support bases for synthesis.",
        "api_signature": "supported_bases(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/solovay_kitaev_synthesis.py"
    },
    {
        "api_name": "supports_basis_gates",
        "full_api_name": "SolovayKitaevSynthesis.supports_basis_gates",
        "api_description": "The plugin does not support basis gates. By default it synthesis to the\n``[\"h\", \"t\", \"tdg\"]`` gate basis.",
        "api_signature": "supports_basis_gates(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/solovay_kitaev_synthesis.py"
    },
    {
        "api_name": "supports_coupling_map",
        "full_api_name": "SolovayKitaevSynthesis.supports_coupling_map",
        "api_description": "The plugin does not support coupling maps.",
        "api_signature": "supports_coupling_map(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/solovay_kitaev_synthesis.py"
    },
    {
        "api_name": "run",
        "full_api_name": "SolovayKitaevSynthesis.run",
        "api_description": "",
        "api_signature": "run(self, unitary)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/solovay_kitaev_synthesis.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "HLSConfig.__init__",
        "api_description": "Creates a high-level-synthesis config.\n\nArgs:\n    use_default_on_unspecified (bool): if True, every higher-level-object without an\n        explicitly specified list of methods will be synthesized using the \"default\"\n        algorithm if it exists.\n    kwargs: a dictionary mapping higher-level-objects to lists of synthesis methods.",
        "api_signature": "__init__(self, use_default_on_unspecified)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/high_level_synthesis.py"
    },
    {
        "api_name": "set_methods",
        "full_api_name": "HLSConfig.set_methods",
        "api_description": "Sets the list of synthesis methods for a given higher-level-object. This overwrites\nthe lists of methods if also set previously.",
        "api_signature": "set_methods(self, hls_name, hls_methods)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/high_level_synthesis.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "HighLevelSynthesis.__init__",
        "api_description": "HighLevelSynthesis initializer.\n\nArgs:\n    hls_config: Optional, the high-level-synthesis config that specifies synthesis methods\n        and parameters for various high-level-objects in the circuit. If it is not specified,\n        the default synthesis methods and parameters will be used.\n    coupling_map: Optional, directed graph represented as a coupling map.\n    target: Optional, the backend target to use for this pass. If it is specified,\n        it will be used instead of the coupling map.\n    use_qubit_indices: a flag indicating whether this synthesis pass is running before or after\n        the layout is set, that is, whether the qubit indices of higher-level-objects correspond\n        to qubit indices on the target backend.\n    equivalence_library: The equivalence library used (instructions in this library will not\n        be unrolled by this pass).\n    basis_gates: Optional, target basis names to unroll to, e.g. `['u3', 'cx']`.\n        Ignored if ``target`` is also specified.\n    min_qubits: The minimum number of qubits for operations in the input\n        dag to translate.",
        "api_signature": "__init__(self, hls_config, coupling_map, target, use_qubit_indices, equivalence_library, basis_gates, min_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/high_level_synthesis.py"
    },
    {
        "api_name": "run",
        "full_api_name": "HighLevelSynthesis.run",
        "api_description": "Run the HighLevelSynthesis pass on `dag`.\n\nArgs:\n    dag: input dag.\n\nReturns:\n    Output dag with higher-level operations synthesized.\n\nRaises:\n    TranspilerError: when the transpiler is unable to synthesize the given DAG\n    (for instance, when the specified synthesis method is not available).",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/high_level_synthesis.py"
    },
    {
        "api_name": "_recursively_handle_op",
        "full_api_name": "HighLevelSynthesis._recursively_handle_op",
        "api_description": "Recursively synthesizes a single operation.\n\nNote: the reason that this function accepts an operation and not a dag node\nis that it's also used for synthesizing the base operation for an annotated\ngate (i.e. no dag node is available).\n\nThere are several possible results:\n\n- The given operation is unchanged: e.g., it is supported by the target or is\n  in the equivalence library\n- The result is a quantum circuit: e.g., synthesizing Clifford using plugin\n- The result is a DAGCircuit: e.g., when unrolling custom gates\n- The result is an Operation: e.g., adding control to CXGate results in CCXGate\n- The given operation could not be synthesized, raising a transpiler error\n\nThe function returns the result of the synthesis (either a quantum circuit or\nan Operation), and, as an optimization, a boolean indicating whether\nsynthesis did anything.\n\nThe function is recursive, for example synthesizing an annotated operation\ninvolves synthesizing its \"base operation\" which might also be\nan annotated operation.",
        "api_signature": "_recursively_handle_op(self, op, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/high_level_synthesis.py"
    },
    {
        "api_name": "_synthesize_op_using_plugins",
        "full_api_name": "HighLevelSynthesis._synthesize_op_using_plugins",
        "api_description": "Attempts to synthesize op using plugin mechanism.\nReturns either the synthesized circuit or None (which occurs when no\nsynthesis methods are available or specified).",
        "api_signature": "_synthesize_op_using_plugins(self, op, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/high_level_synthesis.py"
    },
    {
        "api_name": "_synthesize_annotated_op",
        "full_api_name": "HighLevelSynthesis._synthesize_annotated_op",
        "api_description": "Recursively synthesizes annotated operations.\nReturns either the synthesized operation or None (which occurs when the operation\nis not an annotated operation).",
        "api_signature": "_synthesize_annotated_op(self, op)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/high_level_synthesis.py"
    },
    {
        "api_name": "run",
        "full_api_name": "DefaultSynthesisClifford.run",
        "api_description": "Run synthesis for the given Clifford.",
        "api_signature": "run(self, high_level_object, coupling_map, target, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/high_level_synthesis.py"
    },
    {
        "api_name": "run",
        "full_api_name": "AGSynthesisClifford.run",
        "api_description": "Run synthesis for the given Clifford.",
        "api_signature": "run(self, high_level_object, coupling_map, target, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/high_level_synthesis.py"
    },
    {
        "api_name": "run",
        "full_api_name": "BMSynthesisClifford.run",
        "api_description": "Run synthesis for the given Clifford.",
        "api_signature": "run(self, high_level_object, coupling_map, target, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/high_level_synthesis.py"
    },
    {
        "api_name": "run",
        "full_api_name": "GreedySynthesisClifford.run",
        "api_description": "Run synthesis for the given Clifford.",
        "api_signature": "run(self, high_level_object, coupling_map, target, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/high_level_synthesis.py"
    },
    {
        "api_name": "run",
        "full_api_name": "LayerSynthesisClifford.run",
        "api_description": "Run synthesis for the given Clifford.",
        "api_signature": "run(self, high_level_object, coupling_map, target, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/high_level_synthesis.py"
    },
    {
        "api_name": "run",
        "full_api_name": "LayerLnnSynthesisClifford.run",
        "api_description": "Run synthesis for the given Clifford.",
        "api_signature": "run(self, high_level_object, coupling_map, target, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/high_level_synthesis.py"
    },
    {
        "api_name": "run",
        "full_api_name": "DefaultSynthesisLinearFunction.run",
        "api_description": "Run synthesis for the given LinearFunction.",
        "api_signature": "run(self, high_level_object, coupling_map, target, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/high_level_synthesis.py"
    },
    {
        "api_name": "run",
        "full_api_name": "KMSSynthesisLinearFunction.run",
        "api_description": "Run synthesis for the given LinearFunction.",
        "api_signature": "run(self, high_level_object, coupling_map, target, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/high_level_synthesis.py"
    },
    {
        "api_name": "run",
        "full_api_name": "PMHSynthesisLinearFunction.run",
        "api_description": "Run synthesis for the given LinearFunction.",
        "api_signature": "run(self, high_level_object, coupling_map, target, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/high_level_synthesis.py"
    },
    {
        "api_name": "run",
        "full_api_name": "KMSSynthesisPermutation.run",
        "api_description": "Run synthesis for the given Permutation.",
        "api_signature": "run(self, high_level_object, coupling_map, target, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/high_level_synthesis.py"
    },
    {
        "api_name": "run",
        "full_api_name": "BasicSynthesisPermutation.run",
        "api_description": "Run synthesis for the given Permutation.",
        "api_signature": "run(self, high_level_object, coupling_map, target, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/high_level_synthesis.py"
    },
    {
        "api_name": "run",
        "full_api_name": "ACGSynthesisPermutation.run",
        "api_description": "Run synthesis for the given Permutation.",
        "api_signature": "run(self, high_level_object, coupling_map, target, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/high_level_synthesis.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ASAPSchedule.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/asap.py"
    },
    {
        "api_name": "run",
        "full_api_name": "ASAPSchedule.run",
        "api_description": "Run the ASAPSchedule pass on `dag`.\n\nArgs:\n    dag (DAGCircuit): DAG to schedule.\n\nReturns:\n    DAGCircuit: A scheduled DAG.\n\nRaises:\n    TranspilerError: if the circuit is not mapped on physical qubits.\n    TranspilerError: if conditional bit is added to non-supported instruction.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/asap.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ALAPSchedule.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/alap.py"
    },
    {
        "api_name": "run",
        "full_api_name": "ALAPSchedule.run",
        "api_description": "Run the ALAPSchedule pass on `dag`.\n\nArgs:\n    dag (DAGCircuit): DAG to schedule.\n\nReturns:\n    DAGCircuit: A scheduled DAG.\n\nRaises:\n    TranspilerError: if the circuit is not mapped on physical qubits.\n    TranspilerError: if conditional bit is added to non-supported instruction.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/alap.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "DynamicalDecoupling.__init__",
        "api_description": "Dynamical decoupling initializer.\n\nArgs:\n    durations (InstructionDurations): Durations of instructions to be\n        used in scheduling.\n    dd_sequence (list[Gate]): sequence of gates to apply in idle spots.\n    qubits (list[int]): physical qubits on which to apply DD.\n        If None, all qubits will undergo DD (when possible).\n    spacing (list[float]): a list of spacings between the DD gates.\n        The available slack will be divided according to this.\n        The list length must be one more than the length of dd_sequence,\n        and the elements must sum to 1. If None, a balanced spacing\n        will be used [d/2, d, d, ..., d, d, d/2].\n    skip_reset_qubits (bool): if True, does not insert DD on idle\n        periods that immediately follow initialized/reset qubits (as\n        qubits in the ground state are less susceptile to decoherence).\n    target (Target): The :class:`~.Target` representing the target backend, if both\n          ``durations`` and this are specified then this argument will take\n          precedence and ``durations`` will be ignored.",
        "api_signature": "__init__(self, durations, dd_sequence, qubits, spacing, skip_reset_qubits, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/dynamical_decoupling.py"
    },
    {
        "api_name": "run",
        "full_api_name": "DynamicalDecoupling.run",
        "api_description": "Run the DynamicalDecoupling pass on dag.\n\nArgs:\n    dag (DAGCircuit): a scheduled DAG.\n\nReturns:\n    DAGCircuit: equivalent circuit with delays interrupted by DD,\n        where possible.\n\nRaises:\n    TranspilerError: if the circuit is not mapped on physical qubits.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/dynamical_decoupling.py"
    },
    {
        "api_name": "__gate_supported",
        "full_api_name": "DynamicalDecoupling.__gate_supported",
        "api_description": "A gate is supported on the qubit (qarg) or not.",
        "api_signature": "__gate_supported(self, gate, qarg)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/dynamical_decoupling.py"
    },
    {
        "api_name": "_mod_2pi",
        "full_api_name": "_mod_2pi",
        "api_description": "Wrap angle into interval [-\u03c0,\u03c0). If within atol of the endpoint, clamp to -\u03c0",
        "api_signature": "_mod_2pi(angle, atol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/dynamical_decoupling.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BaseSchedulerTransform.__init__",
        "api_description": "Scheduler initializer.\n\nArgs:\n    durations: Durations of instructions to be used in scheduling\n    clbit_write_latency: A control flow constraints. Because standard superconducting\n        quantum processor implement dispersive QND readout, the actual data transfer\n        to the clbit happens after the round-trip stimulus signal is buffered\n        and discriminated into quantum state.\n        The interval ``[t0, t0 + clbit_write_latency]`` is regarded as idle time\n        for clbits associated with the measure instruction.\n        This defaults to 0 dt which is identical to Qiskit Pulse scheduler.\n    conditional_latency: A control flow constraints. This value represents\n        a latency of reading a classical register for the conditional operation.\n        The gate operation occurs after this latency. This appears as a delay\n        in front of the DAGOpNode of the gate.\n        This defaults to 0 dt.\n    target: The :class:`~.Target` representing the target backend, if both\n        ``durations`` and this are specified then this argument will take\n        precedence and ``durations`` will be ignored.",
        "api_signature": "__init__(self, durations, clbit_write_latency, conditional_latency, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/base_scheduler.py"
    },
    {
        "api_name": "_get_node_duration",
        "full_api_name": "BaseSchedulerTransform._get_node_duration",
        "api_description": "A helper method to get duration from node or calibration.",
        "api_signature": "_get_node_duration(node, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/base_scheduler.py"
    },
    {
        "api_name": "_delay_supported",
        "full_api_name": "BaseSchedulerTransform._delay_supported",
        "api_description": "Delay operation is supported on the qubit (qarg) or not.",
        "api_signature": "_delay_supported(self, qarg)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/base_scheduler.py"
    },
    {
        "api_name": "run",
        "full_api_name": "BaseSchedulerTransform.run",
        "api_description": "",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/base_scheduler.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "TimeUnitConversion.__init__",
        "api_description": "TimeUnitAnalysis initializer.\n\nArgs:\n    inst_durations (InstructionDurations): A dictionary of durations of instructions.\n    target: The :class:`~.Target` representing the target backend, if both\n          ``inst_durations`` and this are specified then this argument will take\n          precedence and ``inst_durations`` will be ignored.",
        "api_signature": "__init__(self, inst_durations, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/time_unit_conversion.py"
    },
    {
        "api_name": "run",
        "full_api_name": "TimeUnitConversion.run",
        "api_description": "Run the TimeUnitAnalysis pass on `dag`.\n\nArgs:\n    dag (DAGCircuit): DAG to be checked.\n\nReturns:\n    DAGCircuit: DAG with consistent timing and op nodes annotated with duration.\n\nRaises:\n    TranspilerError: if the units are not unifiable",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/time_unit_conversion.py"
    },
    {
        "api_name": "_units_used_in_delays",
        "full_api_name": "TimeUnitConversion._units_used_in_delays",
        "api_description": "",
        "api_signature": "_units_used_in_delays(dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/time_unit_conversion.py"
    },
    {
        "api_name": "_unified",
        "full_api_name": "TimeUnitConversion._unified",
        "api_description": "",
        "api_signature": "_unified(unit_set)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/time_unit_conversion.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "AlignMeasures.__init__",
        "api_description": "Create new pass.\n\nArgs:\n    alignment: Integer number representing the minimum time resolution to\n        trigger measure instruction in units of ``dt``. This value depends on\n        the control electronics of your quantum processor.",
        "api_signature": "__init__(self, alignment)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/alignments/align_measures.py"
    },
    {
        "api_name": "run",
        "full_api_name": "AlignMeasures.run",
        "api_description": "Run the measurement alignment pass on `dag`.\n\nArgs:\n    dag (DAGCircuit): DAG to be checked.\n\nReturns:\n    DAGCircuit: DAG with consistent timing and op nodes annotated with duration.\n\nRaises:\n    TranspilerError: If circuit is not scheduled.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/alignments/align_measures.py"
    },
    {
        "api_name": "pad_with_delays",
        "full_api_name": "AlignMeasures.pad_with_delays",
        "api_description": "Pad idle time-slots in ``qubits`` with delays in ``unit`` until ``until``.",
        "api_signature": "pad_with_delays(qubits, until, unit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/alignments/align_measures.py"
    },
    {
        "api_name": "_check_alignment_required",
        "full_api_name": "_check_alignment_required",
        "api_description": "Check DAG nodes and return a boolean representing if instruction scheduling is necessary.\n\nArgs:\n    dag: DAG circuit to check.\n    alignment: Instruction alignment condition.\n    instructions: Target instructions.\n\nReturns:\n    If instruction scheduling is necessary.",
        "api_signature": "_check_alignment_required(dag, alignment, instructions)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/alignments/align_measures.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ValidatePulseGates.__init__",
        "api_description": "Create new pass.\n\nArgs:\n    granularity: Integer number representing the minimum time resolution to\n        define the pulse gate length in units of ``dt``. This value depends on\n        the control electronics of your quantum processor.\n    min_length: Integer number representing the minimum data point length to\n        define the pulse gate in units of ``dt``. This value depends on\n        the control electronics of your quantum processor.",
        "api_signature": "__init__(self, granularity, min_length)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/alignments/pulse_gate_validation.py"
    },
    {
        "api_name": "run",
        "full_api_name": "ValidatePulseGates.run",
        "api_description": "Run the pulse gate validation attached to ``dag``.\n\nArgs:\n    dag: DAG to be validated.\n\nReturns:\n    DAGCircuit: DAG with consistent timing and op nodes annotated with duration.\n\nRaises:\n    TranspilerError: When pulse gate violate pulse controller constraints.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/alignments/pulse_gate_validation.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "InstructionDurationCheck.__init__",
        "api_description": "Create new duration validation pass.\n\nThe alignment values depend on the control electronics of your quantum processor.\n\nArgs:\n    acquire_alignment: Integer number representing the minimum time resolution to\n        trigger acquisition instruction in units of ``dt``.\n    pulse_alignment: Integer number representing the minimum time resolution to\n        trigger gate instruction in units of ``dt``.",
        "api_signature": "__init__(self, acquire_alignment, pulse_alignment)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/alignments/check_durations.py"
    },
    {
        "api_name": "run",
        "full_api_name": "InstructionDurationCheck.run",
        "api_description": "Run duration validation passes.\n\nArgs:\n    dag: DAG circuit to check instruction durations.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/alignments/check_durations.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ConstrainedReschedule.__init__",
        "api_description": "Create new rescheduler pass.\n\nThe alignment values depend on the control electronics of your quantum processor.\n\nArgs:\n    acquire_alignment: Integer number representing the minimum time resolution to\n        trigger acquisition instruction in units of ``dt``.\n    pulse_alignment: Integer number representing the minimum time resolution to\n        trigger gate instruction in units of ``dt``.",
        "api_signature": "__init__(self, acquire_alignment, pulse_alignment)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/alignments/reschedule.py"
    },
    {
        "api_name": "_get_next_gate",
        "full_api_name": "ConstrainedReschedule._get_next_gate",
        "api_description": "Get next non-delay nodes.\n\nArgs:\n    dag: DAG circuit to be rescheduled with constraints.\n    node: Current node.\n\nReturns:\n    A list of non-delay successors.",
        "api_signature": "_get_next_gate(cls, dag, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/alignments/reschedule.py"
    },
    {
        "api_name": "_push_node_back",
        "full_api_name": "ConstrainedReschedule._push_node_back",
        "api_description": "Update the start time of the current node to satisfy alignment constraints.\nImmediate successors are pushed back to avoid overlap and will be processed later.\n\n.. note::\n\n    This logic assumes the all bits in the qregs and cregs synchronously start and end,\n    i.e. occupy the same time slot, but qregs and cregs can take\n    different time slot due to classical I/O latencies.\n\nArgs:\n    dag: DAG circuit to be rescheduled with constraints.\n    node: Current node.",
        "api_signature": "_push_node_back(self, dag, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/alignments/reschedule.py"
    },
    {
        "api_name": "run",
        "full_api_name": "ConstrainedReschedule.run",
        "api_description": "Run rescheduler.\n\nThis pass should perform rescheduling to satisfy:\n\n    - All DAGOpNode nodes (except for compiler directives) are placed at start time\n      satisfying hardware alignment constraints.\n    - The end time of a node does not overlap with the start time of successor nodes.\n\nAssumptions:\n\n    - Topological order and absolute time order of DAGOpNode are consistent.\n    - All bits in either qargs or cargs associated with node synchronously start.\n    - Start time of qargs and cargs may different due to I/O latency.\n\nBased on the configurations above, the rescheduler pass takes the following strategy:\n\n1. The nodes are processed in the topological order, from the beginning of\n    the circuit (i.e. from left to right). For every node (including compiler\n    directives), the function ``_push_node_back`` performs steps 2 and 3.\n2. If the start time of the node violates the alignment constraint,\n    the start time is increased to satisfy the constraint.\n3. Each immediate successor whose start_time overlaps the node's end_time is\n    pushed backwards (towards the end of the wire). Note that at this point\n    the shifted successor does not need to satisfy the constraints, but this\n    will be taken care of when that successor node itself is processed.\n4. After every node is processed, all misalignment constraints will be resolved,\n    and there will be no overlap between the nodes.\n\nArgs:\n    dag: DAG circuit to be rescheduled with constraints.\n\nRaises:\n    TranspilerError: If circuit is not scheduled.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/alignments/reschedule.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PadDynamicalDecoupling.__init__",
        "api_description": "Dynamical decoupling initializer.\n\nArgs:\n    durations: Durations of instructions to be used in scheduling.\n    dd_sequence: Sequence of gates to apply in idle spots.\n    qubits: Physical qubits on which to apply DD.\n        If None, all qubits will undergo DD (when possible).\n    spacing: A list of spacings between the DD gates.\n        The available slack will be divided according to this.\n        The list length must be one more than the length of dd_sequence,\n        and the elements must sum to 1. If None, a balanced spacing\n        will be used [d/2, d, d, ..., d, d, d/2].\n    skip_reset_qubits: If True, does not insert DD on idle periods that\n        immediately follow initialized/reset qubits\n        (as qubits in the ground state are less susceptile to decoherence).\n    pulse_alignment: The hardware constraints for gate timing allocation.\n        This is usually provided from ``backend.configuration().timing_constraints``.\n        If provided, the delay length, i.e. ``spacing``, is implicitly adjusted to\n        satisfy this constraint.\n    extra_slack_distribution: The option to control the behavior of DD sequence generation.\n        The duration of the DD sequence should be identical to an idle time in the\n        scheduled quantum circuit, however, the delay in between gates comprising the sequence\n        should be integer number in units of dt, and it might be further truncated\n        when ``pulse_alignment`` is specified. This sometimes results in the duration of\n        the created sequence being shorter than the idle time\n        that you want to fill with the sequence, i.e. `extra slack`.\n        This option takes following values.\n\n            - \"middle\": Put the extra slack to the interval at the middle of the sequence.\n            - \"edges\": Divide the extra slack as evenly as possible into\n              intervals at beginning and end of the sequence.\n    target: The :class:`~.Target` representing the target backend, if both\n          ``durations`` and this are specified then this argument will take\n          precedence and ``durations`` will be ignored.\n\nRaises:\n    TranspilerError: When invalid DD sequence is specified.\n    TranspilerError: When pulse gate with the duration which is\n        non-multiple of the alignment constraint value is found.\n    TypeError: If ``dd_sequence`` is not specified",
        "api_signature": "__init__(self, durations, dd_sequence, qubits, spacing, skip_reset_qubits, pulse_alignment, extra_slack_distribution, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/padding/dynamical_decoupling.py"
    },
    {
        "api_name": "_pre_runhook",
        "full_api_name": "PadDynamicalDecoupling._pre_runhook",
        "api_description": "",
        "api_signature": "_pre_runhook(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/padding/dynamical_decoupling.py"
    },
    {
        "api_name": "__gate_supported",
        "full_api_name": "PadDynamicalDecoupling.__gate_supported",
        "api_description": "A gate is supported on the qubit (qarg) or not.",
        "api_signature": "__gate_supported(self, gate, qarg)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/padding/dynamical_decoupling.py"
    },
    {
        "api_name": "__is_dd_qubit",
        "full_api_name": "PadDynamicalDecoupling.__is_dd_qubit",
        "api_description": "DD can be inserted in the qubit or not.",
        "api_signature": "__is_dd_qubit(self, qubit_index)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/padding/dynamical_decoupling.py"
    },
    {
        "api_name": "_pad",
        "full_api_name": "PadDynamicalDecoupling._pad",
        "api_description": "",
        "api_signature": "_pad(self, dag, qubit, t_start, t_end, next_node, prev_node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/padding/dynamical_decoupling.py"
    },
    {
        "api_name": "_constrained_length",
        "full_api_name": "PadDynamicalDecoupling._constrained_length",
        "api_description": "",
        "api_signature": "_constrained_length(values)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/padding/dynamical_decoupling.py"
    },
    {
        "api_name": "_resolve_params",
        "full_api_name": "PadDynamicalDecoupling._resolve_params",
        "api_description": "Return gate params with any bound parameters replaced with floats",
        "api_signature": "_resolve_params(gate)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/padding/dynamical_decoupling.py"
    },
    {
        "api_name": "_mod_2pi",
        "full_api_name": "PadDynamicalDecoupling._mod_2pi",
        "api_description": "Wrap angle into interval [-\u03c0,\u03c0). If within atol of the endpoint, clamp to -\u03c0",
        "api_signature": "_mod_2pi(angle, atol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/padding/dynamical_decoupling.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BasePadding.__init__",
        "api_description": "BasePadding initializer.\n\nArgs:\n    target: The :class:`~.Target` representing the target backend.\n        If it supplied and it does not support delay instruction on a qubit,\n        padding passes do not pad any idle time of the qubit.",
        "api_signature": "__init__(self, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/padding/base_padding.py"
    },
    {
        "api_name": "run",
        "full_api_name": "BasePadding.run",
        "api_description": "Run the padding pass on ``dag``.\n\nArgs:\n    dag: DAG to be checked.\n\nReturns:\n    DAGCircuit: DAG with idle time filled with instructions.\n\nRaises:\n    TranspilerError: When a particular node is not scheduled, likely some transform pass\n        is inserted before this node is called.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/padding/base_padding.py"
    },
    {
        "api_name": "__delay_supported",
        "full_api_name": "BasePadding.__delay_supported",
        "api_description": "Delay operation is supported on the qubit (qarg) or not.",
        "api_signature": "__delay_supported(self, qarg)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/padding/base_padding.py"
    },
    {
        "api_name": "_pre_runhook",
        "full_api_name": "BasePadding._pre_runhook",
        "api_description": "Extra routine inserted before running the padding pass.\n\nArgs:\n    dag: DAG circuit on which the sequence is applied.\n\nRaises:\n    TranspilerError: If the whole circuit or instruction is not scheduled.",
        "api_signature": "_pre_runhook(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/padding/base_padding.py"
    },
    {
        "api_name": "_apply_scheduled_op",
        "full_api_name": "BasePadding._apply_scheduled_op",
        "api_description": "Add new operation to DAG with scheduled information.\n\nThis is identical to apply_operation_back + updating the node_start_time propety.\n\nArgs:\n    dag: DAG circuit on which the sequence is applied.\n    t_start: Start time of new node.\n    oper: New operation that is added to the DAG circuit.\n    qubits: The list of qubits that the operation acts on.\n    clbits: The list of clbits that the operation acts on.",
        "api_signature": "_apply_scheduled_op(self, dag, t_start, oper, qubits, clbits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/padding/base_padding.py"
    },
    {
        "api_name": "_pad",
        "full_api_name": "BasePadding._pad",
        "api_description": "Interleave instruction sequence in between two nodes.\n\n.. note::\n    If a DAGOpNode is added here, it should update node_start_time property\n    in the property set so that the added node is also scheduled.\n    This is achieved by adding operation via :meth:`_apply_scheduled_op`.\n\n.. note::\n\n    This method doesn't check if the total duration of new DAGOpNode added here\n    is identical to the interval (``t_end - t_start``).\n    A developer of the pass must guarantee this is satisfied.\n    If the duration is greater than the interval, your circuit may be\n    compiled down to the target code with extra duration on the backend compiler,\n    which is then played normally without error. However, the outcome of your circuit\n    might be unexpected due to erroneous scheduling.\n\nArgs:\n    dag: DAG circuit that sequence is applied.\n    qubit: The wire that the sequence is applied on.\n    t_start: Absolute start time of this interval.\n    t_end: Absolute end time of this interval.\n    next_node: Node that follows the sequence.\n    prev_node: Node ahead of the sequence.",
        "api_signature": "_pad(self, dag, qubit, t_start, t_end, next_node, prev_node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/padding/base_padding.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PadDelay.__init__",
        "api_description": "Create new padding delay pass.\n\nArgs:\n    fill_very_end: Set ``True`` to fill the end of circuit with delay.\n    target: The :class:`~.Target` representing the target backend.\n        If it supplied and it does not support delay instruction on a qubit,\n        padding passes do not pad any idle time of the qubit.",
        "api_signature": "__init__(self, fill_very_end, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/padding/pad_delay.py"
    },
    {
        "api_name": "_pad",
        "full_api_name": "PadDelay._pad",
        "api_description": "",
        "api_signature": "_pad(self, dag, qubit, t_start, t_end, next_node, prev_node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/padding/pad_delay.py"
    },
    {
        "api_name": "run",
        "full_api_name": "ASAPScheduleAnalysis.run",
        "api_description": "Run the ASAPSchedule pass on `dag`.\n\nArgs:\n    dag (DAGCircuit): DAG to schedule.\n\nReturns:\n    DAGCircuit: A scheduled DAG.\n\nRaises:\n    TranspilerError: if the circuit is not mapped on physical qubits.\n    TranspilerError: if conditional bit is added to non-supported instruction.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/scheduling/asap.py"
    },
    {
        "api_name": "run",
        "full_api_name": "ALAPScheduleAnalysis.run",
        "api_description": "Run the ALAPSchedule pass on `dag`.\n\nArgs:\n    dag (DAGCircuit): DAG to schedule.\n\nReturns:\n    DAGCircuit: A scheduled DAG.\n\nRaises:\n    TranspilerError: if the circuit is not mapped on physical qubits.\n    TranspilerError: if conditional bit is added to non-supported instruction.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/scheduling/alap.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BaseScheduler.__init__",
        "api_description": "Scheduler initializer.\n\nArgs:\n    durations: Durations of instructions to be used in scheduling\n    target: The :class:`~.Target` representing the target backend, if both\n          ``durations`` and this are specified then this argument will take\n          precedence and ``durations`` will be ignored.",
        "api_signature": "__init__(self, durations, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/scheduling/base_scheduler.py"
    },
    {
        "api_name": "_get_node_duration",
        "full_api_name": "BaseScheduler._get_node_duration",
        "api_description": "A helper method to get duration from node or calibration.",
        "api_signature": "_get_node_duration(node, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/scheduling/base_scheduler.py"
    },
    {
        "api_name": "run",
        "full_api_name": "BaseScheduler.run",
        "api_description": "",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/scheduling/base_scheduler.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SetIOLatency.__init__",
        "api_description": "Create pass with latency information.\n\nArgs:\n    clbit_write_latency: A control flow constraints. Because standard superconducting\n        quantum processor implement dispersive QND readout, the actual data transfer\n        to the clbit happens after the round-trip stimulus signal is buffered\n        and discriminated into quantum state.\n        The interval ``[t0, t0 + clbit_write_latency]`` is regarded as idle time\n        for clbits associated with the measure instruction.\n        This defaults to 0 dt which is identical to Qiskit Pulse scheduler.\n    conditional_latency: A control flow constraints. This value represents\n        a latency of reading a classical register for the conditional operation.\n        The gate operation occurs after this latency. This appears as a delay\n        in front of the DAGOpNode of the gate.\n        This defaults to 0 dt.",
        "api_signature": "__init__(self, clbit_write_latency, conditional_latency)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/scheduling/set_io_latency.py"
    },
    {
        "api_name": "run",
        "full_api_name": "SetIOLatency.run",
        "api_description": "Add IO latency information.\n\nArgs:\n    dag: Input DAG circuit.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/scheduling/set_io_latency.py"
    },
    {
        "api_name": "cnot_synth",
        "full_api_name": "cnot_synth",
        "api_description": "Synthesize linear reversible circuits for all-to-all architecture\nusing Patel, Markov and Hayes method.\n\nThis function is an implementation of the Patel, Markov and Hayes algorithm from [1]\nfor optimal synthesis of linear reversible circuits for all-to-all architecture,\nas specified by an n x n matrix.\n\nArgs:\n    state (list[list] or ndarray): n x n boolean invertible matrix, describing the state\n        of the input circuit\n    section_size (int): the size of each section, used in the\n        Patel\u2013Markov\u2013Hayes algorithm [1]. section_size must be a factor of num_qubits.\n\nReturns:\n    QuantumCircuit: a CX-only circuit implementing the linear transformation.\n\nRaises:\n    QiskitError: when variable \"state\" isn't of type numpy.ndarray\n\nReferences:\n    1. Patel, Ketan N., Igor L. Markov, and John P. Hayes,\n       *Optimal synthesis of linear reversible circuits*,\n       Quantum Information & Computation 8.3 (2008): 282-294.\n       `arXiv:quant-ph/0302002 [quant-ph] <https://arxiv.org/abs/quant-ph/0302002>`_",
        "api_signature": "cnot_synth(state, section_size)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/graysynth.py"
    },
    {
        "api_name": "graysynth",
        "full_api_name": "graysynth",
        "api_description": "This function is an implementation of the GraySynth algorithm of\nAmy, Azimadeh and Mosca.\n\nGraySynth is a heuristic algorithm from [1] for synthesizing small parity networks.\nIt is inspired by Gray codes. Given a set of binary strings S\n(called \"cnots\" bellow), the algorithm synthesizes a parity network for S by\nrepeatedly choosing an index i to expand and then effectively recursing on\nthe co-factors S_0 and S_1, consisting of the strings y in S,\nwith y_i = 0 or 1 respectively. As a subset S is recursively expanded,\nCNOT gates are applied so that a designated target bit contains the\n(partial) parity ksi_y(x) where y_i = 1 if and only if y'_i = 1 for all\ny' in S. If S is a singleton {y'}, then y = y', hence the target bit contains\nthe value ksi_y'(x) as desired.\n\nNotably, rather than uncomputing this sequence of CNOT gates when a subset S\nis finished being synthesized, the algorithm maintains the invariant\nthat the remaining parities to be computed are expressed over the current state\nof bits. This allows the algorithm to avoid the 'backtracking' inherent in\nuncomputing-based methods.\n\nThe algorithm is described in detail in section 4 of [1].\n\nArgs:\n    cnots (list[list]): a matrix whose columns are the parities to be synthesized\n        e.g.::\n\n            [[0, 1, 1, 1, 1, 1],\n             [1, 0, 0, 1, 1, 1],\n             [1, 0, 0, 1, 0, 0],\n             [0, 0, 1, 0, 1, 0]]\n\n        corresponds to::\n\n             x1^x2 + x0 + x0^x3 + x0^x1^x2 + x0^x1^x3 + x0^x1\n\n    angles (list): a list containing all the phase-shift gates which are\n        to be applied, in the same order as in \"cnots\". A number is\n        interpreted as the angle of p(angle), otherwise the elements\n        have to be 't', 'tdg', 's', 'sdg' or 'z'.\n\n    section_size (int): the size of every section, used in _lwr_cnot_synth(), in the\n        Patel\u2013Markov\u2013Hayes algorithm. section_size must be a factor of num_qubits.\n\nReturns:\n    QuantumCircuit: the decomposed quantum circuit.\n\nRaises:\n    QiskitError: when dimensions of cnots and angles don't align.\n\nReferences:\n    1. Matthew Amy, Parsiad Azimzadeh, and Michele Mosca.\n       *On the controlled-NOT complexity of controlled-NOT\u2013phase circuits.*,\n       Quantum Science and Technology 4.1 (2018): 015002.\n       `arXiv:1712.01859 <https://arxiv.org/abs/1712.01859>`_",
        "api_signature": "graysynth(cnots, angles, section_size)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/graysynth.py"
    },
    {
        "api_name": "__call__",
        "full_api_name": "Minimizer.__call__",
        "api_description": "Minimize the objective function.\n\nThis interface is based on `SciPy's optimize module <https://docs.scipy.org/doc\n/scipy/reference/generated/scipy.optimize.minimize.html>`__.\n\nArgs:\n    fun: The objective function to minimize.\n    x0: The initial point for the optimization.\n    jac: The gradient of the objective function.\n    bounds: Parameters bounds for the optimization. Note that these might not be supported\n        by all optimizers.\n\nReturns:\n     The SciPy minimization result object.",
        "api_signature": "__call__(self, fun, x0, jac, bounds)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/aqc.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "AQC.__init__",
        "api_description": "Args:\n    optimizer: an optimizer to be used in the optimization procedure of the search for\n        the best approximate circuit. By default, the scipy minimizer with the\n        ``L-BFGS-B`` method is used with max iterations set to 1000.\n    seed: a seed value to be used by a random number generator.",
        "api_signature": "__init__(self, optimizer, seed)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/aqc.py"
    },
    {
        "api_name": "compile_unitary",
        "full_api_name": "AQC.compile_unitary",
        "api_description": "Approximately compiles a circuit represented as a unitary matrix by solving an optimization\nproblem defined by ``approximating_objective`` and using ``approximate_circuit`` as a\ntemplate for the approximate circuit.\n\nArgs:\n    target_matrix: a unitary matrix to approximate.\n    approximate_circuit: a template circuit that will be filled with the parameter values\n        obtained in the optimization procedure.\n    approximating_objective: a definition of the optimization problem.\n    initial_point: initial values of angles/parameters to start optimization from.",
        "api_signature": "compile_unitary(self, target_matrix, approximate_circuit, approximating_objective, initial_point)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/aqc.py"
    },
    {
        "api_name": "_lower_limit",
        "full_api_name": "_lower_limit",
        "api_description": "Returns lower limit on the number of CNOT units that guarantees exact representation of\na unitary operator by quantum gates.\n\nArgs:\n    num_qubits: number of qubits.\n\nReturns:\n    lower limit on the number of CNOT units.",
        "api_signature": "_lower_limit(num_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/cnot_structures.py"
    },
    {
        "api_name": "make_cnot_network",
        "full_api_name": "make_cnot_network",
        "api_description": "Generates a network consisting of building blocks each containing a CNOT gate and possibly some\nsingle-qubit ones. This network models a quantum operator in question. Note, each building\nblock has 2 input and outputs corresponding to a pair of qubits. What we actually return here\nis a chain of indices of qubit pairs shared by every building block in a row.\n\nArgs:\n    num_qubits: number of qubits.\n    network_layout: type of network geometry, ``{\"sequ\", \"spin\", \"cart\", \"cyclic_spin\",\n        \"cyclic_line\"}``.\n    connectivity_type: type of inter-qubit connectivity, ``{\"full\", \"line\", \"star\"}``.\n    depth: depth of the CNOT-network, i.e. the number of layers, where each layer consists of\n        a single CNOT-block; default value will be selected, if ``L <= 0``.\n\nReturns:\n    A matrix of size ``(2, N)`` matrix that defines layers in cnot-network, where ``N``\n        is either equal ``L``, or defined by a concrete type of the network.\n\nRaises:\n     ValueError: if unsupported type of CNOT-network layout or number of qubits or combination\n        of parameters are passed.",
        "api_signature": "make_cnot_network(num_qubits, network_layout, connectivity_type, depth)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/cnot_structures.py"
    },
    {
        "api_name": "_get_connectivity",
        "full_api_name": "_get_connectivity",
        "api_description": "Generates connectivity structure between qubits.\n\nArgs:\n    num_qubits: number of qubits.\n    connectivity: type of connectivity structure, ``{\"full\", \"line\", \"star\"}``.\n\nReturns:\n    dictionary of allowed links between qubits.\n\nRaises:\n     ValueError: if unsupported type of CNOT-network layout is passed.",
        "api_signature": "_get_connectivity(num_qubits, connectivity)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/cnot_structures.py"
    },
    {
        "api_name": "_sequential_network",
        "full_api_name": "_sequential_network",
        "api_description": "Generates a sequential network.\n\nArgs:\n    num_qubits: number of qubits.\n    links: dictionary of connectivity links.\n    depth: depth of the network (number of layers of building blocks).\n\nReturns:\n    A matrix of ``(2, N)`` that defines layers in qubit network.",
        "api_signature": "_sequential_network(num_qubits, links, depth)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/cnot_structures.py"
    },
    {
        "api_name": "_spin_network",
        "full_api_name": "_spin_network",
        "api_description": "Generates a spin-like network.\n\nArgs:\n    num_qubits: number of qubits.\n    depth: depth of the network (number of layers of building blocks).\n\nReturns:\n    A matrix of size ``2 x L`` that defines layers in qubit network.",
        "api_signature": "_spin_network(num_qubits, depth)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/cnot_structures.py"
    },
    {
        "api_name": "_cartan_network",
        "full_api_name": "_cartan_network",
        "api_description": "Cartan decomposition in a recursive way, starting from n = 3.\n\nArgs:\n    num_qubits: number of qubits.\n\nReturns:\n    2xN matrix that defines layers in qubit network, where N is the\n         depth of Cartan decomposition.\n\nRaises:\n    ValueError: if number of qubits is less than 3.",
        "api_signature": "_cartan_network(num_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/cnot_structures.py"
    },
    {
        "api_name": "_cyclic_spin_network",
        "full_api_name": "_cyclic_spin_network",
        "api_description": "Same as in the spin-like network, but the first and the last qubits are also connected.\n\nArgs:\n    num_qubits: number of qubits.\n    depth: depth of the network (number of layers of building blocks).\n\nReturns:\n    A matrix of size ``2 x L`` that defines layers in qubit network.",
        "api_signature": "_cyclic_spin_network(num_qubits, depth)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/cnot_structures.py"
    },
    {
        "api_name": "_cyclic_line_network",
        "full_api_name": "_cyclic_line_network",
        "api_description": "Generates a line based CNOT structure.\n\nArgs:\n    num_qubits: number of qubits.\n    depth: depth of the network (number of layers of building blocks).\n\nReturns:\n    A matrix of size ``2 x L`` that defines layers in qubit network.",
        "api_signature": "_cyclic_line_network(num_qubits, depth)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/cnot_structures.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ApproximateCircuit.__init__",
        "api_description": "Args:\n    num_qubits: number of qubit this circuit will span.\n    name: a name of the circuit.",
        "api_signature": "__init__(self, num_qubits, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/approximate.py"
    },
    {
        "api_name": "thetas",
        "full_api_name": "ApproximateCircuit.thetas",
        "api_description": "The property is not implemented and raises a ``NotImplementedException`` exception.\n\nReturns:\n    a vector of parameters of this circuit.",
        "api_signature": "thetas(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/approximate.py"
    },
    {
        "api_name": "build",
        "full_api_name": "ApproximateCircuit.build",
        "api_description": "Constructs this circuit out of the parameters(thetas). Parameter values must be set before\n    constructing the circuit.\n\nArgs:\n    thetas: a vector of parameters to be set in this circuit.",
        "api_signature": "build(self, thetas)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/approximate.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ApproximatingObjective.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/approximate.py"
    },
    {
        "api_name": "objective",
        "full_api_name": "ApproximatingObjective.objective",
        "api_description": "Computes a value of the objective function given a vector of parameter values.\n\nArgs:\n    param_values: a vector of parameter values for the optimization problem.\n\nReturns:\n    a float value of the objective function.",
        "api_signature": "objective(self, param_values)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/approximate.py"
    },
    {
        "api_name": "gradient",
        "full_api_name": "ApproximatingObjective.gradient",
        "api_description": "Computes a gradient with respect to parameters given a vector of parameter values.\n\nArgs:\n    param_values: a vector of parameter values for the optimization problem.\n\nReturns:\n    an array of gradient values.",
        "api_signature": "gradient(self, param_values)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/approximate.py"
    },
    {
        "api_name": "target_matrix",
        "full_api_name": "ApproximatingObjective.target_matrix",
        "api_description": "Returns:\n    a matrix being approximated",
        "api_signature": "target_matrix(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/approximate.py"
    },
    {
        "api_name": "target_matrix",
        "full_api_name": "ApproximatingObjective.target_matrix",
        "api_description": "Args:\n    target_matrix: a matrix to approximate in the optimization procedure.",
        "api_signature": "target_matrix(self, target_matrix)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/approximate.py"
    },
    {
        "api_name": "num_thetas",
        "full_api_name": "ApproximatingObjective.num_thetas",
        "api_description": "Returns:\n    the number of parameters in this optimization problem.",
        "api_signature": "num_thetas(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/approximate.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CNOTUnitObjective.__init__",
        "api_description": "Args:\n    num_qubits: number of qubits.\n    cnots: a CNOT structure to be used in the optimization procedure.",
        "api_signature": "__init__(self, num_qubits, cnots)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/cnot_unit_objective.py"
    },
    {
        "api_name": "num_cnots",
        "full_api_name": "CNOTUnitObjective.num_cnots",
        "api_description": "Returns:\n    A number of CNOT units to be used by the approximate circuit.",
        "api_signature": "num_cnots(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/cnot_unit_objective.py"
    },
    {
        "api_name": "num_thetas",
        "full_api_name": "CNOTUnitObjective.num_thetas",
        "api_description": "Returns:\n    Number of parameters (angles) of rotation gates in this circuit.",
        "api_signature": "num_thetas(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/cnot_unit_objective.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "DefaultCNOTUnitObjective.__init__",
        "api_description": "Args:\n    num_qubits: number of qubits.\n    cnots: a CNOT structure to be used in the optimization procedure.",
        "api_signature": "__init__(self, num_qubits, cnots)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/cnot_unit_objective.py"
    },
    {
        "api_name": "objective",
        "full_api_name": "DefaultCNOTUnitObjective.objective",
        "api_description": "",
        "api_signature": "objective(self, param_values)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/cnot_unit_objective.py"
    },
    {
        "api_name": "gradient",
        "full_api_name": "DefaultCNOTUnitObjective.gradient",
        "api_description": "",
        "api_signature": "gradient(self, param_values)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/cnot_unit_objective.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CNOTUnitCircuit.__init__",
        "api_description": "Args:\n    num_qubits: the number of qubits in this circuit.\n    cnots: an array of dimensions ``(2, L)`` indicating where the CNOT units will be placed.\n    tol: angle parameter less or equal this (small) value is considered equal zero and\n        corresponding gate is not inserted into the output circuit (because it becomes\n        identity one in this case).\n    name: name of this circuit\n\nRaises:\n    ValueError: if an unsupported parameter is passed.",
        "api_signature": "__init__(self, num_qubits, cnots, tol, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/cnot_unit_circuit.py"
    },
    {
        "api_name": "thetas",
        "full_api_name": "CNOTUnitCircuit.thetas",
        "api_description": "Returns a vector of rotation angles used by CNOT units in this circuit.\n\nReturns:\n    Parameters of the rotation gates in this circuit.",
        "api_signature": "thetas(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/cnot_unit_circuit.py"
    },
    {
        "api_name": "build",
        "full_api_name": "CNOTUnitCircuit.build",
        "api_description": "Constructs a Qiskit quantum circuit out of the parameters (angles) of this circuit. If a\n    parameter value is less in absolute value than the specified tolerance then the\n    corresponding rotation gate will be skipped in the circuit.",
        "api_signature": "build(self, thetas)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/cnot_unit_circuit.py"
    },
    {
        "api_name": "place_unitary",
        "full_api_name": "place_unitary",
        "api_description": "Computes I(j - 1) tensor product U tensor product I(n - j), where U is a unitary matrix\nof size ``(2, 2)``.\n\nArgs:\n    unitary: a unitary matrix of size ``(2, 2)``.\n    n: num qubits.\n    j: position where to place a unitary.\n\nReturns:\n    a unitary of n qubits with u in position j.",
        "api_signature": "place_unitary(unitary, n, j)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/elementary_operations.py"
    },
    {
        "api_name": "place_cnot",
        "full_api_name": "place_cnot",
        "api_description": "Places a CNOT from j to k.\n\nArgs:\n    n: number of qubits.\n    j: control qubit.\n    k: target qubit.\n\nReturns:\n    a unitary of n qubits with CNOT placed at ``j`` and ``k``.",
        "api_signature": "place_cnot(n, j, k)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/elementary_operations.py"
    },
    {
        "api_name": "rx_matrix",
        "full_api_name": "rx_matrix",
        "api_description": "Computes an RX rotation by the angle of ``phi``.\n\nArgs:\n    phi: rotation angle.\n\nReturns:\n    an RX rotation matrix.",
        "api_signature": "rx_matrix(phi)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/elementary_operations.py"
    },
    {
        "api_name": "ry_matrix",
        "full_api_name": "ry_matrix",
        "api_description": "Computes an RY rotation by the angle of ``phi``.\n\nArgs:\n    phi: rotation angle.\n\nReturns:\n    an RY rotation matrix.",
        "api_signature": "ry_matrix(phi)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/elementary_operations.py"
    },
    {
        "api_name": "rz_matrix",
        "full_api_name": "rz_matrix",
        "api_description": "Computes an RZ rotation by the angle of ``phi``.\n\nArgs:\n    phi: rotation angle.\n\nReturns:\n    an RZ rotation matrix.",
        "api_signature": "rz_matrix(phi)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/elementary_operations.py"
    },
    {
        "api_name": "max_qubits",
        "full_api_name": "AQCSynthesisPlugin.max_qubits",
        "api_description": "Maximum number of supported qubits is ``14``.",
        "api_signature": "max_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/aqc_plugin.py"
    },
    {
        "api_name": "min_qubits",
        "full_api_name": "AQCSynthesisPlugin.min_qubits",
        "api_description": "Minimum number of supported qubits is ``3``.",
        "api_signature": "min_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/aqc_plugin.py"
    },
    {
        "api_name": "supports_natural_direction",
        "full_api_name": "AQCSynthesisPlugin.supports_natural_direction",
        "api_description": "The plugin does not support natural direction,\nit assumes bidirectional two qubit gates.",
        "api_signature": "supports_natural_direction(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/aqc_plugin.py"
    },
    {
        "api_name": "supports_pulse_optimize",
        "full_api_name": "AQCSynthesisPlugin.supports_pulse_optimize",
        "api_description": "The plugin does not support optimization of pulses.",
        "api_signature": "supports_pulse_optimize(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/aqc_plugin.py"
    },
    {
        "api_name": "supports_gate_lengths",
        "full_api_name": "AQCSynthesisPlugin.supports_gate_lengths",
        "api_description": "The plugin does not support gate lengths.",
        "api_signature": "supports_gate_lengths(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/aqc_plugin.py"
    },
    {
        "api_name": "supports_gate_errors",
        "full_api_name": "AQCSynthesisPlugin.supports_gate_errors",
        "api_description": "The plugin does not support gate errors.",
        "api_signature": "supports_gate_errors(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/aqc_plugin.py"
    },
    {
        "api_name": "supported_bases",
        "full_api_name": "AQCSynthesisPlugin.supported_bases",
        "api_description": "The plugin does not support bases for synthesis.",
        "api_signature": "supported_bases(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/aqc_plugin.py"
    },
    {
        "api_name": "supports_basis_gates",
        "full_api_name": "AQCSynthesisPlugin.supports_basis_gates",
        "api_description": "The plugin does not support basis gates and by default it synthesizes a circuit using\n``[\"rx\", \"ry\", \"rz\", \"cx\"]`` gate basis.",
        "api_signature": "supports_basis_gates(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/aqc_plugin.py"
    },
    {
        "api_name": "supports_coupling_map",
        "full_api_name": "AQCSynthesisPlugin.supports_coupling_map",
        "api_description": "The plugin does not support coupling maps.",
        "api_signature": "supports_coupling_map(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/aqc_plugin.py"
    },
    {
        "api_name": "run",
        "full_api_name": "AQCSynthesisPlugin.run",
        "api_description": "",
        "api_signature": "run(self, unitary)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/aqc_plugin.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "FastCNOTUnitObjective.__init__",
        "api_description": "",
        "api_signature": "__init__(self, num_qubits, cnots)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/fast_gradient/fast_gradient.py"
    },
    {
        "api_name": "objective",
        "full_api_name": "FastCNOTUnitObjective.objective",
        "api_description": "Computes the objective function and some intermediate data for\nthe subsequent gradient computation.\nSee description of the base class method.",
        "api_signature": "objective(self, param_values)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/fast_gradient/fast_gradient.py"
    },
    {
        "api_name": "gradient",
        "full_api_name": "FastCNOTUnitObjective.gradient",
        "api_description": "Computes the gradient of objective function.\nSee description of the base class method.",
        "api_signature": "gradient(self, param_values)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/fast_gradient/fast_gradient.py"
    },
    {
        "api_name": "_init_layers",
        "full_api_name": "FastCNOTUnitObjective._init_layers",
        "api_description": "Initializes C-layers and F-layers by corresponding gate matrices.",
        "api_signature": "_init_layers(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/fast_gradient/fast_gradient.py"
    },
    {
        "api_name": "_calc_ucf_fuc",
        "full_api_name": "FastCNOTUnitObjective._calc_ucf_fuc",
        "api_description": "Computes matrices ``ucf_mat`` and ``fuc_mat``. Both remain non-finalized.",
        "api_signature": "_calc_ucf_fuc(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/fast_gradient/fast_gradient.py"
    },
    {
        "api_name": "_calc_objective_function",
        "full_api_name": "FastCNOTUnitObjective._calc_objective_function",
        "api_description": "Computes the value of objective function.",
        "api_signature": "_calc_objective_function(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/fast_gradient/fast_gradient.py"
    },
    {
        "api_name": "_calc_gradient4d",
        "full_api_name": "FastCNOTUnitObjective._calc_gradient4d",
        "api_description": "Calculates a part gradient contributed by 2-qubit gates.",
        "api_signature": "_calc_gradient4d(self, grad4d)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/fast_gradient/fast_gradient.py"
    },
    {
        "api_name": "_calc_gradient3n",
        "full_api_name": "FastCNOTUnitObjective._calc_gradient3n",
        "api_description": "Calculates a part gradient contributed by 1-qubit gates.",
        "api_signature": "_calc_gradient3n(self, grad3n)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/fast_gradient/fast_gradient.py"
    },
    {
        "api_name": "is_permutation",
        "full_api_name": "is_permutation",
        "api_description": "Checks if array is really an index permutation.\n\nArgs:\n    1D-array of integers that supposedly represents a permutation.\n\nReturns:\n    True, if array is really a permutation of indices.",
        "api_signature": "is_permutation(x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/fast_gradient/fast_grad_utils.py"
    },
    {
        "api_name": "reverse_bits",
        "full_api_name": "reverse_bits",
        "api_description": "Reverses the bit order in a number of ``nbits`` length.\nIf ``x`` is an array, then operation is applied to every entry.\n\nArgs:\n    x: either a single integer or an array of integers.\n    nbits: number of meaningful bits in the number x.\n    enable: apply reverse operation, if enabled, otherwise leave unchanged.\n\nReturns:\n    a number or array of numbers with reversed bits.",
        "api_signature": "reverse_bits(x, nbits, enable)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/fast_gradient/fast_grad_utils.py"
    },
    {
        "api_name": "swap_bits",
        "full_api_name": "swap_bits",
        "api_description": "Swaps the bits at positions 'a' and 'b' in the number 'num'.\n\nArgs:\n    num: an integer number where bits should be swapped.\n    a: index of the first bit to be swapped.\n    b: index of the second bit to be swapped.\n\nReturns:\n    the number with swapped bits.",
        "api_signature": "swap_bits(num, a, b)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/fast_gradient/fast_grad_utils.py"
    },
    {
        "api_name": "bit_permutation_1q",
        "full_api_name": "bit_permutation_1q",
        "api_description": "Constructs index permutation that brings a circuit consisting of a single\n1-qubit gate to \"standard form\": ``kron(I(2^n/2), G)``, as we call it. Here n\nis the number of qubits, ``G`` is a 2x2 gate matrix, ``I(2^n/2)`` is the identity\nmatrix of size ``(2^n/2)x(2^n/2)``, and the full size of the circuit matrix is\n``(2^n)x(2^n)``. Circuit matrix in standard form becomes block-diagonal (with\nsub-matrices ``G`` on the main diagonal). Multiplication of such a matrix and\na dense one is much faster than generic dense-dense product. Moreover,\nwe do not need to keep the entire circuit matrix in memory but just 2x2 ``G``\none. This saves a lot of memory when the number of qubits is large.\n\nArgs:\n    n: number of qubits.\n    k: index of qubit where single 1-qubit gate is applied.\n\nReturns:\n    permutation that brings the whole layer to the standard form.",
        "api_signature": "bit_permutation_1q(n, k)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/fast_gradient/fast_grad_utils.py"
    },
    {
        "api_name": "bit_permutation_2q",
        "full_api_name": "bit_permutation_2q",
        "api_description": "Constructs index permutation that brings a circuit consisting of a single\n2-qubit gate to \"standard form\": ``kron(I(2^n/4), G)``, as we call it. Here ``n``\nis the number of qubits, ``G`` is a 4x4 gate matrix, ``I(2^n/4)`` is the identity\nmatrix of size ``(2^n/4)x(2^n/4)``, and the full size of the circuit matrix is\n``(2^n)x(2^n)``. Circuit matrix in standard form becomes block-diagonal (with\nsub-matrices ``G`` on the main diagonal). Multiplication of such a matrix and\na dense one is much faster than generic dense-dense product. Moreover,\nwe do not need to keep the entire circuit matrix in memory but just 4x4 ``G``\none. This saves a lot of memory when the number of qubits is large.\n\nArgs:\n    n: number of qubits.\n    j: index of control qubit where single 2-qubit gate is applied.\n    k: index of target qubit where single 2-qubit gate is applied.\n\nReturns:\n    permutation that brings the whole layer to the standard form.",
        "api_signature": "bit_permutation_2q(n, j, k)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/fast_gradient/fast_grad_utils.py"
    },
    {
        "api_name": "inverse_permutation",
        "full_api_name": "inverse_permutation",
        "api_description": "Returns inverse permutation.\n\nArgs:\n    perm: permutation to be reversed.\n\nReturns:\n    inverse permutation.",
        "api_signature": "inverse_permutation(perm)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/fast_gradient/fast_grad_utils.py"
    },
    {
        "api_name": "make_rx",
        "full_api_name": "make_rx",
        "api_description": "Makes a 2x2 matrix that corresponds to X-rotation gate.\nThis is a fast implementation that does not allocate the output matrix.\n\nArgs:\n    phi: rotation angle.\n    out: placeholder for the result (2x2, complex-valued matrix).\n\nReturns:\n    rotation gate, same object as referenced by \"out\".",
        "api_signature": "make_rx(phi, out)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/fast_gradient/fast_grad_utils.py"
    },
    {
        "api_name": "make_ry",
        "full_api_name": "make_ry",
        "api_description": "Makes a 2x2 matrix that corresponds to Y-rotation gate.\nThis is a fast implementation that does not allocate the output matrix.\n\nArgs:\n    phi: rotation angle.\n    out: placeholder for the result (2x2, complex-valued matrix).\n\nReturns:\n    rotation gate, same object as referenced by \"out\".",
        "api_signature": "make_ry(phi, out)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/fast_gradient/fast_grad_utils.py"
    },
    {
        "api_name": "make_rz",
        "full_api_name": "make_rz",
        "api_description": "Makes a 2x2 matrix that corresponds to Z-rotation gate.\nThis is a fast implementation that does not allocate the output matrix.\n\nArgs:\n    phi: rotation angle.\n    out: placeholder for the result (2x2, complex-valued matrix).\n\nReturns:\n    rotation gate, same object as referenced by \"out\".",
        "api_signature": "make_rz(phi, out)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/fast_gradient/fast_grad_utils.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PMatrix.__init__",
        "api_description": "Initializes the internal structures of this object but does not set\nthe matrix yet.\n\nArgs:\n    num_qubits: number of qubits.",
        "api_signature": "__init__(self, num_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/fast_gradient/pmatrix.py"
    },
    {
        "api_name": "set_matrix",
        "full_api_name": "PMatrix.set_matrix",
        "api_description": "Copies specified matrix to internal storage. Once the matrix\nis set, the object is ready for use.\n\n**Note**, the matrix will be copied, mind the size issues.\n\nArgs:\n    mat: matrix we want to multiply on the left and on the right by\n         layer matrices.",
        "api_signature": "set_matrix(self, mat)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/fast_gradient/pmatrix.py"
    },
    {
        "api_name": "_init_index_matrix",
        "full_api_name": "PMatrix._init_index_matrix",
        "api_description": "Fast multiplication can be implemented by picking up a subset of\nentries in a sparse matrix.\n\nArgs:\n    dim: problem dimensionality.\n\nReturns:\n    2d-array of indices for the fast multiplication.",
        "api_signature": "_init_index_matrix(dim)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/fast_gradient/pmatrix.py"
    },
    {
        "api_name": "mul_right_q1",
        "full_api_name": "PMatrix.mul_right_q1",
        "api_description": "Multiplies ``NxN`` matrix, wrapped by this object, by a 1-qubit layer\nmatrix of the right, where ``N`` is the actual size of matrices involved,\n``N = 2^{num. of qubits}``.\n\nArgs:\n    layer: 1-qubit layer, i.e. the layer with just one non-trivial\n           1-qubit gate and other gates are just identity operators.\n    temp_mat: a temporary NxN matrix used as a workspace.\n    dagger: if true, the right-hand side matrix will be taken as\n            conjugate transposed.",
        "api_signature": "mul_right_q1(self, layer, temp_mat, dagger)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/fast_gradient/pmatrix.py"
    },
    {
        "api_name": "mul_right_q2",
        "full_api_name": "PMatrix.mul_right_q2",
        "api_description": "Multiplies ``NxN`` matrix, wrapped by this object, by a 2-qubit layer\nmatrix on the right, where ``N`` is the actual size of matrices involved,\n``N = 2^{num. of qubits}``.\n\nArgs:\n    layer: 2-qubit layer, i.e. the layer with just one non-trivial\n           2-qubit gate and other gates are just identity operators.\n    temp_mat: a temporary NxN matrix used as a workspace.\n    dagger: if true, the right-hand side matrix will be taken as\n            conjugate transposed.",
        "api_signature": "mul_right_q2(self, layer, temp_mat, dagger)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/fast_gradient/pmatrix.py"
    },
    {
        "api_name": "mul_left_q1",
        "full_api_name": "PMatrix.mul_left_q1",
        "api_description": "Multiplies ``NxN`` matrix, wrapped by this object, by a 1-qubit layer\nmatrix of the left, where ``dim`` is the actual size of matrices involved,\n``dim = 2^{num. of qubits}``.\n\nArgs:\n    layer: 1-qubit layer, i.e. the layer with just one non-trivial\n           1-qubit gate and other gates are just identity operators.\n    temp_mat: a temporary NxN matrix used as a workspace.",
        "api_signature": "mul_left_q1(self, layer, temp_mat)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/fast_gradient/pmatrix.py"
    },
    {
        "api_name": "mul_left_q2",
        "full_api_name": "PMatrix.mul_left_q2",
        "api_description": "Multiplies ``NxN`` matrix, wrapped by this object, by a 2-qubit layer\nmatrix on the left, where ``dim`` is the actual size of matrices involved,\n``dim = 2^{num. of qubits}``.\n\nArgs:\n    layer: 2-qubit layer, i.e. the layer with just one non-trivial\n           2-qubit gate and other gates are just identity operators.\n    temp_mat: a temporary NxN matrix used as a workspace.",
        "api_signature": "mul_left_q2(self, layer, temp_mat)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/fast_gradient/pmatrix.py"
    },
    {
        "api_name": "product_q1",
        "full_api_name": "PMatrix.product_q1",
        "api_description": "Computes and returns: ``Trace(mat @ C) = Trace(mat @ P^T @ gmat @ P) =\nTrace((P @ mat @ P^T) @ gmat) = Trace(C @ (P @ mat @ P^T)) =\nvec(gmat^T)^T @ vec(P @ mat @ P^T)``, where mat is ``NxN`` matrix wrapped\nby this object, ``C`` is matrix representation of the layer ``L``, and gmat\nis 2x2 matrix of underlying 1-qubit gate.\n\n**Note**: matrix of this class must be finalized beforehand.\n\nArgs:\n    layer: 1-qubit layer.\n    tmp1: temporary, external matrix used as a workspace.\n    tmp2: temporary, external matrix used as a workspace.\n\nReturns:\n    trace of the matrix product.",
        "api_signature": "product_q1(self, layer, tmp1, tmp2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/fast_gradient/pmatrix.py"
    },
    {
        "api_name": "product_q2",
        "full_api_name": "PMatrix.product_q2",
        "api_description": "Computes and returns: ``Trace(mat @ C) = Trace(mat @ P^T @ gmat @ P) =\nTrace((P @ mat @ P^T) @ gmat) = Trace(C @ (P @ mat @ P^T)) =\nvec(gmat^T)^T @ vec(P @ mat @ P^T)``, where mat is ``NxN`` matrix wrapped\nby this object, ``C`` is matrix representation of the layer ``L``, and gmat\nis 4x4 matrix of underlying 2-qubit gate.\n\n**Note**: matrix of this class must be finalized beforehand.\n\nArgs:\n    layer: 2-qubit layer.\n    tmp1: temporary, external matrix used as a workspace.\n    tmp2: temporary, external matrix used as a workspace.\n\nReturns:\n    trace of the matrix product.",
        "api_signature": "product_q2(self, layer, tmp1, tmp2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/fast_gradient/pmatrix.py"
    },
    {
        "api_name": "finalize",
        "full_api_name": "PMatrix.finalize",
        "api_description": "Applies the left (row) and right (column) permutations to the matrix.\nat the end of computation process.\n\nArgs:\n    temp_mat: temporary, external matrix.\n\nReturns:\n    finalized matrix with all transformations applied.",
        "api_signature": "finalize(self, temp_mat)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/fast_gradient/pmatrix.py"
    },
    {
        "api_name": "set_from_matrix",
        "full_api_name": "LayerBase.set_from_matrix",
        "api_description": "Updates this layer from an external gate matrix.\n\nArgs:\n    mat: external gate matrix that initializes this layer's one.",
        "api_signature": "set_from_matrix(self, mat)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/fast_gradient/layer.py"
    },
    {
        "api_name": "get_attr",
        "full_api_name": "LayerBase.get_attr",
        "api_description": "Returns gate matrix, direct and inverse permutations.\n\nReturns:\n    (1) gate matrix; (2) direct permutation; (3) inverse permutations.",
        "api_signature": "get_attr(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/fast_gradient/layer.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Layer1Q.__init__",
        "api_description": "Args:\n    num_qubits: number of qubits.\n    k: index of the bit where gate is applied.\n    g2x2: 2x2 matrix that makes up this layer along with identity ones,\n          or None (should be set up later).",
        "api_signature": "__init__(self, num_qubits, k, g2x2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/fast_gradient/layer.py"
    },
    {
        "api_name": "set_from_matrix",
        "full_api_name": "Layer1Q.set_from_matrix",
        "api_description": "See base class description.",
        "api_signature": "set_from_matrix(self, mat)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/fast_gradient/layer.py"
    },
    {
        "api_name": "get_attr",
        "full_api_name": "Layer1Q.get_attr",
        "api_description": "See base class description.",
        "api_signature": "get_attr(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/fast_gradient/layer.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Layer2Q.__init__",
        "api_description": "Args:\n    num_qubits: number of qubits.\n    j: index of the first (control) bit.\n    k: index of the second (target) bit.\n    g4x4: 4x4 matrix that makes up this layer along with identity ones,\n          or None (should be set up later).",
        "api_signature": "__init__(self, num_qubits, j, k, g4x4)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/fast_gradient/layer.py"
    },
    {
        "api_name": "set_from_matrix",
        "full_api_name": "Layer2Q.set_from_matrix",
        "api_description": "See base class description.",
        "api_signature": "set_from_matrix(self, mat)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/fast_gradient/layer.py"
    },
    {
        "api_name": "get_attr",
        "full_api_name": "Layer2Q.get_attr",
        "api_description": "See base class description.",
        "api_signature": "get_attr(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/fast_gradient/layer.py"
    },
    {
        "api_name": "init_layer1q_matrices",
        "full_api_name": "init_layer1q_matrices",
        "api_description": "Initializes 4x4 matrices of 2-qubit gates defined in the paper.\n\nArgs:\n    thetas: depth x 4 matrix of gate parameters for every layer, where\n            \"depth\" is the number of layers.\n    dst: destination array of size depth x 4 x 4 that will receive gate\n         matrices of each layer.\n\nReturns:\n    Returns the \"dst\" array.",
        "api_signature": "init_layer1q_matrices(thetas, dst)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/fast_gradient/layer.py"
    },
    {
        "api_name": "init_layer1q_deriv_matrices",
        "full_api_name": "init_layer1q_deriv_matrices",
        "api_description": "Initializes 4x4 derivative matrices of 2-qubit gates defined in the paper.\n\nArgs:\n    thetas: depth x 4 matrix of gate parameters for every layer, where\n            \"depth\" is the number of layers.\n    dst: destination array of size depth x 4 x 4 x 4 that will receive gate\n         derivative matrices of each layer; there are 4 parameters per gate,\n         hence, 4 derivative matrices per layer.\n\nReturns:\n    Returns the \"dst\" array.",
        "api_signature": "init_layer1q_deriv_matrices(thetas, dst)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/fast_gradient/layer.py"
    },
    {
        "api_name": "init_layer2q_matrices",
        "full_api_name": "init_layer2q_matrices",
        "api_description": "Initializes 4x4 matrices of 2-qubit gates defined in the paper.\n\nArgs:\n    thetas: depth x 4 matrix of gate parameters for every layer, where\n            \"depth\" is the number of layers.\n    dst: destination array of size depth x 4 x 4 that will receive gate\n         matrices of each layer.\n\nReturns:\n    Returns the \"dst\" array.",
        "api_signature": "init_layer2q_matrices(thetas, dst)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/fast_gradient/layer.py"
    },
    {
        "api_name": "init_layer2q_deriv_matrices",
        "full_api_name": "init_layer2q_deriv_matrices",
        "api_description": "Initializes 4 x 4 derivative matrices of 2-qubit gates defined in the paper.\n\nArgs:\n    thetas: depth x 4 matrix of gate parameters for every layer, where\n            \"depth\" is the number of layers.\n    dst: destination array of size depth x 4 x 4 x 4 that will receive gate\n         derivative matrices of each layer; there are 4 parameters per gate,\n         hence, 4 derivative matrices per layer.\n\nReturns:\n    Returns the \"dst\" array.",
        "api_signature": "init_layer2q_deriv_matrices(thetas, dst)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/synthesis/aqc/fast_gradient/layer.py"
    },
    {
        "api_name": "execute",
        "full_api_name": "Task.execute",
        "api_description": "Execute optimization task for input Qiskit IR.\n\nArgs:\n    passmanager_ir: Qiskit IR to optimize.\n    state: State associated with workflow execution by the pass manager itself.\n    callback: A callback function which is caller per execution of optimization task.\n\nReturns:\n    Optimized Qiskit IR and state of the workflow.",
        "api_signature": "execute(self, passmanager_ir, state, callback)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/passmanager/base_tasks.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "GenericPass.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/passmanager/base_tasks.py"
    },
    {
        "api_name": "name",
        "full_api_name": "GenericPass.name",
        "api_description": "Name of the pass.",
        "api_signature": "name(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/passmanager/base_tasks.py"
    },
    {
        "api_name": "execute",
        "full_api_name": "GenericPass.execute",
        "api_description": "",
        "api_signature": "execute(self, passmanager_ir, state, callback)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/passmanager/base_tasks.py"
    },
    {
        "api_name": "update_status",
        "full_api_name": "GenericPass.update_status",
        "api_description": "Update workflow status.\n\nArgs:\n    state: Pass manager state to update.\n    run_state: Completion status of current task.\n\nReturns:\n    Updated pass manager state.",
        "api_signature": "update_status(self, state, run_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/passmanager/base_tasks.py"
    },
    {
        "api_name": "run",
        "full_api_name": "GenericPass.run",
        "api_description": "Run optimization task.\n\nArgs:\n    passmanager_ir: Qiskit IR to optimize.\n\nReturns:\n    Optimized Qiskit IR.",
        "api_signature": "run(self, passmanager_ir)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/passmanager/base_tasks.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BaseController.__init__",
        "api_description": "Create new flow controller.\n\nArgs:\n    options: Option for this flow controller.",
        "api_signature": "__init__(self, options)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/passmanager/base_tasks.py"
    },
    {
        "api_name": "iter_tasks",
        "full_api_name": "BaseController.iter_tasks",
        "api_description": "A custom logic to choose a next task to run.\n\nController subclass can consume the state to build a proper task pipeline.  The updated\nstate after a task execution will be fed back in as the \"return\" value of any ``yield``\nstatements.  This indicates the order of task execution is only determined at running time.\nThis method is not allowed to mutate the given state object.\n\nArgs:\n    state: The state of the passmanager workflow at the beginning of this flow controller's\n        execution.\n\nReceives:\n    state: the state of pass manager after the execution of the last task that was yielded.\n        The generator does not need to inspect this if it is irrelevant to its logic, nor\n        update it.\n\nYields:\n    Task: Next task to run.",
        "api_signature": "iter_tasks(self, state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/passmanager/base_tasks.py"
    },
    {
        "api_name": "execute",
        "full_api_name": "BaseController.execute",
        "api_description": "",
        "api_signature": "execute(self, passmanager_ir, state, callback)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/passmanager/base_tasks.py"
    },
    {
        "api_name": "__missing__",
        "full_api_name": "PropertySet.__missing__",
        "api_description": "",
        "api_signature": "__missing__(self, key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/passmanager/compilation_status.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BasePassManager.__init__",
        "api_description": "Initialize an empty pass manager object.\n\nArgs:\n    tasks: A pass set to be added to the pass manager schedule.\n    max_iteration: The maximum number of iterations the schedule will be looped if the\n        condition is not met.",
        "api_signature": "__init__(self, tasks, max_iteration)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/passmanager/passmanager.py"
    },
    {
        "api_name": "append",
        "full_api_name": "BasePassManager.append",
        "api_description": "Append tasks to the schedule of passes.\n\nArgs:\n    tasks: A set of pass manager tasks to be added to schedule.\n\nRaises:\n    TypeError: When any element of tasks is not a subclass of passmanager Task.",
        "api_signature": "append(self, tasks)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/passmanager/passmanager.py"
    },
    {
        "api_name": "replace",
        "full_api_name": "BasePassManager.replace",
        "api_description": "Replace a particular pass in the scheduler.\n\nArgs:\n    index: Task index to replace, based on the position in :meth:`tasks`\n    tasks: A set of pass manager tasks to be added to schedule.\n\nRaises:\n    TypeError: When any element of tasks is not a subclass of passmanager Task.\n    PassManagerError: If the index is not found.",
        "api_signature": "replace(self, index, tasks)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/passmanager/passmanager.py"
    },
    {
        "api_name": "remove",
        "full_api_name": "BasePassManager.remove",
        "api_description": "Removes a particular pass in the scheduler.\n\nArgs:\n    index: Pass index to remove, based on the position in :meth:`passes`.\n\nRaises:\n    PassManagerError: If the index is not found.",
        "api_signature": "remove(self, index)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/passmanager/passmanager.py"
    },
    {
        "api_name": "__setitem__",
        "full_api_name": "BasePassManager.__setitem__",
        "api_description": "",
        "api_signature": "__setitem__(self, index, item)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/passmanager/passmanager.py"
    },
    {
        "api_name": "__len__",
        "full_api_name": "BasePassManager.__len__",
        "api_description": "",
        "api_signature": "__len__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/passmanager/passmanager.py"
    },
    {
        "api_name": "__getitem__",
        "full_api_name": "BasePassManager.__getitem__",
        "api_description": "",
        "api_signature": "__getitem__(self, index)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/passmanager/passmanager.py"
    },
    {
        "api_name": "__add__",
        "full_api_name": "BasePassManager.__add__",
        "api_description": "",
        "api_signature": "__add__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/passmanager/passmanager.py"
    },
    {
        "api_name": "_passmanager_frontend",
        "full_api_name": "BasePassManager._passmanager_frontend",
        "api_description": "Convert input program into pass manager IR.\n\nArgs:\n    in_program: Input program.\n\nReturns:\n    Pass manager IR.",
        "api_signature": "_passmanager_frontend(self, input_program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/passmanager/passmanager.py"
    },
    {
        "api_name": "_passmanager_backend",
        "full_api_name": "BasePassManager._passmanager_backend",
        "api_description": "Convert pass manager IR into output program.\n\nArgs:\n    passmanager_ir: Pass manager IR after optimization.\n    in_program: The input program, this can be used if you need\n        any metadata about the original input for the output.\n        It should not be mutated.\n\nReturns:\n    Output program.",
        "api_signature": "_passmanager_backend(self, passmanager_ir, in_program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/passmanager/passmanager.py"
    },
    {
        "api_name": "run",
        "full_api_name": "BasePassManager.run",
        "api_description": "Run all the passes on the specified ``in_programs``.\n\nArgs:\n    in_programs: Input programs to transform via all the registered passes.\n        A single input object cannot be a Python builtin list object.\n        A list object is considered as multiple input objects to optimize.\n    callback: A callback function that will be called after each pass execution. The\n        function will be called with 4 keyword arguments::\n\n            task (GenericPass): the pass being run\n            passmanager_ir (Any): depending on pass manager subclass\n            property_set (PropertySet): the property set\n            running_time (float): the time to execute the pass\n            count (int): the index for the pass execution\n\n        The exact arguments pass expose the internals of the pass\n        manager and are subject to change as the pass manager internals\n        change. If you intend to reuse a callback function over\n        multiple releases be sure to check that the arguments being\n        passed are the same.\n\n        To use the callback feature you define a function that will\n        take in kwargs dict and access the variables. For example::\n\n            def callback_func(**kwargs):\n                task = kwargs['task']\n                passmanager_ir = kwargs['passmanager_ir']\n                property_set = kwargs['property_set']\n                running_time = kwargs['running_time']\n                count = kwargs['count']\n                ...\n\n    kwargs: Arbitrary arguments passed to the compiler frontend and backend.\n\nReturns:\n    The transformed program(s).",
        "api_signature": "run(self, in_programs, callback)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/passmanager/passmanager.py"
    },
    {
        "api_name": "to_flow_controller",
        "full_api_name": "BasePassManager.to_flow_controller",
        "api_description": "Linearize this manager into a single :class:`.FlowControllerLinear`,\nso that it can be nested inside another pass manager.\n\nReturns:\n    A linearized pass manager.",
        "api_signature": "to_flow_controller(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/passmanager/passmanager.py"
    },
    {
        "api_name": "_flatten_tasks",
        "full_api_name": "BasePassManager._flatten_tasks",
        "api_description": "A helper method to recursively flatten a nested task chain.",
        "api_signature": "_flatten_tasks(self, elements)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/passmanager/passmanager.py"
    },
    {
        "api_name": "_run_workflow",
        "full_api_name": "_run_workflow",
        "api_description": "Run single program optimization with a pass manager.\n\nArgs:\n    program: Arbitrary program to optimize.\n    pass_manager: Pass manager with scheduled passes.\n    **kwargs: Keyword arguments for IR conversion.\n\nReturns:\n    Optimized program.",
        "api_signature": "_run_workflow(program, pass_manager)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/passmanager/passmanager.py"
    },
    {
        "api_name": "_run_workflow_in_new_process",
        "full_api_name": "_run_workflow_in_new_process",
        "api_description": "Run single program optimization in new process.\n\nArgs:\n    program: Arbitrary program to optimize.\n    pass_manager_bin: Binary of the pass manager with scheduled passes.\n\nReturns:\n      Optimized program.",
        "api_signature": "_run_workflow_in_new_process(program, pass_manager_bin)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/passmanager/passmanager.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "FlowControllerLinear.__init__",
        "api_description": "",
        "api_signature": "__init__(self, tasks)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/passmanager/flow_controllers.py"
    },
    {
        "api_name": "passes",
        "full_api_name": "FlowControllerLinear.passes",
        "api_description": "Alias of tasks for backward compatibility.",
        "api_signature": "passes(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/passmanager/flow_controllers.py"
    },
    {
        "api_name": "append",
        "full_api_name": "FlowControllerLinear.append",
        "api_description": "Add new task to pipeline.\n\nArgs:\n    passes: A new task or list of tasks to add.",
        "api_signature": "append(self, passes)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/passmanager/flow_controllers.py"
    },
    {
        "api_name": "iter_tasks",
        "full_api_name": "FlowControllerLinear.iter_tasks",
        "api_description": "",
        "api_signature": "iter_tasks(self, state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/passmanager/flow_controllers.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "DoWhileController.__init__",
        "api_description": "",
        "api_signature": "__init__(self, tasks, do_while)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/passmanager/flow_controllers.py"
    },
    {
        "api_name": "passes",
        "full_api_name": "DoWhileController.passes",
        "api_description": "Alias of tasks for backward compatibility.",
        "api_signature": "passes(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/passmanager/flow_controllers.py"
    },
    {
        "api_name": "append",
        "full_api_name": "DoWhileController.append",
        "api_description": "Add new task to pipeline.\n\nArgs:\n    passes: A new task or list of tasks to add.",
        "api_signature": "append(self, passes)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/passmanager/flow_controllers.py"
    },
    {
        "api_name": "iter_tasks",
        "full_api_name": "DoWhileController.iter_tasks",
        "api_description": "",
        "api_signature": "iter_tasks(self, state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/passmanager/flow_controllers.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ConditionalController.__init__",
        "api_description": "",
        "api_signature": "__init__(self, tasks, condition)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/passmanager/flow_controllers.py"
    },
    {
        "api_name": "passes",
        "full_api_name": "ConditionalController.passes",
        "api_description": "Alias of tasks for backward compatibility.",
        "api_signature": "passes(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/passmanager/flow_controllers.py"
    },
    {
        "api_name": "append",
        "full_api_name": "ConditionalController.append",
        "api_description": "Add new task to pipeline.\n\nArgs:\n    passes: A new task or list of tasks to add.",
        "api_signature": "append(self, passes)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/passmanager/flow_controllers.py"
    },
    {
        "api_name": "iter_tasks",
        "full_api_name": "ConditionalController.iter_tasks",
        "api_description": "",
        "api_signature": "iter_tasks(self, state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/passmanager/flow_controllers.py"
    },
    {
        "api_name": "controller_factory",
        "full_api_name": "FlowController.controller_factory",
        "api_description": "Create a new flow controller with normalization.\n\nArgs:\n    passes: A list of optimization tasks.\n    options: Option for this flow controller.\n    controllers: Dictionary of controller callables keyed on flow controller alias.\n\nReturns:\n    An instance of normalized flow controller.",
        "api_signature": "controller_factory(cls, passes, options)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/passmanager/flow_controllers.py"
    },
    {
        "api_name": "add_flow_controller",
        "full_api_name": "FlowController.add_flow_controller",
        "api_description": "Adds a flow controller.\n\nArgs:\n    name: Alias of controller class in the namespace.\n    controller: Flow controller class.",
        "api_signature": "add_flow_controller(cls, name, controller)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/passmanager/flow_controllers.py"
    },
    {
        "api_name": "remove_flow_controller",
        "full_api_name": "FlowController.remove_flow_controller",
        "api_description": "Removes a flow controller.\n\nArgs:\n    name: Alias of the controller to remove.\n\nRaises:\n    KeyError: If the controller to remove was not registered.",
        "api_signature": "remove_flow_controller(cls, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/passmanager/flow_controllers.py"
    },
    {
        "api_name": "disassemble",
        "full_api_name": "disassemble",
        "api_description": "Disassemble a qobj and return the circuits or pulse schedules, run_config, and user header.\n\n.. note::\n\n    ``disassemble(assemble(qc))`` is not guaranteed to produce an exactly equal circuit to the\n    input, due to limitations in the :obj:`.QasmQobj` format that need to be maintained for\n    backend system compatibility.  This is most likely to be the case when using newer features\n    of :obj:`.QuantumCircuit`.  In most cases, the output should be equivalent, if not quite\n    equal.\n\nArgs:\n    qobj (Qobj): The input qobj object to disassemble\n\nReturns:\n    Union[CircuitModule, PulseModule]: The disassembled program which consists of:\n\n        * programs: A list of quantum circuits or pulse schedules\n        * run_config: The dict of the run config\n        * user_qobj_header: The dict of any user headers in the qobj\n\nExamples:\n\n    .. code-block:: python\n\n        from qiskit.circuit import QuantumRegister, ClassicalRegister, QuantumCircuit\n        from qiskit.compiler.assembler import assemble\n        from qiskit.assembler.disassemble import disassemble\n        # Create a circuit to assemble into a qobj\n        q = QuantumRegister(2)\n        c = ClassicalRegister(2)\n        qc = QuantumCircuit(q, c)\n        qc.h(q[0])\n        qc.cx(q[0], q[1])\n        qc.measure(q, c)\n        # Assemble the circuit into a Qobj\n        qobj = assemble(qc, shots=2000, memory=True)\n        # Disassemble the qobj back into a circuit\n        circuits, run_config_out, headers = disassemble(qobj)",
        "api_signature": "disassemble(qobj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/assembler/disassemble.py"
    },
    {
        "api_name": "_disassemble_circuit",
        "full_api_name": "_disassemble_circuit",
        "api_description": "",
        "api_signature": "_disassemble_circuit(qobj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/assembler/disassemble.py"
    },
    {
        "api_name": "_qobj_to_circuit_cals",
        "full_api_name": "_qobj_to_circuit_cals",
        "api_description": "Return circuit calibrations dictionary from qobj/exp config calibrations.",
        "api_signature": "_qobj_to_circuit_cals(qobj, pulse_lib)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/assembler/disassemble.py"
    },
    {
        "api_name": "_experiments_to_circuits",
        "full_api_name": "_experiments_to_circuits",
        "api_description": "Return a list of QuantumCircuit object(s) from a qobj.\n\nArgs:\n    qobj (Qobj): The Qobj object to convert to QuantumCircuits\n\nReturns:\n    list: A list of QuantumCircuit objects from the qobj",
        "api_signature": "_experiments_to_circuits(qobj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/assembler/disassemble.py"
    },
    {
        "api_name": "_disassemble_pulse_schedule",
        "full_api_name": "_disassemble_pulse_schedule",
        "api_description": "",
        "api_signature": "_disassemble_pulse_schedule(qobj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/assembler/disassemble.py"
    },
    {
        "api_name": "_experiments_to_schedules",
        "full_api_name": "_experiments_to_schedules",
        "api_description": "Return a list of :class:`qiskit.pulse.Schedule` object(s) from a qobj.\n\nArgs:\n    qobj (Qobj): The Qobj object to convert to pulse schedules.\n\nReturns:\n    A list of :class:`qiskit.pulse.Schedule` objects from the qobj\n\nRaises:\n    pulse.PulseError: If a parameterized instruction is supplied.",
        "api_signature": "_experiments_to_schedules(qobj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/assembler/disassemble.py"
    },
    {
        "api_name": "assemble_schedules",
        "full_api_name": "assemble_schedules",
        "api_description": "Assembles a list of schedules into a qobj that can be run on the backend.\n\nArgs:\n    schedules: Schedules to assemble.\n    qobj_id: Identifier for the generated qobj.\n    qobj_header: Header to pass to the results.\n    run_config: Configuration of the runtime environment.\n\nReturns:\n    The Qobj to be run on the backends.\n\nRaises:\n    QiskitError: when frequency settings are not supplied.\n\nExamples:\n\n    .. code-block:: python\n\n        from qiskit import pulse\n        from qiskit.assembler import assemble_schedules\n        from qiskit.assembler.run_config import RunConfig\n        # Construct a Qobj header for the output Qobj\n        header = {\"backend_name\": \"FakeOpenPulse2Q\", \"backend_version\": \"0.0.0\"}\n        # Build a configuration object for the output Qobj\n        config = RunConfig(shots=1024,\n                           memory=False,\n                           meas_level=1,\n                           meas_return='avg',\n                           memory_slot_size=100,\n                           parametric_pulses=[],\n                           init_qubits=True,\n                           qubit_lo_freq=[4900000000.0, 5000000000.0],\n                           meas_lo_freq=[6500000000.0, 6600000000.0],\n                           schedule_los=[])\n        # Build a Pulse schedule to assemble into a Qobj\n        schedule = pulse.Schedule()\n        schedule += pulse.Play(pulse.Waveform([0.1] * 16, name=\"test0\"),\n                               pulse.DriveChannel(0),\n                               name=\"test1\")\n        schedule += pulse.Play(pulse.Waveform([0.1] * 16, name=\"test1\"),\n                               pulse.DriveChannel(0),\n                               name=\"test2\")\n        schedule += pulse.Play(pulse.Waveform([0.5] * 16, name=\"test0\"),\n                               pulse.DriveChannel(0),\n                               name=\"test1\")\n        # Assemble a Qobj from the schedule.\n        pulseQobj = assemble_schedules(schedules=[schedule],\n                                       qobj_id=\"custom-id\",\n                                       qobj_header=header,\n                                       run_config=config)",
        "api_signature": "assemble_schedules(schedules, qobj_id, qobj_header, run_config)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/assembler/assemble_schedules.py"
    },
    {
        "api_name": "_assemble_experiments",
        "full_api_name": "_assemble_experiments",
        "api_description": "Assembles a list of schedules into PulseQobjExperiments, and returns related metadata that\nwill be assembled into the Qobj configuration.\n\nArgs:\n    schedules: Schedules to assemble.\n    lo_converter: The configured frequency converter and validator.\n    run_config: Configuration of the runtime environment.\n\nReturns:\n    The list of assembled experiments, and the dictionary of related experiment config.\n\nRaises:\n    QiskitError: when frequency settings are not compatible with the experiments.",
        "api_signature": "_assemble_experiments(schedules, lo_converter, run_config)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/assembler/assemble_schedules.py"
    },
    {
        "api_name": "_assemble_instructions",
        "full_api_name": "_assemble_instructions",
        "api_description": "Assembles the instructions in a schedule into a list of PulseQobjInstructions and returns\nrelated metadata that will be assembled into the Qobj configuration. Lookup table for\npulses defined in all experiments are registered in ``user_pulselib``. This object should be\nmutable python dictionary so that items are properly updated after each instruction assemble.\nThe dictionary is not returned to avoid redundancy.\n\nArgs:\n    sched: Schedule to assemble.\n    instruction_converter: A converter instance which can convert PulseInstructions to\n                           PulseQobjInstructions.\n    run_config: Configuration of the runtime environment.\n    user_pulselib: User pulse library from previous schedule.\n\nReturns:\n    A list of converted instructions, the user pulse library dictionary (from pulse name to\n    pulse samples), and the maximum number of readout memory slots used by this Schedule.",
        "api_signature": "_assemble_instructions(sched, instruction_converter, run_config, user_pulselib)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/assembler/assemble_schedules.py"
    },
    {
        "api_name": "_validate_meas_map",
        "full_api_name": "_validate_meas_map",
        "api_description": "Validate all qubits tied in ``meas_map`` are to be acquired.\n\nArgs:\n    instruction_map: A dictionary grouping Acquire instructions according to their start time\n                     and duration.\n    meas_map: List of groups of qubits that must be acquired together.\n\nRaises:\n    QiskitError: If the instructions do not satisfy the measurement map.",
        "api_signature": "_validate_meas_map(instruction_map, meas_map)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/assembler/assemble_schedules.py"
    },
    {
        "api_name": "_assemble_config",
        "full_api_name": "_assemble_config",
        "api_description": "Assembles the QobjConfiguration from experimental config and runtime config.\n\nArgs:\n    lo_converter: The configured frequency converter and validator.\n    experiment_config: Schedules to assemble.\n    run_config: Configuration of the runtime environment.\n\nReturns:\n    The assembled PulseQobjConfig.",
        "api_signature": "_assemble_config(lo_converter, experiment_config, run_config)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/assembler/assemble_schedules.py"
    },
    {
        "api_name": "_assemble_circuit",
        "full_api_name": "_assemble_circuit",
        "api_description": "Assemble one circuit.\n\nArgs:\n    circuit: circuit to assemble\n    run_config: configuration of the runtime environment\n\nReturns:\n    One experiment for the QasmQobj, and pulse library for pulse gates (which could be None)\n\nRaises:\n    QiskitError: when the circuit has unit other than 'dt'.",
        "api_signature": "_assemble_circuit(circuit, run_config)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/assembler/assemble_circuits.py"
    },
    {
        "api_name": "_assemble_pulse_gates",
        "full_api_name": "_assemble_pulse_gates",
        "api_description": "Assemble and return the circuit calibrations and associated pulse library, if there are any.\nThe calibrations themselves may reference the pulse library which is returned as a dict.\n\nArgs:\n    circuit: circuit which may have pulse calibrations\n    run_config: configuration of the runtime environment\n\nReturns:\n    The calibrations and pulse library, if there are any",
        "api_signature": "_assemble_pulse_gates(circuit, run_config)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/assembler/assemble_circuits.py"
    },
    {
        "api_name": "_extract_common_calibrations",
        "full_api_name": "_extract_common_calibrations",
        "api_description": "Given a list of ``QasmQobjExperiment``s, each of which may have calibrations in their\n``config``, collect common calibrations into a global ``QasmExperimentCalibrations``\nand delete them from their local experiments.\n\nArgs:\n    experiments: The list of OpenQASM experiments that are being assembled into one qobj\n\nReturns:\n    The input experiments with modified calibrations, and common calibrations, if there\n    are any",
        "api_signature": "_extract_common_calibrations(experiments)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/assembler/assemble_circuits.py"
    },
    {
        "api_name": "index_calibrations",
        "full_api_name": "index_calibrations",
        "api_description": "Map each calibration to all experiments that contain it.",
        "api_signature": "index_calibrations()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/assembler/assemble_circuits.py"
    },
    {
        "api_name": "collect_common_calibrations",
        "full_api_name": "collect_common_calibrations",
        "api_description": "If a gate calibration appears in all experiments, collect it.",
        "api_signature": "collect_common_calibrations()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/assembler/assemble_circuits.py"
    },
    {
        "api_name": "remove_common_gate_calibrations",
        "full_api_name": "remove_common_gate_calibrations",
        "api_description": "For calibrations that appear in all experiments, remove them from the individual\nexperiment's ``config.calibrations``.",
        "api_signature": "remove_common_gate_calibrations(exps)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/assembler/assemble_circuits.py"
    },
    {
        "api_name": "_configure_experiment_los",
        "full_api_name": "_configure_experiment_los",
        "api_description": "",
        "api_signature": "_configure_experiment_los(experiments, lo_converter, run_config)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/assembler/assemble_circuits.py"
    },
    {
        "api_name": "assemble_circuits",
        "full_api_name": "assemble_circuits",
        "api_description": "Assembles a list of circuits into a qobj that can be run on the backend.\n\nArgs:\n    circuits: circuit(s) to assemble\n    run_config: configuration of the runtime environment\n    qobj_id: identifier for the generated qobj\n    qobj_header: header to pass to the results\n\nReturns:\n    The qobj to be run on the backends\n\nExamples:\n\n    .. code-block:: python\n\n        from qiskit.circuit import QuantumRegister, ClassicalRegister, QuantumCircuit\n        from qiskit.assembler import assemble_circuits\n        from qiskit.assembler.run_config import RunConfig\n        # Build a circuit to convert into a Qobj\n        q = QuantumRegister(2)\n        c = ClassicalRegister(2)\n        qc = QuantumCircuit(q, c)\n        qc.h(q[0])\n        qc.cx(q[0], q[1])\n        qc.measure(q, c)\n        # Assemble a Qobj from the input circuit\n        qobj = assemble_circuits(circuits=[qc],\n                                 qobj_id=\"custom-id\",\n                                 qobj_header=[],\n                                 run_config=RunConfig(shots=2000, memory=True, init_qubits=True))",
        "api_signature": "assemble_circuits(circuits, run_config, qobj_id, qobj_header)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/assembler/assemble_circuits.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "RunConfig.__init__",
        "api_description": "Initialize a RunConfig object\n\nArgs:\n    shots (int): the number of shots\n    seed_simulator (int): the seed to use in the simulator\n    memory (bool): whether to request memory from backend\n        (per-shot readouts)\n    parameter_binds (list[dict]): List of parameter bindings\n    **kwargs: optional fields",
        "api_signature": "__init__(self, shots, seed_simulator, memory, parameter_binds)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/assembler/run_config.py"
    },
    {
        "api_name": "from_dict",
        "full_api_name": "RunConfig.from_dict",
        "api_description": "Create a new RunConfig object from a dictionary.\n\nArgs:\n    data (dict): A dictionary representing the RunConfig to create.\n                 It will be in the same format as output by\n                 :meth:`to_dict`.\n\nReturns:\n    RunConfig: The RunConfig from the input dictionary.",
        "api_signature": "from_dict(cls, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/assembler/run_config.py"
    },
    {
        "api_name": "to_dict",
        "full_api_name": "RunConfig.to_dict",
        "api_description": "Return a dictionary format representation of the RunConfig\n\nReturns:\n    dict: The dictionary form of the RunConfig.",
        "api_signature": "to_dict(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/assembler/run_config.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Estimator.__init__",
        "api_description": "Args:\n    options: Default options.\n\nRaises:\n    QiskitError: if some classical bits are not used for measurements.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/estimator.py"
    },
    {
        "api_name": "_call",
        "full_api_name": "Estimator._call",
        "api_description": "",
        "api_signature": "_call(self, circuits, observables, parameter_values)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/estimator.py"
    },
    {
        "api_name": "_run",
        "full_api_name": "Estimator._run",
        "api_description": "",
        "api_signature": "_run(self, circuits, observables, parameter_values)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/estimator.py"
    },
    {
        "api_name": "init_circuit",
        "full_api_name": "init_circuit",
        "api_description": "Initialize state by converting the input to a quantum circuit.\n\nArgs:\n    state: The state as quantum circuit or statevector.\n\nReturns:\n    The state as quantum circuit.",
        "api_signature": "init_circuit(state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/utils.py"
    },
    {
        "api_name": "init_observable",
        "full_api_name": "init_observable",
        "api_description": "Initialize observable by converting the input to a :class:`~qiskit.quantum_info.SparsePauliOp`.\n\nArgs:\n    observable: The observable.\n\nReturns:\n    The observable as :class:`~qiskit.quantum_info.SparsePauliOp`.\n\nRaises:\n    TypeError: If the observable is a :class:`~qiskit.opflow.PauliSumOp` and has a parameterized\n        coefficient.",
        "api_signature": "init_observable(observable)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/utils.py"
    },
    {
        "api_name": "final_measurement_mapping",
        "full_api_name": "final_measurement_mapping",
        "api_description": "Return the final measurement mapping for the circuit.\n\nDict keys label measured qubits, whereas the values indicate the\nclassical bit onto which that qubits measurement result is stored.\n\nParameters:\n    circuit: Input quantum circuit.\n\nReturns:\n    Mapping of qubits to classical bits for final measurements.",
        "api_signature": "final_measurement_mapping(circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/utils.py"
    },
    {
        "api_name": "_bits_key",
        "full_api_name": "_bits_key",
        "api_description": "",
        "api_signature": "_bits_key(bits, circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/utils.py"
    },
    {
        "api_name": "_format_params",
        "full_api_name": "_format_params",
        "api_description": "",
        "api_signature": "_format_params(param)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/utils.py"
    },
    {
        "api_name": "_circuit_key",
        "full_api_name": "_circuit_key",
        "api_description": "Private key function for QuantumCircuit.\n\nThis is the workaround until :meth:`QuantumCircuit.__hash__` will be introduced.\nIf key collision is found, please add elements to avoid it.\n\nArgs:\n    circuit: Input quantum circuit.\n    functional: If True, the returned key only includes functional data (i.e. execution related).\n\nReturns:\n    Composite key for circuit.",
        "api_signature": "_circuit_key(circuit, functional)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/utils.py"
    },
    {
        "api_name": "_observable_key",
        "full_api_name": "_observable_key",
        "api_description": "Private key function for SparsePauliOp.\nArgs:\n    observable: Input operator.\n\nReturns:\n    Key for observables.",
        "api_signature": "_observable_key(observable)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/utils.py"
    },
    {
        "api_name": "bound_circuit_to_instruction",
        "full_api_name": "bound_circuit_to_instruction",
        "api_description": "Build an :class:`~qiskit.circuit.Instruction` object from\na :class:`~qiskit.circuit.QuantumCircuit`\n\nThis is a specialized version of :func:`~qiskit.converters.circuit_to_instruction`\nto avoid deep copy. This requires a quantum circuit whose parameters are all bound.\nBecause this does not take a copy of the input circuit, this assumes that the input\ncircuit won't be modified.\n\nIf https://github.com/Qiskit/qiskit-terra/issues/7983 is resolved,\nwe can remove this function.\n\nArgs:\n    circuit(QuantumCircuit): Input quantum circuit\n\nReturns:\n    An :class:`~qiskit.circuit.Instruction` object",
        "api_signature": "bound_circuit_to_instruction(circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/utils.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PrimitiveJob.__init__",
        "api_description": "Args:\n    function: a callable function to execute the job.",
        "api_signature": "__init__(self, function)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/primitive_job.py"
    },
    {
        "api_name": "submit",
        "full_api_name": "PrimitiveJob.submit",
        "api_description": "",
        "api_signature": "submit(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/primitive_job.py"
    },
    {
        "api_name": "result",
        "full_api_name": "PrimitiveJob.result",
        "api_description": "Return the results of the job.",
        "api_signature": "result(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/primitive_job.py"
    },
    {
        "api_name": "cancel",
        "full_api_name": "PrimitiveJob.cancel",
        "api_description": "",
        "api_signature": "cancel(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/primitive_job.py"
    },
    {
        "api_name": "status",
        "full_api_name": "PrimitiveJob.status",
        "api_description": "",
        "api_signature": "status(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/primitive_job.py"
    },
    {
        "api_name": "_check_submitted",
        "full_api_name": "PrimitiveJob._check_submitted",
        "api_description": "",
        "api_signature": "_check_submitted(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/primitive_job.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Sampler.__init__",
        "api_description": "Args:\n    options: Default options.\n\nRaises:\n    QiskitError: if some classical bits are not used for measurements.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/sampler.py"
    },
    {
        "api_name": "_call",
        "full_api_name": "Sampler._call",
        "api_description": "",
        "api_signature": "_call(self, circuits, parameter_values)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/sampler.py"
    },
    {
        "api_name": "_run",
        "full_api_name": "Sampler._run",
        "api_description": "",
        "api_signature": "_run(self, circuits, parameter_values)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/sampler.py"
    },
    {
        "api_name": "_preprocess_circuit",
        "full_api_name": "Sampler._preprocess_circuit",
        "api_description": "",
        "api_signature": "_preprocess_circuit(circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/sampler.py"
    },
    {
        "api_name": "_run_circuits",
        "full_api_name": "_run_circuits",
        "api_description": "Remove metadata of circuits and run the circuits on a backend.\nArgs:\n    circuits: The circuits\n    backend: The backend\n    monitor: Enable job minotor if True\n    **run_options: run_options\nReturns:\n    The result and the metadata of the circuits",
        "api_signature": "_run_circuits(circuits, backend)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_estimator.py"
    },
    {
        "api_name": "_prepare_counts",
        "full_api_name": "_prepare_counts",
        "api_description": "",
        "api_signature": "_prepare_counts(results)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_estimator.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BackendEstimator.__init__",
        "api_description": "Initialize a new BackendEstimator instance\n\nArgs:\n    backend: Required: the backend to run the primitive on\n    options: Default options.\n    abelian_grouping: Whether the observable should be grouped into\n        commuting\n    bound_pass_manager: An optional pass manager to run after\n        parameter binding.\n    skip_transpilation: If this is set to True the internal compilation\n        of the input circuits is skipped and the circuit objects\n        will be directly executed when this object is called.",
        "api_signature": "__init__(self, backend, options, abelian_grouping, bound_pass_manager, skip_transpilation)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_estimator.py"
    },
    {
        "api_name": "transpile_options",
        "full_api_name": "BackendEstimator.transpile_options",
        "api_description": "Return the transpiler options for transpiling the circuits.",
        "api_signature": "transpile_options(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_estimator.py"
    },
    {
        "api_name": "set_transpile_options",
        "full_api_name": "BackendEstimator.set_transpile_options",
        "api_description": "Set the transpiler options for transpiler.\nArgs:\n    **fields: The fields to update the options",
        "api_signature": "set_transpile_options(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_estimator.py"
    },
    {
        "api_name": "preprocessed_circuits",
        "full_api_name": "BackendEstimator.preprocessed_circuits",
        "api_description": "Transpiled quantum circuits produced by preprocessing\nReturns:\n    List of the transpiled quantum circuit",
        "api_signature": "preprocessed_circuits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_estimator.py"
    },
    {
        "api_name": "transpiled_circuits",
        "full_api_name": "BackendEstimator.transpiled_circuits",
        "api_description": "Transpiled quantum circuits.\nReturns:\n    List of the transpiled quantum circuit\nRaises:\n    QiskitError: if the instance has been closed.",
        "api_signature": "transpiled_circuits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_estimator.py"
    },
    {
        "api_name": "backend",
        "full_api_name": "BackendEstimator.backend",
        "api_description": "Returns:\n    The backend which this estimator object based on",
        "api_signature": "backend(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_estimator.py"
    },
    {
        "api_name": "_transpile",
        "full_api_name": "BackendEstimator._transpile",
        "api_description": "Split Transpile",
        "api_signature": "_transpile(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_estimator.py"
    },
    {
        "api_name": "_call",
        "full_api_name": "BackendEstimator._call",
        "api_description": "",
        "api_signature": "_call(self, circuits, observables, parameter_values)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_estimator.py"
    },
    {
        "api_name": "_run",
        "full_api_name": "BackendEstimator._run",
        "api_description": "",
        "api_signature": "_run(self, circuits, observables, parameter_values)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_estimator.py"
    },
    {
        "api_name": "_measurement_circuit",
        "full_api_name": "BackendEstimator._measurement_circuit",
        "api_description": "",
        "api_signature": "_measurement_circuit(num_qubits, pauli)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_estimator.py"
    },
    {
        "api_name": "_preprocessing",
        "full_api_name": "BackendEstimator._preprocessing",
        "api_description": "Preprocessing for evaluation of expectation value using pauli rotation gates.",
        "api_signature": "_preprocessing(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_estimator.py"
    },
    {
        "api_name": "_postprocessing",
        "full_api_name": "BackendEstimator._postprocessing",
        "api_description": "Postprocessing for evaluation of expectation value using pauli rotation gates.",
        "api_signature": "_postprocessing(self, result, accum, metadata)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_estimator.py"
    },
    {
        "api_name": "_bound_pass_manager_run",
        "full_api_name": "BackendEstimator._bound_pass_manager_run",
        "api_description": "",
        "api_signature": "_bound_pass_manager_run(self, circuits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_estimator.py"
    },
    {
        "api_name": "_paulis2inds",
        "full_api_name": "_paulis2inds",
        "api_description": "Convert PauliList to diagonal integers.\nThese are integer representations of the binary string with a\n1 where there are Paulis, and 0 where there are identities.",
        "api_signature": "_paulis2inds(paulis)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_estimator.py"
    },
    {
        "api_name": "_parity",
        "full_api_name": "_parity",
        "api_description": "Return the parity of an integer",
        "api_signature": "_parity(integer)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_estimator.py"
    },
    {
        "api_name": "_pauli_expval_with_variance",
        "full_api_name": "_pauli_expval_with_variance",
        "api_description": "Return array of expval and variance pairs for input Paulis.\nNote: All non-identity Pauli's are treated as Z-paulis, assuming\nthat basis rotations have been applied to convert them to the\ndiagonal basis.",
        "api_signature": "_pauli_expval_with_variance(counts, paulis)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_estimator.py"
    },
    {
        "api_name": "_passmanager_for_measurement_circuits",
        "full_api_name": "_passmanager_for_measurement_circuits",
        "api_description": "",
        "api_signature": "_passmanager_for_measurement_circuits(layout, backend)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_estimator.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BackendSampler.__init__",
        "api_description": "Initialize a new BackendSampler\n\nArgs:\n    backend: Required: the backend to run the sampler primitive on\n    options: Default options.\n    bound_pass_manager: An optional pass manager to run after\n        parameter binding.\n    skip_transpilation: If this is set to True the internal compilation\n        of the input circuits is skipped and the circuit objects\n        will be directly executed when this objected is called.\nRaises:\n    ValueError: If backend is not provided",
        "api_signature": "__init__(self, backend, options, bound_pass_manager, skip_transpilation)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_sampler.py"
    },
    {
        "api_name": "preprocessed_circuits",
        "full_api_name": "BackendSampler.preprocessed_circuits",
        "api_description": "Preprocessed quantum circuits produced by preprocessing\nReturns:\n    List of the transpiled quantum circuit\nRaises:\n    QiskitError: if the instance has been closed.",
        "api_signature": "preprocessed_circuits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_sampler.py"
    },
    {
        "api_name": "transpiled_circuits",
        "full_api_name": "BackendSampler.transpiled_circuits",
        "api_description": "Transpiled quantum circuits.\nReturns:\n    List of the transpiled quantum circuit\nRaises:\n    QiskitError: if the instance has been closed.",
        "api_signature": "transpiled_circuits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_sampler.py"
    },
    {
        "api_name": "backend",
        "full_api_name": "BackendSampler.backend",
        "api_description": "Returns:\n    The backend which this sampler object based on",
        "api_signature": "backend(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_sampler.py"
    },
    {
        "api_name": "transpile_options",
        "full_api_name": "BackendSampler.transpile_options",
        "api_description": "Return the transpiler options for transpiling the circuits.",
        "api_signature": "transpile_options(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_sampler.py"
    },
    {
        "api_name": "set_transpile_options",
        "full_api_name": "BackendSampler.set_transpile_options",
        "api_description": "Set the transpiler options for transpiler.\nArgs:\n    **fields: The fields to update the options.\nReturns:\n    self.\nRaises:\n    QiskitError: if the instance has been closed.",
        "api_signature": "set_transpile_options(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_sampler.py"
    },
    {
        "api_name": "_call",
        "full_api_name": "BackendSampler._call",
        "api_description": "",
        "api_signature": "_call(self, circuits, parameter_values)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_sampler.py"
    },
    {
        "api_name": "_postprocessing",
        "full_api_name": "BackendSampler._postprocessing",
        "api_description": "",
        "api_signature": "_postprocessing(self, result, circuits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_sampler.py"
    },
    {
        "api_name": "_transpile",
        "full_api_name": "BackendSampler._transpile",
        "api_description": "",
        "api_signature": "_transpile(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_sampler.py"
    },
    {
        "api_name": "_bound_pass_manager_run",
        "full_api_name": "BackendSampler._bound_pass_manager_run",
        "api_description": "",
        "api_signature": "_bound_pass_manager_run(self, circuits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_sampler.py"
    },
    {
        "api_name": "_run",
        "full_api_name": "BackendSampler._run",
        "api_description": "",
        "api_signature": "_run(self, circuits, parameter_values)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_sampler.py"
    },
    {
        "api_name": "__post_init__",
        "full_api_name": "BasePrimitiveResult.__post_init__",
        "api_description": "Verify that all fields in any inheriting result dataclass are consistent, after\ninstantiation, with the number of experiments being represented.\n\nThis magic method is specific of `dataclasses.dataclass`, therefore all inheriting\nclasses must have this decorator.\n\nRaises:\n    TypeError: If one of the data fields is not a Sequence or ``numpy.ndarray``.\n    ValueError: Inconsistent number of experiments across data fields.",
        "api_signature": "__post_init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/base/base_result.py"
    },
    {
        "api_name": "num_experiments",
        "full_api_name": "BasePrimitiveResult.num_experiments",
        "api_description": "Number of experiments in any inheriting result dataclass.",
        "api_signature": "num_experiments(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/base/base_result.py"
    },
    {
        "api_name": "experiments",
        "full_api_name": "BasePrimitiveResult.experiments",
        "api_description": "Experiment data dicts in any inheriting result dataclass.",
        "api_signature": "experiments(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/base/base_result.py"
    },
    {
        "api_name": "_generate_experiments",
        "full_api_name": "BasePrimitiveResult._generate_experiments",
        "api_description": "Generate experiment data dicts in any inheriting result dataclass.",
        "api_signature": "_generate_experiments(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/base/base_result.py"
    },
    {
        "api_name": "decompose",
        "full_api_name": "BasePrimitiveResult.decompose",
        "api_description": "Generate single experiment result objects from self.",
        "api_signature": "decompose(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/base/base_result.py"
    },
    {
        "api_name": "_field_names",
        "full_api_name": "BasePrimitiveResult._field_names",
        "api_description": "Tuple of field names in any inheriting result dataclass.",
        "api_signature": "_field_names(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/base/base_result.py"
    },
    {
        "api_name": "_field_values",
        "full_api_name": "BasePrimitiveResult._field_values",
        "api_description": "Tuple of field values in any inheriting result dataclass.",
        "api_signature": "_field_values(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/base/base_result.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BaseSampler.__init__",
        "api_description": "Args:\n    options: Default options.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/base/base_sampler.py"
    },
    {
        "api_name": "run",
        "full_api_name": "BaseSampler.run",
        "api_description": "Run the job of the sampling of bitstrings.\n\nArgs:\n    circuits: One of more circuit objects.\n    parameter_values: Parameters to be bound to the circuit.\n    run_options: Backend runtime options used for circuit execution.\n\nReturns:\n    The job object of the result of the sampler. The i-th result corresponds to\n    ``circuits[i]`` evaluated with parameters bound as ``parameter_values[i]``.\n\nRaises:\n    ValueError: Invalid arguments are given.",
        "api_signature": "run(self, circuits, parameter_values)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/base/base_sampler.py"
    },
    {
        "api_name": "_run",
        "full_api_name": "BaseSampler._run",
        "api_description": "",
        "api_signature": "_run(self, circuits, parameter_values)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/base/base_sampler.py"
    },
    {
        "api_name": "_validate_circuits",
        "full_api_name": "BaseSampler._validate_circuits",
        "api_description": "",
        "api_signature": "_validate_circuits(cls, circuits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/base/base_sampler.py"
    },
    {
        "api_name": "circuits",
        "full_api_name": "BaseSampler.circuits",
        "api_description": "Quantum circuits to be sampled.\n\nReturns:\n    The quantum circuits to be sampled.",
        "api_signature": "circuits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/base/base_sampler.py"
    },
    {
        "api_name": "parameters",
        "full_api_name": "BaseSampler.parameters",
        "api_description": "Parameters of quantum circuits.\n\nReturns:\n    List of the parameters in each quantum circuit.",
        "api_signature": "parameters(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/base/base_sampler.py"
    },
    {
        "api_name": "_has_measure",
        "full_api_name": "_has_measure",
        "api_description": "",
        "api_signature": "_has_measure(circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/base/base_sampler.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BaseEstimator.__init__",
        "api_description": "Creating an instance of an Estimator, or using one in a ``with`` context opens a session that\nholds resources until the instance is ``close()`` ed or the context is exited.\n\nArgs:\n    options: Default options.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/base/base_estimator.py"
    },
    {
        "api_name": "run",
        "full_api_name": "BaseEstimator.run",
        "api_description": "Run the job of the estimation of expectation value(s).\n\n``circuits``, ``observables``, and ``parameter_values`` should have the same\nlength. The i-th element of the result is the expectation of observable\n\n.. code-block:: python\n\n    obs = observables[i]\n\nfor the state prepared by\n\n.. code-block:: python\n\n    circ = circuits[i]\n\nwith bound parameters\n\n.. code-block:: python\n\n    values = parameter_values[i].\n\nArgs:\n    circuits: one or more circuit objects.\n    observables: one or more observable objects. Several formats are allowed;\n        importantly, ``str`` should follow the string representation format for\n        :class:`~qiskit.quantum_info.Pauli` objects.\n    parameter_values: concrete parameters to be bound.\n    run_options: runtime options used for circuit execution.\n\nReturns:\n    The job object of EstimatorResult.\n\nRaises:\n    TypeError: Invalid argument type given.\n    ValueError: Invalid argument values given.",
        "api_signature": "run(self, circuits, observables, parameter_values)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/base/base_estimator.py"
    },
    {
        "api_name": "_run",
        "full_api_name": "BaseEstimator._run",
        "api_description": "",
        "api_signature": "_run(self, circuits, observables, parameter_values)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/base/base_estimator.py"
    },
    {
        "api_name": "_validate_observables",
        "full_api_name": "BaseEstimator._validate_observables",
        "api_description": "",
        "api_signature": "_validate_observables(observables)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/base/base_estimator.py"
    },
    {
        "api_name": "_cross_validate_circuits_observables",
        "full_api_name": "BaseEstimator._cross_validate_circuits_observables",
        "api_description": "",
        "api_signature": "_cross_validate_circuits_observables(circuits, observables)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/base/base_estimator.py"
    },
    {
        "api_name": "circuits",
        "full_api_name": "BaseEstimator.circuits",
        "api_description": "Quantum circuits that represents quantum states.\n\nReturns:\n    The quantum circuits.",
        "api_signature": "circuits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/base/base_estimator.py"
    },
    {
        "api_name": "observables",
        "full_api_name": "BaseEstimator.observables",
        "api_description": "Observables to be estimated.\n\nReturns:\n    The observables.",
        "api_signature": "observables(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/base/base_estimator.py"
    },
    {
        "api_name": "parameters",
        "full_api_name": "BaseEstimator.parameters",
        "api_description": "Parameters of the quantum circuits.\n\nReturns:\n    Parameters, where ``parameters[i][j]`` is the j-th parameter of the i-th circuit.",
        "api_signature": "parameters(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/base/base_estimator.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BasePrimitive.__init__",
        "api_description": "",
        "api_signature": "__init__(self, options)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/base/base_primitive.py"
    },
    {
        "api_name": "options",
        "full_api_name": "BasePrimitive.options",
        "api_description": "Return options values for the estimator.\n\nReturns:\n    options",
        "api_signature": "options(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/base/base_primitive.py"
    },
    {
        "api_name": "set_options",
        "full_api_name": "BasePrimitive.set_options",
        "api_description": "Set options values for the estimator.\n\nArgs:\n    **fields: The fields to update the options",
        "api_signature": "set_options(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/base/base_primitive.py"
    },
    {
        "api_name": "_validate_circuits",
        "full_api_name": "BasePrimitive._validate_circuits",
        "api_description": "",
        "api_signature": "_validate_circuits(circuits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/base/base_primitive.py"
    },
    {
        "api_name": "_validate_parameter_values",
        "full_api_name": "BasePrimitive._validate_parameter_values",
        "api_description": "",
        "api_signature": "_validate_parameter_values(parameter_values, default)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/base/base_primitive.py"
    },
    {
        "api_name": "_cross_validate_circuits_parameter_values",
        "full_api_name": "BasePrimitive._cross_validate_circuits_parameter_values",
        "api_description": "",
        "api_signature": "_cross_validate_circuits_parameter_values(circuits, parameter_values)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/base/base_primitive.py"
    },
    {
        "api_name": "_isint",
        "full_api_name": "_isint",
        "api_description": "Check if object is int.",
        "api_signature": "_isint(obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/base/base_primitive.py"
    },
    {
        "api_name": "_isreal",
        "full_api_name": "_isreal",
        "api_description": "Check if object is a real number: int or float except ``\u00b1Inf`` and ``NaN``.",
        "api_signature": "_isreal(obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/base/base_primitive.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ExtensionError.__init__",
        "api_description": "Set the error message.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/extensions/exceptions.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "ExtensionError.__str__",
        "api_description": "Return the message.",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/extensions/exceptions.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SingleQubitUnitary.__init__",
        "api_description": "Create a new single qubit gate based on the unitary ``u``.",
        "api_signature": "__init__(self, unitary_matrix, mode, up_to_diagonal)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/extensions/quantum_initializer/squ.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "SingleQubitUnitary.inverse",
        "api_description": "Return the inverse.\n\nNote that the resulting gate has an empty ``params`` property.",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/extensions/quantum_initializer/squ.py"
    },
    {
        "api_name": "diag",
        "full_api_name": "SingleQubitUnitary.diag",
        "api_description": "Returns the diagonal gate D up to which the single-qubit unitary u is implemented.\n\nI.e. u=D.u', where u' is the unitary implemented by the found circuit.",
        "api_signature": "diag(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/extensions/quantum_initializer/squ.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "SingleQubitUnitary._define",
        "api_description": "Define the gate using the decomposition.",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/extensions/quantum_initializer/squ.py"
    },
    {
        "api_name": "_zyz_circuit",
        "full_api_name": "SingleQubitUnitary._zyz_circuit",
        "api_description": "Get the circuit for the ZYZ decomposition.",
        "api_signature": "_zyz_circuit(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/extensions/quantum_initializer/squ.py"
    },
    {
        "api_name": "_zyz_dec",
        "full_api_name": "SingleQubitUnitary._zyz_dec",
        "api_description": "Finds rotation angles (a,b,c,d) in the decomposition u=exp(id)*Rz(c).Ry(b).Rz(a).\n\nNote that where \".\" denotes matrix multiplication.",
        "api_signature": "_zyz_dec(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/extensions/quantum_initializer/squ.py"
    },
    {
        "api_name": "validate_parameter",
        "full_api_name": "SingleQubitUnitary.validate_parameter",
        "api_description": "Single-qubit unitary gate parameter has to be an ndarray.",
        "api_signature": "validate_parameter(self, parameter)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/extensions/quantum_initializer/squ.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Snapshot.__init__",
        "api_description": "Create new snapshot instruction.\n\nArgs:\n    label (str): the snapshot label for result data.\n    snapshot_type (str): the type of the snapshot.\n    num_qubits (int): the number of qubits for the snapshot type [Default: 0].\n    num_clbits (int): the number of classical bits for the snapshot type\n                      [Default: 0].\n    params (list or None): the parameters for snapshot_type [Default: None].\n\nRaises:\n    ExtensionError: if snapshot label is invalid.",
        "api_signature": "__init__(self, label, snapshot_type, num_qubits, num_clbits, params)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/extensions/simulator/snapshot.py"
    },
    {
        "api_name": "assemble",
        "full_api_name": "Snapshot.assemble",
        "api_description": "Assemble a QasmQobjInstruction",
        "api_signature": "assemble(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/extensions/simulator/snapshot.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "Snapshot.inverse",
        "api_description": "Special case. Return self.",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/extensions/simulator/snapshot.py"
    },
    {
        "api_name": "snapshot_type",
        "full_api_name": "Snapshot.snapshot_type",
        "api_description": "Return snapshot type",
        "api_signature": "snapshot_type(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/extensions/simulator/snapshot.py"
    },
    {
        "api_name": "c_if",
        "full_api_name": "Snapshot.c_if",
        "api_description": "",
        "api_signature": "c_if(self, classical, val)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/extensions/simulator/snapshot.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ParameterExpression.__init__",
        "api_description": "Create a new :class:`ParameterExpression`.\n\nNot intended to be called directly, but to be instantiated via operations\non other :class:`Parameter` or :class:`ParameterExpression` objects.\n\nArgs:\n    symbol_map (Dict[Parameter, [ParameterExpression, float, or int]]):\n        Mapping of :class:`Parameter` instances to the :class:`sympy.Symbol`\n        serving as their placeholder in expr.\n    expr (sympy.Expr): Expression of :class:`sympy.Symbol` s.",
        "api_signature": "__init__(self, symbol_map, expr)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "parameters",
        "full_api_name": "ParameterExpression.parameters",
        "api_description": "Returns a set of the unbound Parameters in the expression.",
        "api_signature": "parameters(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "_names",
        "full_api_name": "ParameterExpression._names",
        "api_description": "Returns a mapping of parameter names to Parameters in the expression.",
        "api_signature": "_names(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "conjugate",
        "full_api_name": "ParameterExpression.conjugate",
        "api_description": "Return the conjugate.",
        "api_signature": "conjugate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "assign",
        "full_api_name": "ParameterExpression.assign",
        "api_description": "Assign one parameter to a value, which can either be numeric or another parameter\nexpression.\n\nArgs:\n    parameter (Parameter): A parameter in this expression whose value will be updated.\n    value: The new value to bind to.\n\nReturns:\n    A new expression parameterized by any parameters which were not bound by assignment.",
        "api_signature": "assign(self, parameter, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "bind",
        "full_api_name": "ParameterExpression.bind",
        "api_description": "Binds the provided set of parameters to their corresponding values.\n\nArgs:\n    parameter_values: Mapping of Parameter instances to the numeric value to which\n                      they will be bound.\n    allow_unknown_parameters: If ``False``, raises an error if ``parameter_values``\n        contains Parameters in the keys outside those present in the expression.\n        If ``True``, any such parameters are simply ignored.\n\nRaises:\n    CircuitError:\n        - If parameter_values contains Parameters outside those in self.\n        - If a non-numeric value is passed in parameter_values.\n    ZeroDivisionError:\n        - If binding the provided values requires division by zero.\n\nReturns:\n    A new expression parameterized by any parameters which were not bound by\n    parameter_values.",
        "api_signature": "bind(self, parameter_values, allow_unknown_parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "subs",
        "full_api_name": "ParameterExpression.subs",
        "api_description": "Returns a new Expression with replacement Parameters.\n\nArgs:\n    parameter_map: Mapping from Parameters in self to the ParameterExpression\n                   instances with which they should be replaced.\n    allow_unknown_parameters: If ``False``, raises an error if ``parameter_map``\n        contains Parameters in the keys outside those present in the expression.\n        If ``True``, any such parameters are simply ignored.\n\nRaises:\n    CircuitError:\n        - If parameter_map contains Parameters outside those in self.\n        - If the replacement Parameters in parameter_map would result in\n          a name conflict in the generated expression.\n\nReturns:\n    A new expression with the specified parameters replaced.",
        "api_signature": "subs(self, parameter_map, allow_unknown_parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "_raise_if_passed_unknown_parameters",
        "full_api_name": "ParameterExpression._raise_if_passed_unknown_parameters",
        "api_description": "",
        "api_signature": "_raise_if_passed_unknown_parameters(self, parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "_raise_if_passed_nan",
        "full_api_name": "ParameterExpression._raise_if_passed_nan",
        "api_description": "",
        "api_signature": "_raise_if_passed_nan(self, parameter_values)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "_raise_if_parameter_names_conflict",
        "full_api_name": "ParameterExpression._raise_if_parameter_names_conflict",
        "api_description": "",
        "api_signature": "_raise_if_parameter_names_conflict(self, inbound_parameters, outbound_parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "_apply_operation",
        "full_api_name": "ParameterExpression._apply_operation",
        "api_description": "Base method implementing math operations between Parameters and\neither a constant or a second ParameterExpression.\n\nArgs:\n    operation: One of operator.{add,sub,mul,truediv}.\n    other: The second argument to be used with self in operation.\n    reflected: Optional - The default ordering is \"self operator other\".\n               If reflected is True, this is switched to \"other operator self\".\n               For use in e.g. __radd__, ...\n\nRaises:\n    CircuitError:\n        - If parameter_map contains Parameters outside those in self.\n        - If the replacement Parameters in parameter_map would result in\n          a name conflict in the generated expression.\n\nReturns:\n    A new expression describing the result of the operation.",
        "api_signature": "_apply_operation(self, operation, other, reflected)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "gradient",
        "full_api_name": "ParameterExpression.gradient",
        "api_description": "Get the derivative of a parameter expression w.r.t. a specified parameter expression.\n\nArgs:\n    param (Parameter): Parameter w.r.t. which we want to take the derivative\n\nReturns:\n    ParameterExpression representing the gradient of param_expr w.r.t. param\n    or complex or float number",
        "api_signature": "gradient(self, param)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "__add__",
        "full_api_name": "ParameterExpression.__add__",
        "api_description": "",
        "api_signature": "__add__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "__radd__",
        "full_api_name": "ParameterExpression.__radd__",
        "api_description": "",
        "api_signature": "__radd__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "__sub__",
        "full_api_name": "ParameterExpression.__sub__",
        "api_description": "",
        "api_signature": "__sub__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "__rsub__",
        "full_api_name": "ParameterExpression.__rsub__",
        "api_description": "",
        "api_signature": "__rsub__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "__mul__",
        "full_api_name": "ParameterExpression.__mul__",
        "api_description": "",
        "api_signature": "__mul__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "__neg__",
        "full_api_name": "ParameterExpression.__neg__",
        "api_description": "",
        "api_signature": "__neg__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "__rmul__",
        "full_api_name": "ParameterExpression.__rmul__",
        "api_description": "",
        "api_signature": "__rmul__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "__truediv__",
        "full_api_name": "ParameterExpression.__truediv__",
        "api_description": "",
        "api_signature": "__truediv__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "__rtruediv__",
        "full_api_name": "ParameterExpression.__rtruediv__",
        "api_description": "",
        "api_signature": "__rtruediv__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "_call",
        "full_api_name": "ParameterExpression._call",
        "api_description": "",
        "api_signature": "_call(self, ufunc)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "sin",
        "full_api_name": "ParameterExpression.sin",
        "api_description": "Sine of a ParameterExpression",
        "api_signature": "sin(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "cos",
        "full_api_name": "ParameterExpression.cos",
        "api_description": "Cosine of a ParameterExpression",
        "api_signature": "cos(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "tan",
        "full_api_name": "ParameterExpression.tan",
        "api_description": "Tangent of a ParameterExpression",
        "api_signature": "tan(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "arcsin",
        "full_api_name": "ParameterExpression.arcsin",
        "api_description": "Arcsin of a ParameterExpression",
        "api_signature": "arcsin(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "arccos",
        "full_api_name": "ParameterExpression.arccos",
        "api_description": "Arccos of a ParameterExpression",
        "api_signature": "arccos(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "arctan",
        "full_api_name": "ParameterExpression.arctan",
        "api_description": "Arctan of a ParameterExpression",
        "api_signature": "arctan(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "exp",
        "full_api_name": "ParameterExpression.exp",
        "api_description": "Exponential of a ParameterExpression",
        "api_signature": "exp(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "log",
        "full_api_name": "ParameterExpression.log",
        "api_description": "Logarithm of a ParameterExpression",
        "api_signature": "log(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "sign",
        "full_api_name": "ParameterExpression.sign",
        "api_description": "Sign of a ParameterExpression",
        "api_signature": "sign(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "ParameterExpression.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "ParameterExpression.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "__complex__",
        "full_api_name": "ParameterExpression.__complex__",
        "api_description": "",
        "api_signature": "__complex__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "__float__",
        "full_api_name": "ParameterExpression.__float__",
        "api_description": "",
        "api_signature": "__float__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "__int__",
        "full_api_name": "ParameterExpression.__int__",
        "api_description": "",
        "api_signature": "__int__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "__hash__",
        "full_api_name": "ParameterExpression.__hash__",
        "api_description": "",
        "api_signature": "__hash__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "__copy__",
        "full_api_name": "ParameterExpression.__copy__",
        "api_description": "",
        "api_signature": "__copy__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "__deepcopy__",
        "full_api_name": "ParameterExpression.__deepcopy__",
        "api_description": "",
        "api_signature": "__deepcopy__(self, memo)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "__abs__",
        "full_api_name": "ParameterExpression.__abs__",
        "api_description": "Absolute of a ParameterExpression",
        "api_signature": "__abs__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "abs",
        "full_api_name": "ParameterExpression.abs",
        "api_description": "Absolute of a ParameterExpression",
        "api_signature": "abs(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "ParameterExpression.__eq__",
        "api_description": "Check if this parameter expression is equal to another parameter expression\n   or a fixed value (only if this is a bound expression).\nArgs:\n    other (ParameterExpression or a number):\n        Parameter expression or numeric constant used for comparison\nReturns:\n    bool: result of the comparison",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "is_real",
        "full_api_name": "ParameterExpression.is_real",
        "api_description": "Return whether the expression is real",
        "api_signature": "is_real(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "sympify",
        "full_api_name": "ParameterExpression.sympify",
        "api_description": "Return symbolic expression as a raw Sympy or Symengine object.\n\nSymengine is used preferentially; if both are available, the result will always be a\n``symengine`` object.  Symengine is a separate library but has integration with Sympy.\n\n.. note::\n\n    This is for interoperability only.  Qiskit will not accept or work with raw Sympy or\n    Symegine expressions in its parameters, because they do not contain the tracking\n    information used in circuit-parameter binding and assignment.",
        "api_signature": "sympify(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Qubit.__init__",
        "api_description": "Creates a qubit.\n\nArgs:\n    register (QuantumRegister): Optional. A quantum register containing the bit.\n    index (int): Optional. The index of the bit in its containing register.\n\nRaises:\n    CircuitError: if the provided register is not a valid :class:`QuantumRegister`",
        "api_signature": "__init__(self, register, index)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumregister.py"
    },
    {
        "api_name": "qasm",
        "full_api_name": "QuantumRegister.qasm",
        "api_description": "Return OPENQASM string for this register.",
        "api_signature": "qasm(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumregister.py"
    },
    {
        "api_name": "__getattr__",
        "full_api_name": "__getattr__",
        "api_description": "",
        "api_signature": "__getattr__(name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/qpy_serialization.py"
    },
    {
        "api_name": "_instance_key",
        "full_api_name": "ParameterReferences._instance_key",
        "api_description": "",
        "api_signature": "_instance_key(self, ref)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametertable.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ParameterReferences.__init__",
        "api_description": "",
        "api_signature": "__init__(self, refs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametertable.py"
    },
    {
        "api_name": "__getstate__",
        "full_api_name": "ParameterReferences.__getstate__",
        "api_description": "",
        "api_signature": "__getstate__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametertable.py"
    },
    {
        "api_name": "__setstate__",
        "full_api_name": "ParameterReferences.__setstate__",
        "api_description": "",
        "api_signature": "__setstate__(self, refs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametertable.py"
    },
    {
        "api_name": "__len__",
        "full_api_name": "ParameterReferences.__len__",
        "api_description": "",
        "api_signature": "__len__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametertable.py"
    },
    {
        "api_name": "__iter__",
        "full_api_name": "ParameterReferences.__iter__",
        "api_description": "",
        "api_signature": "__iter__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametertable.py"
    },
    {
        "api_name": "__contains__",
        "full_api_name": "ParameterReferences.__contains__",
        "api_description": "",
        "api_signature": "__contains__(self, x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametertable.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "ParameterReferences.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametertable.py"
    },
    {
        "api_name": "add",
        "full_api_name": "ParameterReferences.add",
        "api_description": "Adds a reference to the listing if it's not already present.",
        "api_signature": "add(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametertable.py"
    },
    {
        "api_name": "discard",
        "full_api_name": "ParameterReferences.discard",
        "api_description": "",
        "api_signature": "discard(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametertable.py"
    },
    {
        "api_name": "copy",
        "full_api_name": "ParameterReferences.copy",
        "api_description": "Create a shallow copy.",
        "api_signature": "copy(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametertable.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ParameterTable.__init__",
        "api_description": "Create a new instance, initialized with ``mapping`` if provided.\n\nArgs:\n    mapping (Mapping[Parameter, ParameterReferences]):\n        Mapping of parameter to the set of parameter slots that reference\n        it.\n\nRaises:\n    ValueError: A value in ``mapping`` is not a :class:`~ParameterReferences`.",
        "api_signature": "__init__(self, mapping)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametertable.py"
    },
    {
        "api_name": "__getitem__",
        "full_api_name": "ParameterTable.__getitem__",
        "api_description": "",
        "api_signature": "__getitem__(self, key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametertable.py"
    },
    {
        "api_name": "__setitem__",
        "full_api_name": "ParameterTable.__setitem__",
        "api_description": "Associate a parameter with the set of parameter slots ``(instruction, param_index)``\nthat reference it.\n\n.. note::\n\n    Items in ``refs`` are considered unique if their ``instruction`` is referentially\n    unique. See :class:`~ParameterReferences` for details.\n\nArgs:\n    parameter (Parameter): the parameter\n    refs (Union[ParameterReferences, Iterable[(Instruction, int)]]): the parameter slots.\n        If this is an iterable, a new :class:`~ParameterReferences` is created from its\n        contents.",
        "api_signature": "__setitem__(self, parameter, refs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametertable.py"
    },
    {
        "api_name": "get_keys",
        "full_api_name": "ParameterTable.get_keys",
        "api_description": "Return a set of all keys in the parameter table\n\nReturns:\n    set: A set of all the keys in the parameter table",
        "api_signature": "get_keys(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametertable.py"
    },
    {
        "api_name": "get_names",
        "full_api_name": "ParameterTable.get_names",
        "api_description": "Return a set of all parameter names in the parameter table\n\nReturns:\n    set: A set of all the names in the parameter table",
        "api_signature": "get_names(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametertable.py"
    },
    {
        "api_name": "__delitem__",
        "full_api_name": "ParameterTable.__delitem__",
        "api_description": "",
        "api_signature": "__delitem__(self, key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametertable.py"
    },
    {
        "api_name": "__iter__",
        "full_api_name": "ParameterTable.__iter__",
        "api_description": "",
        "api_signature": "__iter__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametertable.py"
    },
    {
        "api_name": "__len__",
        "full_api_name": "ParameterTable.__len__",
        "api_description": "",
        "api_signature": "__len__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametertable.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "ParameterTable.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametertable.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ParameterView.__init__",
        "api_description": "",
        "api_signature": "__init__(self, iterable)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametertable.py"
    },
    {
        "api_name": "copy",
        "full_api_name": "ParameterView.copy",
        "api_description": "Copy the ParameterView.",
        "api_signature": "copy(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametertable.py"
    },
    {
        "api_name": "isdisjoint",
        "full_api_name": "ParameterView.isdisjoint",
        "api_description": "Check whether self and the input are disjoint.",
        "api_signature": "isdisjoint(self, x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametertable.py"
    },
    {
        "api_name": "remove",
        "full_api_name": "ParameterView.remove",
        "api_description": "Remove an existing element from the view.",
        "api_signature": "remove(self, x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametertable.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "ParameterView.__repr__",
        "api_description": "Format the class as string.",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametertable.py"
    },
    {
        "api_name": "__getitem__",
        "full_api_name": "ParameterView.__getitem__",
        "api_description": "Get items.",
        "api_signature": "__getitem__(self, index)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametertable.py"
    },
    {
        "api_name": "__and__",
        "full_api_name": "ParameterView.__and__",
        "api_description": "Get the intersection between self and the input.",
        "api_signature": "__and__(self, x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametertable.py"
    },
    {
        "api_name": "__rand__",
        "full_api_name": "ParameterView.__rand__",
        "api_description": "Get the intersection between self and the input.",
        "api_signature": "__rand__(self, x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametertable.py"
    },
    {
        "api_name": "__iand__",
        "full_api_name": "ParameterView.__iand__",
        "api_description": "Get the intersection between self and the input in-place.",
        "api_signature": "__iand__(self, x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametertable.py"
    },
    {
        "api_name": "__len__",
        "full_api_name": "ParameterView.__len__",
        "api_description": "Get the length.",
        "api_signature": "__len__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametertable.py"
    },
    {
        "api_name": "__or__",
        "full_api_name": "ParameterView.__or__",
        "api_description": "Get the union of self and the input.",
        "api_signature": "__or__(self, x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametertable.py"
    },
    {
        "api_name": "__sub__",
        "full_api_name": "ParameterView.__sub__",
        "api_description": "Get the difference between self and the input.",
        "api_signature": "__sub__(self, x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametertable.py"
    },
    {
        "api_name": "__xor__",
        "full_api_name": "ParameterView.__xor__",
        "api_description": "Get the symmetric difference between self and the input.",
        "api_signature": "__xor__(self, x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametertable.py"
    },
    {
        "api_name": "__ne__",
        "full_api_name": "ParameterView.__ne__",
        "api_description": "",
        "api_signature": "__ne__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametertable.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "ParameterView.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametertable.py"
    },
    {
        "api_name": "__le__",
        "full_api_name": "ParameterView.__le__",
        "api_description": "",
        "api_signature": "__le__(self, x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametertable.py"
    },
    {
        "api_name": "__lt__",
        "full_api_name": "ParameterView.__lt__",
        "api_description": "",
        "api_signature": "__lt__(self, x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametertable.py"
    },
    {
        "api_name": "__ge__",
        "full_api_name": "ParameterView.__ge__",
        "api_description": "",
        "api_signature": "__ge__(self, x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametertable.py"
    },
    {
        "api_name": "__gt__",
        "full_api_name": "ParameterView.__gt__",
        "api_description": "",
        "api_signature": "__gt__(self, x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametertable.py"
    },
    {
        "api_name": "__iter__",
        "full_api_name": "ParameterView.__iter__",
        "api_description": "",
        "api_signature": "__iter__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametertable.py"
    },
    {
        "api_name": "__contains__",
        "full_api_name": "ParameterView.__contains__",
        "api_description": "",
        "api_signature": "__contains__(self, x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametertable.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Delay.__init__",
        "api_description": "Create new delay instruction.",
        "api_signature": "__init__(self, duration, unit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/delay.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "Delay.inverse",
        "api_description": "Special case. Return self.",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/delay.py"
    },
    {
        "api_name": "broadcast_arguments",
        "full_api_name": "Delay.broadcast_arguments",
        "api_description": "",
        "api_signature": "broadcast_arguments(self, qargs, cargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/delay.py"
    },
    {
        "api_name": "c_if",
        "full_api_name": "Delay.c_if",
        "api_description": "",
        "api_signature": "c_if(self, classical, val)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/delay.py"
    },
    {
        "api_name": "duration",
        "full_api_name": "Delay.duration",
        "api_description": "Get the duration of this delay.",
        "api_signature": "duration(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/delay.py"
    },
    {
        "api_name": "duration",
        "full_api_name": "Delay.duration",
        "api_description": "Set the duration of this delay.",
        "api_signature": "duration(self, duration)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/delay.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "Delay.__array__",
        "api_description": "Return the identity matrix.",
        "api_signature": "__array__(self, dtype)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/delay.py"
    },
    {
        "api_name": "to_matrix",
        "full_api_name": "Delay.to_matrix",
        "api_description": "Return a Numpy.array for the unitary matrix. This has been\nadded to enable simulation without making delay a full Gate type.\n\nReturns:\n    np.ndarray: matrix representation.",
        "api_signature": "to_matrix(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/delay.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "Delay.__repr__",
        "api_description": "Return the official string representing the delay.",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/delay.py"
    },
    {
        "api_name": "validate_parameter",
        "full_api_name": "Delay.validate_parameter",
        "api_description": "Delay parameter (i.e. duration) must be int, float or ParameterExpression.",
        "api_signature": "validate_parameter(self, parameter)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/delay.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Bit.__init__",
        "api_description": "Create a new generic bit.",
        "api_signature": "__init__(self, register, index)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/bit.py"
    },
    {
        "api_name": "register",
        "full_api_name": "Bit.register",
        "api_description": "Get the register of an old-style bit.\n\nIn modern Qiskit Terra (version 0.17+), bits are the fundamental object and registers are\naliases to collections of bits.  A bit can be in many registers depending on the circuit, so\na single containing register is no longer a property of a bit.  It is an error to access\nthis attribute on bits that were not constructed as \"owned\" by a register.",
        "api_signature": "register(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/bit.py"
    },
    {
        "api_name": "index",
        "full_api_name": "Bit.index",
        "api_description": "Get the index of an old-style bit in the register that owns it.\n\nIn modern Qiskit Terra (version 0.17+), bits are the fundamental object and registers are\naliases to collections of bits.  A bit can be in many registers depending on the circuit, so\na single containing register is no longer a property of a bit.  It is an error to access\nthis attribute on bits that were not constructed as \"owned\" by a register.",
        "api_signature": "index(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/bit.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "Bit.__repr__",
        "api_description": "Return the official string representing the bit.",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/bit.py"
    },
    {
        "api_name": "__hash__",
        "full_api_name": "Bit.__hash__",
        "api_description": "",
        "api_signature": "__hash__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/bit.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "Bit.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/bit.py"
    },
    {
        "api_name": "__copy__",
        "full_api_name": "Bit.__copy__",
        "api_description": "",
        "api_signature": "__copy__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/bit.py"
    },
    {
        "api_name": "__deepcopy__",
        "full_api_name": "Bit.__deepcopy__",
        "api_description": "",
        "api_signature": "__deepcopy__(self, memo)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/bit.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Barrier.__init__",
        "api_description": "Create new barrier instruction.\n\nArgs:\n    num_qubits (int): the number of qubits for the barrier type [Default: 0].\n    label (str): the barrier label\n\nRaises:\n    TypeError: if barrier label is invalid.",
        "api_signature": "__init__(self, num_qubits, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/barrier.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "Barrier.inverse",
        "api_description": "Special case. Return self.",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/barrier.py"
    },
    {
        "api_name": "c_if",
        "full_api_name": "Barrier.c_if",
        "api_description": "",
        "api_signature": "c_if(self, classical, val)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/barrier.py"
    },
    {
        "api_name": "name",
        "full_api_name": "Operation.name",
        "api_description": "Unique string identifier for operation type.",
        "api_signature": "name(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/operation.py"
    },
    {
        "api_name": "num_qubits",
        "full_api_name": "Operation.num_qubits",
        "api_description": "Number of qubits.",
        "api_signature": "num_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/operation.py"
    },
    {
        "api_name": "num_clbits",
        "full_api_name": "Operation.num_clbits",
        "api_description": "Number of classical bits.",
        "api_signature": "num_clbits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/operation.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "EquivalenceLibrary.__init__",
        "api_description": "Create a new equivalence library.\n\nArgs:\n    base (Optional[EquivalenceLibrary]):  Base equivalence library to\n        be referenced if an entry is not found in this library.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/equivalence.py"
    },
    {
        "api_name": "graph",
        "full_api_name": "EquivalenceLibrary.graph",
        "api_description": "Return graph representing the equivalence library data.\n\nThis property should be treated as read-only as it provides\na reference to the internal state of the :class:`~.EquivalenceLibrary` object.\nIf the graph returned by this property is mutated it could corrupt the\nthe contents of the object. If you need to modify the output ``PyDiGraph``\nbe sure to make a copy prior to any modification.\n\nReturns:\n    PyDiGraph: A graph object with equivalence data in each node.",
        "api_signature": "graph(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/equivalence.py"
    },
    {
        "api_name": "_set_default_node",
        "full_api_name": "EquivalenceLibrary._set_default_node",
        "api_description": "Create a new node if key not found",
        "api_signature": "_set_default_node(self, key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/equivalence.py"
    },
    {
        "api_name": "add_equivalence",
        "full_api_name": "EquivalenceLibrary.add_equivalence",
        "api_description": "Add a new equivalence to the library. Future queries for the Gate\nwill include the given circuit, in addition to all existing equivalences\n(including those from base).\n\nParameterized Gates (those including `qiskit.circuit.Parameters` in their\n`Gate.params`) can be marked equivalent to parameterized circuits,\nprovided the parameters match.\n\nArgs:\n    gate (Gate): A Gate instance.\n    equivalent_circuit (QuantumCircuit): A circuit equivalently\n        implementing the given Gate.",
        "api_signature": "add_equivalence(self, gate, equivalent_circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/equivalence.py"
    },
    {
        "api_name": "has_entry",
        "full_api_name": "EquivalenceLibrary.has_entry",
        "api_description": "Check if a library contains any decompositions for gate.\n\nArgs:\n    gate (Gate): A Gate instance.\n\nReturns:\n    Bool: True if gate has a known decomposition in the library.\n        False otherwise.",
        "api_signature": "has_entry(self, gate)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/equivalence.py"
    },
    {
        "api_name": "set_entry",
        "full_api_name": "EquivalenceLibrary.set_entry",
        "api_description": "Set the equivalence record for a Gate. Future queries for the Gate\nwill return only the circuits provided.\n\nParameterized Gates (those including `qiskit.circuit.Parameters` in their\n`Gate.params`) can be marked equivalent to parameterized circuits,\nprovided the parameters match.\n\nArgs:\n    gate (Gate): A Gate instance.\n    entry (List['QuantumCircuit']) : A list of QuantumCircuits, each\n        equivalently implementing the given Gate.",
        "api_signature": "set_entry(self, gate, entry)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/equivalence.py"
    },
    {
        "api_name": "get_entry",
        "full_api_name": "EquivalenceLibrary.get_entry",
        "api_description": "Gets the set of QuantumCircuits circuits from the library which\nequivalently implement the given Gate.\n\nParameterized circuits will have their parameters replaced with the\ncorresponding entries from Gate.params.\n\nArgs:\n    gate (Gate) - Gate: A Gate instance.\n\nReturns:\n    List[QuantumCircuit]: A list of equivalent QuantumCircuits. If empty,\n        library contains no known decompositions of Gate.\n\n        Returned circuits will be ordered according to their insertion in\n        the library, from earliest to latest, from top to base. The\n        ordering of the StandardEquivalenceLibrary will not generally be\n        consistent across Qiskit versions.",
        "api_signature": "get_entry(self, gate)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/equivalence.py"
    },
    {
        "api_name": "keys",
        "full_api_name": "EquivalenceLibrary.keys",
        "api_description": "Return list of keys to key to node index map.\n\nReturns:\n    List: Keys to the key to node index map.",
        "api_signature": "keys(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/equivalence.py"
    },
    {
        "api_name": "node_index",
        "full_api_name": "EquivalenceLibrary.node_index",
        "api_description": "Return node index for a given key.\n\nArgs:\n    key (Key): Key to an equivalence.\n\nReturns:\n    Int: Index to the node in the graph for the given key.",
        "api_signature": "node_index(self, key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/equivalence.py"
    },
    {
        "api_name": "draw",
        "full_api_name": "EquivalenceLibrary.draw",
        "api_description": "Draws the equivalence relations available in the library.\n\nArgs:\n    filename (str): An optional path to write the output image to\n        if specified this method will return None.\n\nReturns:\n    PIL.Image or IPython.display.SVG: Drawn equivalence library as an\n        IPython SVG if in a jupyter notebook, or as a PIL.Image otherwise.\n\nRaises:\n    InvalidFileError: if filename is not valid.",
        "api_signature": "draw(self, filename)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/equivalence.py"
    },
    {
        "api_name": "_build_basis_graph",
        "full_api_name": "EquivalenceLibrary._build_basis_graph",
        "api_description": "",
        "api_signature": "_build_basis_graph(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/equivalence.py"
    },
    {
        "api_name": "_get_equivalences",
        "full_api_name": "EquivalenceLibrary._get_equivalences",
        "api_description": "Get all the equivalences for the given key",
        "api_signature": "_get_equivalences(self, key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/equivalence.py"
    },
    {
        "api_name": "_raise_if_param_mismatch",
        "full_api_name": "_raise_if_param_mismatch",
        "api_description": "",
        "api_signature": "_raise_if_param_mismatch(gate_params, circuit_parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/equivalence.py"
    },
    {
        "api_name": "_raise_if_shape_mismatch",
        "full_api_name": "_raise_if_shape_mismatch",
        "api_description": "",
        "api_signature": "_raise_if_shape_mismatch(gate, circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/equivalence.py"
    },
    {
        "api_name": "_rebind_equiv",
        "full_api_name": "_rebind_equiv",
        "api_description": "",
        "api_signature": "_rebind_equiv(equiv, query_params)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/equivalence.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Reset.__init__",
        "api_description": "Create new reset instruction.",
        "api_signature": "__init__(self, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/reset.py"
    },
    {
        "api_name": "broadcast_arguments",
        "full_api_name": "Reset.broadcast_arguments",
        "api_description": "",
        "api_signature": "broadcast_arguments(self, qargs, cargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/reset.py"
    },
    {
        "api_name": "duration_in_dt",
        "full_api_name": "duration_in_dt",
        "api_description": "Return duration in dt.\n\nArgs:\n    duration_in_sec: duration [s] to be converted.\n    dt_in_sec: duration of dt in seconds used for conversion.\n\nReturns:\n    Duration in dt.",
        "api_signature": "duration_in_dt(duration_in_sec, dt_in_sec)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/duration.py"
    },
    {
        "api_name": "convert_durations_to_dt",
        "full_api_name": "convert_durations_to_dt",
        "api_description": "Convert all the durations in SI (seconds) into those in dt.\n\nReturns a new circuit if `inplace=False`.\n\nParameters:\n    qc (QuantumCircuit): Duration of dt in seconds used for conversion.\n    dt_in_sec (float): Duration of dt in seconds used for conversion.\n    inplace (bool): All durations are converted inplace or return new circuit.\n\nReturns:\n    QuantumCircuit: Converted circuit if `inplace = False`, otherwise None.\n\nRaises:\n    CircuitError: if fail to convert durations.",
        "api_signature": "convert_durations_to_dt(qc, dt_in_sec, inplace)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/duration.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "InstructionSet.__init__",
        "api_description": "New collection of instructions.\n\nThe context (``qargs`` and ``cargs`` that each instruction is attached to) is also stored\nseparately for each instruction.\n\nArgs:\n    resource_requester: A callable that takes in the classical resource used in the\n        condition, verifies that it is present in the attached circuit, resolves any indices\n        into concrete :obj:`.Clbit` instances, and returns the concrete resource.  If this\n        is not given, specifying a condition with an index is forbidden, and all concrete\n        :obj:`.Clbit` and :obj:`.ClassicalRegister` resources will be assumed to be valid.\n\n        .. note::\n\n            The callback ``resource_requester`` is called once for each call to\n            :meth:`.c_if`, and assumes that a call implies that the resource will now be\n            used.  It may throw an error if the resource is not valid for usage.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instructionset.py"
    },
    {
        "api_name": "__len__",
        "full_api_name": "InstructionSet.__len__",
        "api_description": "Return number of instructions in set",
        "api_signature": "__len__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instructionset.py"
    },
    {
        "api_name": "__getitem__",
        "full_api_name": "InstructionSet.__getitem__",
        "api_description": "Return instruction at index",
        "api_signature": "__getitem__(self, i)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instructionset.py"
    },
    {
        "api_name": "add",
        "full_api_name": "InstructionSet.add",
        "api_description": "Add an instruction and its context (where it is attached).",
        "api_signature": "add(self, instruction, qargs, cargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instructionset.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "InstructionSet.inverse",
        "api_description": "Invert all instructions.",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instructionset.py"
    },
    {
        "api_name": "c_if",
        "full_api_name": "InstructionSet.c_if",
        "api_description": "Set a classical equality condition on all the instructions in this set between the\n:obj:`.ClassicalRegister` or :obj:`.Clbit` ``classical`` and value ``val``.\n\n.. note::\n\n    This is a setter method, not an additive one.  Calling this multiple times will silently\n    override any previously set condition on any of the contained instructions; it does not\n    stack.\n\nArgs:\n    classical: the classical resource the equality condition should be on.  If this is given\n        as an integer, it will be resolved into a :obj:`.Clbit` using the same conventions\n        as the circuit these instructions are attached to.\n    val: the value the classical resource should be equal to.\n\nReturns:\n    This same instance of :obj:`.InstructionSet`, but now mutated to have the given equality\n    condition.\n\nRaises:\n    CircuitError: if the passed classical resource is invalid, or otherwise not resolvable\n        to a concrete resource that these instructions are permitted to access.\n\nExample:\n    .. plot::\n       :include-source:\n\n       from qiskit import ClassicalRegister, QuantumRegister, QuantumCircuit\n\n       qr = QuantumRegister(2)\n       cr = ClassicalRegister(2)\n       qc = QuantumCircuit(qr, cr)\n       qc.h(range(2))\n       qc.measure(range(2), range(2))\n\n       # apply x gate if the classical register has the value 2 (10 in binary)\n       qc.x(0).c_if(cr, 2)\n\n       # apply y gate if bit 0 is set to 1\n       qc.y(1).c_if(0, 1)\n\n       qc.draw('mpl')",
        "api_signature": "c_if(self, classical, val)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instructionset.py"
    },
    {
        "api_name": "instructions",
        "full_api_name": "InstructionSet.instructions",
        "api_description": "Legacy getter for the instruction components of an instruction set.  This does not\nsupport mutation.",
        "api_signature": "instructions(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instructionset.py"
    },
    {
        "api_name": "qargs",
        "full_api_name": "InstructionSet.qargs",
        "api_description": "Legacy getter for the qargs components of an instruction set.  This does not support\nmutation.",
        "api_signature": "qargs(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instructionset.py"
    },
    {
        "api_name": "cargs",
        "full_api_name": "InstructionSet.cargs",
        "api_description": "Legacy getter for the cargs components of an instruction set.  This does not support\nmutation.",
        "api_signature": "cargs(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instructionset.py"
    },
    {
        "api_name": "sort_parameters",
        "full_api_name": "sort_parameters",
        "api_description": "Sort an iterable of :class:`.Parameter` instances into a canonical order, respecting the\nordering relationships between elements of :class:`.ParameterVector`\\ s.",
        "api_signature": "sort_parameters(parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/_utils.py"
    },
    {
        "api_name": "key",
        "full_api_name": "key",
        "api_description": "",
        "api_signature": "key(parameter)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/_utils.py"
    },
    {
        "api_name": "_compute_control_matrix",
        "full_api_name": "_compute_control_matrix",
        "api_description": "Compute the controlled version of the input matrix with qiskit ordering.\nThis function computes the controlled unitary with :math:`n` control qubits\nand :math:`m` target qubits,\n\n.. math::\n\n    V_n^j(U_{2^m}) = (U_{2^m} \\otimes |j\\rangle\\!\\langle j|) +\n                     (I_{2^m} \\otimes (I_{2^n} - |j\\rangle\\!\\langle j|)).\n\nwhere :math:`|j\\rangle \\in \\mathcal{H}^{2^n}` is the control state.\n\nArgs:\n    base_mat (ndarray): unitary to be controlled\n    num_ctrl_qubits (int): number of controls for new unitary\n    ctrl_state (int or str or None): The control state in decimal or as\n        a bitstring (e.g. '111'). If None, use 2**num_ctrl_qubits-1.\n\nReturns:\n    ndarray: controlled version of base matrix.\n\nRaises:\n    QiskitError: unrecognized mode or invalid ctrl_state",
        "api_signature": "_compute_control_matrix(base_mat, num_ctrl_qubits, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/_utils.py"
    },
    {
        "api_name": "_ctrl_state_to_int",
        "full_api_name": "_ctrl_state_to_int",
        "api_description": "Convert ctrl_state to int.\n\nArgs:\n    ctrl_state (None, str, int): ctrl_state. If None, set to 2**num_ctrl_qubits-1.\n        If str, convert to int. If int, pass.\n    num_ctrl_qubits (int): The number of control qubits.\n\nReturn:\n    int: ctrl_state\n\nRaises:\n    CircuitError: invalid ctrl_state",
        "api_signature": "_ctrl_state_to_int(ctrl_state, num_ctrl_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/_utils.py"
    },
    {
        "api_name": "with_gate_array",
        "full_api_name": "with_gate_array",
        "api_description": "Class decorator that adds an ``__array__`` method to a :class:`.Gate` instance that returns a\nsingleton nonwritable view onto the complex matrix described by ``base_array``.",
        "api_signature": "with_gate_array(base_array)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/_utils.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "__array__",
        "api_description": "",
        "api_signature": "__array__(_self, dtype)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/_utils.py"
    },
    {
        "api_name": "decorator",
        "full_api_name": "decorator",
        "api_description": "",
        "api_signature": "decorator(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/_utils.py"
    },
    {
        "api_name": "with_controlled_gate_array",
        "full_api_name": "with_controlled_gate_array",
        "api_description": "Class decorator that adds an ``__array__`` method to a :class:`.ControlledGate` instance that\nreturns singleton nonwritable views onto a relevant precomputed complex matrix for the given\ncontrol state.\n\nIf ``cached_states`` is not given, then all possible control states are precomputed.  If it is\ngiven, it should be an iterable of integers, and only these control states will be cached.",
        "api_signature": "with_controlled_gate_array(base_array, num_ctrl_qubits, cached_states)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/_utils.py"
    },
    {
        "api_name": "matrix_for_control_state",
        "full_api_name": "matrix_for_control_state",
        "api_description": "",
        "api_signature": "matrix_for_control_state(state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/_utils.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "__array__",
        "api_description": "",
        "api_signature": "__array__(self, dtype)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/_utils.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "__array__",
        "api_description": "",
        "api_signature": "__array__(self, dtype)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/_utils.py"
    },
    {
        "api_name": "decorator",
        "full_api_name": "decorator",
        "api_description": "",
        "api_signature": "decorator(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/_utils.py"
    },
    {
        "api_name": "__get__",
        "full_api_name": "_NameFormat.__get__",
        "api_description": "",
        "api_signature": "__get__(self, obj, objtype)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/register.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Register.__init__",
        "api_description": "Create a new generic register.\n\nEither the ``size`` or the ``bits`` argument must be provided. If\n``size`` is not None, the register will be pre-populated with bits of the\ncorrect type.\n\nArgs:\n    size (int): Optional. The number of bits to include in the register.\n    name (str): Optional. The name of the register. If not provided, a\n       unique name will be auto-generated from the register type.\n    bits (list[Bit]): Optional. A list of Bit() instances to be used to\n       populate the register.\n\nRaises:\n    CircuitError: if both the ``size`` and ``bits`` arguments are\n        provided, or if neither are.\n    CircuitError: if ``size`` is not valid.\n    CircuitError: if ``name`` is not a valid name according to the\n        OpenQASM spec.\n    CircuitError: if ``bits`` contained duplicated bits.\n    CircuitError: if ``bits`` contained bits of an incorrect type.",
        "api_signature": "__init__(self, size, name, bits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/register.py"
    },
    {
        "api_name": "name",
        "full_api_name": "Register.name",
        "api_description": "Get the register name.",
        "api_signature": "name(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/register.py"
    },
    {
        "api_name": "size",
        "full_api_name": "Register.size",
        "api_description": "Get the register size.",
        "api_signature": "size(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/register.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "Register.__repr__",
        "api_description": "Return the official string representing the register.",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/register.py"
    },
    {
        "api_name": "__len__",
        "full_api_name": "Register.__len__",
        "api_description": "Return register size.",
        "api_signature": "__len__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/register.py"
    },
    {
        "api_name": "__getitem__",
        "full_api_name": "Register.__getitem__",
        "api_description": "Arg:\n    bit_type (Qubit or Clbit): a constructor type return element/s.\n    key (int or slice or list): index of the bit to be retrieved.\n\nReturns:\n    Qubit or Clbit or list(Qubit) or list(Clbit): a Qubit or Clbit instance if\n    key is int. If key is a slice, returns a list of these instances.\n\nRaises:\n    CircuitError: if the `key` is not an integer or not in the range `(0, self.size)`.",
        "api_signature": "__getitem__(self, key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/register.py"
    },
    {
        "api_name": "__iter__",
        "full_api_name": "Register.__iter__",
        "api_description": "",
        "api_signature": "__iter__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/register.py"
    },
    {
        "api_name": "__contains__",
        "full_api_name": "Register.__contains__",
        "api_description": "",
        "api_signature": "__contains__(self, bit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/register.py"
    },
    {
        "api_name": "index",
        "full_api_name": "Register.index",
        "api_description": "Find the index of the provided bit within this register.",
        "api_signature": "index(self, bit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/register.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "Register.__eq__",
        "api_description": "Two Registers are the same if they are of the same type\n(i.e. quantum/classical), and have the same name and size. Additionally,\nif either Register contains new-style bits, the bits in both registers\nwill be checked for pairwise equality. If two registers are equal,\nthey will have behave identically when specified as circuit args.\n\nArgs:\n    other (Register): other Register\n\nReturns:\n    bool: `self` and `other` are equal.",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/register.py"
    },
    {
        "api_name": "__hash__",
        "full_api_name": "Register.__hash__",
        "api_description": "Make object hashable, based on the name and size to hash.",
        "api_signature": "__hash__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/register.py"
    },
    {
        "api_name": "__getstate__",
        "full_api_name": "Register.__getstate__",
        "api_description": "",
        "api_signature": "__getstate__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/register.py"
    },
    {
        "api_name": "__setstate__",
        "full_api_name": "Register.__setstate__",
        "api_description": "",
        "api_signature": "__setstate__(self, state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/register.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CircuitInstruction.__init__",
        "api_description": "",
        "api_signature": "__init__(self, operation, qubits, clbits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuitdata.py"
    },
    {
        "api_name": "copy",
        "full_api_name": "CircuitInstruction.copy",
        "api_description": "Return a shallow copy of the :class:`CircuitInstruction`.",
        "api_signature": "copy(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuitdata.py"
    },
    {
        "api_name": "replace",
        "full_api_name": "CircuitInstruction.replace",
        "api_description": "Return a new :class:`CircuitInstruction` with the given fields replaced.",
        "api_signature": "replace(self, operation, qubits, clbits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuitdata.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "CircuitInstruction.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuitdata.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "CircuitInstruction.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuitdata.py"
    },
    {
        "api_name": "_legacy_format",
        "full_api_name": "CircuitInstruction._legacy_format",
        "api_description": "",
        "api_signature": "_legacy_format(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuitdata.py"
    },
    {
        "api_name": "__getitem__",
        "full_api_name": "CircuitInstruction.__getitem__",
        "api_description": "",
        "api_signature": "__getitem__(self, key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuitdata.py"
    },
    {
        "api_name": "__iter__",
        "full_api_name": "CircuitInstruction.__iter__",
        "api_description": "",
        "api_signature": "__iter__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuitdata.py"
    },
    {
        "api_name": "__len__",
        "full_api_name": "CircuitInstruction.__len__",
        "api_description": "",
        "api_signature": "__len__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuitdata.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QuantumCircuitData.__init__",
        "api_description": "",
        "api_signature": "__init__(self, circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuitdata.py"
    },
    {
        "api_name": "__getitem__",
        "full_api_name": "QuantumCircuitData.__getitem__",
        "api_description": "",
        "api_signature": "__getitem__(self, i)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuitdata.py"
    },
    {
        "api_name": "__setitem__",
        "full_api_name": "QuantumCircuitData.__setitem__",
        "api_description": "",
        "api_signature": "__setitem__(self, key, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuitdata.py"
    },
    {
        "api_name": "_resolve_legacy_value",
        "full_api_name": "QuantumCircuitData._resolve_legacy_value",
        "api_description": "Resolve the old-style 3-tuple into the new :class:`CircuitInstruction` type.",
        "api_signature": "_resolve_legacy_value(self, operation, qargs, cargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuitdata.py"
    },
    {
        "api_name": "insert",
        "full_api_name": "QuantumCircuitData.insert",
        "api_description": "",
        "api_signature": "insert(self, index, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuitdata.py"
    },
    {
        "api_name": "__iter__",
        "full_api_name": "QuantumCircuitData.__iter__",
        "api_description": "",
        "api_signature": "__iter__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuitdata.py"
    },
    {
        "api_name": "__delitem__",
        "full_api_name": "QuantumCircuitData.__delitem__",
        "api_description": "",
        "api_signature": "__delitem__(self, i)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuitdata.py"
    },
    {
        "api_name": "__len__",
        "full_api_name": "QuantumCircuitData.__len__",
        "api_description": "",
        "api_signature": "__len__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuitdata.py"
    },
    {
        "api_name": "__cast",
        "full_api_name": "QuantumCircuitData.__cast",
        "api_description": "",
        "api_signature": "__cast(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuitdata.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "QuantumCircuitData.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuitdata.py"
    },
    {
        "api_name": "__lt__",
        "full_api_name": "QuantumCircuitData.__lt__",
        "api_description": "",
        "api_signature": "__lt__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuitdata.py"
    },
    {
        "api_name": "__le__",
        "full_api_name": "QuantumCircuitData.__le__",
        "api_description": "",
        "api_signature": "__le__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuitdata.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "QuantumCircuitData.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuitdata.py"
    },
    {
        "api_name": "__gt__",
        "full_api_name": "QuantumCircuitData.__gt__",
        "api_description": "",
        "api_signature": "__gt__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuitdata.py"
    },
    {
        "api_name": "__ge__",
        "full_api_name": "QuantumCircuitData.__ge__",
        "api_description": "",
        "api_signature": "__ge__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuitdata.py"
    },
    {
        "api_name": "__add__",
        "full_api_name": "QuantumCircuitData.__add__",
        "api_description": "",
        "api_signature": "__add__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuitdata.py"
    },
    {
        "api_name": "__radd__",
        "full_api_name": "QuantumCircuitData.__radd__",
        "api_description": "",
        "api_signature": "__radd__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuitdata.py"
    },
    {
        "api_name": "__mul__",
        "full_api_name": "QuantumCircuitData.__mul__",
        "api_description": "",
        "api_signature": "__mul__(self, n)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuitdata.py"
    },
    {
        "api_name": "__rmul__",
        "full_api_name": "QuantumCircuitData.__rmul__",
        "api_description": "",
        "api_signature": "__rmul__(self, n)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuitdata.py"
    },
    {
        "api_name": "sort",
        "full_api_name": "QuantumCircuitData.sort",
        "api_description": "In-place stable sort. Accepts arguments of list.sort.",
        "api_signature": "sort(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuitdata.py"
    },
    {
        "api_name": "copy",
        "full_api_name": "QuantumCircuitData.copy",
        "api_description": "Returns a shallow copy of instruction list.",
        "api_signature": "copy(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuitdata.py"
    },
    {
        "api_name": "_impl_init_subclass",
        "full_api_name": "_impl_init_subclass",
        "api_description": "",
        "api_signature": "_impl_init_subclass(base, overrides)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/singleton.py"
    },
    {
        "api_name": "__init_subclass__",
        "full_api_name": "__init_subclass__",
        "api_description": "",
        "api_signature": "__init_subclass__(instruction_class)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/singleton.py"
    },
    {
        "api_name": "__new__",
        "full_api_name": "_Singleton.__new__",
        "api_description": "",
        "api_signature": "__new__(singleton_class)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/singleton.py"
    },
    {
        "api_name": "base_class",
        "full_api_name": "_Singleton.base_class",
        "api_description": "",
        "api_signature": "base_class(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/singleton.py"
    },
    {
        "api_name": "mutable",
        "full_api_name": "_Singleton.mutable",
        "api_description": "",
        "api_signature": "mutable(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/singleton.py"
    },
    {
        "api_name": "to_mutable",
        "full_api_name": "_Singleton.to_mutable",
        "api_description": "",
        "api_signature": "to_mutable(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/singleton.py"
    },
    {
        "api_name": "__setattr__",
        "full_api_name": "_Singleton.__setattr__",
        "api_description": "",
        "api_signature": "__setattr__(self, key, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/singleton.py"
    },
    {
        "api_name": "__copy__",
        "full_api_name": "_Singleton.__copy__",
        "api_description": "",
        "api_signature": "__copy__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/singleton.py"
    },
    {
        "api_name": "__deepcopy__",
        "full_api_name": "_Singleton.__deepcopy__",
        "api_description": "",
        "api_signature": "__deepcopy__(self, memo)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/singleton.py"
    },
    {
        "api_name": "__reduce__",
        "full_api_name": "_Singleton.__reduce__",
        "api_description": "",
        "api_signature": "__reduce__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/singleton.py"
    },
    {
        "api_name": "_create_singleton_instance",
        "full_api_name": "_create_singleton_instance",
        "api_description": "",
        "api_signature": "_create_singleton_instance(args, kwargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/singleton.py"
    },
    {
        "api_name": "__new__",
        "full_api_name": "_SingletonMeta.__new__",
        "api_description": "",
        "api_signature": "__new__(mcs, name, bases, namespace)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/singleton.py"
    },
    {
        "api_name": "__call__",
        "full_api_name": "_SingletonMeta.__call__",
        "api_description": "",
        "api_signature": "__call__(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/singleton.py"
    },
    {
        "api_name": "_singleton_lookup_key",
        "full_api_name": "_SingletonBase._singleton_lookup_key",
        "api_description": "Given the arguments to the constructor, return a key tuple that identifies the singleton\ninstance to retrieve, or ``None`` if the arguments imply that a mutable object must be\ncreated.\n\nFor performance, as a special case, this method will not be called if the class constructor\nwas given zero arguments (e.g. the construction ``XGate()`` will not call this method, but\n``XGate(label=None)`` will), and the default singleton will immediately be returned.\n\nThis static method can (and probably should) be overridden by subclasses.  The derived\nsignature should match the class's ``__init__``; this method should then examine the\narguments to determine whether it requires mutability, or what the cache key (if any) should\nbe.\n\nThe function should return either ``None`` or valid ``dict`` key (i.e. hashable and\nimplements equality).  Returning ``None`` means that the created instance must be mutable.\nNo further singleton-based processing will be done, and the class creation will proceed as\nif there was no singleton handling.  Otherwise, the returned key can be anything hashable\nand no special meaning is ascribed to it.  Whenever this method returns the same key, the\nsame singleton instance will be returned.  We suggest that you use a tuple of the values of\nall arguments that can be set while maintaining the singleton nature.\n\nOnly keys that match the default arguments or arguments given to ``additional_singletons``\nat class-creation time will actually return singletons; other values will return a standard\nmutable instance.\n\n.. note::\n\n    The singleton machinery will handle an unhashable return from this function gracefully\n    by returning a mutable instance.  Subclasses should ensure that their key is hashable in\n    the happy path, but they do not need to manually verify that the user-supplied arguments\n    are hashable.  For example, it's safe to implement this as::\n\n        @staticmethod\n        def _singleton_lookup_key(*args, **kwargs):\n            return None if kwargs else args\n\n    even though a user might give some unhashable type as one of the ``args``.",
        "api_signature": "_singleton_lookup_key()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/singleton.py"
    },
    {
        "api_name": "_reject_mutation",
        "full_api_name": "_frozenlist._reject_mutation",
        "api_description": "",
        "api_signature": "_reject_mutation(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/singleton.py"
    },
    {
        "api_name": "_prepare_singleton_instance",
        "full_api_name": "_SingletonInstructionOverrides._prepare_singleton_instance",
        "api_description": "Class-creation hook point.  Given an instance of the type that these overrides correspond\nto, this method should ensure that all lazy properties and caches that require mutation to\nwrite to are eagerly defined.\n\nSubclass \"overrides\" classes can override this method if the user/library-author-facing\nclass they are providing overrides for has more lazy attributes or user-exposed state\nwith interior mutability.",
        "api_signature": "_prepare_singleton_instance(instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/singleton.py"
    },
    {
        "api_name": "c_if",
        "full_api_name": "_SingletonInstructionOverrides.c_if",
        "api_description": "",
        "api_signature": "c_if(self, classical, val)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/singleton.py"
    },
    {
        "api_name": "copy",
        "full_api_name": "_SingletonInstructionOverrides.copy",
        "api_description": "",
        "api_signature": "copy(self, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/singleton.py"
    },
    {
        "api_name": "stdlib_singleton_key",
        "full_api_name": "stdlib_singleton_key",
        "api_description": "Create an implementation of the abstract method\n:meth:`SingletonInstruction._singleton_lookup_key`, for standard-library instructions whose\n``__init__`` signatures match the one given here.\n\n.. warning::\n\n    This method is not safe for use in classes defined outside of Qiskit; it is not included in\n    the backwards compatibility guarantees.  This is because we guarantee that the call\n    signatures of the base classes are backwards compatible in the sense that we will only\n    replace them (without warning) contravariantly, but if you use this method, you effectively\n    use the signature *invariantly*, and we cannot guarantee that.\n\nArgs:\n    num_ctrl_qubits: if given, this implies that the gate is a :class:`.ControlledGate`, and\n        will have a fixed number of qubits that are used as the control.  This is necessary to\n        allow ``ctrl_state`` to be given as either ``None`` or as an all-ones integer/string.",
        "api_signature": "stdlib_singleton_key()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/singleton.py"
    },
    {
        "api_name": "key",
        "full_api_name": "key",
        "api_description": "",
        "api_signature": "key(label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/singleton.py"
    },
    {
        "api_name": "key",
        "full_api_name": "key",
        "api_description": "",
        "api_signature": "key(label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/singleton.py"
    },
    {
        "api_name": "__getattr__",
        "full_api_name": "__getattr__",
        "api_description": "",
        "api_signature": "__getattr__(name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/__init__.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ControlledGate.__init__",
        "api_description": "Create a new ControlledGate. In the new gate the first ``num_ctrl_qubits``\nof the gate are the controls.\n\nArgs:\n    name: The name of the gate.\n    num_qubits: The number of qubits the gate acts on.\n    params: A list of parameters for the gate.\n    label: An optional label for the gate.\n    num_ctrl_qubits: Number of control qubits.\n    definition: A list of gate rules for implementing this gate. The\n        elements of the list are tuples of (:meth:`~qiskit.circuit.Gate`, [qubit_list],\n        [clbit_list]).\n    ctrl_state: The control state in decimal or as\n        a bitstring (e.g. '111'). If specified as a bitstring the length\n        must equal num_ctrl_qubits, MSB on left. If None, use\n        2**num_ctrl_qubits-1.\n    base_gate: Gate object to be controlled.\n\nRaises:\n    CircuitError: If ``num_ctrl_qubits`` >= ``num_qubits``.\n    CircuitError: ctrl_state < 0 or ctrl_state > 2**num_ctrl_qubits.\n\nExamples:\n\nCreate a controlled standard gate and apply it to a circuit.\n\n.. plot::\n   :include-source:\n\n   from qiskit import QuantumCircuit, QuantumRegister\n   from qiskit.circuit.library.standard_gates import HGate\n\n   qr = QuantumRegister(3)\n   qc = QuantumCircuit(qr)\n   c3h_gate = HGate().control(2)\n   qc.append(c3h_gate, qr)\n   qc.draw('mpl')\n\nCreate a controlled custom gate and apply it to a circuit.\n\n.. plot::\n   :include-source:\n\n   from qiskit import QuantumCircuit, QuantumRegister\n   from qiskit.circuit.library.standard_gates import HGate\n\n   qc1 = QuantumCircuit(2)\n   qc1.x(0)\n   qc1.h(1)\n   custom = qc1.to_gate().control(2)\n\n   qc2 = QuantumCircuit(4)\n   qc2.append(custom, [0, 3, 1, 2])\n   qc2.draw('mpl')",
        "api_signature": "__init__(self, name, num_qubits, params, label, num_ctrl_qubits, definition, ctrl_state, base_gate, duration, unit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlledgate.py"
    },
    {
        "api_name": "definition",
        "full_api_name": "ControlledGate.definition",
        "api_description": "Return definition in terms of other basic gates. If the gate has\nopen controls, as determined from `self.ctrl_state`, the returned\ndefinition is conjugated with X without changing the internal\n`_definition`.",
        "api_signature": "definition(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlledgate.py"
    },
    {
        "api_name": "definition",
        "full_api_name": "ControlledGate.definition",
        "api_description": "Set controlled gate definition with closed controls.\n\nArgs:\n    excited_def: The circuit with all closed controls.",
        "api_signature": "definition(self, excited_def)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlledgate.py"
    },
    {
        "api_name": "name",
        "full_api_name": "ControlledGate.name",
        "api_description": "Get name of gate. If the gate has open controls the gate name\nwill become:\n\n   <original_name_o<ctrl_state>\n\nwhere <original_name> is the gate name for the default case of\nclosed control qubits and <ctrl_state> is the integer value of\nthe control state for the gate.",
        "api_signature": "name(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlledgate.py"
    },
    {
        "api_name": "name",
        "full_api_name": "ControlledGate.name",
        "api_description": "Set the name of the gate. Note the reported name may differ\nfrom the set name if the gate has open controls.",
        "api_signature": "name(self, name_str)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlledgate.py"
    },
    {
        "api_name": "num_ctrl_qubits",
        "full_api_name": "ControlledGate.num_ctrl_qubits",
        "api_description": "Get number of control qubits.\n\nReturns:\n    int: The number of control qubits for the gate.",
        "api_signature": "num_ctrl_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlledgate.py"
    },
    {
        "api_name": "num_ctrl_qubits",
        "full_api_name": "ControlledGate.num_ctrl_qubits",
        "api_description": "Set the number of control qubits.\n\nArgs:\n    num_ctrl_qubits (int): The number of control qubits.\n\nRaises:\n    CircuitError: ``num_ctrl_qubits`` is not an integer in ``[1, num_qubits]``.",
        "api_signature": "num_ctrl_qubits(self, num_ctrl_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlledgate.py"
    },
    {
        "api_name": "ctrl_state",
        "full_api_name": "ControlledGate.ctrl_state",
        "api_description": "Return the control state of the gate as a decimal integer.",
        "api_signature": "ctrl_state(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlledgate.py"
    },
    {
        "api_name": "ctrl_state",
        "full_api_name": "ControlledGate.ctrl_state",
        "api_description": "Set the control state of this gate.\n\nArgs:\n    ctrl_state: The control state of the gate.\n\nRaises:\n    CircuitError: ctrl_state is invalid.",
        "api_signature": "ctrl_state(self, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlledgate.py"
    },
    {
        "api_name": "params",
        "full_api_name": "ControlledGate.params",
        "api_description": "Get parameters from base_gate.\n\nReturns:\n    list: List of gate parameters.\n\nRaises:\n    CircuitError: Controlled gate does not define a base gate",
        "api_signature": "params(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlledgate.py"
    },
    {
        "api_name": "params",
        "full_api_name": "ControlledGate.params",
        "api_description": "Set base gate parameters.\n\nArgs:\n    parameters (list): The list of parameters to set.\n\nRaises:\n    CircuitError: If controlled gate does not define a base gate.",
        "api_signature": "params(self, parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlledgate.py"
    },
    {
        "api_name": "__deepcopy__",
        "full_api_name": "ControlledGate.__deepcopy__",
        "api_description": "",
        "api_signature": "__deepcopy__(self, memo)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlledgate.py"
    },
    {
        "api_name": "_open_ctrl",
        "full_api_name": "ControlledGate._open_ctrl",
        "api_description": "Return whether gate has any open controls",
        "api_signature": "_open_ctrl(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlledgate.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "ControlledGate.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlledgate.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "ControlledGate.inverse",
        "api_description": "Invert this gate by calling inverse on the base gate.",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlledgate.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ParameterVectorElement.__init__",
        "api_description": "",
        "api_signature": "__init__(self, vector, index, uuid)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametervector.py"
    },
    {
        "api_name": "index",
        "full_api_name": "ParameterVectorElement.index",
        "api_description": "Get the index of this element in the parent vector.",
        "api_signature": "index(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametervector.py"
    },
    {
        "api_name": "vector",
        "full_api_name": "ParameterVectorElement.vector",
        "api_description": "Get the parent vector instance.",
        "api_signature": "vector(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametervector.py"
    },
    {
        "api_name": "__getstate__",
        "full_api_name": "ParameterVectorElement.__getstate__",
        "api_description": "",
        "api_signature": "__getstate__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametervector.py"
    },
    {
        "api_name": "__setstate__",
        "full_api_name": "ParameterVectorElement.__setstate__",
        "api_description": "",
        "api_signature": "__setstate__(self, state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametervector.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ParameterVector.__init__",
        "api_description": "",
        "api_signature": "__init__(self, name, length)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametervector.py"
    },
    {
        "api_name": "name",
        "full_api_name": "ParameterVector.name",
        "api_description": "Returns the name of the ParameterVector.",
        "api_signature": "name(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametervector.py"
    },
    {
        "api_name": "params",
        "full_api_name": "ParameterVector.params",
        "api_description": "Returns the list of parameters in the ParameterVector.",
        "api_signature": "params(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametervector.py"
    },
    {
        "api_name": "index",
        "full_api_name": "ParameterVector.index",
        "api_description": "Returns first index of value.",
        "api_signature": "index(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametervector.py"
    },
    {
        "api_name": "__getitem__",
        "full_api_name": "ParameterVector.__getitem__",
        "api_description": "",
        "api_signature": "__getitem__(self, key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametervector.py"
    },
    {
        "api_name": "__iter__",
        "full_api_name": "ParameterVector.__iter__",
        "api_description": "",
        "api_signature": "__iter__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametervector.py"
    },
    {
        "api_name": "__len__",
        "full_api_name": "ParameterVector.__len__",
        "api_description": "",
        "api_signature": "__len__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametervector.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "ParameterVector.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametervector.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "ParameterVector.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametervector.py"
    },
    {
        "api_name": "resize",
        "full_api_name": "ParameterVector.resize",
        "api_description": "Resize the parameter vector.\n\nIf necessary, new elements are generated. If length is smaller than before, the\nprevious elements are cached and not re-generated if the vector is enlarged again.\nThis is to ensure that the parameter instances do not change.",
        "api_signature": "resize(self, length)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametervector.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Gate.__init__",
        "api_description": "Create a new gate.\n\nArgs:\n    name: The Qobj name of the gate.\n    num_qubits: The number of qubits the gate acts on.\n    params: A list of parameters.\n    label: An optional label for the gate.",
        "api_signature": "__init__(self, name, num_qubits, params, label, duration, unit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/gate.py"
    },
    {
        "api_name": "to_matrix",
        "full_api_name": "Gate.to_matrix",
        "api_description": "Return a Numpy.array for the gate unitary matrix.\n\nReturns:\n    np.ndarray: if the Gate subclass has a matrix definition.\n\nRaises:\n    CircuitError: If a Gate subclass does not implement this method an\n        exception will be raised when this base class method is called.",
        "api_signature": "to_matrix(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/gate.py"
    },
    {
        "api_name": "power",
        "full_api_name": "Gate.power",
        "api_description": "Creates a unitary gate as `gate^exponent`.\n\nArgs:\n    exponent (float): Gate^exponent\n\nReturns:\n    .library.UnitaryGate: To which `to_matrix` is self.to_matrix^exponent.\n\nRaises:\n    CircuitError: If Gate is not unitary",
        "api_signature": "power(self, exponent)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/gate.py"
    },
    {
        "api_name": "__pow__",
        "full_api_name": "Gate.__pow__",
        "api_description": "",
        "api_signature": "__pow__(self, exponent)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/gate.py"
    },
    {
        "api_name": "_return_repeat",
        "full_api_name": "Gate._return_repeat",
        "api_description": "",
        "api_signature": "_return_repeat(self, exponent)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/gate.py"
    },
    {
        "api_name": "control",
        "full_api_name": "Gate.control",
        "api_description": "Return controlled version of gate. See :class:`.ControlledGate` for usage.\n\nArgs:\n    num_ctrl_qubits: number of controls to add to gate (default: ``1``)\n    label: optional gate label\n    ctrl_state: The control state in decimal or as a bitstring\n        (e.g. ``'111'``). If ``None``, use ``2**num_ctrl_qubits-1``.\n\nReturns:\n    qiskit.circuit.ControlledGate: Controlled version of gate. This default algorithm\n    uses ``num_ctrl_qubits-1`` ancilla qubits so returns a gate of size\n    ``num_qubits + 2*num_ctrl_qubits - 1``.\n\nRaises:\n    QiskitError: unrecognized mode or invalid ctrl_state",
        "api_signature": "control(self, num_ctrl_qubits, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/gate.py"
    },
    {
        "api_name": "_broadcast_single_argument",
        "full_api_name": "Gate._broadcast_single_argument",
        "api_description": "Expands a single argument.\n\nFor example: [q[0], q[1]] -> [q[0]], [q[1]]",
        "api_signature": "_broadcast_single_argument(qarg)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/gate.py"
    },
    {
        "api_name": "_broadcast_2_arguments",
        "full_api_name": "Gate._broadcast_2_arguments",
        "api_description": "",
        "api_signature": "_broadcast_2_arguments(qarg0, qarg1)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/gate.py"
    },
    {
        "api_name": "_broadcast_3_or_more_args",
        "full_api_name": "Gate._broadcast_3_or_more_args",
        "api_description": "",
        "api_signature": "_broadcast_3_or_more_args(qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/gate.py"
    },
    {
        "api_name": "broadcast_arguments",
        "full_api_name": "Gate.broadcast_arguments",
        "api_description": "Validation and handling of the arguments and its relationship.\n\nFor example, ``cx([q[0],q[1]], q[2])`` means ``cx(q[0], q[2]); cx(q[1], q[2])``. This\nmethod yields the arguments in the right grouping. In the given example::\n\n    in: [[q[0],q[1]], q[2]],[]\n    outs: [q[0], q[2]], []\n          [q[1], q[2]], []\n\nThe general broadcasting rules are:\n\n    * If len(qargs) == 1::\n\n        [q[0], q[1]] -> [q[0]],[q[1]]\n\n    * If len(qargs) == 2::\n\n        [[q[0], q[1]], [r[0], r[1]]] -> [q[0], r[0]], [q[1], r[1]]\n        [[q[0]], [r[0], r[1]]]       -> [q[0], r[0]], [q[0], r[1]]\n        [[q[0], q[1]], [r[0]]]       -> [q[0], r[0]], [q[1], r[0]]\n\n    * If len(qargs) >= 3::\n\n        [q[0], q[1]], [r[0], r[1]],  ...] -> [q[0], r[0], ...], [q[1], r[1], ...]\n\nArgs:\n    qargs: List of quantum bit arguments.\n    cargs: List of classical bit arguments.\n\nReturns:\n    A tuple with single arguments.\n\nRaises:\n    CircuitError: If the input is not valid. For example, the number of\n        arguments does not match the gate expectation.",
        "api_signature": "broadcast_arguments(self, qargs, cargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/gate.py"
    },
    {
        "api_name": "validate_parameter",
        "full_api_name": "Gate.validate_parameter",
        "api_description": "Gate parameters should be int, float, or ParameterExpression",
        "api_signature": "validate_parameter(self, parameter)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/gate.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Measure.__init__",
        "api_description": "Create new measurement instruction.",
        "api_signature": "__init__(self, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/measure.py"
    },
    {
        "api_name": "broadcast_arguments",
        "full_api_name": "Measure.broadcast_arguments",
        "api_description": "",
        "api_signature": "broadcast_arguments(self, qargs, cargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/measure.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "VariableMapper.__init__",
        "api_description": "",
        "api_signature": "__init__(self, target_cregs, bit_map, add_register)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/_classical_resource_map.py"
    },
    {
        "api_name": "_map_register",
        "full_api_name": "VariableMapper._map_register",
        "api_description": "Map the target's registers to suitable equivalents in the destination, adding an\nextra one if there's no exact match.",
        "api_signature": "_map_register(self, theirs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/_classical_resource_map.py"
    },
    {
        "api_name": "map_condition",
        "full_api_name": "VariableMapper.map_condition",
        "api_description": "Map the given ``condition`` so that it only references variables in the destination\ncircuit (as given to this class on initialisation).\n\nIf ``allow_reorder`` is ``True``, then when a legacy condition (the two-tuple form) is made\non a register that has a counterpart in the destination with all the same (mapped) bits but\nin a different order, then that register will be used and the value suitably modified to\nmake the equality condition work.  This is maintaining legacy (tested) behaviour of\n:meth:`.DAGCircuit.compose`; nowhere else does this, and in general this would require *far*\nmore complex classical rewriting than Terra needs to worry about in the full expression era.",
        "api_signature": "map_condition()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/_classical_resource_map.py"
    },
    {
        "api_name": "map_target",
        "full_api_name": "VariableMapper.map_target",
        "api_description": "Map the runtime variables in a ``target`` of a :class:`.SwitchCaseOp` to the new circuit,\nas defined in the ``circuit`` argument of the initialiser of this class.",
        "api_signature": "map_target()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/_classical_resource_map.py"
    },
    {
        "api_name": "map_expr",
        "full_api_name": "VariableMapper.map_expr",
        "api_description": "Map the variables in an :class:`~.expr.Expr` node to the new circuit.",
        "api_signature": "map_expr()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/_classical_resource_map.py"
    },
    {
        "api_name": "visit_var",
        "full_api_name": "VariableMapper.visit_var",
        "api_description": "",
        "api_signature": "visit_var()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/_classical_resource_map.py"
    },
    {
        "api_name": "visit_value",
        "full_api_name": "VariableMapper.visit_value",
        "api_description": "",
        "api_signature": "visit_value()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/_classical_resource_map.py"
    },
    {
        "api_name": "visit_unary",
        "full_api_name": "VariableMapper.visit_unary",
        "api_description": "",
        "api_signature": "visit_unary()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/_classical_resource_map.py"
    },
    {
        "api_name": "visit_binary",
        "full_api_name": "VariableMapper.visit_binary",
        "api_description": "",
        "api_signature": "visit_binary()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/_classical_resource_map.py"
    },
    {
        "api_name": "visit_cast",
        "full_api_name": "VariableMapper.visit_cast",
        "api_description": "",
        "api_signature": "visit_cast()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/_classical_resource_map.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Clbit.__init__",
        "api_description": "Creates a classical bit.\n\nArgs:\n    register (ClassicalRegister): Optional. A classical register containing the bit.\n    index (int): Optional. The index of the bit in its containing register.\n\nRaises:\n    CircuitError: if the provided register is not a valid :class:`ClassicalRegister`",
        "api_signature": "__init__(self, register, index)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classicalregister.py"
    },
    {
        "api_name": "qasm",
        "full_api_name": "ClassicalRegister.qasm",
        "api_description": "Return OPENQASM string for this register.",
        "api_signature": "qasm(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classicalregister.py"
    },
    {
        "api_name": "add_control",
        "full_api_name": "add_control",
        "api_description": "For standard gates, if the controlled version already exists in the\nlibrary, it will be returned (e.g. XGate.control() = CnotGate().\n\nFor more generic gates, this method implements the controlled\nversion by first decomposing into the ['u1', 'u3', 'cx'] basis, then\ncontrolling each gate in the decomposition.\n\nOpen controls are implemented by conjugating the control line with\nX gates. Adds num_ctrl_qubits controls to operation.\n\nThis function is meant to be called from the\n:method:`qiskit.circuit.gate.Gate.control()` method.\n\nArgs:\n    operation: The operation to be controlled.\n    num_ctrl_qubits: The number of controls to add to gate.\n    label: An optional gate label.\n    ctrl_state: The control state in decimal or as a bitstring\n        (e.g. '111'). If specified as a bitstring the length\n        must equal num_ctrl_qubits, MSB on left. If None, use\n        2**num_ctrl_qubits-1.\n\nReturns:\n    Controlled version of gate.",
        "api_signature": "add_control(operation, num_ctrl_qubits, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/add_control.py"
    },
    {
        "api_name": "control",
        "full_api_name": "control",
        "api_description": "Return controlled version of gate using controlled rotations. This function\nfirst checks the name of the operation to see if it knows of a method from which\nto generate a controlled version. Currently these are `x`, `rx`, `ry`, and `rz`.\nIf a method is not directly known, it calls the unroller to convert to `u1`, `u3`,\nand `cx` gates.\n\nArgs:\n    operation: The gate used to create the ControlledGate.\n    num_ctrl_qubits: The number of controls to add to gate (default=1).\n    label: An optional gate label.\n    ctrl_state: The control state in decimal or as\n        a bitstring (e.g. '111'). If specified as a bitstring the length\n        must equal num_ctrl_qubits, MSB on left. If None, use\n        2**num_ctrl_qubits-1.\n\nReturns:\n    Controlled version of gate.\n\nRaises:\n    CircuitError: gate contains non-gate in definition",
        "api_signature": "control(operation, num_ctrl_qubits, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/add_control.py"
    },
    {
        "api_name": "_gate_to_circuit",
        "full_api_name": "_gate_to_circuit",
        "api_description": "Converts a gate instance to a QuantumCircuit",
        "api_signature": "_gate_to_circuit(operation)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/add_control.py"
    },
    {
        "api_name": "_unroll_gate",
        "full_api_name": "_unroll_gate",
        "api_description": "Unrolls a gate, possibly composite, to the target basis",
        "api_signature": "_unroll_gate(operation, basis_gates)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/add_control.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Instruction.__init__",
        "api_description": "Create a new instruction.\n\nArgs:\n    name (str): instruction name\n    num_qubits (int): instruction's qubit width\n    num_clbits (int): instruction's clbit width\n    params (list[int|float|complex|str|ndarray|list|ParameterExpression]):\n        list of parameters\n    duration (int or float): instruction's duration. it must be integer if ``unit`` is 'dt'\n    unit (str): time unit of duration\n    label (str or None): An optional label for identifying the instruction.\n\nRaises:\n    CircuitError: when the register is not in the correct format.\n    TypeError: when the optional label is provided, but it is not a string.",
        "api_signature": "__init__(self, name, num_qubits, num_clbits, params, duration, unit, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "base_class",
        "full_api_name": "Instruction.base_class",
        "api_description": "Get the base class of this instruction.  This is guaranteed to be in the inheritance tree\nof ``self``.\n\nThe \"base class\" of an instruction is the lowest class in its inheritance tree that the\nobject should be considered entirely compatible with for _all_ circuit applications.  This\ntypically means that the subclass is defined purely to offer some sort of programmer\nconvenience over the base class, and the base class is the \"true\" class for a behavioural\nperspective.  In particular, you should *not* override :attr:`base_class` if you are\ndefining a custom version of an instruction that will be implemented differently by\nhardware, such as an alternative measurement strategy, or a version of a parametrised gate\nwith a particular set of parameters for the purposes of distinguishing it in a\n:class:`.Target` from the full parametrised gate.\n\nThis is often exactly equivalent to ``type(obj)``, except in the case of singleton instances\nof standard-library instructions.  These singleton instances are special subclasses of their\nbase class, and this property will return that base.  For example::\n\n    >>> isinstance(XGate(), XGate)\n    True\n    >>> type(XGate()) is XGate\n    False\n    >>> XGate().base_class is XGate\n    True\n\nIn general, you should not rely on the precise class of an instruction; within a given\ncircuit, it is expected that :attr:`Instruction.name` should be a more suitable\ndiscriminator in most situations.",
        "api_signature": "base_class(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "mutable",
        "full_api_name": "Instruction.mutable",
        "api_description": "Is this instance is a mutable unique instance or not.\n\nIf this attribute is ``False`` the gate instance is a shared singleton\nand is not mutable.",
        "api_signature": "mutable(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "to_mutable",
        "full_api_name": "Instruction.to_mutable",
        "api_description": "Return a mutable copy of this gate.\n\nThis method will return a new mutable copy of this gate instance.\nIf a singleton instance is being used this will be a new unique\ninstance that can be mutated. If the instance is already mutable it\nwill be a deepcopy of that instance.",
        "api_signature": "to_mutable(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "condition",
        "full_api_name": "Instruction.condition",
        "api_description": "The classical condition on the instruction.",
        "api_signature": "condition(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "condition",
        "full_api_name": "Instruction.condition",
        "api_description": "",
        "api_signature": "condition(self, condition)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "Instruction.__eq__",
        "api_description": "Two instructions are the same if they have the same name,\nsame dimensions, and same params.\n\nArgs:\n    other (instruction): other instruction\n\nReturns:\n    bool: are self and other equal.",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "Instruction.__repr__",
        "api_description": "Generates a representation of the Instruction object instance\nReturns:\n    str: A representation of the Instruction instance with the name,\n         number of qubits, classical bits and params( if any )",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "soft_compare",
        "full_api_name": "Instruction.soft_compare",
        "api_description": "Soft comparison between gates. Their names, number of qubits, and classical\nbit numbers must match. The number of parameters must match. Each parameter\nis compared. If one is a ParameterExpression then it is not taken into\naccount.\n\nArgs:\n    other (instruction): other instruction.\n\nReturns:\n    bool: are self and other equal up to parameter expressions.",
        "api_signature": "soft_compare(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "Instruction._define",
        "api_description": "Populates self.definition with a decomposition of this gate.",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "params",
        "full_api_name": "Instruction.params",
        "api_description": "return instruction params.",
        "api_signature": "params(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "params",
        "full_api_name": "Instruction.params",
        "api_description": "",
        "api_signature": "params(self, parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "validate_parameter",
        "full_api_name": "Instruction.validate_parameter",
        "api_description": "Instruction parameters has no validation or normalization.",
        "api_signature": "validate_parameter(self, parameter)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "is_parameterized",
        "full_api_name": "Instruction.is_parameterized",
        "api_description": "Return True .IFF. instruction is parameterized else False",
        "api_signature": "is_parameterized(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "definition",
        "full_api_name": "Instruction.definition",
        "api_description": "Return definition in terms of other basic gates.",
        "api_signature": "definition(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "definition",
        "full_api_name": "Instruction.definition",
        "api_description": "Set gate representation",
        "api_signature": "definition(self, array)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "decompositions",
        "full_api_name": "Instruction.decompositions",
        "api_description": "Get the decompositions of the instruction from the SessionEquivalenceLibrary.",
        "api_signature": "decompositions(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "decompositions",
        "full_api_name": "Instruction.decompositions",
        "api_description": "Set the decompositions of the instruction from the SessionEquivalenceLibrary.",
        "api_signature": "decompositions(self, decompositions)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "add_decomposition",
        "full_api_name": "Instruction.add_decomposition",
        "api_description": "Add a decomposition of the instruction to the SessionEquivalenceLibrary.",
        "api_signature": "add_decomposition(self, decomposition)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "duration",
        "full_api_name": "Instruction.duration",
        "api_description": "Get the duration.",
        "api_signature": "duration(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "duration",
        "full_api_name": "Instruction.duration",
        "api_description": "Set the duration.",
        "api_signature": "duration(self, duration)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "unit",
        "full_api_name": "Instruction.unit",
        "api_description": "Get the time unit of duration.",
        "api_signature": "unit(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "unit",
        "full_api_name": "Instruction.unit",
        "api_description": "Set the time unit of duration.",
        "api_signature": "unit(self, unit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "assemble",
        "full_api_name": "Instruction.assemble",
        "api_description": "Assemble a QasmQobjInstruction",
        "api_signature": "assemble(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "label",
        "full_api_name": "Instruction.label",
        "api_description": "Return instruction label",
        "api_signature": "label(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "label",
        "full_api_name": "Instruction.label",
        "api_description": "Set instruction label to name\n\nArgs:\n    name (str or None): label to assign instruction\n\nRaises:\n    TypeError: name is not string or None.",
        "api_signature": "label(self, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "reverse_ops",
        "full_api_name": "Instruction.reverse_ops",
        "api_description": "For a composite instruction, reverse the order of sub-instructions.\n\nThis is done by recursively reversing all sub-instructions.\nIt does not invert any gate.\n\nReturns:\n    qiskit.circuit.Instruction: a new instruction with\n        sub-instructions reversed.",
        "api_signature": "reverse_ops(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "Instruction.inverse",
        "api_description": "Invert this instruction.\n\nIf the instruction is composite (i.e. has a definition),\nthen its definition will be recursively inverted.\n\nSpecial instructions inheriting from Instruction can\nimplement their own inverse (e.g. T and Tdg, Barrier, etc.)\n\nReturns:\n    qiskit.circuit.Instruction: a fresh instruction for the inverse\n\nRaises:\n    CircuitError: if the instruction is not composite\n        and an inverse has not been implemented for it.",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "c_if",
        "full_api_name": "Instruction.c_if",
        "api_description": "Set a classical equality condition on this instruction between the register or cbit\n``classical`` and value ``val``.\n\n.. note::\n\n    This is a setter method, not an additive one.  Calling this multiple times will silently\n    override any previously set condition; it does not stack.",
        "api_signature": "c_if(self, classical, val)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "copy",
        "full_api_name": "Instruction.copy",
        "api_description": "Copy of the instruction.\n\nArgs:\n    name (str): name to be given to the copied circuit, if ``None`` then the name stays the same.\n\nReturns:\n    qiskit.circuit.Instruction: a copy of the current instruction, with the name updated if it\n    was provided",
        "api_signature": "copy(self, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "__deepcopy__",
        "full_api_name": "Instruction.__deepcopy__",
        "api_description": "",
        "api_signature": "__deepcopy__(self, memo)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "_qasmif",
        "full_api_name": "Instruction._qasmif",
        "api_description": "Print an if statement if needed.",
        "api_signature": "_qasmif(self, string)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "qasm",
        "full_api_name": "Instruction.qasm",
        "api_description": "Return a default OpenQASM string for the instruction.\n\nDerived instructions may override this to print in a\ndifferent format (e.g. ``measure q[0] -> c[0];``).",
        "api_signature": "qasm(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "broadcast_arguments",
        "full_api_name": "Instruction.broadcast_arguments",
        "api_description": "Validation of the arguments.\n\nArgs:\n    qargs (List): List of quantum bit arguments.\n    cargs (List): List of classical bit arguments.\n\nYields:\n    Tuple(List, List): A tuple with single arguments.\n\nRaises:\n    CircuitError: If the input is not valid. For example, the number of\n        arguments does not match the gate expectation.",
        "api_signature": "broadcast_arguments(self, qargs, cargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "_return_repeat",
        "full_api_name": "Instruction._return_repeat",
        "api_description": "",
        "api_signature": "_return_repeat(self, exponent)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "repeat",
        "full_api_name": "Instruction.repeat",
        "api_description": "Creates an instruction with `gate` repeated `n` amount of times.\n\nArgs:\n    n (int): Number of times to repeat the instruction\n\nReturns:\n    qiskit.circuit.Instruction: Containing the definition.\n\nRaises:\n    CircuitError: If n < 1.",
        "api_signature": "repeat(self, n)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "condition_bits",
        "full_api_name": "Instruction.condition_bits",
        "api_description": "Get Clbits in condition.",
        "api_signature": "condition_bits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "name",
        "full_api_name": "Instruction.name",
        "api_description": "Return the name.",
        "api_signature": "name(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "name",
        "full_api_name": "Instruction.name",
        "api_description": "Set the name.",
        "api_signature": "name(self, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "num_qubits",
        "full_api_name": "Instruction.num_qubits",
        "api_description": "Return the number of qubits.",
        "api_signature": "num_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "num_qubits",
        "full_api_name": "Instruction.num_qubits",
        "api_description": "Set num_qubits.",
        "api_signature": "num_qubits(self, num_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "num_clbits",
        "full_api_name": "Instruction.num_clbits",
        "api_description": "Return the number of clbits.",
        "api_signature": "num_clbits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "num_clbits",
        "full_api_name": "Instruction.num_clbits",
        "api_description": "Set num_clbits.",
        "api_signature": "num_clbits(self, num_clbits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QuantumCircuit.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "from_instructions",
        "full_api_name": "QuantumCircuit.from_instructions",
        "api_description": "Construct a circuit from an iterable of CircuitInstructions.\n\nArgs:\n    instructions: The instructions to add to the circuit.\n    qubits: Any qubits to add to the circuit. This argument can be used,\n        for example, to enforce a particular ordering of qubits.\n    clbits: Any classical bits to add to the circuit. This argument can be used,\n        for example, to enforce a particular ordering of classical bits.\n    name: The name of the circuit.\n    global_phase: The global phase of the circuit in radians.\n    metadata: Arbitrary key value metadata to associate with the circuit.\n\nReturns:\n    The quantum circuit.",
        "api_signature": "from_instructions(instructions)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "layout",
        "full_api_name": "QuantumCircuit.layout",
        "api_description": "Return any associated layout information about the circuit\n\nThis attribute contains an optional :class:`~.TranspileLayout`\nobject. This is typically set on the output from :func:`~.transpile`\nor :meth:`.PassManager.run` to retain information about the\npermutations caused on the input circuit by transpilation.\n\nThere are two types of permutations caused by the :func:`~.transpile`\nfunction, an initial layout which permutes the qubits based on the\nselected physical qubits on the :class:`~.Target`, and a final layout\nwhich is an output permutation caused by :class:`~.SwapGate`\\s\ninserted during routing.",
        "api_signature": "layout(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "header",
        "full_api_name": "QuantumCircuit.header",
        "api_description": "The OpenQASM 2.0 header statement.",
        "api_signature": "header(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "extension_lib",
        "full_api_name": "QuantumCircuit.extension_lib",
        "api_description": "The standard OpenQASM 2 import statement.",
        "api_signature": "extension_lib(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "data",
        "full_api_name": "QuantumCircuit.data",
        "api_description": "Return the circuit data (instructions and context).\n\nReturns:\n    QuantumCircuitData: a list-like object containing the :class:`.CircuitInstruction`\\ s\n    for each instruction.",
        "api_signature": "data(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "data",
        "full_api_name": "QuantumCircuit.data",
        "api_description": "Sets the circuit data from a list of instructions and context.\n\nArgs:\n    data_input (Iterable): A sequence of instructions with their execution contexts.  The\n        elements must either be instances of :class:`.CircuitInstruction` (preferred), or a\n        3-tuple of ``(instruction, qargs, cargs)`` (legacy).  In the legacy format,\n        ``instruction`` must be an :class:`~.circuit.Instruction`, while ``qargs`` and\n        ``cargs`` must be iterables of :class:`.Qubit` or :class:`.Clbit` specifiers\n        (similar to the allowed forms in calls to :meth:`append`).",
        "api_signature": "data(self, data_input)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "op_start_times",
        "full_api_name": "QuantumCircuit.op_start_times",
        "api_description": "Return a list of operation start times.\n\nThis attribute is enabled once one of scheduling analysis passes\nruns on the quantum circuit.\n\nReturns:\n    List of integers representing instruction start times.\n    The index corresponds to the index of instruction in :attr:`QuantumCircuit.data`.\n\nRaises:\n    AttributeError: When circuit is not scheduled.",
        "api_signature": "op_start_times(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "calibrations",
        "full_api_name": "QuantumCircuit.calibrations",
        "api_description": "Return calibration dictionary.\n\nThe custom pulse definition of a given gate is of the form\n``{'gate_name': {(qubits, params): schedule}}``",
        "api_signature": "calibrations(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "calibrations",
        "full_api_name": "QuantumCircuit.calibrations",
        "api_description": "Set the circuit calibration data from a dictionary of calibration definition.\n\nArgs:\n    calibrations (dict): A dictionary of input in the format\n       ``{'gate_name': {(qubits, gate_params): schedule}}``",
        "api_signature": "calibrations(self, calibrations)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "has_calibration_for",
        "full_api_name": "QuantumCircuit.has_calibration_for",
        "api_description": "Return True if the circuit has a calibration defined for the instruction context. In this\ncase, the operation does not need to be translated to the device basis.",
        "api_signature": "has_calibration_for(self, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "metadata",
        "full_api_name": "QuantumCircuit.metadata",
        "api_description": "The user provided metadata associated with the circuit.\n\nThe metadata for the circuit is a user provided ``dict`` of metadata\nfor the circuit. It will not be used to influence the execution or\noperation of the circuit, but it is expected to be passed between\nall transforms of the circuit (ie transpilation) and that providers will\nassociate any circuit metadata with the results it returns from\nexecution of that circuit.",
        "api_signature": "metadata(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "metadata",
        "full_api_name": "QuantumCircuit.metadata",
        "api_description": "Update the circuit metadata",
        "api_signature": "metadata(self, metadata)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "QuantumCircuit.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "QuantumCircuit.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "_increment_instances",
        "full_api_name": "QuantumCircuit._increment_instances",
        "api_description": "",
        "api_signature": "_increment_instances(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "cls_instances",
        "full_api_name": "QuantumCircuit.cls_instances",
        "api_description": "Return the current number of instances of this class,\nuseful for auto naming.",
        "api_signature": "cls_instances(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "cls_prefix",
        "full_api_name": "QuantumCircuit.cls_prefix",
        "api_description": "Return the prefix to use for auto naming.",
        "api_signature": "cls_prefix(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "_name_update",
        "full_api_name": "QuantumCircuit._name_update",
        "api_description": "update name of instance using instance number",
        "api_signature": "_name_update(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "has_register",
        "full_api_name": "QuantumCircuit.has_register",
        "api_description": "Test if this circuit has the register r.\n\nArgs:\n    register (Register): a quantum or classical register.\n\nReturns:\n    bool: True if the register is contained in this circuit.",
        "api_signature": "has_register(self, register)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "reverse_ops",
        "full_api_name": "QuantumCircuit.reverse_ops",
        "api_description": "Reverse the circuit by reversing the order of instructions.\n\nThis is done by recursively reversing all instructions.\nIt does not invert (adjoint) any gate.\n\nReturns:\n    QuantumCircuit: the reversed circuit.\n\nExamples:\n\n    input:\n\n    .. parsed-literal::\n\n             \u250c\u2500\u2500\u2500\u2510\n        q_0: \u2524 H \u251c\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\n             \u2514\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2510\n        q_1: \u2500\u2500\u2500\u2500\u2500\u2524 RX(1.57) \u251c\n                  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    output:\n\n    .. parsed-literal::\n\n                         \u250c\u2500\u2500\u2500\u2510\n        q_0: \u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2524 H \u251c\n             \u250c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2510\u2514\u2500\u2500\u2500\u2518\n        q_1: \u2524 RX(1.57) \u251c\u2500\u2500\u2500\u2500\u2500\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
        "api_signature": "reverse_ops(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "reverse_bits",
        "full_api_name": "QuantumCircuit.reverse_bits",
        "api_description": "Return a circuit with the opposite order of wires.\n\nThe circuit is \"vertically\" flipped. If a circuit is\ndefined over multiple registers, the resulting circuit will have\nthe same registers but with their order flipped.\n\nThis method is useful for converting a circuit written in little-endian\nconvention to the big-endian equivalent, and vice versa.\n\nReturns:\n    QuantumCircuit: the circuit with reversed bit order.\n\nExamples:\n\n    input:\n\n    .. parsed-literal::\n\n             \u250c\u2500\u2500\u2500\u2510\n        a_0: \u2524 H \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n             \u2514\u2500\u2500\u2500\u2518\u250c\u2500\u2534\u2500\u2510\n        a_1: \u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                  \u2514\u2500\u2500\u2500\u2518\u250c\u2500\u2534\u2500\u2510\n        a_2: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                       \u2514\u2500\u2500\u2500\u2518\u250c\u2500\u2534\u2500\u2510\n        b_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u25a0\u2500\u2500\n                            \u2514\u2500\u2500\u2500\u2518\u250c\u2500\u2534\u2500\u2510\n        b_1: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\n                                 \u2514\u2500\u2500\u2500\u2518\n\n    output:\n\n    .. parsed-literal::\n\n                                 \u250c\u2500\u2500\u2500\u2510\n        b_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\n                            \u250c\u2500\u2500\u2500\u2510\u2514\u2500\u252c\u2500\u2518\n        b_1: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u25a0\u2500\u2500\n                       \u250c\u2500\u2500\u2500\u2510\u2514\u2500\u252c\u2500\u2518\n        a_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                  \u250c\u2500\u2500\u2500\u2510\u2514\u2500\u252c\u2500\u2518\n        a_1: \u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n             \u250c\u2500\u2500\u2500\u2510\u2514\u2500\u252c\u2500\u2518\n        a_2: \u2524 H \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n             \u2514\u2500\u2500\u2500\u2518",
        "api_signature": "reverse_bits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "QuantumCircuit.inverse",
        "api_description": "Invert (take adjoint of) this circuit.\n\nThis is done by recursively inverting all gates.\n\nReturns:\n    QuantumCircuit: the inverted circuit\n\nRaises:\n    CircuitError: if the circuit cannot be inverted.\n\nExamples:\n\n    input:\n\n    .. parsed-literal::\n\n             \u250c\u2500\u2500\u2500\u2510\n        q_0: \u2524 H \u251c\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\n             \u2514\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2510\n        q_1: \u2500\u2500\u2500\u2500\u2500\u2524 RX(1.57) \u251c\n                  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    output:\n\n    .. parsed-literal::\n\n                          \u250c\u2500\u2500\u2500\u2510\n        q_0: \u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2524 H \u251c\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2510\u2514\u2500\u2500\u2500\u2518\n        q_1: \u2524 RX(-1.57) \u251c\u2500\u2500\u2500\u2500\u2500\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "repeat",
        "full_api_name": "QuantumCircuit.repeat",
        "api_description": "Repeat this circuit ``reps`` times.\n\nArgs:\n    reps (int): How often this circuit should be repeated.\n\nReturns:\n    QuantumCircuit: A circuit containing ``reps`` repetitions of this circuit.",
        "api_signature": "repeat(self, reps)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "power",
        "full_api_name": "QuantumCircuit.power",
        "api_description": "Raise this circuit to the power of ``power``.\n\nIf ``power`` is a positive integer and ``matrix_power`` is ``False``, this implementation\ndefaults to calling ``repeat``. Otherwise, if the circuit is unitary, the matrix is\ncomputed to calculate the matrix power.\n\nArgs:\n    power (float): The power to raise this circuit to.\n    matrix_power (bool): If True, the circuit is converted to a matrix and then the\n        matrix power is computed. If False, and ``power`` is a positive integer,\n        the implementation defaults to ``repeat``.\n\nRaises:\n    CircuitError: If the circuit needs to be converted to a gate but it is not unitary.\n\nReturns:\n    QuantumCircuit: A circuit implementing this circuit raised to the power of ``power``.",
        "api_signature": "power(self, power, matrix_power)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "control",
        "full_api_name": "QuantumCircuit.control",
        "api_description": "Control this circuit on ``num_ctrl_qubits`` qubits.\n\nArgs:\n    num_ctrl_qubits (int): The number of control qubits.\n    label (str): An optional label to give the controlled operation for visualization.\n    ctrl_state (str or int): The control state in decimal or as a bitstring\n        (e.g. '111'). If None, use ``2**num_ctrl_qubits - 1``.\n\nReturns:\n    QuantumCircuit: The controlled version of this circuit.\n\nRaises:\n    CircuitError: If the circuit contains a non-unitary operation and cannot be controlled.",
        "api_signature": "control(self, num_ctrl_qubits, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "compose",
        "full_api_name": "QuantumCircuit.compose",
        "api_description": "Compose circuit with ``other`` circuit or instruction, optionally permuting wires.\n\n``other`` can be narrower or of equal width to ``self``.\n\nArgs:\n    other (qiskit.circuit.Instruction or QuantumCircuit):\n        (sub)circuit or instruction to compose onto self.  If not a :obj:`.QuantumCircuit`,\n        this can be anything that :obj:`.append` will accept.\n    qubits (list[Qubit|int]): qubits of self to compose onto.\n    clbits (list[Clbit|int]): clbits of self to compose onto.\n    front (bool): If True, front composition will be performed.  This is not possible within\n        control-flow builder context managers.\n    inplace (bool): If True, modify the object. Otherwise return composed circuit.\n    wrap (bool): If True, wraps the other circuit into a gate (or instruction, depending on\n        whether it contains only unitary instructions) before composing it onto self.\n\nReturns:\n    QuantumCircuit: the composed circuit (returns None if inplace==True).\n\nRaises:\n    CircuitError: if no correct wire mapping can be made between the two circuits, such as\n        if ``other`` is wider than ``self``.\n    CircuitError: if trying to emit a new circuit while ``self`` has a partially built\n        control-flow context active, such as the context-manager forms of :meth:`if_test`,\n        :meth:`for_loop` and :meth:`while_loop`.\n    CircuitError: if trying to compose to the front of a circuit when a control-flow builder\n        block is active; there is no clear meaning to this action.\n\nExamples:\n    .. code-block:: python\n\n        >>> lhs.compose(rhs, qubits=[3, 2], inplace=True)\n\n    .. parsed-literal::\n\n                    \u250c\u2500\u2500\u2500\u2510                   \u250c\u2500\u2500\u2500\u2500\u2500\u2510                \u250c\u2500\u2500\u2500\u2510\n        lqr_1_0: \u2500\u2500\u2500\u2524 H \u251c\u2500\u2500\u2500    rqr_0: \u2500\u2500\u25a0\u2500\u2500\u2524 Tdg \u251c    lqr_1_0: \u2500\u2500\u2500\u2524 H \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                    \u251c\u2500\u2500\u2500\u2524              \u250c\u2500\u2534\u2500\u2510\u2514\u2500\u2500\u2500\u2500\u2500\u2518                \u251c\u2500\u2500\u2500\u2524\n        lqr_1_1: \u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500    rqr_1: \u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500    lqr_1_1: \u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                 \u250c\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2510           \u2514\u2500\u2500\u2500\u2518                    \u250c\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\n        lqr_1_2: \u2524 U1(0.1) \u251c  +                     =  lqr_1_2: \u2524 U1(0.1) \u251c\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n        lqr_2_0: \u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500                           lqr_2_0: \u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2524 Tdg \u251c\n                    \u250c\u2500\u2534\u2500\u2510                                          \u250c\u2500\u2534\u2500\u2510        \u2514\u2500\u2500\u2500\u2500\u2500\u2518\n        lqr_2_1: \u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500                           lqr_2_1: \u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                    \u2514\u2500\u2500\u2500\u2518                                          \u2514\u2500\u2500\u2500\u2518\n        lcr_0: 0 \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550                           lcr_0: 0 \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n        lcr_1: 0 \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550                           lcr_1: 0 \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
        "api_signature": "compose(self, other, qubits, clbits, front, inplace, wrap)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "tensor",
        "full_api_name": "QuantumCircuit.tensor",
        "api_description": "Tensor ``self`` with ``other``.\n\nRemember that in the little-endian convention the leftmost operation will be at the bottom\nof the circuit. See also\n`the docs <qiskit.org/documentation/tutorials/circuits/3_summary_of_quantum_operations.html>`__\nfor more information.\n\n.. parsed-literal::\n\n         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510        \u250c\u2500\u2500\u2500\u2500\u2500\u2510          \u250c\u2500\u2500\u2500\u2500\u2500\u2510\n    q_0: \u2524 bottom \u251c \u2297 q_0: \u2524 top \u251c  = q_0: \u2500\u2524 top \u251c\u2500\u2500\n         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518        \u2514\u2500\u2500\u2500\u2500\u2500\u2518         \u250c\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2510\n                                      q_1: \u2524 bottom \u251c\n                                           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nArgs:\n    other (QuantumCircuit): The other circuit to tensor this circuit with.\n    inplace (bool): If True, modify the object. Otherwise return composed circuit.\n\nExamples:\n\n    .. plot::\n       :include-source:\n\n       from qiskit import QuantumCircuit\n       top = QuantumCircuit(1)\n       top.x(0);\n       bottom = QuantumCircuit(2)\n       bottom.cry(0.2, 0, 1);\n       tensored = bottom.tensor(top)\n       tensored.draw('mpl')\n\nReturns:\n    QuantumCircuit: The tensored circuit (returns None if inplace==True).",
        "api_signature": "tensor(self, other, inplace)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "qubits",
        "full_api_name": "QuantumCircuit.qubits",
        "api_description": "Returns a list of quantum bits in the order that the registers were added.",
        "api_signature": "qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "clbits",
        "full_api_name": "QuantumCircuit.clbits",
        "api_description": "Returns a list of classical bits in the order that the registers were added.",
        "api_signature": "clbits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "ancillas",
        "full_api_name": "QuantumCircuit.ancillas",
        "api_description": "Returns a list of ancilla bits in the order that the registers were added.",
        "api_signature": "ancillas(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "__and__",
        "full_api_name": "QuantumCircuit.__and__",
        "api_description": "Overload & to implement self.compose.",
        "api_signature": "__and__(self, rhs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "__iand__",
        "full_api_name": "QuantumCircuit.__iand__",
        "api_description": "Overload &= to implement self.compose in place.",
        "api_signature": "__iand__(self, rhs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "__xor__",
        "full_api_name": "QuantumCircuit.__xor__",
        "api_description": "Overload ^ to implement self.tensor.",
        "api_signature": "__xor__(self, top)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "__ixor__",
        "full_api_name": "QuantumCircuit.__ixor__",
        "api_description": "Overload ^= to implement self.tensor in place.",
        "api_signature": "__ixor__(self, top)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "__len__",
        "full_api_name": "QuantumCircuit.__len__",
        "api_description": "Return number of operations in circuit.",
        "api_signature": "__len__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "__getitem__",
        "full_api_name": "QuantumCircuit.__getitem__",
        "api_description": "",
        "api_signature": "__getitem__(self, item)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "__getitem__",
        "full_api_name": "QuantumCircuit.__getitem__",
        "api_description": "",
        "api_signature": "__getitem__(self, item)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "__getitem__",
        "full_api_name": "QuantumCircuit.__getitem__",
        "api_description": "Return indexed operation.",
        "api_signature": "__getitem__(self, item)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "cast",
        "full_api_name": "QuantumCircuit.cast",
        "api_description": "Best effort to cast value to type. Otherwise, returns the value.",
        "api_signature": "cast(value, type_)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "qbit_argument_conversion",
        "full_api_name": "QuantumCircuit.qbit_argument_conversion",
        "api_description": "Converts several qubit representations (such as indexes, range, etc.)\ninto a list of qubits.\n\nArgs:\n    qubit_representation (Object): representation to expand\n\nReturns:\n    List(Qubit): the resolved instances of the qubits.",
        "api_signature": "qbit_argument_conversion(self, qubit_representation)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "cbit_argument_conversion",
        "full_api_name": "QuantumCircuit.cbit_argument_conversion",
        "api_description": "Converts several classical bit representations (such as indexes, range, etc.)\ninto a list of classical bits.\n\nArgs:\n    clbit_representation (Object): representation to expand\n\nReturns:\n    List(tuple): Where each tuple is a classical bit.",
        "api_signature": "cbit_argument_conversion(self, clbit_representation)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "_resolve_classical_resource",
        "full_api_name": "QuantumCircuit._resolve_classical_resource",
        "api_description": "Resolve a single classical resource specifier into a concrete resource, raising an error\nif the specifier is invalid.\n\nThis is slightly different to :meth:`.cbit_argument_conversion`, because it should not\nunwrap :obj:`.ClassicalRegister` instances into lists, and in general it should not allow\niterables or broadcasting.  It is expected to be used as a callback for things like\n:meth:`.InstructionSet.c_if` to check the validity of their arguments.\n\nArgs:\n    specifier (Union[Clbit, ClassicalRegister, int]): a specifier of a classical resource\n        present in this circuit.  An ``int`` will be resolved into a :obj:`.Clbit` using the\n        same conventions as measurement operations on this circuit use.\n\nReturns:\n    Union[Clbit, ClassicalRegister]: the resolved resource.\n\nRaises:\n    CircuitError: if the resource is not present in this circuit, or if the integer index\n        passed is out-of-bounds.",
        "api_signature": "_resolve_classical_resource(self, specifier)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "_validate_expr",
        "full_api_name": "QuantumCircuit._validate_expr",
        "api_description": "",
        "api_signature": "_validate_expr(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "append",
        "full_api_name": "QuantumCircuit.append",
        "api_description": "Append one or more instructions to the end of the circuit, modifying the circuit in\nplace.\n\nThe ``qargs`` and ``cargs`` will be expanded and broadcast according to the rules of the\ngiven :class:`~.circuit.Instruction`, and any non-:class:`.Bit` specifiers (such as\ninteger indices) will be resolved into the relevant instances.\n\nIf a :class:`.CircuitInstruction` is given, it will be unwrapped, verified in the context of\nthis circuit, and a new object will be appended to the circuit.  In this case, you may not\npass ``qargs`` or ``cargs`` separately.\n\nArgs:\n    instruction: :class:`~.circuit.Instruction` instance to append, or a\n        :class:`.CircuitInstruction` with all its context.\n    qargs: specifiers of the :class:`.Qubit`\\ s to attach instruction to.\n    cargs: specifiers of the :class:`.Clbit`\\ s to attach instruction to.\n\nReturns:\n    qiskit.circuit.InstructionSet: a handle to the :class:`.CircuitInstruction`\\ s that\n    were actually added to the circuit.\n\nRaises:\n    CircuitError: if the operation passed is not an instance of :class:`~.circuit.Instruction` .",
        "api_signature": "append(self, instruction, qargs, cargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "_append",
        "full_api_name": "QuantumCircuit._append",
        "api_description": "",
        "api_signature": "_append(self, instruction, _qargs, _cargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "_append",
        "full_api_name": "QuantumCircuit._append",
        "api_description": "",
        "api_signature": "_append(self, operation, qargs, cargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "_append",
        "full_api_name": "QuantumCircuit._append",
        "api_description": "Append an instruction to the end of the circuit, modifying the circuit in place.\n\n.. warning::\n\n    This is an internal fast-path function, and it is the responsibility of the caller to\n    ensure that all the arguments are valid; there is no error checking here.  In\n    particular, all the qubits and clbits must already exist in the circuit and there can be\n    no duplicates in the list.\n\n.. note::\n\n    This function may be used by callers other than :obj:`.QuantumCircuit` when the caller\n    is sure that all error-checking, broadcasting and scoping has already been performed,\n    and the only reference to the circuit the instructions are being appended to is within\n    that same function.  In particular, it is not safe to call\n    :meth:`QuantumCircuit._append` on a circuit that is received by a function argument.\n    This is because :meth:`.QuantumCircuit._append` will not recognise the scoping\n    constructs of the control-flow builder interface.\n\nArgs:\n    instruction: Operation instance to append\n    qargs: Qubits to attach the instruction to.\n    cargs: Clbits to attach the instruction to.\n\nReturns:\n    Operation: a handle to the instruction that was just added\n\n:meta public:",
        "api_signature": "_append(self, instruction, qargs, cargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "_update_parameter_table",
        "full_api_name": "QuantumCircuit._update_parameter_table",
        "api_description": "",
        "api_signature": "_update_parameter_table(self, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "add_register",
        "full_api_name": "QuantumCircuit.add_register",
        "api_description": "Add registers.",
        "api_signature": "add_register(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "add_bits",
        "full_api_name": "QuantumCircuit.add_bits",
        "api_description": "Add Bits to the circuit.",
        "api_signature": "add_bits(self, bits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "find_bit",
        "full_api_name": "QuantumCircuit.find_bit",
        "api_description": "Find locations in the circuit which can be used to reference a given :obj:`~Bit`.\n\nArgs:\n    bit (Bit): The bit to locate.\n\nReturns:\n    namedtuple(int, List[Tuple(Register, int)]): A 2-tuple. The first element (``index``)\n        contains the index at which the ``Bit`` can be found (in either\n        :obj:`~QuantumCircuit.qubits`, :obj:`~QuantumCircuit.clbits`, depending on its\n        type). The second element (``registers``) is a list of ``(register, index)``\n        pairs with an entry for each :obj:`~Register` in the circuit which contains the\n        :obj:`~Bit` (and the index in the :obj:`~Register` at which it can be found).\n\nNotes:\n    The circuit index of an :obj:`~AncillaQubit` will be its index in\n    :obj:`~QuantumCircuit.qubits`, not :obj:`~QuantumCircuit.ancillas`.\n\nRaises:\n    CircuitError: If the supplied :obj:`~Bit` was of an unknown type.\n    CircuitError: If the supplied :obj:`~Bit` could not be found on the circuit.",
        "api_signature": "find_bit(self, bit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "_check_dups",
        "full_api_name": "QuantumCircuit._check_dups",
        "api_description": "Raise exception if list of qubits contains duplicates.",
        "api_signature": "_check_dups(self, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "to_instruction",
        "full_api_name": "QuantumCircuit.to_instruction",
        "api_description": "Create an Instruction out of this circuit.\n\nArgs:\n    parameter_map(dict): For parameterized circuits, a mapping from\n       parameters in the circuit to parameters to be used in the\n       instruction. If None, existing circuit parameters will also\n       parameterize the instruction.\n    label (str): Optional gate label.\n\nReturns:\n    qiskit.circuit.Instruction: a composite instruction encapsulating this circuit\n    (can be decomposed back)",
        "api_signature": "to_instruction(self, parameter_map, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "to_gate",
        "full_api_name": "QuantumCircuit.to_gate",
        "api_description": "Create a Gate out of this circuit.\n\nArgs:\n    parameter_map(dict): For parameterized circuits, a mapping from\n       parameters in the circuit to parameters to be used in the\n       gate. If None, existing circuit parameters will also\n       parameterize the gate.\n    label (str): Optional gate label.\n\nReturns:\n    Gate: a composite gate encapsulating this circuit\n    (can be decomposed back)",
        "api_signature": "to_gate(self, parameter_map, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "decompose",
        "full_api_name": "QuantumCircuit.decompose",
        "api_description": "Call a decomposition pass on this circuit,\nto decompose one level (shallow decompose).\n\nArgs:\n    gates_to_decompose (type or str or list(type, str)): Optional subset of gates\n        to decompose. Can be a gate type, such as ``HGate``, or a gate name, such\n        as 'h', or a gate label, such as 'My H Gate', or a list of any combination\n        of these. If a gate name is entered, it will decompose all gates with that\n        name, whether the gates have labels or not. Defaults to all gates in circuit.\n    reps (int): Optional number of times the circuit should be decomposed.\n        For instance, ``reps=2`` equals calling ``circuit.decompose().decompose()``.\n        can decompose specific gates specific time\n\nReturns:\n    QuantumCircuit: a circuit one level decomposed",
        "api_signature": "decompose(self, gates_to_decompose, reps)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "qasm",
        "full_api_name": "QuantumCircuit.qasm",
        "api_description": "Return OpenQASM 2.0 string.\n\n.. seealso::\n\n    :func:`.qasm2.dump` and :func:`.qasm2.dumps`\n        The preferred entry points to the OpenQASM 2 export capabilities.  These match the\n        interface for other serialisers in Qiskit.\n\nArgs:\n    formatted (bool): Return formatted OpenQASM 2.0 string.\n    filename (str): Save OpenQASM 2.0 to file with name 'filename'.\n    encoding (str): Optionally specify the encoding to use for the\n        output file if ``filename`` is specified. By default this is\n        set to the system's default encoding (ie whatever\n        ``locale.getpreferredencoding()`` returns) and can be set to\n        any valid codec or alias from stdlib's\n        `codec module <https://docs.python.org/3/library/codecs.html#standard-encodings>`__\n\nReturns:\n    str: If formatted=False.\n\nRaises:\n    MissingOptionalLibraryError: If pygments is not installed and ``formatted`` is\n        ``True``.\n    QASM2ExportError: If circuit has free parameters.\n    QASM2ExportError: If an operation that has no OpenQASM 2 representation is encountered.",
        "api_signature": "qasm(self, formatted, filename, encoding)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "draw",
        "full_api_name": "QuantumCircuit.draw",
        "api_description": "Draw the quantum circuit. Use the output parameter to choose the drawing format:\n\n**text**: ASCII art TextDrawing that can be printed in the console.\n\n**mpl**: images with color rendered purely in Python using matplotlib.\n\n**latex**: high-quality images compiled via latex.\n\n**latex_source**: raw uncompiled latex output.\n\n.. warning::\n\n    Support for :class:`~.expr.Expr` nodes in conditions and :attr:`.SwitchCaseOp.target`\n    fields is preliminary and incomplete.  The ``text`` and ``mpl`` drawers will make a\n    best-effort attempt to show data dependencies, but the LaTeX-based drawers will skip\n    these completely.\n\nArgs:\n    output (str): select the output method to use for drawing the circuit.\n        Valid choices are ``text``, ``mpl``, ``latex``, ``latex_source``.\n        By default the `text` drawer is used unless the user config file\n        (usually ``~/.qiskit/settings.conf``) has an alternative backend set\n        as the default. For example, ``circuit_drawer = latex``. If the output\n        kwarg is set, that backend will always be used over the default in\n        the user config file.\n    scale (float): scale of image to draw (shrink if < 1.0). Only used by\n        the `mpl`, `latex` and `latex_source` outputs. Defaults to 1.0.\n    filename (str): file path to save image to. Defaults to None.\n    style (dict or str): dictionary of style or file name of style json file.\n        This option is only used by the `mpl` or `latex` output type.\n        If `style` is a str, it is used as the path to a json file\n        which contains a style dict. The file will be opened, parsed, and\n        then any style elements in the dict will replace the default values\n        in the input dict. A file to be loaded must end in ``.json``, but\n        the name entered here can omit ``.json``. For example,\n        ``style='iqp.json'`` or ``style='iqp'``.\n        If `style` is a dict and the ``'name'`` key is set, that name\n        will be used to load a json file, followed by loading the other\n        items in the style dict. For example, ``style={'name': 'iqp'}``.\n        If `style` is not a str and `name` is not a key in the style dict,\n        then the default value from the user config file (usually\n        ``~/.qiskit/settings.conf``) will be used, for example,\n        ``circuit_mpl_style = iqp``.\n        If none of these are set, the `clifford` style will be used.\n        The search path for style json files can be specified in the user\n        config, for example,\n        ``circuit_mpl_style_path = /home/user/styles:/home/user``.\n        See: :class:`~qiskit.visualization.qcstyle.DefaultStyle` for more\n        information on the contents.\n    interactive (bool): when set to true, show the circuit in a new window\n        (for `mpl` this depends on the matplotlib backend being used\n        supporting this). Note when used with either the `text` or the\n        `latex_source` output type this has no effect and will be silently\n        ignored. Defaults to False.\n    reverse_bits (bool): when set to True, reverse the bit order inside\n        registers for the output visualization. Defaults to False unless the\n        user config file (usually ``~/.qiskit/settings.conf``) has an\n        alternative value set. For example, ``circuit_reverse_bits = True``.\n    plot_barriers (bool): enable/disable drawing barriers in the output\n        circuit. Defaults to True.\n    justify (string): options are ``left``, ``right`` or ``none``. If\n        anything else is supplied, it defaults to left justified. It refers\n        to where gates should be placed in the output circuit if there is\n        an option. ``none`` results in each gate being placed in its own\n        column.\n    vertical_compression (string): ``high``, ``medium`` or ``low``. It\n        merges the lines generated by the `text` output so the drawing\n        will take less vertical room.  Default is ``medium``. Only used by\n        the `text` output, will be silently ignored otherwise.\n    idle_wires (bool): include idle wires (wires with no circuit elements)\n        in output visualization. Default is True.\n    with_layout (bool): include layout information, with labels on the\n        physical layout. Default is True.\n    fold (int): sets pagination. It can be disabled using -1. In `text`,\n        sets the length of the lines. This is useful when the drawing does\n        not fit in the console. If None (default), it will try to guess the\n        console width using ``shutil.get_terminal_size()``. However, if\n        running in jupyter, the default line length is set to 80 characters.\n        In `mpl`, it is the number of (visual) layers before folding.\n        Default is 25.\n    ax (matplotlib.axes.Axes): Only used by the `mpl` backend. An optional\n        Axes object to be used for the visualization output. If none is\n        specified, a new matplotlib Figure will be created and used.\n        Additionally, if specified there will be no returned Figure since\n        it is redundant.\n    initial_state (bool): Optional. Adds ``|0>`` in the beginning of the wire.\n        Default is False.\n    cregbundle (bool): Optional. If set True, bundle classical registers.\n        Default is True, except for when ``output`` is set to  ``\"text\"``.\n    wire_order (list): Optional. A list of integers used to reorder the display\n        of the bits. The list must have an entry for every bit with the bits\n        in the range 0 to (``num_qubits`` + ``num_clbits``).\n    expr_len (int): Optional. The number of characters to display if an :class:`~.expr.Expr`\n        is used for the condition in a :class:`.ControlFlowOp`. If this number is exceeded,\n        the string will be truncated at that number and '...' added to the end.\n\nReturns:\n    :class:`.TextDrawing` or :class:`matplotlib.figure` or :class:`PIL.Image` or\n    :class:`str`:\n\n    * `TextDrawing` (output='text')\n        A drawing that can be printed as ascii art.\n    * `matplotlib.figure.Figure` (output='mpl')\n        A matplotlib figure object for the circuit diagram.\n    * `PIL.Image` (output='latex')\n        An in-memory representation of the image of the circuit diagram.\n    * `str` (output='latex_source')\n        The LaTeX source code for visualizing the circuit diagram.\n\nRaises:\n    VisualizationError: when an invalid output method is selected\n    ImportError: when the output methods requires non-installed libraries.\n\nExample:\n    .. plot::\n       :include-source:\n\n       from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit\n       q = QuantumRegister(1)\n       c = ClassicalRegister(1)\n       qc = QuantumCircuit(q, c)\n       qc.h(q)\n       qc.measure(q, c)\n       qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})",
        "api_signature": "draw(self, output, scale, filename, style, interactive, plot_barriers, reverse_bits, justify, vertical_compression, idle_wires, with_layout, fold, ax, initial_state, cregbundle, wire_order, expr_len)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "size",
        "full_api_name": "QuantumCircuit.size",
        "api_description": "Returns total number of instructions in circuit.\n\nArgs:\n    filter_function (callable): a function to filter out some instructions.\n        Should take as input a tuple of (Instruction, list(Qubit), list(Clbit)).\n        By default filters out \"directives\", such as barrier or snapshot.\n\nReturns:\n    int: Total number of gate operations.",
        "api_signature": "size(self, filter_function)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "depth",
        "full_api_name": "QuantumCircuit.depth",
        "api_description": "Return circuit depth (i.e., length of critical path).\n\nArgs:\n    filter_function (callable): A function to filter instructions.\n        Should take as input a tuple of (Instruction, list(Qubit), list(Clbit)).\n        Instructions for which the function returns False are ignored in the\n        computation of the circuit depth.\n        By default filters out \"directives\", such as barrier or snapshot.\n\nReturns:\n    int: Depth of circuit.\n\nNotes:\n    The circuit depth and the DAG depth need not be the\n    same.",
        "api_signature": "depth(self, filter_function)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "width",
        "full_api_name": "QuantumCircuit.width",
        "api_description": "Return number of qubits plus clbits in circuit.\n\nReturns:\n    int: Width of circuit.",
        "api_signature": "width(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "num_qubits",
        "full_api_name": "QuantumCircuit.num_qubits",
        "api_description": "Return number of qubits.",
        "api_signature": "num_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "num_ancillas",
        "full_api_name": "QuantumCircuit.num_ancillas",
        "api_description": "Return the number of ancilla qubits.",
        "api_signature": "num_ancillas(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "num_clbits",
        "full_api_name": "QuantumCircuit.num_clbits",
        "api_description": "Return number of classical bits.",
        "api_signature": "num_clbits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "count_ops",
        "full_api_name": "QuantumCircuit.count_ops",
        "api_description": "Count each operation kind in the circuit.\n\nReturns:\n    OrderedDict: a breakdown of how many operations of each kind, sorted by amount.",
        "api_signature": "count_ops(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "num_nonlocal_gates",
        "full_api_name": "QuantumCircuit.num_nonlocal_gates",
        "api_description": "Return number of non-local gates (i.e. involving 2+ qubits).\n\nConditional nonlocal gates are also included.",
        "api_signature": "num_nonlocal_gates(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "get_instructions",
        "full_api_name": "QuantumCircuit.get_instructions",
        "api_description": "Get instructions matching name.\n\nArgs:\n    name (str): The name of instruction to.\n\nReturns:\n    list(tuple): list of (instruction, qargs, cargs).",
        "api_signature": "get_instructions(self, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "num_connected_components",
        "full_api_name": "QuantumCircuit.num_connected_components",
        "api_description": "How many non-entangled subcircuits can the circuit be factored to.\n\nArgs:\n    unitary_only (bool): Compute only unitary part of graph.\n\nReturns:\n    int: Number of connected components in circuit.",
        "api_signature": "num_connected_components(self, unitary_only)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "num_unitary_factors",
        "full_api_name": "QuantumCircuit.num_unitary_factors",
        "api_description": "Computes the number of tensor factors in the unitary\n(quantum) part of the circuit only.",
        "api_signature": "num_unitary_factors(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "num_tensor_factors",
        "full_api_name": "QuantumCircuit.num_tensor_factors",
        "api_description": "Computes the number of tensor factors in the unitary\n(quantum) part of the circuit only.\n\nNotes:\n    This is here for backwards compatibility, and will be\n    removed in a future release of Qiskit. You should call\n    `num_unitary_factors` instead.",
        "api_signature": "num_tensor_factors(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "copy",
        "full_api_name": "QuantumCircuit.copy",
        "api_description": "Copy the circuit.\n\nArgs:\n  name (str): name to be given to the copied circuit. If None, then the name stays the same.\n\nReturns:\n  QuantumCircuit: a deepcopy of the current circuit, with the specified name",
        "api_signature": "copy(self, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "copy_empty_like",
        "full_api_name": "QuantumCircuit.copy_empty_like",
        "api_description": "Return a copy of self with the same structure but empty.\n\nThat structure includes:\n    * name, calibrations and other metadata\n    * global phase\n    * all the qubits and clbits, including the registers\n\nArgs:\n    name (str): Name for the copied circuit. If None, then the name stays the same.\n\nReturns:\n    QuantumCircuit: An empty copy of self.",
        "api_signature": "copy_empty_like(self, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "clear",
        "full_api_name": "QuantumCircuit.clear",
        "api_description": "Clear all instructions in self.\n\nClearing the circuits will keep the metadata and calibrations.",
        "api_signature": "clear(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "_create_creg",
        "full_api_name": "QuantumCircuit._create_creg",
        "api_description": "Creates a creg, checking if ClassicalRegister with same name exists",
        "api_signature": "_create_creg(self, length, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "_create_qreg",
        "full_api_name": "QuantumCircuit._create_qreg",
        "api_description": "Creates a qreg, checking if QuantumRegister with same name exists",
        "api_signature": "_create_qreg(self, length, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "reset",
        "full_api_name": "QuantumCircuit.reset",
        "api_description": "Reset the quantum bit(s) to their default state.\n\nArgs:\n    qubit: qubit(s) to reset.\n\nReturns:\n    qiskit.circuit.InstructionSet: handle to the added instruction.",
        "api_signature": "reset(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "measure",
        "full_api_name": "QuantumCircuit.measure",
        "api_description": "Measure a quantum bit (``qubit``) in the Z basis into a classical bit (``cbit``).\n\nWhen a quantum state is measured, a qubit is projected in the computational (Pauli Z) basis\nto either :math:`\\lvert 0 \\rangle` or :math:`\\lvert 1 \\rangle`. The classical bit ``cbit``\nindicates the result\nof that projection as a ``0`` or a ``1`` respectively. This operation is non-reversible.\n\nArgs:\n    qubit: qubit(s) to measure.\n    cbit: classical bit(s) to place the measurement result(s) in.\n\nReturns:\n    qiskit.circuit.InstructionSet: handle to the added instructions.\n\nRaises:\n    CircuitError: if arguments have bad format.\n\nExamples:\n    In this example, a qubit is measured and the result of that measurement is stored in the\n    classical bit (usually expressed in diagrams as a double line):\n\n    .. code-block::\n\n       from qiskit import QuantumCircuit\n       circuit = QuantumCircuit(1, 1)\n       circuit.h(0)\n       circuit.measure(0, 0)\n       circuit.draw()\n\n\n    .. parsed-literal::\n\n              \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2510\n           q: \u2524 H \u251c\u2524M\u251c\n              \u2514\u2500\u2500\u2500\u2518\u2514\u2565\u2518\n         c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\n                    0\n\n    It is possible to call ``measure`` with lists of ``qubits`` and ``cbits`` as a shortcut\n    for one-to-one measurement. These two forms produce identical results:\n\n    .. code-block::\n\n       circuit = QuantumCircuit(2, 2)\n       circuit.measure([0,1], [0,1])\n\n    .. code-block::\n\n       circuit = QuantumCircuit(2, 2)\n       circuit.measure(0, 0)\n       circuit.measure(1, 1)\n\n    Instead of lists, you can use :class:`~qiskit.circuit.QuantumRegister` and\n    :class:`~qiskit.circuit.ClassicalRegister` under the same logic.\n\n    .. code-block::\n\n        from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister\n        qreg = QuantumRegister(2, \"qreg\")\n        creg = ClassicalRegister(2, \"creg\")\n        circuit = QuantumCircuit(qreg, creg)\n        circuit.measure(qreg, creg)\n\n    This is equivalent to:\n\n    .. code-block::\n\n        circuit = QuantumCircuit(qreg, creg)\n        circuit.measure(qreg[0], creg[0])\n        circuit.measure(qreg[1], creg[1])",
        "api_signature": "measure(self, qubit, cbit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "measure_active",
        "full_api_name": "QuantumCircuit.measure_active",
        "api_description": "Adds measurement to all non-idle qubits. Creates a new ClassicalRegister with\na size equal to the number of non-idle qubits being measured.\n\nReturns a new circuit with measurements if `inplace=False`.\n\nArgs:\n    inplace (bool): All measurements inplace or return new circuit.\n\nReturns:\n    QuantumCircuit: Returns circuit with measurements when `inplace = False`.",
        "api_signature": "measure_active(self, inplace)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "measure_all",
        "full_api_name": "QuantumCircuit.measure_all",
        "api_description": "Adds measurement to all qubits.\n\nBy default, adds new classical bits in a :obj:`.ClassicalRegister` to store these\nmeasurements.  If ``add_bits=False``, the results of the measurements will instead be stored\nin the already existing classical bits, with qubit ``n`` being measured into classical bit\n``n``.\n\nReturns a new circuit with measurements if ``inplace=False``.\n\nArgs:\n    inplace (bool): All measurements inplace or return new circuit.\n    add_bits (bool): Whether to add new bits to store the results.\n\nReturns:\n    QuantumCircuit: Returns circuit with measurements when ``inplace=False``.\n\nRaises:\n    CircuitError: if ``add_bits=False`` but there are not enough classical bits.",
        "api_signature": "measure_all(self, inplace, add_bits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "remove_final_measurements",
        "full_api_name": "QuantumCircuit.remove_final_measurements",
        "api_description": "Removes final measurements and barriers on all qubits if they are present.\nDeletes the classical registers that were used to store the values from these measurements\nthat become idle as a result of this operation, and deletes classical bits that are\nreferenced only by removed registers, or that aren't referenced at all but have\nbecome idle as a result of this operation.\n\nMeasurements and barriers are considered final if they are\nfollowed by no other operations (aside from other measurements or barriers.)\n\nArgs:\n    inplace (bool): All measurements removed inplace or return new circuit.\n\nReturns:\n    QuantumCircuit: Returns the resulting circuit when ``inplace=False``, else None.",
        "api_signature": "remove_final_measurements(self, inplace)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "from_qasm_file",
        "full_api_name": "QuantumCircuit.from_qasm_file",
        "api_description": "Read an OpenQASM 2.0 program from a file and convert to an instance of\n:class:`.QuantumCircuit`.\n\nArgs:\n  path (str): Path to the file for an OpenQASM 2 program\n\nReturn:\n  QuantumCircuit: The QuantumCircuit object for the input OpenQASM 2.\n\nSee also:\n    :func:`.qasm2.load`: the complete interface to the OpenQASM 2 importer.",
        "api_signature": "from_qasm_file(path)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "from_qasm_str",
        "full_api_name": "QuantumCircuit.from_qasm_str",
        "api_description": "Convert a string containing an OpenQASM 2.0 program to a :class:`.QuantumCircuit`.\n\nArgs:\n  qasm_str (str): A string containing an OpenQASM 2.0 program.\nReturn:\n  QuantumCircuit: The QuantumCircuit object for the input OpenQASM 2\n\nSee also:\n    :func:`.qasm2.loads`: the complete interface to the OpenQASM 2 importer.",
        "api_signature": "from_qasm_str(qasm_str)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "global_phase",
        "full_api_name": "QuantumCircuit.global_phase",
        "api_description": "Return the global phase of the current circuit scope in radians.",
        "api_signature": "global_phase(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "global_phase",
        "full_api_name": "QuantumCircuit.global_phase",
        "api_description": "Set the phase of the current circuit scope.\n\nArgs:\n    angle (float, ParameterExpression): radians",
        "api_signature": "global_phase(self, angle)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "parameters",
        "full_api_name": "QuantumCircuit.parameters",
        "api_description": "The parameters defined in the circuit.\n\nThis attribute returns the :class:`.Parameter` objects in the circuit sorted\nalphabetically. Note that parameters instantiated with a :class:`.ParameterVector`\nare still sorted numerically.\n\nExamples:\n\n    The snippet below shows that insertion order of parameters does not matter.\n\n    .. code-block:: python\n\n        >>> from qiskit.circuit import QuantumCircuit, Parameter\n        >>> a, b, elephant = Parameter(\"a\"), Parameter(\"b\"), Parameter(\"elephant\")\n        >>> circuit = QuantumCircuit(1)\n        >>> circuit.rx(b, 0)\n        >>> circuit.rz(elephant, 0)\n        >>> circuit.ry(a, 0)\n        >>> circuit.parameters  # sorted alphabetically!\n        ParameterView([Parameter(a), Parameter(b), Parameter(elephant)])\n\n    Bear in mind that alphabetical sorting might be unintuitive when it comes to numbers.\n    The literal \"10\" comes before \"2\" in strict alphabetical sorting.\n\n    .. code-block:: python\n\n        >>> from qiskit.circuit import QuantumCircuit, Parameter\n        >>> angles = [Parameter(\"angle_1\"), Parameter(\"angle_2\"), Parameter(\"angle_10\")]\n        >>> circuit = QuantumCircuit(1)\n        >>> circuit.u(*angles, 0)\n        >>> circuit.draw()\n           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q: \u2524 U(angle_1,angle_2,angle_10) \u251c\n           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        >>> circuit.parameters\n        ParameterView([Parameter(angle_1), Parameter(angle_10), Parameter(angle_2)])\n\n    To respect numerical sorting, a :class:`.ParameterVector` can be used.\n\n    .. code-block:: python\n\n    >>> from qiskit.circuit import QuantumCircuit, Parameter, ParameterVector\n    >>> x = ParameterVector(\"x\", 12)\n    >>> circuit = QuantumCircuit(1)\n    >>> for x_i in x:\n    ...     circuit.rx(x_i, 0)\n    >>> circuit.parameters\n    ParameterView([\n        ParameterVectorElement(x[0]), ParameterVectorElement(x[1]),\n        ParameterVectorElement(x[2]), ParameterVectorElement(x[3]),\n        ..., ParameterVectorElement(x[11])\n    ])\n\n\nReturns:\n    The sorted :class:`.Parameter` objects in the circuit.",
        "api_signature": "parameters(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "num_parameters",
        "full_api_name": "QuantumCircuit.num_parameters",
        "api_description": "The number of parameter objects in the circuit.",
        "api_signature": "num_parameters(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "_unsorted_parameters",
        "full_api_name": "QuantumCircuit._unsorted_parameters",
        "api_description": "Efficiently get all parameters in the circuit, without any sorting overhead.\n\n.. warning::\n\n    The returned object may directly view onto the ``ParameterTable`` internals, and so\n    should not be mutated.  This is an internal performance detail.  Code outside of this\n    package should not use this method.",
        "api_signature": "_unsorted_parameters(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "assign_parameters",
        "full_api_name": "QuantumCircuit.assign_parameters",
        "api_description": "",
        "api_signature": "assign_parameters(self, parameters, inplace)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "assign_parameters",
        "full_api_name": "QuantumCircuit.assign_parameters",
        "api_description": "",
        "api_signature": "assign_parameters(self, parameters, inplace)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "assign_parameters",
        "full_api_name": "QuantumCircuit.assign_parameters",
        "api_description": "Assign parameters to new parameters or values.\n\nIf ``parameters`` is passed as a dictionary, the keys must be :class:`.Parameter`\ninstances in the current circuit. The values of the dictionary can either be numeric values\nor new parameter objects.\n\nIf ``parameters`` is passed as a list or array, the elements are assigned to the\ncurrent parameters in the order of :attr:`parameters` which is sorted\nalphabetically (while respecting the ordering in :class:`.ParameterVector` objects).\n\nThe values can be assigned to the current circuit object or to a copy of it.\n\nArgs:\n    parameters: Either a dictionary or iterable specifying the new parameter values.\n    inplace: If False, a copy of the circuit with the bound parameters is returned.\n        If True the circuit instance itself is modified.\n    flat_input: If ``True`` and ``parameters`` is a mapping type, it is assumed to be\n        exactly a mapping of ``{parameter: value}``.  By default (``False``), the mapping\n        may also contain :class:`.ParameterVector` keys that point to a corresponding\n        sequence of values, and these will be unrolled during the mapping.\n    strict: If ``False``, any parameters given in the mapping that are not used in the\n        circuit will be ignored.  If ``True`` (the default), an error will be raised\n        indicating a logic error.\n\nRaises:\n    CircuitError: If parameters is a dict and contains parameters not present in the\n        circuit.\n    ValueError: If parameters is a list/array and the length mismatches the number of free\n        parameters in the circuit.\n\nReturns:\n    A copy of the circuit with bound parameters if ``inplace`` is False, otherwise None.\n\nExamples:\n\n    Create a parameterized circuit and assign the parameters in-place.\n\n    .. plot::\n       :include-source:\n\n       from qiskit.circuit import QuantumCircuit, Parameter\n\n       circuit = QuantumCircuit(2)\n       params = [Parameter('A'), Parameter('B'), Parameter('C')]\n       circuit.ry(params[0], 0)\n       circuit.crx(params[1], 0, 1)\n       circuit.draw('mpl')\n       circuit.assign_parameters({params[0]: params[2]}, inplace=True)\n       circuit.draw('mpl')\n\n    Bind the values out-of-place by list and get a copy of the original circuit.\n\n    .. plot::\n       :include-source:\n\n       from qiskit.circuit import QuantumCircuit, ParameterVector\n\n       circuit = QuantumCircuit(2)\n       params = ParameterVector('P', 2)\n       circuit.ry(params[0], 0)\n       circuit.crx(params[1], 0, 1)\n\n       bound_circuit = circuit.assign_parameters([1, 2])\n       bound_circuit.draw('mpl')\n\n       circuit.draw('mpl')",
        "api_signature": "assign_parameters(self, parameters, inplace)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "map_calibration",
        "full_api_name": "QuantumCircuit.map_calibration",
        "api_description": "",
        "api_signature": "map_calibration(qubits, parameters, schedule)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "_unroll_param_dict",
        "full_api_name": "QuantumCircuit._unroll_param_dict",
        "api_description": "",
        "api_signature": "_unroll_param_dict(parameter_binds)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "bind_parameters",
        "full_api_name": "QuantumCircuit.bind_parameters",
        "api_description": "Assign numeric parameters to values yielding a new circuit.\n\nIf the values are given as list or array they are bound to the circuit in the order\nof :attr:`parameters` (see the docstring for more details).\n\nTo assign new Parameter objects or bind the values in-place, without yielding a new\ncircuit, use the :meth:`assign_parameters` method.\n\nArgs:\n    values: ``{parameter: value, ...}`` or ``[value1, value2, ...]``\n\nRaises:\n    CircuitError: If values is a dict and contains parameters not present in the circuit.\n    TypeError: If values contains a ParameterExpression.\n\nReturns:\n    Copy of self with assignment substitution.",
        "api_signature": "bind_parameters(self, values)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "barrier",
        "full_api_name": "QuantumCircuit.barrier",
        "api_description": "Apply :class:`~.library.Barrier`. If ``qargs`` is empty, applies to all qubits\nin the circuit.\n\nArgs:\n    qargs (QubitSpecifier): Specification for one or more qubit arguments.\n    label (str): The string label of the barrier.\n\nReturns:\n    qiskit.circuit.InstructionSet: handle to the added instructions.",
        "api_signature": "barrier(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "delay",
        "full_api_name": "QuantumCircuit.delay",
        "api_description": "Apply :class:`~.circuit.Delay`. If qarg is ``None``, applies to all qubits.\nWhen applying to multiple qubits, delays with the same duration will be created.\n\nArgs:\n    duration (int or float or ParameterExpression): duration of the delay.\n    qarg (Object): qubit argument to apply this delay.\n    unit (str): unit of the duration. Supported units: ``'s'``, ``'ms'``, ``'us'``,\n        ``'ns'``, ``'ps'``, and ``'dt'``. Default is ``'dt'``, i.e. integer time unit\n        depending on the target backend.\n\nReturns:\n    qiskit.circuit.InstructionSet: handle to the added instructions.\n\nRaises:\n    CircuitError: if arguments have bad format.",
        "api_signature": "delay(self, duration, qarg, unit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "h",
        "full_api_name": "QuantumCircuit.h",
        "api_description": "Apply :class:`~qiskit.circuit.library.HGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    qubit: The qubit(s) to apply the gate to.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "h(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "ch",
        "full_api_name": "QuantumCircuit.ch",
        "api_description": "Apply :class:`~qiskit.circuit.library.CHGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    control_qubit: The qubit(s) used as the control.\n    target_qubit: The qubit(s) targeted by the gate.\n    label: The string label of the gate in the circuit.\n    ctrl_state:\n        The control state in decimal, or as a bitstring (e.g. '1').  Defaults to controlling\n        on the '1' state.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "ch(self, control_qubit, target_qubit, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "i",
        "full_api_name": "QuantumCircuit.i",
        "api_description": "Apply :class:`~qiskit.circuit.library.IGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    qubit: The qubit(s) to apply the gate to.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "i(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "id",
        "full_api_name": "QuantumCircuit.id",
        "api_description": "Apply :class:`~qiskit.circuit.library.IGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    qubit: The qubit(s) to apply the gate to.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "id(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "ms",
        "full_api_name": "QuantumCircuit.ms",
        "api_description": "Apply :class:`~qiskit.circuit.library.MSGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    theta: The angle of the rotation.\n    qubits: The qubits to apply the gate to.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "ms(self, theta, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "p",
        "full_api_name": "QuantumCircuit.p",
        "api_description": "Apply :class:`~qiskit.circuit.library.PhaseGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    theta: THe angle of the rotation.\n    qubit: The qubit(s) to apply the gate to.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "p(self, theta, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "cp",
        "full_api_name": "QuantumCircuit.cp",
        "api_description": "Apply :class:`~qiskit.circuit.library.CPhaseGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    theta: The angle of the rotation.\n    control_qubit: The qubit(s) used as the control.\n    target_qubit: The qubit(s) targeted by the gate.\n    label: The string label of the gate in the circuit.\n    ctrl_state:\n        The control state in decimal, or as a bitstring (e.g. '1').  Defaults to controlling\n        on the '1' state.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "cp(self, theta, control_qubit, target_qubit, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "mcp",
        "full_api_name": "QuantumCircuit.mcp",
        "api_description": "Apply :class:`~qiskit.circuit.library.MCPhaseGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    lam: The angle of the rotation.\n    control_qubits: The qubits used as the controls.\n    target_qubit: The qubit(s) targeted by the gate.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "mcp(self, lam, control_qubits, target_qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "r",
        "full_api_name": "QuantumCircuit.r",
        "api_description": "Apply :class:`~qiskit.circuit.library.RGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    theta: The angle of the rotation.\n    phi: The angle of the axis of rotation in the x-y plane.\n    qubit: The qubit(s) to apply the gate to.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "r(self, theta, phi, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "rv",
        "full_api_name": "QuantumCircuit.rv",
        "api_description": "Apply :class:`~qiskit.circuit.library.RVGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nRotation around an arbitrary rotation axis :math:`v`, where :math:`|v|` is the angle of\nrotation in radians.\n\nArgs:\n    vx: x-component of the rotation axis.\n    vy: y-component of the rotation axis.\n    vz: z-component of the rotation axis.\n    qubit: The qubit(s) to apply the gate to.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "rv(self, vx, vy, vz, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "rccx",
        "full_api_name": "QuantumCircuit.rccx",
        "api_description": "Apply :class:`~qiskit.circuit.library.RCCXGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    control_qubit1: The qubit(s) used as the first control.\n    control_qubit2: The qubit(s) used as the second control.\n    target_qubit: The qubit(s) targeted by the gate.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "rccx(self, control_qubit1, control_qubit2, target_qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "rcccx",
        "full_api_name": "QuantumCircuit.rcccx",
        "api_description": "Apply :class:`~qiskit.circuit.library.RC3XGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    control_qubit1: The qubit(s) used as the first control.\n    control_qubit2: The qubit(s) used as the second control.\n    control_qubit3: The qubit(s) used as the third control.\n    target_qubit: The qubit(s) targeted by the gate.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "rcccx(self, control_qubit1, control_qubit2, control_qubit3, target_qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "rx",
        "full_api_name": "QuantumCircuit.rx",
        "api_description": "Apply :class:`~qiskit.circuit.library.RXGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    theta: The rotation angle of the gate.\n    qubit: The qubit(s) to apply the gate to.\n    label: The string label of the gate in the circuit.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "rx(self, theta, qubit, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "crx",
        "full_api_name": "QuantumCircuit.crx",
        "api_description": "Apply :class:`~qiskit.circuit.library.CRXGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    theta: The angle of the rotation.\n    control_qubit: The qubit(s) used as the control.\n    target_qubit: The qubit(s) targeted by the gate.\n    label: The string label of the gate in the circuit.\n    ctrl_state:\n        The control state in decimal, or as a bitstring (e.g. '1').  Defaults to controlling\n        on the '1' state.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "crx(self, theta, control_qubit, target_qubit, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "rxx",
        "full_api_name": "QuantumCircuit.rxx",
        "api_description": "Apply :class:`~qiskit.circuit.library.RXXGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    theta: The angle of the rotation.\n    qubit1: The qubit(s) to apply the gate to.\n    qubit2: The qubit(s) to apply the gate to.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "rxx(self, theta, qubit1, qubit2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "ry",
        "full_api_name": "QuantumCircuit.ry",
        "api_description": "Apply :class:`~qiskit.circuit.library.RYGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    theta: The rotation angle of the gate.\n    qubit: The qubit(s) to apply the gate to.\n    label: The string label of the gate in the circuit.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "ry(self, theta, qubit, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "cry",
        "full_api_name": "QuantumCircuit.cry",
        "api_description": "Apply :class:`~qiskit.circuit.library.CRYGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    theta: The angle of the rotation.\n    control_qubit: The qubit(s) used as the control.\n    target_qubit: The qubit(s) targeted by the gate.\n    label: The string label of the gate in the circuit.\n    ctrl_state:\n        The control state in decimal, or as a bitstring (e.g. '1').  Defaults to controlling\n        on the '1' state.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "cry(self, theta, control_qubit, target_qubit, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "ryy",
        "full_api_name": "QuantumCircuit.ryy",
        "api_description": "Apply :class:`~qiskit.circuit.library.RYYGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    theta: The rotation angle of the gate.\n    qubit1: The qubit(s) to apply the gate to.\n    qubit2: The qubit(s) to apply the gate to.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "ryy(self, theta, qubit1, qubit2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "rz",
        "full_api_name": "QuantumCircuit.rz",
        "api_description": "Apply :class:`~qiskit.circuit.library.RZGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    phi: The rotation angle of the gate.\n    qubit: The qubit(s) to apply the gate to.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "rz(self, phi, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "crz",
        "full_api_name": "QuantumCircuit.crz",
        "api_description": "Apply :class:`~qiskit.circuit.library.CRZGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    theta: The angle of the rotation.\n    control_qubit: The qubit(s) used as the control.\n    target_qubit: The qubit(s) targeted by the gate.\n    label: The string label of the gate in the circuit.\n    ctrl_state:\n        The control state in decimal, or as a bitstring (e.g. '1').  Defaults to controlling\n        on the '1' state.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "crz(self, theta, control_qubit, target_qubit, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "rzx",
        "full_api_name": "QuantumCircuit.rzx",
        "api_description": "Apply :class:`~qiskit.circuit.library.RZXGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    theta: The rotation angle of the gate.\n    qubit1: The qubit(s) to apply the gate to.\n    qubit2: The qubit(s) to apply the gate to.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "rzx(self, theta, qubit1, qubit2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "rzz",
        "full_api_name": "QuantumCircuit.rzz",
        "api_description": "Apply :class:`~qiskit.circuit.library.RZZGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    theta: The rotation angle of the gate.\n    qubit1: The qubit(s) to apply the gate to.\n    qubit2: The qubit(s) to apply the gate to.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "rzz(self, theta, qubit1, qubit2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "ecr",
        "full_api_name": "QuantumCircuit.ecr",
        "api_description": "Apply :class:`~qiskit.circuit.library.ECRGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    qubit1, qubit2: The qubits to apply the gate to.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "ecr(self, qubit1, qubit2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "s",
        "full_api_name": "QuantumCircuit.s",
        "api_description": "Apply :class:`~qiskit.circuit.library.SGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    qubit: The qubit(s) to apply the gate to.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "s(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "sdg",
        "full_api_name": "QuantumCircuit.sdg",
        "api_description": "Apply :class:`~qiskit.circuit.library.SdgGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    qubit: The qubit(s) to apply the gate to.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "sdg(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "cs",
        "full_api_name": "QuantumCircuit.cs",
        "api_description": "Apply :class:`~qiskit.circuit.library.CSGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    control_qubit: The qubit(s) used as the control.\n    target_qubit: The qubit(s) targeted by the gate.\n    label: The string label of the gate in the circuit.\n    ctrl_state:\n        The control state in decimal, or as a bitstring (e.g. '1').  Defaults to controlling\n        on the '1' state.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "cs(self, control_qubit, target_qubit, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "csdg",
        "full_api_name": "QuantumCircuit.csdg",
        "api_description": "Apply :class:`~qiskit.circuit.library.CSdgGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    control_qubit: The qubit(s) used as the control.\n    target_qubit: The qubit(s) targeted by the gate.\n    label: The string label of the gate in the circuit.\n    ctrl_state:\n        The control state in decimal, or as a bitstring (e.g. '1').  Defaults to controlling\n        on the '1' state.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "csdg(self, control_qubit, target_qubit, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "swap",
        "full_api_name": "QuantumCircuit.swap",
        "api_description": "Apply :class:`~qiskit.circuit.library.SwapGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    qubit1, qubit2: The qubits to apply the gate to.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "swap(self, qubit1, qubit2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "iswap",
        "full_api_name": "QuantumCircuit.iswap",
        "api_description": "Apply :class:`~qiskit.circuit.library.iSwapGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    qubit1, qubit2: The qubits to apply the gate to.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "iswap(self, qubit1, qubit2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "cswap",
        "full_api_name": "QuantumCircuit.cswap",
        "api_description": "Apply :class:`~qiskit.circuit.library.CSwapGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    control_qubit: The qubit(s) used as the control.\n    target_qubit1: The qubit(s) targeted by the gate.\n    target_qubit2: The qubit(s) targeted by the gate.\n    label: The string label of the gate in the circuit.\n    ctrl_state:\n        The control state in decimal, or as a bitstring (e.g. ``'1'``).  Defaults to controlling\n        on the ``'1'`` state.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "cswap(self, control_qubit, target_qubit1, target_qubit2, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "fredkin",
        "full_api_name": "QuantumCircuit.fredkin",
        "api_description": "Apply :class:`~qiskit.circuit.library.CSwapGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    control_qubit: The qubit(s) used as the control.\n    target_qubit1: The qubit(s) targeted by the gate.\n    target_qubit2: The qubit(s) targeted by the gate.\n\nReturns:\n    A handle to the instructions created.\n\nSee Also:\n    QuantumCircuit.cswap: the same function with a different name.",
        "api_signature": "fredkin(self, control_qubit, target_qubit1, target_qubit2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "sx",
        "full_api_name": "QuantumCircuit.sx",
        "api_description": "Apply :class:`~qiskit.circuit.library.SXGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    qubit: The qubit(s) to apply the gate to.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "sx(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "sxdg",
        "full_api_name": "QuantumCircuit.sxdg",
        "api_description": "Apply :class:`~qiskit.circuit.library.SXdgGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    qubit: The qubit(s) to apply the gate to.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "sxdg(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "csx",
        "full_api_name": "QuantumCircuit.csx",
        "api_description": "Apply :class:`~qiskit.circuit.library.CSXGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    control_qubit: The qubit(s) used as the control.\n    target_qubit: The qubit(s) targeted by the gate.\n    label: The string label of the gate in the circuit.\n    ctrl_state:\n        The control state in decimal, or as a bitstring (e.g. '1').  Defaults to controlling\n        on the '1' state.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "csx(self, control_qubit, target_qubit, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "t",
        "full_api_name": "QuantumCircuit.t",
        "api_description": "Apply :class:`~qiskit.circuit.library.TGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    qubit: The qubit(s) to apply the gate to.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "t(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "tdg",
        "full_api_name": "QuantumCircuit.tdg",
        "api_description": "Apply :class:`~qiskit.circuit.library.TdgGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    qubit: The qubit(s) to apply the gate to.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "tdg(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "u",
        "full_api_name": "QuantumCircuit.u",
        "api_description": "Apply :class:`~qiskit.circuit.library.UGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    theta: The :math:`\\theta` rotation angle of the gate.\n    phi: The :math:`\\phi` rotation angle of the gate.\n    lam: The :math:`\\lambda` rotation angle of the gate.\n    qubit: The qubit(s) to apply the gate to.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "u(self, theta, phi, lam, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "cu",
        "full_api_name": "QuantumCircuit.cu",
        "api_description": "Apply :class:`~qiskit.circuit.library.CUGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    theta: The :math:`\\theta` rotation angle of the gate.\n    phi: The :math:`\\phi` rotation angle of the gate.\n    lam: The :math:`\\lambda` rotation angle of the gate.\n    gamma: The global phase applied of the U gate, if applied.\n    control_qubit: The qubit(s) used as the control.\n    target_qubit: The qubit(s) targeted by the gate.\n    label: The string label of the gate in the circuit.\n    ctrl_state:\n        The control state in decimal, or as a bitstring (e.g. '1').  Defaults to controlling\n        on the '1' state.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "cu(self, theta, phi, lam, gamma, control_qubit, target_qubit, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "x",
        "full_api_name": "QuantumCircuit.x",
        "api_description": "Apply :class:`~qiskit.circuit.library.XGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    qubit: The qubit(s) to apply the gate to.\n    label: The string label of the gate in the circuit.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "x(self, qubit, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "cx",
        "full_api_name": "QuantumCircuit.cx",
        "api_description": "Apply :class:`~qiskit.circuit.library.CXGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    control_qubit: The qubit(s) used as the control.\n    target_qubit: The qubit(s) targeted by the gate.\n    label: The string label of the gate in the circuit.\n    ctrl_state:\n        The control state in decimal, or as a bitstring (e.g. '1').  Defaults to controlling\n        on the '1' state.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "cx(self, control_qubit, target_qubit, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "cnot",
        "full_api_name": "QuantumCircuit.cnot",
        "api_description": "Apply :class:`~qiskit.circuit.library.CXGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    control_qubit: The qubit(s) used as the control.\n    target_qubit: The qubit(s) targeted by the gate.\n    label: The string label of the gate in the circuit.\n    ctrl_state:\n        The control state in decimal, or as a bitstring (e.g. '1').  Defaults to controlling\n        on the '1' state.\n\nReturns:\n    A handle to the instructions created.\n\nSee Also:\n    QuantumCircuit.cx: the same function with a different name.",
        "api_signature": "cnot(self, control_qubit, target_qubit, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "dcx",
        "full_api_name": "QuantumCircuit.dcx",
        "api_description": "Apply :class:`~qiskit.circuit.library.DCXGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    qubit1: The qubit(s) to apply the gate to.\n    qubit2: The qubit(s) to apply the gate to.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "dcx(self, qubit1, qubit2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "ccx",
        "full_api_name": "QuantumCircuit.ccx",
        "api_description": "Apply :class:`~qiskit.circuit.library.CCXGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    control_qubit1: The qubit(s) used as the first control.\n    control_qubit2: The qubit(s) used as the second control.\n    target_qubit: The qubit(s) targeted by the gate.\n    ctrl_state:\n        The control state in decimal, or as a bitstring (e.g. '1').  Defaults to controlling\n        on the '1' state.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "ccx(self, control_qubit1, control_qubit2, target_qubit, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "toffoli",
        "full_api_name": "QuantumCircuit.toffoli",
        "api_description": "Apply :class:`~qiskit.circuit.library.CCXGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    control_qubit1: The qubit(s) used as the first control.\n    control_qubit2: The qubit(s) used as the second control.\n    target_qubit: The qubit(s) targeted by the gate.\n\nReturns:\n    A handle to the instructions created.\n\nSee Also:\n    QuantumCircuit.ccx: the same gate with a different name.",
        "api_signature": "toffoli(self, control_qubit1, control_qubit2, target_qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "mcx",
        "full_api_name": "QuantumCircuit.mcx",
        "api_description": "Apply :class:`~qiskit.circuit.library.MCXGate`.\n\nThe multi-cX gate can be implemented using different techniques, which use different numbers\nof ancilla qubits and have varying circuit depth. These modes are:\n\n- ``'noancilla'``: Requires 0 ancilla qubits.\n- ``'recursion'``: Requires 1 ancilla qubit if more than 4 controls are used, otherwise 0.\n- ``'v-chain'``: Requires 2 less ancillas than the number of control qubits.\n- ``'v-chain-dirty'``: Same as for the clean ancillas (but the circuit will be longer).\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    control_qubits: The qubits used as the controls.\n    target_qubit: The qubit(s) targeted by the gate.\n    ancilla_qubits: The qubits used as the ancillae, if the mode requires them.\n    mode: The choice of mode, explained further above.\n\nReturns:\n    A handle to the instructions created.\n\nRaises:\n    ValueError: if the given mode is not known, or if too few ancilla qubits are passed.\n    AttributeError: if no ancilla qubits are passed, but some are needed.",
        "api_signature": "mcx(self, control_qubits, target_qubit, ancilla_qubits, mode)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "mct",
        "full_api_name": "QuantumCircuit.mct",
        "api_description": "Apply :class:`~qiskit.circuit.library.MCXGate`.\n\nThe multi-cX gate can be implemented using different techniques, which use different numbers\nof ancilla qubits and have varying circuit depth. These modes are:\n\n- ``'noancilla'``: Requires 0 ancilla qubits.\n- ``'recursion'``: Requires 1 ancilla qubit if more than 4 controls are used, otherwise 0.\n- ``'v-chain'``: Requires 2 less ancillas than the number of control qubits.\n- ``'v-chain-dirty'``: Same as for the clean ancillas (but the circuit will be longer).\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    control_qubits: The qubits used as the controls.\n    target_qubit: The qubit(s) targeted by the gate.\n    ancilla_qubits: The qubits used as the ancillae, if the mode requires them.\n    mode: The choice of mode, explained further above.\n\nReturns:\n    A handle to the instructions created.\n\nRaises:\n    ValueError: if the given mode is not known, or if too few ancilla qubits are passed.\n    AttributeError: if no ancilla qubits are passed, but some are needed.\n\nSee Also:\n    QuantumCircuit.mcx: the same gate with a different name.",
        "api_signature": "mct(self, control_qubits, target_qubit, ancilla_qubits, mode)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "y",
        "full_api_name": "QuantumCircuit.y",
        "api_description": "Apply :class:`~qiskit.circuit.library.YGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    qubit: The qubit(s) to apply the gate to.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "y(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "cy",
        "full_api_name": "QuantumCircuit.cy",
        "api_description": "Apply :class:`~qiskit.circuit.library.CYGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    control_qubit: The qubit(s) used as the controls.\n    target_qubit: The qubit(s) targeted by the gate.\n    label: The string label of the gate in the circuit.\n    ctrl_state:\n        The control state in decimal, or as a bitstring (e.g. '1').  Defaults to controlling\n        on the '1' state.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "cy(self, control_qubit, target_qubit, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "z",
        "full_api_name": "QuantumCircuit.z",
        "api_description": "Apply :class:`~qiskit.circuit.library.ZGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    qubit: The qubit(s) to apply the gate to.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "z(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "cz",
        "full_api_name": "QuantumCircuit.cz",
        "api_description": "Apply :class:`~qiskit.circuit.library.CZGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    control_qubit: The qubit(s) used as the controls.\n    target_qubit: The qubit(s) targeted by the gate.\n    label: The string label of the gate in the circuit.\n    ctrl_state:\n        The control state in decimal, or as a bitstring (e.g. '1').  Defaults to controlling\n        on the '1' state.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "cz(self, control_qubit, target_qubit, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "ccz",
        "full_api_name": "QuantumCircuit.ccz",
        "api_description": "Apply :class:`~qiskit.circuit.library.CCZGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    control_qubit1: The qubit(s) used as the first control.\n    control_qubit2: The qubit(s) used as the second control.\n    target_qubit: The qubit(s) targeted by the gate.\n    label: The string label of the gate in the circuit.\n    ctrl_state:\n        The control state in decimal, or as a bitstring (e.g. '10').  Defaults to controlling\n        on the '11' state.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "ccz(self, control_qubit1, control_qubit2, target_qubit, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "pauli",
        "full_api_name": "QuantumCircuit.pauli",
        "api_description": "Apply :class:`~qiskit.circuit.library.PauliGate`.\n\nArgs:\n    pauli_string: A string representing the Pauli operator to apply, e.g. 'XX'.\n    qubits: The qubits to apply this gate to.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "pauli(self, pauli_string, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "initialize",
        "full_api_name": "QuantumCircuit.initialize",
        "api_description": "Initialize qubits in a specific state.\n\nQubit initialization is done by first resetting the qubits to :math:`|0\\rangle`\nfollowed by calling :class:`qiskit.extensions.StatePreparation`\nclass to prepare the qubits in a specified state.\nBoth these steps are included in the\n:class:`qiskit.extensions.Initialize` instruction.\n\nArgs:\n    params: The state to initialize to, can be either of the following.\n\n        * Statevector or vector of complex amplitudes to initialize to.\n        * Labels of basis states of the Pauli eigenstates Z, X, Y. See\n          :meth:`.Statevector.from_label`. Notice the order of the labels is reversed with\n          respect to the qubit index to be applied to. Example label '01' initializes the\n          qubit zero to :math:`|1\\rangle` and the qubit one to :math:`|0\\rangle`.\n        * An integer that is used as a bitmap indicating which qubits to initialize to\n          :math:`|1\\rangle`. Example: setting params to 5 would initialize qubit 0 and qubit\n          2 to :math:`|1\\rangle` and qubit 1 to :math:`|0\\rangle`.\n\n    qubits: Qubits to initialize. If ``None`` the initialization is applied to all qubits in\n        the circuit.\n    normalize: Whether to normalize an input array to a unit vector.\n\nReturns:\n    A handle to the instructions created.\n\nExamples:\n    Prepare a qubit in the state :math:`(|0\\rangle - |1\\rangle) / \\sqrt{2}`.\n\n    .. code-block::\n\n        import numpy as np\n        from qiskit import QuantumCircuit\n\n        circuit = QuantumCircuit(1)\n        circuit.initialize([1/np.sqrt(2), -1/np.sqrt(2)], 0)\n        circuit.draw()\n\n    output:\n\n    .. parsed-literal::\n\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_0: \u2524 Initialize(0.70711,-0.70711) \u251c\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n\n    Initialize from a string two qubits in the state :math:`|10\\rangle`.\n    The order of the labels is reversed with respect to qubit index.\n    More information about labels for basis states are in\n    :meth:`.Statevector.from_label`.\n\n    .. code-block::\n\n        import numpy as np\n        from qiskit import QuantumCircuit\n\n        circuit = QuantumCircuit(2)\n        circuit.initialize('01', circuit.qubits)\n        circuit.draw()\n\n    output:\n\n    .. parsed-literal::\n\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_0: \u25240                 \u251c\n             \u2502  Initialize(0,1) \u2502\n        q_1: \u25241                 \u251c\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    Initialize two qubits from an array of complex amplitudes.\n\n    .. code-block::\n\n        import numpy as np\n        from qiskit import QuantumCircuit\n\n        circuit = QuantumCircuit(2)\n        circuit.initialize([0, 1/np.sqrt(2), -1.j/np.sqrt(2), 0], circuit.qubits)\n        circuit.draw()\n\n    output:\n\n    .. parsed-literal::\n\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_0: \u25240                                   \u251c\n             \u2502  Initialize(0,0.70711,-0.70711j,0) \u2502\n        q_1: \u25241                                   \u251c\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
        "api_signature": "initialize(self, params, qubits, normalize)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "unitary",
        "full_api_name": "QuantumCircuit.unitary",
        "api_description": "Apply unitary gate specified by ``obj`` to ``qubits``.\n\nArgs:\n    obj: Unitary operator.\n    qubits: The circuit qubits to apply the transformation to.\n    label: Unitary name for backend [Default: None].\n\nReturns:\n    QuantumCircuit: The quantum circuit.\n\nExample:\n\n    Apply a gate specified by a unitary matrix to a quantum circuit\n\n    .. code-block:: python\n\n        from qiskit import QuantumCircuit\n        matrix = [[0, 0, 0, 1],\n                [0, 0, 1, 0],\n                [1, 0, 0, 0],\n                [0, 1, 0, 0]]\n        circuit = QuantumCircuit(2)\n        circuit.unitary(matrix, [0, 1])",
        "api_signature": "unitary(self, obj, qubits, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "diagonal",
        "full_api_name": "QuantumCircuit.diagonal",
        "api_description": "Attach a diagonal gate to a circuit.\n\nThe decomposition is based on Theorem 7 given in \"Synthesis of Quantum Logic Circuits\" by\nShende et al. (https://arxiv.org/pdf/quant-ph/0406176.pdf).\n\nArgs:\n    diag (list): list of the 2^k diagonal entries (for a diagonal gate on k qubits).\n        Must contain at least two entries\n    qubit (QuantumRegister | list): list of k qubits the diagonal is\n        acting on (the order of the qubits specifies the computational basis in which the\n        diagonal gate is provided: the first element in diag acts on the state where all\n        the qubits in q are in the state 0, the second entry acts on the state where all\n        the qubits q[1],...,q[k-1] are in the state zero and q[0] is in the state 1,\n        and so on)\n\nReturns:\n    QuantumCircuit: the diagonal gate which was attached to the circuit.\n\nRaises:\n    QiskitError: if the list of the diagonal entries or the qubit list is in bad format;\n        if the number of diagonal entries is not 2^k, where k denotes the number of qubits",
        "api_signature": "diagonal(self, diag, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "iso",
        "full_api_name": "QuantumCircuit.iso",
        "api_description": "Attach an arbitrary isometry from m to n qubits to a circuit. In particular,\nthis allows to attach arbitrary unitaries on n qubits (m=n) or to prepare any state\non n qubits (m=0).\nThe decomposition used here was introduced by Iten et al. in https://arxiv.org/abs/1501.06911.\n\nArgs:\n    isometry (ndarray): an isometry from m to n qubits, i.e., a (complex) ndarray of\n        dimension 2^n\u00d72^m with orthonormal columns (given in the computational basis\n        specified by the order of the ancillas and the input qubits, where the ancillas\n        are considered to be more significant than the input qubits.).\n    q_input (QuantumRegister | list[Qubit]): list of m qubits where the input\n        to the isometry is fed in (empty list for state preparation).\n    q_ancillas_for_output (QuantumRegister | list[Qubit]): list of n-m ancilla\n        qubits that are used for the output of the isometry and which are assumed to start\n        in the zero state. The qubits are listed with increasing significance.\n    q_ancillas_zero (QuantumRegister | list[Qubit]): list of ancilla qubits\n        which are assumed to start in the zero state. Default is q_ancillas_zero = None.\n    q_ancillas_dirty (QuantumRegister | list[Qubit]): list of ancilla qubits\n        which can start in an arbitrary state. Default is q_ancillas_dirty = None.\n    epsilon (float): error tolerance of calculations.\n        Default is epsilon = _EPS.\n\nReturns:\n    QuantumCircuit: the isometry is attached to the quantum circuit.\n\nRaises:\n    QiskitError: if the array is not an isometry of the correct size corresponding to\n        the provided number of qubits.",
        "api_signature": "iso(self, isometry, q_input, q_ancillas_for_output, q_ancillas_zero, q_ancillas_dirty, epsilon)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "hamiltonian",
        "full_api_name": "QuantumCircuit.hamiltonian",
        "api_description": "Apply hamiltonian evolution to qubits.\n\nThis gate resolves to a :class:`~.library.UnitaryGate` as :math:`U(t) = exp(-i t H)`,\nwhich can be decomposed into basis gates if it is 2 qubits or less, or\nsimulated directly in Aer for more qubits.\n\nArgs:\n    operator (matrix or Operator): a hermitian operator.\n    time (float or ParameterExpression): time evolution parameter.\n    qubits (Union[int, Tuple[int]]): The circuit qubits to apply the\n        transformation to.\n    label (str): unitary name for backend [Default: None].\n\nReturns:\n    QuantumCircuit: The quantum circuit.",
        "api_signature": "hamiltonian(self, operator, time, qubits, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "uc",
        "full_api_name": "QuantumCircuit.uc",
        "api_description": "Attach a uniformly controlled gates (also called multiplexed gates) to a circuit.\n\nThe decomposition was introduced by Bergholm et al. in\nhttps://arxiv.org/pdf/quant-ph/0410066.pdf.\n\nArgs:\n    gate_list (list[ndarray]): list of two qubit unitaries [U_0,...,U_{2^k-1}],\n        where each single-qubit unitary U_i is a given as a 2*2 array\n    q_controls (QuantumRegister | list[(QuantumRegister,int)]): list of k control qubits.\n        The qubits are ordered according to their significance in the computational basis.\n        For example if q_controls=[q[1],q[2]] (with q = QuantumRegister(2)),\n        the unitary U_0 is performed\u00a0if q[1] and q[2] are in the state zero, U_1 is\n        performed if q[2] is in the state zero and q[1] is in the state one, and so on\n    q_target (QuantumRegister | tuple(QuantumRegister, int)):  target qubit, where we act on with\n        the single-qubit gates.\n    up_to_diagonal (bool): If set to True, the uniformly controlled gate is decomposed up\n        to a diagonal gate, i.e. a unitary u' is implemented such that there exists a\n        diagonal gate d with u = d.dot(u'), where the unitary u describes the uniformly\n        controlled gate\n\nReturns:\n    QuantumCircuit: the uniformly controlled gate is attached to the circuit.\n\nRaises:\n    QiskitError: if the list number of control qubits does not correspond to the provided\n        number of single-qubit unitaries; if an input is of the wrong type",
        "api_signature": "uc(self, gate_list, q_controls, q_target, up_to_diagonal)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "ucrx",
        "full_api_name": "QuantumCircuit.ucrx",
        "api_description": "Attach a uniformly controlled (also called multiplexed) Rx rotation gate to a circuit.\n\nThe decomposition is base on https://arxiv.org/pdf/quant-ph/0406176.pdf by Shende et al.\n\nArgs:\n    angle_list (list[float]): list of (real) rotation angles :math:`[a_0,...,a_{2^k-1}]`\n    q_controls (Sequence[QubitSpecifier]): list of k control qubits\n        (or empty list if no controls). The control qubits are ordered according to their\n        significance in increasing order: For example if ``q_controls=[q[0],q[1]]``\n        (with ``q = QuantumRegister(2)``), the rotation ``Rx(a_0)`` is performed if ``q[0]``\n        and ``q[1]`` are in the state zero, the rotation ``Rx(a_1)`` is performed if ``q[0]``\n        is in the state one and ``q[1]`` is in the state zero, and so on\n    q_target (QubitSpecifier): target qubit, where we act on with\n        the single-qubit rotation gates\n\nReturns:\n    QuantumCircuit: the uniformly controlled rotation gate is attached to the circuit.\n\nRaises:\n    QiskitError: if the list number of control qubits does not correspond to the provided\n        number of single-qubit unitaries; if an input is of the wrong type",
        "api_signature": "ucrx(self, angle_list, q_controls, q_target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "ucry",
        "full_api_name": "QuantumCircuit.ucry",
        "api_description": "Attach a uniformly controlled (also called multiplexed) Ry rotation gate to a circuit.\n\nThe decomposition is base on https://arxiv.org/pdf/quant-ph/0406176.pdf by Shende et al.\n\nArgs:\n    angle_list (list[float]): list of (real) rotation angles :math:`[a_0,...,a_{2^k-1}]`\n    q_controls (Sequence[QubitSpecifier]): list of k control qubits\n        (or empty list if no controls). The control qubits are ordered according to their\n        significance in increasing order: For example if ``q_controls=[q[0],q[1]]``\n        (with ``q = QuantumRegister(2)``), the rotation ``Ry(a_0)`` is performed if ``q[0]``\n        and ``q[1]`` are in the state zero, the rotation ``Ry(a_1)`` is performed if ``q[0]``\n        is in the state one and ``q[1]`` is in the state zero, and so on\n    q_target (QubitSpecifier): target qubit, where we act on with\n        the single-qubit rotation gates\n\nReturns:\n    QuantumCircuit: the uniformly controlled rotation gate is attached to the circuit.\n\nRaises:\n    QiskitError: if the list number of control qubits does not correspond to the provided\n        number of single-qubit unitaries; if an input is of the wrong type",
        "api_signature": "ucry(self, angle_list, q_controls, q_target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "ucrz",
        "full_api_name": "QuantumCircuit.ucrz",
        "api_description": "Attach a uniformly controlled (also called multiplexed) Rz rotation gate to a circuit.\n\nThe decomposition is base on https://arxiv.org/pdf/quant-ph/0406176.pdf by Shende et al.\n\nArgs:\n    angle_list (list[float]): list of (real) rotation angles :math:`[a_0,...,a_{2^k-1}]`\n    q_controls (Sequence[QubitSpecifier]): list of k control qubits\n        (or empty list if no controls). The control qubits are ordered according to their\n        significance in increasing order: For example if ``q_controls=[q[0],q[1]]``\n        (with ``q = QuantumRegister(2)``), the rotation ``Rz(a_0)`` is performed if ``q[0]``\n        and ``q[1]`` are in the state zero, the rotation ``Rz(a_1)`` is performed if ``q[0]``\n        is in the state one and ``q[1]`` is in the state zero, and so on\n    q_target (QubitSpecifier): target qubit, where we act on with\n        the single-qubit rotation gates\n\nReturns:\n    QuantumCircuit: the uniformly controlled rotation gate is attached to the circuit.\n\nRaises:\n    QiskitError: if the list number of control qubits does not correspond to the provided\n        number of single-qubit unitaries; if an input is of the wrong type",
        "api_signature": "ucrz(self, angle_list, q_controls, q_target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "squ",
        "full_api_name": "QuantumCircuit.squ",
        "api_description": "Decompose an arbitrary 2*2 unitary into three rotation gates.\n\nNote that the decomposition is up to a global phase shift.\n(This is a well known decomposition which can be found for example in Nielsen and Chuang's book\n\"Quantum computation and quantum information\".)\n\nArgs:\n    unitary_matrix (ndarray): 2*2 unitary (given as a (complex) ndarray).\n    qubit (QuantumRegister or Qubit): The qubit which the gate is acting on.\n    mode (string): determines the used decomposition by providing the rotation axes.\n        The allowed modes are: \"ZYZ\" (default)\n    up_to_diagonal (bool):  if set to True, the single-qubit unitary is decomposed up to\n        a diagonal matrix, i.e. a unitary u' is implemented such that there exists a 2*2\n        diagonal gate d with u = d.dot(u')\n\nReturns:\n    InstructionSet: The single-qubit unitary instruction attached to the circuit.\n\nRaises:\n    QiskitError: if the format is wrong; if the array u is not unitary",
        "api_signature": "squ(self, unitary_matrix, qubit, mode, up_to_diagonal)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "snapshot",
        "full_api_name": "QuantumCircuit.snapshot",
        "api_description": "Take a statevector snapshot of the internal simulator representation.\nWorks on all qubits, and prevents reordering (like barrier).\n\nFor other types of snapshots use the Snapshot extension directly.\n\nArgs:\n    label (str): a snapshot label to report the result.\n    snapshot_type (str): the type of the snapshot.\n    qubits (list or None): the qubits to apply snapshot to [Default: None].\n    params (list or None): the parameters for snapshot_type [Default: None].\n\nReturns:\n    QuantumCircuit: with attached command\n\nRaises:\n    ExtensionError: malformed command",
        "api_signature": "snapshot(self, label, snapshot_type, qubits, params)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "_push_scope",
        "full_api_name": "QuantumCircuit._push_scope",
        "api_description": "Add a scope for collecting instructions into this circuit.\n\nThis should only be done by the control-flow context managers, which will handle cleaning up\nafter themselves at the end as well.\n\nArgs:\n    qubits: Any qubits that this scope should automatically use.\n    clbits: Any clbits that this scope should automatically use.\n    allow_jumps: Whether this scope allows jumps to be used within it.\n    forbidden_message: If given, all attempts to add instructions to this scope will raise a\n        :exc:`.CircuitError` with this message.",
        "api_signature": "_push_scope(self, qubits, clbits, registers, allow_jumps, forbidden_message)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "_pop_scope",
        "full_api_name": "QuantumCircuit._pop_scope",
        "api_description": "Finish a scope used in the control-flow builder interface, and return it to the caller.\n\nThis should only be done by the control-flow context managers, since they naturally\nsynchronise the creation and deletion of stack elements.",
        "api_signature": "_pop_scope(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "_peek_previous_instruction_in_scope",
        "full_api_name": "QuantumCircuit._peek_previous_instruction_in_scope",
        "api_description": "Return the instruction 3-tuple of the most recent instruction in the current scope, even\nif that scope is currently under construction.\n\nThis function is only intended for use by the control-flow ``if``-statement builders, which\nmay need to modify a previous instruction.",
        "api_signature": "_peek_previous_instruction_in_scope(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "_pop_previous_instruction_in_scope",
        "full_api_name": "QuantumCircuit._pop_previous_instruction_in_scope",
        "api_description": "Return the instruction 3-tuple of the most recent instruction in the current scope, even\nif that scope is currently under construction, and remove it from that scope.\n\nThis function is only intended for use by the control-flow ``if``-statement builders, which\nmay need to replace a previous instruction with another.",
        "api_signature": "_pop_previous_instruction_in_scope(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "_update_parameter_table_on_instruction_removal",
        "full_api_name": "QuantumCircuit._update_parameter_table_on_instruction_removal",
        "api_description": "Update the :obj:`.ParameterTable` of this circuit given that an instance of the given\n``instruction`` has just been removed from the circuit.\n\n.. note::\n\n    This does not account for the possibility for the same instruction instance being added\n    more than once to the circuit.  At the time of writing (2021-11-17, main commit 271a82f)\n    there is a defensive ``deepcopy`` of parameterised instructions inside\n    :meth:`.QuantumCircuit.append`, so this should be safe.  Trying to account for it would\n    involve adding a potentially quadratic-scaling loop to check each entry in ``data``.",
        "api_signature": "_update_parameter_table_on_instruction_removal(self, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "while_loop",
        "full_api_name": "QuantumCircuit.while_loop",
        "api_description": "",
        "api_signature": "while_loop(self, condition, body, qubits, clbits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "while_loop",
        "full_api_name": "QuantumCircuit.while_loop",
        "api_description": "",
        "api_signature": "while_loop(self, condition, body, qubits, clbits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "while_loop",
        "full_api_name": "QuantumCircuit.while_loop",
        "api_description": "Create a ``while`` loop on this circuit.\n\nThere are two forms for calling this function.  If called with all its arguments (with the\npossible exception of ``label``), it will create a\n:obj:`~qiskit.circuit.controlflow.WhileLoopOp` with the given ``body``.  If ``body`` (and\n``qubits`` and ``clbits``) are *not* passed, then this acts as a context manager, which\nwill automatically build a :obj:`~qiskit.circuit.controlflow.WhileLoopOp` when the scope\nfinishes.  In this form, you do not need to keep track of the qubits or clbits you are\nusing, because the scope will handle it for you.\n\nExample usage::\n\n    from qiskit.circuit import QuantumCircuit, Clbit, Qubit\n    bits = [Qubit(), Qubit(), Clbit()]\n    qc = QuantumCircuit(bits)\n\n    with qc.while_loop((bits[2], 0)):\n        qc.h(0)\n        qc.cx(0, 1)\n        qc.measure(0, 0)\n\nArgs:\n    condition (Tuple[Union[ClassicalRegister, Clbit], int]): An equality condition to be\n        checked prior to executing ``body``. The left-hand side of the condition must be a\n        :obj:`~ClassicalRegister` or a :obj:`~Clbit`, and the right-hand side must be an\n        integer or boolean.\n    body (Optional[QuantumCircuit]): The loop body to be repeatedly executed.  Omit this to\n        use the context-manager mode.\n    qubits (Optional[Sequence[Qubit]]): The circuit qubits over which the loop body should\n        be run.  Omit this to use the context-manager mode.\n    clbits (Optional[Sequence[Clbit]]): The circuit clbits over which the loop body should\n        be run.  Omit this to use the context-manager mode.\n    label (Optional[str]): The string label of the instruction in the circuit.\n\nReturns:\n    InstructionSet or WhileLoopContext: If used in context-manager mode, then this should be\n    used as a ``with`` resource, which will infer the block content and operands on exit.\n    If the full form is used, then this returns a handle to the instructions created.\n\nRaises:\n    CircuitError: if an incorrect calling convention is used.",
        "api_signature": "while_loop(self, condition, body, qubits, clbits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "for_loop",
        "full_api_name": "QuantumCircuit.for_loop",
        "api_description": "",
        "api_signature": "for_loop(self, indexset, loop_parameter, body, qubits, clbits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "for_loop",
        "full_api_name": "QuantumCircuit.for_loop",
        "api_description": "",
        "api_signature": "for_loop(self, indexset, loop_parameter, body, qubits, clbits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "for_loop",
        "full_api_name": "QuantumCircuit.for_loop",
        "api_description": "Create a ``for`` loop on this circuit.\n\nThere are two forms for calling this function.  If called with all its arguments (with the\npossible exception of ``label``), it will create a\n:class:`~qiskit.circuit.ForLoopOp` with the given ``body``.  If ``body`` (and\n``qubits`` and ``clbits``) are *not* passed, then this acts as a context manager, which,\nwhen entered, provides a loop variable (unless one is given, in which case it will be\nreused) and will automatically build a :class:`~qiskit.circuit.ForLoopOp` when the\nscope finishes.  In this form, you do not need to keep track of the qubits or clbits you are\nusing, because the scope will handle it for you.\n\nFor example::\n\n    from qiskit import QuantumCircuit\n    qc = QuantumCircuit(2, 1)\n\n    with qc.for_loop(range(5)) as i:\n        qc.h(0)\n        qc.cx(0, 1)\n        qc.measure(0, 0)\n        qc.break_loop().c_if(0, True)\n\nArgs:\n    indexset (Iterable[int]): A collection of integers to loop over.  Always necessary.\n    loop_parameter (Optional[Parameter]): The parameter used within ``body`` to which\n        the values from ``indexset`` will be assigned.  In the context-manager form, if this\n        argument is not supplied, then a loop parameter will be allocated for you and\n        returned as the value of the ``with`` statement.  This will only be bound into the\n        circuit if it is used within the body.\n\n        If this argument is ``None`` in the manual form of this method, ``body`` will be\n        repeated once for each of the items in ``indexset`` but their values will be\n        ignored.\n    body (Optional[QuantumCircuit]): The loop body to be repeatedly executed.  Omit this to\n        use the context-manager mode.\n    qubits (Optional[Sequence[QubitSpecifier]]): The circuit qubits over which the loop body\n        should be run.  Omit this to use the context-manager mode.\n    clbits (Optional[Sequence[ClbitSpecifier]]): The circuit clbits over which the loop body\n        should be run.  Omit this to use the context-manager mode.\n    label (Optional[str]): The string label of the instruction in the circuit.\n\nReturns:\n    InstructionSet or ForLoopContext: depending on the call signature, either a context\n    manager for creating the for loop (it will automatically be added to the circuit at the\n    end of the block), or an :obj:`~InstructionSet` handle to the appended loop operation.\n\nRaises:\n    CircuitError: if an incorrect calling convention is used.",
        "api_signature": "for_loop(self, indexset, loop_parameter, body, qubits, clbits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "if_test",
        "full_api_name": "QuantumCircuit.if_test",
        "api_description": "",
        "api_signature": "if_test(self, condition, true_body, qubits, clbits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "if_test",
        "full_api_name": "QuantumCircuit.if_test",
        "api_description": "",
        "api_signature": "if_test(self, condition, true_body, qubits, clbits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "if_test",
        "full_api_name": "QuantumCircuit.if_test",
        "api_description": "Create an ``if`` statement on this circuit.\n\nThere are two forms for calling this function.  If called with all its arguments (with the\npossible exception of ``label``), it will create a\n:obj:`~qiskit.circuit.IfElseOp` with the given ``true_body``, and there will be\nno branch for the ``false`` condition (see also the :meth:`.if_else` method).  However, if\n``true_body`` (and ``qubits`` and ``clbits``) are *not* passed, then this acts as a context\nmanager, which can be used to build ``if`` statements.  The return value of the ``with``\nstatement is a chainable context manager, which can be used to create subsequent ``else``\nblocks.  In this form, you do not need to keep track of the qubits or clbits you are using,\nbecause the scope will handle it for you.\n\nFor example::\n\n    from qiskit.circuit import QuantumCircuit, Qubit, Clbit\n    bits = [Qubit(), Qubit(), Qubit(), Clbit(), Clbit()]\n    qc = QuantumCircuit(bits)\n\n    qc.h(0)\n    qc.cx(0, 1)\n    qc.measure(0, 0)\n    qc.h(0)\n    qc.cx(0, 1)\n    qc.measure(0, 1)\n\n    with qc.if_test((bits[3], 0)) as else_:\n        qc.x(2)\n    with else_:\n        qc.h(2)\n        qc.z(2)\n\nArgs:\n    condition (Tuple[Union[ClassicalRegister, Clbit], int]): A condition to be evaluated at\n        circuit runtime which, if true, will trigger the evaluation of ``true_body``. Can be\n        specified as either a tuple of a ``ClassicalRegister`` to be tested for equality\n        with a given ``int``, or as a tuple of a ``Clbit`` to be compared to either a\n        ``bool`` or an ``int``.\n    true_body (Optional[QuantumCircuit]): The circuit body to be run if ``condition`` is\n        true.\n    qubits (Optional[Sequence[QubitSpecifier]]): The circuit qubits over which the if/else\n        should be run.\n    clbits (Optional[Sequence[ClbitSpecifier]]): The circuit clbits over which the if/else\n        should be run.\n    label (Optional[str]): The string label of the instruction in the circuit.\n\nReturns:\n    InstructionSet or IfContext: depending on the call signature, either a context\n    manager for creating the ``if`` block (it will automatically be added to the circuit at\n    the end of the block), or an :obj:`~InstructionSet` handle to the appended conditional\n    operation.\n\nRaises:\n    CircuitError: If the provided condition references Clbits outside the\n        enclosing circuit.\n    CircuitError: if an incorrect calling convention is used.\n\nReturns:\n    A handle to the instruction created.",
        "api_signature": "if_test(self, condition, true_body, qubits, clbits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "if_else",
        "full_api_name": "QuantumCircuit.if_else",
        "api_description": "Apply :class:`~qiskit.circuit.IfElseOp`.\n\n.. note::\n\n    This method does not have an associated context-manager form, because it is already\n    handled by the :meth:`.if_test` method.  You can use the ``else`` part of that with\n    something such as::\n\n        from qiskit.circuit import QuantumCircuit, Qubit, Clbit\n        bits = [Qubit(), Qubit(), Clbit()]\n        qc = QuantumCircuit(bits)\n        qc.h(0)\n        qc.cx(0, 1)\n        qc.measure(0, 0)\n        with qc.if_test((bits[2], 0)) as else_:\n            qc.h(0)\n        with else_:\n            qc.x(0)\n\nArgs:\n    condition: A condition to be evaluated at circuit runtime which,\n        if true, will trigger the evaluation of ``true_body``. Can be\n        specified as either a tuple of a ``ClassicalRegister`` to be\n        tested for equality with a given ``int``, or as a tuple of a\n        ``Clbit`` to be compared to either a ``bool`` or an ``int``.\n    true_body: The circuit body to be run if ``condition`` is true.\n    false_body: The circuit to be run if ``condition`` is false.\n    qubits: The circuit qubits over which the if/else should be run.\n    clbits: The circuit clbits over which the if/else should be run.\n    label: The string label of the instruction in the circuit.\n\nRaises:\n    CircuitError: If the provided condition references Clbits outside the\n        enclosing circuit.\n\nReturns:\n    A handle to the instruction created.",
        "api_signature": "if_else(self, condition, true_body, false_body, qubits, clbits, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "switch",
        "full_api_name": "QuantumCircuit.switch",
        "api_description": "",
        "api_signature": "switch(self, target, cases, qubits, clbits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "switch",
        "full_api_name": "QuantumCircuit.switch",
        "api_description": "",
        "api_signature": "switch(self, target, cases, qubits, clbits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "switch",
        "full_api_name": "QuantumCircuit.switch",
        "api_description": "Create a ``switch``/``case`` structure on this circuit.\n\nThere are two forms for calling this function.  If called with all its arguments (with the\npossible exception of ``label``), it will create a :class:`.SwitchCaseOp` with the given\ncase structure.  If ``cases`` (and ``qubits`` and ``clbits``) are *not* passed, then this\nacts as a context manager, which will automatically build a :class:`.SwitchCaseOp` when the\nscope finishes.  In this form, you do not need to keep track of the qubits or clbits you are\nusing, because the scope will handle it for you.\n\nExample usage::\n\n    from qiskit.circuit import QuantumCircuit, ClassicalRegister, QuantumRegister\n    qreg = QuantumRegister(3)\n    creg = ClassicalRegister(3)\n    qc = QuantumCircuit(qreg, creg)\n    qc.h([0, 1, 2])\n    qc.measure([0, 1, 2], [0, 1, 2])\n\n    with qc.switch(creg) as case:\n        with case(0):\n            qc.x(0)\n        with case(1, 2):\n            qc.z(1)\n        with case(case.DEFAULT):\n            qc.cx(0, 1)\n\nArgs:\n    target (Union[ClassicalRegister, Clbit]): The classical value to switch one.  This must\n        be integer-like.\n    cases (Iterable[Tuple[typing.Any, QuantumCircuit]]): A sequence of case specifiers.\n        Each tuple defines one case body (the second item).  The first item of the tuple can\n        be either a single integer value, the special value :data:`.CASE_DEFAULT`, or a\n        tuple of several integer values.  Each of the integer values will be tried in turn;\n        control will then pass to the body corresponding to the first match.\n        :data:`.CASE_DEFAULT` matches all possible values.  Omit in context-manager form.\n    qubits (Sequence[Qubit]): The circuit qubits over which all case bodies execute. Omit in\n        context-manager form.\n    clbits (Sequence[Clbit]): The circuit clbits over which all case bodies execute. Omit in\n        context-manager form.\n    label (Optional[str]): The string label of the instruction in the circuit.\n\nReturns:\n    InstructionSet or SwitchCaseContext: If used in context-manager mode, then this should\n    be used as a ``with`` resource, which will return an object that can be repeatedly\n    entered to produce cases for the switch statement.  If the full form is used, then this\n    returns a handle to the instructions created.\n\nRaises:\n    CircuitError: if an incorrect calling convention is used.",
        "api_signature": "switch(self, target, cases, qubits, clbits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "break_loop",
        "full_api_name": "QuantumCircuit.break_loop",
        "api_description": "Apply :class:`~qiskit.circuit.BreakLoopOp`.\n\n.. warning::\n\n    If you are using the context-manager \"builder\" forms of :meth:`.if_test`,\n    :meth:`.for_loop` or :meth:`.while_loop`, you can only call this method if you are\n    within a loop context, because otherwise the \"resource width\" of the operation cannot be\n    determined.  This would quickly lead to invalid circuits, and so if you are trying to\n    construct a reusable loop body (without the context managers), you must also use the\n    non-context-manager form of :meth:`.if_test` and :meth:`.if_else`.  Take care that the\n    :obj:`.BreakLoopOp` instruction must span all the resources of its containing loop, not\n    just the immediate scope.\n\nReturns:\n    A handle to the instruction created.\n\nRaises:\n    CircuitError: if this method was called within a builder context, but not contained\n        within a loop.",
        "api_signature": "break_loop(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "continue_loop",
        "full_api_name": "QuantumCircuit.continue_loop",
        "api_description": "Apply :class:`~qiskit.circuit.ContinueLoopOp`.\n\n.. warning::\n\n    If you are using the context-manager \"builder\" forms of :meth:`.if_test`,\n    :meth:`.for_loop` or :meth:`.while_loop`, you can only call this method if you are\n    within a loop context, because otherwise the \"resource width\" of the operation cannot be\n    determined.  This would quickly lead to invalid circuits, and so if you are trying to\n    construct a reusable loop body (without the context managers), you must also use the\n    non-context-manager form of :meth:`.if_test` and :meth:`.if_else`.  Take care that the\n    :class:`~qiskit.circuit.ContinueLoopOp` instruction must span all the resources of its\n    containing loop, not just the immediate scope.\n\nReturns:\n    A handle to the instruction created.\n\nRaises:\n    CircuitError: if this method was called within a builder context, but not contained\n        within a loop.",
        "api_signature": "continue_loop(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "add_calibration",
        "full_api_name": "QuantumCircuit.add_calibration",
        "api_description": "Register a low-level, custom pulse definition for the given gate.\n\nArgs:\n    gate (Union[Gate, str]): Gate information.\n    qubits (Union[int, Tuple[int]]): List of qubits to be measured.\n    schedule (Schedule): Schedule information.\n    params (Optional[List[Union[float, Parameter]]]): A list of parameters.\n\nRaises:\n    Exception: if the gate is of type string and params is None.",
        "api_signature": "add_calibration(self, gate, qubits, schedule, params)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "_format",
        "full_api_name": "QuantumCircuit._format",
        "api_description": "",
        "api_signature": "_format(operand)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "qubit_duration",
        "full_api_name": "QuantumCircuit.qubit_duration",
        "api_description": "Return the duration between the start and stop time of the first and last instructions,\nexcluding delays, over the supplied qubits. Its time unit is ``self.unit``.\n\nArgs:\n    *qubits: Qubits within ``self`` to include.\n\nReturns:\n    Return the duration between the first start and last stop time of non-delay instructions",
        "api_signature": "qubit_duration(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "qubit_start_time",
        "full_api_name": "QuantumCircuit.qubit_start_time",
        "api_description": "Return the start time of the first instruction, excluding delays,\nover the supplied qubits. Its time unit is ``self.unit``.\n\nReturn 0 if there are no instructions over qubits\n\nArgs:\n    *qubits: Qubits within ``self`` to include. Integers are allowed for qubits, indicating\n    indices of ``self.qubits``.\n\nReturns:\n    Return the start time of the first instruction, excluding delays, over the qubits\n\nRaises:\n    CircuitError: if ``self`` is a not-yet scheduled circuit.",
        "api_signature": "qubit_start_time(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "qubit_stop_time",
        "full_api_name": "QuantumCircuit.qubit_stop_time",
        "api_description": "Return the stop time of the last instruction, excluding delays, over the supplied qubits.\nIts time unit is ``self.unit``.\n\nReturn 0 if there are no instructions over qubits\n\nArgs:\n    *qubits: Qubits within ``self`` to include. Integers are allowed for qubits, indicating\n    indices of ``self.qubits``.\n\nReturns:\n    Return the stop time of the last instruction, excluding delays, over the qubits\n\nRaises:\n    CircuitError: if ``self`` is a not-yet scheduled circuit.",
        "api_signature": "qubit_stop_time(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "_ParameterBindsDict.__init__",
        "api_description": "",
        "api_signature": "__init__(self, mapping, allowed_keys)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "items",
        "full_api_name": "_ParameterBindsDict.items",
        "api_description": "Iterator through all the keys in the mapping that we care about.  Wrapping the main\nmapping allows us to avoid reconstructing a new 'dict', but just use the given 'mapping'\nwithout any copy / reconstruction.",
        "api_signature": "items(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "_ParameterBindsSequence.__init__",
        "api_description": "",
        "api_signature": "__init__(self, parameters, values)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "items",
        "full_api_name": "_ParameterBindsSequence.items",
        "api_description": "Iterator through all the keys in the mapping that we care about.",
        "api_signature": "items(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "mapping",
        "full_api_name": "_ParameterBindsSequence.mapping",
        "api_description": "Cached version of a mapping.  This is only generated on demand.",
        "api_signature": "mapping(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "_bit_argument_conversion",
        "full_api_name": "_bit_argument_conversion",
        "api_description": "Get the list of bits referred to by the specifier ``specifier``.\n\nValid types for ``specifier`` are integers, bits of the correct type (as given in ``type_``), or\niterables of one of those two scalar types.  Integers are interpreted as indices into the\nsequence ``bit_sequence``.  All allowed bits must be in ``bit_set`` (which should implement\nfast lookup), which is assumed to contain the same bits as ``bit_sequence``.\n\nReturns:\n    List[Bit]: a list of the specified bits from ``bits``.\n\nRaises:\n    CircuitError: if an incorrect type or index is encountered, if the same bit is specified\n        more than once, or if the specifier is to a bit not in the ``bit_set``.",
        "api_signature": "_bit_argument_conversion(specifier, bit_sequence, bit_set, type_)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "_bit_argument_conversion_scalar",
        "full_api_name": "_bit_argument_conversion_scalar",
        "api_description": "",
        "api_signature": "_bit_argument_conversion_scalar(specifier, bit_sequence, bit_set, type_)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ControlModifier.__init__",
        "api_description": "",
        "api_signature": "__init__(self, num_ctrl_qubits, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/annotated_operation.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "AnnotatedOperation.__init__",
        "api_description": "Create a new AnnotatedOperation.\n\nAn \"annotated operation\" allows to add a list of modifiers to the\n\"base\" operation. For now, the only supported modifiers are of\ntypes :class:`~.InverseModifier`, :class:`~.ControlModifier` and\n:class:`~.PowerModifier`.\n\nAn annotated operation can be viewed as an extension of\n:class:`~.ControlledGate` (which also allows adding control to the\nbase operation). However, an important difference is that the\ncircuit definition of an annotated operation is not constructed when\nthe operation is declared, and instead happens during transpilation,\nspecifically during the :class:`~.HighLevelSynthesis` transpiler pass.\n\nAn annotated operation can be also viewed as a \"higher-level\"\nor \"more abstract\" object that can be added to a quantum circuit.\nThis enables writing transpiler optimization passes that make use of\nthis higher-level representation, for instance removing a gate\nthat is immediately followed by its inverse.\n\nArgs:\n    base_op: base operation being modified\n    modifiers: ordered list of modifiers. Supported modifiers include\n        ``InverseModifier``, ``ControlModifier`` and ``PowerModifier``.\n\nExamples::\n\n    op1 = AnnotatedOperation(SGate(), [InverseModifier(), ControlModifier(2)])\n\n    op2_inner = AnnotatedGate(SGate(), InverseModifier())\n    op2 = AnnotatedGate(op2_inner, ControlModifier(2))\n\nBoth op1 and op2 are semantically equivalent to an ``SGate()`` which is first\ninverted and then controlled by 2 qubits.",
        "api_signature": "__init__(self, base_op, modifiers)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/annotated_operation.py"
    },
    {
        "api_name": "name",
        "full_api_name": "AnnotatedOperation.name",
        "api_description": "Unique string identifier for operation type.",
        "api_signature": "name(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/annotated_operation.py"
    },
    {
        "api_name": "num_qubits",
        "full_api_name": "AnnotatedOperation.num_qubits",
        "api_description": "Number of qubits.",
        "api_signature": "num_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/annotated_operation.py"
    },
    {
        "api_name": "num_clbits",
        "full_api_name": "AnnotatedOperation.num_clbits",
        "api_description": "Number of classical bits.",
        "api_signature": "num_clbits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/annotated_operation.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "AnnotatedOperation.__eq__",
        "api_description": "Checks if two AnnotatedOperations are equal.",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/annotated_operation.py"
    },
    {
        "api_name": "copy",
        "full_api_name": "AnnotatedOperation.copy",
        "api_description": "Return a copy of the :class:`~.AnnotatedOperation`.",
        "api_signature": "copy(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/annotated_operation.py"
    },
    {
        "api_name": "to_matrix",
        "full_api_name": "AnnotatedOperation.to_matrix",
        "api_description": "Return a matrix representation (allowing to construct Operator).",
        "api_signature": "to_matrix(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/annotated_operation.py"
    },
    {
        "api_name": "_canonicalize_modifiers",
        "full_api_name": "_canonicalize_modifiers",
        "api_description": "Returns the canonical representative of the modifier list. This is possible\nsince all the modifiers commute; also note that InverseModifier is a special\ncase of PowerModifier. The current solution is to compute the total number\nof control qubits / control state and the total power. The InverseModifier\nwill be present if total power is negative, whereas the power modifier will\nbe present only with positive powers different from 1.",
        "api_signature": "_canonicalize_modifiers(modifiers)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/annotated_operation.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Parameter.__init__",
        "api_description": "Create a new named :class:`Parameter`.\n\nArgs:\n    name: name of the ``Parameter``, used for visual representation. This can\n        be any unicode string, e.g. \"\u03d5\".\n    uuid: For advanced usage only.  Override the UUID of this parameter, in order to make it\n        compare equal to some other parameter object.  By default, two parameters with the\n        same name do not compare equal to help catch shadowing bugs when two circuits\n        containing the same named parameters are spurious combined.  Setting the ``uuid``\n        field when creating two parameters to the same thing (along with the same name)\n        allows them to be equal.  This is useful during serialization and deserialization.",
        "api_signature": "__init__(self, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameter.py"
    },
    {
        "api_name": "assign",
        "full_api_name": "Parameter.assign",
        "api_description": "",
        "api_signature": "assign(self, parameter, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameter.py"
    },
    {
        "api_name": "subs",
        "full_api_name": "Parameter.subs",
        "api_description": "Substitute self with the corresponding parameter in ``parameter_map``.",
        "api_signature": "subs(self, parameter_map, allow_unknown_parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameter.py"
    },
    {
        "api_name": "name",
        "full_api_name": "Parameter.name",
        "api_description": "Returns the name of the :class:`Parameter`.",
        "api_signature": "name(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameter.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "Parameter.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameter.py"
    },
    {
        "api_name": "__copy__",
        "full_api_name": "Parameter.__copy__",
        "api_description": "",
        "api_signature": "__copy__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameter.py"
    },
    {
        "api_name": "__deepcopy__",
        "full_api_name": "Parameter.__deepcopy__",
        "api_description": "",
        "api_signature": "__deepcopy__(self, memo)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameter.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "Parameter.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameter.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "Parameter.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameter.py"
    },
    {
        "api_name": "_hash_key",
        "full_api_name": "Parameter._hash_key",
        "api_description": "",
        "api_signature": "_hash_key(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameter.py"
    },
    {
        "api_name": "__hash__",
        "full_api_name": "Parameter.__hash__",
        "api_description": "",
        "api_signature": "__hash__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameter.py"
    },
    {
        "api_name": "__getstate__",
        "full_api_name": "Parameter.__getstate__",
        "api_description": "",
        "api_signature": "__getstate__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameter.py"
    },
    {
        "api_name": "__setstate__",
        "full_api_name": "Parameter.__setstate__",
        "api_description": "",
        "api_signature": "__setstate__(self, state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameter.py"
    },
    {
        "api_name": "_identity_op",
        "full_api_name": "_identity_op",
        "api_description": "Cached identity matrix",
        "api_signature": "_identity_op(num_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/commutation_checker.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CommutationChecker.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/commutation_checker.py"
    },
    {
        "api_name": "_hashable_parameters",
        "full_api_name": "CommutationChecker._hashable_parameters",
        "api_description": "Convert the parameters of a gate into a hashable format for lookup in a dictionary.\n\nThis aims to be fast in common cases, and is not intended to work outside of the lifetime of a\nsingle commutation pass; it does not handle mutable state correctly if the state is actually\nchanged.",
        "api_signature": "_hashable_parameters(self, params)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/commutation_checker.py"
    },
    {
        "api_name": "commute",
        "full_api_name": "CommutationChecker.commute",
        "api_description": "Checks if two Operations commute. The return value of `True` means that the operations\ntruly commute, and the return value of `False` means that either the operations do not\ncommute or that the commutation check was skipped (for example, when the operations\nhave conditions or have too many qubits).\n\nArgs:\n    op1: first operation.\n    qargs1: first operation's qubits.\n    cargs1: first operation's clbits.\n    op2: second operation.\n    qargs2: second operation's qubits.\n    cargs2: second operation's clbits.\n    max_num_qubits: the maximum number of qubits to consider, the check may be skipped if\n        the number of qubits for either operation exceeds this amount.\n\nReturns:\n    bool: whether two operations commute.",
        "api_signature": "commute(self, op1, qargs1, cargs1, op2, qargs2, cargs2, max_num_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/commutation_checker.py"
    },
    {
        "api_name": "simulate",
        "full_api_name": "ClassicalElement.simulate",
        "api_description": "Evaluate the expression on a bitstring.\n\nThis evaluation is done classically.\n\nArgs:\n    bitstring: The bitstring for which to evaluate.\n\nReturns:\n    bool: result of the evaluation.",
        "api_signature": "simulate(self, bitstring)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classicalfunction/classical_element.py"
    },
    {
        "api_name": "synth",
        "full_api_name": "ClassicalElement.synth",
        "api_description": "Synthesis the logic network into a :class:`~qiskit.circuit.QuantumCircuit`.\n\nArgs:\n    registerless (bool): Default ``True``. If ``False`` uses the parameter names\n        to create registers with those names. Otherwise, creates a circuit with a flat\n        quantum register.\n    synthesizer (callable): A callable that takes a Logic Network and returns a Tweedledum\n        circuit.\nReturns:\n    QuantumCircuit: A circuit implementing the logic network.",
        "api_signature": "synth(self, registerless, synthesizer)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classicalfunction/classical_element.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "ClassicalElement._define",
        "api_description": "The definition of the boolean expression is its synthesis",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classicalfunction/classical_element.py"
    },
    {
        "api_name": "_convert_tweedledum_operator",
        "full_api_name": "_convert_tweedledum_operator",
        "api_description": "",
        "api_signature": "_convert_tweedledum_operator(op)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classicalfunction/utils.py"
    },
    {
        "api_name": "tweedledum2qiskit",
        "full_api_name": "tweedledum2qiskit",
        "api_description": "Converts a `Tweedledum <https://github.com/boschmitt/tweedledum>`_\ncircuit into a Qiskit circuit.\nArgs:\n    tweedledum_circuit (tweedledum.ir.Circuit): Tweedledum circuit.\n    name (str): Name for the resulting Qiskit circuit.\n    qregs (list(QuantumRegister)): Optional. List of QuantumRegisters on which the\n       circuit would operate. If not provided, it will create a flat register.\n\nReturns:\n    QuantumCircuit: The Tweedledum circuit converted to a Qiskit circuit.\n\nRaises:\n    ClassicalFunctionCompilerError: If a gate in the Tweedledum circuit has no Qiskit equivalent.",
        "api_signature": "tweedledum2qiskit(tweedledum_circuit, name, qregs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classicalfunction/utils.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BooleanExpression.__init__",
        "api_description": "Args:\n    expression (str): The logical expression string.\n    name (str): Optional. Instruction gate name. Otherwise part of the expression is\n       going to be used.\n    var_order(list): A list with the order in which variables will be created.\n       (default: by appearance)",
        "api_signature": "__init__(self, expression, name, var_order)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classicalfunction/boolean_expression.py"
    },
    {
        "api_name": "simulate",
        "full_api_name": "BooleanExpression.simulate",
        "api_description": "Evaluate the expression on a bitstring.\n\nThis evaluation is done classically.\n\nArgs:\n    bitstring: The bitstring for which to evaluate.\n\nReturns:\n    bool: result of the evaluation.",
        "api_signature": "simulate(self, bitstring)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classicalfunction/boolean_expression.py"
    },
    {
        "api_name": "synth",
        "full_api_name": "BooleanExpression.synth",
        "api_description": "Synthesis the logic network into a :class:`~qiskit.circuit.QuantumCircuit`.\n\nArgs:\n    registerless: Default ``True``. If ``False`` uses the parameter names\n        to create registers with those names. Otherwise, creates a circuit with a flat\n        quantum register.\n    synthesizer: A callable that takes self and returns a Tweedledum\n        circuit.\nReturns:\n    QuantumCircuit: A circuit implementing the logic network.",
        "api_signature": "synth(self, registerless, synthesizer)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classicalfunction/boolean_expression.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "BooleanExpression._define",
        "api_description": "The definition of the boolean expression is its synthesis",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classicalfunction/boolean_expression.py"
    },
    {
        "api_name": "from_dimacs_file",
        "full_api_name": "BooleanExpression.from_dimacs_file",
        "api_description": "Create a BooleanExpression from the string in the DIMACS format.\nArgs:\n    filename: A file in DIMACS format.\n\nReturns:\n    BooleanExpression: A gate for the input string\n\nRaises:\n    FileNotFoundError: If filename is not found.",
        "api_signature": "from_dimacs_file(cls, filename)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classicalfunction/boolean_expression.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ClassicalFunction.__init__",
        "api_description": "Creates a ``ClassicalFunction`` from Python source code in ``source``.\n\nThe code should be a single function with types.\n\nArgs:\n    source (str): Python code with type hints.\n    name (str): Optional. Default: \"*classicalfunction*\". ClassicalFunction name.\n\nRaises:\n    QiskitError: If source is not a string.",
        "api_signature": "__init__(self, source, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classicalfunction/classicalfunction.py"
    },
    {
        "api_name": "compile",
        "full_api_name": "ClassicalFunction.compile",
        "api_description": "Parses and creates the logical circuit",
        "api_signature": "compile(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classicalfunction/classicalfunction.py"
    },
    {
        "api_name": "network",
        "full_api_name": "ClassicalFunction.network",
        "api_description": "Returns the logical network",
        "api_signature": "network(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classicalfunction/classicalfunction.py"
    },
    {
        "api_name": "scopes",
        "full_api_name": "ClassicalFunction.scopes",
        "api_description": "Returns the scope dict",
        "api_signature": "scopes(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classicalfunction/classicalfunction.py"
    },
    {
        "api_name": "args",
        "full_api_name": "ClassicalFunction.args",
        "api_description": "Returns the classicalfunction arguments",
        "api_signature": "args(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classicalfunction/classicalfunction.py"
    },
    {
        "api_name": "types",
        "full_api_name": "ClassicalFunction.types",
        "api_description": "Dumps a list of scopes with their variables and types.\n\nReturns:\n    list(dict): A list of scopes as dicts, where key is the variable name and\n    value is its type.",
        "api_signature": "types(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classicalfunction/classicalfunction.py"
    },
    {
        "api_name": "simulate",
        "full_api_name": "ClassicalFunction.simulate",
        "api_description": "Evaluate the expression on a bitstring.\n\nThis evaluation is done classically.\n\nArgs:\n    bitstring: The bitstring for which to evaluate.\n\nReturns:\n    bool: result of the evaluation.",
        "api_signature": "simulate(self, bitstring)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classicalfunction/classicalfunction.py"
    },
    {
        "api_name": "simulate_all",
        "full_api_name": "ClassicalFunction.simulate_all",
        "api_description": "Returns a truth table.\n\nReturns:\n    str: a bitstring with a truth table",
        "api_signature": "simulate_all(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classicalfunction/classicalfunction.py"
    },
    {
        "api_name": "truth_table",
        "full_api_name": "ClassicalFunction.truth_table",
        "api_description": "Returns (and computes) the truth table",
        "api_signature": "truth_table(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classicalfunction/classicalfunction.py"
    },
    {
        "api_name": "synth",
        "full_api_name": "ClassicalFunction.synth",
        "api_description": "Synthesis the logic network into a :class:`~qiskit.circuit.QuantumCircuit`.\n\nArgs:\n    registerless: Default ``True``. If ``False`` uses the parameter names to create\n    registers with those names. Otherwise, creates a circuit with a flat quantum register.\n    synthesizer: Optional. If None tweedledum's pkrm_synth is used.\n\nReturns:\n    QuantumCircuit: A circuit implementing the logic network.",
        "api_signature": "synth(self, registerless, synthesizer)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classicalfunction/classicalfunction.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "ClassicalFunction._define",
        "api_description": "The definition of the classical function is its synthesis",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classicalfunction/classicalfunction.py"
    },
    {
        "api_name": "qregs",
        "full_api_name": "ClassicalFunction.qregs",
        "api_description": "The list of qregs used by the classicalfunction",
        "api_signature": "qregs(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classicalfunction/classicalfunction.py"
    },
    {
        "api_name": "classical_function",
        "full_api_name": "classical_function",
        "api_description": "Parses and type checks the callable ``func`` to compile it into an ``ClassicalFunction``\nthat can be synthesized into a ``QuantumCircuit``.\n\nArgs:\n    func (callable): A callable (with type hints) to compile into an ``ClassicalFunction``.\n\nReturns:\n    ClassicalFunction: An object that can synthesis into a QuantumCircuit (via ``synth()``\n    method).",
        "api_signature": "classical_function(func)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classicalfunction/__init__.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ClassicalFunctionVisitor.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classicalfunction/classical_function_visitor.py"
    },
    {
        "api_name": "visit_Module",
        "full_api_name": "ClassicalFunctionVisitor.visit_Module",
        "api_description": "The full snippet should contain a single function",
        "api_signature": "visit_Module(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classicalfunction/classical_function_visitor.py"
    },
    {
        "api_name": "visit_FunctionDef",
        "full_api_name": "ClassicalFunctionVisitor.visit_FunctionDef",
        "api_description": "The function definition should have type hints",
        "api_signature": "visit_FunctionDef(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classicalfunction/classical_function_visitor.py"
    },
    {
        "api_name": "visit_Return",
        "full_api_name": "ClassicalFunctionVisitor.visit_Return",
        "api_description": "The return type should match the return type hint.",
        "api_signature": "visit_Return(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classicalfunction/classical_function_visitor.py"
    },
    {
        "api_name": "visit_Assign",
        "full_api_name": "ClassicalFunctionVisitor.visit_Assign",
        "api_description": "When assign, the scope needs to be updated with the right type",
        "api_signature": "visit_Assign(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classicalfunction/classical_function_visitor.py"
    },
    {
        "api_name": "bit_binop",
        "full_api_name": "ClassicalFunctionVisitor.bit_binop",
        "api_description": "Uses ClassicalFunctionVisitor.bitops to extend self._network",
        "api_signature": "bit_binop(self, op, values)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classicalfunction/classical_function_visitor.py"
    },
    {
        "api_name": "visit_BoolOp",
        "full_api_name": "ClassicalFunctionVisitor.visit_BoolOp",
        "api_description": "Handles ``and`` and ``or``.\nnode.left=Int1 and node.right=Int1 return Int1",
        "api_signature": "visit_BoolOp(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classicalfunction/classical_function_visitor.py"
    },
    {
        "api_name": "visit_BinOp",
        "full_api_name": "ClassicalFunctionVisitor.visit_BinOp",
        "api_description": "Handles ``&``, ``^``, and ``|``.\nnode.left=Int1 and node.right=Int1 return Int1",
        "api_signature": "visit_BinOp(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classicalfunction/classical_function_visitor.py"
    },
    {
        "api_name": "visit_UnaryOp",
        "full_api_name": "ClassicalFunctionVisitor.visit_UnaryOp",
        "api_description": "Handles ``~``. Cannot operate on Int1s.",
        "api_signature": "visit_UnaryOp(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classicalfunction/classical_function_visitor.py"
    },
    {
        "api_name": "visit_Name",
        "full_api_name": "ClassicalFunctionVisitor.visit_Name",
        "api_description": "Reduce variable names.",
        "api_signature": "visit_Name(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classicalfunction/classical_function_visitor.py"
    },
    {
        "api_name": "generic_visit",
        "full_api_name": "ClassicalFunctionVisitor.generic_visit",
        "api_description": "Catch all for the unhandled nodes.",
        "api_signature": "generic_visit(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classicalfunction/classical_function_visitor.py"
    },
    {
        "api_name": "extend_scope",
        "full_api_name": "ClassicalFunctionVisitor.extend_scope",
        "api_description": "Add the arguments to the scope",
        "api_signature": "extend_scope(self, args_node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classicalfunction/classical_function_visitor.py"
    },
    {
        "api_name": "random_circuit",
        "full_api_name": "random_circuit",
        "api_description": "Generate random circuit of arbitrary size and form.\n\nThis function will generate a random circuit by randomly selecting gates\nfrom the set of standard gates in :mod:`qiskit.extensions`. For example:\n\n.. plot::\n   :include-source:\n\n   from qiskit.circuit.random import random_circuit\n\n   circ = random_circuit(2, 2, measure=True)\n   circ.draw(output='mpl')\n\nArgs:\n    num_qubits (int): number of quantum wires\n    depth (int): layers of operations (i.e. critical path length)\n    max_operands (int): maximum qubit operands of each gate (between 1 and 4)\n    measure (bool): if True, measure all qubits at the end\n    conditional (bool): if True, insert middle measurements and conditionals\n    reset (bool): if True, insert middle resets\n    seed (int): sets random seed (optional)\n\nReturns:\n    QuantumCircuit: constructed circuit\n\nRaises:\n    CircuitError: when invalid options given",
        "api_signature": "random_circuit(num_qubits, depth, max_operands, measure, conditional, reset, seed)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/random/utils.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PauliEvolutionGate.__init__",
        "api_description": "Args:\n    operator (Pauli | PauliOp | SparsePauliOp | PauliSumOp | list):\n        The operator to evolve. Can also be provided as list of non-commuting\n        operators where the elements are sums of commuting operators.\n        For example: ``[XY + YX, ZZ + ZI + IZ, YY]``.\n    time: The evolution time.\n    label: A label for the gate to display in visualizations. Per default, the label is\n        set to ``exp(-it <operators>)`` where ``<operators>`` is the sum of the Paulis.\n        Note that the label does not include any coefficients of the Paulis. See the\n        class docstring for an example.\n    synthesis: A synthesis strategy. If None, the default synthesis is the Lie-Trotter\n        product formula with a single repetition.",
        "api_signature": "__init__(self, operator, time, label, synthesis)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/pauli_evolution.py"
    },
    {
        "api_name": "time",
        "full_api_name": "PauliEvolutionGate.time",
        "api_description": "Return the evolution time as stored in the gate parameters.\n\nReturns:\n    The evolution time.",
        "api_signature": "time(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/pauli_evolution.py"
    },
    {
        "api_name": "time",
        "full_api_name": "PauliEvolutionGate.time",
        "api_description": "Set the evolution time.\n\nArgs:\n    time: The evolution time.",
        "api_signature": "time(self, time)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/pauli_evolution.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "PauliEvolutionGate._define",
        "api_description": "Unroll, where the default synthesis is matrix based.",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/pauli_evolution.py"
    },
    {
        "api_name": "validate_parameter",
        "full_api_name": "PauliEvolutionGate.validate_parameter",
        "api_description": "Gate parameters should be int, float, or ParameterExpression",
        "api_signature": "validate_parameter(self, parameter)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/pauli_evolution.py"
    },
    {
        "api_name": "_to_sparse_pauli_op",
        "full_api_name": "_to_sparse_pauli_op",
        "api_description": "Cast the operator to a SparsePauliOp.\n\nFor Opflow objects, return a global coefficient that must be multiplied to the evolution time.\nSince this coefficient might contain unbound parameters it cannot be absorbed into the\ncoefficients of the SparsePauliOp.",
        "api_signature": "_to_sparse_pauli_op(operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/pauli_evolution.py"
    },
    {
        "api_name": "_get_default_label",
        "full_api_name": "_get_default_label",
        "api_description": "",
        "api_signature": "_get_default_label(operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/pauli_evolution.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QuantumVolume.__init__",
        "api_description": "Create quantum volume model circuit of size num_qubits x depth.\n\nArgs:\n    num_qubits: number of active qubits in model circuit.\n    depth: layers of SU(4) operations in model circuit.\n    seed: Random number generator or generator seed.\n    classical_permutation: use classical permutations at every layer,\n        rather than quantum.",
        "api_signature": "__init__(self, num_qubits, depth, seed, classical_permutation)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/quantum_volume.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "IQP.__init__",
        "api_description": "Create IQP circuit.\n\nArgs:\n    interactions: input n-by-n symmetric matrix.\n\nRaises:\n    CircuitError: if the inputs is not as symmetric matrix.",
        "api_signature": "__init__(self, interactions)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/iqp.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "HiddenLinearFunction.__init__",
        "api_description": "Create new HLF circuit.\n\nArgs:\n    adjacency_matrix: a symmetric n-by-n list of 0-1 lists.\n        n will be the number of qubits.\n\nRaises:\n    CircuitError: If A is not symmetric.",
        "api_signature": "__init__(self, adjacency_matrix)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/hidden_linear_function.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "FourierChecking.__init__",
        "api_description": "Create Fourier checking circuit.\n\nArgs:\n    f: truth table for f, length 2**n list of {1,-1}.\n    g: truth table for g, length 2**n list of {1,-1}.\n\nRaises:\n    CircuitError: if the inputs f and g are not valid.\n\nReference Circuit:\n    .. plot::\n\n       from qiskit.circuit.library import FourierChecking\n       from qiskit.tools.jupyter.library import _generate_circuit_library_visualization\n       f = [1, -1, -1, -1]\n       g = [1, 1, -1, -1]\n       circuit = FourierChecking(f, g)\n       _generate_circuit_library_visualization(circuit)",
        "api_signature": "__init__(self, f, g)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/fourier_checking.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PhaseOracle.__init__",
        "api_description": "Creates a PhaseOracle object\n\nArgs:\n    expression: A Python-like boolean expression.\n    synthesizer: Optional. A function to convert a BooleanExpression into a QuantumCircuit\n       If None is provided, Tweedledum's `pkrm_synth` with `phase_esop` will be used.\n    var_order(list): A list with the order in which variables will be created.\n       (default: by appearance)",
        "api_signature": "__init__(self, expression, synthesizer, var_order)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/phase_oracle.py"
    },
    {
        "api_name": "synthesizer",
        "full_api_name": "PhaseOracle.synthesizer",
        "api_description": "",
        "api_signature": "synthesizer(boolean_expression)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/phase_oracle.py"
    },
    {
        "api_name": "evaluate_bitstring",
        "full_api_name": "PhaseOracle.evaluate_bitstring",
        "api_description": "Evaluate the oracle on a bitstring.\nThis evaluation is done classically without any quantum circuit.\n\nArgs:\n    bitstring: The bitstring for which to evaluate. The input bitstring is expected to be\n        in little-endian order.\n\nReturns:\n    True if the bitstring is a good state, False otherwise.",
        "api_signature": "evaluate_bitstring(self, bitstring)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/phase_oracle.py"
    },
    {
        "api_name": "from_dimacs_file",
        "full_api_name": "PhaseOracle.from_dimacs_file",
        "api_description": "Create a PhaseOracle from the string in the DIMACS format.\n\nIt is possible to build a PhaseOracle from a file in `DIMACS CNF format\n<http://www.satcompetition.org/2009/format-benchmarks2009.html>`__,\nwhich is the standard format for specifying SATisfiability (SAT) problem instances in\n`Conjunctive Normal Form (CNF) <https://en.wikipedia.org/wiki/Conjunctive_normal_form>`__,\nwhich is a conjunction of one or more clauses, where a clause is a disjunction of one\nor more literals.\n\nThe following is an example of a CNF expressed in the DIMACS format:\n\n.. code:: text\n\n  c DIMACS CNF file with 3 satisfying assignments: 1 -2 3, -1 -2 -3, 1 2 -3.\n  p cnf 3 5\n  -1 -2 -3 0\n  1 -2 3 0\n  1 2 -3 0\n  1 -2 -3 0\n  -1 2 3 0\n\nThe first line, following the `c` character, is a comment. The second line specifies that\nthe CNF is over three boolean variables --- let us call them  :math:`x_1, x_2, x_3`, and\ncontains five clauses.  The five clauses, listed afterwards, are implicitly joined by the\nlogical `AND` operator, :math:`\\land`, while the variables in each clause, represented by\ntheir indices, are implicitly disjoined by the logical `OR` operator, :math:`lor`. The\n:math:`-` symbol preceding a boolean variable index corresponds to the logical `NOT`\noperator, :math:`lnot`. Character `0` (zero) marks the end of each clause.  Essentially,\nthe code above corresponds to the following CNF:\n\n:math:`(\\lnot x_1 \\lor \\lnot x_2 \\lor \\lnot x_3)\n\\land (x_1 \\lor \\lnot x_2 \\lor x_3)\n\\land (x_1 \\lor x_2 \\lor \\lnot x_3)\n\\land (x_1 \\lor \\lnot x_2 \\lor \\lnot x_3)\n\\land (\\lnot x_1 \\lor x_2 \\lor x_3)`.\n\n\nArgs:\n    filename: A file in DIMACS format.\n\nReturns:\n    PhaseOracle: A quantum circuit with a phase oracle.",
        "api_signature": "from_dimacs_file(cls, filename)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/phase_oracle.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "UnitaryOverlap.__init__",
        "api_description": "Args:\n    unitary1: Unitary acting on the ket vector.\n    unitary2: Unitary whose inverse operates on the bra vector.\n    prefix1: The name of the parameter vector associated to ``unitary1``,\n        if it is parameterized. Defaults to ``\"p1\"``.\n    prefix2: The name of the parameter vector associated to ``unitary2``,\n        if it is parameterized. Defaults to ``\"p2\"``.\n\nRaises:\n    CircuitError: Number of qubits in ``unitary1`` and ``unitary2`` does not match.\n    CircuitError: Inputs contain measurements and/or resets.",
        "api_signature": "__init__(self, unitary1, unitary2, prefix1, prefix2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/overlap.py"
    },
    {
        "api_name": "_check_unitary",
        "full_api_name": "_check_unitary",
        "api_description": "Check a circuit is unitary by checking if all operations are of type ``Gate``.",
        "api_signature": "_check_unitary(circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/overlap.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PhaseEstimation.__init__",
        "api_description": "Args:\n    num_evaluation_qubits: The number of evaluation qubits.\n    unitary: The unitary operation :math:`U` which will be repeated and controlled.\n    iqft: A inverse Quantum Fourier Transform, per default the inverse of\n        :class:`~qiskit.circuit.library.QFT` is used. Note that the QFT should not include\n        the usual swaps!\n    name: The name of the circuit.\n\n.. note::\n\n    The inverse QFT should not include a swap of the qubit order.\n\nReference Circuit:\n    .. plot::\n\n       from qiskit.circuit import QuantumCircuit\n       from qiskit.circuit.library import PhaseEstimation\n       from qiskit.tools.jupyter.library import _generate_circuit_library_visualization\n       unitary = QuantumCircuit(2)\n       unitary.x(0)\n       unitary.y(1)\n       circuit = PhaseEstimation(3, unitary)\n       _generate_circuit_library_visualization(circuit)",
        "api_signature": "__init__(self, num_evaluation_qubits, unitary, iqft, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/phase_estimation.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "GroverOperator.__init__",
        "api_description": "Args:\n    oracle: The phase oracle implementing a reflection about the bad state. Note that this\n        is not a bitflip oracle, see the docstring for more information.\n    state_preparation: The operator preparing the good and bad state.\n        For Grover's algorithm, this is a n-qubit Hadamard gate and for amplitude\n        amplification or estimation the operator :math:`\\mathcal{A}`.\n    zero_reflection: The reflection about the zero state, :math:`\\mathcal{S}_0`.\n    reflection_qubits: Qubits on which the zero reflection acts on.\n    insert_barriers: Whether barriers should be inserted between the reflections and A.\n    mcx_mode: The mode to use for building the default zero reflection.\n    name: The name of the circuit.",
        "api_signature": "__init__(self, oracle, state_preparation, zero_reflection, reflection_qubits, insert_barriers, mcx_mode, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/grover_operator.py"
    },
    {
        "api_name": "reflection_qubits",
        "full_api_name": "GroverOperator.reflection_qubits",
        "api_description": "Reflection qubits, on which S0 is applied (if S0 is not user-specified).",
        "api_signature": "reflection_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/grover_operator.py"
    },
    {
        "api_name": "zero_reflection",
        "full_api_name": "GroverOperator.zero_reflection",
        "api_description": "The subcircuit implementing the reflection about 0.",
        "api_signature": "zero_reflection(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/grover_operator.py"
    },
    {
        "api_name": "state_preparation",
        "full_api_name": "GroverOperator.state_preparation",
        "api_description": "The subcircuit implementing the A operator or Hadamards.",
        "api_signature": "state_preparation(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/grover_operator.py"
    },
    {
        "api_name": "oracle",
        "full_api_name": "GroverOperator.oracle",
        "api_description": "The oracle implementing a reflection about the bad state.",
        "api_signature": "oracle(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/grover_operator.py"
    },
    {
        "api_name": "_build",
        "full_api_name": "GroverOperator._build",
        "api_description": "",
        "api_signature": "_build(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/grover_operator.py"
    },
    {
        "api_name": "_zero_reflection",
        "full_api_name": "_zero_reflection",
        "api_description": "",
        "api_signature": "_zero_reflection(num_state_qubits, qubits, mcx_mode)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/grover_operator.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BlueprintCircuit.__init__",
        "api_description": "Create a new blueprint circuit.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/blueprintcircuit.py"
    },
    {
        "api_name": "_check_configuration",
        "full_api_name": "BlueprintCircuit._check_configuration",
        "api_description": "Check if the current configuration allows the circuit to be built.\n\nArgs:\n    raise_on_failure: If True, raise if the configuration is invalid. If False, return\n        False if the configuration is invalid.\n\nReturns:\n    True, if the configuration is valid. Otherwise, depending on the value of\n    ``raise_on_failure`` an error is raised or False is returned.",
        "api_signature": "_check_configuration(self, raise_on_failure)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/blueprintcircuit.py"
    },
    {
        "api_name": "_build",
        "full_api_name": "BlueprintCircuit._build",
        "api_description": "Build the circuit.",
        "api_signature": "_build(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/blueprintcircuit.py"
    },
    {
        "api_name": "_invalidate",
        "full_api_name": "BlueprintCircuit._invalidate",
        "api_description": "Invalidate the current circuit build.",
        "api_signature": "_invalidate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/blueprintcircuit.py"
    },
    {
        "api_name": "qregs",
        "full_api_name": "BlueprintCircuit.qregs",
        "api_description": "A list of the quantum registers associated with the circuit.",
        "api_signature": "qregs(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/blueprintcircuit.py"
    },
    {
        "api_name": "qregs",
        "full_api_name": "BlueprintCircuit.qregs",
        "api_description": "Set the quantum registers associated with the circuit.",
        "api_signature": "qregs(self, qregs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/blueprintcircuit.py"
    },
    {
        "api_name": "data",
        "full_api_name": "BlueprintCircuit.data",
        "api_description": "",
        "api_signature": "data(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/blueprintcircuit.py"
    },
    {
        "api_name": "decompose",
        "full_api_name": "BlueprintCircuit.decompose",
        "api_description": "",
        "api_signature": "decompose(self, gates_to_decompose, reps)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/blueprintcircuit.py"
    },
    {
        "api_name": "draw",
        "full_api_name": "BlueprintCircuit.draw",
        "api_description": "",
        "api_signature": "draw(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/blueprintcircuit.py"
    },
    {
        "api_name": "num_parameters",
        "full_api_name": "BlueprintCircuit.num_parameters",
        "api_description": "",
        "api_signature": "num_parameters(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/blueprintcircuit.py"
    },
    {
        "api_name": "parameters",
        "full_api_name": "BlueprintCircuit.parameters",
        "api_description": "",
        "api_signature": "parameters(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/blueprintcircuit.py"
    },
    {
        "api_name": "qasm",
        "full_api_name": "BlueprintCircuit.qasm",
        "api_description": "",
        "api_signature": "qasm(self, formatted, filename, encoding)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/blueprintcircuit.py"
    },
    {
        "api_name": "_append",
        "full_api_name": "BlueprintCircuit._append",
        "api_description": "",
        "api_signature": "_append(self, instruction, _qargs, _cargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/blueprintcircuit.py"
    },
    {
        "api_name": "compose",
        "full_api_name": "BlueprintCircuit.compose",
        "api_description": "",
        "api_signature": "compose(self, other, qubits, clbits, front, inplace, wrap)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/blueprintcircuit.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "BlueprintCircuit.inverse",
        "api_description": "",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/blueprintcircuit.py"
    },
    {
        "api_name": "__len__",
        "full_api_name": "BlueprintCircuit.__len__",
        "api_description": "",
        "api_signature": "__len__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/blueprintcircuit.py"
    },
    {
        "api_name": "__getitem__",
        "full_api_name": "BlueprintCircuit.__getitem__",
        "api_description": "",
        "api_signature": "__getitem__(self, item)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/blueprintcircuit.py"
    },
    {
        "api_name": "size",
        "full_api_name": "BlueprintCircuit.size",
        "api_description": "",
        "api_signature": "size(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/blueprintcircuit.py"
    },
    {
        "api_name": "to_instruction",
        "full_api_name": "BlueprintCircuit.to_instruction",
        "api_description": "",
        "api_signature": "to_instruction(self, parameter_map, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/blueprintcircuit.py"
    },
    {
        "api_name": "to_gate",
        "full_api_name": "BlueprintCircuit.to_gate",
        "api_description": "",
        "api_signature": "to_gate(self, parameter_map, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/blueprintcircuit.py"
    },
    {
        "api_name": "depth",
        "full_api_name": "BlueprintCircuit.depth",
        "api_description": "",
        "api_signature": "depth(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/blueprintcircuit.py"
    },
    {
        "api_name": "count_ops",
        "full_api_name": "BlueprintCircuit.count_ops",
        "api_description": "",
        "api_signature": "count_ops(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/blueprintcircuit.py"
    },
    {
        "api_name": "num_nonlocal_gates",
        "full_api_name": "BlueprintCircuit.num_nonlocal_gates",
        "api_description": "",
        "api_signature": "num_nonlocal_gates(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/blueprintcircuit.py"
    },
    {
        "api_name": "num_connected_components",
        "full_api_name": "BlueprintCircuit.num_connected_components",
        "api_description": "",
        "api_signature": "num_connected_components(self, unitary_only)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/blueprintcircuit.py"
    },
    {
        "api_name": "copy",
        "full_api_name": "BlueprintCircuit.copy",
        "api_description": "",
        "api_signature": "copy(self, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/blueprintcircuit.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "HamiltonianGate.__init__",
        "api_description": "Args:\n    data: A hermitian operator.\n    time: Time evolution parameter.\n    label: Unitary name for backend [Default: None].\n\nRaises:\n    ValueError: if input data is not an N-qubit unitary operator.",
        "api_signature": "__init__(self, data, time, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/hamiltonian_gate.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "HamiltonianGate.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/hamiltonian_gate.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "HamiltonianGate.__array__",
        "api_description": "Return matrix for the unitary.",
        "api_signature": "__array__(self, dtype)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/hamiltonian_gate.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "HamiltonianGate.inverse",
        "api_description": "Return the adjoint of the unitary.",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/hamiltonian_gate.py"
    },
    {
        "api_name": "conjugate",
        "full_api_name": "HamiltonianGate.conjugate",
        "api_description": "Return the conjugate of the Hamiltonian.",
        "api_signature": "conjugate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/hamiltonian_gate.py"
    },
    {
        "api_name": "adjoint",
        "full_api_name": "HamiltonianGate.adjoint",
        "api_description": "Return the adjoint of the unitary.",
        "api_signature": "adjoint(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/hamiltonian_gate.py"
    },
    {
        "api_name": "transpose",
        "full_api_name": "HamiltonianGate.transpose",
        "api_description": "Return the transpose of the Hamiltonian.",
        "api_signature": "transpose(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/hamiltonian_gate.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "HamiltonianGate._define",
        "api_description": "Calculate a subcircuit that implements this unitary.",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/hamiltonian_gate.py"
    },
    {
        "api_name": "qasm",
        "full_api_name": "HamiltonianGate.qasm",
        "api_description": "Raise an error, as QASM is not defined for the HamiltonianGate.",
        "api_signature": "qasm(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/hamiltonian_gate.py"
    },
    {
        "api_name": "validate_parameter",
        "full_api_name": "HamiltonianGate.validate_parameter",
        "api_description": "Hamiltonian parameter has to be an ndarray, operator or float.",
        "api_signature": "validate_parameter(self, parameter)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/hamiltonian_gate.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "EvolvedOperatorAnsatz.__init__",
        "api_description": "Args:\n    operators (BaseOperator | OperatorBase | QuantumCircuit | list | None): The operators\n        to evolve. If a circuit is passed, we assume it implements an already evolved\n        operator and thus the circuit is not evolved again. Can be a single operator\n        (circuit) or a list of operators (and circuits).\n    reps: The number of times to repeat the evolved operators.\n    evolution (EvolutionBase | EvolutionSynthesis | None):\n        A specification of which evolution synthesis to use for the\n        :class:`.PauliEvolutionGate`, if the operator is from :mod:`qiskit.quantum_info`\n        or an opflow converter object if the operator is from :mod:`qiskit.opflow`.\n        Defaults to first order Trotterization.\n    insert_barriers: Whether to insert barriers in between each evolution.\n    name: The name of the circuit.\n    parameter_prefix: Set the names of the circuit parameters. If a string, the same prefix\n        will be used for each parameters. Can also be a list to specify a prefix per\n        operator.\n    initial_state: A :class:`.QuantumCircuit` object to prepend to the circuit.\n    flatten: Set this to ``True`` to output a flat circuit instead of nesting it inside multiple\n        layers of gate objects. By default currently the contents of\n        the output circuit will be wrapped in nested objects for\n        cleaner visualization. However, if you're using this circuit\n        for anything besides visualization its **strongly** recommended\n        to set this flag to ``True`` to avoid a large performance\n        overhead for parameter binding.",
        "api_signature": "__init__(self, operators, reps, evolution, insert_barriers, name, parameter_prefix, initial_state, flatten)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/evolved_operator_ansatz.py"
    },
    {
        "api_name": "_check_configuration",
        "full_api_name": "EvolvedOperatorAnsatz._check_configuration",
        "api_description": "Check if the current configuration is valid.",
        "api_signature": "_check_configuration(self, raise_on_failure)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/evolved_operator_ansatz.py"
    },
    {
        "api_name": "num_qubits",
        "full_api_name": "EvolvedOperatorAnsatz.num_qubits",
        "api_description": "",
        "api_signature": "num_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/evolved_operator_ansatz.py"
    },
    {
        "api_name": "evolution",
        "full_api_name": "EvolvedOperatorAnsatz.evolution",
        "api_description": "The evolution converter used to compute the evolution.\n\nReturns:\n    EvolutionBase or EvolutionSynthesis: The evolution converter used to compute the evolution.",
        "api_signature": "evolution(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/evolved_operator_ansatz.py"
    },
    {
        "api_name": "evolution",
        "full_api_name": "EvolvedOperatorAnsatz.evolution",
        "api_description": "Sets the evolution converter used to compute the evolution.\n\nArgs:\n    evol (EvolutionBase | EvolutionSynthesis): An evolution synthesis object or\n        opflow converter object to construct the evolution.",
        "api_signature": "evolution(self, evol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/evolved_operator_ansatz.py"
    },
    {
        "api_name": "operators",
        "full_api_name": "EvolvedOperatorAnsatz.operators",
        "api_description": "The operators that are evolved in this circuit.\n\nReturns:\n    list: The operators to be evolved (and circuits) contained in this ansatz.",
        "api_signature": "operators(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/evolved_operator_ansatz.py"
    },
    {
        "api_name": "operators",
        "full_api_name": "EvolvedOperatorAnsatz.operators",
        "api_description": "Set the operators to be evolved.\n\noperators (Optional[Union[OperatorBase, QuantumCircuit, list]): The operators to evolve.\n    If a circuit is passed, we assume it implements an already evolved operator and thus\n    the circuit is not evolved again. Can be a single operator (circuit) or a list of\n    operators (and circuits).",
        "api_signature": "operators(self, operators)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/evolved_operator_ansatz.py"
    },
    {
        "api_name": "preferred_init_points",
        "full_api_name": "EvolvedOperatorAnsatz.preferred_init_points",
        "api_description": "Getter of preferred initial points based on the given initial state.",
        "api_signature": "preferred_init_points(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/evolved_operator_ansatz.py"
    },
    {
        "api_name": "_evolve_operator",
        "full_api_name": "EvolvedOperatorAnsatz._evolve_operator",
        "api_description": "",
        "api_signature": "_evolve_operator(self, operator, time)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/evolved_operator_ansatz.py"
    },
    {
        "api_name": "_build",
        "full_api_name": "EvolvedOperatorAnsatz._build",
        "api_description": "",
        "api_signature": "_build(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/evolved_operator_ansatz.py"
    },
    {
        "api_name": "_validate_operators",
        "full_api_name": "_validate_operators",
        "api_description": "",
        "api_signature": "_validate_operators(operators)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/evolved_operator_ansatz.py"
    },
    {
        "api_name": "_validate_prefix",
        "full_api_name": "_validate_prefix",
        "api_description": "",
        "api_signature": "_validate_prefix(parameter_prefix, operators)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/evolved_operator_ansatz.py"
    },
    {
        "api_name": "_is_pauli_identity",
        "full_api_name": "_is_pauli_identity",
        "api_description": "",
        "api_signature": "_is_pauli_identity(operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/evolved_operator_ansatz.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "GraphState.__init__",
        "api_description": "Create graph state preparation circuit.\n\nArgs:\n    adjacency_matrix: input graph as n-by-n list of 0-1 lists\n\nRaises:\n    CircuitError: If adjacency_matrix is not symmetric.\n\nThe circuit prepares a graph state with the given adjacency\nmatrix.",
        "api_signature": "__init__(self, adjacency_matrix)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/graph_state.py"
    },
    {
        "api_name": "clifford_8_1",
        "full_api_name": "clifford_8_1",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "clifford_8_1()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/clifford/clifford_8_1.py"
    },
    {
        "api_name": "clifford_3_1",
        "full_api_name": "clifford_3_1",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "clifford_3_1()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/clifford/clifford_3_1.py"
    },
    {
        "api_name": "clifford_6_5",
        "full_api_name": "clifford_6_5",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "clifford_6_5()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/clifford/clifford_6_5.py"
    },
    {
        "api_name": "clifford_8_3",
        "full_api_name": "clifford_8_3",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "clifford_8_3()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/clifford/clifford_8_3.py"
    },
    {
        "api_name": "clifford_6_2",
        "full_api_name": "clifford_6_2",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "clifford_6_2()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/clifford/clifford_6_2.py"
    },
    {
        "api_name": "clifford_8_2",
        "full_api_name": "clifford_8_2",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "clifford_8_2()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/clifford/clifford_8_2.py"
    },
    {
        "api_name": "clifford_6_1",
        "full_api_name": "clifford_6_1",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "clifford_6_1()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/clifford/clifford_6_1.py"
    },
    {
        "api_name": "clifford_4_4",
        "full_api_name": "clifford_4_4",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "clifford_4_4()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/clifford/clifford_4_4.py"
    },
    {
        "api_name": "clifford_2_2",
        "full_api_name": "clifford_2_2",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "clifford_2_2()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/clifford/clifford_2_2.py"
    },
    {
        "api_name": "clifford_5_1",
        "full_api_name": "clifford_5_1",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "clifford_5_1()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/clifford/clifford_5_1.py"
    },
    {
        "api_name": "clifford_4_2",
        "full_api_name": "clifford_4_2",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "clifford_4_2()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/clifford/clifford_4_2.py"
    },
    {
        "api_name": "clifford_6_4",
        "full_api_name": "clifford_6_4",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "clifford_6_4()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/clifford/clifford_6_4.py"
    },
    {
        "api_name": "clifford_2_3",
        "full_api_name": "clifford_2_3",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "clifford_2_3()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/clifford/clifford_2_3.py"
    },
    {
        "api_name": "clifford_4_3",
        "full_api_name": "clifford_4_3",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "clifford_4_3()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/clifford/clifford_4_3.py"
    },
    {
        "api_name": "clifford_2_4",
        "full_api_name": "clifford_2_4",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "clifford_2_4()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/clifford/clifford_2_4.py"
    },
    {
        "api_name": "clifford_6_3",
        "full_api_name": "clifford_6_3",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "clifford_6_3()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/clifford/clifford_6_3.py"
    },
    {
        "api_name": "clifford_4_1",
        "full_api_name": "clifford_4_1",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "clifford_4_1()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/clifford/clifford_4_1.py"
    },
    {
        "api_name": "clifford_2_1",
        "full_api_name": "clifford_2_1",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "clifford_2_1()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/clifford/clifford_2_1.py"
    },
    {
        "api_name": "rzx_cy",
        "full_api_name": "rzx_cy",
        "api_description": "Template for CX - RYGate - CX.",
        "api_signature": "rzx_cy(theta)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/rzx/rzx_cy.py"
    },
    {
        "api_name": "rzx_zz2",
        "full_api_name": "rzx_zz2",
        "api_description": "Template for CX - RZGate - CX.",
        "api_signature": "rzx_zz2(theta)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/rzx/rzx_zz2.py"
    },
    {
        "api_name": "rzx_xz",
        "full_api_name": "rzx_xz",
        "api_description": "Template for CX - RXGate - CX.",
        "api_signature": "rzx_xz(theta)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/rzx/rzx_xz.py"
    },
    {
        "api_name": "rzx_zz3",
        "full_api_name": "rzx_zz3",
        "api_description": "Template for CX - RZGate - CX.",
        "api_signature": "rzx_zz3(theta)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/rzx/rzx_zz3.py"
    },
    {
        "api_name": "rzx_zz1",
        "full_api_name": "rzx_zz1",
        "api_description": "Template for CX - RZGate - CX.",
        "api_signature": "rzx_zz1(theta)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/rzx/rzx_zz1.py"
    },
    {
        "api_name": "rzx_yz",
        "full_api_name": "rzx_yz",
        "api_description": "Template for CX - RYGate - CX.",
        "api_signature": "rzx_yz(theta)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/rzx/rzx_yz.py"
    },
    {
        "api_name": "template_nct_9c_6",
        "full_api_name": "template_nct_9c_6",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_9c_6()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_9c_6.py"
    },
    {
        "api_name": "template_nct_9c_1",
        "full_api_name": "template_nct_9c_1",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_9c_1()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_9c_1.py"
    },
    {
        "api_name": "template_nct_9d_5",
        "full_api_name": "template_nct_9d_5",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_9d_5()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_9d_5.py"
    },
    {
        "api_name": "template_nct_4b_1",
        "full_api_name": "template_nct_4b_1",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_4b_1()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_4b_1.py"
    },
    {
        "api_name": "template_nct_9d_8",
        "full_api_name": "template_nct_9d_8",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_9d_8()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_9d_8.py"
    },
    {
        "api_name": "template_nct_9c_11",
        "full_api_name": "template_nct_9c_11",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_9c_11()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_9c_11.py"
    },
    {
        "api_name": "template_nct_6b_1",
        "full_api_name": "template_nct_6b_1",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_6b_1()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_6b_1.py"
    },
    {
        "api_name": "template_nct_5a_2",
        "full_api_name": "template_nct_5a_2",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_5a_2()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_5a_2.py"
    },
    {
        "api_name": "template_nct_6a_3",
        "full_api_name": "template_nct_6a_3",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_6a_3()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_6a_3.py"
    },
    {
        "api_name": "template_nct_5a_4",
        "full_api_name": "template_nct_5a_4",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_5a_4()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_5a_4.py"
    },
    {
        "api_name": "template_nct_9d_9",
        "full_api_name": "template_nct_9d_9",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_9d_9()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_9d_9.py"
    },
    {
        "api_name": "template_nct_2a_3",
        "full_api_name": "template_nct_2a_3",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_2a_3()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_2a_3.py"
    },
    {
        "api_name": "template_nct_9d_1",
        "full_api_name": "template_nct_9d_1",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_9d_1()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_9d_1.py"
    },
    {
        "api_name": "template_nct_9c_5",
        "full_api_name": "template_nct_9c_5",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_9c_5()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_9c_5.py"
    },
    {
        "api_name": "template_nct_6a_4",
        "full_api_name": "template_nct_6a_4",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_6a_4()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_6a_4.py"
    },
    {
        "api_name": "template_nct_6a_1",
        "full_api_name": "template_nct_6a_1",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_6a_1()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_6a_1.py"
    },
    {
        "api_name": "template_nct_7a_1",
        "full_api_name": "template_nct_7a_1",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_7a_1()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_7a_1.py"
    },
    {
        "api_name": "template_nct_9c_12",
        "full_api_name": "template_nct_9c_12",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_9c_12()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_9c_12.py"
    },
    {
        "api_name": "template_nct_9c_7",
        "full_api_name": "template_nct_9c_7",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_9c_7()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_9c_7.py"
    },
    {
        "api_name": "template_nct_7c_1",
        "full_api_name": "template_nct_7c_1",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_7c_1()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_7c_1.py"
    },
    {
        "api_name": "template_nct_6c_1",
        "full_api_name": "template_nct_6c_1",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_6c_1()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_6c_1.py"
    },
    {
        "api_name": "template_nct_4b_2",
        "full_api_name": "template_nct_4b_2",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_4b_2()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_4b_2.py"
    },
    {
        "api_name": "template_nct_2a_1",
        "full_api_name": "template_nct_2a_1",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_2a_1()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_2a_1.py"
    },
    {
        "api_name": "template_nct_5a_3",
        "full_api_name": "template_nct_5a_3",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_5a_3()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_5a_3.py"
    },
    {
        "api_name": "template_nct_9c_9",
        "full_api_name": "template_nct_9c_9",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_9c_9()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_9c_9.py"
    },
    {
        "api_name": "template_nct_9d_4",
        "full_api_name": "template_nct_9d_4",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_9d_4()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_9d_4.py"
    },
    {
        "api_name": "template_nct_9c_10",
        "full_api_name": "template_nct_9c_10",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_9c_10()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_9c_10.py"
    },
    {
        "api_name": "template_nct_9a_1",
        "full_api_name": "template_nct_9a_1",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_9a_1()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_9a_1.py"
    },
    {
        "api_name": "template_nct_9c_3",
        "full_api_name": "template_nct_9c_3",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_9c_3()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_9c_3.py"
    },
    {
        "api_name": "template_nct_6a_2",
        "full_api_name": "template_nct_6a_2",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_6a_2()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_6a_2.py"
    },
    {
        "api_name": "template_nct_9d_10",
        "full_api_name": "template_nct_9d_10",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_9d_10()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_9d_10.py"
    },
    {
        "api_name": "template_nct_4a_3",
        "full_api_name": "template_nct_4a_3",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_4a_3()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_4a_3.py"
    },
    {
        "api_name": "template_nct_9d_2",
        "full_api_name": "template_nct_9d_2",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_9d_2()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_9d_2.py"
    },
    {
        "api_name": "template_nct_9c_4",
        "full_api_name": "template_nct_9c_4",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_9c_4()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_9c_4.py"
    },
    {
        "api_name": "template_nct_9d_3",
        "full_api_name": "template_nct_9d_3",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_9d_3()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_9d_3.py"
    },
    {
        "api_name": "template_nct_4a_1",
        "full_api_name": "template_nct_4a_1",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_4a_1()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_4a_1.py"
    },
    {
        "api_name": "template_nct_4a_2",
        "full_api_name": "template_nct_4a_2",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_4a_2()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_4a_2.py"
    },
    {
        "api_name": "template_nct_5a_1",
        "full_api_name": "template_nct_5a_1",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_5a_1()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_5a_1.py"
    },
    {
        "api_name": "template_nct_9c_8",
        "full_api_name": "template_nct_9c_8",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_9c_8()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_9c_8.py"
    },
    {
        "api_name": "template_nct_6b_2",
        "full_api_name": "template_nct_6b_2",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_6b_2()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_6b_2.py"
    },
    {
        "api_name": "template_nct_7d_1",
        "full_api_name": "template_nct_7d_1",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_7d_1()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_7d_1.py"
    },
    {
        "api_name": "template_nct_7b_1",
        "full_api_name": "template_nct_7b_1",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_7b_1()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_7b_1.py"
    },
    {
        "api_name": "template_nct_9d_6",
        "full_api_name": "template_nct_9d_6",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_9d_6()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_9d_6.py"
    },
    {
        "api_name": "template_nct_9d_7",
        "full_api_name": "template_nct_9d_7",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_9d_7()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_9d_7.py"
    },
    {
        "api_name": "template_nct_7e_1",
        "full_api_name": "template_nct_7e_1",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_7e_1()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_7e_1.py"
    },
    {
        "api_name": "template_nct_2a_2",
        "full_api_name": "template_nct_2a_2",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_2a_2()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_2a_2.py"
    },
    {
        "api_name": "template_nct_9c_2",
        "full_api_name": "template_nct_9c_2",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_9c_2()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_9c_2.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PiecewiseLinearPauliRotations.__init__",
        "api_description": "Construct piecewise-linearly-controlled Pauli rotations.\n\nArgs:\n    num_state_qubits: The number of qubits representing the state.\n    breakpoints: The breakpoints to define the piecewise-linear function.\n        Defaults to ``[0]``.\n    slopes: The slopes for different segments of the piecewise-linear function.\n        Defaults to ``[1]``.\n    offsets: The offsets for different segments of the piecewise-linear function.\n        Defaults to ``[0]``.\n    basis: The type of Pauli rotation (``'X'``, ``'Y'``, ``'Z'``).\n    name: The name of the circuit.",
        "api_signature": "__init__(self, num_state_qubits, breakpoints, slopes, offsets, basis, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_linear_pauli_rotations.py"
    },
    {
        "api_name": "breakpoints",
        "full_api_name": "PiecewiseLinearPauliRotations.breakpoints",
        "api_description": "The breakpoints of the piecewise linear function.\n\nThe function is linear in the intervals ``[point_i, point_{i+1}]`` where the last\npoint implicitly is ``2**(num_state_qubits + 1)``.",
        "api_signature": "breakpoints(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_linear_pauli_rotations.py"
    },
    {
        "api_name": "breakpoints",
        "full_api_name": "PiecewiseLinearPauliRotations.breakpoints",
        "api_description": "Set the breakpoints.\n\nArgs:\n    breakpoints: The new breakpoints.",
        "api_signature": "breakpoints(self, breakpoints)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_linear_pauli_rotations.py"
    },
    {
        "api_name": "slopes",
        "full_api_name": "PiecewiseLinearPauliRotations.slopes",
        "api_description": "The breakpoints of the piecewise linear function.\n\nThe function is linear in the intervals ``[point_i, point_{i+1}]`` where the last\npoint implicitly is ``2**(num_state_qubits + 1)``.",
        "api_signature": "slopes(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_linear_pauli_rotations.py"
    },
    {
        "api_name": "slopes",
        "full_api_name": "PiecewiseLinearPauliRotations.slopes",
        "api_description": "Set the slopes.\n\nArgs:\n    slopes: The new slopes.",
        "api_signature": "slopes(self, slopes)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_linear_pauli_rotations.py"
    },
    {
        "api_name": "offsets",
        "full_api_name": "PiecewiseLinearPauliRotations.offsets",
        "api_description": "The breakpoints of the piecewise linear function.\n\nThe function is linear in the intervals ``[point_i, point_{i+1}]`` where the last\npoint implicitly is ``2**(num_state_qubits + 1)``.",
        "api_signature": "offsets(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_linear_pauli_rotations.py"
    },
    {
        "api_name": "offsets",
        "full_api_name": "PiecewiseLinearPauliRotations.offsets",
        "api_description": "Set the offsets.\n\nArgs:\n    offsets: The new offsets.",
        "api_signature": "offsets(self, offsets)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_linear_pauli_rotations.py"
    },
    {
        "api_name": "mapped_slopes",
        "full_api_name": "PiecewiseLinearPauliRotations.mapped_slopes",
        "api_description": "The slopes mapped to the internal representation.\n\nReturns:\n    The mapped slopes.",
        "api_signature": "mapped_slopes(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_linear_pauli_rotations.py"
    },
    {
        "api_name": "mapped_offsets",
        "full_api_name": "PiecewiseLinearPauliRotations.mapped_offsets",
        "api_description": "The offsets mapped to the internal representation.\n\nReturns:\n    The mapped offsets.",
        "api_signature": "mapped_offsets(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_linear_pauli_rotations.py"
    },
    {
        "api_name": "contains_zero_breakpoint",
        "full_api_name": "PiecewiseLinearPauliRotations.contains_zero_breakpoint",
        "api_description": "Whether 0 is the first breakpoint.\n\nReturns:\n    True, if 0 is the first breakpoint, otherwise False.",
        "api_signature": "contains_zero_breakpoint(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_linear_pauli_rotations.py"
    },
    {
        "api_name": "evaluate",
        "full_api_name": "PiecewiseLinearPauliRotations.evaluate",
        "api_description": "Classically evaluate the piecewise linear rotation.\n\nArgs:\n    x: Value to be evaluated at.\n\nReturns:\n    Value of piecewise linear function at x.",
        "api_signature": "evaluate(self, x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_linear_pauli_rotations.py"
    },
    {
        "api_name": "_check_configuration",
        "full_api_name": "PiecewiseLinearPauliRotations._check_configuration",
        "api_description": "Check if the current configuration is valid.",
        "api_signature": "_check_configuration(self, raise_on_failure)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_linear_pauli_rotations.py"
    },
    {
        "api_name": "_reset_registers",
        "full_api_name": "PiecewiseLinearPauliRotations._reset_registers",
        "api_description": "Reset the registers.",
        "api_signature": "_reset_registers(self, num_state_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_linear_pauli_rotations.py"
    },
    {
        "api_name": "_build",
        "full_api_name": "PiecewiseLinearPauliRotations._build",
        "api_description": "If not already built, build the circuit.",
        "api_signature": "_build(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_linear_pauli_rotations.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QuadraticForm.__init__",
        "api_description": "Args:\n    num_result_qubits: The number of qubits to encode the result. Called :math:`m` in\n        the class documentation.\n    quadratic: A matrix containing the quadratic coefficients, :math:`A`.\n    linear: An array containing the linear coefficients, :math:`b`.\n    offset: A constant offset, :math:`c`.\n    little_endian: Encode the result in little endianness.\n\nRaises:\n    ValueError: If ``linear`` and ``quadratic`` have mismatching sizes.\n    ValueError: If ``num_result_qubits`` is unspecified but cannot be determined because\n        some values of the quadratic form are parameterized.",
        "api_signature": "__init__(self, num_result_qubits, quadratic, linear, offset, little_endian)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/quadratic_form.py"
    },
    {
        "api_name": "required_result_qubits",
        "full_api_name": "QuadraticForm.required_result_qubits",
        "api_description": "Get the number of required result qubits.\n\nArgs:\n    quadratic: A matrix containing the quadratic coefficients.\n    linear: An array containing the linear coefficients.\n    offset: A constant offset.\n\nReturns:\n    The number of qubits needed to represent the value of the quadratic form\n    in twos complement.",
        "api_signature": "required_result_qubits(quadratic, linear, offset)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/quadratic_form.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "LinearPauliRotations.__init__",
        "api_description": "Create a new linear rotation circuit.\n\nArgs:\n    num_state_qubits: The number of qubits representing the state :math:`|x\\rangle`.\n    slope: The slope of the controlled rotation.\n    offset: The offset of the controlled rotation.\n    basis: The type of Pauli rotation ('X', 'Y', 'Z').\n    name: The name of the circuit object.",
        "api_signature": "__init__(self, num_state_qubits, slope, offset, basis, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/linear_pauli_rotations.py"
    },
    {
        "api_name": "slope",
        "full_api_name": "LinearPauliRotations.slope",
        "api_description": "The multiplicative factor in the rotation angle of the controlled rotations.\n\nThe rotation angles are ``slope * 2^0``, ``slope * 2^1``, ... , ``slope * 2^(n-1)`` where\n``n`` is the number of state qubits.\n\nReturns:\n    The rotation angle common in all controlled rotations.",
        "api_signature": "slope(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/linear_pauli_rotations.py"
    },
    {
        "api_name": "slope",
        "full_api_name": "LinearPauliRotations.slope",
        "api_description": "Set the multiplicative factor of the rotation angles.\n\nArgs:\n    The slope of the rotation angles.",
        "api_signature": "slope(self, slope)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/linear_pauli_rotations.py"
    },
    {
        "api_name": "offset",
        "full_api_name": "LinearPauliRotations.offset",
        "api_description": "The angle of the single qubit offset rotation on the target qubit.\n\nBefore applying the controlled rotations, a single rotation of angle ``offset`` is\napplied to the target qubit.\n\nReturns:\n    The offset angle.",
        "api_signature": "offset(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/linear_pauli_rotations.py"
    },
    {
        "api_name": "offset",
        "full_api_name": "LinearPauliRotations.offset",
        "api_description": "Set the angle for the offset rotation on the target qubit.\n\nArgs:\n    offset: The offset rotation angle.",
        "api_signature": "offset(self, offset)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/linear_pauli_rotations.py"
    },
    {
        "api_name": "_reset_registers",
        "full_api_name": "LinearPauliRotations._reset_registers",
        "api_description": "Set the number of state qubits.\n\nNote that this changes the underlying quantum register, if the number of state qubits\nchanges.\n\nArgs:\n    num_state_qubits: The new number of qubits.",
        "api_signature": "_reset_registers(self, num_state_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/linear_pauli_rotations.py"
    },
    {
        "api_name": "_check_configuration",
        "full_api_name": "LinearPauliRotations._check_configuration",
        "api_description": "Check if the current configuration is valid.",
        "api_signature": "_check_configuration(self, raise_on_failure)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/linear_pauli_rotations.py"
    },
    {
        "api_name": "_build",
        "full_api_name": "LinearPauliRotations._build",
        "api_description": "If not already built, build the circuit.",
        "api_signature": "_build(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/linear_pauli_rotations.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "LinearAmplitudeFunction.__init__",
        "api_description": "Args:\n    num_state_qubits: The number of qubits used to encode the variable :math:`x`.\n    slope: The slope of the linear function. Can be a list of slopes if it is a piecewise\n        linear function.\n    offset: The offset of the linear function. Can be a list of offsets if it is a piecewise\n        linear function.\n    domain: The domain of the function as tuple :math:`(x_\\min{}, x_\\max{})`.\n    image: The image of the function as tuple :math:`(f_\\min{}, f_\\max{})`.\n    rescaling_factor: The rescaling factor to adjust the accuracy in the Taylor\n        approximation.\n    breakpoints: The breakpoints if the function is piecewise linear. If None, the function\n        is not piecewise.\n    name: Name of the circuit.",
        "api_signature": "__init__(self, num_state_qubits, slope, offset, domain, image, rescaling_factor, breakpoints, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/linear_amplitude_function.py"
    },
    {
        "api_name": "post_processing",
        "full_api_name": "LinearAmplitudeFunction.post_processing",
        "api_description": "Map the function value of the approximated :math:`\\hat{f}` to :math:`f`.\n\nArgs:\n    scaled_value: A function value from the Taylor expansion of :math:`\\hat{f}(x)`.\n\nReturns:\n    The ``scaled_value`` mapped back to the domain of :math:`f`, by first inverting\n    the transformation used for the Taylor approximation and then mapping back from\n    :math:`[0, 1]` to the original domain.",
        "api_signature": "post_processing(self, scaled_value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/linear_amplitude_function.py"
    },
    {
        "api_name": "_check_sorted_and_in_range",
        "full_api_name": "_check_sorted_and_in_range",
        "api_description": "",
        "api_signature": "_check_sorted_and_in_range(breakpoints, domain)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/linear_amplitude_function.py"
    },
    {
        "api_name": "_check_sizes_match",
        "full_api_name": "_check_sizes_match",
        "api_description": "",
        "api_signature": "_check_sizes_match(slope, offset, breakpoints)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/linear_amplitude_function.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PiecewisePolynomialPauliRotations.__init__",
        "api_description": "Args:\n    num_state_qubits: The number of qubits representing the state.\n    breakpoints: The breakpoints to define the piecewise-linear function.\n        Defaults to ``[0]``.\n    coeffs: The coefficients of the polynomials for different segments of the\n    piecewise-linear function. ``coeffs[j][i]`` is the coefficient of the i-th power of x\n    for the j-th polynomial.\n        Defaults to linear: ``[[1]]``.\n    basis: The type of Pauli rotation (``'X'``, ``'Y'``, ``'Z'``).\n    name: The name of the circuit.",
        "api_signature": "__init__(self, num_state_qubits, breakpoints, coeffs, basis, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_polynomial_pauli_rotations.py"
    },
    {
        "api_name": "breakpoints",
        "full_api_name": "PiecewisePolynomialPauliRotations.breakpoints",
        "api_description": "The breakpoints of the piecewise polynomial function.\n\nThe function is polynomial in the intervals ``[point_i, point_{i+1}]`` where the last\npoint implicitly is ``2**(num_state_qubits + 1)``.\n\nReturns:\n    The list of breakpoints.",
        "api_signature": "breakpoints(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_polynomial_pauli_rotations.py"
    },
    {
        "api_name": "breakpoints",
        "full_api_name": "PiecewisePolynomialPauliRotations.breakpoints",
        "api_description": "Set the breakpoints.\n\nArgs:\n    breakpoints: The new breakpoints.",
        "api_signature": "breakpoints(self, breakpoints)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_polynomial_pauli_rotations.py"
    },
    {
        "api_name": "coeffs",
        "full_api_name": "PiecewisePolynomialPauliRotations.coeffs",
        "api_description": "The coefficients of the polynomials.\n\nReturns:\n    The polynomial coefficients per interval as nested lists.",
        "api_signature": "coeffs(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_polynomial_pauli_rotations.py"
    },
    {
        "api_name": "coeffs",
        "full_api_name": "PiecewisePolynomialPauliRotations.coeffs",
        "api_description": "Set the polynomials.\n\nArgs:\n    coeffs: The new polynomials.",
        "api_signature": "coeffs(self, coeffs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_polynomial_pauli_rotations.py"
    },
    {
        "api_name": "mapped_coeffs",
        "full_api_name": "PiecewisePolynomialPauliRotations.mapped_coeffs",
        "api_description": "The coefficients mapped to the internal representation, since we only compare\nx>=breakpoint.\n\nReturns:\n    The mapped coefficients.",
        "api_signature": "mapped_coeffs(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_polynomial_pauli_rotations.py"
    },
    {
        "api_name": "contains_zero_breakpoint",
        "full_api_name": "PiecewisePolynomialPauliRotations.contains_zero_breakpoint",
        "api_description": "Whether 0 is the first breakpoint.\n\nReturns:\n    True, if 0 is the first breakpoint, otherwise False.",
        "api_signature": "contains_zero_breakpoint(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_polynomial_pauli_rotations.py"
    },
    {
        "api_name": "evaluate",
        "full_api_name": "PiecewisePolynomialPauliRotations.evaluate",
        "api_description": "Classically evaluate the piecewise polynomial rotation.\n\nArgs:\n    x: Value to be evaluated at.\n\nReturns:\n    Value of piecewise polynomial function at x.",
        "api_signature": "evaluate(self, x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_polynomial_pauli_rotations.py"
    },
    {
        "api_name": "_check_configuration",
        "full_api_name": "PiecewisePolynomialPauliRotations._check_configuration",
        "api_description": "Check if the current configuration is valid.",
        "api_signature": "_check_configuration(self, raise_on_failure)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_polynomial_pauli_rotations.py"
    },
    {
        "api_name": "_reset_registers",
        "full_api_name": "PiecewisePolynomialPauliRotations._reset_registers",
        "api_description": "Reset the registers.",
        "api_signature": "_reset_registers(self, num_state_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_polynomial_pauli_rotations.py"
    },
    {
        "api_name": "_build",
        "full_api_name": "PiecewisePolynomialPauliRotations._build",
        "api_description": "If not already built, build the circuit.",
        "api_signature": "_build(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_polynomial_pauli_rotations.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PiecewiseChebyshev.__init__",
        "api_description": "Args:\n    f_x: the function to be approximated. Constant functions should be specified\n     as f_x = constant.\n    degree: the degree of the polynomials.\n        Defaults to ``1``.\n    breakpoints: the breakpoints to define the piecewise-linear function.\n        Defaults to the full interval.\n    num_state_qubits: number of qubits representing the state.\n    name: The name of the circuit object.",
        "api_signature": "__init__(self, f_x, degree, breakpoints, num_state_qubits, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_chebyshev.py"
    },
    {
        "api_name": "_check_configuration",
        "full_api_name": "PiecewiseChebyshev._check_configuration",
        "api_description": "Check if the current configuration is valid.",
        "api_signature": "_check_configuration(self, raise_on_failure)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_chebyshev.py"
    },
    {
        "api_name": "f_x",
        "full_api_name": "PiecewiseChebyshev.f_x",
        "api_description": "The function to be approximated.\n\nReturns:\n    The function to be approximated.",
        "api_signature": "f_x(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_chebyshev.py"
    },
    {
        "api_name": "f_x",
        "full_api_name": "PiecewiseChebyshev.f_x",
        "api_description": "Set the function to be approximated.\n\nNote that this may change the underlying quantum register, if the number of state qubits\nchanges.\n\nArgs:\n    f_x: The new function to be approximated.",
        "api_signature": "f_x(self, f_x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_chebyshev.py"
    },
    {
        "api_name": "degree",
        "full_api_name": "PiecewiseChebyshev.degree",
        "api_description": "The degree of the polynomials.\n\nReturns:\n    The degree of the polynomials.",
        "api_signature": "degree(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_chebyshev.py"
    },
    {
        "api_name": "degree",
        "full_api_name": "PiecewiseChebyshev.degree",
        "api_description": "Set the error tolerance.\n\nNote that this may change the underlying quantum register, if the number of state qubits\nchanges.\n\nArgs:\n    degree: The new degree.",
        "api_signature": "degree(self, degree)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_chebyshev.py"
    },
    {
        "api_name": "breakpoints",
        "full_api_name": "PiecewiseChebyshev.breakpoints",
        "api_description": "The breakpoints for the piecewise approximation.\n\nReturns:\n    The breakpoints for the piecewise approximation.",
        "api_signature": "breakpoints(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_chebyshev.py"
    },
    {
        "api_name": "breakpoints",
        "full_api_name": "PiecewiseChebyshev.breakpoints",
        "api_description": "Set the breakpoints for the piecewise approximation.\n\nNote that this may change the underlying quantum register, if the number of state qubits\nchanges.\n\nArgs:\n    breakpoints: The new breakpoints for the piecewise approximation.",
        "api_signature": "breakpoints(self, breakpoints)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_chebyshev.py"
    },
    {
        "api_name": "polynomials",
        "full_api_name": "PiecewiseChebyshev.polynomials",
        "api_description": "The polynomials for the piecewise approximation.\n\nReturns:\n    The polynomials for the piecewise approximation.\n\nRaises:\n    TypeError: If the input function is not in the correct format.",
        "api_signature": "polynomials(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_chebyshev.py"
    },
    {
        "api_name": "polynomials",
        "full_api_name": "PiecewiseChebyshev.polynomials",
        "api_description": "Set the polynomials for the piecewise approximation.\n\nNote that this may change the underlying quantum register, if the number of state qubits\nchanges.\n\nArgs:\n    polynomials: The new breakpoints for the piecewise approximation.",
        "api_signature": "polynomials(self, polynomials)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_chebyshev.py"
    },
    {
        "api_name": "num_state_qubits",
        "full_api_name": "PiecewiseChebyshev.num_state_qubits",
        "api_description": "The number of state qubits representing the state :math:`|x\\rangle`.\n\nReturns:\n    The number of state qubits.",
        "api_signature": "num_state_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_chebyshev.py"
    },
    {
        "api_name": "num_state_qubits",
        "full_api_name": "PiecewiseChebyshev.num_state_qubits",
        "api_description": "Set the number of state qubits.\n\nNote that this may change the underlying quantum register, if the number of state qubits\nchanges.\n\nArgs:\n    num_state_qubits: The new number of qubits.",
        "api_signature": "num_state_qubits(self, num_state_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_chebyshev.py"
    },
    {
        "api_name": "_reset_registers",
        "full_api_name": "PiecewiseChebyshev._reset_registers",
        "api_description": "Reset the registers.",
        "api_signature": "_reset_registers(self, num_state_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_chebyshev.py"
    },
    {
        "api_name": "_build",
        "full_api_name": "PiecewiseChebyshev._build",
        "api_description": "Build the circuit if not already build. The operation is considered successful\nwhen q_objective is :math:`|1>`",
        "api_signature": "_build(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_chebyshev.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ExactReciprocal.__init__",
        "api_description": "Args:\n    num_state_qubits: The number of qubits representing the value to invert.\n    scaling: Scaling factor :math:`s` of the reciprocal function, i.e. to compute\n        :math:`s / x`.\n    neg_vals: Whether :math:`x` might represent negative values. In this case the first\n        qubit is the sign, with :math:`|1\\rangle` for negative and :math:`|0\\rangle` for\n        positive.  For the negative case it is assumed that the remaining string represents\n        :math:`1 - x`. This is because :math:`e^{-2 \\pi i x} = e^{2 \\pi i (1 - x)}` for\n        :math:`x \\in [0,1)`.\n    name: The name of the object.\n\n.. note::\n\n    It is assumed that the binary string :math:`x` represents a number < 1.",
        "api_signature": "__init__(self, num_state_qubits, scaling, neg_vals, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/exact_reciprocal.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "WeightedAdder.__init__",
        "api_description": "Computes the weighted sum controlled by state qubits.\n\nArgs:\n    num_state_qubits: The number of state qubits.\n    weights: List of weights, one for each state qubit. If none are provided they\n        default to 1 for every qubit.\n    name: The name of the circuit.",
        "api_signature": "__init__(self, num_state_qubits, weights, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/weighted_adder.py"
    },
    {
        "api_name": "num_sum_qubits",
        "full_api_name": "WeightedAdder.num_sum_qubits",
        "api_description": "The number of sum qubits in the circuit.\n\nReturns:\n    The number of qubits needed to represent the weighted sum of the qubits.",
        "api_signature": "num_sum_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/weighted_adder.py"
    },
    {
        "api_name": "weights",
        "full_api_name": "WeightedAdder.weights",
        "api_description": "The weights for the qubit states.\n\nReturns:\n    The weight for the qubit states.",
        "api_signature": "weights(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/weighted_adder.py"
    },
    {
        "api_name": "weights",
        "full_api_name": "WeightedAdder.weights",
        "api_description": "Set the weights for summing the qubit states.\n\nArgs:\n    weights: The new weights.\n\nRaises:\n    ValueError: If not all weights are close to an integer.",
        "api_signature": "weights(self, weights)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/weighted_adder.py"
    },
    {
        "api_name": "num_state_qubits",
        "full_api_name": "WeightedAdder.num_state_qubits",
        "api_description": "The number of qubits to be summed.\n\nReturns:\n    The number of state qubits.",
        "api_signature": "num_state_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/weighted_adder.py"
    },
    {
        "api_name": "num_state_qubits",
        "full_api_name": "WeightedAdder.num_state_qubits",
        "api_description": "Set the number of state qubits.\n\nArgs:\n    num_state_qubits: The new number of state qubits.",
        "api_signature": "num_state_qubits(self, num_state_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/weighted_adder.py"
    },
    {
        "api_name": "_reset_registers",
        "full_api_name": "WeightedAdder._reset_registers",
        "api_description": "Reset the registers.",
        "api_signature": "_reset_registers(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/weighted_adder.py"
    },
    {
        "api_name": "num_carry_qubits",
        "full_api_name": "WeightedAdder.num_carry_qubits",
        "api_description": "The number of carry qubits required to compute the sum.\n\nNote that this is not necessarily equal to the number of ancilla qubits, these can\nbe queried using ``num_ancilla_qubits``.\n\nReturns:\n    The number of carry qubits required to compute the sum.",
        "api_signature": "num_carry_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/weighted_adder.py"
    },
    {
        "api_name": "num_control_qubits",
        "full_api_name": "WeightedAdder.num_control_qubits",
        "api_description": "The number of additional control qubits required.\n\nNote that the total number of ancilla qubits can be obtained by calling the\nmethod ``num_ancilla_qubits``.\n\nReturns:\n    The number of additional control qubits required (0 or 1).",
        "api_signature": "num_control_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/weighted_adder.py"
    },
    {
        "api_name": "_check_configuration",
        "full_api_name": "WeightedAdder._check_configuration",
        "api_description": "Check if the current configuration is valid.",
        "api_signature": "_check_configuration(self, raise_on_failure)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/weighted_adder.py"
    },
    {
        "api_name": "_build",
        "full_api_name": "WeightedAdder._build",
        "api_description": "If not already built, build the circuit.",
        "api_signature": "_build(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/weighted_adder.py"
    },
    {
        "api_name": "_binomial_coefficients",
        "full_api_name": "_binomial_coefficients",
        "api_description": "Return a dictionary of binomial coefficients\n\nBased-on/forked from sympy's binomial_coefficients() function [#]\n\n.. [#] https://github.com/sympy/sympy/blob/sympy-1.5.1/sympy/ntheory/multinomial.py",
        "api_signature": "_binomial_coefficients(n)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/polynomial_pauli_rotations.py"
    },
    {
        "api_name": "_large_coefficients_iter",
        "full_api_name": "_large_coefficients_iter",
        "api_description": "Return an iterator of multinomial coefficients\n\nBased-on/forked from sympy's multinomial_coefficients_iterator() function [#]\n\n.. [#] https://github.com/sympy/sympy/blob/sympy-1.5.1/sympy/ntheory/multinomial.py",
        "api_signature": "_large_coefficients_iter(m, n)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/polynomial_pauli_rotations.py"
    },
    {
        "api_name": "_multinomial_coefficients",
        "full_api_name": "_multinomial_coefficients",
        "api_description": "Return an iterator of multinomial coefficients\n\nBased-on/forked from sympy's multinomial_coefficients() function [#]\n\n.. [#] https://github.com/sympy/sympy/blob/sympy-1.5.1/sympy/ntheory/multinomial.py",
        "api_signature": "_multinomial_coefficients(m, n)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/polynomial_pauli_rotations.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PolynomialPauliRotations.__init__",
        "api_description": "Prepare an approximation to a state with amplitudes specified by a polynomial.\n\nArgs:\n    num_state_qubits: The number of qubits representing the state.\n    coeffs: The coefficients of the polynomial. ``coeffs[i]`` is the coefficient of the\n        i-th power of x. Defaults to linear: [0, 1].\n    basis: The type of Pauli rotation ('X', 'Y', 'Z').\n    name: The name of the circuit.",
        "api_signature": "__init__(self, num_state_qubits, coeffs, basis, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/polynomial_pauli_rotations.py"
    },
    {
        "api_name": "coeffs",
        "full_api_name": "PolynomialPauliRotations.coeffs",
        "api_description": "The coefficients of the polynomial.\n\n``coeffs[i]`` is the coefficient of the i-th power of the function input :math:`x`,\nthat means that the rotation angles are based on the coefficients value,\nfollowing the formula\n\n.. math::\n\n    c_j x^j ,  j=0, ..., d\n\nwhere :math:`d` is the degree of the polynomial :math:`p(x)` and :math:`c` are the coefficients\n``coeffs``.\n\nReturns:\n    The coefficients of the polynomial.",
        "api_signature": "coeffs(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/polynomial_pauli_rotations.py"
    },
    {
        "api_name": "coeffs",
        "full_api_name": "PolynomialPauliRotations.coeffs",
        "api_description": "Set the coefficients of the polynomial.\n\n``coeffs[i]`` is the coefficient of the i-th power of x.\n\nArgs:\n    The coefficients of the polynomial.",
        "api_signature": "coeffs(self, coeffs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/polynomial_pauli_rotations.py"
    },
    {
        "api_name": "degree",
        "full_api_name": "PolynomialPauliRotations.degree",
        "api_description": "Return the degree of the polynomial, equals to the number of coefficients minus 1.\n\nReturns:\n    The degree of the polynomial. If the coefficients have not been set, return 0.",
        "api_signature": "degree(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/polynomial_pauli_rotations.py"
    },
    {
        "api_name": "_reset_registers",
        "full_api_name": "PolynomialPauliRotations._reset_registers",
        "api_description": "Reset the registers.",
        "api_signature": "_reset_registers(self, num_state_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/polynomial_pauli_rotations.py"
    },
    {
        "api_name": "_check_configuration",
        "full_api_name": "PolynomialPauliRotations._check_configuration",
        "api_description": "Check if the current configuration is valid.",
        "api_signature": "_check_configuration(self, raise_on_failure)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/polynomial_pauli_rotations.py"
    },
    {
        "api_name": "_get_rotation_coefficients",
        "full_api_name": "PolynomialPauliRotations._get_rotation_coefficients",
        "api_description": "Compute the coefficient of each monomial.\n\nReturns:\n    A dictionary with pairs ``{control_state: rotation angle}`` where ``control_state``\n    is a tuple of ``0`` or ``1`` bits.",
        "api_signature": "_get_rotation_coefficients(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/polynomial_pauli_rotations.py"
    },
    {
        "api_name": "_build",
        "full_api_name": "PolynomialPauliRotations._build",
        "api_description": "If not already built, build the circuit.",
        "api_signature": "_build(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/polynomial_pauli_rotations.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "IntegerComparator.__init__",
        "api_description": "Create a new fixed value comparator circuit.\n\nArgs:\n    num_state_qubits: Number of state qubits. If this is set it will determine the number\n        of qubits required for the circuit.\n    value: The fixed value to compare with.\n    geq: If True, evaluate a ``>=`` condition, else ``<``.\n    name: Name of the circuit.",
        "api_signature": "__init__(self, num_state_qubits, value, geq, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/integer_comparator.py"
    },
    {
        "api_name": "value",
        "full_api_name": "IntegerComparator.value",
        "api_description": "The value to compare the qubit register to.\n\nReturns:\n    The value against which the value of the qubit register is compared.",
        "api_signature": "value(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/integer_comparator.py"
    },
    {
        "api_name": "value",
        "full_api_name": "IntegerComparator.value",
        "api_description": "",
        "api_signature": "value(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/integer_comparator.py"
    },
    {
        "api_name": "geq",
        "full_api_name": "IntegerComparator.geq",
        "api_description": "Return whether the comparator compares greater or less equal.\n\nReturns:\n    True, if the comparator compares ``>=``, False if ``<``.",
        "api_signature": "geq(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/integer_comparator.py"
    },
    {
        "api_name": "geq",
        "full_api_name": "IntegerComparator.geq",
        "api_description": "Set whether the comparator compares greater or less equal.\n\nArgs:\n    geq: If True, the comparator compares ``>=``, if False ``<``.",
        "api_signature": "geq(self, geq)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/integer_comparator.py"
    },
    {
        "api_name": "num_ancilla_qubits",
        "full_api_name": "IntegerComparator.num_ancilla_qubits",
        "api_description": "Deprecated. Use num_ancillas instead.",
        "api_signature": "num_ancilla_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/integer_comparator.py"
    },
    {
        "api_name": "num_state_qubits",
        "full_api_name": "IntegerComparator.num_state_qubits",
        "api_description": "The number of qubits encoding the state for the comparison.\n\nReturns:\n    The number of state qubits.",
        "api_signature": "num_state_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/integer_comparator.py"
    },
    {
        "api_name": "num_state_qubits",
        "full_api_name": "IntegerComparator.num_state_qubits",
        "api_description": "Set the number of state qubits.\n\nNote that this will change the quantum registers.\n\nArgs:\n    num_state_qubits: The new number of state qubits.",
        "api_signature": "num_state_qubits(self, num_state_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/integer_comparator.py"
    },
    {
        "api_name": "_get_twos_complement",
        "full_api_name": "IntegerComparator._get_twos_complement",
        "api_description": "Returns the 2's complement of ``self.value`` as array.\n\nReturns:\n     The 2's complement of ``self.value``.",
        "api_signature": "_get_twos_complement(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/integer_comparator.py"
    },
    {
        "api_name": "_check_configuration",
        "full_api_name": "IntegerComparator._check_configuration",
        "api_description": "Check if the current configuration is valid.",
        "api_signature": "_check_configuration(self, raise_on_failure)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/integer_comparator.py"
    },
    {
        "api_name": "_build",
        "full_api_name": "IntegerComparator._build",
        "api_description": "If not already built, build the circuit.",
        "api_signature": "_build(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/integer_comparator.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "FunctionalPauliRotations.__init__",
        "api_description": "Create a new functional Pauli rotation circuit.\n\nArgs:\n    num_state_qubits: The number of qubits representing the state :math:`|x\\rangle`.\n    basis: The kind of Pauli rotation to use. Must be 'X', 'Y' or 'Z'.\n    name: The name of the circuit object.",
        "api_signature": "__init__(self, num_state_qubits, basis, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/functional_pauli_rotations.py"
    },
    {
        "api_name": "basis",
        "full_api_name": "FunctionalPauliRotations.basis",
        "api_description": "The kind of Pauli rotation to be used.\n\nSet the basis to 'X', 'Y' or 'Z' for controlled-X, -Y, or -Z rotations respectively.\n\nReturns:\n    The kind of Pauli rotation used in controlled rotation.",
        "api_signature": "basis(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/functional_pauli_rotations.py"
    },
    {
        "api_name": "basis",
        "full_api_name": "FunctionalPauliRotations.basis",
        "api_description": "Set the kind of Pauli rotation to be used.\n\nArgs:\n    basis: The Pauli rotation to be used.\n\nRaises:\n    ValueError: The provided basis in not X, Y or Z.",
        "api_signature": "basis(self, basis)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/functional_pauli_rotations.py"
    },
    {
        "api_name": "num_state_qubits",
        "full_api_name": "FunctionalPauliRotations.num_state_qubits",
        "api_description": "The number of state qubits representing the state :math:`|x\\rangle`.\n\nReturns:\n    The number of state qubits.",
        "api_signature": "num_state_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/functional_pauli_rotations.py"
    },
    {
        "api_name": "num_state_qubits",
        "full_api_name": "FunctionalPauliRotations.num_state_qubits",
        "api_description": "Set the number of state qubits.\n\nNote that this may change the underlying quantum register, if the number of state qubits\nchanges.\n\nArgs:\n    num_state_qubits: The new number of qubits.",
        "api_signature": "num_state_qubits(self, num_state_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/functional_pauli_rotations.py"
    },
    {
        "api_name": "_reset_registers",
        "full_api_name": "FunctionalPauliRotations._reset_registers",
        "api_description": "Reset the registers according to the new number of state qubits.\n\nArgs:\n    num_state_qubits: The new number of qubits.",
        "api_signature": "_reset_registers(self, num_state_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/functional_pauli_rotations.py"
    },
    {
        "api_name": "num_ancilla_qubits",
        "full_api_name": "FunctionalPauliRotations.num_ancilla_qubits",
        "api_description": "The minimum number of ancilla qubits in the circuit.\n\nReturns:\n    The minimal number of ancillas required.",
        "api_signature": "num_ancilla_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/functional_pauli_rotations.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "RGQFTMultiplier.__init__",
        "api_description": "Args:\n    num_state_qubits: The number of qubits in either input register for\n        state :math:`|a\\rangle` or :math:`|b\\rangle`. The two input\n        registers must have the same number of qubits.\n    num_result_qubits: The number of result qubits to limit the output to.\n        If number of result qubits is :math:`n`, multiplication modulo :math:`2^n` is performed\n        to limit the output to the specified number of qubits. Default\n        value is ``2 * num_state_qubits`` to represent any possible\n        result from the multiplication of the two inputs.\n    name: The name of the circuit object.",
        "api_signature": "__init__(self, num_state_qubits, num_result_qubits, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/multipliers/rg_qft_multiplier.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "HRSCumulativeMultiplier.__init__",
        "api_description": "Args:\n    num_state_qubits: The number of qubits in either input register for\n        state :math:`|a\\rangle` or :math:`|b\\rangle`. The two input\n        registers must have the same number of qubits.\n    num_result_qubits: The number of result qubits to limit the output to.\n        If number of result qubits is :math:`n`, multiplication modulo :math:`2^n` is performed\n        to limit the output to the specified number of qubits. Default\n        value is ``2 * num_state_qubits`` to represent any possible\n        result from the multiplication of the two inputs.\n    adder: Half adder circuit to be used for performing multiplication. The\n        CDKMRippleCarryAdder is used as default if no adder is provided.\n    name: The name of the circuit object.\nRaises:\n    NotImplementedError: If ``num_result_qubits`` is not default and a custom adder is provided.",
        "api_signature": "__init__(self, num_state_qubits, num_result_qubits, adder, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/multipliers/hrs_cumulative_multiplier.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Multiplier.__init__",
        "api_description": "Args:\n    num_state_qubits: The number of qubits in each of the input registers.\n    num_result_qubits: The number of result qubits to limit the output to.\n        Default value is ``2 * num_state_qubits`` to represent any possible\n        result from the multiplication of the two inputs.\n    name: The name of the circuit.\nRaises:\n    ValueError: If ``num_state_qubits`` is smaller than 1.\n    ValueError: If ``num_result_qubits`` is smaller than ``num_state_qubits``.\n    ValueError: If ``num_result_qubits`` is larger than ``2 * num_state_qubits``.",
        "api_signature": "__init__(self, num_state_qubits, num_result_qubits, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/multipliers/multiplier.py"
    },
    {
        "api_name": "num_state_qubits",
        "full_api_name": "Multiplier.num_state_qubits",
        "api_description": "The number of state qubits, i.e. the number of bits in each input register.\n\nReturns:\n    The number of state qubits.",
        "api_signature": "num_state_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/multipliers/multiplier.py"
    },
    {
        "api_name": "num_result_qubits",
        "full_api_name": "Multiplier.num_result_qubits",
        "api_description": "The number of result qubits to limit the output to.\n\nReturns:\n    The number of result qubits.",
        "api_signature": "num_result_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/multipliers/multiplier.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "DraperQFTAdder.__init__",
        "api_description": "Args:\n    num_state_qubits: The number of qubits in either input register for\n        state :math:`|a\\rangle` or :math:`|b\\rangle`. The two input\n        registers must have the same number of qubits.\n    kind: The kind of adder, can be ``'half'`` for a half adder or\n        ``'fixed'`` for a fixed-sized adder. A half adder contains a carry-out to represent\n        the most-significant bit, but the fixed-sized adder doesn't and hence performs\n        addition modulo ``2 ** num_state_qubits``.\n    name: The name of the circuit object.\nRaises:\n    ValueError: If ``num_state_qubits`` is lower than 1.",
        "api_signature": "__init__(self, num_state_qubits, kind, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/adders/draper_qft_adder.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Adder.__init__",
        "api_description": "Args:\n    num_state_qubits: The number of qubits in each of the registers.\n    name: The name of the circuit.",
        "api_signature": "__init__(self, num_state_qubits, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/adders/adder.py"
    },
    {
        "api_name": "num_state_qubits",
        "full_api_name": "Adder.num_state_qubits",
        "api_description": "The number of state qubits, i.e. the number of bits in each input register.\n\nReturns:\n    The number of state qubits.",
        "api_signature": "num_state_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/adders/adder.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "VBERippleCarryAdder.__init__",
        "api_description": "Args:\n    num_state_qubits: The size of the register.\n    kind: The kind of adder, can be ``'full'`` for a full adder, ``'half'`` for a half\n        adder, or ``'fixed'`` for a fixed-sized adder. A full adder includes both carry-in\n        and carry-out, a half only carry-out, and a fixed-sized adder neither carry-in\n        nor carry-out.\n    name: The name of the circuit.\n\nRaises:\n    ValueError: If ``num_state_qubits`` is lower than 1.",
        "api_signature": "__init__(self, num_state_qubits, kind, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/adders/vbe_ripple_carry_adder.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CDKMRippleCarryAdder.__init__",
        "api_description": "Args:\n    num_state_qubits: The number of qubits in either input register for\n        state :math:`|a\\rangle` or :math:`|b\\rangle`. The two input\n        registers must have the same number of qubits.\n    kind: The kind of adder, can be ``'full'`` for a full adder, ``'half'`` for a half\n        adder, or ``'fixed'`` for a fixed-sized adder. A full adder includes both carry-in\n        and carry-out, a half only carry-out, and a fixed-sized adder neither carry-in\n        nor carry-out.\n    name: The name of the circuit object.\nRaises:\n    ValueError: If ``num_state_qubits`` is lower than 1.",
        "api_signature": "__init__(self, num_state_qubits, kind, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/adders/cdkm_ripple_carry_adder.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "UCGate.__init__",
        "api_description": "Args:\n    gate_list: List of two qubit unitaries :math:`[U_0, ..., U_{2^{k-1}}]`, where each\n        single-qubit unitary :math:`U_i` is given as a :math:`2 \\times 2` numpy array.\n    up_to_diagonal: Determines if the gate is implemented up to a diagonal.\n        or if it is decomposed completely (default: False).\n        If the ``UCGate`` :math:`U` is decomposed up to a diagonal :math:`D`, this means\n        that the circuit implements a unitary :math:`U'` such that :math:`D U' = U`.\n\nRaises:\n    QiskitError: in case of bad input to the constructor",
        "api_signature": "__init__(self, gate_list, up_to_diagonal)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/uc.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "UCGate.inverse",
        "api_description": "Return the inverse.\n\nThis does not re-compute the decomposition for the multiplexer with the inverse of the\ngates but simply inverts the existing decomposition.",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/uc.py"
    },
    {
        "api_name": "_get_diagonal",
        "full_api_name": "UCGate._get_diagonal",
        "api_description": "",
        "api_signature": "_get_diagonal(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/uc.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "UCGate._define",
        "api_description": "",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/uc.py"
    },
    {
        "api_name": "_dec_ucg",
        "full_api_name": "UCGate._dec_ucg",
        "api_description": "Call to create a circuit that implements the uniformly controlled gate. If\nup_to_diagonal=True, the circuit implements the gate up to a diagonal gate and\nthe diagonal gate is also returned.",
        "api_signature": "_dec_ucg(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/uc.py"
    },
    {
        "api_name": "_dec_ucg_help",
        "full_api_name": "UCGate._dec_ucg_help",
        "api_description": "This method finds the single qubit gate arising in the decomposition of UCGates given in\nhttps://arxiv.org/pdf/quant-ph/0410066.pdf.",
        "api_signature": "_dec_ucg_help(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/uc.py"
    },
    {
        "api_name": "_demultiplex_single_uc",
        "full_api_name": "UCGate._demultiplex_single_uc",
        "api_description": "This method implements the decomposition given in equation (3) in\nhttps://arxiv.org/pdf/quant-ph/0410066.pdf.\nThe decomposition is used recursively to decompose uniformly controlled gates.\na,b = single qubit unitaries\nv,u,r = outcome of the decomposition given in the reference mentioned above\n(see there for the details).",
        "api_signature": "_demultiplex_single_uc(self, a, b)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/uc.py"
    },
    {
        "api_name": "_ct",
        "full_api_name": "UCGate._ct",
        "api_description": "",
        "api_signature": "_ct(m)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/uc.py"
    },
    {
        "api_name": "_rz",
        "full_api_name": "UCGate._rz",
        "api_description": "",
        "api_signature": "_rz(alpha)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/uc.py"
    },
    {
        "api_name": "validate_parameter",
        "full_api_name": "UCGate.validate_parameter",
        "api_description": "Uniformly controlled gate parameter has to be an ndarray.",
        "api_signature": "validate_parameter(self, parameter)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/uc.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Isometry.__init__",
        "api_description": "Args:\n    isometry: An isometry from :math:`m` to :math`n` qubits, i.e., a complex\n        ``np.ndarray`` of dimension :math:`2^n \\times 2^m` with orthonormal columns (given\n        in the computational basis specified by the order of the ancillas\n        and the input qubits, where the ancillas are considered to be more\n        significant than the input qubits).\n    num_ancillas_zero: Number of additional ancillas that start in the state :math:`|0\\rangle`\n        (the :math:`n-m` ancillas required for providing the output of the isometry are\n        not accounted for here).\n    num_ancillas_dirty: Number of additional ancillas that start in an arbitrary state.\n    epsilon: Error tolerance of calculations.",
        "api_signature": "__init__(self, isometry, num_ancillas_zero, num_ancillas_dirty, epsilon)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/isometry.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "Isometry._define",
        "api_description": "",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/isometry.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "Isometry.inverse",
        "api_description": "",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/isometry.py"
    },
    {
        "api_name": "_gates_to_uncompute",
        "full_api_name": "Isometry._gates_to_uncompute",
        "api_description": "Call to create a circuit with gates that take the desired isometry to the first 2^m columns\n of the 2^n*2^n identity matrix (see https://arxiv.org/abs/1501.06911)",
        "api_signature": "_gates_to_uncompute(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/isometry.py"
    },
    {
        "api_name": "_decompose_column",
        "full_api_name": "Isometry._decompose_column",
        "api_description": "Decomposes the column with index column_index.",
        "api_signature": "_decompose_column(self, circuit, q, diag, remaining_isometry, column_index)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/isometry.py"
    },
    {
        "api_name": "_disentangle",
        "full_api_name": "Isometry._disentangle",
        "api_description": "Disentangle the s-th significant qubit (starting with s = 0) into the zero or the one state\n(dependent on column_index)",
        "api_signature": "_disentangle(self, circuit, q, diag, remaining_isometry, column_index, s)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/isometry.py"
    },
    {
        "api_name": "_find_squs_for_disentangling",
        "full_api_name": "Isometry._find_squs_for_disentangling",
        "api_description": "",
        "api_signature": "_find_squs_for_disentangling(self, v, k, s)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/isometry.py"
    },
    {
        "api_name": "_append_ucg_up_to_diagonal",
        "full_api_name": "Isometry._append_ucg_up_to_diagonal",
        "api_description": "",
        "api_signature": "_append_ucg_up_to_diagonal(self, circ, q, single_qubit_gates, control_labels, target_label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/isometry.py"
    },
    {
        "api_name": "_append_mcg_up_to_diagonal",
        "full_api_name": "Isometry._append_mcg_up_to_diagonal",
        "api_description": "",
        "api_signature": "_append_mcg_up_to_diagonal(self, circ, q, gate, control_labels, target_label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/isometry.py"
    },
    {
        "api_name": "_define_qubit_role",
        "full_api_name": "Isometry._define_qubit_role",
        "api_description": "",
        "api_signature": "_define_qubit_role(self, q)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/isometry.py"
    },
    {
        "api_name": "validate_parameter",
        "full_api_name": "Isometry.validate_parameter",
        "api_description": "Isometry parameter has to be an ndarray.",
        "api_signature": "validate_parameter(self, parameter)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/isometry.py"
    },
    {
        "api_name": "inv_gate",
        "full_api_name": "Isometry.inv_gate",
        "api_description": "Return the adjoint of the unitary.",
        "api_signature": "inv_gate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/isometry.py"
    },
    {
        "api_name": "_reverse_qubit_state",
        "full_api_name": "_reverse_qubit_state",
        "api_description": "",
        "api_signature": "_reverse_qubit_state(state, basis_state, epsilon)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/isometry.py"
    },
    {
        "api_name": "_apply_ucg",
        "full_api_name": "_apply_ucg",
        "api_description": "",
        "api_signature": "_apply_ucg(m, k, single_qubit_gates)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/isometry.py"
    },
    {
        "api_name": "_apply_diagonal_gate",
        "full_api_name": "_apply_diagonal_gate",
        "api_description": "",
        "api_signature": "_apply_diagonal_gate(m, action_qubit_labels, diag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/isometry.py"
    },
    {
        "api_name": "_apply_diagonal_gate_to_diag",
        "full_api_name": "_apply_diagonal_gate_to_diag",
        "api_description": "",
        "api_signature": "_apply_diagonal_gate_to_diag(m_diagonal, action_qubit_labels, diag, num_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/isometry.py"
    },
    {
        "api_name": "_apply_multi_controlled_gate",
        "full_api_name": "_apply_multi_controlled_gate",
        "api_description": "",
        "api_signature": "_apply_multi_controlled_gate(m, control_labels, target_label, gate)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/isometry.py"
    },
    {
        "api_name": "_construct_basis_states",
        "full_api_name": "_construct_basis_states",
        "api_description": "",
        "api_signature": "_construct_basis_states(state_free, control_labels, target_label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/isometry.py"
    },
    {
        "api_name": "_get_qubits_by_label",
        "full_api_name": "_get_qubits_by_label",
        "api_description": "",
        "api_signature": "_get_qubits_by_label(labels, qubits, num_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/isometry.py"
    },
    {
        "api_name": "_reverse_qubit_oder",
        "full_api_name": "_reverse_qubit_oder",
        "api_description": "",
        "api_signature": "_reverse_qubit_oder(qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/isometry.py"
    },
    {
        "api_name": "_bin_to_int",
        "full_api_name": "_bin_to_int",
        "api_description": "",
        "api_signature": "_bin_to_int(binary_digits_as_list)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/isometry.py"
    },
    {
        "api_name": "_ct",
        "full_api_name": "_ct",
        "api_description": "",
        "api_signature": "_ct(m)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/isometry.py"
    },
    {
        "api_name": "_get_binary_rep_as_list",
        "full_api_name": "_get_binary_rep_as_list",
        "api_description": "",
        "api_signature": "_get_binary_rep_as_list(n, num_digits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/isometry.py"
    },
    {
        "api_name": "_merge_UCGate_and_diag",
        "full_api_name": "_merge_UCGate_and_diag",
        "api_description": "",
        "api_signature": "_merge_UCGate_and_diag(single_qubit_gates, diag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/isometry.py"
    },
    {
        "api_name": "_a",
        "full_api_name": "_a",
        "api_description": "",
        "api_signature": "_a(k, s)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/isometry.py"
    },
    {
        "api_name": "_b",
        "full_api_name": "_b",
        "api_description": "",
        "api_signature": "_b(k, s)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/isometry.py"
    },
    {
        "api_name": "_k_s",
        "full_api_name": "_k_s",
        "api_description": "",
        "api_signature": "_k_s(k, s)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/isometry.py"
    },
    {
        "api_name": "_ucg_is_identity_up_to_global_phase",
        "full_api_name": "_ucg_is_identity_up_to_global_phase",
        "api_description": "",
        "api_signature": "_ucg_is_identity_up_to_global_phase(single_qubit_gates, epsilon)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/isometry.py"
    },
    {
        "api_name": "_diag_is_identity_up_to_global_phase",
        "full_api_name": "_diag_is_identity_up_to_global_phase",
        "api_description": "",
        "api_signature": "_diag_is_identity_up_to_global_phase(diag, epsilon)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/isometry.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Diagonal.__init__",
        "api_description": "Args:\n    diag: List of the :math:`2^k` diagonal entries (for a diagonal gate on :math:`k` qubits).\n\nRaises:\n    CircuitError: if the list of the diagonal entries or the qubit list is in bad format;\n        if the number of diagonal entries is not :math:`2^k`, where :math:`k` denotes the\n        number of qubits.",
        "api_signature": "__init__(self, diag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/diagonal.py"
    },
    {
        "api_name": "_check_input",
        "full_api_name": "Diagonal._check_input",
        "api_description": "Check if ``diag`` is in valid format.",
        "api_signature": "_check_input(diag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/diagonal.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "DiagonalGate.__init__",
        "api_description": "Args:\n    diag: list of the :math:`2^k` diagonal entries (for a diagonal gate on :math:`k` qubits).",
        "api_signature": "__init__(self, diag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/diagonal.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "DiagonalGate._define",
        "api_description": "",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/diagonal.py"
    },
    {
        "api_name": "validate_parameter",
        "full_api_name": "DiagonalGate.validate_parameter",
        "api_description": "Diagonal Gate parameter should accept complex\n(in addition to the Gate parameter types) and always return build-in complex.",
        "api_signature": "validate_parameter(self, parameter)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/diagonal.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "DiagonalGate.inverse",
        "api_description": "Return the inverse of the diagonal gate.",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/diagonal.py"
    },
    {
        "api_name": "_extract_rz",
        "full_api_name": "_extract_rz",
        "api_description": "Extract a Rz rotation (angle given by first output) such that exp(j*phase)*Rz(z_angle)\nis equal to the diagonal matrix with entires exp(1j*ph1) and exp(1j*ph2).",
        "api_signature": "_extract_rz(phi1, phi2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/diagonal.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "GR.__init__",
        "api_description": "Create a new Global R (GR) gate.\n\nArgs:\n    num_qubits: number of qubits.\n    theta: rotation angle about axis determined by phi\n    phi: angle of rotation axis in xy-plane",
        "api_signature": "__init__(self, num_qubits, theta, phi)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/gr.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "GRX.__init__",
        "api_description": "Create a new Global RX (GRX) gate.\n\nArgs:\n    num_qubits: number of qubits.\n    theta: rotation angle about x-axis",
        "api_signature": "__init__(self, num_qubits, theta)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/gr.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "GRY.__init__",
        "api_description": "Create a new Global RY (GRY) gate.\n\nArgs:\n    num_qubits: number of qubits.\n    theta: rotation angle about y-axis",
        "api_signature": "__init__(self, num_qubits, theta)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/gr.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "GRZ.__init__",
        "api_description": "Create a new Global RZ (GRZ) gate.\n\nArgs:\n    num_qubits: number of qubits.\n    phi: rotation angle about z-axis",
        "api_signature": "__init__(self, num_qubits, phi)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/gr.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "LinearFunction.__init__",
        "api_description": "Create a new linear function.\n\nArgs:\n    linear (list[list] or ndarray[bool] or QuantumCircuit or LinearFunction\n        or PermutationGate or Clifford): data from which a linear function\n        can be constructed. It can be either a nxn matrix (describing the\n        linear transformation), a permutation (which is a special case of\n        a linear function), another linear function, a clifford (when it\n        corresponds to a linear function), or a quantum circuit composed of\n        linear gates (CX and SWAP) and other objects described above, including\n        nested subcircuits.\n\n    validate_input: if True, performs more expensive input validation checks,\n        such as checking that a given n x n matrix is invertible.\n\nRaises:\n    CircuitError: if the input is invalid:\n        either the input matrix is not square or not invertible,\n        or the input quantum circuit contains non-linear objects\n        (for example, a Hadamard gate, or a Clifford that does\n        not correspond to a linear function).",
        "api_signature": "__init__(self, linear, validate_input)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/linear_function.py"
    },
    {
        "api_name": "_circuit_to_mat",
        "full_api_name": "LinearFunction._circuit_to_mat",
        "api_description": "This creates a nxn matrix corresponding to the given quantum circuit.",
        "api_signature": "_circuit_to_mat(qc)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/linear_function.py"
    },
    {
        "api_name": "_clifford_to_mat",
        "full_api_name": "LinearFunction._clifford_to_mat",
        "api_description": "This creates a nxn matrix corresponding to the given Clifford, when Clifford\ncan be converted to a linear function. This is possible when the clifford has\ntableau of the form [[A, B], [C, D]], with B = C = 0 and D = A^{-1}^t, and zero\nphase vector. In this case, the required matrix is A^t.\nRaises an error otherwise.",
        "api_signature": "_clifford_to_mat(cliff)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/linear_function.py"
    },
    {
        "api_name": "_permutation_to_mat",
        "full_api_name": "LinearFunction._permutation_to_mat",
        "api_description": "This creates a nxn matrix from a given permutation gate.",
        "api_signature": "_permutation_to_mat(perm)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/linear_function.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "LinearFunction.__eq__",
        "api_description": "Check if two linear functions represent the same matrix.",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/linear_function.py"
    },
    {
        "api_name": "validate_parameter",
        "full_api_name": "LinearFunction.validate_parameter",
        "api_description": "Parameter validation",
        "api_signature": "validate_parameter(self, parameter)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/linear_function.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "LinearFunction._define",
        "api_description": "Populates self.definition with a decomposition of this gate.",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/linear_function.py"
    },
    {
        "api_name": "synthesize",
        "full_api_name": "LinearFunction.synthesize",
        "api_description": "Synthesizes the linear function into a quantum circuit.\n\nReturns:\n    QuantumCircuit: A circuit implementing the evolution.",
        "api_signature": "synthesize(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/linear_function.py"
    },
    {
        "api_name": "linear",
        "full_api_name": "LinearFunction.linear",
        "api_description": "Returns the n x n matrix representing this linear function.",
        "api_signature": "linear(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/linear_function.py"
    },
    {
        "api_name": "original_circuit",
        "full_api_name": "LinearFunction.original_circuit",
        "api_description": "Returns the original circuit used to construct this linear function\n(including None, when the linear function is not constructed from a circuit).",
        "api_signature": "original_circuit(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/linear_function.py"
    },
    {
        "api_name": "is_permutation",
        "full_api_name": "LinearFunction.is_permutation",
        "api_description": "Returns whether this linear function is a permutation,\nthat is whether every row and every column of the n x n matrix\nhas exactly one 1.",
        "api_signature": "is_permutation(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/linear_function.py"
    },
    {
        "api_name": "permutation_pattern",
        "full_api_name": "LinearFunction.permutation_pattern",
        "api_description": "This method first checks if a linear function is a permutation and raises a\n`qiskit.circuit.exceptions.CircuitError` if not. In the case that this linear function\nis a permutation, returns the permutation pattern.",
        "api_signature": "permutation_pattern(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/linear_function.py"
    },
    {
        "api_name": "extend_with_identity",
        "full_api_name": "LinearFunction.extend_with_identity",
        "api_description": "Extend linear function to a linear function over nq qubits,\nwith identities on other subsystems.\n\nArgs:\n    num_qubits: number of qubits of the extended function.\n\n    positions: describes the positions of original qubits in the extended\n        function's qubits.\n\nReturns:\n    LinearFunction: extended linear function.",
        "api_signature": "extend_with_identity(self, num_qubits, positions)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/linear_function.py"
    },
    {
        "api_name": "mat_str",
        "full_api_name": "LinearFunction.mat_str",
        "api_description": "Return string representation of the linear function\nviewed as a matrix with 0/1 entries.",
        "api_signature": "mat_str(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/linear_function.py"
    },
    {
        "api_name": "function_str",
        "full_api_name": "LinearFunction.function_str",
        "api_description": "Return string representation of the linear function\nviewed as a linear transformation.",
        "api_signature": "function_str(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/linear_function.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Permutation.__init__",
        "api_description": "Return an n_qubit permutation circuit implemented using SWAPs.\n\nArgs:\n    num_qubits: circuit width.\n    pattern: permutation pattern, describing which qubits occupy the\n        positions 0, 1, 2, etc. after applying the permutation, that\n        is ``pattern[k] = m`` when the permutation maps qubit ``m``\n        to position ``k``. As an example, the pattern ``[2, 4, 3, 0, 1]``\n        means that qubit ``2`` goes to position ``0``, qubit ``4``\n        goes to the position ``1``, etc. The pattern can also be ``None``,\n        in which case a random permutation over ``num_qubits`` is\n        created.\n    seed: random seed in case a random permutation is requested.\n\nRaises:\n    CircuitError: if permutation pattern is malformed.\n\nReference Circuit:\n    .. plot::\n\n       from qiskit.circuit.library import Permutation\n       A = [2,4,3,0,1]\n       circuit = Permutation(5, A)\n       circuit.draw('mpl')\n\nExpanded Circuit:\n    .. plot::\n\n       from qiskit.circuit.library import Permutation\n       from qiskit.tools.jupyter.library import _generate_circuit_library_visualization\n       A = [2,4,3,0,1]\n       circuit = Permutation(5, A)\n       _generate_circuit_library_visualization(circuit.decompose())",
        "api_signature": "__init__(self, num_qubits, pattern, seed)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/permutation.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PermutationGate.__init__",
        "api_description": "Return a permutation gate.\n\nArgs:\n    pattern: permutation pattern, describing which qubits occupy the\n        positions 0, 1, 2, etc. after applying the permutation, that\n        is ``pattern[k] = m`` when the permutation maps qubit ``m``\n        to position ``k``. As an example, the pattern ``[2, 4, 3, 0, 1]``\n        means that qubit ``2`` goes to position ``0``, qubit ``4``\n        goes to the position ``1``, etc.\n\nRaises:\n    CircuitError: if permutation pattern is malformed.\n\nReference Circuit:\n    .. plot::\n\n        from qiskit.circuit.quantumcircuit import QuantumCircuit\n        from qiskit.circuit.library import PermutationGate\n        A = [2,4,3,0,1]\n        permutation = PermutationGate(A)\n        circuit = QuantumCircuit(5)\n        circuit.append(permutation, [0, 1, 2, 3, 4])\n        circuit.draw('mpl')\n\nExpanded Circuit:\n    .. plot::\n\n        from qiskit.circuit.quantumcircuit import QuantumCircuit\n        from qiskit.circuit.library import PermutationGate\n        from qiskit.tools.jupyter.library import _generate_circuit_library_visualization\n        A = [2,4,3,0,1]\n        permutation = PermutationGate(A)\n        circuit = QuantumCircuit(5)\n        circuit.append(permutation, [0, 1, 2, 3, 4])\n\n        _generate_circuit_library_visualization(circuit.decompose())",
        "api_signature": "__init__(self, pattern)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/permutation.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "PermutationGate.__array__",
        "api_description": "Return a numpy.array for the Permutation gate.",
        "api_signature": "__array__(self, dtype)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/permutation.py"
    },
    {
        "api_name": "validate_parameter",
        "full_api_name": "PermutationGate.validate_parameter",
        "api_description": "Parameter validation.",
        "api_signature": "validate_parameter(self, parameter)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/permutation.py"
    },
    {
        "api_name": "pattern",
        "full_api_name": "PermutationGate.pattern",
        "api_description": "Returns the permutation pattern defining this permutation.",
        "api_signature": "pattern(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/permutation.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "PermutationGate.inverse",
        "api_description": "Returns the inverse of the permutation.",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/permutation.py"
    },
    {
        "api_name": "_qasm2_decomposition",
        "full_api_name": "PermutationGate._qasm2_decomposition",
        "api_description": "",
        "api_signature": "_qasm2_decomposition(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/permutation.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "UCRYGate.__init__",
        "api_description": "Args:\n    angle_list: List of rotation angles :math:`[a_0, ..., a_{2^{k-1}}]`.",
        "api_signature": "__init__(self, angle_list)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/ucry.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "UCRXGate.__init__",
        "api_description": "Args:\n    angle_list: List of rotation angles :math:`[a_0, ..., a_{2^{k-1}}]`.",
        "api_signature": "__init__(self, angle_list)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/ucrx.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "GMS.__init__",
        "api_description": "Create a new Global M\u00f8lmer\u2013S\u00f8rensen (GMS) gate.\n\nArgs:\n    num_qubits: width of gate.\n    theta: a num_qubits x num_qubits symmetric matrix of\n        interaction angles for each qubit pair. The upper\n        triangle is considered.",
        "api_signature": "__init__(self, num_qubits, theta)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/gms.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "MSGate.__init__",
        "api_description": "Create new MS gate.",
        "api_signature": "__init__(self, num_qubits, theta, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/gms.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "MSGate._define",
        "api_description": "",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/gms.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "UnitaryGate.__init__",
        "api_description": "Create a gate from a numeric unitary matrix.\n\nArgs:\n    data: Unitary operator.\n    label: Unitary name for backend [Default: None].\n    check_input: If set to ``False`` this asserts the input\n        is known to be unitary and the checking to validate this will\n        be skipped. This should only ever be used if you know the\n        input is unitary, setting this to ``False`` and passing in\n        a non-unitary matrix will result unexpected behavior and errors.\n\nRaises:\n    ValueError: If input data is not an N-qubit unitary operator.",
        "api_signature": "__init__(self, data, label, check_input)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/unitary.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "UnitaryGate.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/unitary.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "UnitaryGate.__array__",
        "api_description": "Return matrix for the unitary.",
        "api_signature": "__array__(self, dtype)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/unitary.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "UnitaryGate.inverse",
        "api_description": "Return the adjoint of the unitary.",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/unitary.py"
    },
    {
        "api_name": "conjugate",
        "full_api_name": "UnitaryGate.conjugate",
        "api_description": "Return the conjugate of the unitary.",
        "api_signature": "conjugate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/unitary.py"
    },
    {
        "api_name": "adjoint",
        "full_api_name": "UnitaryGate.adjoint",
        "api_description": "Return the adjoint of the unitary.",
        "api_signature": "adjoint(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/unitary.py"
    },
    {
        "api_name": "transpose",
        "full_api_name": "UnitaryGate.transpose",
        "api_description": "Return the transpose of the unitary.",
        "api_signature": "transpose(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/unitary.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "UnitaryGate._define",
        "api_description": "Calculate a subcircuit that implements this unitary.",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/unitary.py"
    },
    {
        "api_name": "control",
        "full_api_name": "UnitaryGate.control",
        "api_description": "Return controlled version of gate.\n\nArgs:\n    num_ctrl_qubits: Number of controls to add to gate (default is 1).\n    label: Optional gate label.\n    ctrl_state: The control state in decimal or as a bit string (e.g. ``\"1011\"``).\n        If ``None``, use ``2**num_ctrl_qubits - 1``.\n\nReturns:\n    Controlled version of gate.",
        "api_signature": "control(self, num_ctrl_qubits, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/unitary.py"
    },
    {
        "api_name": "_qasm2_decomposition",
        "full_api_name": "UnitaryGate._qasm2_decomposition",
        "api_description": "Return an unparameterized version of ourselves, so the OQ2 exporter doesn't choke on the\nnon-standard things in our `params` field.",
        "api_signature": "_qasm2_decomposition(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/unitary.py"
    },
    {
        "api_name": "validate_parameter",
        "full_api_name": "UnitaryGate.validate_parameter",
        "api_description": "Unitary gate parameter has to be an ndarray.",
        "api_signature": "validate_parameter(self, parameter)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/unitary.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "UCPauliRotGate.__init__",
        "api_description": "Args:\n    angle_list: List of rotation angles :math:`[a_0, ..., a_{2^{k-1}}]`.\n    rot_axis: Rotation axis. Must be either of ``\"X\"``, ``\"Y\"`` or ``\"Z\"``.",
        "api_signature": "__init__(self, angle_list, rot_axis)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/uc_pauli_rot.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "UCPauliRotGate._define",
        "api_description": "",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/uc_pauli_rot.py"
    },
    {
        "api_name": "_dec_ucrot",
        "full_api_name": "UCPauliRotGate._dec_ucrot",
        "api_description": "Finds a decomposition of a UC rotation gate into elementary gates\n(C-NOTs and single-qubit rotations).",
        "api_signature": "_dec_ucrot(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/uc_pauli_rot.py"
    },
    {
        "api_name": "_dec_uc_rotations",
        "full_api_name": "UCPauliRotGate._dec_uc_rotations",
        "api_description": "Calculates rotation angles for a uniformly controlled R_t gate with a C-NOT gate at\nthe end of the circuit. The rotation angles of the gate R_t are stored in\nangles[start_index:end_index]. If reversed_dec == True, it decomposes the gate such that\nthere is a C-NOT gate at the start of the circuit (in fact, the circuit topology for\nthe reversed decomposition is the reversed one of the original decomposition)",
        "api_signature": "_dec_uc_rotations(angles, start_index, end_index, reversed_dec)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/uc_pauli_rot.py"
    },
    {
        "api_name": "_update_angles",
        "full_api_name": "UCPauliRotGate._update_angles",
        "api_description": "Calculate the new rotation angles according to Shende's decomposition.",
        "api_signature": "_update_angles(angle1, angle2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/uc_pauli_rot.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "UCRZGate.__init__",
        "api_description": "Args:\n    angle_list: List of rotation angles :math:`[a_0, ..., a_{2^{k-1}}]`.",
        "api_signature": "__init__(self, angle_list)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/ucrz.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "MCGupDiag.__init__",
        "api_description": "Args:\n    gate: :math:`2 \\times 2` unitary given as a (complex) ``ndarray``.\n    num_controls: Number of control qubits.\n    num_ancillas_zero: Number of ancilla qubits that start in the state zero.\n    num_ancillas_dirty: Number of ancilla qubits that are allowed to start in an\n        arbitrary state.\n\nRaises:\n    QiskitError: if the input format is wrong; if the array gate is not unitary",
        "api_signature": "__init__(self, gate, num_controls, num_ancillas_zero, num_ancillas_dirty)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/mcg_up_to_diagonal.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "MCGupDiag._define",
        "api_description": "",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/mcg_up_to_diagonal.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "MCGupDiag.inverse",
        "api_description": "Return the inverse.\n\nNote that the resulting Gate object has an empty ``params`` property.",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/mcg_up_to_diagonal.py"
    },
    {
        "api_name": "_get_diagonal",
        "full_api_name": "MCGupDiag._get_diagonal",
        "api_description": "",
        "api_signature": "_get_diagonal(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/mcg_up_to_diagonal.py"
    },
    {
        "api_name": "_dec_mcg_up_diag",
        "full_api_name": "MCGupDiag._dec_mcg_up_diag",
        "api_description": "Call to create a circuit with gates that implement the MCG up to a diagonal gate.\nRemark: The qubits the gate acts on are ordered in the following way:\n    q=[q_target,q_controls,q_ancilla_zero,q_ancilla_dirty]",
        "api_signature": "_dec_mcg_up_diag(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/mcg_up_to_diagonal.py"
    },
    {
        "api_name": "_define_qubit_role",
        "full_api_name": "MCGupDiag._define_qubit_role",
        "api_description": "",
        "api_signature": "_define_qubit_role(self, q)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/mcg_up_to_diagonal.py"
    },
    {
        "api_name": "validate_parameter",
        "full_api_name": "MCGupDiag.validate_parameter",
        "api_description": "Multi controlled single-qubit unitary gate parameter has to be an ndarray.",
        "api_signature": "validate_parameter(self, parameter)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/mcg_up_to_diagonal.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "RVGate.__init__",
        "api_description": "Create new rv single-qubit gate.\n\nArgs:\n    v_x (float): x-component\n    v_y (float): y-component\n    v_z (float): z-component\n    basis (str, optional): basis (see\n        :class:`~qiskit.quantum_info.synthesis.one_qubit_decompose.OneQubitEulerDecomposer`)",
        "api_signature": "__init__(self, v_x, v_y, v_z, basis)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/rv.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "RVGate._define",
        "api_description": "",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/rv.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "RVGate.inverse",
        "api_description": "Invert this gate.",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/rv.py"
    },
    {
        "api_name": "to_matrix",
        "full_api_name": "RVGate.to_matrix",
        "api_description": "Return a numpy.array for the R(v) gate.",
        "api_signature": "to_matrix(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/rv.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "MCMT.__init__",
        "api_description": "Create a new multi-control multi-target gate.\n\nArgs:\n    gate: The gate to be applied controlled on the control qubits and applied to the target\n        qubits. Can be either a Gate or a circuit method.\n        If it is a callable, it will be casted to a Gate.\n    num_ctrl_qubits: The number of control qubits.\n    num_target_qubits: The number of target qubits.\n\nRaises:\n    AttributeError: If the gate cannot be casted to a controlled gate.\n    AttributeError: If the number of controls or targets is 0.",
        "api_signature": "__init__(self, gate, num_ctrl_qubits, num_target_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/mcmt.py"
    },
    {
        "api_name": "_build",
        "full_api_name": "MCMT._build",
        "api_description": "Define the MCMT gate without ancillas.",
        "api_signature": "_build(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/mcmt.py"
    },
    {
        "api_name": "num_ancilla_qubits",
        "full_api_name": "MCMT.num_ancilla_qubits",
        "api_description": "Return the number of ancillas.",
        "api_signature": "num_ancilla_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/mcmt.py"
    },
    {
        "api_name": "_identify_gate",
        "full_api_name": "MCMT._identify_gate",
        "api_description": "Case the gate input to a gate.",
        "api_signature": "_identify_gate(self, gate)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/mcmt.py"
    },
    {
        "api_name": "control",
        "full_api_name": "MCMT.control",
        "api_description": "Return the controlled version of the MCMT circuit.",
        "api_signature": "control(self, num_ctrl_qubits, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/mcmt.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "MCMT.inverse",
        "api_description": "Return the inverse MCMT circuit, which is itself.",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/mcmt.py"
    },
    {
        "api_name": "_build",
        "full_api_name": "MCMTVChain._build",
        "api_description": "Define the MCMT gate.",
        "api_signature": "_build(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/mcmt.py"
    },
    {
        "api_name": "num_ancilla_qubits",
        "full_api_name": "MCMTVChain.num_ancilla_qubits",
        "api_description": "Return the number of ancilla qubits required.",
        "api_signature": "num_ancilla_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/mcmt.py"
    },
    {
        "api_name": "_ccx_v_chain_rule",
        "full_api_name": "MCMTVChain._ccx_v_chain_rule",
        "api_description": "Get the rule for the CCX V-chain.\n\nThe CCX V-chain progressively computes the CCX of the control qubits and puts the final\nresult in the last ancillary qubit.\n\nArgs:\n    control_qubits: The control qubits.\n    ancilla_qubits: The ancilla qubits.\n    reverse: If True, compute the chain down to the qubit. If False, compute upwards.\n\nReturns:\n    The rule for the (reversed) CCX V-chain.\n\nRaises:\n    QiskitError: If an insufficient number of ancilla qubits was provided.",
        "api_signature": "_ccx_v_chain_rule(self, control_qubits, ancilla_qubits, reverse)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/mcmt.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "MCMTVChain.inverse",
        "api_description": "",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/mcmt.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PauliGate.__init__",
        "api_description": "",
        "api_signature": "__init__(self, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/pauli.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "PauliGate._define",
        "api_description": "gate pauli (p1 a1,...,pn an) { p1 a1; ... ; pn an; }",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/pauli.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "PauliGate.inverse",
        "api_description": "Return inverted pauli gate (itself).",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/pauli.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "PauliGate.__array__",
        "api_description": "Return a Numpy.array for the pauli gate.\ni.e. tensor product of the paulis",
        "api_signature": "__array__(self, dtype)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/pauli.py"
    },
    {
        "api_name": "validate_parameter",
        "full_api_name": "PauliGate.validate_parameter",
        "api_description": "",
        "api_signature": "validate_parameter(self, parameter)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/pauli.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "HGate.__init__",
        "api_description": "Create new H gate.",
        "api_signature": "__init__(self, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/h.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "HGate._define",
        "api_description": "gate h a { u2(0,pi) a; }",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/h.py"
    },
    {
        "api_name": "control",
        "full_api_name": "HGate.control",
        "api_description": "Return a (multi-)controlled-H gate.\n\nOne control qubit returns a CH gate.\n\nArgs:\n    num_ctrl_qubits (int): number of control qubits.\n    label (str or None): An optional label for the gate [Default: None]\n    ctrl_state (int or str or None): control state expressed as integer,\n        string (e.g. '110'), or None. If None, use all 1s.\n\nReturns:\n    ControlledGate: controlled version of this gate.",
        "api_signature": "control(self, num_ctrl_qubits, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/h.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "HGate.inverse",
        "api_description": "Return inverted H gate (itself).",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/h.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CHGate.__init__",
        "api_description": "Create new CH gate.",
        "api_signature": "__init__(self, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/h.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "CHGate._define",
        "api_description": "gate ch a,b {\n    s b;\n    h b;\n    t b;\n    cx a, b;\n    tdg b;\n    h b;\n    sdg b;\n}",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/h.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "CHGate.inverse",
        "api_description": "Return inverted CH gate (itself).",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/h.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "UGate.__init__",
        "api_description": "Create new U gate.",
        "api_signature": "__init__(self, theta, phi, lam, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "UGate.inverse",
        "api_description": "Return inverted U gate.\n\n:math:`U(\\theta,\\phi,\\lambda)^{\\dagger} =U(-\\theta,-\\lambda,-\\phi)`)",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u.py"
    },
    {
        "api_name": "control",
        "full_api_name": "UGate.control",
        "api_description": "Return a (multi-)controlled-U gate.\n\nArgs:\n    num_ctrl_qubits (int): number of control qubits.\n    label (str or None): An optional label for the gate [Default: None]\n    ctrl_state (int or str or None): control state expressed as integer,\n        string (e.g. '110'), or None. If None, use all 1s.\n\nReturns:\n    ControlledGate: controlled version of this gate.",
        "api_signature": "control(self, num_ctrl_qubits, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "UGate.__array__",
        "api_description": "Return a numpy.array for the U gate.",
        "api_signature": "__array__(self, dtype)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "_CUGateParams.__init__",
        "api_description": "",
        "api_signature": "__init__(self, gate)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u.py"
    },
    {
        "api_name": "__setitem__",
        "full_api_name": "_CUGateParams.__setitem__",
        "api_description": "",
        "api_signature": "__setitem__(self, key, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CUGate.__init__",
        "api_description": "Create new CU gate.",
        "api_signature": "__init__(self, theta, phi, lam, gamma, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "CUGate._define",
        "api_description": "gate cu(theta,phi,lambda,gamma) c, t\n{ phase(gamma) c;\n  phase((lambda+phi)/2) c;\n  phase((lambda-phi)/2) t;\n  cx c,t;\n  u(-theta/2,0,-(phi+lambda)/2) t;\n  cx c,t;\n  u(theta/2,phi,0) t;\n}",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "CUGate.inverse",
        "api_description": "Return inverted CU gate.\n\n:math:`CU(\\theta,\\phi,\\lambda,\\gamma)^{\\dagger} = CU(-\\theta,-\\phi,-\\lambda,-\\gamma)`)",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "CUGate.__array__",
        "api_description": "Return a numpy.array for the CU gate.",
        "api_signature": "__array__(self, dtype)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u.py"
    },
    {
        "api_name": "params",
        "full_api_name": "CUGate.params",
        "api_description": "",
        "api_signature": "params(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u.py"
    },
    {
        "api_name": "params",
        "full_api_name": "CUGate.params",
        "api_description": "",
        "api_signature": "params(self, parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u.py"
    },
    {
        "api_name": "__deepcopy__",
        "full_api_name": "CUGate.__deepcopy__",
        "api_description": "",
        "api_signature": "__deepcopy__(self, memo)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ZGate.__init__",
        "api_description": "Create new Z gate.",
        "api_signature": "__init__(self, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/z.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "ZGate._define",
        "api_description": "",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/z.py"
    },
    {
        "api_name": "control",
        "full_api_name": "ZGate.control",
        "api_description": "Return a (multi-)controlled-Z gate.\n\nOne control returns a CZ gate.\n\nArgs:\n    num_ctrl_qubits (int): number of control qubits.\n    label (str or None): An optional label for the gate [Default: None]\n    ctrl_state (int or str or None): control state expressed as integer,\n        string (e.g. '110'), or None. If None, use all 1s.\n\nReturns:\n    ControlledGate: controlled version of this gate.",
        "api_signature": "control(self, num_ctrl_qubits, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/z.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "ZGate.inverse",
        "api_description": "Return inverted Z gate (itself).",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/z.py"
    },
    {
        "api_name": "power",
        "full_api_name": "ZGate.power",
        "api_description": "Raise gate to a power.",
        "api_signature": "power(self, exponent)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/z.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CZGate.__init__",
        "api_description": "Create new CZ gate.",
        "api_signature": "__init__(self, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/z.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "CZGate._define",
        "api_description": "gate cz a,b { h b; cx a,b; h b; }",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/z.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "CZGate.inverse",
        "api_description": "Return inverted CZ gate (itself).",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/z.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CCZGate.__init__",
        "api_description": "Create new CCZ gate.",
        "api_signature": "__init__(self, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/z.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "CCZGate._define",
        "api_description": "gate ccz a,b,c { h c; ccx a,b,c; h c; }",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/z.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "CCZGate.inverse",
        "api_description": "Return inverted CCZ gate (itself).",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/z.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "RZGate.__init__",
        "api_description": "Create new RZ gate.",
        "api_signature": "__init__(self, phi, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rz.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "RZGate._define",
        "api_description": "gate rz(phi) a { u1(phi) a; }",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rz.py"
    },
    {
        "api_name": "control",
        "full_api_name": "RZGate.control",
        "api_description": "Return a (multi-)controlled-RZ gate.\n\nArgs:\n    num_ctrl_qubits (int): number of control qubits.\n    label (str or None): An optional label for the gate [Default: None]\n    ctrl_state (int or str or None): control state expressed as integer,\n        string (e.g. '110'), or None. If None, use all 1s.\n\nReturns:\n    ControlledGate: controlled version of this gate.",
        "api_signature": "control(self, num_ctrl_qubits, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rz.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "RZGate.inverse",
        "api_description": "Return inverted RZ gate\n\n:math:`RZ(\\lambda)^{\\dagger} = RZ(-\\lambda)`",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rz.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "RZGate.__array__",
        "api_description": "Return a numpy.array for the RZ gate.",
        "api_signature": "__array__(self, dtype)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rz.py"
    },
    {
        "api_name": "power",
        "full_api_name": "RZGate.power",
        "api_description": "Raise gate to a power.",
        "api_signature": "power(self, exponent)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rz.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CRZGate.__init__",
        "api_description": "Create new CRZ gate.",
        "api_signature": "__init__(self, theta, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rz.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "CRZGate._define",
        "api_description": "gate crz(lambda) a,b\n{ rz(lambda/2) b; cx a,b;\n  rz(-lambda/2) b; cx a,b;\n}",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rz.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "CRZGate.inverse",
        "api_description": "Return inverse CRZ gate (i.e. with the negative rotation angle).",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rz.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "CRZGate.__array__",
        "api_description": "Return a numpy.array for the CRZ gate.",
        "api_signature": "__array__(self, dtype)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rz.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "DCXGate.__init__",
        "api_description": "Create new DCX gate.",
        "api_signature": "__init__(self, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/dcx.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "DCXGate._define",
        "api_description": "gate dcx a, b { cx a, b; cx b, a; }",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/dcx.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "U2Gate.__init__",
        "api_description": "Create new U2 gate.",
        "api_signature": "__init__(self, phi, lam, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u2.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "U2Gate._define",
        "api_description": "",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u2.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "U2Gate.inverse",
        "api_description": "Return inverted U2 gate.\n\n:math:`U2(\\phi, \\lambda)^{\\dagger} =U2(-\\lambda-\\pi, -\\phi+\\pi)`)",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u2.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "U2Gate.__array__",
        "api_description": "Return a Numpy.array for the U2 gate.",
        "api_signature": "__array__(self, dtype)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u2.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PhaseGate.__init__",
        "api_description": "Create new Phase gate.",
        "api_signature": "__init__(self, theta, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/p.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "PhaseGate._define",
        "api_description": "",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/p.py"
    },
    {
        "api_name": "control",
        "full_api_name": "PhaseGate.control",
        "api_description": "Return a (multi-)controlled-Phase gate.\n\nArgs:\n    num_ctrl_qubits (int): number of control qubits.\n    label (str or None): An optional label for the gate [Default: None]\n    ctrl_state (int or str or None): control state expressed as integer,\n        string (e.g. '110'), or None. If None, use all 1s.\n\nReturns:\n    ControlledGate: controlled version of this gate.",
        "api_signature": "control(self, num_ctrl_qubits, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/p.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "PhaseGate.inverse",
        "api_description": "Return inverted Phase gate (:math:`Phase(\\lambda)^{\\dagger} = Phase(-\\lambda)`)",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/p.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "PhaseGate.__array__",
        "api_description": "Return a numpy.array for the Phase gate.",
        "api_signature": "__array__(self, dtype)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/p.py"
    },
    {
        "api_name": "power",
        "full_api_name": "PhaseGate.power",
        "api_description": "Raise gate to a power.",
        "api_signature": "power(self, exponent)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/p.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CPhaseGate.__init__",
        "api_description": "Create new CPhase gate.",
        "api_signature": "__init__(self, theta, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/p.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "CPhaseGate._define",
        "api_description": "gate cphase(lambda) a,b\n{ phase(lambda/2) a; cx a,b;\n  phase(-lambda/2) b; cx a,b;\n  phase(lambda/2) b;\n}",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/p.py"
    },
    {
        "api_name": "control",
        "full_api_name": "CPhaseGate.control",
        "api_description": "Controlled version of this gate.\n\nArgs:\n    num_ctrl_qubits (int): number of control qubits.\n    label (str or None): An optional label for the gate [Default: None]\n    ctrl_state (int or str or None): control state expressed as integer,\n        string (e.g. '110'), or None. If None, use all 1s.\n\nReturns:\n    ControlledGate: controlled version of this gate.",
        "api_signature": "control(self, num_ctrl_qubits, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/p.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "CPhaseGate.inverse",
        "api_description": "Return inverted CPhase gate (:math:`CPhase(\\lambda)^{\\dagger} = CPhase(-\\lambda)`)",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/p.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "CPhaseGate.__array__",
        "api_description": "Return a numpy.array for the CPhase gate.",
        "api_signature": "__array__(self, dtype)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/p.py"
    },
    {
        "api_name": "power",
        "full_api_name": "CPhaseGate.power",
        "api_description": "Raise gate to a power.",
        "api_signature": "power(self, exponent)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/p.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "MCPhaseGate.__init__",
        "api_description": "Create new MCPhase gate.",
        "api_signature": "__init__(self, lam, num_ctrl_qubits, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/p.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "MCPhaseGate._define",
        "api_description": "",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/p.py"
    },
    {
        "api_name": "control",
        "full_api_name": "MCPhaseGate.control",
        "api_description": "Controlled version of this gate.\n\nArgs:\n    num_ctrl_qubits (int): number of control qubits.\n    label (str or None): An optional label for the gate [Default: None]\n    ctrl_state (int or str or None): control state expressed as integer,\n        string (e.g. '110'), or None. If None, use all 1s.\n\nReturns:\n    ControlledGate: controlled version of this gate.",
        "api_signature": "control(self, num_ctrl_qubits, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/p.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "MCPhaseGate.inverse",
        "api_description": "Return inverted MCU1 gate (:math:`MCU1(\\lambda)^{\\dagger} = MCU1(-\\lambda)`)",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/p.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "RYGate.__init__",
        "api_description": "Create new RY gate.",
        "api_signature": "__init__(self, theta, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/ry.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "RYGate._define",
        "api_description": "gate ry(theta) a { r(theta, pi/2) a; }",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/ry.py"
    },
    {
        "api_name": "control",
        "full_api_name": "RYGate.control",
        "api_description": "Return a (multi-)controlled-RY gate.\n\nArgs:\n    num_ctrl_qubits (int): number of control qubits.\n    label (str or None): An optional label for the gate [Default: None]\n    ctrl_state (int or str or None): control state expressed as integer,\n        string (e.g. '110'), or None. If None, use all 1s.\n\nReturns:\n    ControlledGate: controlled version of this gate.",
        "api_signature": "control(self, num_ctrl_qubits, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/ry.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "RYGate.inverse",
        "api_description": "Return inverted RY gate.\n\n:math:`RY(\\lambda)^{\\dagger} = RY(-\\lambda)`",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/ry.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "RYGate.__array__",
        "api_description": "Return a numpy.array for the RY gate.",
        "api_signature": "__array__(self, dtype)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/ry.py"
    },
    {
        "api_name": "power",
        "full_api_name": "RYGate.power",
        "api_description": "Raise gate to a power.",
        "api_signature": "power(self, exponent)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/ry.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CRYGate.__init__",
        "api_description": "Create new CRY gate.",
        "api_signature": "__init__(self, theta, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/ry.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "CRYGate._define",
        "api_description": "gate cry(lambda) a,b\n{ u3(lambda/2,0,0) b; cx a,b;\n  u3(-lambda/2,0,0) b; cx a,b;\n}",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/ry.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "CRYGate.inverse",
        "api_description": "Return inverse CRY gate (i.e. with the negative rotation angle).",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/ry.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "CRYGate.__array__",
        "api_description": "Return a numpy.array for the CRY gate.",
        "api_signature": "__array__(self, dtype)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/ry.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "XGate.__init__",
        "api_description": "Create new X gate.",
        "api_signature": "__init__(self, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "XGate._define",
        "api_description": "gate x a { u3(pi,0,pi) a; }",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "control",
        "full_api_name": "XGate.control",
        "api_description": "Return a (multi-)controlled-X gate.\n\nOne control returns a CX gate. Two controls returns a CCX gate.\n\nArgs:\n    num_ctrl_qubits (int): number of control qubits.\n    label (str or None): An optional label for the gate [Default: None]\n    ctrl_state (int or str or None): control state expressed as integer,\n        string (e.g. '110'), or None. If None, use all 1s.\n\nReturns:\n    ControlledGate: controlled version of this gate.",
        "api_signature": "control(self, num_ctrl_qubits, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "XGate.inverse",
        "api_description": "Return inverted X gate (itself).",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CXGate.__init__",
        "api_description": "Create new CX gate.",
        "api_signature": "__init__(self, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "control",
        "full_api_name": "CXGate.control",
        "api_description": "Return a controlled-X gate with more control lines.\n\nArgs:\n    num_ctrl_qubits (int): number of control qubits.\n    label (str or None): An optional label for the gate [Default: None]\n    ctrl_state (int or str or None): control state expressed as integer,\n        string (e.g. '110'), or None. If None, use all 1s.\n\nReturns:\n    ControlledGate: controlled version of this gate.",
        "api_signature": "control(self, num_ctrl_qubits, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "CXGate.inverse",
        "api_description": "Return inverted CX gate (itself).",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CCXGate.__init__",
        "api_description": "Create new CCX gate.",
        "api_signature": "__init__(self, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "CCXGate._define",
        "api_description": "gate ccx a,b,c\n{\nh c; cx b,c; tdg c; cx a,c;\nt c; cx b,c; tdg c; cx a,c;\nt b; t c; h c; cx a,b;\nt a; tdg b; cx a,b;}",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "control",
        "full_api_name": "CCXGate.control",
        "api_description": "Controlled version of this gate.\n\nArgs:\n    num_ctrl_qubits (int): number of control qubits.\n    label (str or None): An optional label for the gate [Default: None]\n    ctrl_state (int or str or None): control state expressed as integer,\n        string (e.g. '110'), or None. If None, use all 1s.\n\nReturns:\n    ControlledGate: controlled version of this gate.",
        "api_signature": "control(self, num_ctrl_qubits, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "CCXGate.inverse",
        "api_description": "Return an inverted CCX gate (also a CCX).",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "RCCXGate.__init__",
        "api_description": "Create a new simplified CCX gate.",
        "api_signature": "__init__(self, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "RCCXGate._define",
        "api_description": "gate rccx a,b,c\n{ u2(0,pi) c;\n  u1(pi/4) c;\n  cx b, c;\n  u1(-pi/4) c;\n  cx a, c;\n  u1(pi/4) c;\n  cx b, c;\n  u1(-pi/4) c;\n  u2(0,pi) c;\n}",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "C3SXGate.__init__",
        "api_description": "Create a new 3-qubit controlled sqrt-X gate.\n\nArgs:\n    label (str or None): An optional label for the gate [Default: None]\n    ctrl_state (int or str or None): control state expressed as integer,\n        string (e.g. '110'), or None. If None, use all 1s.",
        "api_signature": "__init__(self, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "C3SXGate._define",
        "api_description": "gate c3sqrtx a,b,c,d\n{\n    h d; cu1(pi/8) a,d; h d;\n    cx a,b;\n    h d; cu1(-pi/8) b,d; h d;\n    cx a,b;\n    h d; cu1(pi/8) b,d; h d;\n    cx b,c;\n    h d; cu1(-pi/8) c,d; h d;\n    cx a,c;\n    h d; cu1(pi/8) c,d; h d;\n    cx b,c;\n    h d; cu1(-pi/8) c,d; h d;\n    cx a,c;\n    h d; cu1(pi/8) c,d; h d;\n}",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "qasm",
        "full_api_name": "C3SXGate.qasm",
        "api_description": "",
        "api_signature": "qasm(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "C3XGate.__init__",
        "api_description": "Create a new 3-qubit controlled X gate.",
        "api_signature": "__init__(self, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "C3XGate._define",
        "api_description": "gate c3x a,b,c,d\n{\n    h d;\n    p(pi/8) a;\n    p(pi/8) b;\n    p(pi/8) c;\n    p(pi/8) d;\n    cx a, b;\n    p(-pi/8) b;\n    cx a, b;\n    cx b, c;\n    p(-pi/8) c;\n    cx a, c;\n    p(pi/8) c;\n    cx b, c;\n    p(-pi/8) c;\n    cx a, c;\n    cx c, d;\n    p(-pi/8) d;\n    cx b, d;\n    p(pi/8) d;\n    cx c, d;\n    p(-pi/8) d;\n    cx a, d;\n    p(pi/8) d;\n    cx c, d;\n    p(-pi/8) d;\n    cx b, d;\n    p(pi/8) d;\n    cx c, d;\n    p(-pi/8) d;\n    cx a, d;\n    h d;\n}",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "control",
        "full_api_name": "C3XGate.control",
        "api_description": "Controlled version of this gate.\n\nArgs:\n    num_ctrl_qubits (int): number of control qubits.\n    label (str or None): An optional label for the gate [Default: None]\n    ctrl_state (int or str or None): control state expressed as integer,\n        string (e.g. '110'), or None. If None, use all 1s.\n\nReturns:\n    ControlledGate: controlled version of this gate.",
        "api_signature": "control(self, num_ctrl_qubits, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "C3XGate.inverse",
        "api_description": "Invert this gate. The C4X is its own inverse.",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "RC3XGate.__init__",
        "api_description": "Create a new RC3X gate.",
        "api_signature": "__init__(self, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "RC3XGate._define",
        "api_description": "gate rc3x a,b,c,d\n{ u2(0,pi) d;\n  u1(pi/4) d;\n  cx c,d;\n  u1(-pi/4) d;\n  u2(0,pi) d;\n  cx a,d;\n  u1(pi/4) d;\n  cx b,d;\n  u1(-pi/4) d;\n  cx a,d;\n  u1(pi/4) d;\n  cx b,d;\n  u1(-pi/4) d;\n  u2(0,pi) d;\n  u1(pi/4) d;\n  cx c,d;\n  u1(-pi/4) d;\n  u2(0,pi) d;\n}",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "C4XGate.__init__",
        "api_description": "Create a new 4-qubit controlled X gate.",
        "api_signature": "__init__(self, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "C4XGate._define",
        "api_description": "gate c3sqrtx a,b,c,d\n{\n    h d; cu1(pi/8) a,d; h d;\n    cx a,b;\n    h d; cu1(-pi/8) b,d; h d;\n    cx a,b;\n    h d; cu1(pi/8) b,d; h d;\n    cx b,c;\n    h d; cu1(-pi/8) c,d; h d;\n    cx a,c;\n    h d; cu1(pi/8) c,d; h d;\n    cx b,c;\n    h d; cu1(-pi/8) c,d; h d;\n    cx a,c;\n    h d; cu1(pi/8) c,d; h d;\n}\ngate c4x a,b,c,d,e\n{\n    h e; cu1(pi/2) d,e; h e;\n    rc3x a,b,c,d;\n    h e; cu1(-pi/2) d,e; h e;\n    rc3x a,b,c,d;\n    c3sqrtx a,b,c,e;\n}",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "control",
        "full_api_name": "C4XGate.control",
        "api_description": "Controlled version of this gate.\n\nArgs:\n    num_ctrl_qubits (int): number of control qubits.\n    label (str or None): An optional label for the gate [Default: None]\n    ctrl_state (int or str or None): control state expressed as integer,\n        string (e.g. '110'), or None. If None, use all 1s.\n\nReturns:\n    ControlledGate: controlled version of this gate.",
        "api_signature": "control(self, num_ctrl_qubits, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "C4XGate.inverse",
        "api_description": "Invert this gate. The C4X is its own inverse.",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "__new__",
        "full_api_name": "MCXGate.__new__",
        "api_description": "Create a new MCX instance.\n\nDepending on the number of controls and which mode of the MCX, this creates an\nexplicit CX, CCX, C3X or C4X instance or a generic MCX gate.",
        "api_signature": "__new__(cls, num_ctrl_qubits, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "MCXGate.__init__",
        "api_description": "Create new MCX gate.",
        "api_signature": "__init__(self, num_ctrl_qubits, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "MCXGate.inverse",
        "api_description": "Invert this gate. The MCX is its own inverse.",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "get_num_ancilla_qubits",
        "full_api_name": "MCXGate.get_num_ancilla_qubits",
        "api_description": "Get the number of required ancilla qubits without instantiating the class.\n\nThis staticmethod might be necessary to check the number of ancillas before\ncreating the gate, or to use the number of ancillas in the initialization.",
        "api_signature": "get_num_ancilla_qubits(num_ctrl_qubits, mode)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "MCXGate._define",
        "api_description": "The standard definition used the Gray code implementation.",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "num_ancilla_qubits",
        "full_api_name": "MCXGate.num_ancilla_qubits",
        "api_description": "The number of ancilla qubits.",
        "api_signature": "num_ancilla_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "control",
        "full_api_name": "MCXGate.control",
        "api_description": "Return a multi-controlled-X gate with more control lines.\n\nArgs:\n    num_ctrl_qubits (int): number of control qubits.\n    label (str or None): An optional label for the gate [Default: None]\n    ctrl_state (int or str or None): control state expressed as integer,\n        string (e.g. '110'), or None. If None, use all 1s.\n\nReturns:\n    ControlledGate: controlled version of this gate.",
        "api_signature": "control(self, num_ctrl_qubits, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "__new__",
        "full_api_name": "MCXGrayCode.__new__",
        "api_description": "Create a new MCXGrayCode instance",
        "api_signature": "__new__(cls, num_ctrl_qubits, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "MCXGrayCode.__init__",
        "api_description": "",
        "api_signature": "__init__(self, num_ctrl_qubits, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "MCXGrayCode.inverse",
        "api_description": "Invert this gate. The MCX is its own inverse.",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "MCXGrayCode._define",
        "api_description": "Define the MCX gate using the Gray code.",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "MCXRecursive.__init__",
        "api_description": "",
        "api_signature": "__init__(self, num_ctrl_qubits, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "get_num_ancilla_qubits",
        "full_api_name": "MCXRecursive.get_num_ancilla_qubits",
        "api_description": "Get the number of required ancilla qubits.",
        "api_signature": "get_num_ancilla_qubits(num_ctrl_qubits, mode)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "MCXRecursive.inverse",
        "api_description": "Invert this gate. The MCX is its own inverse.",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "MCXRecursive._define",
        "api_description": "Define the MCX gate using recursion.",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "_recurse",
        "full_api_name": "MCXRecursive._recurse",
        "api_description": "",
        "api_signature": "_recurse(self, q, q_ancilla)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "__new__",
        "full_api_name": "MCXVChain.__new__",
        "api_description": "Create a new MCX instance.\n\nThis must be defined anew to include the additional argument ``dirty_ancillas``.",
        "api_signature": "__new__(cls, num_ctrl_qubits, dirty_ancillas, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "MCXVChain.__init__",
        "api_description": "",
        "api_signature": "__init__(self, num_ctrl_qubits, dirty_ancillas, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "MCXVChain.inverse",
        "api_description": "Invert this gate. The MCX is its own inverse.",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "get_num_ancilla_qubits",
        "full_api_name": "MCXVChain.get_num_ancilla_qubits",
        "api_description": "Get the number of required ancilla qubits.",
        "api_signature": "get_num_ancilla_qubits(num_ctrl_qubits, mode)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "MCXVChain._define",
        "api_description": "Define the MCX gate using a V-chain of CX gates.",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SGate.__init__",
        "api_description": "Create new S gate.",
        "api_signature": "__init__(self, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/s.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "SGate._define",
        "api_description": "gate s a { u1(pi/2) a; }",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/s.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "SGate.inverse",
        "api_description": "Return inverse of S (SdgGate).",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/s.py"
    },
    {
        "api_name": "power",
        "full_api_name": "SGate.power",
        "api_description": "Raise gate to a power.",
        "api_signature": "power(self, exponent)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/s.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SdgGate.__init__",
        "api_description": "Create new Sdg gate.",
        "api_signature": "__init__(self, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/s.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "SdgGate._define",
        "api_description": "gate sdg a { u1(-pi/2) a; }",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/s.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "SdgGate.inverse",
        "api_description": "Return inverse of Sdg (SGate).",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/s.py"
    },
    {
        "api_name": "power",
        "full_api_name": "SdgGate.power",
        "api_description": "Raise gate to a power.",
        "api_signature": "power(self, exponent)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/s.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CSGate.__init__",
        "api_description": "Create new CS gate.",
        "api_signature": "__init__(self, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/s.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "CSGate._define",
        "api_description": "gate cs a,b { h b; cp(pi/2) a,b; h b; }",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/s.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "CSGate.inverse",
        "api_description": "Return inverse of CSGate (CSdgGate).",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/s.py"
    },
    {
        "api_name": "power",
        "full_api_name": "CSGate.power",
        "api_description": "Raise gate to a power.",
        "api_signature": "power(self, exponent)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/s.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CSdgGate.__init__",
        "api_description": "Create new CSdg gate.",
        "api_signature": "__init__(self, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/s.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "CSdgGate._define",
        "api_description": "gate csdg a,b { h b; cp(-pi/2) a,b; h b; }",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/s.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "CSdgGate.inverse",
        "api_description": "Return inverse of CSdgGate (CSGate).",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/s.py"
    },
    {
        "api_name": "power",
        "full_api_name": "CSdgGate.power",
        "api_description": "Raise gate to a power.",
        "api_signature": "power(self, exponent)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/s.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "RZZGate.__init__",
        "api_description": "Create new RZZ gate.",
        "api_signature": "__init__(self, theta, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rzz.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "RZZGate._define",
        "api_description": "gate rzz(theta) a, b { cx a, b; u1(theta) b; cx a, b; }",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rzz.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "RZZGate.inverse",
        "api_description": "Return inverse RZZ gate (i.e. with the negative rotation angle).",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rzz.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "RZZGate.__array__",
        "api_description": "Return a numpy.array for the RZZ gate.",
        "api_signature": "__array__(self, dtype)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rzz.py"
    },
    {
        "api_name": "power",
        "full_api_name": "RZZGate.power",
        "api_description": "Raise gate to a power.",
        "api_signature": "power(self, exponent)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rzz.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "RGate.__init__",
        "api_description": "Create new r single-qubit gate.",
        "api_signature": "__init__(self, theta, phi, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/r.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "RGate._define",
        "api_description": "gate r(\u03b8, \u03c6) a {u3(\u03b8, \u03c6 - \u03c0/2, -\u03c6 + \u03c0/2) a;}",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/r.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "RGate.inverse",
        "api_description": "Invert this gate.\n\nr(\u03b8, \u03c6)^dagger = r(-\u03b8, \u03c6)",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/r.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "RGate.__array__",
        "api_description": "Return a numpy.array for the R gate.",
        "api_signature": "__array__(self, dtype)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/r.py"
    },
    {
        "api_name": "power",
        "full_api_name": "RGate.power",
        "api_description": "Raise gate to a power.",
        "api_signature": "power(self, exponent)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/r.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "iSwapGate.__init__",
        "api_description": "Create new iSwap gate.",
        "api_signature": "__init__(self, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/iswap.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "iSwapGate._define",
        "api_description": "gate iswap a,b {\n    s q[0];\n    s q[1];\n    h q[0];\n    cx q[0],q[1];\n    cx q[1],q[0];\n    h q[1];\n}",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/iswap.py"
    },
    {
        "api_name": "power",
        "full_api_name": "iSwapGate.power",
        "api_description": "Raise gate to a power.",
        "api_signature": "power(self, exponent)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/iswap.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "RYYGate.__init__",
        "api_description": "Create new RYY gate.",
        "api_signature": "__init__(self, theta, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/ryy.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "RYYGate._define",
        "api_description": "Calculate a subcircuit that implements this unitary.",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/ryy.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "RYYGate.inverse",
        "api_description": "Return inverse RYY gate (i.e. with the negative rotation angle).",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/ryy.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "RYYGate.__array__",
        "api_description": "Return a numpy.array for the RYY gate.",
        "api_signature": "__array__(self, dtype)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/ryy.py"
    },
    {
        "api_name": "power",
        "full_api_name": "RYYGate.power",
        "api_description": "Raise gate to a power.",
        "api_signature": "power(self, exponent)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/ryy.py"
    },
    {
        "api_name": "_apply_cu",
        "full_api_name": "_apply_cu",
        "api_description": "",
        "api_signature": "_apply_cu(circuit, theta, phi, lam, control, target, use_basis_gates)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/multi_control_rotation_gates.py"
    },
    {
        "api_name": "_apply_mcu_graycode",
        "full_api_name": "_apply_mcu_graycode",
        "api_description": "Apply multi-controlled u gate from ctls to tgt using graycode\npattern with single-step angles theta, phi, lam.",
        "api_signature": "_apply_mcu_graycode(circuit, theta, phi, lam, ctls, tgt, use_basis_gates)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/multi_control_rotation_gates.py"
    },
    {
        "api_name": "_mcsu2_real_diagonal",
        "full_api_name": "_mcsu2_real_diagonal",
        "api_description": "Return a multi-controlled SU(2) gate [1]_ with a real main diagonal or secondary diagonal.\n\nArgs:\n    unitary: SU(2) unitary matrix with one real diagonal.\n    num_controls: The number of control qubits.\n    ctrl_state: The state on which the SU(2) operation is controlled. Defaults to all\n        control qubits being in state 1.\n    use_basis_gates: If ``True``, use ``[p, u, cx]`` gates to implement the decomposition.\n\nReturns:\n    A :class:`.QuantumCircuit` implementing the multi-controlled SU(2) gate.\n\nRaises:\n    QiskitError: If the input matrix is invalid.\n\nReferences:\n\n    .. [1]: R. Vale et al. Decomposition of Multi-controlled Special Unitary Single-Qubit Gates\n        `arXiv:2302.06377 (2023) <https://arxiv.org/abs/2302.06377>`__",
        "api_signature": "_mcsu2_real_diagonal(unitary, num_controls, ctrl_state, use_basis_gates)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/multi_control_rotation_gates.py"
    },
    {
        "api_name": "mcrx",
        "full_api_name": "mcrx",
        "api_description": "Apply Multiple-Controlled X rotation gate\n\nArgs:\n    self (QuantumCircuit): The QuantumCircuit object to apply the mcrx gate on.\n    theta (float): angle theta\n    q_controls (QuantumRegister or list(Qubit)): The list of control qubits\n    q_target (Qubit): The target qubit\n    use_basis_gates (bool): use p, u, cx\n\nRaises:\n    QiskitError: parameter errors",
        "api_signature": "mcrx(self, theta, q_controls, q_target, use_basis_gates)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/multi_control_rotation_gates.py"
    },
    {
        "api_name": "mcry",
        "full_api_name": "mcry",
        "api_description": "Apply Multiple-Controlled Y rotation gate\n\nArgs:\n    self (QuantumCircuit): The QuantumCircuit object to apply the mcry gate on.\n    theta (float): angle theta\n    q_controls (list(Qubit)): The list of control qubits\n    q_target (Qubit): The target qubit\n    q_ancillae (QuantumRegister or tuple(QuantumRegister, int)): The list of ancillary qubits.\n    mode (string): The implementation mode to use\n    use_basis_gates (bool): use p, u, cx\n\nRaises:\n    QiskitError: parameter errors",
        "api_signature": "mcry(self, theta, q_controls, q_target, q_ancillae, mode, use_basis_gates)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/multi_control_rotation_gates.py"
    },
    {
        "api_name": "mcrz",
        "full_api_name": "mcrz",
        "api_description": "Apply Multiple-Controlled Z rotation gate\n\nArgs:\n    self (QuantumCircuit): The QuantumCircuit object to apply the mcrz gate on.\n    lam (float): angle lambda\n    q_controls (list(Qubit)): The list of control qubits\n    q_target (Qubit): The target qubit\n    use_basis_gates (bool): use p, u, cx\n\nRaises:\n    QiskitError: parameter errors",
        "api_signature": "mcrz(self, lam, q_controls, q_target, use_basis_gates)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/multi_control_rotation_gates.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "RXGate.__init__",
        "api_description": "Create new RX gate.",
        "api_signature": "__init__(self, theta, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rx.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "RXGate._define",
        "api_description": "gate rx(theta) a {r(theta, 0) a;}",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rx.py"
    },
    {
        "api_name": "control",
        "full_api_name": "RXGate.control",
        "api_description": "Return a (multi-)controlled-RX gate.\n\nArgs:\n    num_ctrl_qubits (int): number of control qubits.\n    label (str or None): An optional label for the gate [Default: None]\n    ctrl_state (int or str or None): control state expressed as integer,\n        string (e.g. '110'), or None. If None, use all 1s.\n\nReturns:\n    ControlledGate: controlled version of this gate.",
        "api_signature": "control(self, num_ctrl_qubits, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rx.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "RXGate.inverse",
        "api_description": "Return inverted RX gate.\n\n:math:`RX(\\lambda)^{\\dagger} = RX(-\\lambda)`",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rx.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "RXGate.__array__",
        "api_description": "Return a numpy.array for the RX gate.",
        "api_signature": "__array__(self, dtype)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rx.py"
    },
    {
        "api_name": "power",
        "full_api_name": "RXGate.power",
        "api_description": "Raise gate to a power.",
        "api_signature": "power(self, exponent)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rx.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CRXGate.__init__",
        "api_description": "Create new CRX gate.",
        "api_signature": "__init__(self, theta, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rx.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "CRXGate._define",
        "api_description": "gate cu3(theta,phi,lambda) c, t\n{ u1(pi/2) t;\n  cx c,t;\n  u3(-theta/2,0,0) t;\n  cx c,t;\n  u3(theta/2,-pi/2,0) t;\n}",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rx.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "CRXGate.inverse",
        "api_description": "Return inverse CRX gate (i.e. with the negative rotation angle).",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rx.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "CRXGate.__array__",
        "api_description": "Return a numpy.array for the CRX gate.",
        "api_signature": "__array__(self, dtype)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rx.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "U1Gate.__init__",
        "api_description": "Create new U1 gate.",
        "api_signature": "__init__(self, theta, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u1.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "U1Gate._define",
        "api_description": "",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u1.py"
    },
    {
        "api_name": "control",
        "full_api_name": "U1Gate.control",
        "api_description": "Return a (multi-)controlled-U1 gate.\n\nArgs:\n    num_ctrl_qubits (int): number of control qubits.\n    label (str or None): An optional label for the gate [Default: None]\n    ctrl_state (int or str or None): control state expressed as integer,\n        string (e.g. '110'), or None. If None, use all 1s.\n\nReturns:\n    ControlledGate: controlled version of this gate.",
        "api_signature": "control(self, num_ctrl_qubits, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u1.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "U1Gate.inverse",
        "api_description": "Return inverted U1 gate (:math:`U1(\\lambda)^{\\dagger} = U1(-\\lambda)`)",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u1.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "U1Gate.__array__",
        "api_description": "Return a numpy.array for the U1 gate.",
        "api_signature": "__array__(self, dtype)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u1.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CU1Gate.__init__",
        "api_description": "Create new CU1 gate.",
        "api_signature": "__init__(self, theta, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u1.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "CU1Gate._define",
        "api_description": "gate cu1(lambda) a,b\n{ u1(lambda/2) a; cx a,b;\n  u1(-lambda/2) b; cx a,b;\n  u1(lambda/2) b;\n}",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u1.py"
    },
    {
        "api_name": "control",
        "full_api_name": "CU1Gate.control",
        "api_description": "Controlled version of this gate.\n\nArgs:\n    num_ctrl_qubits (int): number of control qubits.\n    label (str or None): An optional label for the gate [Default: None]\n    ctrl_state (int or str or None): control state expressed as integer,\n        string (e.g. '110'), or None. If None, use all 1s.\n\nReturns:\n    ControlledGate: controlled version of this gate.",
        "api_signature": "control(self, num_ctrl_qubits, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u1.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "CU1Gate.inverse",
        "api_description": "Return inverted CU1 gate (:math:`CU1(\\lambda)^{\\dagger} = CU1(-\\lambda)`)",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u1.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "CU1Gate.__array__",
        "api_description": "Return a numpy.array for the CU1 gate.",
        "api_signature": "__array__(self, dtype)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u1.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "MCU1Gate.__init__",
        "api_description": "Create new MCU1 gate.",
        "api_signature": "__init__(self, lam, num_ctrl_qubits, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u1.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "MCU1Gate._define",
        "api_description": "",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u1.py"
    },
    {
        "api_name": "control",
        "full_api_name": "MCU1Gate.control",
        "api_description": "Controlled version of this gate.\n\nArgs:\n    num_ctrl_qubits (int): number of control qubits.\n    label (str or None): An optional label for the gate [Default: None]\n    ctrl_state (int or str or None): control state expressed as integer,\n        string (e.g. '110'), or None. If None, use all 1s.\n\nReturns:\n    ControlledGate: controlled version of this gate.",
        "api_signature": "control(self, num_ctrl_qubits, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u1.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "MCU1Gate.inverse",
        "api_description": "Return inverted MCU1 gate (:math:`MCU1(\\lambda)^{\\dagger} = MCU1(-\\lambda)`)",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u1.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "GlobalPhaseGate.__init__",
        "api_description": "Args:\n    phase: The value of phase it takes.\n    label: An optional label for the gate.",
        "api_signature": "__init__(self, phase, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/global_phase.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "GlobalPhaseGate._define",
        "api_description": "",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/global_phase.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "GlobalPhaseGate.inverse",
        "api_description": "Return inverted GLobalPhaseGate gate.\n\n:math:`\\text{GlobalPhaseGate}(\\lambda)^{\\dagger} = \\text{GlobalPhaseGate}(-\\lambda)`",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/global_phase.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "GlobalPhaseGate.__array__",
        "api_description": "Return a numpy.array for the global_phase gate.",
        "api_signature": "__array__(self, dtype)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/global_phase.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SwapGate.__init__",
        "api_description": "Create new SWAP gate.",
        "api_signature": "__init__(self, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/swap.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "SwapGate._define",
        "api_description": "gate swap a,b { cx a,b; cx b,a; cx a,b; }",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/swap.py"
    },
    {
        "api_name": "control",
        "full_api_name": "SwapGate.control",
        "api_description": "Return a (multi-)controlled-SWAP gate.\n\nOne control returns a CSWAP (Fredkin) gate.\n\nArgs:\n    num_ctrl_qubits (int): number of control qubits.\n    label (str or None): An optional label for the gate [Default: None]\n    ctrl_state (int or str or None): control state expressed as integer,\n        string (e.g. '110'), or None. If None, use all 1s.\n\nReturns:\n    ControlledGate: controlled version of this gate.",
        "api_signature": "control(self, num_ctrl_qubits, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/swap.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "SwapGate.inverse",
        "api_description": "Return inverse Swap gate (itself).",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/swap.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CSwapGate.__init__",
        "api_description": "Create new CSWAP gate.",
        "api_signature": "__init__(self, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/swap.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "CSwapGate._define",
        "api_description": "gate cswap a,b,c\n{ cx c,b;\n  ccx a,b,c;\n  cx c,b;\n}",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/swap.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "CSwapGate.inverse",
        "api_description": "Return inverse CSwap gate (itself).",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/swap.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "U3Gate.__init__",
        "api_description": "Create new U3 gate.",
        "api_signature": "__init__(self, theta, phi, lam, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u3.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "U3Gate.inverse",
        "api_description": "Return inverted U3 gate.\n\n:math:`U3(\\theta,\\phi,\\lambda)^{\\dagger} =U3(-\\theta,-\\lambda,-\\phi)`)",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u3.py"
    },
    {
        "api_name": "control",
        "full_api_name": "U3Gate.control",
        "api_description": "Return a (multi-)controlled-U3 gate.\n\nArgs:\n    num_ctrl_qubits (int): number of control qubits.\n    label (str or None): An optional label for the gate [Default: None]\n    ctrl_state (int or str or None): control state expressed as integer,\n        string (e.g. '110'), or None. If None, use all 1s.\n\nReturns:\n    ControlledGate: controlled version of this gate.",
        "api_signature": "control(self, num_ctrl_qubits, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u3.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "U3Gate._define",
        "api_description": "",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u3.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "U3Gate.__array__",
        "api_description": "Return a Numpy.array for the U3 gate.",
        "api_signature": "__array__(self, dtype)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u3.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CU3Gate.__init__",
        "api_description": "Create new CU3 gate.",
        "api_signature": "__init__(self, theta, phi, lam, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u3.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "CU3Gate._define",
        "api_description": "gate cu3(theta,phi,lambda) c, t\n{ u1((lambda+phi)/2) c;\n  u1((lambda-phi)/2) t;\n  cx c,t;\n  u3(-theta/2,0,-(phi+lambda)/2) t;\n  cx c,t;\n  u3(theta/2,phi,0) t;\n}",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u3.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "CU3Gate.inverse",
        "api_description": "Return inverted CU3 gate.\n\n:math:`CU3(\\theta,\\phi,\\lambda)^{\\dagger} =CU3(-\\theta,-\\phi,-\\lambda)`)",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u3.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "CU3Gate.__array__",
        "api_description": "Return a numpy.array for the CU3 gate.",
        "api_signature": "__array__(self, dtype)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u3.py"
    },
    {
        "api_name": "_generate_gray_code",
        "full_api_name": "_generate_gray_code",
        "api_description": "Generate the gray code for ``num_bits`` bits.",
        "api_signature": "_generate_gray_code(num_bits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u3.py"
    },
    {
        "api_name": "_gray_code_chain",
        "full_api_name": "_gray_code_chain",
        "api_description": "Apply the gate to the last qubit in the register ``q``, controlled on all\npreceding qubits. This function uses the gray code to propagate down to the last qubit.\n\nPorted and adapted from Aqua (github.com/Qiskit/qiskit-aqua),\ncommit 769ca8d, file qiskit/aqua/circuits/gates/multi_control_u1_gate.py.",
        "api_signature": "_gray_code_chain(q, num_ctrl_qubits, gate)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u3.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "TGate.__init__",
        "api_description": "Create new T gate.",
        "api_signature": "__init__(self, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/t.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "TGate._define",
        "api_description": "gate t a { u1(pi/4) a; }",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/t.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "TGate.inverse",
        "api_description": "Return inverse T gate (i.e. Tdg).",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/t.py"
    },
    {
        "api_name": "power",
        "full_api_name": "TGate.power",
        "api_description": "Raise gate to a power.",
        "api_signature": "power(self, exponent)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/t.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "TdgGate.__init__",
        "api_description": "Create new Tdg gate.",
        "api_signature": "__init__(self, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/t.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "TdgGate._define",
        "api_description": "gate tdg a { u1(pi/4) a; }",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/t.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "TdgGate.inverse",
        "api_description": "Return inverse Tdg gate (i.e. T).",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/t.py"
    },
    {
        "api_name": "power",
        "full_api_name": "TdgGate.power",
        "api_description": "Raise gate to a power.",
        "api_signature": "power(self, exponent)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/t.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "IGate.__init__",
        "api_description": "Create new Identity gate.",
        "api_signature": "__init__(self, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/i.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "IGate.inverse",
        "api_description": "Invert this gate.",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/i.py"
    },
    {
        "api_name": "power",
        "full_api_name": "IGate.power",
        "api_description": "Raise gate to a power.",
        "api_signature": "power(self, exponent)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/i.py"
    },
    {
        "api_name": "get_standard_gate_name_mapping",
        "full_api_name": "get_standard_gate_name_mapping",
        "api_description": "Return a dictionary mapping the name of standard gates and instructions to an object for\nthat name.",
        "api_signature": "get_standard_gate_name_mapping()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/__init__.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "RZXGate.__init__",
        "api_description": "Create new RZX gate.",
        "api_signature": "__init__(self, theta, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rzx.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "RZXGate._define",
        "api_description": "gate rzx(theta) a, b { h b; cx a, b; u1(theta) b; cx a, b; h b;}",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rzx.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "RZXGate.inverse",
        "api_description": "Return inverse RZX gate (i.e. with the negative rotation angle).",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rzx.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "RZXGate.__array__",
        "api_description": "Return a numpy.array for the RZX gate.",
        "api_signature": "__array__(self, dtype)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rzx.py"
    },
    {
        "api_name": "power",
        "full_api_name": "RZXGate.power",
        "api_description": "Raise gate to a power.",
        "api_signature": "power(self, exponent)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rzx.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SXGate.__init__",
        "api_description": "Create new SX gate.",
        "api_signature": "__init__(self, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/sx.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "SXGate._define",
        "api_description": "gate sx a { rz(-pi/2) a; h a; rz(-pi/2); }",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/sx.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "SXGate.inverse",
        "api_description": "Return inverse SX gate (i.e. SXdg).",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/sx.py"
    },
    {
        "api_name": "control",
        "full_api_name": "SXGate.control",
        "api_description": "Return a (multi-)controlled-SX gate.\n\nOne control returns a CSX gate.\n\nArgs:\n    num_ctrl_qubits (int): number of control qubits.\n    label (str or None): An optional label for the gate [Default: None]\n    ctrl_state (int or str or None): control state expressed as integer,\n        string (e.g. '110'), or None. If None, use all 1s.\n\nReturns:\n    SingletonControlledGate: controlled version of this gate.",
        "api_signature": "control(self, num_ctrl_qubits, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/sx.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SXdgGate.__init__",
        "api_description": "Create new SXdg gate.",
        "api_signature": "__init__(self, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/sx.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "SXdgGate._define",
        "api_description": "gate sxdg a { rz(pi/2) a; h a; rz(pi/2); }",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/sx.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "SXdgGate.inverse",
        "api_description": "Return inverse SXdg gate (i.e. SX).",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/sx.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CSXGate.__init__",
        "api_description": "Create new CSX gate.",
        "api_signature": "__init__(self, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/sx.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "CSXGate._define",
        "api_description": "gate csx a,b { h b; cu1(pi/2) a,b; h b; }",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/sx.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "XXMinusYYGate.__init__",
        "api_description": "Create new XX-YY gate.\n\nArgs:\n    theta: The rotation angle.\n    beta: The phase angle.\n    label: The label of the gate.",
        "api_signature": "__init__(self, theta, beta, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/xx_minus_yy.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "XXMinusYYGate._define",
        "api_description": "gate xx_minus_yy(theta, beta) a, b {\n    rz(-beta) b;\n    rz(-pi/2) a;\n    sx a;\n    rz(pi/2) a;\n    s b;\n    cx a, b;\n    ry(theta/2) a;\n    ry(-theta/2) b;\n    cx a, b;\n    sdg b;\n    rz(-pi/2) a;\n    sxdg a;\n    rz(pi/2) a;\n    rz(beta) b;\n}",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/xx_minus_yy.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "XXMinusYYGate.inverse",
        "api_description": "Inverse gate.",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/xx_minus_yy.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "XXMinusYYGate.__array__",
        "api_description": "Gate matrix.",
        "api_signature": "__array__(self, dtype)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/xx_minus_yy.py"
    },
    {
        "api_name": "power",
        "full_api_name": "XXMinusYYGate.power",
        "api_description": "Raise gate to a power.",
        "api_signature": "power(self, exponent)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/xx_minus_yy.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ECRGate.__init__",
        "api_description": "Create new ECR gate.",
        "api_signature": "__init__(self, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/ecr.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "ECRGate._define",
        "api_description": "gate ecr a, b { rzx(pi/4) a, b; x a; rzx(-pi/4) a, b;}",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/ecr.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "ECRGate.inverse",
        "api_description": "Return inverse ECR gate (itself).",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/ecr.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "YGate.__init__",
        "api_description": "Create new Y gate.",
        "api_signature": "__init__(self, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/y.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "YGate._define",
        "api_description": "",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/y.py"
    },
    {
        "api_name": "control",
        "full_api_name": "YGate.control",
        "api_description": "Return a (multi-)controlled-Y gate.\n\nOne control returns a CY gate.\n\nArgs:\n    num_ctrl_qubits (int): number of control qubits.\n    label (str or None): An optional label for the gate [Default: None]\n    ctrl_state (int or str or None): control state expressed as integer,\n        string (e.g. '110'), or None. If None, use all 1s.\n\nReturns:\n    ControlledGate: controlled version of this gate.",
        "api_signature": "control(self, num_ctrl_qubits, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/y.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "YGate.inverse",
        "api_description": "Return inverted Y gate (:math:`Y^{\\dagger} = Y`)",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/y.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CYGate.__init__",
        "api_description": "Create new CY gate.",
        "api_signature": "__init__(self, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/y.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "CYGate._define",
        "api_description": "gate cy a,b { sdg b; cx a,b; s b; }",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/y.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "CYGate.inverse",
        "api_description": "Return inverted CY gate (itself).",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/y.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "RXXGate.__init__",
        "api_description": "Create new RXX gate.",
        "api_signature": "__init__(self, theta, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rxx.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "RXXGate._define",
        "api_description": "Calculate a subcircuit that implements this unitary.",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rxx.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "RXXGate.inverse",
        "api_description": "Return inverse RXX gate (i.e. with the negative rotation angle).",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rxx.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "RXXGate.__array__",
        "api_description": "Return a Numpy.array for the RXX gate.",
        "api_signature": "__array__(self, dtype)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rxx.py"
    },
    {
        "api_name": "power",
        "full_api_name": "RXXGate.power",
        "api_description": "Raise gate to a power.",
        "api_signature": "power(self, exponent)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rxx.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "XXPlusYYGate.__init__",
        "api_description": "Create new XX+YY gate.\n\nArgs:\n    theta: The rotation angle.\n    beta: The phase angle.\n    label: The label of the gate.",
        "api_signature": "__init__(self, theta, beta, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/xx_plus_yy.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "XXPlusYYGate._define",
        "api_description": "gate xx_plus_yy(theta, beta) a, b {\n    rz(beta) b;\n    rz(-pi/2) a;\n    sx a;\n    rz(pi/2) a;\n    s b;\n    cx a, b;\n    ry(theta/2) a;\n    ry(theta/2) b;\n    cx a, b;\n    sdg b;\n    rz(-pi/2) a;\n    sxdg a;\n    rz(pi/2) a;\n    rz(-beta) b;\n}",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/xx_plus_yy.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "XXPlusYYGate.inverse",
        "api_description": "Return inverse XX+YY gate (i.e. with the negative rotation angle and same phase angle).",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/xx_plus_yy.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "XXPlusYYGate.__array__",
        "api_description": "Return a numpy.array for the XX+YY gate.",
        "api_signature": "__array__(self, dtype)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/xx_plus_yy.py"
    },
    {
        "api_name": "power",
        "full_api_name": "XXPlusYYGate.power",
        "api_description": "Raise gate to a power.",
        "api_signature": "power(self, exponent)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/xx_plus_yy.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QFT.__init__",
        "api_description": "Construct a new QFT circuit.\n\nArgs:\n    num_qubits: The number of qubits on which the QFT acts.\n    approximation_degree: The degree of approximation (0 for no approximation).\n    do_swaps: Whether to include the final swaps in the QFT.\n    inverse: If True, the inverse Fourier transform is constructed.\n    insert_barriers: If True, barriers are inserted as visualization improvement.\n    name: The name of the circuit.",
        "api_signature": "__init__(self, num_qubits, approximation_degree, do_swaps, inverse, insert_barriers, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/basis_change/qft.py"
    },
    {
        "api_name": "num_qubits",
        "full_api_name": "QFT.num_qubits",
        "api_description": "The number of qubits in the QFT circuit.\n\nReturns:\n    The number of qubits in the circuit.",
        "api_signature": "num_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/basis_change/qft.py"
    },
    {
        "api_name": "num_qubits",
        "full_api_name": "QFT.num_qubits",
        "api_description": "Set the number of qubits.\n\nNote that this changes the registers of the circuit.\n\nArgs:\n    num_qubits: The new number of qubits.",
        "api_signature": "num_qubits(self, num_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/basis_change/qft.py"
    },
    {
        "api_name": "approximation_degree",
        "full_api_name": "QFT.approximation_degree",
        "api_description": "The approximation degree of the QFT.\n\nReturns:\n    The currently set approximation degree.",
        "api_signature": "approximation_degree(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/basis_change/qft.py"
    },
    {
        "api_name": "approximation_degree",
        "full_api_name": "QFT.approximation_degree",
        "api_description": "Set the approximation degree of the QFT.\n\nArgs:\n    approximation_degree: The new approximation degree.\n\nRaises:\n    ValueError: If the approximation degree is smaller than 0.",
        "api_signature": "approximation_degree(self, approximation_degree)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/basis_change/qft.py"
    },
    {
        "api_name": "insert_barriers",
        "full_api_name": "QFT.insert_barriers",
        "api_description": "Whether barriers are inserted for better visualization or not.\n\nReturns:\n    True, if barriers are inserted, False if not.",
        "api_signature": "insert_barriers(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/basis_change/qft.py"
    },
    {
        "api_name": "insert_barriers",
        "full_api_name": "QFT.insert_barriers",
        "api_description": "Specify whether barriers are inserted for better visualization or not.\n\nArgs:\n    insert_barriers: If True, barriers are inserted, if False not.",
        "api_signature": "insert_barriers(self, insert_barriers)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/basis_change/qft.py"
    },
    {
        "api_name": "do_swaps",
        "full_api_name": "QFT.do_swaps",
        "api_description": "Whether the final swaps of the QFT are applied or not.\n\nReturns:\n    True, if the final swaps are applied, False if not.",
        "api_signature": "do_swaps(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/basis_change/qft.py"
    },
    {
        "api_name": "do_swaps",
        "full_api_name": "QFT.do_swaps",
        "api_description": "Specify whether to do the final swaps of the QFT circuit or not.\n\nArgs:\n    do_swaps: If True, the final swaps are applied, if False not.",
        "api_signature": "do_swaps(self, do_swaps)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/basis_change/qft.py"
    },
    {
        "api_name": "is_inverse",
        "full_api_name": "QFT.is_inverse",
        "api_description": "Whether the inverse Fourier transform is implemented.\n\nReturns:\n    True, if the inverse Fourier transform is implemented, False otherwise.",
        "api_signature": "is_inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/basis_change/qft.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "QFT.inverse",
        "api_description": "Invert this circuit.\n\nReturns:\n    The inverted circuit.",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/basis_change/qft.py"
    },
    {
        "api_name": "_warn_if_precision_loss",
        "full_api_name": "QFT._warn_if_precision_loss",
        "api_description": "Issue a warning if constructing the circuit will lose precision.\n\nIf we need an angle smaller than ``pi * 2**-1022``, we start to lose precision by going into\nthe subnormal numbers.  We won't lose _all_ precision until an exponent of about 1075, but\nbeyond 1022 we're using fractional bits to represent leading zeros.",
        "api_signature": "_warn_if_precision_loss(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/basis_change/qft.py"
    },
    {
        "api_name": "_check_configuration",
        "full_api_name": "QFT._check_configuration",
        "api_description": "Check if the current configuration is valid.",
        "api_signature": "_check_configuration(self, raise_on_failure)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/basis_change/qft.py"
    },
    {
        "api_name": "_build",
        "full_api_name": "QFT._build",
        "api_description": "If not already built, build the circuit.",
        "api_signature": "_build(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/basis_change/qft.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Initialize.__init__",
        "api_description": "Args:\n    params: The state to initialize to, can be either of the following.\n\n        * Statevector or vector of complex amplitudes to initialize to.\n        * Labels of basis states of the Pauli eigenstates Z, X, Y. See\n          :meth:`.Statevector.from_label`. Notice the order of the labels is reversed with\n          respect to the qubit index to be applied to. Example label '01' initializes the\n          qubit zero to :math:`|1\\rangle` and the qubit one to :math:`|0\\rangle`.\n        * An integer that is used as a bitmap indicating which qubits to initialize to\n          :math:`|1\\rangle`. Example: setting params to 5 would initialize qubit 0 and qubit\n          2 to :math:`|1\\rangle` and qubit 1 to :math:`|0\\rangle`.\n\n    num_qubits: This parameter is only used if params is an int. Indicates the total\n        number of qubits in the `initialize` call. Example: `initialize` covers 5 qubits\n        and params is 3. This allows qubits 0 and 1 to be initialized to :math:`|1\\rangle`\n        and the remaining 3 qubits to be initialized to :math:`|0\\rangle`.\n    normalize: Whether to normalize an input array to a unit vector.",
        "api_signature": "__init__(self, params, num_qubits, normalize)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/initializer.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "Initialize._define",
        "api_description": "",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/initializer.py"
    },
    {
        "api_name": "gates_to_uncompute",
        "full_api_name": "Initialize.gates_to_uncompute",
        "api_description": "Call to create a circuit with gates that take the desired vector to zero.\n\nReturns:\n    Circuit to take ``self.params`` vector to :math:`|{00\\ldots0}\\rangle`",
        "api_signature": "gates_to_uncompute(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/initializer.py"
    },
    {
        "api_name": "params",
        "full_api_name": "Initialize.params",
        "api_description": "Return initialize params.",
        "api_signature": "params(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/initializer.py"
    },
    {
        "api_name": "params",
        "full_api_name": "Initialize.params",
        "api_description": "Set initialize params.",
        "api_signature": "params(self, parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/initializer.py"
    },
    {
        "api_name": "broadcast_arguments",
        "full_api_name": "Initialize.broadcast_arguments",
        "api_description": "",
        "api_signature": "broadcast_arguments(self, qargs, cargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/initializer.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PauliFeatureMap.__init__",
        "api_description": "Create a new Pauli expansion circuit.\n\nArgs:\n    feature_dimension: Number of qubits in the circuit.\n    reps: The number of repeated circuits.\n    entanglement: Specifies the entanglement structure. Refer to\n        :class:`~qiskit.circuit.library.NLocal` for detail.\n    alpha: The Pauli rotation factor, multiplicative to the pauli rotations\n    paulis: A list of strings for to-be-used paulis. If None are provided, ``['Z', 'ZZ']``\n        will be used.\n    data_map_func: A mapping function for data x which can be supplied to override the\n        default mapping from :meth:`self_product`.\n    parameter_prefix: The prefix used if default parameters are generated.\n    insert_barriers: If True, barriers are inserted in between the evolution instructions\n        and hadamard layers.",
        "api_signature": "__init__(self, feature_dimension, reps, entanglement, alpha, paulis, data_map_func, parameter_prefix, insert_barriers, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/pauli_feature_map.py"
    },
    {
        "api_name": "_parameter_generator",
        "full_api_name": "PauliFeatureMap._parameter_generator",
        "api_description": "If certain blocks should use certain parameters this method can be overridden.",
        "api_signature": "_parameter_generator(self, rep, block, indices)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/pauli_feature_map.py"
    },
    {
        "api_name": "num_parameters_settable",
        "full_api_name": "PauliFeatureMap.num_parameters_settable",
        "api_description": "The number of distinct parameters.",
        "api_signature": "num_parameters_settable(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/pauli_feature_map.py"
    },
    {
        "api_name": "paulis",
        "full_api_name": "PauliFeatureMap.paulis",
        "api_description": "The Pauli strings used in the entanglement of the qubits.\n\nReturns:\n    The Pauli strings as list.",
        "api_signature": "paulis(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/pauli_feature_map.py"
    },
    {
        "api_name": "paulis",
        "full_api_name": "PauliFeatureMap.paulis",
        "api_description": "Set the pauli strings.\n\nArgs:\n    paulis: The new pauli strings.",
        "api_signature": "paulis(self, paulis)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/pauli_feature_map.py"
    },
    {
        "api_name": "alpha",
        "full_api_name": "PauliFeatureMap.alpha",
        "api_description": "The Pauli rotation factor (alpha).\n\nReturns:\n    The Pauli rotation factor.",
        "api_signature": "alpha(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/pauli_feature_map.py"
    },
    {
        "api_name": "alpha",
        "full_api_name": "PauliFeatureMap.alpha",
        "api_description": "Set the Pauli rotation factor (alpha).\n\nArgs:\n    alpha: Pauli rotation factor",
        "api_signature": "alpha(self, alpha)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/pauli_feature_map.py"
    },
    {
        "api_name": "entanglement_blocks",
        "full_api_name": "PauliFeatureMap.entanglement_blocks",
        "api_description": "",
        "api_signature": "entanglement_blocks(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/pauli_feature_map.py"
    },
    {
        "api_name": "entanglement_blocks",
        "full_api_name": "PauliFeatureMap.entanglement_blocks",
        "api_description": "",
        "api_signature": "entanglement_blocks(self, entanglement_blocks)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/pauli_feature_map.py"
    },
    {
        "api_name": "feature_dimension",
        "full_api_name": "PauliFeatureMap.feature_dimension",
        "api_description": "Returns the feature dimension (which is equal to the number of qubits).\n\nReturns:\n    The feature dimension of this feature map.",
        "api_signature": "feature_dimension(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/pauli_feature_map.py"
    },
    {
        "api_name": "feature_dimension",
        "full_api_name": "PauliFeatureMap.feature_dimension",
        "api_description": "Set the feature dimension.\n\nArgs:\n    feature_dimension: The new feature dimension.",
        "api_signature": "feature_dimension(self, feature_dimension)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/pauli_feature_map.py"
    },
    {
        "api_name": "_extract_data_for_rotation",
        "full_api_name": "PauliFeatureMap._extract_data_for_rotation",
        "api_description": "",
        "api_signature": "_extract_data_for_rotation(self, pauli, x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/pauli_feature_map.py"
    },
    {
        "api_name": "pauli_block",
        "full_api_name": "PauliFeatureMap.pauli_block",
        "api_description": "Get the Pauli block for the feature map circuit.",
        "api_signature": "pauli_block(self, pauli_string)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/pauli_feature_map.py"
    },
    {
        "api_name": "pauli_evolution",
        "full_api_name": "PauliFeatureMap.pauli_evolution",
        "api_description": "Get the evolution block for the given pauli string.",
        "api_signature": "pauli_evolution(self, pauli_string, time)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/pauli_feature_map.py"
    },
    {
        "api_name": "basis_change",
        "full_api_name": "PauliFeatureMap.basis_change",
        "api_description": "",
        "api_signature": "basis_change(circuit, inverse)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/pauli_feature_map.py"
    },
    {
        "api_name": "cx_chain",
        "full_api_name": "PauliFeatureMap.cx_chain",
        "api_description": "",
        "api_signature": "cx_chain(circuit, inverse)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/pauli_feature_map.py"
    },
    {
        "api_name": "self_product",
        "full_api_name": "self_product",
        "api_description": "Define a function map from R^n to R.\n\nArgs:\n    x: data\n\nReturns:\n    float: the mapped value",
        "api_signature": "self_product(x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/pauli_feature_map.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "StatePreparation.__init__",
        "api_description": "Args:\n    params:\n        * Statevector: Statevector to initialize to.\n        * list: vector of complex amplitudes to initialize to.\n        * string: labels of basis states of the Pauli eigenstates Z, X, Y. See\n          :meth:`.Statevector.from_label`.\n          Notice the order of the labels is reversed with respect to the qubit index to\n          be applied to. Example label '01' initializes the qubit zero to :math:`|1\\rangle`\n          and the qubit one to :math:`|0\\rangle`.\n        * int: an integer that is used as a bitmap indicating which qubits to initialize\n          to :math:`|1\\rangle`. Example: setting params to 5 would initialize qubit 0 and qubit 2\n          to :math:`|1\\rangle` and qubit 1 to :math:`|0\\rangle`.\n    num_qubits: This parameter is only used if params is an int. Indicates the total\n        number of qubits in the `initialize` call. Example: `initialize` covers 5 qubits\n        and params is 3. This allows qubits 0 and 1 to be initialized to :math:`|1\\rangle`\n        and the remaining 3 qubits to be initialized to :math:`|0\\rangle`.\n    inverse: if True, the inverse state is constructed.\n    label: An optional label for the gate\n    normalize (bool): Whether to normalize an input array to a unit vector.\n\nRaises:\n    QiskitError: ``num_qubits`` parameter used when ``params`` is not an integer\n\nWhen a Statevector argument is passed the state is prepared using a recursive\ninitialization algorithm, including optimizations, from [1], as well\nas some additional optimizations including removing zero rotations and double cnots.\n\n**References:**\n[1] Shende, Bullock, Markov. Synthesis of Quantum Logic Circuits (2004)\n[`https://arxiv.org/abs/quant-ph/0406176v5`]",
        "api_signature": "__init__(self, params, num_qubits, inverse, label, normalize)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/state_preparation.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "StatePreparation._define",
        "api_description": "",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/state_preparation.py"
    },
    {
        "api_name": "_define_from_label",
        "full_api_name": "StatePreparation._define_from_label",
        "api_description": "",
        "api_signature": "_define_from_label(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/state_preparation.py"
    },
    {
        "api_name": "_define_from_int",
        "full_api_name": "StatePreparation._define_from_int",
        "api_description": "",
        "api_signature": "_define_from_int(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/state_preparation.py"
    },
    {
        "api_name": "_define_synthesis",
        "full_api_name": "StatePreparation._define_synthesis",
        "api_description": "Calculate a subcircuit that implements this initialization\n\nImplements a recursive initialization algorithm, including optimizations,\nfrom \"Synthesis of Quantum Logic Circuits\" Shende, Bullock, Markov\nhttps://arxiv.org/abs/quant-ph/0406176v5\n\nAdditionally implements some extra optimizations: remove zero rotations and\ndouble cnots.",
        "api_signature": "_define_synthesis(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/state_preparation.py"
    },
    {
        "api_name": "_get_num_qubits",
        "full_api_name": "StatePreparation._get_num_qubits",
        "api_description": "Get number of qubits needed for state preparation",
        "api_signature": "_get_num_qubits(self, num_qubits, params)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/state_preparation.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "StatePreparation.inverse",
        "api_description": "Return inverted StatePreparation",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/state_preparation.py"
    },
    {
        "api_name": "broadcast_arguments",
        "full_api_name": "StatePreparation.broadcast_arguments",
        "api_description": "",
        "api_signature": "broadcast_arguments(self, qargs, cargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/state_preparation.py"
    },
    {
        "api_name": "validate_parameter",
        "full_api_name": "StatePreparation.validate_parameter",
        "api_description": "StatePreparation instruction parameter can be str, int, float, and complex.",
        "api_signature": "validate_parameter(self, parameter)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/state_preparation.py"
    },
    {
        "api_name": "_return_repeat",
        "full_api_name": "StatePreparation._return_repeat",
        "api_description": "",
        "api_signature": "_return_repeat(self, exponent)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/state_preparation.py"
    },
    {
        "api_name": "_gates_to_uncompute",
        "full_api_name": "StatePreparation._gates_to_uncompute",
        "api_description": "Call to create a circuit with gates that take the desired vector to zero.\n\nReturns:\n    QuantumCircuit: circuit to take self.params vector to :math:`|{00\\ldots0}\\rangle`",
        "api_signature": "_gates_to_uncompute(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/state_preparation.py"
    },
    {
        "api_name": "_rotations_to_disentangle",
        "full_api_name": "StatePreparation._rotations_to_disentangle",
        "api_description": "Static internal method to work out Ry and Rz rotation angles used\nto disentangle the LSB qubit.\nThese rotations make up the block diagonal matrix U (i.e. multiplexor)\nthat disentangles the LSB.\n\n[[Ry(theta_1).Rz(phi_1)  0   .   .   0],\n[0         Ry(theta_2).Rz(phi_2) .  0],\n                            .\n                                .\n0         0           Ry(theta_2^n).Rz(phi_2^n)]]",
        "api_signature": "_rotations_to_disentangle(local_param)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/state_preparation.py"
    },
    {
        "api_name": "_bloch_angles",
        "full_api_name": "StatePreparation._bloch_angles",
        "api_description": "Static internal method to work out rotation to create the passed-in\nqubit from the zero vector.",
        "api_signature": "_bloch_angles(pair_of_complex)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/state_preparation.py"
    },
    {
        "api_name": "_multiplex",
        "full_api_name": "StatePreparation._multiplex",
        "api_description": "Return a recursive implementation of a multiplexor circuit,\nwhere each instruction itself has a decomposition based on\nsmaller multiplexors.\n\nThe LSB is the multiplexor \"data\" and the other bits are multiplexor \"select\".\n\nArgs:\n    target_gate (Gate): Ry or Rz gate to apply to target qubit, multiplexed\n        over all other \"select\" qubits\n    list_of_angles (list[float]): list of rotation angles to apply Ry and Rz\n    last_cnot (bool): add the last cnot if last_cnot = True\n\nReturns:\n    DAGCircuit: the circuit implementing the multiplexor's action",
        "api_signature": "_multiplex(self, target_gate, list_of_angles, last_cnot)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/state_preparation.py"
    },
    {
        "api_name": "prepare_state",
        "full_api_name": "prepare_state",
        "api_description": "Prepare qubits in a specific state.\n\nThis class implements a state preparing unitary. Unlike\n:class:`qiskit.extensions.Initialize` it does not reset the qubits first.\n\nArgs:\n    state (str or list or int or Statevector):\n        * Statevector: Statevector to initialize to.\n        * str: labels of basis states of the Pauli eigenstates Z, X, Y. See\n          :meth:`.Statevector.from_label`. Notice the order of the labels is reversed with respect\n          to the qubit index to be applied to. Example label '01' initializes the qubit zero to\n          :math:`|1\\rangle` and the qubit one to :math:`|0\\rangle`.\n        * list: vector of complex amplitudes to initialize to.\n        * int: an integer that is used as a bitmap indicating which qubits to initialize\n          to :math:`|1\\rangle`. Example: setting params to 5 would initialize qubit 0 and qubit 2\n          to :math:`|1\\rangle` and qubit 1 to :math:`|0\\rangle`.\n\n    qubits (QuantumRegister or Qubit or int):\n        * QuantumRegister: A list of qubits to be initialized [Default: None].\n        * Qubit: Single qubit to be initialized [Default: None].\n        * int: Index of qubit to be initialized [Default: None].\n        * list: Indexes of qubits to be initialized [Default: None].\n    label (str): An optional label for the gate\n    normalize (bool): Whether to normalize an input array to a unit vector.\n\nReturns:\n    qiskit.circuit.Instruction: a handle to the instruction that was just initialized\n\nExamples:\n    Prepare a qubit in the state :math:`(|0\\rangle - |1\\rangle) / \\sqrt{2}`.\n\n    .. code-block::\n\n       import numpy as np\n       from qiskit import QuantumCircuit\n\n       circuit = QuantumCircuit(1)\n       circuit.prepare_state([1/np.sqrt(2), -1/np.sqrt(2)], 0)\n       circuit.draw()\n\n    output:\n\n    .. parsed-literal::\n\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_0: \u2524 State Preparation(0.70711,-0.70711) \u251c\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n\n    Prepare from a string two qubits in the state :math:`|10\\rangle`.\n    The order of the labels is reversed with respect to qubit index.\n    More information about labels for basis states are in\n    :meth:`.Statevector.from_label`.\n\n    .. code-block::\n\n        import numpy as np\n        from qiskit import QuantumCircuit\n\n        circuit = QuantumCircuit(2)\n        circuit.prepare_state('01', circuit.qubits)\n        circuit.draw()\n\n    output:\n\n    .. parsed-literal::\n\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_0: \u25240                        \u251c\n             \u2502  State Preparation(0,1) \u2502\n        q_1: \u25241                        \u251c\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n\n    Initialize two qubits from an array of complex amplitudes\n    .. code-block::\n\n        import numpy as np\n        from qiskit import QuantumCircuit\n\n        circuit = QuantumCircuit(2)\n        circuit.prepare_state([0, 1/np.sqrt(2), -1.j/np.sqrt(2), 0], circuit.qubits)\n        circuit.draw()\n\n    output:\n\n    .. parsed-literal::\n\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_0: \u25240                                          \u251c\n             \u2502  State Preparation(0,0.70711,-0.70711j,0) \u2502\n        q_1: \u25241                                          \u251c\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
        "api_signature": "prepare_state(self, state, qubits, label, normalize)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/state_preparation.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ZZFeatureMap.__init__",
        "api_description": "Create a new second-order Pauli-Z expansion.\n\nArgs:\n    feature_dimension: Number of features.\n    reps: The number of repeated circuits, has a min. value of 1.\n    entanglement: Specifies the entanglement structure. Refer to\n        :class:`~qiskit.circuit.library.NLocal` for detail.\n    data_map_func: A mapping function for data x.\n    parameter_prefix: The prefix used if default parameters are generated.\n    insert_barriers: If True, barriers are inserted in between the evolution instructions\n        and hadamard layers.\n\nRaises:\n    ValueError: If the feature dimension is smaller than 2.",
        "api_signature": "__init__(self, feature_dimension, reps, entanglement, data_map_func, parameter_prefix, insert_barriers, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/zz_feature_map.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ZFeatureMap.__init__",
        "api_description": "Create a new first-order Pauli-Z expansion circuit.\n\nArgs:\n    feature_dimension: The number of features\n    reps: The number of repeated circuits. Defaults to 2, has a minimum value of 1.\n    data_map_func: A mapping function for data x which can be supplied to override the\n        default mapping from :meth:`self_product`.\n    parameter_prefix: The prefix used if default parameters are generated.\n    insert_barriers: If True, barriers are inserted in between the evolution instructions\n        and hadamard layers.",
        "api_signature": "__init__(self, feature_dimension, reps, data_map_func, parameter_prefix, insert_barriers, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/z_feature_map.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "OR.__init__",
        "api_description": "Create a new logical OR circuit.\n\nArgs:\n    num_variable_qubits: The qubits of which the OR is computed. The result will be written\n        into an additional result qubit.\n    flags: A list of +1/0/-1 marking negations or omissions of qubits.\n    mcx_mode: The mode to be used to implement the multi-controlled X gate.",
        "api_signature": "__init__(self, num_variable_qubits, flags, mcx_mode)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/boolean_logic/quantum_or.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "AND.__init__",
        "api_description": "Create a new logical AND circuit.\n\nArgs:\n    num_variable_qubits: The qubits of which the OR is computed. The result will be written\n        into an additional result qubit.\n    flags: A list of +1/0/-1 marking negations or omissions of qubits.\n    mcx_mode: The mode to be used to implement the multi-controlled X gate.",
        "api_signature": "__init__(self, num_variable_qubits, flags, mcx_mode)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/boolean_logic/quantum_and.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "InnerProduct.__init__",
        "api_description": "Return a circuit to compute the inner product of 2 n-qubit registers.\n\nArgs:\n    num_qubits: width of top and bottom registers (half total circuit width)",
        "api_signature": "__init__(self, num_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/boolean_logic/inner_product.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "XOR.__init__",
        "api_description": "Return a circuit implementing bitwise xor.\n\nArgs:\n    num_qubits: the width of circuit.\n    amount: the xor amount in decimal form.\n    seed: random seed in case a random xor is requested.\n\nRaises:\n    CircuitError: if the xor bitstring exceeds available qubits.\n\nReference Circuit:\n    .. plot::\n\n       from qiskit.circuit.library import XOR\n       from qiskit.tools.jupyter.library import _generate_circuit_library_visualization\n       circuit = XOR(5, seed=42)\n       _generate_circuit_library_visualization(circuit)",
        "api_signature": "__init__(self, num_qubits, amount, seed)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/boolean_logic/quantum_xor.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "RealAmplitudes.__init__",
        "api_description": "Args:\n    num_qubits: The number of qubits of the RealAmplitudes circuit.\n    reps: Specifies how often the structure of a rotation layer followed by an entanglement\n        layer is repeated.\n    entanglement: Specifies the entanglement structure. Can be a string ('full', 'linear'\n        'reverse_linear, 'circular' or 'sca'), a list of integer-pairs specifying the indices\n        of qubits entangled with one another, or a callable returning such a list provided with\n        the index of the entanglement layer.\n        Default to 'reverse_linear' entanglement.\n        Note that 'reverse_linear' entanglement provides the same unitary as 'full'\n        with fewer entangling gates.\n        See the Examples section of :class:`~qiskit.circuit.library.TwoLocal` for more\n        detail.\n    initial_state: A `QuantumCircuit` object to prepend to the circuit.\n    skip_unentangled_qubits: If True, the single qubit gates are only applied to qubits\n        that are entangled with another qubit. If False, the single qubit gates are applied\n        to each qubit in the Ansatz. Defaults to False.\n    skip_unentangled_qubits: If True, the single qubit gates are only applied to qubits\n        that are entangled with another qubit. If False, the single qubit gates are applied\n        to each qubit in the Ansatz. Defaults to False.\n    skip_final_rotation_layer: If False, a rotation layer is added at the end of the\n        ansatz. If True, no rotation layer is added.\n    parameter_prefix: The parameterized gates require a parameter to be defined, for which\n        we use :class:`~qiskit.circuit.ParameterVector`.\n    insert_barriers: If True, barriers are inserted in between each layer. If False,\n        no barriers are inserted.\n    flatten: Set this to ``True`` to output a flat circuit instead of nesting it inside multiple\n        layers of gate objects. By default currently the contents of\n        the output circuit will be wrapped in nested objects for\n        cleaner visualization. However, if you're using this circuit\n        for anything besides visualization its **strongly** recommended\n        to set this flag to ``True`` to avoid a large performance\n        overhead for parameter binding.",
        "api_signature": "__init__(self, num_qubits, entanglement, reps, skip_unentangled_qubits, skip_final_rotation_layer, parameter_prefix, insert_barriers, initial_state, name, flatten)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/real_amplitudes.py"
    },
    {
        "api_name": "parameter_bounds",
        "full_api_name": "RealAmplitudes.parameter_bounds",
        "api_description": "Return the parameter bounds.\n\nReturns:\n    The parameter bounds.",
        "api_signature": "parameter_bounds(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/real_amplitudes.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QAOAAnsatz.__init__",
        "api_description": "Args:\n    cost_operator (BaseOperator or OperatorBase, optional): The operator\n        representing the cost of the optimization problem, denoted as :math:`U(C, \\gamma)`\n        in the original paper. Must be set either in the constructor or via property setter.\n    reps (int): The integer parameter p, which determines the depth of the circuit,\n        as specified in the original paper, default is 1.\n    initial_state (QuantumCircuit, optional): An optional initial state to use.\n        If `None` is passed then a set of Hadamard gates is applied as an initial state\n        to all qubits.\n    mixer_operator (BaseOperator or OperatorBase or QuantumCircuit, optional): An optional\n        custom mixer to use instead of the global X-rotations, denoted as :math:`U(B, \\beta)`\n        in the original paper. Can be an operator or an optionally parameterized quantum\n        circuit.\n    name (str): A name of the circuit, default 'qaoa'\n    flatten: Set this to ``True`` to output a flat circuit instead of nesting it inside multiple\n        layers of gate objects. By default currently the contents of\n        the output circuit will be wrapped in nested objects for\n        cleaner visualization. However, if you're using this circuit\n        for anything besides visualization its **strongly** recommended\n        to set this flag to ``True`` to avoid a large performance\n        overhead for parameter binding.",
        "api_signature": "__init__(self, cost_operator, reps, initial_state, mixer_operator, name, flatten)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/qaoa_ansatz.py"
    },
    {
        "api_name": "_check_configuration",
        "full_api_name": "QAOAAnsatz._check_configuration",
        "api_description": "Check if the current configuration is valid.",
        "api_signature": "_check_configuration(self, raise_on_failure)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/qaoa_ansatz.py"
    },
    {
        "api_name": "parameter_bounds",
        "full_api_name": "QAOAAnsatz.parameter_bounds",
        "api_description": "The parameter bounds for the unbound parameters in the circuit.\n\nReturns:\n    A list of pairs indicating the bounds, as (lower, upper). None indicates an unbounded\n    parameter in the corresponding direction. If None is returned, problem is fully\n    unbounded.",
        "api_signature": "parameter_bounds(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/qaoa_ansatz.py"
    },
    {
        "api_name": "parameter_bounds",
        "full_api_name": "QAOAAnsatz.parameter_bounds",
        "api_description": "Set the parameter bounds.\n\nArgs:\n    bounds: The new parameter bounds.",
        "api_signature": "parameter_bounds(self, bounds)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/qaoa_ansatz.py"
    },
    {
        "api_name": "operators",
        "full_api_name": "QAOAAnsatz.operators",
        "api_description": "The operators that are evolved in this circuit.\n\nReturns:\n     List[Union[BaseOperator, OperatorBase, QuantumCircuit]]: The operators to be evolved\n        (and circuits) in this ansatz.",
        "api_signature": "operators(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/qaoa_ansatz.py"
    },
    {
        "api_name": "cost_operator",
        "full_api_name": "QAOAAnsatz.cost_operator",
        "api_description": "Returns an operator representing the cost of the optimization problem.\n\nReturns:\n    BaseOperator or OperatorBase: cost operator.",
        "api_signature": "cost_operator(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/qaoa_ansatz.py"
    },
    {
        "api_name": "cost_operator",
        "full_api_name": "QAOAAnsatz.cost_operator",
        "api_description": "Sets cost operator.\n\nArgs:\n    cost_operator (BaseOperator or OperatorBase, optional): cost operator to set.",
        "api_signature": "cost_operator(self, cost_operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/qaoa_ansatz.py"
    },
    {
        "api_name": "reps",
        "full_api_name": "QAOAAnsatz.reps",
        "api_description": "Returns the `reps` parameter, which determines the depth of the circuit.",
        "api_signature": "reps(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/qaoa_ansatz.py"
    },
    {
        "api_name": "reps",
        "full_api_name": "QAOAAnsatz.reps",
        "api_description": "Sets the `reps` parameter.",
        "api_signature": "reps(self, reps)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/qaoa_ansatz.py"
    },
    {
        "api_name": "initial_state",
        "full_api_name": "QAOAAnsatz.initial_state",
        "api_description": "Returns an optional initial state as a circuit",
        "api_signature": "initial_state(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/qaoa_ansatz.py"
    },
    {
        "api_name": "initial_state",
        "full_api_name": "QAOAAnsatz.initial_state",
        "api_description": "Sets initial state.",
        "api_signature": "initial_state(self, initial_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/qaoa_ansatz.py"
    },
    {
        "api_name": "mixer_operator",
        "full_api_name": "QAOAAnsatz.mixer_operator",
        "api_description": "Returns an optional mixer operator expressed as an operator or a quantum circuit.\n\nReturns:\n    BaseOperator or OperatorBase or QuantumCircuit, optional: mixer operator or circuit.",
        "api_signature": "mixer_operator(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/qaoa_ansatz.py"
    },
    {
        "api_name": "mixer_operator",
        "full_api_name": "QAOAAnsatz.mixer_operator",
        "api_description": "Sets mixer operator.\n\nArgs:\n    mixer_operator (BaseOperator or OperatorBase or QuantumCircuit, optional): mixer\n        operator or circuit to set.",
        "api_signature": "mixer_operator(self, mixer_operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/qaoa_ansatz.py"
    },
    {
        "api_name": "num_qubits",
        "full_api_name": "QAOAAnsatz.num_qubits",
        "api_description": "",
        "api_signature": "num_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/qaoa_ansatz.py"
    },
    {
        "api_name": "_build",
        "full_api_name": "QAOAAnsatz._build",
        "api_description": "If not already built, build the circuit.",
        "api_signature": "_build(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/qaoa_ansatz.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PauliTwoDesign.__init__",
        "api_description": "",
        "api_signature": "__init__(self, num_qubits, reps, seed, insert_barriers, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/pauli_two_design.py"
    },
    {
        "api_name": "_invalidate",
        "full_api_name": "PauliTwoDesign._invalidate",
        "api_description": "Invalidate the circuit and reset the random number.",
        "api_signature": "_invalidate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/pauli_two_design.py"
    },
    {
        "api_name": "_build_rotation_layer",
        "full_api_name": "PauliTwoDesign._build_rotation_layer",
        "api_description": "Build a rotation layer.",
        "api_signature": "_build_rotation_layer(self, circuit, param_iter, i)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/pauli_two_design.py"
    },
    {
        "api_name": "num_parameters_settable",
        "full_api_name": "PauliTwoDesign.num_parameters_settable",
        "api_description": "Return the number of settable parameters.\n\nReturns:\n    The number of possibly distinct parameters.",
        "api_signature": "num_parameters_settable(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/pauli_two_design.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "EfficientSU2.__init__",
        "api_description": "Args:\n    num_qubits: The number of qubits of the EfficientSU2 circuit.\n    reps: Specifies how often the structure of a rotation layer followed by an entanglement\n        layer is repeated.\n    su2_gates: The SU(2) single qubit gates to apply in single qubit gate layers.\n        If only one gate is provided, the same gate is applied to each qubit.\n        If a list of gates is provided, all gates are applied to each qubit in the provided\n        order.\n    entanglement: Specifies the entanglement structure. Can be a string ('full', 'linear'\n        , 'reverse_linear', 'circular' or 'sca'), a list of integer-pairs specifying the indices\n        of qubits entangled with one another, or a callable returning such a list provided with\n        the index of the entanglement layer.\n        Default to 'reverse_linear' entanglement.\n        Note that 'reverse_linear' entanglement provides the same unitary as 'full'\n        with fewer entangling gates.\n        See the Examples section of :class:`~qiskit.circuit.library.TwoLocal` for more\n        detail.\n    initial_state: A `QuantumCircuit` object to prepend to the circuit.\n    skip_unentangled_qubits: If True, the single qubit gates are only applied to qubits\n        that are entangled with another qubit. If False, the single qubit gates are applied\n        to each qubit in the Ansatz. Defaults to False.\n    skip_final_rotation_layer: If False, a rotation layer is added at the end of the\n        ansatz. If True, no rotation layer is added.\n    parameter_prefix: The parameterized gates require a parameter to be defined, for which\n        we use :class:`~qiskit.circuit.ParameterVector`.\n    insert_barriers: If True, barriers are inserted in between each layer. If False,\n        no barriers are inserted.\n    flatten: Set this to ``True`` to output a flat circuit instead of nesting it inside multiple\n        layers of gate objects. By default currently the contents of\n        the output circuit will be wrapped in nested objects for\n        cleaner visualization. However, if you're using this circuit\n        for anything besides visualization its **strongly** recommended\n        to set this flag to ``True`` to avoid a large performance\n        overhead for parameter binding.",
        "api_signature": "__init__(self, num_qubits, su2_gates, entanglement, reps, skip_unentangled_qubits, skip_final_rotation_layer, parameter_prefix, insert_barriers, initial_state, name, flatten)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/efficient_su2.py"
    },
    {
        "api_name": "parameter_bounds",
        "full_api_name": "EfficientSU2.parameter_bounds",
        "api_description": "Return the parameter bounds.\n\nReturns:\n    The parameter bounds.",
        "api_signature": "parameter_bounds(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/efficient_su2.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "TwoLocal.__init__",
        "api_description": "Args:\n    num_qubits: The number of qubits of the two-local circuit.\n    rotation_blocks: The gates used in the rotation layer. Can be specified via the name of\n        a gate (e.g. ``'ry'``) or the gate type itself (e.g. :class:`.RYGate`).\n        If only one gate is provided, the gate same gate is applied to each qubit.\n        If a list of gates is provided, all gates are applied to each qubit in the provided\n        order.\n        See the Examples section for more detail.\n    entanglement_blocks: The gates used in the entanglement layer. Can be specified in\n        the same format as ``rotation_blocks``.\n    entanglement: Specifies the entanglement structure. Can be a string (``'full'``,\n        ``'linear'``, ``'reverse_linear'``, ``'circular'`` or ``'sca'``),\n        a list of integer-pairs specifying the indices\n        of qubits entangled with one another, or a callable returning such a list provided with\n        the index of the entanglement layer.\n        Default to ``'full'`` entanglement.\n        Note that if ``entanglement_blocks = 'cx'``, then ``'full'`` entanglement provides the\n        same unitary as ``'reverse_linear'`` but the latter option has fewer entangling gates.\n        See the Examples section for more detail.\n    reps: Specifies how often a block consisting of a rotation layer and entanglement\n        layer is repeated.\n    skip_unentangled_qubits: If ``True``, the single qubit gates are only applied to qubits\n        that are entangled with another qubit. If ``False``, the single qubit gates are applied\n        to each qubit in the ansatz. Defaults to ``False``.\n    skip_final_rotation_layer: If ``False``, a rotation layer is added at the end of the\n        ansatz. If ``True``, no rotation layer is added.\n    parameter_prefix: The parameterized gates require a parameter to be defined, for which\n        we use instances of :class:`~qiskit.circuit.Parameter`. The name of each parameter will\n        be this specified prefix plus its index.\n    insert_barriers: If ``True``, barriers are inserted in between each layer. If ``False``,\n        no barriers are inserted. Defaults to ``False``.\n    initial_state: A :class:`.QuantumCircuit` object to prepend to the circuit.\n    flatten: Set this to ``True`` to output a flat circuit instead of nesting it inside multiple\n        layers of gate objects. By default currently the contents of\n        the output circuit will be wrapped in nested objects for\n        cleaner visualization. However, if you're using this circuit\n        for anything besides visualization its **strongly** recommended\n        to set this flag to ``True`` to avoid a large performance\n        overhead for parameter binding.",
        "api_signature": "__init__(self, num_qubits, rotation_blocks, entanglement_blocks, entanglement, reps, skip_unentangled_qubits, skip_final_rotation_layer, parameter_prefix, insert_barriers, initial_state, name, flatten)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/two_local.py"
    },
    {
        "api_name": "_convert_to_block",
        "full_api_name": "TwoLocal._convert_to_block",
        "api_description": "For a layer provided as str (e.g. ``'ry'``) or type (e.g. :class:`.RYGate`) this function\n returns the\n according layer type along with the number of parameters (e.g. ``(RYGate, 1)``).\n\nArgs:\n    layer: The qubit layer.\n\nReturns:\n    The specified layer with the required number of parameters.\n\nRaises:\n    TypeError: The type of ``layer`` is invalid.\n    ValueError: The type of ``layer`` is str but the name is unknown.\n    ValueError: The type of ``layer`` is type but the layer type is unknown.\n\nNote:\n    Outlook: If layers knew their number of parameters as static property, we could also\n    allow custom layer types.",
        "api_signature": "_convert_to_block(self, layer)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/two_local.py"
    },
    {
        "api_name": "get_entangler_map",
        "full_api_name": "TwoLocal.get_entangler_map",
        "api_description": "Overloading to handle the special case of 1 qubit where the entanglement are ignored.",
        "api_signature": "get_entangler_map(self, rep_num, block_num, num_block_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/two_local.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "NLocal.__init__",
        "api_description": "Args:\n    num_qubits: The number of qubits of the circuit.\n    rotation_blocks: The blocks used in the rotation layers. If multiple are passed,\n        these will be applied one after another (like new sub-layers).\n    entanglement_blocks: The blocks used in the entanglement layers. If multiple are passed,\n        these will be applied one after another. To use different entanglements for\n        the sub-layers, see :meth:`get_entangler_map`.\n    entanglement: The indices specifying on which qubits the input blocks act. If ``None``, the\n        entanglement blocks are applied at the top of the circuit.\n    reps: Specifies how often the rotation blocks and entanglement blocks are repeated.\n    insert_barriers: If ``True``, barriers are inserted in between each layer. If ``False``,\n        no barriers are inserted.\n    parameter_prefix: The prefix used if default parameters are generated.\n    overwrite_block_parameters: If the parameters in the added blocks should be overwritten.\n        If ``False``, the parameters in the blocks are not changed.\n    skip_final_rotation_layer: Whether a final rotation layer is added to the circuit.\n    skip_unentangled_qubits: If ``True``, the rotation gates act only on qubits that\n        are entangled. If ``False``, the rotation gates act on all qubits.\n    initial_state: A :class:`.QuantumCircuit` object which can be used to describe an initial\n        state prepended to the NLocal circuit.\n    name: The name of the circuit.\n    flatten: Set this to ``True`` to output a flat circuit instead of nesting it inside multiple\n        layers of gate objects. By default currently the contents of\n        the output circuit will be wrapped in nested objects for\n        cleaner visualization. However, if you're using this circuit\n        for anything besides visualization its **strongly** recommended\n        to set this flag to ``True`` to avoid a large performance\n        overhead for parameter binding.\n\nRaises:\n    ValueError: If ``reps`` parameter is less than or equal to 0.\n    TypeError: If ``reps`` parameter is not an int value.",
        "api_signature": "__init__(self, num_qubits, rotation_blocks, entanglement_blocks, entanglement, reps, insert_barriers, parameter_prefix, overwrite_block_parameters, skip_final_rotation_layer, skip_unentangled_qubits, initial_state, name, flatten)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "num_qubits",
        "full_api_name": "NLocal.num_qubits",
        "api_description": "Returns the number of qubits in this circuit.\n\nReturns:\n    The number of qubits.",
        "api_signature": "num_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "num_qubits",
        "full_api_name": "NLocal.num_qubits",
        "api_description": "Set the number of qubits for the n-local circuit.\n\nArgs:\n    The new number of qubits.",
        "api_signature": "num_qubits(self, num_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "flatten",
        "full_api_name": "NLocal.flatten",
        "api_description": "Returns whether the circuit is wrapped in nested gates/instructions or flattened.",
        "api_signature": "flatten(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "flatten",
        "full_api_name": "NLocal.flatten",
        "api_description": "",
        "api_signature": "flatten(self, flatten)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "_convert_to_block",
        "full_api_name": "NLocal._convert_to_block",
        "api_description": "Try to convert ``layer`` to a QuantumCircuit.\n\nArgs:\n    layer: The object to be converted to an NLocal block / Instruction.\n\nReturns:\n    The layer converted to a circuit.\n\nRaises:\n    TypeError: If the input cannot be converted to a circuit.",
        "api_signature": "_convert_to_block(self, layer)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "rotation_blocks",
        "full_api_name": "NLocal.rotation_blocks",
        "api_description": "The blocks in the rotation layers.\n\nReturns:\n    The blocks in the rotation layers.",
        "api_signature": "rotation_blocks(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "rotation_blocks",
        "full_api_name": "NLocal.rotation_blocks",
        "api_description": "Set the blocks in the rotation layers.\n\nArgs:\n    blocks: The new blocks for the rotation layers.",
        "api_signature": "rotation_blocks(self, blocks)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "entanglement_blocks",
        "full_api_name": "NLocal.entanglement_blocks",
        "api_description": "The blocks in the entanglement layers.\n\nReturns:\n    The blocks in the entanglement layers.",
        "api_signature": "entanglement_blocks(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "entanglement_blocks",
        "full_api_name": "NLocal.entanglement_blocks",
        "api_description": "Set the blocks in the entanglement layers.\n\nArgs:\n    blocks: The new blocks for the entanglement layers.",
        "api_signature": "entanglement_blocks(self, blocks)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "entanglement",
        "full_api_name": "NLocal.entanglement",
        "api_description": "Get the entanglement strategy.\n\nReturns:\n    The entanglement strategy, see :meth:`get_entangler_map` for more detail on how the\n    format is interpreted.",
        "api_signature": "entanglement(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "entanglement",
        "full_api_name": "NLocal.entanglement",
        "api_description": "Set the entanglement strategy.\n\nArgs:\n    entanglement: The entanglement strategy. See :meth:`get_entangler_map` for more detail\n        on the supported formats.",
        "api_signature": "entanglement(self, entanglement)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "num_layers",
        "full_api_name": "NLocal.num_layers",
        "api_description": "Return the number of layers in the n-local circuit.\n\nReturns:\n    The number of layers in the circuit.",
        "api_signature": "num_layers(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "_check_configuration",
        "full_api_name": "NLocal._check_configuration",
        "api_description": "Check if the configuration of the NLocal class is valid.\n\nArgs:\n    raise_on_failure: Whether to raise on failure.\n\nReturns:\n    True, if the configuration is valid and the circuit can be constructed. Otherwise\n    an ValueError is raised.\n\nRaises:\n    ValueError: If the blocks are not set.\n    ValueError: If the number of repetitions is not set.\n    ValueError: If the qubit indices are not set.\n    ValueError: If the number of qubit indices does not match the number of blocks.\n    ValueError: If an index in the repetitions list exceeds the number of blocks.\n    ValueError: If the number of repetitions does not match the number of block-wise\n        parameters.\n    ValueError: If a specified qubit index is larger than the (manually set) number of\n        qubits.",
        "api_signature": "_check_configuration(self, raise_on_failure)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "ordered_parameters",
        "full_api_name": "NLocal.ordered_parameters",
        "api_description": "The parameters used in the underlying circuit.\n\nThis includes float values and duplicates.\n\nExamples:\n\n    >>> # prepare circuit ...\n    >>> print(nlocal)\n         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    q_0: \u2524 Ry(1) \u251c\u2524 Ry(\u03b8[1]) \u251c\u2524 Ry(\u03b8[1]) \u251c\u2524 Ry(\u03b8[3]) \u251c\n         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    >>> nlocal.parameters\n    {Parameter(\u03b8[1]), Parameter(\u03b8[3])}\n    >>> nlocal.ordered_parameters\n    [1, Parameter(\u03b8[1]), Parameter(\u03b8[1]), Parameter(\u03b8[3])]\n\nReturns:\n    The parameters objects used in the circuit.",
        "api_signature": "ordered_parameters(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "ordered_parameters",
        "full_api_name": "NLocal.ordered_parameters",
        "api_description": "Set the parameters used in the underlying circuit.\n\nArgs:\n    The parameters to be used in the underlying circuit.\n\nRaises:\n    ValueError: If the length of ordered parameters does not match the number of\n        parameters in the circuit and they are not a ``ParameterVector`` (which could\n        be resized to fit the number of parameters).",
        "api_signature": "ordered_parameters(self, parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "insert_barriers",
        "full_api_name": "NLocal.insert_barriers",
        "api_description": "If barriers are inserted in between the layers or not.\n\nReturns:\n    ``True``, if barriers are inserted in between the layers, ``False`` if not.",
        "api_signature": "insert_barriers(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "insert_barriers",
        "full_api_name": "NLocal.insert_barriers",
        "api_description": "Specify whether barriers should be inserted in between the layers or not.\n\nArgs:\n    insert_barriers: If True, barriers are inserted, if False not.",
        "api_signature": "insert_barriers(self, insert_barriers)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "get_unentangled_qubits",
        "full_api_name": "NLocal.get_unentangled_qubits",
        "api_description": "Get the indices of unentangled qubits in a set.\n\nReturns:\n    The unentangled qubits.",
        "api_signature": "get_unentangled_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "num_parameters_settable",
        "full_api_name": "NLocal.num_parameters_settable",
        "api_description": "The number of total parameters that can be set to distinct values.\n\nThis does not change when the parameters are bound or exchanged for same parameters,\nand therefore is different from ``num_parameters`` which counts the number of unique\n:class:`~qiskit.circuit.Parameter` objects currently in the circuit.\n\nReturns:\n    The number of parameters originally available in the circuit.\n\nNote:\n    This quantity does not require the circuit to be built yet.",
        "api_signature": "num_parameters_settable(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "reps",
        "full_api_name": "NLocal.reps",
        "api_description": "The number of times rotation and entanglement block are repeated.\n\nReturns:\n    The number of repetitions.",
        "api_signature": "reps(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "reps",
        "full_api_name": "NLocal.reps",
        "api_description": "Set the repetitions.\n\nIf the repetitions are `0`, only one rotation layer with no entanglement\nlayers is applied (unless ``self.skip_final_rotation_layer`` is set to ``True``).\n\nArgs:\n    repetitions: The new repetitions.\n\nRaises:\n    ValueError: If reps setter has parameter repetitions < 0.",
        "api_signature": "reps(self, repetitions)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "print_settings",
        "full_api_name": "NLocal.print_settings",
        "api_description": "Returns information about the setting.\n\nReturns:\n    The class name and the attributes/parameters of the instance as ``str``.",
        "api_signature": "print_settings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "preferred_init_points",
        "full_api_name": "NLocal.preferred_init_points",
        "api_description": "The initial points for the parameters. Can be stored as initial guess in optimization.\n\nReturns:\n    The initial values for the parameters, or None, if none have been set.",
        "api_signature": "preferred_init_points(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "get_entangler_map",
        "full_api_name": "NLocal.get_entangler_map",
        "api_description": "Get the entangler map for in the repetition ``rep_num`` and the block ``block_num``.\n\nThe entangler map for the current block is derived from the value of ``self.entanglement``.\nBelow the different cases are listed, where ``i`` and ``j`` denote the repetition number\nand the block number, respectively, and ``n`` the number of qubits in the block.\n\n=================================== ========================================================\nentanglement type                   entangler map\n=================================== ========================================================\n``None``                            ``[[0, ..., n - 1]]``\n``str`` (e.g ``'full'``)            the specified connectivity on ``n`` qubits\n``List[int]``                       [``entanglement``]\n``List[List[int]]``                 ``entanglement``\n``List[List[List[int]]]``           ``entanglement[i]``\n``List[List[List[List[int]]]]``     ``entanglement[i][j]``\n``List[str]``                       the connectivity specified in ``entanglement[i]``\n``List[List[str]]``                 the connectivity specified in ``entanglement[i][j]``\n``Callable[int, str]``              same as ``List[str]``\n``Callable[int, List[List[int]]]``  same as ``List[List[List[int]]]``\n=================================== ========================================================\n\n\nNote that all indices are to be taken modulo the length of the array they act on, i.e.\nno out-of-bounds index error will be raised but we re-iterate from the beginning of the\nlist.\n\nArgs:\n    rep_num: The current repetition we are in.\n    block_num: The block number within the entanglement layers.\n    num_block_qubits: The number of qubits in the block.\n\nReturns:\n    The entangler map for the current block in the current repetition.\n\nRaises:\n    ValueError: If the value of ``entanglement`` could not be cast to a corresponding\n        entangler map.",
        "api_signature": "get_entangler_map(self, rep_num, block_num, num_block_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "initial_state",
        "full_api_name": "NLocal.initial_state",
        "api_description": "Return the initial state that is added in front of the n-local circuit.\n\nReturns:\n    The initial state.",
        "api_signature": "initial_state(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "initial_state",
        "full_api_name": "NLocal.initial_state",
        "api_description": "Set the initial state.\n\nArgs:\n    initial_state: The new initial state.\n\nRaises:\n    ValueError: If the number of qubits has been set before and the initial state\n        does not match the number of qubits.",
        "api_signature": "initial_state(self, initial_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "parameter_bounds",
        "full_api_name": "NLocal.parameter_bounds",
        "api_description": "The parameter bounds for the unbound parameters in the circuit.\n\nReturns:\n    A list of pairs indicating the bounds, as (lower, upper). None indicates an unbounded\n    parameter in the corresponding direction. If ``None`` is returned, problem is fully\n    unbounded.",
        "api_signature": "parameter_bounds(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "parameter_bounds",
        "full_api_name": "NLocal.parameter_bounds",
        "api_description": "Set the parameter bounds.\n\nArgs:\n    bounds: The new parameter bounds.",
        "api_signature": "parameter_bounds(self, bounds)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "add_layer",
        "full_api_name": "NLocal.add_layer",
        "api_description": "Append another layer to the NLocal.\n\nArgs:\n    other: The layer to compose, can be another NLocal, an Instruction or Gate,\n        or a QuantumCircuit.\n    entanglement: The entanglement or qubit indices.\n    front: If True, ``other`` is appended to the front, else to the back.\n\nReturns:\n    self, such that chained composes are possible.\n\nRaises:\n    TypeError: If `other` is not compatible, i.e. is no Instruction and does not have a\n        `to_instruction` method.",
        "api_signature": "add_layer(self, other, entanglement, front)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "assign_parameters",
        "full_api_name": "NLocal.assign_parameters",
        "api_description": "Assign parameters to the n-local circuit.\n\nThis method also supports passing a list instead of a dictionary. If a list\nis passed, the list must have the same length as the number of unbound parameters in\nthe circuit. The parameters are assigned in the order of the parameters in\n:meth:`ordered_parameters`.\n\nReturns:\n    A copy of the NLocal circuit with the specified parameters.\n\nRaises:\n    AttributeError: If the parameters are given as list and do not match the number\n        of parameters.",
        "api_signature": "assign_parameters(self, parameters, inplace)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "_parameterize_block",
        "full_api_name": "NLocal._parameterize_block",
        "api_description": "Convert ``block`` to a circuit of correct width and parameterized using the iterator.",
        "api_signature": "_parameterize_block(self, block, param_iter, rep_num, block_num, indices, params)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "_build_rotation_layer",
        "full_api_name": "NLocal._build_rotation_layer",
        "api_description": "Build a rotation layer.",
        "api_signature": "_build_rotation_layer(self, circuit, param_iter, i)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "_build_entanglement_layer",
        "full_api_name": "NLocal._build_entanglement_layer",
        "api_description": "Build an entanglement layer.",
        "api_signature": "_build_entanglement_layer(self, circuit, param_iter, i)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "_build_additional_layers",
        "full_api_name": "NLocal._build_additional_layers",
        "api_description": "",
        "api_signature": "_build_additional_layers(self, circuit, which)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "_build",
        "full_api_name": "NLocal._build",
        "api_description": "If not already built, build the circuit.",
        "api_signature": "_build(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "_parameter_generator",
        "full_api_name": "NLocal._parameter_generator",
        "api_description": "If certain blocks should use certain parameters this method can be overridden.",
        "api_signature": "_parameter_generator(self, rep, block, indices)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "get_parameters",
        "full_api_name": "get_parameters",
        "api_description": "Return the list of Parameters objects inside a circuit or instruction.\n\nThis is required since, in a standard gate the parameters are not necessarily Parameter\nobjects (e.g. U3Gate(0.1, 0.2, 0.3).params == [0.1, 0.2, 0.3]) and instructions and\ncircuits do not have the same interface for parameters.",
        "api_signature": "get_parameters(block)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "get_entangler_map",
        "full_api_name": "get_entangler_map",
        "api_description": "Get an entangler map for an arbitrary number of qubits.\n\nArgs:\n    num_block_qubits: The number of qubits of the entangling block.\n    num_circuit_qubits: The number of qubits of the circuit.\n    entanglement: The entanglement strategy.\n    offset: The block offset, can be used if the entanglements differ per block.\n        See mode ``sca`` for instance.\n\nReturns:\n    The entangler map using mode ``entanglement`` to scatter a block of ``num_block_qubits``\n    qubits on ``num_circuit_qubits`` qubits.\n\nRaises:\n    ValueError: If the entanglement mode ist not supported.",
        "api_signature": "get_entangler_map(num_block_qubits, num_circuit_qubits, entanglement, offset)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ExcitationPreserving.__init__",
        "api_description": "Args:\n    num_qubits: The number of qubits of the ExcitationPreserving circuit.\n    mode: Choose the entangler mode, can be `'iswap'` or `'fsim'`.\n    reps: Specifies how often the structure of a rotation layer followed by an entanglement\n        layer is repeated.\n    entanglement: Specifies the entanglement structure. Can be a string ('full', 'linear'\n        or 'sca'), a list of integer-pairs specifying the indices of qubits\n        entangled with one another, or a callable returning such a list provided with\n        the index of the entanglement layer.\n        See the Examples section of :class:`~qiskit.circuit.library.TwoLocal` for more\n        detail.\n    initial_state: A `QuantumCircuit` object to prepend to the circuit.\n    skip_unentangled_qubits: If True, the single qubit gates are only applied to qubits\n        that are entangled with another qubit. If False, the single qubit gates are applied\n        to each qubit in the Ansatz. Defaults to False.\n    skip_unentangled_qubits: If True, the single qubit gates are only applied to qubits\n        that are entangled with another qubit. If False, the single qubit gates are applied\n        to each qubit in the Ansatz. Defaults to False.\n    skip_final_rotation_layer: If True, a rotation layer is added at the end of the\n        ansatz. If False, no rotation layer is added. Defaults to True.\n    parameter_prefix: The parameterized gates require a parameter to be defined, for which\n        we use :class:`~qiskit.circuit.ParameterVector`.\n    insert_barriers: If True, barriers are inserted in between each layer. If False,\n        no barriers are inserted.\n    flatten: Set this to ``True`` to output a flat circuit instead of nesting it inside multiple\n        layers of gate objects. By default currently the contents of\n        the output circuit will be wrapped in nested objects for\n        cleaner visualization. However, if you're using this circuit\n        for anything besides visualization its **strongly** recommended\n        to set this flag to ``True`` to avoid a large performance\n        overhead for parameter binding.\n\nRaises:\n    ValueError: If the selected mode is not supported.",
        "api_signature": "__init__(self, num_qubits, mode, entanglement, reps, skip_unentangled_qubits, skip_final_rotation_layer, parameter_prefix, insert_barriers, initial_state, name, flatten)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/excitation_preserving.py"
    },
    {
        "api_name": "parameter_bounds",
        "full_api_name": "ExcitationPreserving.parameter_bounds",
        "api_description": "Return the parameter bounds.\n\nReturns:\n    The parameter bounds.",
        "api_signature": "parameter_bounds(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/excitation_preserving.py"
    },
    {
        "api_name": "pi_check",
        "full_api_name": "pi_check",
        "api_description": "Computes if a number is close to an integer\nfraction or multiple of PI and returns the\ncorresponding string.\n\nArgs:\n    inpt (float): Number to check.\n    eps (float): EPS to check against.\n    output (str): Options are 'text' (default),\n                  'latex', 'mpl', and 'qasm'.\n    ndigits (int or None): Number of digits to print\n                           if returning raw inpt.\n                           If `None` (default), Python's\n                           default float formatting is used.\n\nReturns:\n    str: string representation of output.\n\nRaises:\n    QiskitError: if output is not a valid option.",
        "api_signature": "pi_check(inpt, eps, output, ndigits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/tools/pi_check.py"
    },
    {
        "api_name": "normalize",
        "full_api_name": "normalize",
        "api_description": "",
        "api_signature": "normalize(single_inpt)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/tools/pi_check.py"
    },
    {
        "api_name": "_get_singleton_instance",
        "full_api_name": "_Singleton._get_singleton_instance",
        "api_description": "",
        "api_signature": "_get_singleton_instance(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/types/types.py"
    },
    {
        "api_name": "__prepare__",
        "full_api_name": "_Singleton.__prepare__",
        "api_description": "",
        "api_signature": "__prepare__(mcs, name, bases)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/types/types.py"
    },
    {
        "api_name": "__new__",
        "full_api_name": "_Singleton.__new__",
        "api_description": "",
        "api_signature": "__new__(cls, name, bases, namespace)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/types/types.py"
    },
    {
        "api_name": "kind",
        "full_api_name": "Type.kind",
        "api_description": "Get the kind of this type.  This is exactly equal to the Python type object that defines\nthis type, that is ``t.kind is type(t)``, but is exposed like this to make it clear that\nthis a hashable enum-like discriminator you can rely on.",
        "api_signature": "kind(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/types/types.py"
    },
    {
        "api_name": "__setattr__",
        "full_api_name": "Type.__setattr__",
        "api_description": "",
        "api_signature": "__setattr__(self, _key, _value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/types/types.py"
    },
    {
        "api_name": "__copy__",
        "full_api_name": "Type.__copy__",
        "api_description": "",
        "api_signature": "__copy__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/types/types.py"
    },
    {
        "api_name": "__deepcopy__",
        "full_api_name": "Type.__deepcopy__",
        "api_description": "",
        "api_signature": "__deepcopy__(self, _memo)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/types/types.py"
    },
    {
        "api_name": "__setstate__",
        "full_api_name": "Type.__setstate__",
        "api_description": "",
        "api_signature": "__setstate__(self, state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/types/types.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "Bool.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/types/types.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "Bool.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/types/types.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Uint.__init__",
        "api_description": "",
        "api_signature": "__init__(self, width)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/types/types.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "Uint.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/types/types.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "Uint.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/types/types.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "Ordering.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/types/ordering.py"
    },
    {
        "api_name": "_order_bool_bool",
        "full_api_name": "_order_bool_bool",
        "api_description": "",
        "api_signature": "_order_bool_bool()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/types/ordering.py"
    },
    {
        "api_name": "_order_uint_uint",
        "full_api_name": "_order_uint_uint",
        "api_description": "",
        "api_signature": "_order_uint_uint()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/types/ordering.py"
    },
    {
        "api_name": "order",
        "full_api_name": "order",
        "api_description": "Get the ordering relationship between the two types as an enumeration value.\n\nExamples:\n    Compare two :class:`Uint` types of different widths::\n\n        >>> from qiskit.circuit.classical import types\n        >>> types.order(types.Uint(8), types.Uint(16))\n        Ordering.LESS\n\n    Compare two types that have no ordering between them::\n\n        >>> types.order(types.Uint(8), types.Bool())\n        Ordering.NONE",
        "api_signature": "order()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/types/ordering.py"
    },
    {
        "api_name": "is_subtype",
        "full_api_name": "is_subtype",
        "api_description": "Does the relation :math:`\\text{left} \\le \\text{right}` hold?  If there is no ordering\nrelation between the two types, then this returns ``False``.  If ``strict``, then the equality\nis also forbidden.\n\nExamples:\n    Check if one type is a subclass of another::\n\n        >>> from qiskit.circuit.classical import types\n        >>> types.is_subtype(types.Uint(8), types.Uint(16))\n        True\n\n    Check if one type is a strict subclass of another::\n\n        >>> types.is_subtype(types.Bool(), types.Bool())\n        True\n        >>> types.is_subtype(types.Bool(), types.Bool(), strict=True)\n        False",
        "api_signature": "is_subtype(strict)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/types/ordering.py"
    },
    {
        "api_name": "is_supertype",
        "full_api_name": "is_supertype",
        "api_description": "Does the relation :math:`\\text{left} \\ge \\text{right}` hold?  If there is no ordering\nrelation between the two types, then this returns ``False``.  If ``strict``, then the equality\nis also forbidden.\n\nExamples:\n    Check if one type is a superclass of another::\n\n        >>> from qiskit.circuit.classical import types\n        >>> types.is_supertype(types.Uint(8), types.Uint(16))\n        False\n\n    Check if one type is a strict superclass of another::\n\n        >>> types.is_supertype(types.Bool(), types.Bool())\n        True\n        >>> types.is_supertype(types.Bool(), types.Bool(), strict=True)\n        False",
        "api_signature": "is_supertype(strict)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/types/ordering.py"
    },
    {
        "api_name": "greater",
        "full_api_name": "greater",
        "api_description": "Get the greater of the two types, assuming that there is an ordering relation between them.\nTechnically, this is a slightly restricted version of the concept of the 'meet' of the two\ntypes in that the return value must be one of the inputs. In practice in the type system there\nis no concept of a 'sum' type, so the 'meet' exists if and only if there is an ordering between\nthe two types, and is equal to the greater of the two types.\n\nReturns:\n    The greater of the two types.\n\nRaises:\n    TypeError: if there is no ordering relation between the two types.\n\nExamples:\n    Find the greater of two :class:`Uint` types::\n\n        >>> from qiskit.circuit.classical import types\n        >>> types.greater(types.Uint(8), types.Uint(16))\n        types.Uint(16)",
        "api_signature": "greater()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/types/ordering.py"
    },
    {
        "api_name": "_uint_cast",
        "full_api_name": "_uint_cast",
        "api_description": "",
        "api_signature": "_uint_cast()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/constructors.py"
    },
    {
        "api_name": "_cast_kind",
        "full_api_name": "_cast_kind",
        "api_description": "",
        "api_signature": "_cast_kind()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/constructors.py"
    },
    {
        "api_name": "_coerce_lossless",
        "full_api_name": "_coerce_lossless",
        "api_description": "Coerce ``expr`` to ``type`` by inserting a suitable :class:`Cast` node, if the cast is\nlossless.  Otherwise, raise a ``TypeError``.",
        "api_signature": "_coerce_lossless(expr, type)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/constructors.py"
    },
    {
        "api_name": "lift_legacy_condition",
        "full_api_name": "lift_legacy_condition",
        "api_description": "Lift a legacy two-tuple equality condition into a new-style :class:`Expr`.\n\nExamples:\n    Taking an old-style conditional instruction and getting an :class:`Expr` from its\n    condition::\n\n        from qiskit.circuit import ClassicalRegister\n        from qiskit.circuit.library import HGate\n        from qiskit.circuit.classical import expr\n\n        cr = ClassicalRegister(2)\n        instr = HGate().c_if(cr, 3)\n\n        lifted = expr.lift_legacy_condition(instr.condition)",
        "api_signature": "lift_legacy_condition()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/constructors.py"
    },
    {
        "api_name": "lift",
        "full_api_name": "lift",
        "api_description": "Lift the given Python ``value`` to a :class:`~.expr.Value` or :class:`~.expr.Var`.\n\nIf an explicit ``type`` is given, the typing in the output will reflect that.\n\nExamples:\n    Lifting simple circuit objects to be :class:`~.expr.Var` instances::\n\n        >>> from qiskit.circuit import Clbit, ClassicalRegister\n        >>> from qiskit.circuit.classical import expr\n        >>> expr.lift(Clbit())\n        Var(<clbit>, Bool())\n        >>> expr.lift(ClassicalRegister(3, \"c\"))\n        Var(ClassicalRegister(3, \"c\"), Uint(3))\n\n    The type of the return value can be influenced, if the given value could be interpreted\n    losslessly as the given type (use :func:`cast` to perform a full set of casting\n    operations, include lossy ones)::\n\n        >>> from qiskit.circuit import ClassicalRegister\n        >>> from qiskit.circuit.classical import expr, types\n        >>> expr.lift(ClassicalRegister(3, \"c\"), types.Uint(5))\n        Var(ClassicalRegister(3, \"c\"), Uint(5))\n        >>> expr.lift(5, types.Uint(4))\n        Value(5, Uint(4))",
        "api_signature": "lift(type)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/constructors.py"
    },
    {
        "api_name": "cast",
        "full_api_name": "cast",
        "api_description": "Create an explicit cast from the given value to the given type.\n\nExamples:\n    Add an explicit cast node that explicitly casts a higher precision type to a lower precision\n    one::\n\n        >>> from qiskit.circuit.classical import expr, types\n        >>> value = expr.value(5, types.Uint(32))\n        >>> expr.cast(value, types.Uint(8))\n        Cast(Value(5, types.Uint(32)), types.Uint(8), implicit=False)",
        "api_signature": "cast()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/constructors.py"
    },
    {
        "api_name": "bit_not",
        "full_api_name": "bit_not",
        "api_description": "Create a bitwise 'not' expression node from the given value, resolving any implicit casts and\nlifting the value into a :class:`Value` node if required.\n\nExamples:\n    Bitwise negation of a :class:`.ClassicalRegister`::\n\n        >>> from qiskit.circuit import ClassicalRegister\n        >>> from qiskit.circuit.classical import expr\n        >>> expr.bit_not(ClassicalRegister(3, \"c\"))\n        Unary(Unary.Op.BIT_NOT, Var(ClassicalRegister(3, 'c'), Uint(3)), Uint(3))",
        "api_signature": "bit_not()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/constructors.py"
    },
    {
        "api_name": "logic_not",
        "full_api_name": "logic_not",
        "api_description": "Create a logical 'not' expression node from the given value, resolving any implicit casts and\nlifting the value into a :class:`Value` node if required.\n\nExamples:\n    Logical negation of a :class:`.ClassicalRegister`::\n\n        >>> from qiskit.circuit import ClassicalRegister\n        >>> from qiskit.circuit.classical import expr\n        >>> expr.logic_not(ClassicalRegister(3, \"c\"))\n        Unary(Unary.Op.LOGIC_NOT, Cast(Var(ClassicalRegister(3, 'c'), Uint(3)), Bool(), implicit=True), Bool())",
        "api_signature": "logic_not()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/constructors.py"
    },
    {
        "api_name": "_lift_binary_operands",
        "full_api_name": "_lift_binary_operands",
        "api_description": "Lift two binary operands simultaneously, inferring the widths of integer literals in either\nposition to match the other operand.",
        "api_signature": "_lift_binary_operands(left, right)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/constructors.py"
    },
    {
        "api_name": "_binary_bitwise",
        "full_api_name": "_binary_bitwise",
        "api_description": "",
        "api_signature": "_binary_bitwise(op, left, right)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/constructors.py"
    },
    {
        "api_name": "bit_and",
        "full_api_name": "bit_and",
        "api_description": "Create a bitwise 'and' expression node from the given value, resolving any implicit casts and\nlifting the values into :class:`Value` nodes if required.\n\nExamples:\n    Bitwise 'and' of a classical register and an integer literal::\n\n        >>> from qiskit.circuit import ClassicalRegister\n        >>> from qiskit.circuit.classical import expr\n        >>> expr.bit_and(ClassicalRegister(3, \"c\"), 0b111)\n        Binary(Binary.Op.BIT_AND, Var(ClassicalRegister(3, 'c'), Uint(3)), Value(7, Uint(3)), Uint(3))\n    ",
        "api_signature": "bit_and()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/constructors.py"
    },
    {
        "api_name": "bit_or",
        "full_api_name": "bit_or",
        "api_description": "Create a bitwise 'or' expression node from the given value, resolving any implicit casts and\nlifting the values into :class:`Value` nodes if required.\n\nExamples:\n    Bitwise 'or' of a classical register and an integer literal::\n\n        >>> from qiskit.circuit import ClassicalRegister\n        >>> from qiskit.circuit.classical import expr\n        >>> expr.bit_or(ClassicalRegister(3, \"c\"), 0b101)\n        Binary(Binary.Op.BIT_OR, Var(ClassicalRegister(3, 'c'), Uint(3)), Value(5, Uint(3)), Uint(3))",
        "api_signature": "bit_or()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/constructors.py"
    },
    {
        "api_name": "bit_xor",
        "full_api_name": "bit_xor",
        "api_description": "Create a bitwise 'exclusive or' expression node from the given value, resolving any implicit\ncasts and lifting the values into :class:`Value` nodes if required.\n\nExamples:\n    Bitwise 'exclusive or' of a classical register and an integer literal::\n\n        >>> from qiskit.circuit import ClassicalRegister\n        >>> from qiskit.circuit.classical import expr\n        >>> expr.bit_xor(ClassicalRegister(3, \"c\"), 0b101)\n        Binary(Binary.Op.BIT_XOR, Var(ClassicalRegister(3, 'c'), Uint(3)), Value(5, Uint(3)), Uint(3))",
        "api_signature": "bit_xor()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/constructors.py"
    },
    {
        "api_name": "_binary_logical",
        "full_api_name": "_binary_logical",
        "api_description": "",
        "api_signature": "_binary_logical(op, left, right)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/constructors.py"
    },
    {
        "api_name": "logic_and",
        "full_api_name": "logic_and",
        "api_description": "Create a logical 'and' expression node from the given value, resolving any implicit casts and\nlifting the values into :class:`Value` nodes if required.\n\nExamples:\n    Logical 'and' of two classical bits::\n\n        >>> from qiskit.circuit import Clbit\n        >>> from qiskit.circuit.classical import expr\n        >>> expr.logical_and(Clbit(), Clbit())\n        Binary(Binary.Op.LOGIC_AND, Var(<clbit 0>, Bool()), Var(<clbit 1>, Bool()), Bool())",
        "api_signature": "logic_and()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/constructors.py"
    },
    {
        "api_name": "logic_or",
        "full_api_name": "logic_or",
        "api_description": "Create a logical 'or' expression node from the given value, resolving any implicit casts and\nlifting the values into :class:`Value` nodes if required.\n\nExamples:\n    Logical 'or' of two classical bits\n\n        >>> from qiskit.circuit import Clbit\n        >>> from qiskit.circuit.classical import expr\n        >>> expr.logical_and(Clbit(), Clbit())\n        Binary(Binary.Op.LOGIC_OR, Var(<clbit 0>, Bool()), Var(<clbit 1>, Bool()), Bool())",
        "api_signature": "logic_or()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/constructors.py"
    },
    {
        "api_name": "_equal_like",
        "full_api_name": "_equal_like",
        "api_description": "",
        "api_signature": "_equal_like(op, left, right)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/constructors.py"
    },
    {
        "api_name": "equal",
        "full_api_name": "equal",
        "api_description": "Create an 'equal' expression node from the given value, resolving any implicit casts and\nlifting the values into :class:`Value` nodes if required.\n\nExamples:\n    Equality between a classical register and an integer::\n\n        >>> from qiskit.circuit import ClassicalRegister\n        >>> from qiskit.circuit.classical import expr\n        >>> expr.equal(ClassicalRegister(3, \"c\"), 7)\n        Binary(Binary.Op.EQUAL, Var(ClassicalRegister(3, \"c\"), Uint(3)), Value(7, Uint(3)), Uint(3))",
        "api_signature": "equal()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/constructors.py"
    },
    {
        "api_name": "not_equal",
        "full_api_name": "not_equal",
        "api_description": "Create a 'not equal' expression node from the given value, resolving any implicit casts and\nlifting the values into :class:`Value` nodes if required.\n\nExamples:\n    Inequality between a classical register and an integer::\n\n        >>> from qiskit.circuit import ClassicalRegister\n        >>> from qiskit.circuit.classical import expr\n        >>> expr.not_equal(ClassicalRegister(3, \"c\"), 7)\n        Binary(Binary.Op.NOT_EQUAL, Var(ClassicalRegister(3, \"c\"), Uint(3)), Value(7, Uint(3)), Uint(3))",
        "api_signature": "not_equal()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/constructors.py"
    },
    {
        "api_name": "_binary_relation",
        "full_api_name": "_binary_relation",
        "api_description": "",
        "api_signature": "_binary_relation(op, left, right)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/constructors.py"
    },
    {
        "api_name": "less",
        "full_api_name": "less",
        "api_description": "Create a 'less than' expression node from the given value, resolving any implicit casts and\nlifting the values into :class:`Value` nodes if required.\n\nExamples:\n    Query if a classical register is less than an integer::\n\n        >>> from qiskit.circuit import ClassicalRegister\n        >>> from qiskit.circuit.classical import expr\n        >>> expr.less(ClassicalRegister(3, \"c\"), 5)\n        Binary(Binary.Op.LESS, Var(ClassicalRegister(3, \"c\"), Uint(3)), Value(5, Uint(3)), Uint(3))",
        "api_signature": "less()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/constructors.py"
    },
    {
        "api_name": "less_equal",
        "full_api_name": "less_equal",
        "api_description": "Create a 'less than or equal to' expression node from the given value, resolving any implicit\ncasts and lifting the values into :class:`Value` nodes if required.\n\nExamples:\n    Query if a classical register is less than or equal to another::\n\n        >>> from qiskit.circuit import ClassicalRegister\n        >>> from qiskit.circuit.classical import expr\n        >>> expr.less(ClassicalRegister(3, \"a\"), ClassicalRegister(3, \"b\"))\n        Binary(Binary.Op.LESS_EQUAL, Var(ClassicalRegister(3, \"a\"), Uint(3)), Var(ClassicalRegister(3, \"b\"), Uint(3)), Uint(3))",
        "api_signature": "less_equal()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/constructors.py"
    },
    {
        "api_name": "greater",
        "full_api_name": "greater",
        "api_description": "Create a 'greater than' expression node from the given value, resolving any implicit casts\nand lifting the values into :class:`Value` nodes if required.\n\nExamples:\n    Query if a classical register is greater than an integer::\n\n        >>> from qiskit.circuit import ClassicalRegister\n        >>> from qiskit.circuit.classical import expr\n        >>> expr.less(ClassicalRegister(3, \"c\"), 5)\n        Binary(Binary.Op.GREATER, Var(ClassicalRegister(3, \"c\"), Uint(3)), Value(5, Uint(3)), Uint(3))",
        "api_signature": "greater()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/constructors.py"
    },
    {
        "api_name": "greater_equal",
        "full_api_name": "greater_equal",
        "api_description": "Create a 'greater than or equal to' expression node from the given value, resolving any\nimplicit casts and lifting the values into :class:`Value` nodes if required.\n\nExamples:\n    Query if a classical register is greater than or equal to another::\n\n        >>> from qiskit.circuit import ClassicalRegister\n        >>> from qiskit.circuit.classical import expr\n        >>> expr.less(ClassicalRegister(3, \"a\"), ClassicalRegister(3, \"b\"))\n        Binary(Binary.Op.GREATER_EQUAL, Var(ClassicalRegister(3, \"a\"), Uint(3)), Var(ClassicalRegister(3, \"b\"), Uint(3)), Uint(3))",
        "api_signature": "greater_equal()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/constructors.py"
    },
    {
        "api_name": "visit_generic",
        "full_api_name": "ExprVisitor.visit_generic",
        "api_description": "",
        "api_signature": "visit_generic()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/visitors.py"
    },
    {
        "api_name": "visit_var",
        "full_api_name": "ExprVisitor.visit_var",
        "api_description": "",
        "api_signature": "visit_var()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/visitors.py"
    },
    {
        "api_name": "visit_value",
        "full_api_name": "ExprVisitor.visit_value",
        "api_description": "",
        "api_signature": "visit_value()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/visitors.py"
    },
    {
        "api_name": "visit_unary",
        "full_api_name": "ExprVisitor.visit_unary",
        "api_description": "",
        "api_signature": "visit_unary()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/visitors.py"
    },
    {
        "api_name": "visit_binary",
        "full_api_name": "ExprVisitor.visit_binary",
        "api_description": "",
        "api_signature": "visit_binary()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/visitors.py"
    },
    {
        "api_name": "visit_cast",
        "full_api_name": "ExprVisitor.visit_cast",
        "api_description": "",
        "api_signature": "visit_cast()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/visitors.py"
    },
    {
        "api_name": "visit_var",
        "full_api_name": "_VarWalkerImpl.visit_var",
        "api_description": "",
        "api_signature": "visit_var()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/visitors.py"
    },
    {
        "api_name": "visit_value",
        "full_api_name": "_VarWalkerImpl.visit_value",
        "api_description": "",
        "api_signature": "visit_value()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/visitors.py"
    },
    {
        "api_name": "visit_unary",
        "full_api_name": "_VarWalkerImpl.visit_unary",
        "api_description": "",
        "api_signature": "visit_unary()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/visitors.py"
    },
    {
        "api_name": "visit_binary",
        "full_api_name": "_VarWalkerImpl.visit_binary",
        "api_description": "",
        "api_signature": "visit_binary()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/visitors.py"
    },
    {
        "api_name": "visit_cast",
        "full_api_name": "_VarWalkerImpl.visit_cast",
        "api_description": "",
        "api_signature": "visit_cast()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/visitors.py"
    },
    {
        "api_name": "iter_vars",
        "full_api_name": "iter_vars",
        "api_description": "Get an iterator over the :class:`~.expr.Var` nodes referenced at any level in the given\n:class:`~.expr.Expr`.\n\nExamples:\n    Print out the name of each :class:`.ClassicalRegister` encountered::\n\n        from qiskit.circuit import ClassicalRegister\n        from qiskit.circuit.classical import expr\n\n        cr1 = ClassicalRegister(3, \"a\")\n        cr2 = ClassicalRegister(3, \"b\")\n\n        for node in expr.iter_vars(expr.bit_and(expr.bit_not(cr1), cr2)):\n            if isinstance(node.var, ClassicalRegister):\n                print(node.var.name)",
        "api_signature": "iter_vars(node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/visitors.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "_StructuralEquivalenceImpl.__init__",
        "api_description": "",
        "api_signature": "__init__(self, other, self_key, other_key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/visitors.py"
    },
    {
        "api_name": "visit_var",
        "full_api_name": "_StructuralEquivalenceImpl.visit_var",
        "api_description": "",
        "api_signature": "visit_var()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/visitors.py"
    },
    {
        "api_name": "visit_value",
        "full_api_name": "_StructuralEquivalenceImpl.visit_value",
        "api_description": "",
        "api_signature": "visit_value()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/visitors.py"
    },
    {
        "api_name": "visit_unary",
        "full_api_name": "_StructuralEquivalenceImpl.visit_unary",
        "api_description": "",
        "api_signature": "visit_unary()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/visitors.py"
    },
    {
        "api_name": "visit_binary",
        "full_api_name": "_StructuralEquivalenceImpl.visit_binary",
        "api_description": "",
        "api_signature": "visit_binary()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/visitors.py"
    },
    {
        "api_name": "visit_cast",
        "full_api_name": "_StructuralEquivalenceImpl.visit_cast",
        "api_description": "",
        "api_signature": "visit_cast()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/visitors.py"
    },
    {
        "api_name": "structurally_equivalent",
        "full_api_name": "structurally_equivalent",
        "api_description": "Do these two expressions have exactly the same tree structure, up to some key function for\nthe :class:`~.expr.Var` objects?\n\nIn other words, are these two expressions the exact same trees, except we compare the\n:attr:`.Var.var` fields by calling the appropriate ``*_var_key`` function on them, and comparing\nthat output for equality.  This function does not allow any semantic \"equivalences\" such as\nasserting that ``a == b`` is equivalent to ``b == a``; the evaluation order of the operands\ncould, in general, cause such a statement to be false (consider hypothetical ``extern``\nfunctions that access global state).\n\nThere's no requirements on the key functions, except that their outputs should have general\n``__eq__`` methods.  If a key function returns ``None``, the variable will be used verbatim\ninstead.\n\nArgs:\n    left: one of the :class:`~.expr.Expr` nodes.\n    right: the other :class:`~.expr.Expr` node.\n    left_var_key: a callable whose output should be used when comparing :attr:`.Var.var`\n        attributes.  If this argument is ``None`` or its output is ``None`` for a given\n        variable in ``left``, the variable will be used verbatim.\n    right_var_key: same as ``left_var_key``, but used on the variables in ``right`` instead.\n\nExamples:\n    Comparing two expressions for structural equivalence, with no remapping of the variables.\n    These are different because the different :class:`.Clbit` instances compare differently::\n\n        >>> from qiskit.circuit import Clbit\n        >>> from qiskit.circuit.classical import expr\n        >>> left_bits = [Clbit(), Clbit()]\n        >>> right_bits = [Clbit(), Clbit()]\n        >>> left = expr.logic_and(expr.logic_not(left_bits[0]), left_bits[1])\n        >>> right = expr.logic_and(expr.logic_not(right_bits[0]), right_bits[1])\n        >>> expr.structurally_equivalent(left, right)\n        False\n\n    Comparing the same two expressions, but this time using mapping functions that associate\n    the bits with simple indices::\n\n        >>> left_key = {var: i for i, var in enumerate(left_bits)}.get\n        >>> right_key = {var: i for i, var in enumerate(right_bits)}.get\n        >>> expr.structurally_equivalent(left, right, left_key, right_key)\n        True",
        "api_signature": "structurally_equivalent(left, right, left_var_key, right_var_key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/visitors.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Expr.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/expr.py"
    },
    {
        "api_name": "accept",
        "full_api_name": "Expr.accept",
        "api_description": "Call the relevant ``visit_*`` method on the given :class:`ExprVisitor`.  The usual entry\npoint for a simple visitor is to construct it, and then call :meth:`accept` on the root\nobject to be visited.  For example::\n\n    expr = ...\n    visitor = MyVisitor()\n    visitor.accept(expr)\n\nSubclasses of :class:`Expr` should override this to call the correct virtual method on the\nvisitor.  This implements double dispatch with the visitor.",
        "api_signature": "accept()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/expr.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Cast.__init__",
        "api_description": "",
        "api_signature": "__init__(self, operand, type, implicit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/expr.py"
    },
    {
        "api_name": "accept",
        "full_api_name": "Cast.accept",
        "api_description": "",
        "api_signature": "accept()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/expr.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "Cast.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/expr.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "Cast.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/expr.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Var.__init__",
        "api_description": "",
        "api_signature": "__init__(self, var, type)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/expr.py"
    },
    {
        "api_name": "accept",
        "full_api_name": "Var.accept",
        "api_description": "",
        "api_signature": "accept()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/expr.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "Var.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/expr.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "Var.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/expr.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Value.__init__",
        "api_description": "",
        "api_signature": "__init__(self, value, type)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/expr.py"
    },
    {
        "api_name": "accept",
        "full_api_name": "Value.accept",
        "api_description": "",
        "api_signature": "accept()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/expr.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "Value.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/expr.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "Value.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/expr.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "Op.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/expr.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "Op.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/expr.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "__init__",
        "api_description": "",
        "api_signature": "__init__(self, op, operand, type)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/expr.py"
    },
    {
        "api_name": "accept",
        "full_api_name": "accept",
        "api_description": "",
        "api_signature": "accept()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/expr.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/expr.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/expr.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "Op.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/expr.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "Op.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/expr.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "__init__",
        "api_description": "",
        "api_signature": "__init__(self, op, left, right, type)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/expr.py"
    },
    {
        "api_name": "accept",
        "full_api_name": "accept",
        "api_description": "",
        "api_signature": "accept()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/expr.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/expr.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/expr.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "WhileLoopOp.__init__",
        "api_description": "",
        "api_signature": "__init__(self, condition, body, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/while_loop.py"
    },
    {
        "api_name": "params",
        "full_api_name": "WhileLoopOp.params",
        "api_description": "",
        "api_signature": "params(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/while_loop.py"
    },
    {
        "api_name": "params",
        "full_api_name": "WhileLoopOp.params",
        "api_description": "",
        "api_signature": "params(self, parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/while_loop.py"
    },
    {
        "api_name": "blocks",
        "full_api_name": "WhileLoopOp.blocks",
        "api_description": "",
        "api_signature": "blocks(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/while_loop.py"
    },
    {
        "api_name": "replace_blocks",
        "full_api_name": "WhileLoopOp.replace_blocks",
        "api_description": "",
        "api_signature": "replace_blocks(self, blocks)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/while_loop.py"
    },
    {
        "api_name": "c_if",
        "full_api_name": "WhileLoopOp.c_if",
        "api_description": "",
        "api_signature": "c_if(self, classical, val)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/while_loop.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "WhileLoopContext.__init__",
        "api_description": "",
        "api_signature": "__init__(self, circuit, condition)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/while_loop.py"
    },
    {
        "api_name": "__enter__",
        "full_api_name": "WhileLoopContext.__enter__",
        "api_description": "",
        "api_signature": "__enter__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/while_loop.py"
    },
    {
        "api_name": "__exit__",
        "full_api_name": "WhileLoopContext.__exit__",
        "api_description": "",
        "api_signature": "__exit__(self, exc_type, exc_val, exc_tb)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/while_loop.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "IfElseOp.__init__",
        "api_description": "",
        "api_signature": "__init__(self, condition, true_body, false_body, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/if_else.py"
    },
    {
        "api_name": "params",
        "full_api_name": "IfElseOp.params",
        "api_description": "",
        "api_signature": "params(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/if_else.py"
    },
    {
        "api_name": "params",
        "full_api_name": "IfElseOp.params",
        "api_description": "",
        "api_signature": "params(self, parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/if_else.py"
    },
    {
        "api_name": "blocks",
        "full_api_name": "IfElseOp.blocks",
        "api_description": "",
        "api_signature": "blocks(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/if_else.py"
    },
    {
        "api_name": "replace_blocks",
        "full_api_name": "IfElseOp.replace_blocks",
        "api_description": "Replace blocks and return new instruction.\n\nArgs:\n    blocks: Iterable of circuits for \"if\" and \"else\" condition. If there is no \"else\"\n        circuit it may be set to None or omitted.\n\nReturns:\n    New IfElseOp with replaced blocks.",
        "api_signature": "replace_blocks(self, blocks)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/if_else.py"
    },
    {
        "api_name": "c_if",
        "full_api_name": "IfElseOp.c_if",
        "api_description": "",
        "api_signature": "c_if(self, classical, val)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/if_else.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "IfElsePlaceholder.__init__",
        "api_description": "Args:\n    condition: the condition to execute the true block on.  This has the same semantics as\n        the ``condition`` argument to :obj:`.IfElseOp`.\n    true_block: the unbuilt scope block that will become the \"true\" branch at creation time.\n    false_block: if given, the unbuilt scope block that will become the \"false\" branch at\n        creation time.\n    label: the label to give the operator when it is created.",
        "api_signature": "__init__(self, condition, true_block, false_block)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/if_else.py"
    },
    {
        "api_name": "with_false_block",
        "full_api_name": "IfElsePlaceholder.with_false_block",
        "api_description": "Return a new placeholder instruction, with the false block set to the given value,\nupdating the bits used by both it and the true body, if necessary.\n\nIt is an error to try and set the false block on a placeholder that already has one.\n\nArgs:\n    false_block: The (unbuilt) instruction scope to set the false body to.\n\nReturns:\n    A new placeholder, with ``false_block`` set to the given input, and both true and false\n    blocks expanded to account for all resources.\n\nRaises:\n    CircuitError: if the false block of this placeholder instruction is already set.",
        "api_signature": "with_false_block(self, false_block)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/if_else.py"
    },
    {
        "api_name": "registers",
        "full_api_name": "IfElsePlaceholder.registers",
        "api_description": "Get the registers used by the interior blocks.",
        "api_signature": "registers(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/if_else.py"
    },
    {
        "api_name": "_calculate_placeholder_resources",
        "full_api_name": "IfElsePlaceholder._calculate_placeholder_resources",
        "api_description": "Get the placeholder resources (see :meth:`.placeholder_resources`).\n\nThis is a separate function because we use the resources during the initialisation to\ndetermine how we should set our ``num_qubits`` and ``num_clbits``, so we implement the\npublic version as a cache access for efficiency.",
        "api_signature": "_calculate_placeholder_resources(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/if_else.py"
    },
    {
        "api_name": "placeholder_resources",
        "full_api_name": "IfElsePlaceholder.placeholder_resources",
        "api_description": "",
        "api_signature": "placeholder_resources(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/if_else.py"
    },
    {
        "api_name": "concrete_instruction",
        "full_api_name": "IfElsePlaceholder.concrete_instruction",
        "api_description": "",
        "api_signature": "concrete_instruction(self, qubits, clbits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/if_else.py"
    },
    {
        "api_name": "c_if",
        "full_api_name": "IfElsePlaceholder.c_if",
        "api_description": "",
        "api_signature": "c_if(self, classical, val)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/if_else.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "IfContext.__init__",
        "api_description": "",
        "api_signature": "__init__(self, circuit, condition)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/if_else.py"
    },
    {
        "api_name": "circuit",
        "full_api_name": "IfContext.circuit",
        "api_description": "Get the circuit that this context manager is attached to.",
        "api_signature": "circuit(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/if_else.py"
    },
    {
        "api_name": "condition",
        "full_api_name": "IfContext.condition",
        "api_description": "Get the expression that this statement is conditioned on.",
        "api_signature": "condition(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/if_else.py"
    },
    {
        "api_name": "appended_instructions",
        "full_api_name": "IfContext.appended_instructions",
        "api_description": "Get the instruction set that was created when this block finished.  If the block has not\nyet finished, then this will be ``None``.",
        "api_signature": "appended_instructions(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/if_else.py"
    },
    {
        "api_name": "in_loop",
        "full_api_name": "IfContext.in_loop",
        "api_description": "Whether this context manager is enclosed within a loop.",
        "api_signature": "in_loop(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/if_else.py"
    },
    {
        "api_name": "__enter__",
        "full_api_name": "IfContext.__enter__",
        "api_description": "",
        "api_signature": "__enter__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/if_else.py"
    },
    {
        "api_name": "__exit__",
        "full_api_name": "IfContext.__exit__",
        "api_description": "",
        "api_signature": "__exit__(self, exc_type, exc_val, exc_tb)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/if_else.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ElseContext.__init__",
        "api_description": "",
        "api_signature": "__init__(self, if_context)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/if_else.py"
    },
    {
        "api_name": "__enter__",
        "full_api_name": "ElseContext.__enter__",
        "api_description": "",
        "api_signature": "__enter__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/if_else.py"
    },
    {
        "api_name": "__exit__",
        "full_api_name": "ElseContext.__exit__",
        "api_description": "",
        "api_signature": "__exit__(self, exc_type, exc_val, exc_tb)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/if_else.py"
    },
    {
        "api_name": "blocks",
        "full_api_name": "ControlFlowOp.blocks",
        "api_description": "Tuple of QuantumCircuits which may be executed as part of the\nexecution of this ControlFlowOp. May be parameterized by a loop\nparameter to be resolved at run time.",
        "api_signature": "blocks(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/control_flow.py"
    },
    {
        "api_name": "replace_blocks",
        "full_api_name": "ControlFlowOp.replace_blocks",
        "api_description": "Replace blocks and return new instruction.\nArgs:\n    blocks: Tuple of QuantumCircuits to replace in instruction.\n\nReturns:\n    New ControlFlowOp with replaced blocks.",
        "api_signature": "replace_blocks(self, blocks)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/control_flow.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BreakLoopOp.__init__",
        "api_description": "",
        "api_signature": "__init__(self, num_qubits, num_clbits, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/break_loop.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BreakLoopPlaceholder.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/break_loop.py"
    },
    {
        "api_name": "concrete_instruction",
        "full_api_name": "BreakLoopPlaceholder.concrete_instruction",
        "api_description": "",
        "api_signature": "concrete_instruction(self, qubits, clbits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/break_loop.py"
    },
    {
        "api_name": "placeholder_resources",
        "full_api_name": "BreakLoopPlaceholder.placeholder_resources",
        "api_description": "",
        "api_signature": "placeholder_resources(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/break_loop.py"
    },
    {
        "api_name": "concrete_instruction",
        "full_api_name": "InstructionPlaceholder.concrete_instruction",
        "api_description": "Get a concrete, complete instruction that is valid to act over all the given resources.\n\nThe returned resources may not be the full width of the given resources, but will certainly\nbe a subset of them; this can occur if (for example) a placeholder ``if`` statement is\npresent, but does not itself contain any placeholder instructions.  For resource efficiency,\nthe returned :class:`.ControlFlowOp` will not unnecessarily span all resources, but only the\nones that it needs.\n\n.. note::\n\n    The caller of this function is responsible for ensuring that the inputs to this function\n    are non-strict supersets of the bits returned by :meth:`placeholder_resources`.\n\nAny condition added in by a call to :obj:`.Instruction.c_if` will be propagated through, but\nset properties like ``duration`` will not; it doesn't make sense for control-flow operations\nto have pulse scheduling on them.\n\nArgs:\n    qubits: The qubits the created instruction should be defined across.\n    clbits: The clbits the created instruction should be defined across.\n\nReturns:\n    A full version of the relevant control-flow instruction, and the resources that it uses.\n    This is a \"proper\" instruction instance, as if it had been defined with the correct\n    number of qubits and clbits from the beginning.",
        "api_signature": "concrete_instruction(self, qubits, clbits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/builder.py"
    },
    {
        "api_name": "placeholder_resources",
        "full_api_name": "InstructionPlaceholder.placeholder_resources",
        "api_description": "Get the qubit and clbit resources that this placeholder instruction should be considered\nas using before construction.\n\nThis will likely not include *all* resources after the block has been built, but using the\noutput of this method ensures that all resources will pass through a\n:meth:`.QuantumCircuit.append` call, even if they come from a placeholder, and consequently\nwill be tracked by the scope managers.\n\nReturns:\n    A collection of the quantum and classical resources this placeholder instruction will\n    certainly use.",
        "api_signature": "placeholder_resources(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/builder.py"
    },
    {
        "api_name": "_copy_mutable_properties",
        "full_api_name": "InstructionPlaceholder._copy_mutable_properties",
        "api_description": "Copy mutable properties from ourselves onto a non-placeholder instruction.\n\nThe mutable properties are expected to be things like ``condition``, added onto a\nplaceholder by the :meth:`c_if` method.  This mutates ``instruction``, and returns the same\ninstance that was passed.  This is mostly intended to make writing concrete versions of\n:meth:`.concrete_instruction` easy.\n\nThe complete list of mutations is:\n\n* ``condition``, added by :meth:`c_if`.\n\nArgs:\n    instruction: the concrete instruction instance to be mutated.\n\nReturns:\n    The same instruction instance that was passed, but mutated to propagate the tracked\n    changes to this class.",
        "api_signature": "_copy_mutable_properties(self, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/builder.py"
    },
    {
        "api_name": "assemble",
        "full_api_name": "InstructionPlaceholder.assemble",
        "api_description": "",
        "api_signature": "assemble(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/builder.py"
    },
    {
        "api_name": "qasm",
        "full_api_name": "InstructionPlaceholder.qasm",
        "api_description": "",
        "api_signature": "qasm(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/builder.py"
    },
    {
        "api_name": "repeat",
        "full_api_name": "InstructionPlaceholder.repeat",
        "api_description": "",
        "api_signature": "repeat(self, n)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/builder.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ControlFlowBuilderBlock.__init__",
        "api_description": "Args:\n    qubits: Any qubits this scope should consider itself as using from the beginning.\n    clbits: Any clbits this scope should consider itself as using from the beginning.  Along\n        with ``qubits``, this is useful for things such as ``if`` and ``while`` loop\n        builders, where the classical condition has associated resources, and is known when\n        this scope is created.\n    registers: Any registers this scope should consider itself as using from the\n        beginning.  This is useful for :obj:`.IfElseOp` and :obj:`.WhileLoopOp` instances\n        which use a classical register as their condition.\n    allow_jumps: Whether this builder scope should allow ``break`` and ``continue``\n        statements within it.  This is intended to help give sensible error messages when\n        dangerous behaviour is encountered, such as using ``break`` inside an ``if`` context\n        manager that is not within a ``for`` manager.  This can only be safe if the user is\n        going to place the resulting :obj:`.QuantumCircuit` inside a :obj:`.ForLoopOp` that\n        uses *exactly* the same set of resources.  We cannot verify this from within the\n        builder interface (and it is too expensive to do when the ``for`` op is made), so we\n        fail safe, and require the user to use the more verbose, internal form.\n    resource_requester: A callback function that takes in some classical resource specifier,\n        and returns a concrete classical resource, if this scope is allowed to access that\n        resource.  In almost all cases, this should be a resolver from the\n        :obj:`.QuantumCircuit` that this scope is contained in.  See\n        :meth:`.QuantumCircuit._resolve_classical_resource` for the normal expected input\n        here, and the documentation of :obj:`.InstructionSet`, which uses this same\n        callback.\n    forbidden_message: If a string is given here, a :exc:`.CircuitError` will be raised on\n        any attempts to append instructions to the scope with this message.  This is used by\n        pseudo scopes where the state machine of the builder scopes has changed into a\n        position where no instructions should be accepted, such as when inside a ``switch``\n        but outside any cases.",
        "api_signature": "__init__(self, qubits, clbits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/builder.py"
    },
    {
        "api_name": "allow_jumps",
        "full_api_name": "ControlFlowBuilderBlock.allow_jumps",
        "api_description": "Whether this builder scope should allow ``break`` and ``continue`` statements within it.\n\nThis is intended to help give sensible error messages when dangerous behaviour is\nencountered, such as using ``break`` inside an ``if`` context manager that is not within a\n``for`` manager.  This can only be safe if the user is going to place the resulting\n:obj:`.QuantumCircuit` inside a :obj:`.ForLoopOp` that uses *exactly* the same set of\nresources.  We cannot verify this from within the builder interface (and it is too expensive\nto do when the ``for`` op is made), so we fail safe, and require the user to use the more\nverbose, internal form.",
        "api_signature": "allow_jumps(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/builder.py"
    },
    {
        "api_name": "append",
        "full_api_name": "ControlFlowBuilderBlock.append",
        "api_description": "Add an instruction into the scope, keeping track of the qubits and clbits that have been\nused in total.",
        "api_signature": "append(self, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/builder.py"
    },
    {
        "api_name": "request_classical_resource",
        "full_api_name": "ControlFlowBuilderBlock.request_classical_resource",
        "api_description": "Resolve a single classical resource specifier into a concrete resource, raising an error\nif the specifier is invalid, and track it as now being used in scope.\n\nArgs:\n    specifier (Union[Clbit, ClassicalRegister, int]): a specifier of a classical resource\n        present in this circuit.  An ``int`` will be resolved into a :obj:`.Clbit` using the\n        same conventions that measurement operations on this circuit use.\n\nReturns:\n    Union[Clbit, ClassicalRegister]: the requested resource, resolved into a concrete\n    instance of :obj:`.Clbit` or :obj:`.ClassicalRegister`.\n\nRaises:\n    CircuitError: if the resource is not present in this circuit, or if the integer index\n        passed is out-of-bounds.",
        "api_signature": "request_classical_resource(self, specifier)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/builder.py"
    },
    {
        "api_name": "peek",
        "full_api_name": "ControlFlowBuilderBlock.peek",
        "api_description": "Get the value of the most recent instruction tuple in this scope.",
        "api_signature": "peek(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/builder.py"
    },
    {
        "api_name": "pop",
        "full_api_name": "ControlFlowBuilderBlock.pop",
        "api_description": "Get the value of the most recent instruction in this scope, and remove it from this\nobject.",
        "api_signature": "pop(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/builder.py"
    },
    {
        "api_name": "add_bits",
        "full_api_name": "ControlFlowBuilderBlock.add_bits",
        "api_description": "Add extra bits to this scope that are not associated with any concrete instruction yet.\n\nThis is useful for expanding a scope's resource width when it may contain ``break`` or\n``continue`` statements, or when its width needs to be expanded to match another scope's\nwidth (as in the case of :obj:`.IfElseOp`).\n\nArgs:\n    bits: The qubits and clbits that should be added to a scope.  It is not an error if\n        there are duplicates, either within the iterable or with the bits currently in\n        scope.\n\nRaises:\n    TypeError: if the provided bit is of an incorrect type.",
        "api_signature": "add_bits(self, bits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/builder.py"
    },
    {
        "api_name": "add_register",
        "full_api_name": "ControlFlowBuilderBlock.add_register",
        "api_description": "Add a :obj:`.Register` to the set of resources used by this block, ensuring that\nall bits contained within are also accounted for.\n\nArgs:\n    register: the register to add to the block.",
        "api_signature": "add_register(self, register)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/builder.py"
    },
    {
        "api_name": "build",
        "full_api_name": "ControlFlowBuilderBlock.build",
        "api_description": "Build this scoped block into a complete :obj:`.QuantumCircuit` instance.\n\nThis will build a circuit which contains all of the necessary qubits and clbits and no\nothers.\n\nThe ``qubits`` and ``clbits`` arguments should be sets that contains all the resources in\nthe outer scope; these will be passed down to inner placeholder instructions, so they can\napply themselves across the whole scope should they need to.  The resulting\n:obj:`.QuantumCircuit` will be defined over a (nonstrict) subset of these resources.  This\nis used to let ``break`` and ``continue`` span all resources, even if they are nested within\nseveral :obj:`.IfElsePlaceholder` objects, without requiring :obj:`.IfElsePlaceholder`\nobjects *without* any ``break`` or ``continue`` statements to be full-width.\n\nArgs:\n    all_qubits: all the qubits in the containing scope of this block.  The block may expand\n        to use some or all of these qubits, but will never gain qubits that are not in this\n        set.\n    all_clbits: all the clbits in the containing scope of this block.  The block may expand\n        to use some or all of these clbits, but will never gain clbits that are not in this\n        set.\n\nReturns:\n    A circuit containing concrete versions of all the instructions that were in the scope,\n    and using the minimal set of resources necessary to support them, within the enclosing\n    scope.",
        "api_signature": "build(self, all_qubits, all_clbits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/builder.py"
    },
    {
        "api_name": "copy",
        "full_api_name": "ControlFlowBuilderBlock.copy",
        "api_description": "Return a semi-shallow copy of this builder block.\n\nThe instruction lists and sets of qubits and clbits will be new instances (so mutations will\nnot propagate), but any :obj:`.Instruction` instances within them will not be copied.\n\nReturns:\n    a semi-shallow copy of this object.",
        "api_signature": "copy(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/builder.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "_DefaultCaseType.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/switch_case.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SwitchCaseOp.__init__",
        "api_description": "",
        "api_signature": "__init__(self, target, cases)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/switch_case.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "SwitchCaseOp.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/switch_case.py"
    },
    {
        "api_name": "cases_specifier",
        "full_api_name": "SwitchCaseOp.cases_specifier",
        "api_description": "Return an iterable where each element is a 2-tuple whose first element is a tuple of\njump values, and whose second is the single circuit block that is associated with those\nvalues.\n\nThis is an abstract specification of the jump table suitable for creating new\n:class:`.SwitchCaseOp` instances.\n\n.. seealso::\n    :meth:`.SwitchCaseOp.cases`\n        Create a lookup table that you can use for your own purposes to jump from values to\n        the circuit that would be executed.",
        "api_signature": "cases_specifier(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/switch_case.py"
    },
    {
        "api_name": "cases",
        "full_api_name": "SwitchCaseOp.cases",
        "api_description": "Return a lookup table from case labels to the circuit that would be executed in that\ncase.  This object is not generally suitable for creating a new :class:`.SwitchCaseOp`\nbecause any keys that point to the same object will not be grouped.\n\n.. seealso::\n    :meth:`.SwitchCaseOp.cases_specifier`\n        An alternate method that produces its output in a suitable format for creating new\n        :class:`.SwitchCaseOp` instances.",
        "api_signature": "cases(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/switch_case.py"
    },
    {
        "api_name": "blocks",
        "full_api_name": "SwitchCaseOp.blocks",
        "api_description": "",
        "api_signature": "blocks(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/switch_case.py"
    },
    {
        "api_name": "replace_blocks",
        "full_api_name": "SwitchCaseOp.replace_blocks",
        "api_description": "",
        "api_signature": "replace_blocks(self, blocks)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/switch_case.py"
    },
    {
        "api_name": "c_if",
        "full_api_name": "SwitchCaseOp.c_if",
        "api_description": "",
        "api_signature": "c_if(self, classical, val)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/switch_case.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SwitchCasePlaceholder.__init__",
        "api_description": "",
        "api_signature": "__init__(self, target, cases)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/switch_case.py"
    },
    {
        "api_name": "_calculate_placeholder_resources",
        "full_api_name": "SwitchCasePlaceholder._calculate_placeholder_resources",
        "api_description": "",
        "api_signature": "_calculate_placeholder_resources(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/switch_case.py"
    },
    {
        "api_name": "placeholder_resources",
        "full_api_name": "SwitchCasePlaceholder.placeholder_resources",
        "api_description": "",
        "api_signature": "placeholder_resources(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/switch_case.py"
    },
    {
        "api_name": "concrete_instruction",
        "full_api_name": "SwitchCasePlaceholder.concrete_instruction",
        "api_description": "",
        "api_signature": "concrete_instruction(self, qubits, clbits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/switch_case.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SwitchContext.__init__",
        "api_description": "",
        "api_signature": "__init__(self, circuit, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/switch_case.py"
    },
    {
        "api_name": "label_in_use",
        "full_api_name": "SwitchContext.label_in_use",
        "api_description": "Return whether a case label is already accounted for in the switch statement.",
        "api_signature": "label_in_use(self, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/switch_case.py"
    },
    {
        "api_name": "add_case",
        "full_api_name": "SwitchContext.add_case",
        "api_description": "Add a sequence of conditions and the single block that should be run if they are\ntriggered to the context.  The labels are assumed to have already been validated using\n:meth:`label_in_use`.",
        "api_signature": "add_case(self, labels, block)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/switch_case.py"
    },
    {
        "api_name": "__enter__",
        "full_api_name": "SwitchContext.__enter__",
        "api_description": "",
        "api_signature": "__enter__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/switch_case.py"
    },
    {
        "api_name": "__exit__",
        "full_api_name": "SwitchContext.__exit__",
        "api_description": "",
        "api_signature": "__exit__(self, exc_type, exc_val, exc_tb)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/switch_case.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CaseBuilder.__init__",
        "api_description": "",
        "api_signature": "__init__(self, parent)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/switch_case.py"
    },
    {
        "api_name": "__call__",
        "full_api_name": "CaseBuilder.__call__",
        "api_description": "",
        "api_signature": "__call__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/switch_case.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ForLoopOp.__init__",
        "api_description": "",
        "api_signature": "__init__(self, indexset, loop_parameter, body, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/for_loop.py"
    },
    {
        "api_name": "params",
        "full_api_name": "ForLoopOp.params",
        "api_description": "",
        "api_signature": "params(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/for_loop.py"
    },
    {
        "api_name": "params",
        "full_api_name": "ForLoopOp.params",
        "api_description": "",
        "api_signature": "params(self, parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/for_loop.py"
    },
    {
        "api_name": "blocks",
        "full_api_name": "ForLoopOp.blocks",
        "api_description": "",
        "api_signature": "blocks(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/for_loop.py"
    },
    {
        "api_name": "replace_blocks",
        "full_api_name": "ForLoopOp.replace_blocks",
        "api_description": "",
        "api_signature": "replace_blocks(self, blocks)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/for_loop.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ForLoopContext.__init__",
        "api_description": "",
        "api_signature": "__init__(self, circuit, indexset, loop_parameter)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/for_loop.py"
    },
    {
        "api_name": "__enter__",
        "full_api_name": "ForLoopContext.__enter__",
        "api_description": "",
        "api_signature": "__enter__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/for_loop.py"
    },
    {
        "api_name": "__exit__",
        "full_api_name": "ForLoopContext.__exit__",
        "api_description": "",
        "api_signature": "__exit__(self, exc_type, exc_val, exc_tb)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/for_loop.py"
    },
    {
        "api_name": "validate_condition",
        "full_api_name": "validate_condition",
        "api_description": "Validate that a condition is in a valid format and return it, but raise if it is invalid.\n\nArgs:\n    condition: the condition to be tested for validity.  Must be either the legacy 2-tuple\n        format, or a :class:`~.expr.Expr` that has `Bool` type.\n\nRaises:\n    CircuitError: if the condition is not in a valid format.\n\nReturns:\n    The same condition as passed, if it was valid.",
        "api_signature": "validate_condition(condition)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/_builder_utils.py"
    },
    {
        "api_name": "node_resources",
        "full_api_name": "node_resources",
        "api_description": "Get the legacy classical resources (:class:`.Clbit` and :class:`.ClassicalRegister`)\nreferenced by an :class:`~.expr.Expr`.",
        "api_signature": "node_resources(node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/_builder_utils.py"
    },
    {
        "api_name": "condition_resources",
        "full_api_name": "condition_resources",
        "api_description": "Get the legacy classical resources (:class:`.Clbit` and :class:`.ClassicalRegister`)\nreferenced by a legacy condition or an :class:`~.expr.Expr`.",
        "api_signature": "condition_resources(condition)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/_builder_utils.py"
    },
    {
        "api_name": "partition_registers",
        "full_api_name": "partition_registers",
        "api_description": "Partition a sequence of registers into its quantum and classical registers.",
        "api_signature": "partition_registers(registers)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/_builder_utils.py"
    },
    {
        "api_name": "unify_circuit_resources",
        "full_api_name": "unify_circuit_resources",
        "api_description": "Ensure that all the given ``circuits`` have all the same qubits, clbits and registers, and\nthat they are defined in the same order.  The order is important for binding when the bodies are\nused in the 3-tuple :obj:`.Instruction` context.\n\nThis function will preferentially try to mutate its inputs if they share an ordering, but if\nnot, it will rebuild two new circuits.  This is to avoid coupling too tightly to the inner\nclass; there is no real support for deleting or re-ordering bits within a :obj:`.QuantumCircuit`\ncontext, and we don't want to rely on the *current* behaviour of the private APIs, since they\nare very liable to change.  No matter the method used, circuits with unified bits and registers\nare returned.",
        "api_signature": "unify_circuit_resources(circuits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/_builder_utils.py"
    },
    {
        "api_name": "_unify_circuit_resources_rebuild",
        "full_api_name": "_unify_circuit_resources_rebuild",
        "api_description": "Ensure that all the given circuits have all the same qubits and clbits, and that they\nare defined in the same order.  The order is important for binding when the bodies are used in\nthe 3-tuple :obj:`.Instruction` context.\n\nThis function will always rebuild the objects into new :class:`.QuantumCircuit` instances.",
        "api_signature": "_unify_circuit_resources_rebuild(circuits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/_builder_utils.py"
    },
    {
        "api_name": "_unify_circuit_registers",
        "full_api_name": "_unify_circuit_registers",
        "api_description": "Ensure that ``true_body`` and ``false_body`` have the same registers defined within them.  These\ndo not need to be in the same order between circuits.  The two input circuits are returned,\nmutated to have the same registers.",
        "api_signature": "_unify_circuit_registers(circuits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/_builder_utils.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ContinueLoopOp.__init__",
        "api_description": "",
        "api_signature": "__init__(self, num_qubits, num_clbits, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/continue_loop.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ContinueLoopPlaceholder.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/continue_loop.py"
    },
    {
        "api_name": "concrete_instruction",
        "full_api_name": "ContinueLoopPlaceholder.concrete_instruction",
        "api_description": "",
        "api_signature": "concrete_instruction(self, qubits, clbits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/continue_loop.py"
    },
    {
        "api_name": "placeholder_resources",
        "full_api_name": "ContinueLoopPlaceholder.placeholder_resources",
        "api_description": "",
        "api_signature": "placeholder_resources(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/continue_loop.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QasmParser.__init__",
        "api_description": "Create the parser.",
        "api_signature": "__init__(self, filename)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "__enter__",
        "full_api_name": "QasmParser.__enter__",
        "api_description": "",
        "api_signature": "__enter__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "__exit__",
        "full_api_name": "QasmParser.__exit__",
        "api_description": "",
        "api_signature": "__exit__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "update_symtab",
        "full_api_name": "QasmParser.update_symtab",
        "api_description": "Update a node in the symbol table.\n\nEverything in the symtab must be a node with these attributes:\nname - the string name of the object\ntype - the string type of the object\nline - the source line where the type was first found\nfile - the source file where the type was first found",
        "api_signature": "update_symtab(self, obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "verify_declared_bit",
        "full_api_name": "QasmParser.verify_declared_bit",
        "api_description": "Verify a qubit id against the gate prototype.",
        "api_signature": "verify_declared_bit(self, obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "verify_bit_list",
        "full_api_name": "QasmParser.verify_bit_list",
        "api_description": "Verify each qubit in a list of ids.",
        "api_signature": "verify_bit_list(self, obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "verify_exp_list",
        "full_api_name": "QasmParser.verify_exp_list",
        "api_description": "Verify each expression in a list.",
        "api_signature": "verify_exp_list(self, obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "verify_as_gate",
        "full_api_name": "QasmParser.verify_as_gate",
        "api_description": "Verify a user defined gate call.",
        "api_signature": "verify_as_gate(self, obj, bitlist, arglist)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "verify_reg",
        "full_api_name": "QasmParser.verify_reg",
        "api_description": "Verify a register.",
        "api_signature": "verify_reg(self, obj, object_type)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "verify_reg_list",
        "full_api_name": "QasmParser.verify_reg_list",
        "api_description": "Verify a list of registers.",
        "api_signature": "verify_reg_list(self, obj, object_type)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "id_tuple_list",
        "full_api_name": "QasmParser.id_tuple_list",
        "api_description": "Return a list of (name, index) tuples for this id node.",
        "api_signature": "id_tuple_list(self, id_node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "verify_distinct",
        "full_api_name": "QasmParser.verify_distinct",
        "api_description": "Check that objects in list_of_nodes represent distinct (qu)bits.\n\nlist_of_nodes is a list containing nodes of type id, indexed_id,\nprimary_list, or id_list. We assume these are all the same type\n'qreg' or 'creg'.\nThis method raises an exception if list_of_nodes refers to the\nsame object more than once.",
        "api_signature": "verify_distinct(self, list_of_nodes)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "pop_scope",
        "full_api_name": "QasmParser.pop_scope",
        "api_description": "Return to the previous scope.",
        "api_signature": "pop_scope(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "push_scope",
        "full_api_name": "QasmParser.push_scope",
        "api_description": "Enter a new scope.",
        "api_signature": "push_scope(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "p_main",
        "full_api_name": "QasmParser.p_main",
        "api_description": "main : program",
        "api_signature": "p_main(self, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "p_program_0",
        "full_api_name": "QasmParser.p_program_0",
        "api_description": "program : statement",
        "api_signature": "p_program_0(self, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "p_program_1",
        "full_api_name": "QasmParser.p_program_1",
        "api_description": "program : program statement",
        "api_signature": "p_program_1(self, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "p_statement",
        "full_api_name": "QasmParser.p_statement",
        "api_description": "statement : decl\n          | quantum_op ';'\n          | format ';'\n          | ignore\n          | quantum_op error\n          | format error",
        "api_signature": "p_statement(self, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "p_format",
        "full_api_name": "QasmParser.p_format",
        "api_description": "format : FORMAT",
        "api_signature": "p_format(self, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "p_id",
        "full_api_name": "QasmParser.p_id",
        "api_description": "id : ID",
        "api_signature": "p_id(self, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "p_id_e",
        "full_api_name": "QasmParser.p_id_e",
        "api_description": "id : error",
        "api_signature": "p_id_e(self, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "p_indexed_id",
        "full_api_name": "QasmParser.p_indexed_id",
        "api_description": "indexed_id : id '[' NNINTEGER ']'\n           | id '[' NNINTEGER error\n           | id '[' error",
        "api_signature": "p_indexed_id(self, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "p_primary",
        "full_api_name": "QasmParser.p_primary",
        "api_description": "primary : id\n        | indexed_id",
        "api_signature": "p_primary(self, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "p_id_list_0",
        "full_api_name": "QasmParser.p_id_list_0",
        "api_description": "id_list : id",
        "api_signature": "p_id_list_0(self, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "p_id_list_1",
        "full_api_name": "QasmParser.p_id_list_1",
        "api_description": "id_list : id_list ',' id",
        "api_signature": "p_id_list_1(self, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "p_gate_id_list_0",
        "full_api_name": "QasmParser.p_gate_id_list_0",
        "api_description": "gate_id_list : id",
        "api_signature": "p_gate_id_list_0(self, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "p_gate_id_list_1",
        "full_api_name": "QasmParser.p_gate_id_list_1",
        "api_description": "gate_id_list : gate_id_list ',' id",
        "api_signature": "p_gate_id_list_1(self, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "p_bit_list_0",
        "full_api_name": "QasmParser.p_bit_list_0",
        "api_description": "bit_list : id",
        "api_signature": "p_bit_list_0(self, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "p_bit_list_1",
        "full_api_name": "QasmParser.p_bit_list_1",
        "api_description": "bit_list : bit_list ',' id",
        "api_signature": "p_bit_list_1(self, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "p_primary_list_0",
        "full_api_name": "QasmParser.p_primary_list_0",
        "api_description": "primary_list : primary",
        "api_signature": "p_primary_list_0(self, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "p_primary_list_1",
        "full_api_name": "QasmParser.p_primary_list_1",
        "api_description": "primary_list : primary_list ',' primary",
        "api_signature": "p_primary_list_1(self, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "p_decl",
        "full_api_name": "QasmParser.p_decl",
        "api_description": "decl : qreg_decl ';'\n     | creg_decl ';'\n     | qreg_decl error\n     | creg_decl error\n     | gate_decl",
        "api_signature": "p_decl(self, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "p_qreg_decl",
        "full_api_name": "QasmParser.p_qreg_decl",
        "api_description": "qreg_decl : QREG indexed_id",
        "api_signature": "p_qreg_decl(self, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "p_qreg_decl_e",
        "full_api_name": "QasmParser.p_qreg_decl_e",
        "api_description": "qreg_decl : QREG error",
        "api_signature": "p_qreg_decl_e(self, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "p_creg_decl",
        "full_api_name": "QasmParser.p_creg_decl",
        "api_description": "creg_decl : CREG indexed_id",
        "api_signature": "p_creg_decl(self, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "p_creg_decl_e",
        "full_api_name": "QasmParser.p_creg_decl_e",
        "api_description": "creg_decl : CREG error",
        "api_signature": "p_creg_decl_e(self, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "p_gate_decl_0",
        "full_api_name": "QasmParser.p_gate_decl_0",
        "api_description": "gate_decl : GATE id gate_scope bit_list gate_body",
        "api_signature": "p_gate_decl_0(self, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "p_gate_decl_1",
        "full_api_name": "QasmParser.p_gate_decl_1",
        "api_description": "gate_decl : GATE id gate_scope '(' ')' bit_list gate_body",
        "api_signature": "p_gate_decl_1(self, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "p_gate_decl_2",
        "full_api_name": "QasmParser.p_gate_decl_2",
        "api_description": "gate_decl : GATE id gate_scope '(' gate_id_list ')' bit_list gate_body",
        "api_signature": "p_gate_decl_2(self, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "p_gate_scope",
        "full_api_name": "QasmParser.p_gate_scope",
        "api_description": "gate_scope :",
        "api_signature": "p_gate_scope(self, _)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "p_gate_body_0",
        "full_api_name": "QasmParser.p_gate_body_0",
        "api_description": "gate_body : '{' '}'",
        "api_signature": "p_gate_body_0(self, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "p_gate_body_1",
        "full_api_name": "QasmParser.p_gate_body_1",
        "api_description": "gate_body : '{' gate_op_list '}'",
        "api_signature": "p_gate_body_1(self, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "p_gate_op_list_0",
        "full_api_name": "QasmParser.p_gate_op_list_0",
        "api_description": "gate_op_list : gate_op",
        "api_signature": "p_gate_op_list_0(self, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "p_gate_op_list_1",
        "full_api_name": "QasmParser.p_gate_op_list_1",
        "api_description": "gate_op_list : gate_op_list gate_op",
        "api_signature": "p_gate_op_list_1(self, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "p_unitary_op_0",
        "full_api_name": "QasmParser.p_unitary_op_0",
        "api_description": "unitary_op : U '(' exp_list ')' primary",
        "api_signature": "p_unitary_op_0(self, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "p_unitary_op_1",
        "full_api_name": "QasmParser.p_unitary_op_1",
        "api_description": "unitary_op : CX primary ',' primary",
        "api_signature": "p_unitary_op_1(self, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "p_unitary_op_2",
        "full_api_name": "QasmParser.p_unitary_op_2",
        "api_description": "unitary_op : id primary_list",
        "api_signature": "p_unitary_op_2(self, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "p_unitary_op_3",
        "full_api_name": "QasmParser.p_unitary_op_3",
        "api_description": "unitary_op : id '(' ')' primary_list",
        "api_signature": "p_unitary_op_3(self, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "p_unitary_op_4",
        "full_api_name": "QasmParser.p_unitary_op_4",
        "api_description": "unitary_op : id '(' exp_list ')' primary_list",
        "api_signature": "p_unitary_op_4(self, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "p_gate_op_0",
        "full_api_name": "QasmParser.p_gate_op_0",
        "api_description": "gate_op : U '(' exp_list ')' id ';'",
        "api_signature": "p_gate_op_0(self, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "p_gate_op_0e1",
        "full_api_name": "QasmParser.p_gate_op_0e1",
        "api_description": "gate_op : U '(' exp_list ')' error",
        "api_signature": "p_gate_op_0e1(self, p)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "p_gate_op_0e2",
        "full_api_name": "QasmParser.p_gate_op_0e2",
        "api_description": "gate_op : U '(' exp_list error",
        "api_signature": "p_gate_op_0e2(self, _)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "p_gate_op_1",
        "full_api_name": "QasmParser.p_gate_op_1",
        "api_description": "gate_op : CX id ',' id ';'",
        "api_signature": "p_gate_op_1(self, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "p_gate_op_1e1",
        "full_api_name": "QasmParser.p_gate_op_1e1",
        "api_description": "gate_op : CX error",
        "api_signature": "p_gate_op_1e1(self, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "p_gate_op_1e2",
        "full_api_name": "QasmParser.p_gate_op_1e2",
        "api_description": "gate_op : CX id ',' error",
        "api_signature": "p_gate_op_1e2(self, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "p_gate_op_2",
        "full_api_name": "QasmParser.p_gate_op_2",
        "api_description": "gate_op : id id_list ';'",
        "api_signature": "p_gate_op_2(self, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "p_gate_op_2e",
        "full_api_name": "QasmParser.p_gate_op_2e",
        "api_description": "gate_op : id  id_list error",
        "api_signature": "p_gate_op_2e(self, _)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "p_gate_op_3",
        "full_api_name": "QasmParser.p_gate_op_3",
        "api_description": "gate_op : id '(' ')' id_list ';'",
        "api_signature": "p_gate_op_3(self, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "p_gate_op_4",
        "full_api_name": "QasmParser.p_gate_op_4",
        "api_description": "gate_op : id '(' exp_list ')' id_list ';'",
        "api_signature": "p_gate_op_4(self, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "p_gate_op_4e0",
        "full_api_name": "QasmParser.p_gate_op_4e0",
        "api_description": "gate_op : id '(' ')'  error",
        "api_signature": "p_gate_op_4e0(self, _)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "p_gate_op_4e1",
        "full_api_name": "QasmParser.p_gate_op_4e1",
        "api_description": "gate_op : id '('   error",
        "api_signature": "p_gate_op_4e1(self, _)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "p_gate_op_5",
        "full_api_name": "QasmParser.p_gate_op_5",
        "api_description": "gate_op : BARRIER id_list ';'",
        "api_signature": "p_gate_op_5(self, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "p_gate_op_5e",
        "full_api_name": "QasmParser.p_gate_op_5e",
        "api_description": "gate_op : BARRIER error",
        "api_signature": "p_gate_op_5e(self, _)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "p_opaque_0",
        "full_api_name": "QasmParser.p_opaque_0",
        "api_description": "opaque : OPAQUE id gate_scope bit_list",
        "api_signature": "p_opaque_0(self, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "p_opaque_1",
        "full_api_name": "QasmParser.p_opaque_1",
        "api_description": "opaque : OPAQUE id gate_scope '(' ')' bit_list",
        "api_signature": "p_opaque_1(self, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "p_opaque_2",
        "full_api_name": "QasmParser.p_opaque_2",
        "api_description": "opaque : OPAQUE id gate_scope '(' gate_id_list ')' bit_list",
        "api_signature": "p_opaque_2(self, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "p_opaque_1e",
        "full_api_name": "QasmParser.p_opaque_1e",
        "api_description": "opaque : OPAQUE id gate_scope '(' error",
        "api_signature": "p_opaque_1e(self, _)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "p_measure",
        "full_api_name": "QasmParser.p_measure",
        "api_description": "measure : MEASURE primary ASSIGN primary",
        "api_signature": "p_measure(self, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "p_measure_e",
        "full_api_name": "QasmParser.p_measure_e",
        "api_description": "measure : MEASURE primary error",
        "api_signature": "p_measure_e(self, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "p_barrier",
        "full_api_name": "QasmParser.p_barrier",
        "api_description": "barrier : BARRIER primary_list",
        "api_signature": "p_barrier(self, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "p_reset",
        "full_api_name": "QasmParser.p_reset",
        "api_description": "reset : RESET primary",
        "api_signature": "p_reset(self, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "p_if",
        "full_api_name": "QasmParser.p_if",
        "api_description": "if : IF '(' id MATCHES NNINTEGER ')' quantum_op\nif : IF '(' id error\nif : IF '(' id MATCHES error\nif : IF '(' id MATCHES NNINTEGER error\nif : IF error",
        "api_signature": "p_if(self, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "p_quantum_op",
        "full_api_name": "QasmParser.p_quantum_op",
        "api_description": "quantum_op : unitary_op\n           | opaque\n           | measure\n           | barrier\n           | reset\n           | if",
        "api_signature": "p_quantum_op(self, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "p_unary_0",
        "full_api_name": "QasmParser.p_unary_0",
        "api_description": "unary : NNINTEGER",
        "api_signature": "p_unary_0(self, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "p_unary_1",
        "full_api_name": "QasmParser.p_unary_1",
        "api_description": "unary : REAL",
        "api_signature": "p_unary_1(self, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "p_unary_2",
        "full_api_name": "QasmParser.p_unary_2",
        "api_description": "unary : PI",
        "api_signature": "p_unary_2(self, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "p_unary_3",
        "full_api_name": "QasmParser.p_unary_3",
        "api_description": "unary : id",
        "api_signature": "p_unary_3(self, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "p_unary_4",
        "full_api_name": "QasmParser.p_unary_4",
        "api_description": "unary : '(' expression ')'",
        "api_signature": "p_unary_4(self, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "p_unary_6",
        "full_api_name": "QasmParser.p_unary_6",
        "api_description": "unary : id '(' expression ')'",
        "api_signature": "p_unary_6(self, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "p_expression_1",
        "full_api_name": "QasmParser.p_expression_1",
        "api_description": "expression : '-' expression %prec negative\n            | '+' expression %prec positive",
        "api_signature": "p_expression_1(self, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "p_expression_0",
        "full_api_name": "QasmParser.p_expression_0",
        "api_description": "expression : expression '*' expression\n            | expression '/' expression\n            | expression '+' expression\n            | expression '-' expression\n            | expression '^' expression",
        "api_signature": "p_expression_0(self, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "p_expression_2",
        "full_api_name": "QasmParser.p_expression_2",
        "api_description": "expression : unary",
        "api_signature": "p_expression_2(self, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "p_exp_list_0",
        "full_api_name": "QasmParser.p_exp_list_0",
        "api_description": "exp_list : expression",
        "api_signature": "p_exp_list_0(self, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "p_exp_list_1",
        "full_api_name": "QasmParser.p_exp_list_1",
        "api_description": "exp_list : exp_list ',' expression",
        "api_signature": "p_exp_list_1(self, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "p_ignore",
        "full_api_name": "QasmParser.p_ignore",
        "api_description": "ignore : STRING",
        "api_signature": "p_ignore(self, _)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "p_error",
        "full_api_name": "QasmParser.p_error",
        "api_description": "",
        "api_signature": "p_error(self, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "find_column",
        "full_api_name": "QasmParser.find_column",
        "api_description": "Compute the column.\n\nInput is the input text string.\ntoken is a token instance.",
        "api_signature": "find_column(self, input_, token)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "read_tokens",
        "full_api_name": "QasmParser.read_tokens",
        "api_description": "finds and reads the tokens.",
        "api_signature": "read_tokens(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "parse_debug",
        "full_api_name": "QasmParser.parse_debug",
        "api_description": "Set the parse_deb field.",
        "api_signature": "parse_debug(self, val)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "parse",
        "full_api_name": "QasmParser.parse",
        "api_description": "Parse some data.",
        "api_signature": "parse(self, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "print_tree",
        "full_api_name": "QasmParser.print_tree",
        "api_description": "Print parsed OPENQASM.",
        "api_signature": "print_tree(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "run",
        "full_api_name": "QasmParser.run",
        "api_description": "Parser runner.\n\nTo use this module stand-alone.",
        "api_signature": "run(self, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmparser.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Qasm.__init__",
        "api_description": "Create an OPENQASM circuit object.",
        "api_signature": "__init__(self, filename, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasm.py"
    },
    {
        "api_name": "return_filename",
        "full_api_name": "Qasm.return_filename",
        "api_description": "Return the filename.",
        "api_signature": "return_filename(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasm.py"
    },
    {
        "api_name": "generate_tokens",
        "full_api_name": "Qasm.generate_tokens",
        "api_description": "Returns a generator of the tokens.",
        "api_signature": "generate_tokens(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasm.py"
    },
    {
        "api_name": "parse",
        "full_api_name": "Qasm.parse",
        "api_description": "Parse the data.",
        "api_signature": "parse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasm.py"
    },
    {
        "api_name": "__mklexer__",
        "full_api_name": "QasmLexer.__mklexer__",
        "api_description": "Create a PLY lexer.",
        "api_signature": "__mklexer__(self, filename)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmlexer.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QasmLexer.__init__",
        "api_description": "Create the OPENQASM lexer.",
        "api_signature": "__init__(self, filename)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmlexer.py"
    },
    {
        "api_name": "input",
        "full_api_name": "QasmLexer.input",
        "api_description": "Set the input text data.",
        "api_signature": "input(self, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmlexer.py"
    },
    {
        "api_name": "token",
        "full_api_name": "QasmLexer.token",
        "api_description": "Return the next token.",
        "api_signature": "token(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmlexer.py"
    },
    {
        "api_name": "pop",
        "full_api_name": "QasmLexer.pop",
        "api_description": "Pop a PLY lexer off the stack.",
        "api_signature": "pop(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmlexer.py"
    },
    {
        "api_name": "push",
        "full_api_name": "QasmLexer.push",
        "api_description": "Push a PLY lexer on the stack to parse filename.",
        "api_signature": "push(self, filename)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmlexer.py"
    },
    {
        "api_name": "t_REAL",
        "full_api_name": "QasmLexer.t_REAL",
        "api_description": "(([0-9]+|([0-9]+)?\\.[0-9]+|[0-9]+\\.)[eE][+-]?[0-9]+)|(([0-9]+)?\\.[0-9]+|[0-9]+\\.)",
        "api_signature": "t_REAL(self, t)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmlexer.py"
    },
    {
        "api_name": "t_NNINTEGER",
        "full_api_name": "QasmLexer.t_NNINTEGER",
        "api_description": "[1-9]+[0-9]*|0",
        "api_signature": "t_NNINTEGER(self, t)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmlexer.py"
    },
    {
        "api_name": "t_ASSIGN",
        "full_api_name": "QasmLexer.t_ASSIGN",
        "api_description": "->",
        "api_signature": "t_ASSIGN(self, t)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmlexer.py"
    },
    {
        "api_name": "t_MATCHES",
        "full_api_name": "QasmLexer.t_MATCHES",
        "api_description": "==",
        "api_signature": "t_MATCHES(self, t)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmlexer.py"
    },
    {
        "api_name": "t_STRING",
        "full_api_name": "QasmLexer.t_STRING",
        "api_description": "\\\"([^\\\\\\\"]|\\\\.)*\\\"",
        "api_signature": "t_STRING(self, t)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmlexer.py"
    },
    {
        "api_name": "t_INCLUDE",
        "full_api_name": "QasmLexer.t_INCLUDE",
        "api_description": "include",
        "api_signature": "t_INCLUDE(self, _)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmlexer.py"
    },
    {
        "api_name": "t_FORMAT",
        "full_api_name": "QasmLexer.t_FORMAT",
        "api_description": "OPENQASM\\s+[0-9]+(\\.[0-9]+)?",
        "api_signature": "t_FORMAT(self, t)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmlexer.py"
    },
    {
        "api_name": "t_COMMENT",
        "full_api_name": "QasmLexer.t_COMMENT",
        "api_description": "//.*",
        "api_signature": "t_COMMENT(self, _)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmlexer.py"
    },
    {
        "api_name": "t_CX",
        "full_api_name": "QasmLexer.t_CX",
        "api_description": "CX",
        "api_signature": "t_CX(self, t)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmlexer.py"
    },
    {
        "api_name": "t_U",
        "full_api_name": "QasmLexer.t_U",
        "api_description": "U",
        "api_signature": "t_U(self, t)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmlexer.py"
    },
    {
        "api_name": "t_ID",
        "full_api_name": "QasmLexer.t_ID",
        "api_description": "[a-z][a-zA-Z0-9_]*",
        "api_signature": "t_ID(self, t)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmlexer.py"
    },
    {
        "api_name": "t_newline",
        "full_api_name": "QasmLexer.t_newline",
        "api_description": "\\n+",
        "api_signature": "t_newline(self, t)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmlexer.py"
    },
    {
        "api_name": "t_eof",
        "full_api_name": "QasmLexer.t_eof",
        "api_description": "",
        "api_signature": "t_eof(self, _)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmlexer.py"
    },
    {
        "api_name": "t_error",
        "full_api_name": "QasmLexer.t_error",
        "api_description": "",
        "api_signature": "t_error(self, t)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/qasmlexer.py"
    },
    {
        "api_name": "__getattr__",
        "full_api_name": "__getattr__",
        "api_description": "",
        "api_signature": "__getattr__(name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/__init__.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Program.__init__",
        "api_description": "Create the program node.",
        "api_signature": "__init__(self, children)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/program.py"
    },
    {
        "api_name": "qasm",
        "full_api_name": "Program.qasm",
        "api_description": "Return the corresponding OPENQASM string.",
        "api_signature": "qasm(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/program.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "IdList.__init__",
        "api_description": "Create the idlist node.",
        "api_signature": "__init__(self, children)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/idlist.py"
    },
    {
        "api_name": "size",
        "full_api_name": "IdList.size",
        "api_description": "Return the length of the list.",
        "api_signature": "size(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/idlist.py"
    },
    {
        "api_name": "qasm",
        "full_api_name": "IdList.qasm",
        "api_description": "Return the corresponding OPENQASM string.",
        "api_signature": "qasm(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/idlist.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Creg.__init__",
        "api_description": "Create the creg node.",
        "api_signature": "__init__(self, children)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/creg.py"
    },
    {
        "api_name": "to_string",
        "full_api_name": "Creg.to_string",
        "api_description": "Print the node data, with indent.",
        "api_signature": "to_string(self, indent)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/creg.py"
    },
    {
        "api_name": "qasm",
        "full_api_name": "Creg.qasm",
        "api_description": "Return the corresponding OPENQASM string.",
        "api_signature": "qasm(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/creg.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Prefix.__init__",
        "api_description": "Create the prefix node.",
        "api_signature": "__init__(self, children)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/prefix.py"
    },
    {
        "api_name": "qasm",
        "full_api_name": "Prefix.qasm",
        "api_description": "Return the corresponding OPENQASM string.",
        "api_signature": "qasm(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/prefix.py"
    },
    {
        "api_name": "latex",
        "full_api_name": "Prefix.latex",
        "api_description": "Return the corresponding math mode latex string.",
        "api_signature": "latex(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/prefix.py"
    },
    {
        "api_name": "real",
        "full_api_name": "Prefix.real",
        "api_description": "Return the correspond floating point number.",
        "api_signature": "real(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/prefix.py"
    },
    {
        "api_name": "sym",
        "full_api_name": "Prefix.sym",
        "api_description": "Return the correspond symbolic number.",
        "api_signature": "sym(self, nested_scope)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/prefix.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Format.__init__",
        "api_description": "Create the version node.",
        "api_signature": "__init__(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/format.py"
    },
    {
        "api_name": "version",
        "full_api_name": "Format.version",
        "api_description": "Return the version.",
        "api_signature": "version(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/format.py"
    },
    {
        "api_name": "qasm",
        "full_api_name": "Format.qasm",
        "api_description": "Return the corresponding format string.",
        "api_signature": "qasm(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/format.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Barrier.__init__",
        "api_description": "Create the barrier node.",
        "api_signature": "__init__(self, children)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/barrier.py"
    },
    {
        "api_name": "qasm",
        "full_api_name": "Barrier.qasm",
        "api_description": "Return the corresponding OPENQASM string.",
        "api_signature": "qasm(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/barrier.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "NodeException.__init__",
        "api_description": "Set the error message.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/nodeexception.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "NodeException.__str__",
        "api_description": "Return the message.",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/nodeexception.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CustomUnitary.__init__",
        "api_description": "Create the custom gate node.",
        "api_signature": "__init__(self, children)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/customunitary.py"
    },
    {
        "api_name": "qasm",
        "full_api_name": "CustomUnitary.qasm",
        "api_description": "Return the corresponding OPENQASM string.",
        "api_signature": "qasm(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/customunitary.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Reset.__init__",
        "api_description": "Create the reset node.",
        "api_signature": "__init__(self, children)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/reset.py"
    },
    {
        "api_name": "qasm",
        "full_api_name": "Reset.qasm",
        "api_description": "Return the corresponding OPENQASM string.",
        "api_signature": "qasm(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/reset.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PrimaryList.__init__",
        "api_description": "Create the primarylist node.",
        "api_signature": "__init__(self, children)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/primarylist.py"
    },
    {
        "api_name": "size",
        "full_api_name": "PrimaryList.size",
        "api_description": "Return the size of the list.",
        "api_signature": "size(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/primarylist.py"
    },
    {
        "api_name": "qasm",
        "full_api_name": "PrimaryList.qasm",
        "api_description": "Return the corresponding OPENQASM string.",
        "api_signature": "qasm(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/primarylist.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Qreg.__init__",
        "api_description": "Create the qreg node.",
        "api_signature": "__init__(self, children)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/qreg.py"
    },
    {
        "api_name": "to_string",
        "full_api_name": "Qreg.to_string",
        "api_description": "Print the node data, with indent.",
        "api_signature": "to_string(self, indent)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/qreg.py"
    },
    {
        "api_name": "qasm",
        "full_api_name": "Qreg.qasm",
        "api_description": "Return the corresponding OPENQASM string.",
        "api_signature": "qasm(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/qreg.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Real.__init__",
        "api_description": "Create the real node.",
        "api_signature": "__init__(self, id)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/real.py"
    },
    {
        "api_name": "to_string",
        "full_api_name": "Real.to_string",
        "api_description": "Print with indent.",
        "api_signature": "to_string(self, indent)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/real.py"
    },
    {
        "api_name": "qasm",
        "full_api_name": "Real.qasm",
        "api_description": "Return the corresponding OPENQASM string.",
        "api_signature": "qasm(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/real.py"
    },
    {
        "api_name": "latex",
        "full_api_name": "Real.latex",
        "api_description": "Return the corresponding math mode latex string.",
        "api_signature": "latex(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/real.py"
    },
    {
        "api_name": "sym",
        "full_api_name": "Real.sym",
        "api_description": "Return the correspond symbolic number.",
        "api_signature": "sym(self, nested_scope)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/real.py"
    },
    {
        "api_name": "real",
        "full_api_name": "Real.real",
        "api_description": "Return the correspond floating point number.",
        "api_signature": "real(self, nested_scope)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/real.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "UniversalUnitary.__init__",
        "api_description": "Create the U node.",
        "api_signature": "__init__(self, children)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/universalunitary.py"
    },
    {
        "api_name": "qasm",
        "full_api_name": "UniversalUnitary.qasm",
        "api_description": "Return the corresponding OPENQASM string.",
        "api_signature": "qasm(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/universalunitary.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "UnaryOperator.__init__",
        "api_description": "Create the operator node.",
        "api_signature": "__init__(self, operation)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/unaryoperator.py"
    },
    {
        "api_name": "operation",
        "full_api_name": "UnaryOperator.operation",
        "api_description": "Return the operator as a function f(left, right).",
        "api_signature": "operation(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/unaryoperator.py"
    },
    {
        "api_name": "qasm",
        "full_api_name": "UnaryOperator.qasm",
        "api_description": "Return OpenQASM 2 representation.",
        "api_signature": "qasm(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/unaryoperator.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "GateBody.__init__",
        "api_description": "Create the gatebody node.",
        "api_signature": "__init__(self, children)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/gatebody.py"
    },
    {
        "api_name": "qasm",
        "full_api_name": "GateBody.qasm",
        "api_description": "Return the corresponding OPENQASM string.",
        "api_signature": "qasm(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/gatebody.py"
    },
    {
        "api_name": "calls",
        "full_api_name": "GateBody.calls",
        "api_description": "Return a list of custom gate names in this gate body.",
        "api_signature": "calls(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/gatebody.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "External.__init__",
        "api_description": "Create the external node.",
        "api_signature": "__init__(self, children)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/external.py"
    },
    {
        "api_name": "qasm",
        "full_api_name": "External.qasm",
        "api_description": "Return the corresponding OPENQASM string.",
        "api_signature": "qasm(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/external.py"
    },
    {
        "api_name": "latex",
        "full_api_name": "External.latex",
        "api_description": "Return the corresponding math mode latex string.",
        "api_signature": "latex(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/external.py"
    },
    {
        "api_name": "real",
        "full_api_name": "External.real",
        "api_description": "Return the correspond floating point number.",
        "api_signature": "real(self, nested_scope)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/external.py"
    },
    {
        "api_name": "sym",
        "full_api_name": "External.sym",
        "api_description": "Return the corresponding symbolic expression.",
        "api_signature": "sym(self, nested_scope)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/external.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "IndexedId.__init__",
        "api_description": "Create the indexed id node.",
        "api_signature": "__init__(self, children)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/indexedid.py"
    },
    {
        "api_name": "to_string",
        "full_api_name": "IndexedId.to_string",
        "api_description": "Print with indent.",
        "api_signature": "to_string(self, indent)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/indexedid.py"
    },
    {
        "api_name": "qasm",
        "full_api_name": "IndexedId.qasm",
        "api_description": "Return the corresponding OPENQASM string.",
        "api_signature": "qasm(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/indexedid.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "If.__init__",
        "api_description": "Create the if node.",
        "api_signature": "__init__(self, children)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/if_.py"
    },
    {
        "api_name": "qasm",
        "full_api_name": "If.qasm",
        "api_description": "Return the corresponding OPENQASM string.",
        "api_signature": "qasm(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/if_.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BinaryOp.__init__",
        "api_description": "Create the binaryop node.",
        "api_signature": "__init__(self, children)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/binaryop.py"
    },
    {
        "api_name": "qasm",
        "full_api_name": "BinaryOp.qasm",
        "api_description": "Return the corresponding OPENQASM string.",
        "api_signature": "qasm(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/binaryop.py"
    },
    {
        "api_name": "latex",
        "full_api_name": "BinaryOp.latex",
        "api_description": "Return the corresponding math mode latex string.",
        "api_signature": "latex(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/binaryop.py"
    },
    {
        "api_name": "real",
        "full_api_name": "BinaryOp.real",
        "api_description": "Return the correspond floating point number.",
        "api_signature": "real(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/binaryop.py"
    },
    {
        "api_name": "sym",
        "full_api_name": "BinaryOp.sym",
        "api_description": "Return the correspond symbolic number.",
        "api_signature": "sym(self, nested_scope)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/binaryop.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Gate.__init__",
        "api_description": "Create the gate node.",
        "api_signature": "__init__(self, children)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/gate.py"
    },
    {
        "api_name": "n_args",
        "full_api_name": "Gate.n_args",
        "api_description": "Return the number of parameter expressions.",
        "api_signature": "n_args(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/gate.py"
    },
    {
        "api_name": "n_bits",
        "full_api_name": "Gate.n_bits",
        "api_description": "Return the number of qubit arguments.",
        "api_signature": "n_bits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/gate.py"
    },
    {
        "api_name": "qasm",
        "full_api_name": "Gate.qasm",
        "api_description": "Return the corresponding OPENQASM string.",
        "api_signature": "qasm(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/gate.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ExpressionList.__init__",
        "api_description": "Create the expression list node.",
        "api_signature": "__init__(self, children)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/expressionlist.py"
    },
    {
        "api_name": "size",
        "full_api_name": "ExpressionList.size",
        "api_description": "Return the number of expressions.",
        "api_signature": "size(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/expressionlist.py"
    },
    {
        "api_name": "qasm",
        "full_api_name": "ExpressionList.qasm",
        "api_description": "Return the corresponding OPENQASM string.",
        "api_signature": "qasm(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/expressionlist.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Node.__init__",
        "api_description": "Construct a new node object.",
        "api_signature": "__init__(self, type, children, root)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/node.py"
    },
    {
        "api_name": "is_expression",
        "full_api_name": "Node.is_expression",
        "api_description": "Return True if this is an expression node.",
        "api_signature": "is_expression(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/node.py"
    },
    {
        "api_name": "add_child",
        "full_api_name": "Node.add_child",
        "api_description": "Add a child node.",
        "api_signature": "add_child(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/node.py"
    },
    {
        "api_name": "to_string",
        "full_api_name": "Node.to_string",
        "api_description": "Print with indent.",
        "api_signature": "to_string(self, indent)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/node.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Measure.__init__",
        "api_description": "Create the measure node.",
        "api_signature": "__init__(self, children)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/measure.py"
    },
    {
        "api_name": "qasm",
        "full_api_name": "Measure.qasm",
        "api_description": "Return the corresponding OPENQASM string.",
        "api_signature": "qasm(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/measure.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Int.__init__",
        "api_description": "Create the integer node.",
        "api_signature": "__init__(self, id)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/intnode.py"
    },
    {
        "api_name": "to_string",
        "full_api_name": "Int.to_string",
        "api_description": "Print with indent.",
        "api_signature": "to_string(self, indent)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/intnode.py"
    },
    {
        "api_name": "qasm",
        "full_api_name": "Int.qasm",
        "api_description": "Return the corresponding OPENQASM string.",
        "api_signature": "qasm(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/intnode.py"
    },
    {
        "api_name": "latex",
        "full_api_name": "Int.latex",
        "api_description": "Return the corresponding math mode latex string.",
        "api_signature": "latex(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/intnode.py"
    },
    {
        "api_name": "sym",
        "full_api_name": "Int.sym",
        "api_description": "Return the correspond symbolic number.",
        "api_signature": "sym(self, nested_scope)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/intnode.py"
    },
    {
        "api_name": "real",
        "full_api_name": "Int.real",
        "api_description": "Return the correspond floating point number.",
        "api_signature": "real(self, nested_scope)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/intnode.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Opaque.__init__",
        "api_description": "Create the opaque gate node.",
        "api_signature": "__init__(self, children)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/opaque.py"
    },
    {
        "api_name": "n_args",
        "full_api_name": "Opaque.n_args",
        "api_description": "Return the number of parameter expressions.",
        "api_signature": "n_args(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/opaque.py"
    },
    {
        "api_name": "n_bits",
        "full_api_name": "Opaque.n_bits",
        "api_description": "Return the number of qubit arguments.",
        "api_signature": "n_bits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/opaque.py"
    },
    {
        "api_name": "qasm",
        "full_api_name": "Opaque.qasm",
        "api_description": "Return the corresponding OPENQASM string.",
        "api_signature": "qasm(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/opaque.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BinaryOperator.__init__",
        "api_description": "Create the operator node.",
        "api_signature": "__init__(self, operation)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/binaryoperator.py"
    },
    {
        "api_name": "operation",
        "full_api_name": "BinaryOperator.operation",
        "api_description": "Return the operator as a function f(left, right).",
        "api_signature": "operation(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/binaryoperator.py"
    },
    {
        "api_name": "qasm",
        "full_api_name": "BinaryOperator.qasm",
        "api_description": "Return the OpenQASM 2 representation.",
        "api_signature": "qasm(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/binaryoperator.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Id.__init__",
        "api_description": "Create the id node.",
        "api_signature": "__init__(self, id, line, file)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/id.py"
    },
    {
        "api_name": "to_string",
        "full_api_name": "Id.to_string",
        "api_description": "Print the node with indent.",
        "api_signature": "to_string(self, indent)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/id.py"
    },
    {
        "api_name": "qasm",
        "full_api_name": "Id.qasm",
        "api_description": "Return the corresponding OPENQASM string.",
        "api_signature": "qasm(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/id.py"
    },
    {
        "api_name": "latex",
        "full_api_name": "Id.latex",
        "api_description": "Return the correspond math mode latex string.",
        "api_signature": "latex(self, nested_scope)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/id.py"
    },
    {
        "api_name": "sym",
        "full_api_name": "Id.sym",
        "api_description": "Return the correspond symbolic number.",
        "api_signature": "sym(self, nested_scope)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/id.py"
    },
    {
        "api_name": "real",
        "full_api_name": "Id.real",
        "api_description": "Return the correspond floating point number.",
        "api_signature": "real(self, nested_scope)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/id.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Cnot.__init__",
        "api_description": "Create the cnot node.",
        "api_signature": "__init__(self, children)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/cnot.py"
    },
    {
        "api_name": "qasm",
        "full_api_name": "Cnot.qasm",
        "api_description": "Return the corresponding OPENQASM string.",
        "api_signature": "qasm(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm/node/cnot.py"
    },
    {
        "api_name": "transpile",
        "full_api_name": "transpile",
        "api_description": "Transpile one or more circuits, according to some desired transpilation targets.\n\nTranspilation is potentially done in parallel using multiprocessing when ``circuits``\nis a list with > 1 :class:`~.QuantumCircuit` object depending on the local environment\nand configuration.\n\nArgs:\n    circuits: Circuit(s) to transpile\n    backend: If set, the transpiler will compile the input circuit to this target\n        device. If any other option is explicitly set (e.g., ``coupling_map``), it\n        will override the backend's.\n    basis_gates: List of basis gate names to unroll to\n        (e.g: ``['u1', 'u2', 'u3', 'cx']``). If ``None``, do not unroll.\n    inst_map: Mapping of unrolled gates to pulse schedules. If this is not provided,\n        transpiler tries to get from the backend. If any user defined calibration\n        is found in the map and this is used in a circuit, transpiler attaches\n        the custom gate definition to the circuit. This enables one to flexibly\n        override the low-level instruction implementation. This feature is available\n        iff the backend supports the pulse gate experiment.\n    coupling_map: Directed coupling map (perhaps custom) to target in mapping. If\n        the coupling map is symmetric, both directions need to be specified.\n\n        Multiple formats are supported:\n\n        #. ``CouplingMap`` instance\n        #. List, must be given as an adjacency matrix, where each entry\n           specifies all directed two-qubit interactions supported by backend,\n           e.g: ``[[0, 1], [0, 3], [1, 2], [1, 5], [2, 5], [4, 1], [5, 3]]``\n\n    backend_properties: properties returned by a backend, including information on gate\n        errors, readout errors, qubit coherence times, etc. Find a backend\n        that provides this information with: ``backend.properties()``\n    initial_layout: Initial position of virtual qubits on physical qubits.\n        If this layout makes the circuit compatible with the coupling_map\n        constraints, it will be used. The final layout is not guaranteed to be the same,\n        as the transpiler may permute qubits through swaps or other means.\n        Multiple formats are supported:\n\n        #. ``Layout`` instance\n        #. Dict\n           * virtual to physical::\n\n                {qr[0]: 0,\n                 qr[1]: 3,\n                 qr[2]: 5}\n\n           * physical to virtual::\n\n                {0: qr[0],\n                 3: qr[1],\n                 5: qr[2]}\n\n        #. List\n\n           * virtual to physical::\n\n                [0, 3, 5]  # virtual qubits are ordered (in addition to named)\n\n           * physical to virtual::\n\n                [qr[0], None, None, qr[1], None, qr[2]]\n\n    layout_method: Name of layout selection pass ('trivial', 'dense', 'noise_adaptive', 'sabre').\n        This can also be the external plugin name to use for the ``layout`` stage.\n        You can see a list of installed plugins by using :func:`~.list_stage_plugins` with\n        ``\"layout\"`` for the ``stage_name`` argument.\n    routing_method: Name of routing pass\n        ('basic', 'lookahead', 'stochastic', 'sabre', 'none'). Note\n        This can also be the external plugin name to use for the ``routing`` stage.\n        You can see a list of installed plugins by using :func:`~.list_stage_plugins` with\n        ``\"routing\"`` for the ``stage_name`` argument.\n    translation_method: Name of translation pass ('unroller', 'translator', 'synthesis')\n        This can also be the external plugin name to use for the ``translation`` stage.\n        You can see a list of installed plugins by using :func:`~.list_stage_plugins` with\n        ``\"translation\"`` for the ``stage_name`` argument.\n    scheduling_method: Name of scheduling pass.\n        * ``'as_soon_as_possible'``: Schedule instructions greedily, as early as possible\n        on a qubit resource. (alias: ``'asap'``)\n        * ``'as_late_as_possible'``: Schedule instructions late, i.e. keeping qubits\n        in the ground state when possible. (alias: ``'alap'``)\n        If ``None``, no scheduling will be done. This can also be the external plugin name\n        to use for the ``scheduling`` stage. You can see a list of installed plugins by\n        using :func:`~.list_stage_plugins` with ``\"scheduling\"`` for the ``stage_name``\n        argument.\n    instruction_durations: Durations of instructions.\n        Applicable only if scheduling_method is specified.\n        The gate lengths defined in ``backend.properties`` are used as default.\n        They are overwritten if this ``instruction_durations`` is specified.\n        The format of ``instruction_durations`` must be as follows.\n        The `instruction_durations` must be given as a list of tuples\n        [(instruction_name, qubits, duration, unit), ...].\n        | [('cx', [0, 1], 12.3, 'ns'), ('u3', [0], 4.56, 'ns')]\n        | [('cx', [0, 1], 1000), ('u3', [0], 300)]\n        If unit is omitted, the default is 'dt', which is a sample time depending on backend.\n        If the time unit is 'dt', the duration must be an integer.\n    dt: Backend sample time (resolution) in seconds.\n        If ``None`` (default), ``backend.configuration().dt`` is used.\n    approximation_degree (float): heuristic dial used for circuit approximation\n        (1.0=no approximation, 0.0=maximal approximation)\n    timing_constraints: An optional control hardware restriction on instruction time resolution.\n        A quantum computer backend may report a set of restrictions, namely:\n\n        - granularity: An integer value representing minimum pulse gate\n          resolution in units of ``dt``. A user-defined pulse gate should have\n          duration of a multiple of this granularity value.\n        - min_length: An integer value representing minimum pulse gate\n          length in units of ``dt``. A user-defined pulse gate should be longer\n          than this length.\n        - pulse_alignment: An integer value representing a time resolution of gate\n          instruction starting time. Gate instruction should start at time which\n          is a multiple of the alignment value.\n        - acquire_alignment: An integer value representing a time resolution of measure\n          instruction starting time. Measure instruction should start at time which\n          is a multiple of the alignment value.\n\n        This information will be provided by the backend configuration.\n        If the backend doesn't have any restriction on the instruction time allocation,\n        then ``timing_constraints`` is None and no adjustment will be performed.\n    seed_transpiler: Sets random seed for the stochastic parts of the transpiler\n    optimization_level: How much optimization to perform on the circuits.\n        Higher levels generate more optimized circuits,\n        at the expense of longer transpilation time.\n\n        * 0: no optimization\n        * 1: light optimization\n        * 2: heavy optimization\n        * 3: even heavier optimization\n\n        If ``None``, level 1 will be chosen as default.\n    callback: A callback function that will be called after each\n        pass execution. The function will be called with 5 keyword\n        arguments,\n        | ``pass_``: the pass being run.\n        | ``dag``: the dag output of the pass.\n        | ``time``: the time to execute the pass.\n        | ``property_set``: the property set.\n        | ``count``: the index for the pass execution.\n        The exact arguments passed expose the internals of the pass manager,\n        and are subject to change as the pass manager internals change. If\n        you intend to reuse a callback function over multiple releases, be\n        sure to check that the arguments being passed are the same.\n        To use the callback feature, define a function that will\n        take in kwargs dict and access the variables. For example::\n\n            def callback_func(**kwargs):\n                pass_ = kwargs['pass_']\n                dag = kwargs['dag']\n                time = kwargs['time']\n                property_set = kwargs['property_set']\n                count = kwargs['count']\n                ...\n            transpile(circ, callback=callback_func)\n\n    output_name: A list with strings to identify the output circuits. The length of\n        the list should be exactly the length of the ``circuits`` parameter.\n    unitary_synthesis_method (str): The name of the unitary synthesis\n        method to use. By default ``'default'`` is used. You can see a list of installed\n        plugins with :func:`.unitary_synthesis_plugin_names`.\n    unitary_synthesis_plugin_config: An optional configuration dictionary\n        that will be passed directly to the unitary synthesis plugin. By\n        default this setting will have no effect as the default unitary\n        synthesis method does not take custom configuration. This should\n        only be necessary when a unitary synthesis plugin is specified with\n        the ``unitary_synthesis`` argument. As this is custom for each\n        unitary synthesis plugin refer to the plugin documentation for how\n        to use this option.\n    target: A backend transpiler target. Normally this is specified as part of\n        the ``backend`` argument, but if you have manually constructed a\n        :class:`~qiskit.transpiler.Target` object you can specify it manually here.\n        This will override the target from ``backend``.\n    hls_config: An optional configuration class\n        :class:`~qiskit.transpiler.passes.synthesis.HLSConfig` that will be passed directly\n        to :class:`~qiskit.transpiler.passes.synthesis.HighLevelSynthesis` transformation pass.\n        This configuration class allows to specify for various high-level objects the lists of\n        synthesis algorithms and their parameters.\n    init_method: The plugin name to use for the ``init`` stage. By default an external\n        plugin is not used. You can see a list of installed plugins by\n        using :func:`~.list_stage_plugins` with ``\"init\"`` for the stage\n        name argument.\n    optimization_method: The plugin name to use for the\n        ``optimization`` stage. By default an external\n        plugin is not used. You can see a list of installed plugins by\n        using :func:`~.list_stage_plugins` with ``\"optimization\"`` for the\n        ``stage_name`` argument.\n    ignore_backend_supplied_default_methods: If set to ``True`` any default methods specified by\n        a backend will be ignored. Some backends specify alternative default methods\n        to support custom compilation target-specific passes/plugins which support\n        backend-specific compilation techniques. If you'd prefer that these defaults were\n        not used this option is used to disable those backend-specific defaults.\n\nReturns:\n    The transpiled circuit(s).\n\nRaises:\n    TranspilerError: in case of bad inputs to transpiler (like conflicting parameters)\n        or errors in passes",
        "api_signature": "transpile(circuits, backend, basis_gates, inst_map, coupling_map, backend_properties, initial_layout, layout_method, routing_method, translation_method, scheduling_method, instruction_durations, dt, approximation_degree, timing_constraints, seed_transpiler, optimization_level, callback, output_name, unitary_synthesis_method, unitary_synthesis_plugin_config, target, hls_config, init_method, optimization_method, ignore_backend_supplied_default_methods)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/compiler/transpiler.py"
    },
    {
        "api_name": "_check_circuits_coupling_map",
        "full_api_name": "_check_circuits_coupling_map",
        "api_description": "",
        "api_signature": "_check_circuits_coupling_map(circuits, cmap, backend)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/compiler/transpiler.py"
    },
    {
        "api_name": "_log_transpile_time",
        "full_api_name": "_log_transpile_time",
        "api_description": "",
        "api_signature": "_log_transpile_time(start_time, end_time)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/compiler/transpiler.py"
    },
    {
        "api_name": "_parse_inst_map",
        "full_api_name": "_parse_inst_map",
        "api_description": "",
        "api_signature": "_parse_inst_map(inst_map, backend)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/compiler/transpiler.py"
    },
    {
        "api_name": "_parse_coupling_map",
        "full_api_name": "_parse_coupling_map",
        "api_description": "",
        "api_signature": "_parse_coupling_map(coupling_map, backend)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/compiler/transpiler.py"
    },
    {
        "api_name": "_parse_initial_layout",
        "full_api_name": "_parse_initial_layout",
        "api_description": "",
        "api_signature": "_parse_initial_layout(initial_layout)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/compiler/transpiler.py"
    },
    {
        "api_name": "_parse_instruction_durations",
        "full_api_name": "_parse_instruction_durations",
        "api_description": "Create a list of ``InstructionDuration``s. If ``inst_durations`` is provided,\nthe backend will be ignored, otherwise, the durations will be populated from the\nbackend. If any circuits have gate calibrations, those calibration durations would\ntake precedence over backend durations, but be superceded by ``inst_duration``s.",
        "api_signature": "_parse_instruction_durations(backend, inst_durations, dt, circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/compiler/transpiler.py"
    },
    {
        "api_name": "_parse_approximation_degree",
        "full_api_name": "_parse_approximation_degree",
        "api_description": "",
        "api_signature": "_parse_approximation_degree(approximation_degree)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/compiler/transpiler.py"
    },
    {
        "api_name": "_parse_output_name",
        "full_api_name": "_parse_output_name",
        "api_description": "",
        "api_signature": "_parse_output_name(output_name, circuits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/compiler/transpiler.py"
    },
    {
        "api_name": "_parse_timing_constraints",
        "full_api_name": "_parse_timing_constraints",
        "api_description": "",
        "api_signature": "_parse_timing_constraints(backend, timing_constraints)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/compiler/transpiler.py"
    },
    {
        "api_name": "_log_schedule_time",
        "full_api_name": "_log_schedule_time",
        "api_description": "",
        "api_signature": "_log_schedule_time(start_time, end_time)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/compiler/scheduler.py"
    },
    {
        "api_name": "schedule",
        "full_api_name": "schedule",
        "api_description": "Schedule a circuit to a pulse ``Schedule``, using the backend, according to any specified\nmethods. Supported methods are documented in :py:mod:`qiskit.scheduler.schedule_circuit`.\n\nArgs:\n    circuits: The quantum circuit or circuits to translate\n    backend: A backend instance, which contains hardware-specific data required for scheduling\n    inst_map: Mapping of circuit operations to pulse schedules. If ``None``, defaults to the\n              ``backend``'s ``instruction_schedule_map``\n    meas_map: List of sets of qubits that must be measured together. If ``None``, defaults to\n              the ``backend``'s ``meas_map``\n    dt: The output sample rate of backend control electronics. For scheduled circuits\n        which contain time information, dt is required. If not provided, it will be\n        obtained from the backend configuration\n    method: Optionally specify a particular scheduling method\n\nReturns:\n    A pulse ``Schedule`` that implements the input circuit\n\nRaises:\n    QiskitError: If ``inst_map`` and ``meas_map`` are not passed and ``backend`` is not passed",
        "api_signature": "schedule(circuits, backend, inst_map, meas_map, dt, method)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/compiler/scheduler.py"
    },
    {
        "api_name": "_log_assembly_time",
        "full_api_name": "_log_assembly_time",
        "api_description": "",
        "api_signature": "_log_assembly_time(start_time, end_time)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/compiler/assembler.py"
    },
    {
        "api_name": "assemble",
        "full_api_name": "assemble",
        "api_description": "Assemble a list of circuits or pulse schedules into a ``Qobj``.\n\nThis function serializes the payloads, which could be either circuits or schedules,\nto create ``Qobj`` \"experiments\". It further annotates the experiment payload with\nheader and configurations.\n\nNOTE: Backend.options is not used within assemble. The required values\n(previously given by backend.set_options) should be manually extracted\nfrom options and supplied directly when calling.\n\nArgs:\n    experiments: Circuit(s) or pulse schedule(s) to execute\n    backend: If set, some runtime options are automatically grabbed from\n        ``backend.configuration()`` and ``backend.defaults()``.\n        If any other option is explicitly set (e.g., ``rep_time``), it\n        will override the backend's.\n        If any other options is set in the run_config, it will\n        also override the backend's.\n    qobj_id: String identifier to annotate the ``Qobj``\n    qobj_header: User input that will be inserted in ``Qobj`` header, and will also be\n        copied to the corresponding Result header. Headers do not affect the run.\n    shots: Number of repetitions of each circuit, for sampling. Default: 1024\n        or ``max_shots`` from the backend configuration, whichever is smaller\n    memory: If ``True``, per-shot measurement bitstrings are returned as well\n        (provided the backend supports it). For OpenPulse jobs, only\n        measurement level 2 supports this option.\n    seed_simulator: Random seed to control sampling, for when backend is a simulator\n    qubit_lo_freq: List of job level qubit drive LO frequencies in Hz. Overridden by\n        ``schedule_los`` if specified. Must have length ``n_qubits.``\n    meas_lo_freq: List of measurement LO frequencies in Hz. Overridden by ``schedule_los`` if\n        specified. Must have length ``n_qubits.``\n    qubit_lo_range: List of job level drive LO ranges each of form ``[range_min, range_max]``\n        in Hz. Used to validate ``qubit_lo_freq``. Must have length ``n_qubits.``\n    meas_lo_range: List of job level measurement LO ranges each of form\n        ``[range_min, range_max]`` in Hz. Used to validate ``meas_lo_freq``. Must have length\n        ``n_qubits.``\n    schedule_los: Experiment level (ie circuit or schedule) LO frequency configurations for\n        qubit drive and measurement channels. These values override the job level values from\n        ``default_qubit_los`` and ``default_meas_los``. Frequencies are in Hz. Settable for\n        OpenQASM 2 and pulse jobs.\n    meas_level: Set the appropriate level of the measurement output for pulse experiments.\n    meas_return: Level of measurement data for the backend to return.\n\n        For ``meas_level`` 0 and 1:\n            * ``single`` returns information from every shot.\n            * ``avg`` returns average measurement output (averaged over number of shots).\n    meas_map: List of lists, containing qubits that must be measured together.\n    memory_slot_size: Size of each memory slot if the output is Level 0.\n    rep_time (int): Time per program execution in seconds. Must be from the list provided\n        by the backend (``backend.configuration().rep_times``). Defaults to the first entry.\n    rep_delay (float): Delay between programs in seconds. Only supported on certain\n        backends (if ``backend.configuration().dynamic_reprate_enabled=True``). If supported,\n        ``rep_delay`` will be used instead of ``rep_time`` and must be from the range supplied\n        by the backend (``backend.configuration().rep_delay_range``). Default is given by\n        ``backend.configuration().default_rep_delay``.\n    parameter_binds: List of Parameter bindings over which the set of experiments will be\n        executed. Each list element (bind) should be of the form\n        {Parameter1: value1, Parameter2: value2, ...}. All binds will be\n        executed across all experiments; e.g., if parameter_binds is a\n        length-n list, and there are m experiments, a total of m x n\n        experiments will be run (one for each experiment/bind pair).\n    parametric_pulses: A list of pulse shapes which are supported internally on the backend.\n        Example::\n\n        ['gaussian', 'constant']\n    init_qubits: Whether to reset the qubits to the ground state for each shot.\n                 Default: ``True``.\n    **run_config: Extra arguments used to configure the run (e.g., for Aer configurable\n        backends). Refer to the backend documentation for details on these\n        arguments.\n\nReturns:\n        A ``Qobj`` that can be run on a backend. Depending on the type of input,\n        this will be either a ``QasmQobj`` or a ``PulseQobj``.\n\nRaises:\n    QiskitError: if the input cannot be interpreted as either circuits or schedules",
        "api_signature": "assemble(experiments, backend, qobj_id, qobj_header, shots, memory, seed_simulator, qubit_lo_freq, meas_lo_freq, qubit_lo_range, meas_lo_range, schedule_los, meas_level, meas_return, meas_map, memory_slot_size, rep_time, rep_delay, parameter_binds, parametric_pulses, init_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/compiler/assembler.py"
    },
    {
        "api_name": "_parse_common_args",
        "full_api_name": "_parse_common_args",
        "api_description": "Resolve the various types of args allowed to the assemble() function through\nduck typing, overriding args, etc. Refer to the assemble() docstring for details on\nwhat types of inputs are allowed.\n\nHere the args are resolved by converting them to standard instances, and prioritizing\nthem in case a run option is passed through multiple args (explicitly setting an arg\nhas more priority than the arg set by backend)\n\nReturns:\n    RunConfig: a run config, which is a standardized object that configures the qobj\n        and determines the runtime environment.\n\nRaises:\n    QiskitError:\n        - If the memory arg is True and the backend does not support memory.\n        - If ``shots`` exceeds ``max_shots`` for the configured backend.\n        - If ``shots`` are not int type.\n        - If any of qubit or meas lo's, or associated ranges do not have length equal to\n        ``n_qubits``.\n        - If qubit or meas lo's do not fit into prescribed ranges.",
        "api_signature": "_parse_common_args(backend, qobj_id, qobj_header, shots, memory, seed_simulator, init_qubits, rep_delay, qubit_lo_freq, meas_lo_freq, qubit_lo_range, meas_lo_range, schedule_los, pulse_qobj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/compiler/assembler.py"
    },
    {
        "api_name": "_check_lo_freqs",
        "full_api_name": "_check_lo_freqs",
        "api_description": "Check that LO frequencies are within the perscribed LO range.\n\nNOTE: Only checks if frequency/range lists have equal length. And does not check that the lists\nhave length ``n_qubits``. This is because some backends, like simulator backends, do not\nrequire these constraints. For real hardware, these parameters will be validated on the backend.\n\nArgs:\n    lo_freq: List of LO frequencies.\n    lo_range: Nested list of LO frequency ranges. Inner list is of the form\n        ``[lo_min, lo_max]``.\n    lo_type: The type of LO value--\"qubit\" or \"meas\".\n\nRaises:\n    QiskitError:\n        - If each element of the LO range is not a 2d list.\n        - If the LO frequency is not in the LO range for a given qubit.",
        "api_signature": "_check_lo_freqs(lo_freq, lo_range, lo_type)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/compiler/assembler.py"
    },
    {
        "api_name": "_parse_pulse_args",
        "full_api_name": "_parse_pulse_args",
        "api_description": "Build a pulse RunConfig replacing unset arguments with defaults derived from the `backend`.\nSee `assemble` for more information on the required arguments.\n\nReturns:\n    RunConfig: a run config, which is a standardized object that configures the qobj\n        and determines the runtime environment.\nRaises:\n    QiskitError: If the given meas_level is not allowed for the given `backend`.",
        "api_signature": "_parse_pulse_args(backend, meas_level, meas_return, meas_map, memory_slot_size, rep_time, parametric_pulses)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/compiler/assembler.py"
    },
    {
        "api_name": "_parse_circuit_args",
        "full_api_name": "_parse_circuit_args",
        "api_description": "Build a circuit RunConfig replacing unset arguments with defaults derived from the `backend`.\nSee `assemble` for more information on the required arguments.\n\nReturns:\n    RunConfig: a run config, which is a standardized object that configures the qobj\n        and determines the runtime environment.",
        "api_signature": "_parse_circuit_args(parameter_binds, backend, meas_level, meas_return, parametric_pulses)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/compiler/assembler.py"
    },
    {
        "api_name": "_parse_rep_delay",
        "full_api_name": "_parse_rep_delay",
        "api_description": "Parse and set ``rep_delay`` parameter in runtime config.\n\nArgs:\n    rep_delay: Initial rep delay.\n    default_rep_delay: Backend default rep delay.\n    rep_delay_range: Backend list defining allowable range of rep delays.\n\nRaises:\n    QiskitError: If rep_delay is not in the backend rep_delay_range.\nReturns:\n    float: Modified rep delay after parsing.",
        "api_signature": "_parse_rep_delay(rep_delay, default_rep_delay, rep_delay_range)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/compiler/assembler.py"
    },
    {
        "api_name": "_expand_parameters",
        "full_api_name": "_expand_parameters",
        "api_description": "Verifies that there is a single common set of parameters shared between\nall circuits and all parameter binds in the run_config. Returns an expanded\nlist of circuits (if parameterized) with all parameters bound, and a copy of\nthe run_config with parameter_binds cleared.\n\nIf neither the circuits nor the run_config specify parameters, the two are\nreturned unmodified.\n\nRaises:\n    QiskitError: if run_config parameters are not compatible with circuit parameters\n\nReturns:\n    Tuple(List[QuantumCircuit], RunConfig):\n      - List of input circuits expanded and with parameters bound\n      - RunConfig with parameter_binds removed",
        "api_signature": "_expand_parameters(circuits, run_config)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/compiler/assembler.py"
    },
    {
        "api_name": "sequence",
        "full_api_name": "sequence",
        "api_description": "Schedule a scheduled circuit to a pulse ``Schedule``, using the backend.\n\nArgs:\n    scheduled_circuits: Scheduled circuit(s) to be translated\n    backend: A backend instance, which contains hardware-specific data required for scheduling\n    inst_map: Mapping of circuit operations to pulse schedules. If ``None``, defaults to the\n              ``backend``'s ``instruction_schedule_map``\n    meas_map: List of sets of qubits that must be measured together. If ``None``, defaults to\n              the ``backend``'s ``meas_map``\n    dt: The output sample rate of backend control electronics. For scheduled circuits\n        which contain time information, dt is required. If not provided, it will be\n        obtained from the backend configuration\n\nReturns:\n    A pulse ``Schedule`` that implements the input circuit\n\nRaises:\n    QiskitError: If ``inst_map`` and ``meas_map`` are not passed and ``backend`` is not passed",
        "api_signature": "sequence(scheduled_circuits, backend, inst_map, meas_map, dt)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/compiler/sequencer.py"
    },
    {
        "api_name": "dump",
        "full_api_name": "dump",
        "api_description": "Dump a circuit as an OpenQASM 2 program to a file or stream.\n\nArgs:\n    circuit: the :class:`.QuantumCircuit` to be exported.\n    filename_or_stream: either a path-like object (likely a :class:`str` or\n        :class:`pathlib.Path`), or an already opened text-mode stream.\n\nRaises:\n    QASM2ExportError: if the circuit cannot be represented by OpenQASM 2.",
        "api_signature": "dump()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm2/export.py"
    },
    {
        "api_name": "dumps",
        "full_api_name": "dumps",
        "api_description": "Export a circuit to an OpenQASM 2 program in a string.\n\nArgs:\n    circuit: the :class:`.QuantumCircuit` to be exported.\n\nReturns:\n    An OpenQASM 2 string representing the circuit.\n\nRaises:\n    QASM2ExportError: if the circuit cannot be represented by OpenQASM 2.",
        "api_signature": "dumps()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm2/export.py"
    },
    {
        "api_name": "_escape_name",
        "full_api_name": "_escape_name",
        "api_description": "Returns a valid OpenQASM 2.0 identifier, using `prefix` as a prefix if necessary.  `prefix`\nmust itself be a valid identifier.",
        "api_signature": "_escape_name(name, prefix)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm2/export.py"
    },
    {
        "api_name": "_make_unique",
        "full_api_name": "_make_unique",
        "api_description": "Generate a name by suffixing the given stem that is unique within the defined set.",
        "api_signature": "_make_unique(name, already_defined)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm2/export.py"
    },
    {
        "api_name": "_rename_operation",
        "full_api_name": "_rename_operation",
        "api_description": "Returns the operation with a new name following this pattern: {operation name}_{operation id}",
        "api_signature": "_rename_operation(operation)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm2/export.py"
    },
    {
        "api_name": "_instruction_call_site",
        "full_api_name": "_instruction_call_site",
        "api_description": "Return an OpenQASM 2 string for the instruction.",
        "api_signature": "_instruction_call_site(operation)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm2/export.py"
    },
    {
        "api_name": "_custom_operation_statement",
        "full_api_name": "_custom_operation_statement",
        "api_description": "",
        "api_signature": "_custom_operation_statement(instruction, gates_to_define, bit_labels)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm2/export.py"
    },
    {
        "api_name": "_define_custom_operation",
        "full_api_name": "_define_custom_operation",
        "api_description": "Extract a custom definition from the given operation, and append any necessary additional\nsubcomponents' definitions to the ``gates_to_define`` ordered dictionary.\n\nReturns a potentially new :class:`.Instruction`, which should be used for the\n:meth:`~.Instruction.qasm` call (it may have been renamed).",
        "api_signature": "_define_custom_operation(operation, gates_to_define)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm2/export.py"
    },
    {
        "api_name": "_generate_delay",
        "full_api_name": "_generate_delay",
        "api_description": "",
        "api_signature": "_generate_delay(time)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm2/parse.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "_U0Gate.__init__",
        "api_description": "",
        "api_signature": "__init__(self, count)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm2/parse.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "_U0Gate._define",
        "api_description": "",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm2/parse.py"
    },
    {
        "api_name": "from_bytecode",
        "full_api_name": "from_bytecode",
        "api_description": "Loop through the Rust bytecode iterator `bytecode` producing a\n:class:`~qiskit.circuit.QuantumCircuit` instance from it.  All the hard work is done in Rust\nspace where operations are faster; here, we're just about looping through the instructions as\nfast as possible, doing as little calculation as we can in Python space.  The Python-space\ncomponents are the vast majority of the runtime.\n\nThe \"bytecode\", and so also this Python function, is very tightly coupled to the output of the\nRust parser.  The bytecode itself is largely defined by Rust; from Python space, the iterator is\nover essentially a 2-tuple of `(opcode, operands)`.  The `operands` are fixed by Rust, and\nassumed to be correct by this function.\n\nThe Rust code is responsible for all validation.  If this function causes any errors to be\nraised by Qiskit (except perhaps for some symbolic manipulations of `Parameter` objects), we\nshould consider that a bug in the Rust code.",
        "api_signature": "from_bytecode(bytecode, custom_instructions)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm2/parse.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "_DefinedGate.__init__",
        "api_description": "",
        "api_signature": "__init__(self, name, num_qubits, params, gates, bytecode)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm2/parse.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "_DefinedGate._define",
        "api_description": "",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm2/parse.py"
    },
    {
        "api_name": "__getstate__",
        "full_api_name": "_DefinedGate.__getstate__",
        "api_description": "",
        "api_signature": "__getstate__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm2/parse.py"
    },
    {
        "api_name": "__setstate__",
        "full_api_name": "_DefinedGate.__setstate__",
        "api_description": "",
        "api_signature": "__setstate__(self, state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm2/parse.py"
    },
    {
        "api_name": "_gate_builder",
        "full_api_name": "_gate_builder",
        "api_description": "Create a gate-builder function of the signature `*params -> Gate` for a gate with a given\n`name`.  This produces a `_DefinedGate` class, whose `_define` method runs through the given\n`bytecode` using the current list of `known_gates` to interpret the gate indices.\n\nThe indirection here is mostly needed to correctly close over `known_gates` and `bytecode`.",
        "api_signature": "_gate_builder(name, num_qubits, known_gates, bytecode)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm2/parse.py"
    },
    {
        "api_name": "definer",
        "full_api_name": "definer",
        "api_description": "",
        "api_signature": "definer()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm2/parse.py"
    },
    {
        "api_name": "_opaque_builder",
        "full_api_name": "_opaque_builder",
        "api_description": "Create a gate-builder function of the signature `*params -> Gate` for an opaque gate with a\ngiven `name`, which takes the given numbers of qubits.",
        "api_signature": "_opaque_builder(name, num_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm2/parse.py"
    },
    {
        "api_name": "definer",
        "full_api_name": "definer",
        "api_description": "",
        "api_signature": "definer()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm2/parse.py"
    },
    {
        "api_name": "_evaluate_argument",
        "full_api_name": "_evaluate_argument",
        "api_description": "Inner recursive function to calculate the value of a mathematical expression given the\nconcrete values in the `parameters` field.",
        "api_signature": "_evaluate_argument(expr, parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm2/parse.py"
    },
    {
        "api_name": "_normalize_path",
        "full_api_name": "_normalize_path",
        "api_description": "Normalise a given path into a path-like object that can be passed to Rust.\n\nIdeally this would be something that we can convert to Rust's `OSString`, but in practice,\nPython uses `os.fsencode` to produce a `bytes` object, but this doesn't map especially well.",
        "api_signature": "_normalize_path(path)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm2/__init__.py"
    },
    {
        "api_name": "loads",
        "full_api_name": "loads",
        "api_description": "Parse an OpenQASM 2 program from a string into a :class:`.QuantumCircuit`.\n\nArgs:\n    string: The OpenQASM 2 program in a string.\n    include_path: order of directories to search when evaluating ``include`` statements.\n    custom_instructions: any custom constructors that should be used for specific gates or\n        opaque instructions during circuit construction.  See :ref:`qasm2-custom-instructions`\n        for more.\n    custom_classical: any custom classical functions that should be used during the parsing of\n        classical expressions.  See :ref:`qasm2-custom-classical` for more.\n    strict: whether to run in :ref:`strict mode <qasm2-strict-mode>`.\n\nReturns:\n    A circuit object representing the same OpenQASM 2 program.",
        "api_signature": "loads(string)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm2/__init__.py"
    },
    {
        "api_name": "load",
        "full_api_name": "load",
        "api_description": "Parse an OpenQASM 2 program from a file into a :class:`.QuantumCircuit`.  The given path\nshould be ASCII or UTF-8 encoded, and contain the OpenQASM 2 program.\n\nArgs:\n    filename: The OpenQASM 2 program in a string.\n    include_path: order of directories to search when evaluating ``include`` statements.\n    include_input_directory: Whether to add the directory of the input file to the\n        ``include_path``, and if so, whether to *append* it to search last, or *prepend* it to\n        search first.  Pass ``None`` to suppress adding this directory entirely.\n    custom_instructions: any custom constructors that should be used for specific gates or\n        opaque instructions during circuit construction.  See :ref:`qasm2-custom-instructions`\n        for more.\n    custom_classical: any custom classical functions that should be used during the parsing of\n        classical expressions.  See :ref:`qasm2-custom-classical` for more.\n    strict: whether to run in :ref:`strict mode <qasm2-strict-mode>`.\n\nReturns:\n    A circuit object representing the same OpenQASM 2 program.",
        "api_signature": "load(filename)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm2/__init__.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QobjDictField.__init__",
        "api_description": "Instantiate a new Qobj dict field object.\n\nArgs:\n    kwargs: arbitrary keyword arguments that can be accessed as\n        attributes of the object.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/common.py"
    },
    {
        "api_name": "to_dict",
        "full_api_name": "QobjDictField.to_dict",
        "api_description": "Return a dictionary format representation of the OpenQASM 2 Qobj.\n\nReturns:\n    dict: The dictionary form of the QobjHeader.",
        "api_signature": "to_dict(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/common.py"
    },
    {
        "api_name": "from_dict",
        "full_api_name": "QobjDictField.from_dict",
        "api_description": "Create a new QobjHeader object from a dictionary.\n\nArgs:\n    data (dict): A dictionary representing the QobjHeader to create. It\n        will be in the same format as output by :func:`to_dict`.\n\nReturns:\n    QobjDictFieldr: The QobjDictField from the input dictionary.",
        "api_signature": "from_dict(cls, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/common.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "QobjDictField.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/common.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QasmQobjInstruction.__init__",
        "api_description": "Instantiate a new QasmQobjInstruction object.\n\nArgs:\n    name (str): The name of the instruction\n    params (list): The list of parameters for the gate\n    qubits (list): A list of ``int`` representing the qubits the\n        instruction operates on\n    register (list): If a ``measure`` instruction this is a list\n        of ``int`` containing the list of register slots in which to\n        store the measurement results (must be the same length as\n        qubits). If a ``bfunc`` instruction this is a single ``int``\n        of the register slot in which to store the result.\n    memory (list): If a ``measure`` instruction this is a list\n        of ``int`` containing the list of memory slots to store the\n        measurement results in (must be the same length as qubits).\n        If a ``bfunc`` instruction this is a single ``int`` of the\n        memory slot to store the boolean function result in.\n    condition (tuple): A tuple of the form ``(int, int)`` where the\n        first ``int`` is the control register and the second ``int`` is\n        the control value if the gate has a condition.\n    conditional (int):  The register index of the condition\n    label (str): An optional label assigned to the instruction\n    mask (int): For a ``bfunc`` instruction the hex value which is\n        applied as an ``AND`` to the register bits.\n    relation (str): Relational  operator  for  comparing  the  masked\n        register to the ``val`` kwarg. Can be either ``==`` (equals) or\n        ``!=`` (not equals).\n    val (int): Value to which to compare the masked register. In other\n        words, the output of the function is ``(register AND mask)``\n    snapshot_type (str): For snapshot instructions the type of snapshot\n        to use",
        "api_signature": "__init__(self, name, params, qubits, register, memory, condition, conditional, label, mask, relation, val, snapshot_type)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/qasm_qobj.py"
    },
    {
        "api_name": "to_dict",
        "full_api_name": "QasmQobjInstruction.to_dict",
        "api_description": "Return a dictionary format representation of the Instruction.\n\nReturns:\n    dict: The dictionary form of the QasmQobjInstruction.",
        "api_signature": "to_dict(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/qasm_qobj.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "QasmQobjInstruction.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/qasm_qobj.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "QasmQobjInstruction.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/qasm_qobj.py"
    },
    {
        "api_name": "from_dict",
        "full_api_name": "QasmQobjInstruction.from_dict",
        "api_description": "Create a new QasmQobjInstruction object from a dictionary.\n\nArgs:\n    data (dict): A dictionary for the experiment config\n\nReturns:\n    QasmQobjInstruction: The object from the input dictionary.",
        "api_signature": "from_dict(cls, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/qasm_qobj.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "QasmQobjInstruction.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/qasm_qobj.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QasmQobjExperiment.__init__",
        "api_description": "Instantiate a QasmQobjExperiment.\n\nArgs:\n    config (QasmQobjExperimentConfig): A config object for the experiment\n    header (QasmQobjExperimentHeader): A header object for the experiment\n    instructions (list): A list of :class:`QasmQobjInstruction` objects",
        "api_signature": "__init__(self, config, header, instructions)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/qasm_qobj.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "QasmQobjExperiment.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/qasm_qobj.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "QasmQobjExperiment.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/qasm_qobj.py"
    },
    {
        "api_name": "to_dict",
        "full_api_name": "QasmQobjExperiment.to_dict",
        "api_description": "Return a dictionary format representation of the Experiment.\n\nReturns:\n    dict: The dictionary form of the QasmQObjExperiment.",
        "api_signature": "to_dict(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/qasm_qobj.py"
    },
    {
        "api_name": "from_dict",
        "full_api_name": "QasmQobjExperiment.from_dict",
        "api_description": "Create a new QasmQobjExperiment object from a dictionary.\n\nArgs:\n    data (dict): A dictionary for the experiment config\n\nReturns:\n    QasmQobjExperiment: The object from the input dictionary.",
        "api_signature": "from_dict(cls, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/qasm_qobj.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "QasmQobjExperiment.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/qasm_qobj.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QasmQobjConfig.__init__",
        "api_description": "Model for RunConfig.\n\nArgs:\n    shots (int): the number of shots.\n    seed_simulator (int): the seed to use in the simulator\n    memory (bool): whether to request memory from backend (per-shot readouts)\n    parameter_binds (list[dict]): List of parameter bindings\n    meas_level (int): Measurement level 0, 1, or 2\n    meas_return (str): For measurement level < 2, whether single or avg shots are returned\n    memory_slots (int): The number of memory slots on the device\n    n_qubits (int): The number of qubits on the device\n    pulse_library (list): List of :class:`PulseLibraryItem`.\n    calibrations (QasmExperimentCalibrations): Information required for Pulse gates.\n    rep_delay (float): Delay between programs in sec. Only supported on certain\n        backends (``backend.configuration().dynamic_reprate_enabled`` ). Must be from the\n        range supplied by the backend (``backend.configuration().rep_delay_range``). Default\n        is ``backend.configuration().default_rep_delay``.\n    qubit_lo_freq (list): List of frequencies (as floats) for the qubit driver LO's in GHz.\n    meas_lo_freq (list): List of frequencies (as floats) for the measurement driver LO's in\n        GHz.\n    kwargs: Additional free form key value fields to add to the\n        configuration.",
        "api_signature": "__init__(self, shots, seed_simulator, memory, parameter_binds, meas_level, meas_return, memory_slots, n_qubits, pulse_library, calibrations, rep_delay, qubit_lo_freq, meas_lo_freq)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/qasm_qobj.py"
    },
    {
        "api_name": "to_dict",
        "full_api_name": "QasmQobjConfig.to_dict",
        "api_description": "Return a dictionary format representation of the OpenQASM 2 Qobj config.\n\nReturns:\n    dict: The dictionary form of the QasmQobjConfig.",
        "api_signature": "to_dict(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/qasm_qobj.py"
    },
    {
        "api_name": "from_dict",
        "full_api_name": "QasmQobjConfig.from_dict",
        "api_description": "Create a new QasmQobjConfig object from a dictionary.\n\nArgs:\n    data (dict): A dictionary for the config\n\nReturns:\n    QasmQobjConfig: The object from the input dictionary.",
        "api_signature": "from_dict(cls, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/qasm_qobj.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "QasmQobjConfig.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/qasm_qobj.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QasmQobjExperimentConfig.__init__",
        "api_description": "Args:\n    calibrations (QasmExperimentCalibrations): Information required for Pulse gates.\n    qubit_lo_freq (List[float]): List of qubit LO frequencies in GHz.\n    meas_lo_freq (List[float]): List of meas readout LO frequencies in GHz.\n    kwargs: Additional free form key value fields to add to the configuration",
        "api_signature": "__init__(self, calibrations, qubit_lo_freq, meas_lo_freq)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/qasm_qobj.py"
    },
    {
        "api_name": "to_dict",
        "full_api_name": "QasmQobjExperimentConfig.to_dict",
        "api_description": "",
        "api_signature": "to_dict(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/qasm_qobj.py"
    },
    {
        "api_name": "from_dict",
        "full_api_name": "QasmQobjExperimentConfig.from_dict",
        "api_description": "",
        "api_signature": "from_dict(cls, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/qasm_qobj.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QasmExperimentCalibrations.__init__",
        "api_description": "Initialize a container for calibrations.\n\nArgs:\n    gates (list(GateCalibration))",
        "api_signature": "__init__(self, gates)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/qasm_qobj.py"
    },
    {
        "api_name": "to_dict",
        "full_api_name": "QasmExperimentCalibrations.to_dict",
        "api_description": "Return a dictionary format representation of the calibrations.\n\nReturns:\n    dict: The dictionary form of the GateCalibration.",
        "api_signature": "to_dict(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/qasm_qobj.py"
    },
    {
        "api_name": "from_dict",
        "full_api_name": "QasmExperimentCalibrations.from_dict",
        "api_description": "Create a new GateCalibration object from a dictionary.\n\nArgs:\n    data (dict): A dictionary representing the QasmExperimentCalibrations to\n                 create. It will be in the same format as output by :func:`to_dict`.\n\nReturns:\n    QasmExperimentCalibrations: The QasmExperimentCalibrations from the input dictionary.",
        "api_signature": "from_dict(cls, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/qasm_qobj.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "GateCalibration.__init__",
        "api_description": "Initialize a single gate calibration. Instructions may reference waveforms which should be\nmade available in the pulse_library.\n\nArgs:\n    name (str): Gate name.\n    qubits (list(int)): Qubits the gate applies to.\n    params (list(complex)): Gate parameter values, if any.\n    instructions (list(PulseQobjInstruction)): The gate implementation.",
        "api_signature": "__init__(self, name, qubits, params, instructions)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/qasm_qobj.py"
    },
    {
        "api_name": "__hash__",
        "full_api_name": "GateCalibration.__hash__",
        "api_description": "",
        "api_signature": "__hash__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/qasm_qobj.py"
    },
    {
        "api_name": "to_dict",
        "full_api_name": "GateCalibration.to_dict",
        "api_description": "Return a dictionary format representation of the Gate Calibration.\n\nReturns:\n    dict: The dictionary form of the GateCalibration.",
        "api_signature": "to_dict(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/qasm_qobj.py"
    },
    {
        "api_name": "from_dict",
        "full_api_name": "GateCalibration.from_dict",
        "api_description": "Create a new GateCalibration object from a dictionary.\n\nArgs:\n    data (dict): A dictionary representing the GateCalibration to create. It\n        will be in the same format as output by :func:`to_dict`.\n\nReturns:\n    GateCalibration: The GateCalibration from the input dictionary.",
        "api_signature": "from_dict(cls, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/qasm_qobj.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QasmQobj.__init__",
        "api_description": "Instantiate a new OpenQASM 2 Qobj Object.\n\nEach OpenQASM 2 Qobj object is used to represent a single payload that will\nbe passed to a Qiskit provider. It mirrors the Qobj the published\n`Qobj specification <https://arxiv.org/abs/1809.03452>`_ for OpenQASM\nexperiments.\n\nArgs:\n    qobj_id (str): An identifier for the qobj\n    config (QasmQobjRunConfig): A config for the entire run\n    header (QobjHeader): A header for the entire run\n    experiments (list): A list of lists of :class:`QasmQobjExperiment`\n        objects representing an experiment",
        "api_signature": "__init__(self, qobj_id, config, experiments, header)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/qasm_qobj.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "QasmQobj.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/qasm_qobj.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "QasmQobj.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/qasm_qobj.py"
    },
    {
        "api_name": "to_dict",
        "full_api_name": "QasmQobj.to_dict",
        "api_description": "Return a dictionary format representation of the OpenQASM 2 Qobj.\n\nNote this dict is not in the json wire format expected by IBM and Qobj\nspecification because complex numbers are still of type complex. Also,\nthis may contain native numpy arrays. When serializing this output\nfor use with IBM systems, you can leverage a json encoder that converts these\nas expected. For example:\n\n.. code-block::\n\n    import json\n    import numpy\n\n    class QobjEncoder(json.JSONEncoder):\n        def default(self, obj):\n            if isinstance(obj, numpy.ndarray):\n                return obj.tolist()\n            if isinstance(obj, complex):\n                return (obj.real, obj.imag)\n            return json.JSONEncoder.default(self, obj)\n\n    json.dumps(qobj.to_dict(), cls=QobjEncoder)\n\nReturns:\n    dict: A dictionary representation of the QasmQobj object",
        "api_signature": "to_dict(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/qasm_qobj.py"
    },
    {
        "api_name": "from_dict",
        "full_api_name": "QasmQobj.from_dict",
        "api_description": "Create a new QASMQobj object from a dictionary.\n\nArgs:\n    data (dict): A dictionary representing the QasmQobj to create. It\n        will be in the same format as output by :func:`to_dict`.\n\nReturns:\n    QasmQobj: The QasmQobj from the input dictionary.",
        "api_signature": "from_dict(cls, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/qasm_qobj.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "QasmQobj.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/qasm_qobj.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QobjMeasurementOption.__init__",
        "api_description": "Instantiate a new QobjMeasurementOption object.\n\nArgs:\n    name (str): The name of the measurement option\n    params (list): The parameters of the measurement option.",
        "api_signature": "__init__(self, name, params)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/pulse_qobj.py"
    },
    {
        "api_name": "to_dict",
        "full_api_name": "QobjMeasurementOption.to_dict",
        "api_description": "Return a dict format representation of the QobjMeasurementOption.\n\nReturns:\n    dict: The dictionary form of the QasmMeasurementOption.",
        "api_signature": "to_dict(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/pulse_qobj.py"
    },
    {
        "api_name": "from_dict",
        "full_api_name": "QobjMeasurementOption.from_dict",
        "api_description": "Create a new QobjMeasurementOption object from a dictionary.\n\nArgs:\n    data (dict): A dictionary for the experiment config\n\nReturns:\n    QobjMeasurementOption: The object from the input dictionary.",
        "api_signature": "from_dict(cls, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/pulse_qobj.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "QobjMeasurementOption.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/pulse_qobj.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PulseQobjInstruction.__init__",
        "api_description": "Instantiate a new PulseQobjInstruction object.\n\nArgs:\n    name (str): The name of the instruction\n    t0 (int): Pulse start time in integer **dt** units.\n    ch (str): The channel to apply the pulse instruction.\n    conditional (int): The register to use for a conditional for this\n        instruction\n    val (complex): Complex value to apply, bounded by an absolute value\n        of 1.\n    phase (float): if a ``fc`` instruction, the frame change phase in\n        radians.\n    frequency (float): if a ``sf`` instruction, the frequency in Hz.\n    duration (int): The duration of the pulse in **dt** units.\n    qubits (list): A list of ``int`` representing the qubits the\n        instruction operates on\n    memory_slot (list): If a ``measure`` instruction this is a list\n        of ``int`` containing the list of memory slots to store the\n        measurement results in (must be the same length as qubits).\n        If a ``bfunc`` instruction this is a single ``int`` of the\n        memory slot to store the boolean function result in.\n    register_slot (list): If a ``measure`` instruction this is a list\n        of ``int`` containing the list of register slots in which to\n        store the measurement results (must be the same length as\n        qubits). If a ``bfunc`` instruction this is a single ``int``\n        of the register slot in which to store the result.\n    kernels (list): List of :class:`QobjMeasurementOption` objects\n        defining the measurement kernels and set of parameters if the\n        measurement level is 1 or 2. Only used for ``acquire``\n        instructions.\n    discriminators (list): A list of :class:`QobjMeasurementOption`\n        used to set the discriminators to be used if the measurement\n        level is 2. Only used for ``acquire`` instructions.\n    label (str): Label of instruction\n    type (str): Type of instruction\n    pulse_shape (str): The shape of the parametric pulse\n    parameters (dict): The parameters for a parametric pulse",
        "api_signature": "__init__(self, name, t0, ch, conditional, val, phase, duration, qubits, memory_slot, register_slot, kernels, discriminators, label, type, pulse_shape, parameters, frequency)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/pulse_qobj.py"
    },
    {
        "api_name": "to_dict",
        "full_api_name": "PulseQobjInstruction.to_dict",
        "api_description": "Return a dictionary format representation of the Instruction.\n\nReturns:\n    dict: The dictionary form of the PulseQobjInstruction.",
        "api_signature": "to_dict(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/pulse_qobj.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "PulseQobjInstruction.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/pulse_qobj.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "PulseQobjInstruction.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/pulse_qobj.py"
    },
    {
        "api_name": "from_dict",
        "full_api_name": "PulseQobjInstruction.from_dict",
        "api_description": "Create a new PulseQobjExperimentConfig object from a dictionary.\n\nArgs:\n    data (dict): A dictionary for the experiment config\n\nReturns:\n    PulseQobjInstruction: The object from the input dictionary.",
        "api_signature": "from_dict(cls, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/pulse_qobj.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "PulseQobjInstruction.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/pulse_qobj.py"
    },
    {
        "api_name": "_to_complex",
        "full_api_name": "_to_complex",
        "api_description": "Convert the input value to type ``complex``.\nArgs:\n    value: Value to be converted.\nReturns:\n    Input value in ``complex``.\nRaises:\n    TypeError: If the input value is not in the expected format.",
        "api_signature": "_to_complex(value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/pulse_qobj.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PulseQobjConfig.__init__",
        "api_description": "Instantiate a PulseQobjConfig object.\n\nArgs:\n    meas_level (int): The measurement level to use.\n    meas_return (int): The level of measurement information to return.\n    pulse_library (list): A list of :class:`PulseLibraryItem` objects\n        which define the set of primitive pulses\n    qubit_lo_freq (list): List of frequencies (as floats) for the qubit\n        driver LO's in GHz.\n    meas_lo_freq (list): List of frequencies (as floats) for the'\n        measurement driver LO's in GHz.\n    memory_slot_size (int): Size of each memory slot if the output is\n        Level 0.\n    rep_time (int): Time per program execution in sec. Must be from the list provided\n        by the backend (``backend.configuration().rep_times``). Defaults to the first entry\n        in ``backend.configuration().rep_times``.\n    rep_delay (float): Delay between programs in sec. Only supported on certain\n        backends (``backend.configuration().dynamic_reprate_enabled`` ). If supported,\n        ``rep_delay`` will be used instead of ``rep_time`` and must be from the range\n        supplied by the backend (``backend.configuration().rep_delay_range``). Default is\n        ``backend.configuration().default_rep_delay``.\n    shots (int): The number of shots\n    seed_simulator (int): the seed to use in the simulator\n    memory_slots (list): The number of memory slots on the device\n    kwargs: Additional free form key value fields to add to the\n        configuration",
        "api_signature": "__init__(self, meas_level, meas_return, pulse_library, qubit_lo_freq, meas_lo_freq, memory_slot_size, rep_time, rep_delay, shots, seed_simulator, memory_slots)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/pulse_qobj.py"
    },
    {
        "api_name": "to_dict",
        "full_api_name": "PulseQobjConfig.to_dict",
        "api_description": "Return a dictionary format representation of the Pulse Qobj config.\n\nReturns:\n    dict: The dictionary form of the PulseQobjConfig.",
        "api_signature": "to_dict(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/pulse_qobj.py"
    },
    {
        "api_name": "from_dict",
        "full_api_name": "PulseQobjConfig.from_dict",
        "api_description": "Create a new PulseQobjConfig object from a dictionary.\n\nArgs:\n    data (dict): A dictionary for the config\n\nReturns:\n    PulseQobjConfig: The object from the input dictionary.",
        "api_signature": "from_dict(cls, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/pulse_qobj.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PulseQobjExperiment.__init__",
        "api_description": "Instantiate a PulseQobjExperiment.\n\nArgs:\n    config (PulseQobjExperimentConfig): A config object for the experiment\n    header (PulseQobjExperimentHeader): A header object for the experiment\n    instructions (list): A list of :class:`PulseQobjInstruction` objects",
        "api_signature": "__init__(self, instructions, config, header)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/pulse_qobj.py"
    },
    {
        "api_name": "to_dict",
        "full_api_name": "PulseQobjExperiment.to_dict",
        "api_description": "Return a dictionary format representation of the Experiment.\n\nReturns:\n    dict: The dictionary form of the PulseQobjExperiment.",
        "api_signature": "to_dict(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/pulse_qobj.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "PulseQobjExperiment.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/pulse_qobj.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "PulseQobjExperiment.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/pulse_qobj.py"
    },
    {
        "api_name": "from_dict",
        "full_api_name": "PulseQobjExperiment.from_dict",
        "api_description": "Create a new PulseQobjExperiment object from a dictionary.\n\nArgs:\n    data (dict): A dictionary for the experiment config\n\nReturns:\n    PulseQobjExperiment: The object from the input dictionary.",
        "api_signature": "from_dict(cls, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/pulse_qobj.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "PulseQobjExperiment.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/pulse_qobj.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PulseQobjExperimentConfig.__init__",
        "api_description": "Instantiate a PulseQobjExperimentConfig object.\n\nArgs:\n    qubit_lo_freq (List[float]): List of qubit LO frequencies in GHz.\n    meas_lo_freq (List[float]): List of meas readout LO frequencies in GHz.\n    kwargs: Additional free form key value fields to add to the configuration",
        "api_signature": "__init__(self, qubit_lo_freq, meas_lo_freq)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/pulse_qobj.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PulseLibraryItem.__init__",
        "api_description": "Instantiate a pulse library item.\n\nArgs:\n    name (str): A name for the pulse.\n    samples (list[complex]): A list of complex values defining pulse\n        shape.",
        "api_signature": "__init__(self, name, samples)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/pulse_qobj.py"
    },
    {
        "api_name": "to_dict",
        "full_api_name": "PulseLibraryItem.to_dict",
        "api_description": "Return a dictionary format representation of the pulse library item.\n\nReturns:\n    dict: The dictionary form of the PulseLibraryItem.",
        "api_signature": "to_dict(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/pulse_qobj.py"
    },
    {
        "api_name": "from_dict",
        "full_api_name": "PulseLibraryItem.from_dict",
        "api_description": "Create a new PulseLibraryItem object from a dictionary.\n\nArgs:\n    data (dict): A dictionary for the experiment config\n\nReturns:\n    PulseLibraryItem: The object from the input dictionary.",
        "api_signature": "from_dict(cls, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/pulse_qobj.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "PulseLibraryItem.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/pulse_qobj.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "PulseLibraryItem.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/pulse_qobj.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "PulseLibraryItem.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/pulse_qobj.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PulseQobj.__init__",
        "api_description": "Instantiate a new Pulse Qobj Object.\n\nEach Pulse Qobj object is used to represent a single payload that will\nbe passed to a Qiskit provider. It mirrors the Qobj the published\n`Qobj specification <https://arxiv.org/abs/1809.03452>`_ for Pulse\nexperiments.\n\nArgs:\n    qobj_id (str): An identifier for the qobj\n    config (PulseQobjConfig): A config for the entire run\n    header (QobjHeader): A header for the entire run\n    experiments (list): A list of lists of :class:`PulseQobjExperiment`\n        objects representing an experiment",
        "api_signature": "__init__(self, qobj_id, config, experiments, header)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/pulse_qobj.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "PulseQobj.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/pulse_qobj.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "PulseQobj.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/pulse_qobj.py"
    },
    {
        "api_name": "to_dict",
        "full_api_name": "PulseQobj.to_dict",
        "api_description": "Return a dictionary format representation of the Pulse Qobj.\n\nNote this dict is not in the json wire format expected by IBMQ and qobj\nspecification because complex numbers are still of type complex. Also\nthis may contain native numpy arrays. When serializing this output\nfor use with IBMQ you can leverage a json encoder that converts these\nas expected. For example:\n\n.. code-block::\n\n    import json\n    import numpy\n\n    class QobjEncoder(json.JSONEncoder):\n        def default(self, obj):\n            if isinstance(obj, numpy.ndarray):\n                return obj.tolist()\n            if isinstance(obj, complex):\n                return (obj.real, obj.imag)\n            return json.JSONEncoder.default(self, obj)\n\n    json.dumps(qobj.to_dict(), cls=QobjEncoder)\n\nReturns:\n    dict: A dictionary representation of the PulseQobj object",
        "api_signature": "to_dict(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/pulse_qobj.py"
    },
    {
        "api_name": "from_dict",
        "full_api_name": "PulseQobj.from_dict",
        "api_description": "Create a new PulseQobj object from a dictionary.\n\nArgs:\n    data (dict): A dictionary representing the PulseQobj to create. It\n        will be in the same format as output by :func:`to_dict`.\n\nReturns:\n    PulseQobj: The PulseQobj from the input dictionary.",
        "api_signature": "from_dict(cls, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/pulse_qobj.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "PulseQobj.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/pulse_qobj.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "LoConfigConverter.__init__",
        "api_description": "Create new converter.\n\nArgs:\n    qobj_model (Union[PulseQobjExperimentConfig, QasmQobjExperimentConfig): qobj model for\n        experiment config.\n    qubit_lo_freq (Optional[List[float]]): List of default qubit LO frequencies in Hz.\n    meas_lo_freq (Optional[List[float]]): List of default meas LO frequencies in Hz.\n    qubit_lo_range (Optional[List[List[float]]]): List of qubit LO ranges,\n        each of form ``[range_min, range_max]`` in Hz.\n    meas_lo_range (Optional[List[List[float]]]): List of measurement LO ranges,\n        each of form ``[range_min, range_max]`` in Hz.\n    n_qubits (int): Number of qubits in the system.\n    run_config (dict): experimental configuration.",
        "api_signature": "__init__(self, qobj_model, qubit_lo_freq, meas_lo_freq, qubit_lo_range, meas_lo_range)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/lo_config.py"
    },
    {
        "api_name": "__call__",
        "full_api_name": "LoConfigConverter.__call__",
        "api_description": "Return experiment config w/ LO values property configured.\n\nArgs:\n    user_lo_config (LoConfig): A dictionary of LOs to format.\n\nReturns:\n    Union[PulseQobjExperimentConfig, QasmQobjExperimentConfig]: Qobj experiment config.",
        "api_signature": "__call__(self, user_lo_config)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/lo_config.py"
    },
    {
        "api_name": "get_qubit_los",
        "full_api_name": "LoConfigConverter.get_qubit_los",
        "api_description": "Set experiment level qubit LO frequencies. Use default values from job level if\nexperiment level values not supplied. If experiment level and job level values not supplied,\nraise an error. If configured LO frequency is the same as default, this method returns\n``None``.\n\nArgs:\n    user_lo_config (LoConfig): A dictionary of LOs to format.\n\nReturns:\n    List[float]: A list of qubit LOs.\n\nRaises:\n    QiskitError: When LO frequencies are missing and no default is set at job level.",
        "api_signature": "get_qubit_los(self, user_lo_config)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/lo_config.py"
    },
    {
        "api_name": "get_meas_los",
        "full_api_name": "LoConfigConverter.get_meas_los",
        "api_description": "Set experiment level meas LO frequencies. Use default values from job level if experiment\nlevel values not supplied. If experiment level and job level values not supplied, raise an\nerror. If configured LO frequency is the same as default, this method returns ``None``.\n\nArgs:\n    user_lo_config (LoConfig): A dictionary of LOs to format.\n\nReturns:\n    List[float]: A list of measurement LOs.\n\nRaises:\n    QiskitError: When LO frequencies are missing and no default is set at job level.",
        "api_signature": "get_meas_los(self, user_lo_config)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/lo_config.py"
    },
    {
        "api_name": "from_instance",
        "full_api_name": "ParametricPulseShapes.from_instance",
        "api_description": "Get Qobj name from the pulse class instance.\n\nArgs:\n    instance: Symbolic or ParametricPulse class.\n\nReturns:\n    Qobj name.\n\nRaises:\n    QiskitError: When pulse instance is not recognizable type.",
        "api_signature": "from_instance(cls, instance)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "to_type",
        "full_api_name": "ParametricPulseShapes.to_type",
        "api_description": "Get symbolic pulse class from the name.\n\nArgs:\n    name: Qobj name of the pulse.\n\nReturns:\n    Corresponding class.",
        "api_signature": "to_type(cls, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "InstructionToQobjConverter.__init__",
        "api_description": "Create new converter.\n\nArgs:\n     qobj_model: Transfer layer data schema.\n     run_config: Run configuration.",
        "api_signature": "__init__(self, qobj_model)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "__call__",
        "full_api_name": "InstructionToQobjConverter.__call__",
        "api_description": "Convert Qiskit in-memory representation to Qobj instruction.\n\nArgs:\n    instruction: Instruction data in Qiskit Pulse.\n\nReturns:\n    Qobj instruction data.\n\nRaises:\n    QiskitError: When list of instruction is provided except for Acquire.",
        "api_signature": "__call__(self, shift, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "_convert_instruction",
        "full_api_name": "InstructionToQobjConverter._convert_instruction",
        "api_description": "",
        "api_signature": "_convert_instruction(self, instruction, time_offset)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "_convert_acquire",
        "full_api_name": "InstructionToQobjConverter._convert_acquire",
        "api_description": "Return converted `Acquire`.\n\nArgs:\n    instruction: Qiskit Pulse acquire instruction.\n    time_offset: Offset time.\n\nReturns:\n    Qobj instruction data.",
        "api_signature": "_convert_acquire(self, instruction, time_offset)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "_convert_set_frequency",
        "full_api_name": "InstructionToQobjConverter._convert_set_frequency",
        "api_description": "Return converted `SetFrequency`.\n\nArgs:\n    instruction: Qiskit Pulse set frequency instruction.\n    time_offset: Offset time.\n\nReturns:\n    Qobj instruction data.",
        "api_signature": "_convert_set_frequency(self, instruction, time_offset)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "_convert_shift_frequency",
        "full_api_name": "InstructionToQobjConverter._convert_shift_frequency",
        "api_description": "Return converted `ShiftFrequency`.\n\nArgs:\n    instruction: Qiskit Pulse shift frequency instruction.\n    time_offset: Offset time.\n\nReturns:\n    Qobj instruction data.",
        "api_signature": "_convert_shift_frequency(self, instruction, time_offset)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "_convert_set_phase",
        "full_api_name": "InstructionToQobjConverter._convert_set_phase",
        "api_description": "Return converted `SetPhase`.\n\nArgs:\n    instruction: Qiskit Pulse set phase instruction.\n    time_offset: Offset time.\n\nReturns:\n    Qobj instruction data.",
        "api_signature": "_convert_set_phase(self, instruction, time_offset)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "_convert_shift_phase",
        "full_api_name": "InstructionToQobjConverter._convert_shift_phase",
        "api_description": "Return converted `ShiftPhase`.\n\nArgs:\n    instruction: Qiskit Pulse shift phase instruction.\n    time_offset: Offset time.\n\nReturns:\n    Qobj instruction data.",
        "api_signature": "_convert_shift_phase(self, instruction, time_offset)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "_convert_delay",
        "full_api_name": "InstructionToQobjConverter._convert_delay",
        "api_description": "Return converted `Delay`.\n\nArgs:\n    instruction: Qiskit Pulse delay instruction.\n    time_offset: Offset time.\n\nReturns:\n    Qobj instruction data.",
        "api_signature": "_convert_delay(self, instruction, time_offset)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "_convert_play",
        "full_api_name": "InstructionToQobjConverter._convert_play",
        "api_description": "Return converted `Play`.\n\nArgs:\n    instruction: Qiskit Pulse play instruction.\n    time_offset: Offset time.\n\nReturns:\n    Qobj instruction data.",
        "api_signature": "_convert_play(self, instruction, time_offset)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "_convert_snapshot",
        "full_api_name": "InstructionToQobjConverter._convert_snapshot",
        "api_description": "Return converted `Snapshot`.\n\nArgs:\n    time_offset: Offset time.\n    instruction: Qiskit Pulse snapshot instruction.\n\nReturns:\n    Qobj instruction data.",
        "api_signature": "_convert_snapshot(self, instruction, time_offset)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "_convert_bundled_acquire",
        "full_api_name": "InstructionToQobjConverter._convert_bundled_acquire",
        "api_description": "Return converted list of parallel `Acquire` instructions.\n\nArgs:\n    instruction_bundle: List of Qiskit Pulse acquire instruction.\n    time_offset: Offset time.\n\nReturns:\n    Qobj instruction data.\n\nRaises:\n    QiskitError: When instructions are not aligned.\n    QiskitError: When instructions have different duration.\n    QiskitError: When discriminator or kernel is missing in a part of instructions.",
        "api_signature": "_convert_bundled_acquire(self, instruction_bundle, time_offset)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "convert_acquire",
        "full_api_name": "InstructionToQobjConverter.convert_acquire",
        "api_description": "",
        "api_signature": "convert_acquire(self, shift, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "convert_bundled_acquires",
        "full_api_name": "InstructionToQobjConverter.convert_bundled_acquires",
        "api_description": "",
        "api_signature": "convert_bundled_acquires(self, shift, instructions_)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "convert_set_frequency",
        "full_api_name": "InstructionToQobjConverter.convert_set_frequency",
        "api_description": "",
        "api_signature": "convert_set_frequency(self, shift, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "convert_shift_frequency",
        "full_api_name": "InstructionToQobjConverter.convert_shift_frequency",
        "api_description": "",
        "api_signature": "convert_shift_frequency(self, shift, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "convert_set_phase",
        "full_api_name": "InstructionToQobjConverter.convert_set_phase",
        "api_description": "",
        "api_signature": "convert_set_phase(self, shift, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "convert_shift_phase",
        "full_api_name": "InstructionToQobjConverter.convert_shift_phase",
        "api_description": "",
        "api_signature": "convert_shift_phase(self, shift, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "convert_delay",
        "full_api_name": "InstructionToQobjConverter.convert_delay",
        "api_description": "",
        "api_signature": "convert_delay(self, shift, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "convert_play",
        "full_api_name": "InstructionToQobjConverter.convert_play",
        "api_description": "",
        "api_signature": "convert_play(self, shift, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "convert_snapshot",
        "full_api_name": "InstructionToQobjConverter.convert_snapshot",
        "api_description": "",
        "api_signature": "convert_snapshot(self, shift, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QobjToInstructionConverter.__init__",
        "api_description": "Create new converter.\n\nArgs:\n    pulse_library: Pulse library in Qobj format.\n     run_config: Run configuration.",
        "api_signature": "__init__(self, pulse_library)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "__call__",
        "full_api_name": "QobjToInstructionConverter.__call__",
        "api_description": "Convert Qobj instruction to Qiskit in-memory representation.\n\nArgs:\n    instruction: Instruction data in Qobj format.\n\nReturns:\n    Scheduled Qiskit Pulse instruction in Schedule format.",
        "api_signature": "__call__(self, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "_get_sequences",
        "full_api_name": "QobjToInstructionConverter._get_sequences",
        "api_description": "A method to iterate over pulse instructions without creating Schedule.\n\n.. note::\n\n    This is internal fast-path function, and callers other than this converter class\n    might directly use this method to generate schedule from multiple\n    Qobj instructions. Because __call__ always returns a schedule with the time offset\n    parsed instruction, composing multiple Qobj instructions to create\n    a gate schedule is somewhat inefficient due to composing overhead of schedules.\n    Directly combining instructions with this method is much performant.\n\nArgs:\n    instruction: Instruction data in Qobj format.\n\nYields:\n    Qiskit Pulse instructions.\n\n:meta public:",
        "api_signature": "_get_sequences(self, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "get_supported_instructions",
        "full_api_name": "QobjToInstructionConverter.get_supported_instructions",
        "api_description": "Retrun a list of supported instructions.",
        "api_signature": "get_supported_instructions(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "get_channel",
        "full_api_name": "QobjToInstructionConverter.get_channel",
        "api_description": "Parse and retrieve channel from ch string.\n\nArgs:\n    channel: String identifier of pulse instruction channel.\n\nReturns:\n    Matched channel object.\n\nRaises:\n    QiskitError: Is raised if valid channel is not matched",
        "api_signature": "get_channel(self, channel)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "disassemble_value",
        "full_api_name": "QobjToInstructionConverter.disassemble_value",
        "api_description": "A helper function to format instruction operand.\n\nIf parameter in string representation is specified, this method parses the\ninput string and generates Qiskit ParameterExpression object.\n\nArgs:\n    value_expr: Operand value in Qobj.\n\nReturns:\n    Parsed operand value. ParameterExpression object is returned if value is not number.",
        "api_signature": "disassemble_value(value_expr)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "_convert_acquire",
        "full_api_name": "QobjToInstructionConverter._convert_acquire",
        "api_description": "Return converted `Acquire` instruction.\n\nArgs:\n    instruction: Acquire qobj\n\nYields:\n    Qiskit Pulse acquire instructions",
        "api_signature": "_convert_acquire(self, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "_convert_setp",
        "full_api_name": "QobjToInstructionConverter._convert_setp",
        "api_description": "Return converted `SetPhase` instruction.\n\nArgs:\n    instruction: SetPhase qobj instruction\n\nYields:\n    Qiskit Pulse set phase instructions",
        "api_signature": "_convert_setp(self, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "_convert_fc",
        "full_api_name": "QobjToInstructionConverter._convert_fc",
        "api_description": "Return converted `ShiftPhase` instruction.\n\nArgs:\n    instruction: ShiftPhase qobj instruction\n\nYields:\n    Qiskit Pulse shift phase schedule instructions",
        "api_signature": "_convert_fc(self, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "_convert_setf",
        "full_api_name": "QobjToInstructionConverter._convert_setf",
        "api_description": "Return converted `SetFrequencyInstruction` instruction.\n\n.. note::\n\n    We assume frequency value is expressed in string with \"GHz\".\n    Operand value is thus scaled by a factor of 1e9.\n\nArgs:\n    instruction: SetFrequency qobj instruction\n\nYields:\n    Qiskit Pulse set frequency instructions",
        "api_signature": "_convert_setf(self, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "_convert_shiftf",
        "full_api_name": "QobjToInstructionConverter._convert_shiftf",
        "api_description": "Return converted `ShiftFrequency` instruction.\n\n.. note::\n\n    We assume frequency value is expressed in string with \"GHz\".\n    Operand value is thus scaled by a factor of 1e9.\n\nArgs:\n    instruction: ShiftFrequency qobj instruction\n\nYields:\n    Qiskit Pulse shift frequency schedule instructions",
        "api_signature": "_convert_shiftf(self, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "_convert_delay",
        "full_api_name": "QobjToInstructionConverter._convert_delay",
        "api_description": "Return converted `Delay` instruction.\n\nArgs:\n    instruction: Delay qobj instruction\n\nYields:\n    Qiskit Pulse delay instructions",
        "api_signature": "_convert_delay(self, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "_convert_parametric_pulse",
        "full_api_name": "QobjToInstructionConverter._convert_parametric_pulse",
        "api_description": "Return converted `Play` instruction with parametric pulse operand.\n\n.. note::\n\n    If parametric pulse label is not provided by the backend, this method naively generates\n    a pulse name based on the pulse shape and bound parameters. This pulse name is formatted\n    to, for example, `gaussian_a4e3`, here the last four digits are a part of\n    the hash string generated based on the pulse shape and the parameters.\n    Because we are using a truncated hash for readability,\n    there may be a small risk of pulse name collision with other pulses.\n    Basically the parametric pulse name is used just for visualization purpose and\n    the pulse module should not have dependency on the parametric pulse names.\n\nArgs:\n    instruction: Play qobj instruction with parametric pulse\n\nYields:\n    Qiskit Pulse play schedule instructions",
        "api_signature": "_convert_parametric_pulse(self, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "_convert_snapshot",
        "full_api_name": "QobjToInstructionConverter._convert_snapshot",
        "api_description": "Return converted `Snapshot` instruction.\n\nArgs:\n    instruction: Snapshot qobj instruction\n\nYields:\n    Qiskit Pulse snapshot instructions",
        "api_signature": "_convert_snapshot(self, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "_convert_generic",
        "full_api_name": "QobjToInstructionConverter._convert_generic",
        "api_description": "Convert generic pulse instruction.\n\nArgs:\n    instruction: Generic qobj instruction\n\nYields:\n    Qiskit Pulse generic instructions\n\nRaises:\n    QiskitError: When instruction name not found.",
        "api_signature": "_convert_generic(self, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "convert_acquire",
        "full_api_name": "QobjToInstructionConverter.convert_acquire",
        "api_description": "",
        "api_signature": "convert_acquire(self, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "convert_set_phase",
        "full_api_name": "QobjToInstructionConverter.convert_set_phase",
        "api_description": "",
        "api_signature": "convert_set_phase(self, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "convert_shift_phase",
        "full_api_name": "QobjToInstructionConverter.convert_shift_phase",
        "api_description": "",
        "api_signature": "convert_shift_phase(self, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "convert_set_frequency",
        "full_api_name": "QobjToInstructionConverter.convert_set_frequency",
        "api_description": "",
        "api_signature": "convert_set_frequency(self, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "convert_shift_frequency",
        "full_api_name": "QobjToInstructionConverter.convert_shift_frequency",
        "api_description": "",
        "api_signature": "convert_shift_frequency(self, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "convert_delay",
        "full_api_name": "QobjToInstructionConverter.convert_delay",
        "api_description": "",
        "api_signature": "convert_delay(self, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "bind_pulse",
        "full_api_name": "QobjToInstructionConverter.bind_pulse",
        "api_description": "",
        "api_signature": "bind_pulse(self, pulse)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "convert_parametric",
        "full_api_name": "QobjToInstructionConverter.convert_parametric",
        "api_description": "",
        "api_signature": "convert_parametric(self, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "convert_snapshot",
        "full_api_name": "QobjToInstructionConverter.convert_snapshot",
        "api_description": "",
        "api_signature": "convert_snapshot(self, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "synth_clifford_ag",
        "full_api_name": "synth_clifford_ag",
        "api_description": "Decompose a Clifford operator into a QuantumCircuit based on Aaronson-Gottesman method.\n\nArgs:\n    clifford (Clifford): a clifford operator.\n\nReturn:\n    QuantumCircuit: a circuit implementation of the Clifford.\n\nReference:\n    1. S. Aaronson, D. Gottesman, *Improved Simulation of Stabilizer Circuits*,\n       Phys. Rev. A 70, 052328 (2004).\n       `arXiv:quant-ph/0406196 <https://arxiv.org/abs/quant-ph/0406196>`_",
        "api_signature": "synth_clifford_ag(clifford)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/clifford/clifford_decompose_ag.py"
    },
    {
        "api_name": "_set_qubit_x_true",
        "full_api_name": "_set_qubit_x_true",
        "api_description": "Set destabilizer.X[qubit, qubit] to be True.\n\nThis is done by permuting columns l > qubit or if necessary applying\na Hadamard",
        "api_signature": "_set_qubit_x_true(clifford, circuit, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/clifford/clifford_decompose_ag.py"
    },
    {
        "api_name": "_set_row_x_zero",
        "full_api_name": "_set_row_x_zero",
        "api_description": "Set destabilizer.X[qubit, i] to False for all i > qubit.\n\nThis is done by applying CNOTS assumes k<=N and A[k][k]=1",
        "api_signature": "_set_row_x_zero(clifford, circuit, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/clifford/clifford_decompose_ag.py"
    },
    {
        "api_name": "_set_row_z_zero",
        "full_api_name": "_set_row_z_zero",
        "api_description": "Set stabilizer.Z[qubit, i] to False for all i > qubit.\n\nImplemented by applying (reverse) CNOTS assumes qubit < num_qubits\nand _set_row_x_zero has been called first",
        "api_signature": "_set_row_z_zero(clifford, circuit, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/clifford/clifford_decompose_ag.py"
    },
    {
        "api_name": "synth_clifford_greedy",
        "full_api_name": "synth_clifford_greedy",
        "api_description": "Decompose a Clifford operator into a QuantumCircuit based on the\ngreedy Clifford compiler that is described in Appendix A of\nBravyi, Hu, Maslov and Shaydulin.\n\nThis method typically yields better CX cost compared to the Aaronson-Gottesman method.\n\nArgs:\n    clifford (Clifford): a clifford operator.\n\nReturn:\n    QuantumCircuit: a circuit implementation of the Clifford.\n\nRaises:\n    QiskitError: if symplectic Gaussian elimination fails.\n\nReference:\n    1. Sergey Bravyi, Shaohan Hu, Dmitri Maslov, Ruslan Shaydulin,\n       *Clifford Circuit Optimization with Templates and Symbolic Pauli Gates*,\n       `arXiv:2105.02291 [quant-ph] <https://arxiv.org/abs/2105.02291>`_",
        "api_signature": "synth_clifford_greedy(clifford)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/clifford/clifford_decompose_greedy.py"
    },
    {
        "api_name": "_from_pair_paulis_to_type",
        "full_api_name": "_from_pair_paulis_to_type",
        "api_description": "Converts a pair of Paulis pauli_x and pauli_z into a type",
        "api_signature": "_from_pair_paulis_to_type(pauli_x, pauli_z, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/clifford/clifford_decompose_greedy.py"
    },
    {
        "api_name": "_compute_greedy_cost",
        "full_api_name": "_compute_greedy_cost",
        "api_description": "Compute the CNOT cost of one step of the algorithm",
        "api_signature": "_compute_greedy_cost(list_pairs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/clifford/clifford_decompose_greedy.py"
    },
    {
        "api_name": "_calc_decoupling",
        "full_api_name": "_calc_decoupling",
        "api_description": "Calculate a decoupling operator D:\nD^{-1} * Ox * D = x1\nD^{-1} * Oz * D = z1\nand reduce the clifford such that it will act trivially on min_qubit",
        "api_signature": "_calc_decoupling(pauli_x, pauli_z, qubit_list, min_qubit, num_qubits, cliff)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/clifford/clifford_decompose_greedy.py"
    },
    {
        "api_name": "synth_clifford_full",
        "full_api_name": "synth_clifford_full",
        "api_description": "Decompose a Clifford operator into a QuantumCircuit.\n\nFor N <= 3 qubits this is based on optimal CX cost decomposition\nfrom reference [1]. For N > 3 qubits this is done using the general\nnon-optimal greedy compilation routine from reference [3],\nwhich typically yields better CX cost compared to the AG method in [2].\n\nArgs:\n    clifford (Clifford): a clifford operator.\n    method (str):  Optional, a synthesis method ('AG' or 'greedy').\n         If set this overrides optimal decomposition for N <=3 qubits.\n\nReturn:\n    QuantumCircuit: a circuit implementation of the Clifford.\n\nReferences:\n    1. S. Bravyi, D. Maslov, *Hadamard-free circuits expose the\n       structure of the Clifford group*,\n       `arXiv:2003.09412 [quant-ph] <https://arxiv.org/abs/2003.09412>`_\n\n    2. S. Aaronson, D. Gottesman, *Improved Simulation of Stabilizer Circuits*,\n       Phys. Rev. A 70, 052328 (2004).\n       `arXiv:quant-ph/0406196 <https://arxiv.org/abs/quant-ph/0406196>`_\n\n    3. Sergey Bravyi, Shaohan Hu, Dmitri Maslov, Ruslan Shaydulin,\n       *Clifford Circuit Optimization with Templates and Symbolic Pauli Gates*,\n       `arXiv:2105.02291 [quant-ph] <https://arxiv.org/abs/2105.02291>`_",
        "api_signature": "synth_clifford_full(clifford, method)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/clifford/clifford_decompose_full.py"
    },
    {
        "api_name": "synth_clifford_bm",
        "full_api_name": "synth_clifford_bm",
        "api_description": "Optimal CX-cost decomposition of a Clifford operator on 2-qubits or 3-qubits\ninto a QuantumCircuit based on Bravyi-Maslov method.\n\nArgs:\n    clifford (Clifford): a clifford operator.\n\nReturn:\n    QuantumCircuit: a circuit implementation of the Clifford.\n\nRaises:\n    QiskitError: if clifford is on more than 3 qubits.\n\nReference:\n    1. S. Bravyi, D. Maslov, *Hadamard-free circuits expose the\n       structure of the Clifford group*,\n       `arXiv:2003.09412 [quant-ph] <https://arxiv.org/abs/2003.09412>`_",
        "api_signature": "synth_clifford_bm(clifford)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/clifford/clifford_decompose_bm.py"
    },
    {
        "api_name": "_decompose_clifford_1q",
        "full_api_name": "_decompose_clifford_1q",
        "api_description": "Decompose a single-qubit clifford",
        "api_signature": "_decompose_clifford_1q(tableau)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/clifford/clifford_decompose_bm.py"
    },
    {
        "api_name": "_reduce_cost",
        "full_api_name": "_reduce_cost",
        "api_description": "Two-qubit cost reduction step",
        "api_signature": "_reduce_cost(clifford, inv_circuit, cost)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/clifford/clifford_decompose_bm.py"
    },
    {
        "api_name": "_cx_cost",
        "full_api_name": "_cx_cost",
        "api_description": "Return the number of CX gates required for Clifford decomposition.",
        "api_signature": "_cx_cost(clifford)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/clifford/clifford_decompose_bm.py"
    },
    {
        "api_name": "_rank2",
        "full_api_name": "_rank2",
        "api_description": "Return rank of 2x2 boolean matrix.",
        "api_signature": "_rank2(a, b, c, d)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/clifford/clifford_decompose_bm.py"
    },
    {
        "api_name": "_cx_cost2",
        "full_api_name": "_cx_cost2",
        "api_description": "Return CX cost of a 2-qubit clifford.",
        "api_signature": "_cx_cost2(clifford)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/clifford/clifford_decompose_bm.py"
    },
    {
        "api_name": "_cx_cost3",
        "full_api_name": "_cx_cost3",
        "api_description": "Return CX cost of a 3-qubit clifford.",
        "api_signature": "_cx_cost3(clifford)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/clifford/clifford_decompose_bm.py"
    },
    {
        "api_name": "_default_cx_synth_func",
        "full_api_name": "_default_cx_synth_func",
        "api_description": "Construct the layer of CX gates from a boolean invertible matrix mat.",
        "api_signature": "_default_cx_synth_func(mat)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/clifford/clifford_decompose_layers.py"
    },
    {
        "api_name": "_default_cz_synth_func",
        "full_api_name": "_default_cz_synth_func",
        "api_description": "Construct the layer of CZ gates from a symmetric matrix.",
        "api_signature": "_default_cz_synth_func(symmetric_mat)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/clifford/clifford_decompose_layers.py"
    },
    {
        "api_name": "synth_clifford_layers",
        "full_api_name": "synth_clifford_layers",
        "api_description": "Synthesis of a Clifford into layers, it provides a similar decomposition to the synthesis\ndescribed in Lemma 8 of Bravyi and Maslov.\n\nFor example, a 5-qubit Clifford circuit is decomposed into the following layers:\n\n.. parsed-literal::\n         \u250c\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    q_0: \u25240    \u251c\u25240    \u251c\u25240       \u251c\u25240    \u251c\u25240    \u251c\u25240    \u251c\u25240    \u251c\u25240       \u251c\n         \u2502     \u2502\u2502     \u2502\u2502        \u2502\u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502        \u2502\n    q_1: \u25241    \u251c\u25241    \u251c\u25241       \u251c\u25241    \u251c\u25241    \u251c\u25241    \u251c\u25241    \u251c\u25241       \u251c\n         \u2502     \u2502\u2502     \u2502\u2502        \u2502\u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502        \u2502\n    q_2: \u25242 S2 \u251c\u25242 CZ \u251c\u25242 CX_dg \u251c\u25242 H2 \u251c\u25242 S1 \u251c\u25242 CZ \u251c\u25242 H1 \u251c\u25242 Pauli \u251c\n         \u2502     \u2502\u2502     \u2502\u2502        \u2502\u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502        \u2502\n    q_3: \u25243    \u251c\u25243    \u251c\u25243       \u251c\u25243    \u251c\u25243    \u251c\u25243    \u251c\u25243    \u251c\u25243       \u251c\n         \u2502     \u2502\u2502     \u2502\u2502        \u2502\u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502        \u2502\n    q_4: \u25244    \u251c\u25244    \u251c\u25244       \u251c\u25244    \u251c\u25244    \u251c\u25244    \u251c\u25244    \u251c\u25244       \u251c\n         \u2514\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nThis decomposition is for the default cz_synth_func and cx_synth_func functions,\nwith other functions one may see slightly different decomposition.\n\nArgs:\n    cliff (Clifford): a clifford operator.\n    cx_synth_func (Callable): a function to decompose the CX sub-circuit.\n        It gets as input a boolean invertible matrix, and outputs a QuantumCircuit.\n    cz_synth_func (Callable): a function to decompose the CZ sub-circuit.\n        It gets as input a boolean symmetric matrix, and outputs a QuantumCircuit.\n    cx_cz_synth_func (Callable): optional, a function to decompose both sub-circuits CZ and CX.\n    validate (Boolean): if True, validates the synthesis process.\n    cz_func_reverse_qubits (Boolean): True only if cz_synth_func is synth_cz_depth_line_mr,\n        since this function returns a circuit that reverts the order of qubits.\n\nReturn:\n    QuantumCircuit: a circuit implementation of the Clifford.\n\nReference:\n    1. S. Bravyi, D. Maslov, *Hadamard-free circuits expose the\n       structure of the Clifford group*,\n       `arXiv:2003.09412 [quant-ph] <https://arxiv.org/abs/2003.09412>`_",
        "api_signature": "synth_clifford_layers(cliff, cx_synth_func, cz_synth_func, cx_cz_synth_func, cz_func_reverse_qubits, validate)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/clifford/clifford_decompose_layers.py"
    },
    {
        "api_name": "_reverse_clifford",
        "full_api_name": "_reverse_clifford",
        "api_description": "Reverse qubit order of a Clifford cliff",
        "api_signature": "_reverse_clifford(cliff)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/clifford/clifford_decompose_layers.py"
    },
    {
        "api_name": "_create_graph_state",
        "full_api_name": "_create_graph_state",
        "api_description": "Given a Clifford cliff (denoted by U) that induces a stabilizer state U |0>,\napply a layer H1 of Hadamard gates to a subset of the qubits to make H1 U |0> into a graph state,\nnamely to make cliff.stab_x matrix have full rank.\nReturns the QuantumCircuit H1_circ that includes the Hadamard gates and the updated Clifford\nthat induces the graph state.\nThe algorithm is based on Lemma 6 in [2].\n\nArgs:\n    cliff (Clifford): a clifford operator.\n    validate (Boolean): if True, validates the synthesis process.\n\nReturn:\n    H1_circ: a circuit containing a layer of Hadamard gates.\n    cliffh: cliffh.stab_x has full rank.\n\nRaises:\n    QiskitError: if there are errors in the Gauss elimination process.\n\nReference:\n    2. S. Aaronson, D. Gottesman, *Improved Simulation of Stabilizer Circuits*,\n       Phys. Rev. A 70, 052328 (2004).\n       `arXiv:quant-ph/0406196 <https://arxiv.org/abs/quant-ph/0406196>`_",
        "api_signature": "_create_graph_state(cliff, validate)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/clifford/clifford_decompose_layers.py"
    },
    {
        "api_name": "_decompose_graph_state",
        "full_api_name": "_decompose_graph_state",
        "api_description": "Assumes that a stabilizer state of the Clifford cliff (denoted by U) corresponds to a graph state.\nDecompose it into the layers S1 - CZ1 - H2, such that:\nS1 CZ1 H2 |0> = U |0>,\nwhere S1_circ is a circuit that can contain only S gates,\nCZ1_circ is a circuit that can contain only CZ gates, and\nH2_circ is a circuit that can contain H gates on all qubits.\n\nArgs:\n    cliff (Clifford): a clifford operator corresponding to a graph state, cliff.stab_x has full rank.\n    validate (Boolean): if True, validates the synthesis process.\n    cz_synth_func (Callable): a function to decompose the CZ sub-circuit.\n\nReturn:\n    S1_circ: a circuit that can contain only S gates.\n    CZ1_circ: a circuit that can contain only CZ gates.\n    H2_circ: a circuit containing a layer of Hadamard gates.\n    cliff_cpy: a Hadamard-free Clifford.\n\nRaises:\n    QiskitError: if cliff does not induce a graph state.",
        "api_signature": "_decompose_graph_state(cliff, validate, cz_synth_func)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/clifford/clifford_decompose_layers.py"
    },
    {
        "api_name": "_decompose_hadamard_free",
        "full_api_name": "_decompose_hadamard_free",
        "api_description": "Assumes that the Clifford cliff is Hadamard free.\nDecompose it into the layers S2 - CZ2 - CX, where\nS2_circ is a circuit that can contain only S gates,\nCZ2_circ is a circuit that can contain only CZ gates, and\nCX_circ is a circuit that can contain CX gates.\n\nArgs:\n    cliff (Clifford): a Hadamard-free clifford operator.\n    validate (Boolean): if True, validates the synthesis process.\n    cz_synth_func (Callable): a function to decompose the CZ sub-circuit.\n    cx_synth_func (Callable): a function to decompose the CX sub-circuit.\n    cx_cz_synth_func (Callable): optional, a function to decompose both sub-circuits CZ and CX.\n    cz_func_reverse_qubits (Boolean): True only if cz_synth_func is synth_cz_depth_line_mr.\n\nReturn:\n    S2_circ: a circuit that can contain only S gates.\n    CZ2_circ: a circuit that can contain only CZ gates.\n    CX_circ: a circuit that can contain only CX gates.\n\nRaises:\n    QiskitError: if cliff is not Hadamard free.",
        "api_signature": "_decompose_hadamard_free(cliff, validate, cz_synth_func, cx_synth_func, cx_cz_synth_func, cz_func_reverse_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/clifford/clifford_decompose_layers.py"
    },
    {
        "api_name": "_calc_pauli_diff",
        "full_api_name": "_calc_pauli_diff",
        "api_description": "Given two Cliffords that differ by a Pauli, we find this Pauli.",
        "api_signature": "_calc_pauli_diff(cliff, cliff_target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/clifford/clifford_decompose_layers.py"
    },
    {
        "api_name": "synth_clifford_depth_lnn",
        "full_api_name": "synth_clifford_depth_lnn",
        "api_description": "Synthesis of a Clifford into layers for linear-nearest neighbour connectivity.\n\nThe depth of the synthesized n-qubit circuit is bounded by 7*n+2, which is not optimal.\nIt should be replaced by a better algorithm that provides depth bounded by 7*n-4 [3].\n\nArgs:\n    cliff (Clifford): a clifford operator.\n\nReturn:\n    QuantumCircuit: a circuit implementation of the Clifford.\n\nReference:\n    1. S. Bravyi, D. Maslov, *Hadamard-free circuits expose the\n       structure of the Clifford group*,\n       `arXiv:2003.09412 [quant-ph] <https://arxiv.org/abs/2003.09412>`_\n    2. Dmitri Maslov, Martin Roetteler,\n       *Shorter stabilizer circuits via Bruhat decomposition and quantum circuit transformations*,\n       `arXiv:1705.09176 <https://arxiv.org/abs/1705.09176>`_.\n    3. Dmitri Maslov, Willers Yang, *CNOT circuits need little help to implement arbitrary\n       Hadamard-free Clifford transformations they generate*,\n       `arXiv:2210.16195 <https://arxiv.org/abs/2210.16195>`_.",
        "api_signature": "synth_clifford_depth_lnn(cliff)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/clifford/clifford_decompose_layers.py"
    },
    {
        "api_name": "_compute_trace_so3",
        "full_api_name": "_compute_trace_so3",
        "api_description": "Computes trace of an SO(3)-matrix.\n\nArgs:\n    matrix: an SO(3)-matrix\n\nReturns:\n    Trace of ``matrix``.\n\nRaises:\n    ValueError: if ``matrix`` is not an SO(3)-matrix.",
        "api_signature": "_compute_trace_so3(matrix)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/commutator_decompose.py"
    },
    {
        "api_name": "_compute_rotation_axis",
        "full_api_name": "_compute_rotation_axis",
        "api_description": "Computes rotation axis of SO(3)-matrix.\n\nArgs:\n    matrix: The SO(3)-matrix for which rotation angle needs to be computed.\n\nReturns:\n    The rotation axis of the SO(3)-matrix ``matrix``.\n\nRaises:\n    ValueError: if ``matrix`` is not an SO(3)-matrix.",
        "api_signature": "_compute_rotation_axis(matrix)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/commutator_decompose.py"
    },
    {
        "api_name": "_solve_decomposition_angle",
        "full_api_name": "_solve_decomposition_angle",
        "api_description": "Computes angle for balanced commutator of SO(3)-matrix ``matrix``.\n\nComputes angle a so that the SO(3)-matrix ``matrix`` can be decomposed\nas commutator [v,w] where v and w are both rotations of a about some axis.\nThe computation is done by solving a trigonometric equation using scipy.optimize.fsolve.\n\nArgs:\n    matrix: The SO(3)-matrix for which the decomposition angle needs to be computed.\n\nReturns:\n    Angle a so that matrix = [v,w] with v and w rotations of a about some axis.\n\nRaises:\n    ValueError: if ``matrix`` is not an SO(3)-matrix.",
        "api_signature": "_solve_decomposition_angle(matrix)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/commutator_decompose.py"
    },
    {
        "api_name": "objective",
        "full_api_name": "objective",
        "api_description": "",
        "api_signature": "objective(phi)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/commutator_decompose.py"
    },
    {
        "api_name": "_compute_rotation_from_angle_and_axis",
        "full_api_name": "_compute_rotation_from_angle_and_axis",
        "api_description": "Computes the SO(3)-matrix corresponding to the rotation of ``angle`` about ``axis``.\n\nArgs:\n    angle: The angle of the rotation.\n    axis: The axis of the rotation.\n\nReturns:\n    SO(3)-matrix that represents a rotation of ``angle`` about ``axis``.\n\nRaises:\n    ValueError: if ``axis`` is not a 3-dim unit vector.",
        "api_signature": "_compute_rotation_from_angle_and_axis(angle, axis)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/commutator_decompose.py"
    },
    {
        "api_name": "_compute_rotation_between",
        "full_api_name": "_compute_rotation_between",
        "api_description": "Computes the SO(3)-matrix for rotating ``from_vector`` to ``to_vector``.\n\nArgs:\n    from_vector: unit vector of size 3\n    to_vector: unit vector of size 3\n\nReturns:\n    SO(3)-matrix that brings ``from_vector`` to ``to_vector``.\n\nRaises:\n    ValueError: if at least one of ``from_vector`` of ``to_vector`` is not a 3-dim unit vector.",
        "api_signature": "_compute_rotation_between(from_vector, to_vector)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/commutator_decompose.py"
    },
    {
        "api_name": "_cross_product_matrix",
        "full_api_name": "_cross_product_matrix",
        "api_description": "Computes cross product matrix from vector.\n\nArgs:\n    v: Vector for which cross product matrix needs to be computed.\n\nReturns:\n    The cross product matrix corresponding to vector ``v``.",
        "api_signature": "_cross_product_matrix(v)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/commutator_decompose.py"
    },
    {
        "api_name": "_compute_commutator_so3",
        "full_api_name": "_compute_commutator_so3",
        "api_description": "Computes the commutator of the SO(3)-matrices ``a`` and ``b``.\n\nThe computation uses the fact that the inverse of an SO(3)-matrix is equal to its transpose.\n\nArgs:\n    a: SO(3)-matrix\n    b: SO(3)-matrix\n\nReturns:\n    The commutator [a,b] of ``a`` and ``b`` w\n\nRaises:\n    ValueError: if at least one of ``a`` or ``b`` is not an SO(3)-matrix.",
        "api_signature": "_compute_commutator_so3(a, b)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/commutator_decompose.py"
    },
    {
        "api_name": "commutator_decompose",
        "full_api_name": "commutator_decompose",
        "api_description": "Decompose an :math:`SO(3)`-matrix, :math:`U` as a balanced commutator.\n\nThis function finds two :math:`SO(3)` matrices :math:`V, W` such that the input matrix\nequals\n\n.. math::\n\n    U = V^\\dagger W^\\dagger V W.\n\nFor this decomposition, the following statement holds\n\n\n.. math::\n\n    ||V - I||_F, ||W - I||_F \\leq \\frac{\\sqrt{||U - I||_F}}{2},\n\nwhere :math:`I` is the identity and :math:`||\\cdot ||_F` is the Frobenius norm.\n\nArgs:\n    u_so3: SO(3)-matrix that needs to be decomposed as balanced commutator.\n    check_input: If True, checks whether the input matrix is actually SO(3).\n\nReturns:\n    Tuple of GateSequences from SO(3)-matrices :math:`V, W`.\n\nRaises:\n    ValueError: if ``u_so3`` is not an SO(3)-matrix.",
        "api_signature": "commutator_decompose(u_so3, check_input)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/commutator_decompose.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SolovayKitaevDecomposition.__init__",
        "api_description": "Args:\n    basic_approximations: A specification of the basic SU(2) approximations in terms\n        of discrete gates. At each iteration this algorithm, the remaining error is\n        approximated with the closest sequence of gates in this set.\n        If a ``str``, this specifies a ``.npy`` filename from which to load the\n        approximation. If a ``dict``, then this contains\n        ``{gates: effective_SO3_matrix}`` pairs,\n        e.g. ``{\"h t\": np.array([[0, 0.7071, -0.7071], [0, -0.7071, -0.7071], [-1, 0, 0]]}``.\n        If a list, this contains the same information as the dict, but already converted to\n        :class:`.GateSequence` objects, which contain the SO(3) matrix and gates.",
        "api_signature": "__init__(self, basic_approximations)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/solovay_kitaev.py"
    },
    {
        "api_name": "load_basic_approximations",
        "full_api_name": "SolovayKitaevDecomposition.load_basic_approximations",
        "api_description": "Load basic approximations.\n\nArgs:\n    data: If a string, specifies the path to the file from where to load the data.\n        If a dictionary, directly specifies the decompositions as ``{gates: matrix}``.\n        There ``gates`` are the names of the gates producing the SO(3) matrix ``matrix``,\n        e.g. ``{\"h t\": np.array([[0, 0.7071, -0.7071], [0, -0.7071, -0.7071], [-1, 0, 0]]}``.\n\nReturns:\n    A list of basic approximations as type ``GateSequence``.\n\nRaises:\n    ValueError: If the number of gate combinations and associated matrices does not match.",
        "api_signature": "load_basic_approximations(self, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/solovay_kitaev.py"
    },
    {
        "api_name": "run",
        "full_api_name": "SolovayKitaevDecomposition.run",
        "api_description": "Run the algorithm.\n\nArgs:\n    gate_matrix: The 2x2 matrix representing the gate. This matrix has to be SU(2)\n        up to global phase.\n    recursion_degree: The recursion degree, called :math:`n` in the paper.\n    return_dag: If ``True`` return a :class:`.DAGCircuit`, else a :class:`.QuantumCircuit`.\n    check_input: If ``True`` check that the input matrix is valid for the decomposition.\n\nReturns:\n    A one-qubit circuit approximating the ``gate_matrix`` in the specified discrete basis.",
        "api_signature": "run(self, gate_matrix, recursion_degree, return_dag, check_input)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/solovay_kitaev.py"
    },
    {
        "api_name": "_recurse",
        "full_api_name": "SolovayKitaevDecomposition._recurse",
        "api_description": "Performs ``n`` iterations of the Solovay-Kitaev algorithm on ``sequence``.\n\nArgs:\n    sequence: ``GateSequence`` to which the Solovay-Kitaev algorithm is applied.\n    n: The number of iterations that the algorithm needs to run.\n    check_input: If ``True`` check that the input matrix represented by ``GateSequence``\n        is valid for the decomposition.\n\nReturns:\n    GateSequence that approximates ``sequence``.\n\nRaises:\n    ValueError: If the matrix in ``GateSequence`` does not represent an SO(3)-matrix.",
        "api_signature": "_recurse(self, sequence, n, check_input)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/solovay_kitaev.py"
    },
    {
        "api_name": "find_basic_approximation",
        "full_api_name": "SolovayKitaevDecomposition.find_basic_approximation",
        "api_description": "Finds gate in ``self._basic_approximations`` that best represents ``sequence``.\n\nArgs:\n    sequence: The gate to find the approximation to.\n\nReturns:\n    Gate in basic approximations that is closest to ``sequence``.",
        "api_signature": "find_basic_approximation(self, sequence)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/solovay_kitaev.py"
    },
    {
        "api_name": "key",
        "full_api_name": "SolovayKitaevDecomposition.key",
        "api_description": "",
        "api_signature": "key(x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/solovay_kitaev.py"
    },
    {
        "api_name": "_remove_inverse_follows_gate",
        "full_api_name": "_remove_inverse_follows_gate",
        "api_description": "",
        "api_signature": "_remove_inverse_follows_gate(sequence)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/solovay_kitaev.py"
    },
    {
        "api_name": "_remove_identities",
        "full_api_name": "_remove_identities",
        "api_description": "",
        "api_signature": "_remove_identities(sequence)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/solovay_kitaev.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "GateSequence.__init__",
        "api_description": "Create a new sequence of gates.\n\nArgs:\n    gates: The gates in the sequence. The default is [].",
        "api_signature": "__init__(self, gates)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/gate_sequence.py"
    },
    {
        "api_name": "remove_cancelling_pair",
        "full_api_name": "GateSequence.remove_cancelling_pair",
        "api_description": "Remove a pair of indices that cancel each other and *do not* change the matrices.",
        "api_signature": "remove_cancelling_pair(self, indices)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/gate_sequence.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "GateSequence.__eq__",
        "api_description": "Check if this GateSequence is the same as the other GateSequence.\n\nArgs:\n    other: The GateSequence that will be compared to ``self``.\n\nReturns:\n    True if ``other`` is equivalent to ``self``, false otherwise.",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/gate_sequence.py"
    },
    {
        "api_name": "to_circuit",
        "full_api_name": "GateSequence.to_circuit",
        "api_description": "Convert to a circuit.\n\nIf no gates set but the product is not the identity, returns a circuit with a\nunitary operation to implement the matrix.",
        "api_signature": "to_circuit(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/gate_sequence.py"
    },
    {
        "api_name": "to_dag",
        "full_api_name": "GateSequence.to_dag",
        "api_description": "Convert to a :class:`.DAGCircuit`.\n\nIf no gates set but the product is not the identity, returns a circuit with a\nunitary operation to implement the matrix.",
        "api_signature": "to_dag(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/gate_sequence.py"
    },
    {
        "api_name": "append",
        "full_api_name": "GateSequence.append",
        "api_description": "Append gate to the sequence of gates.\n\nArgs:\n    gate: The gate to be appended.\n\nReturns:\n    GateSequence with ``gate`` appended.",
        "api_signature": "append(self, gate)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/gate_sequence.py"
    },
    {
        "api_name": "adjoint",
        "full_api_name": "GateSequence.adjoint",
        "api_description": "Get the complex conjugate.",
        "api_signature": "adjoint(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/gate_sequence.py"
    },
    {
        "api_name": "copy",
        "full_api_name": "GateSequence.copy",
        "api_description": "Create copy of the sequence of gates.\n\nReturns:\n    A new ``GateSequence`` containing copy of list of gates.",
        "api_signature": "copy(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/gate_sequence.py"
    },
    {
        "api_name": "__len__",
        "full_api_name": "GateSequence.__len__",
        "api_description": "Return length of sequence of gates.\n\nReturns:\n    Length of list containing gates.",
        "api_signature": "__len__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/gate_sequence.py"
    },
    {
        "api_name": "__getitem__",
        "full_api_name": "GateSequence.__getitem__",
        "api_description": "Returns the gate at ``index`` from the list of gates.\n\nArgs\n    index: Index of gate in list that will be returned.\n\nReturns:\n    The gate at ``index`` in the list of gates.",
        "api_signature": "__getitem__(self, index)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/gate_sequence.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "GateSequence.__repr__",
        "api_description": "Return string representation of this object.\n\nReturns:\n    Representation of this sequence of gates.",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/gate_sequence.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "GateSequence.__str__",
        "api_description": "Return string representation of this object.\n\nReturns:\n    Representation of this sequence of gates.",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/gate_sequence.py"
    },
    {
        "api_name": "from_matrix",
        "full_api_name": "GateSequence.from_matrix",
        "api_description": "Initialize the gate sequence from a matrix, without a gate sequence.\n\nArgs:\n    matrix: The matrix, can be SU(2) or SO(3).\n\nReturns:\n    A ``GateSequence`` initialized from the input matrix.\n\nRaises:\n    ValueError: If the matrix has an invalid shape.",
        "api_signature": "from_matrix(cls, matrix)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/gate_sequence.py"
    },
    {
        "api_name": "dot",
        "full_api_name": "GateSequence.dot",
        "api_description": "Compute the dot-product with another gate sequence.\n\nArgs:\n    other: The other gate sequence.\n\nReturns:\n    The dot-product as gate sequence.",
        "api_signature": "dot(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/gate_sequence.py"
    },
    {
        "api_name": "_convert_u2_to_su2",
        "full_api_name": "_convert_u2_to_su2",
        "api_description": "Convert a U(2) matrix to SU(2) by adding a global phase.",
        "api_signature": "_convert_u2_to_su2(u2_matrix)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/gate_sequence.py"
    },
    {
        "api_name": "_compute_euler_angles_from_so3",
        "full_api_name": "_compute_euler_angles_from_so3",
        "api_description": "Computes the Euler angles from the SO(3)-matrix u.\n\nUses the algorithm from Gregory Slabaugh,\nsee `here <https://www.gregslabaugh.net/publications/euler.pdf>`_.\n\nArgs:\n    matrix: The SO(3)-matrix for which the Euler angles need to be computed.\n\nReturns:\n    Tuple (phi, theta, psi), where phi is rotation about z-axis, theta rotation about y-axis\n    and psi rotation about x-axis.",
        "api_signature": "_compute_euler_angles_from_so3(matrix)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/gate_sequence.py"
    },
    {
        "api_name": "_compute_su2_from_euler_angles",
        "full_api_name": "_compute_su2_from_euler_angles",
        "api_description": "Computes SU(2)-matrix from Euler angles.\n\nArgs:\n    angles: The tuple containing the Euler angles for which the corresponding SU(2)-matrix\n        needs to be computed.\n\nReturns:\n    The SU(2)-matrix corresponding to the Euler angles in angles.",
        "api_signature": "_compute_su2_from_euler_angles(angles)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/gate_sequence.py"
    },
    {
        "api_name": "_convert_su2_to_so3",
        "full_api_name": "_convert_su2_to_so3",
        "api_description": "Computes SO(3)-matrix from input SU(2)-matrix.\n\nArgs:\n    matrix: The SU(2)-matrix for which a corresponding SO(3)-matrix needs to be computed.\n\nReturns:\n    The SO(3)-matrix corresponding to ``matrix``.\n\nRaises:\n    ValueError: if ``matrix`` is not an SU(2)-matrix.",
        "api_signature": "_convert_su2_to_so3(matrix)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/gate_sequence.py"
    },
    {
        "api_name": "_convert_so3_to_su2",
        "full_api_name": "_convert_so3_to_su2",
        "api_description": "Converts an SO(3)-matrix to a corresponding SU(2)-matrix.\n\nArgs:\n    matrix: SO(3)-matrix to convert.\n\nReturns:\n    SU(2)-matrix corresponding to SO(3)-matrix ``matrix``.\n\nRaises:\n    ValueError: if ``matrix`` is not an SO(3)-matrix.",
        "api_signature": "_convert_so3_to_su2(matrix)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/gate_sequence.py"
    },
    {
        "api_name": "_check_is_su2",
        "full_api_name": "_check_is_su2",
        "api_description": "Check whether ``matrix`` is SU(2), otherwise raise an error.",
        "api_signature": "_check_is_su2(matrix)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/gate_sequence.py"
    },
    {
        "api_name": "_check_is_so3",
        "full_api_name": "_check_is_so3",
        "api_description": "Check whether ``matrix`` is SO(3), otherwise raise an error.",
        "api_signature": "_check_is_so3(matrix)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/gate_sequence.py"
    },
    {
        "api_name": "_check_candidate",
        "full_api_name": "_check_candidate",
        "api_description": "",
        "api_signature": "_check_candidate(candidate, existing_sequences, tol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/generate_basis_approximations.py"
    },
    {
        "api_name": "_check_candidate_greedy",
        "full_api_name": "_check_candidate_greedy",
        "api_description": "",
        "api_signature": "_check_candidate_greedy(candidate, existing_sequences, tol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/generate_basis_approximations.py"
    },
    {
        "api_name": "_check_candidate_kdtree",
        "full_api_name": "_check_candidate_kdtree",
        "api_description": "Check if there's a candidate implementing the same matrix up to ``tol``.\n\nThis uses a k-d tree search and is much faster than the greedy, list-based search.",
        "api_signature": "_check_candidate_kdtree(candidate, existing_sequences, tol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/generate_basis_approximations.py"
    },
    {
        "api_name": "_process_node",
        "full_api_name": "_process_node",
        "api_description": "",
        "api_signature": "_process_node(node, basis, sequences)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/generate_basis_approximations.py"
    },
    {
        "api_name": "generate_basic_approximations",
        "full_api_name": "generate_basic_approximations",
        "api_description": "Generates a list of ``GateSequence``s with the gates in ``basic_gates``.\n\nArgs:\n    basis_gates: The gates from which to create the sequences of gates.\n    depth: The maximum depth of the approximations.\n    filename: If provided, the basic approximations are stored in this file.\n\nReturns:\n    List of ``GateSequences`` using the gates in ``basic_gates``.\n\nRaises:\n    ValueError: If ``basis_gates`` contains an invalid gate identifier.",
        "api_signature": "generate_basic_approximations(basis_gates, depth, filename)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/generate_basis_approximations.py"
    },
    {
        "api_name": "_get_ordered_swap",
        "full_api_name": "_get_ordered_swap",
        "api_description": "Sorts the input permutation by iterating through the permutation list\nand putting each element to its correct position via a SWAP (if it's not\nat the correct position already). If ``n`` is the length of the input\npermutation, this requires at most ``n`` SWAPs.\n\nMore precisely, if the input permutation is a cycle of length ``m``,\nthen this creates a quantum circuit with ``m-1`` SWAPs (and of depth ``m-1``);\nif the input  permutation consists of several disjoint cycles, then each cycle\nis essentially treated independently.",
        "api_signature": "_get_ordered_swap(permutation_in)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/permutation/permutation_utils.py"
    },
    {
        "api_name": "_inverse_pattern",
        "full_api_name": "_inverse_pattern",
        "api_description": "Finds inverse of a permutation pattern.",
        "api_signature": "_inverse_pattern(pattern)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/permutation/permutation_utils.py"
    },
    {
        "api_name": "_pattern_to_cycles",
        "full_api_name": "_pattern_to_cycles",
        "api_description": "Given a permutation pattern, creates its disjoint cycle decomposition.",
        "api_signature": "_pattern_to_cycles(pattern)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/permutation/permutation_utils.py"
    },
    {
        "api_name": "_decompose_cycles",
        "full_api_name": "_decompose_cycles",
        "api_description": "Given a disjoint cycle decomposition, decomposes every cycle into a SWAP\ncircuit of depth 2.",
        "api_signature": "_decompose_cycles(cycles)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/permutation/permutation_utils.py"
    },
    {
        "api_name": "synth_permutation_depth_lnn_kms",
        "full_api_name": "synth_permutation_depth_lnn_kms",
        "api_description": "Synthesize a permutation circuit for a linear nearest-neighbor\narchitecture using the Kutin, Moulton, Smithline method.\n\nThis is the permutation synthesis algorithm from\nhttps://arxiv.org/abs/quant-ph/0701194, Chapter 6.\nIt synthesizes any permutation of n qubits over linear nearest-neighbor\narchitecture using SWAP gates with depth at most n and size at most\nn(n-1)/2 (where both depth and size are measured with respect to SWAPs).\n\nArgs:\n    pattern (Union[list[int], np.ndarray]): permutation pattern, describing\n        which qubits occupy the positions 0, 1, 2, etc. after applying the\n        permutation. That is, ``pattern[k] = m`` when the permutation maps\n        qubit ``m`` to position ``k``. As an example, the pattern ``[2, 4, 3, 0, 1]``\n        means that qubit ``2`` goes to position ``0``, qubit ``4`` goes to\n        position ``1``, etc.\n\nReturns:\n    QuantumCircuit: the synthesized quantum circuit.",
        "api_signature": "synth_permutation_depth_lnn_kms(pattern)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/permutation/permutation_lnn.py"
    },
    {
        "api_name": "_create_swap_layer",
        "full_api_name": "_create_swap_layer",
        "api_description": "Implements a single swap layer, consisting of conditional swaps between each\nneighboring couple. The starting_point is the first qubit to use (either 0 or 1\nfor even or odd layers respectively). Mutates both the quantum circuit ``qc``\nand the permutation pattern ``pattern``.",
        "api_signature": "_create_swap_layer(qc, pattern, starting_point)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/permutation/permutation_lnn.py"
    },
    {
        "api_name": "synth_permutation_basic",
        "full_api_name": "synth_permutation_basic",
        "api_description": "Synthesize a permutation circuit for a fully-connected\narchitecture using sorting.\n\nMore precisely, if the input permutation is a cycle of length ``m``,\nthen this creates a quantum circuit with ``m-1`` SWAPs (and of depth ``m-1``);\nif the input  permutation consists of several disjoint cycles, then each cycle\nis essentially treated independently.\n\nArgs:\n    pattern (Union[list[int], np.ndarray]): permutation pattern, describing\n        which qubits occupy the positions 0, 1, 2, etc. after applying the\n        permutation. That is, ``pattern[k] = m`` when the permutation maps\n        qubit ``m`` to position ``k``. As an example, the pattern ``[2, 4, 3, 0, 1]``\n        means that qubit ``2`` goes to position ``0``, qubit ``4`` goes to\n        position ``1``, etc.\n\nReturns:\n    QuantumCircuit: the synthesized quantum circuit.",
        "api_signature": "synth_permutation_basic(pattern)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/permutation/permutation_full.py"
    },
    {
        "api_name": "synth_permutation_acg",
        "full_api_name": "synth_permutation_acg",
        "api_description": "Synthesize a permutation circuit for a fully-connected\narchitecture using the Alon, Chung, Graham method.\n\nThis produces a quantum circuit of depth 2 (measured in the number of SWAPs).\n\nThis implementation is based on the Theorem 2 in the paper\n\"Routing Permutations on Graphs Via Matchings\" (1993),\navailable at https://www.cs.tau.ac.il/~nogaa/PDFS/r.pdf.\n\nArgs:\n    pattern (Union[list[int], np.ndarray]): permutation pattern, describing\n        which qubits occupy the positions 0, 1, 2, etc. after applying the\n        permutation. That is, ``pattern[k] = m`` when the permutation maps\n        qubit ``m`` to position ``k``. As an example, the pattern ``[2, 4, 3, 0, 1]``\n        means that qubit ``2`` goes to position ``0``, qubit ``4`` goes to\n        position ``1``, etc.\n\nReturns:\n    QuantumCircuit: the synthesized quantum circuit.",
        "api_signature": "synth_permutation_acg(pattern)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/permutation/permutation_full.py"
    },
    {
        "api_name": "synth_stabilizer_layers",
        "full_api_name": "synth_stabilizer_layers",
        "api_description": "Synthesis of a stabilizer state into layers.\n\nIt provides a similar decomposition to the synthesis described in Lemma 8 of Bravyi and Maslov,\nwithout the initial Hadamard-free sub-circuit which do not affect the stabilizer state.\n\nFor example, a 5-qubit stabilizer state is decomposed into the following layers:\n\n.. parsed-literal::\n         \u250c\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    q_0: \u25240    \u251c\u25240    \u251c\u25240    \u251c\u25240    \u251c\u25240       \u251c\n         \u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502        \u2502\n    q_1: \u25241    \u251c\u25241    \u251c\u25241    \u251c\u25241    \u251c\u25241       \u251c\n         \u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502        \u2502\n    q_2: \u25242 H2 \u251c\u25242 S1 \u251c\u25242 CZ \u251c\u25242 H1 \u251c\u25242 Pauli \u251c\n         \u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502        \u2502\n    q_3: \u25243    \u251c\u25243    \u251c\u25243    \u251c\u25243    \u251c\u25243       \u251c\n         \u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502        \u2502\n    q_4: \u25244    \u251c\u25244    \u251c\u25244    \u251c\u25244    \u251c\u25244       \u251c\n         \u2514\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nArgs:\n    stab (StabilizerState): a stabilizer state.\n    cz_synth_func (Callable): a function to decompose the CZ sub-circuit.\n        It gets as input a boolean symmetric matrix, and outputs a QuantumCircuit.\n    validate (Boolean): if True, validates the synthesis process.\n    cz_func_reverse_qubits (Boolean): True only if cz_synth_func is synth_cz_depth_line_mr,\n        since this function returns a circuit that reverts the order of qubits.\n\nReturn:\n    QuantumCircuit: a circuit implementation of the stabilizer state.\n\nRaises:\n    QiskitError: if the input is not a StabilizerState.\n\nReference:\n    1. S. Bravyi, D. Maslov, *Hadamard-free circuits expose the\n       structure of the Clifford group*,\n       `arXiv:2003.09412 [quant-ph] <https://arxiv.org/abs/2003.09412>`_",
        "api_signature": "synth_stabilizer_layers(stab, cz_synth_func, cz_func_reverse_qubits, validate)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/stabilizer/stabilizer_decompose.py"
    },
    {
        "api_name": "_calc_pauli_diff_stabilizer",
        "full_api_name": "_calc_pauli_diff_stabilizer",
        "api_description": "Given two Cliffords whose stabilizers differ by a Pauli, we find this Pauli.",
        "api_signature": "_calc_pauli_diff_stabilizer(cliff, cliff_target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/stabilizer/stabilizer_decompose.py"
    },
    {
        "api_name": "synth_stabilizer_depth_lnn",
        "full_api_name": "synth_stabilizer_depth_lnn",
        "api_description": "Synthesis of an n-qubit stabilizer state for linear-nearest neighbour connectivity,\nin 2-qubit depth 2*n+2 and two distinct CX layers, using CX and phase gates (S, Sdg or Z).\n\nArgs:\n    stab (StabilizerState): a stabilizer state.\n\nReturn:\n    QuantumCircuit: a circuit implementation of the stabilizer state.\n\nReference:\n    1. S. Bravyi, D. Maslov, *Hadamard-free circuits expose the\n       structure of the Clifford group*,\n       `arXiv:2003.09412 [quant-ph] <https://arxiv.org/abs/2003.09412>`_\n    2. Dmitri Maslov, Martin Roetteler,\n       *Shorter stabilizer circuits via Bruhat decomposition and quantum circuit transformations*,\n       `arXiv:1705.09176 <https://arxiv.org/abs/1705.09176>`_.",
        "api_signature": "synth_stabilizer_depth_lnn(stab)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/stabilizer/stabilizer_decompose.py"
    },
    {
        "api_name": "synthesize",
        "full_api_name": "EvolutionSynthesis.synthesize",
        "api_description": "Synthesize an ``qiskit.circuit.library.PauliEvolutionGate``.\n\nArgs:\n    evolution (PauliEvolutionGate): The evolution gate to synthesize.\n\nReturns:\n    QuantumCircuit: A circuit implementing the evolution.",
        "api_signature": "synthesize(self, evolution)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/evolution/evolution_synthesis.py"
    },
    {
        "api_name": "settings",
        "full_api_name": "EvolutionSynthesis.settings",
        "api_description": "Return the settings in a dictionary, which can be used to reconstruct the object.\n\nReturns:\n    A dictionary containing the settings of this product formula.\n\nRaises:\n    NotImplementedError: The interface does not implement this method.",
        "api_signature": "settings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/evolution/evolution_synthesis.py"
    },
    {
        "api_name": "synthesize",
        "full_api_name": "MatrixExponential.synthesize",
        "api_description": "",
        "api_signature": "synthesize(self, evolution)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/evolution/matrix_synthesis.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QDrift.__init__",
        "api_description": "Args:\n    reps: The number of times to repeat the Trotterization circuit.\n    insert_barriers: Whether to insert barriers between the atomic evolutions.\n    cx_structure: How to arrange the CX gates for the Pauli evolutions, can be\n        \"chain\", where next neighbor connections are used, or \"fountain\", where all\n        qubits are connected to one.\n    atomic_evolution: A function to construct the circuit for the evolution of single\n        Pauli string. Per default, a single Pauli evolution is decomposed in a CX chain\n        and a single qubit Z rotation.\n    seed: An optional seed for reproducibility of the random sampling process.",
        "api_signature": "__init__(self, reps, insert_barriers, cx_structure, atomic_evolution, seed)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/evolution/qdrift.py"
    },
    {
        "api_name": "synthesize",
        "full_api_name": "QDrift.synthesize",
        "api_description": "",
        "api_signature": "synthesize(self, evolution)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/evolution/qdrift.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ProductFormula.__init__",
        "api_description": "Args:\n    order: The order of the product formula.\n    reps: The number of time steps.\n    insert_barriers: Whether to insert barriers between the atomic evolutions.\n    cx_structure: How to arrange the CX gates for the Pauli evolutions, can be\n        \"chain\", where next neighbor connections are used, or \"fountain\", where all\n        qubits are connected to one.\n    atomic_evolution: A function to construct the circuit for the evolution of single\n        Pauli string. Per default, a single Pauli evolution is decomposed in a CX chain\n        and a single qubit Z rotation.",
        "api_signature": "__init__(self, order, reps, insert_barriers, cx_structure, atomic_evolution)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/evolution/product_formula.py"
    },
    {
        "api_name": "settings",
        "full_api_name": "ProductFormula.settings",
        "api_description": "Return the settings in a dictionary, which can be used to reconstruct the object.\n\nReturns:\n    A dictionary containing the settings of this product formula.\n\nRaises:\n    NotImplementedError: If a custom atomic evolution is set, which cannot be serialized.",
        "api_signature": "settings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/evolution/product_formula.py"
    },
    {
        "api_name": "evolve_pauli",
        "full_api_name": "evolve_pauli",
        "api_description": "Construct a circuit implementing the time evolution of a single Pauli string.\n\nFor a Pauli string :math:`P = \\{I, X, Y, Z\\}^{\\otimes n}` on :math:`n` qubits and an\nevolution time :math:`t`, the returned circuit implements the unitary operation\n\n.. math::\n\n    U(t) = e^{-itP}.\n\nSince only a single Pauli string is evolved the circuit decomposition is exact.\n\nArgs:\n    pauli: The Pauli to evolve.\n    time: The evolution time.\n    cx_structure: Determine the structure of CX gates, can be either \"chain\" for\n        next-neighbor connections or \"fountain\" to connect directly to the top qubit.\n    label: A label for the gate.\n\nReturns:\n    A quantum circuit implementing the time evolution of the Pauli.",
        "api_signature": "evolve_pauli(pauli, time, cx_structure, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/evolution/product_formula.py"
    },
    {
        "api_name": "_single_qubit_evolution",
        "full_api_name": "_single_qubit_evolution",
        "api_description": "",
        "api_signature": "_single_qubit_evolution(pauli, time)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/evolution/product_formula.py"
    },
    {
        "api_name": "_two_qubit_evolution",
        "full_api_name": "_two_qubit_evolution",
        "api_description": "",
        "api_signature": "_two_qubit_evolution(pauli, time, cx_structure)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/evolution/product_formula.py"
    },
    {
        "api_name": "_multi_qubit_evolution",
        "full_api_name": "_multi_qubit_evolution",
        "api_description": "",
        "api_signature": "_multi_qubit_evolution(pauli, time, cx_structure)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/evolution/product_formula.py"
    },
    {
        "api_name": "diagonalizing_clifford",
        "full_api_name": "diagonalizing_clifford",
        "api_description": "Get the clifford circuit to diagonalize the Pauli operator.\n\nArgs:\n    pauli: The Pauli to diagonalize.\n\nReturns:\n    A circuit to diagonalize.",
        "api_signature": "diagonalizing_clifford(pauli)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/evolution/product_formula.py"
    },
    {
        "api_name": "cnot_chain",
        "full_api_name": "cnot_chain",
        "api_description": "CX chain.\n\nFor example, for the Pauli with the label 'XYZIX'.\n\n.. parsed-literal::\n\n                   \u250c\u2500\u2500\u2500\u2510\n    q_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\n                   \u2514\u2500\u252c\u2500\u2518\n    q_1: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\n              \u250c\u2500\u2500\u2500\u2510  \u2502\n    q_2: \u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u25a0\u2500\u2500\n         \u250c\u2500\u2500\u2500\u2510\u2514\u2500\u252c\u2500\u2518\n    q_3: \u2524 X \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n         \u2514\u2500\u252c\u2500\u2518\n    q_4: \u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nArgs:\n    pauli: The Pauli for which to construct the CX chain.\n\nReturns:\n    A circuit implementing the CX chain.",
        "api_signature": "cnot_chain(pauli)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/evolution/product_formula.py"
    },
    {
        "api_name": "cnot_fountain",
        "full_api_name": "cnot_fountain",
        "api_description": "CX chain in the fountain shape.\n\nFor example, for the Pauli with the label 'XYZIX'.\n\n.. parsed-literal::\n\n         \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\n    q_0: \u2524 X \u251c\u2524 X \u251c\u2524 X \u251c\n         \u2514\u2500\u252c\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u252c\u2500\u2518\n    q_1: \u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\n           \u2502    \u2502    \u2502\n    q_2: \u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\n                \u2502    \u2502\n    q_3: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\n                     \u2502\n    q_4: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\n\nArgs:\n    pauli: The Pauli for which to construct the CX chain.\n\nReturns:\n    A circuit implementing the CX chain.",
        "api_signature": "cnot_fountain(pauli)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/evolution/product_formula.py"
    },
    {
        "api_name": "_default_atomic_evolution",
        "full_api_name": "_default_atomic_evolution",
        "api_description": "",
        "api_signature": "_default_atomic_evolution(operator, time, cx_structure)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/evolution/product_formula.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SuzukiTrotter.__init__",
        "api_description": "Args:\n    order: The order of the product formula.\n    reps: The number of time steps.\n    insert_barriers: Whether to insert barriers between the atomic evolutions.\n    cx_structure: How to arrange the CX gates for the Pauli evolutions, can be \"chain\",\n        where next neighbor connections are used, or \"fountain\", where all qubits are\n        connected to one.\n    atomic_evolution: A function to construct the circuit for the evolution of single\n        Pauli string. Per default, a single Pauli evolution is decomposed in a CX chain\n        and a single qubit Z rotation.\nRaises:\n    ValueError: If order is not even",
        "api_signature": "__init__(self, order, reps, insert_barriers, cx_structure, atomic_evolution)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/evolution/suzuki_trotter.py"
    },
    {
        "api_name": "synthesize",
        "full_api_name": "SuzukiTrotter.synthesize",
        "api_description": "",
        "api_signature": "synthesize(self, evolution)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/evolution/suzuki_trotter.py"
    },
    {
        "api_name": "_recurse",
        "full_api_name": "SuzukiTrotter._recurse",
        "api_description": "",
        "api_signature": "_recurse(order, time, pauli_list)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/evolution/suzuki_trotter.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "LieTrotter.__init__",
        "api_description": "Args:\n    reps: The number of time steps.\n    insert_barriers: Whether to insert barriers between the atomic evolutions.\n    cx_structure: How to arrange the CX gates for the Pauli evolutions, can be\n        \"chain\", where next neighbor connections are used, or \"fountain\", where all\n        qubits are connected to one.\n    atomic_evolution: A function to construct the circuit for the evolution of single\n        Pauli string. Per default, a single Pauli evolution is decomposed in a CX chain\n        and a single qubit Z rotation.",
        "api_signature": "__init__(self, reps, insert_barriers, cx_structure, atomic_evolution)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/evolution/lie_trotter.py"
    },
    {
        "api_name": "synthesize",
        "full_api_name": "LieTrotter.synthesize",
        "api_description": "",
        "api_signature": "synthesize(self, evolution)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/evolution/lie_trotter.py"
    },
    {
        "api_name": "settings",
        "full_api_name": "LieTrotter.settings",
        "api_description": "Return the settings in a dictionary, which can be used to reconstruct the object.\n\nReturns:\n    A dictionary containing the settings of this product formula.\n\nRaises:\n    NotImplementedError: If a custom atomic evolution is set, which cannot be serialized.",
        "api_signature": "settings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/evolution/lie_trotter.py"
    },
    {
        "api_name": "_append_cx_stage1",
        "full_api_name": "_append_cx_stage1",
        "api_description": "A single layer of CX gates.",
        "api_signature": "_append_cx_stage1(qc, n)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/linear_phase/cz_depth_lnn.py"
    },
    {
        "api_name": "_append_cx_stage2",
        "full_api_name": "_append_cx_stage2",
        "api_description": "A single layer of CX gates.",
        "api_signature": "_append_cx_stage2(qc, n)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/linear_phase/cz_depth_lnn.py"
    },
    {
        "api_name": "_odd_pattern1",
        "full_api_name": "_odd_pattern1",
        "api_description": "A pattern denoted by Pj in [1] for odd number of qubits:\n[n-2, n-4, n-4, ..., 3, 3, 1, 1, 0, 0, 2, 2, ..., n-3, n-3]",
        "api_signature": "_odd_pattern1(n)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/linear_phase/cz_depth_lnn.py"
    },
    {
        "api_name": "_odd_pattern2",
        "full_api_name": "_odd_pattern2",
        "api_description": "A pattern denoted by Pk in [1] for odd number of qubits:\n[2, 2, 4, 4, ..., n-1, n-1, n-2, n-2, n-4, n-4, ..., 5, 5, 3, 3, 1]",
        "api_signature": "_odd_pattern2(n)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/linear_phase/cz_depth_lnn.py"
    },
    {
        "api_name": "_even_pattern1",
        "full_api_name": "_even_pattern1",
        "api_description": "A pattern denoted by Pj in [1] for even number of qubits:\n[n-1, n-3, n-3, n-5, n-5, ..., 1, 1, 0, 0, 2, 2, ..., n-4, n-4, n-2]",
        "api_signature": "_even_pattern1(n)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/linear_phase/cz_depth_lnn.py"
    },
    {
        "api_name": "_even_pattern2",
        "full_api_name": "_even_pattern2",
        "api_description": "A pattern denoted by Pk in [1] for even number of qubits:\n[2, 2, 4, 4, ..., n-2, n-2, n-1, n-1, ..., 3, 3, 1, 1]",
        "api_signature": "_even_pattern2(n)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/linear_phase/cz_depth_lnn.py"
    },
    {
        "api_name": "_create_patterns",
        "full_api_name": "_create_patterns",
        "api_description": "Creating the patterns for the phase layers.",
        "api_signature": "_create_patterns(n)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/linear_phase/cz_depth_lnn.py"
    },
    {
        "api_name": "synth_cz_depth_line_mr",
        "full_api_name": "synth_cz_depth_line_mr",
        "api_description": "Synthesis of a CZ circuit for linear nearest neighbour (LNN) connectivity,\nbased on Maslov and Roetteler.\n\nNote that this method *reverts* the order of qubits in the circuit,\nand returns a circuit containing CX and phase (S, Sdg or Z) gates.\n\nArgs:\n    mat: an upper-diagonal matrix representing the CZ circuit.\n        mat[i][j]=1 for i<j represents a CZ(i,j) gate\n\nReturn:\n    QuantumCircuit: a circuit implementation of the CZ circuit of depth 2*n+2 for LNN connectivity.\n\nReference:\n    1. Dmitri Maslov, Martin Roetteler,\n       *Shorter stabilizer circuits via Bruhat decomposition and quantum circuit transformations*,\n       `arXiv:1705.09176 <https://arxiv.org/abs/1705.09176>`_.",
        "api_signature": "synth_cz_depth_line_mr(mat)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/linear_phase/cz_depth_lnn.py"
    },
    {
        "api_name": "synth_cnot_phase_aam",
        "full_api_name": "synth_cnot_phase_aam",
        "api_description": "This function is an implementation of the GraySynth algorithm of\nAmy, Azimadeh and Mosca.\n\nGraySynth is a heuristic algorithm from [1] for synthesizing small parity networks.\nIt is inspired by Gray codes. Given a set of binary strings S\n(called \"cnots\" bellow), the algorithm synthesizes a parity network for S by\nrepeatedly choosing an index i to expand and then effectively recursing on\nthe co-factors S_0 and S_1, consisting of the strings y in S,\nwith y_i = 0 or 1 respectively. As a subset S is recursively expanded,\nCNOT gates are applied so that a designated target bit contains the\n(partial) parity ksi_y(x) where y_i = 1 if and only if y'_i = 1 for all\ny' in S. If S is a singleton {y'}, then y = y', hence the target bit contains\nthe value ksi_y'(x) as desired.\n\nNotably, rather than uncomputing this sequence of CNOT gates when a subset S\nis finished being synthesized, the algorithm maintains the invariant\nthat the remaining parities to be computed are expressed over the current state\nof bits. This allows the algorithm to avoid the 'backtracking' inherent in\nuncomputing-based methods.\n\nThe algorithm is described in detail in section 4 of [1].\n\nArgs:\n    cnots (list[list]): a matrix whose columns are the parities to be synthesized\n        e.g.::\n\n            [[0, 1, 1, 1, 1, 1],\n             [1, 0, 0, 1, 1, 1],\n             [1, 0, 0, 1, 0, 0],\n             [0, 0, 1, 0, 1, 0]]\n\n        corresponds to::\n\n             x1^x2 + x0 + x0^x3 + x0^x1^x2 + x0^x1^x3 + x0^x1\n\n    angles (list): a list containing all the phase-shift gates which are\n        to be applied, in the same order as in \"cnots\". A number is\n        interpreted as the angle of p(angle), otherwise the elements\n        have to be 't', 'tdg', 's', 'sdg' or 'z'.\n\n    section_size (int): the size of every section, used in _lwr_cnot_synth(), in the\n        Patel\u2013Markov\u2013Hayes algorithm. section_size must be a factor of num_qubits.\n\nReturns:\n    QuantumCircuit: the decomposed quantum circuit.\n\nRaises:\n    QiskitError: when dimensions of cnots and angles don't align.\n\nReferences:\n    1. Matthew Amy, Parsiad Azimzadeh, and Michele Mosca.\n       *On the controlled-NOT complexity of controlled-NOT\u2013phase circuits.*,\n       Quantum Science and Technology 4.1 (2018): 015002.\n       `arXiv:1712.01859 <https://arxiv.org/abs/1712.01859>`_",
        "api_signature": "synth_cnot_phase_aam(cnots, angles, section_size)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/linear_phase/cnot_phase_synth.py"
    },
    {
        "api_name": "_remove_duplicates",
        "full_api_name": "_remove_duplicates",
        "api_description": "Remove duplicates in list\n\nArgs:\n    lists (list): a list which may contain duplicate elements.\n\nReturns:\n    list: a list which contains only unique elements.",
        "api_signature": "_remove_duplicates(lists)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/linear_phase/cnot_phase_synth.py"
    },
    {
        "api_name": "_initialize_phase_schedule",
        "full_api_name": "_initialize_phase_schedule",
        "api_description": "Given a CZ layer (represented as an n*n CZ matrix Mz)\nReturn a scheudle of phase gates implementing Mz in a SWAP-only netwrok\n(c.f. Alg 1, [2])",
        "api_signature": "_initialize_phase_schedule(mat_z)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/linear_phase/cx_cz_depth_lnn.py"
    },
    {
        "api_name": "_shuffle",
        "full_api_name": "_shuffle",
        "api_description": "Args:\n    labels : a list of indices\n    odd : a boolean indicating whether this layer is odd or even,\nShuffle the indices in labels by swapping adjacent elements\n(c.f. Fig.2, [2])",
        "api_signature": "_shuffle(labels, odd)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/linear_phase/cx_cz_depth_lnn.py"
    },
    {
        "api_name": "_make_seq",
        "full_api_name": "_make_seq",
        "api_description": "Given the width of the circuit n,\nReturn the labels of the boxes in order from left to right, top to bottom\n(c.f. Fig.2, [2])",
        "api_signature": "_make_seq(n)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/linear_phase/cx_cz_depth_lnn.py"
    },
    {
        "api_name": "_swap_plus",
        "full_api_name": "_swap_plus",
        "api_description": "Given CX instructions (c.f. Thm 7.1, [1]) and the labels of all boxes,\nReturn a list of labels of the boxes that is SWAP+ in descending order\n    * Assumes the instruction gives gates in the order from top to bottom,\n      from left to right\n    * SWAP+ is defined in section 3.A. of [2]. Note the northwest\n      diagonalization procedure of [1] consists exactly n layers of boxes,\n      each being either a SWAP or a SWAP+. That is, each northwest\n      diagonalization circuit can be uniquely represented by which of its\n      n(n-1)/2 boxes are SWAP+ and which are SWAP.",
        "api_signature": "_swap_plus(instructions, seq)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/linear_phase/cx_cz_depth_lnn.py"
    },
    {
        "api_name": "_update_phase_schedule",
        "full_api_name": "_update_phase_schedule",
        "api_description": "Given phase_schedule initialized to induce a CZ circuit in SWAP-only network and list of SWAP+ boxes\nUpdate phase_schedule for each SWAP+ according to Algorithm 2, [2]",
        "api_signature": "_update_phase_schedule(n, phase_schedule, swap_plus)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/linear_phase/cx_cz_depth_lnn.py"
    },
    {
        "api_name": "_apply_phase_to_nw_circuit",
        "full_api_name": "_apply_phase_to_nw_circuit",
        "api_description": "Given\n    Width of the circuit (int n)\n    A CZ circuit, represented by the n*n phase schedule phase_schedule\n    A CX circuit, represented by box-labels (seq) and whether the box is SWAP+ (swap_plus)\n        *   This circuit corresponds to the CX tranformation that tranforms a matrix to\n            a NW matrix (c.f. Prop.7.4, [1])\n        *   SWAP+ is defined in section 3.A. of [2].\n        *   As previously noted, the northwest diagonalization procedure of [1] consists\n            of exactly n layers of boxes, each being either a SWAP or a SWAP+. That is,\n            each northwest diagonalization circuit can be uniquely represented by which\n            of its n(n-1)/2 boxes are SWAP+ and which are SWAP.\nReturn a QuantumCircuit that computes the phase scheudle S inside CX",
        "api_signature": "_apply_phase_to_nw_circuit(n, phase_schedule, seq, swap_plus)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/linear_phase/cx_cz_depth_lnn.py"
    },
    {
        "api_name": "synth_cx_cz_depth_line_my",
        "full_api_name": "synth_cx_cz_depth_line_my",
        "api_description": "Joint synthesis of a -CZ-CX- circuit for linear nearest neighbour (LNN) connectivity,\nwith 2-qubit depth at most 5n, based on Maslov and Yang.\nThis method computes the CZ circuit inside the CX circuit via phase gate insertions.\n\nArgs:\n    mat_z : a boolean symmetric matrix representing a CZ circuit.\n        Mz[i][j]=1 represents a CZ(i,j) gate\n\n    mat_x : a boolean invertible matrix representing a CX circuit.\n\nReturn:\n    QuantumCircuit : a circuit implementation of a CX circuit following a CZ circuit,\n    denoted as a -CZ-CX- circuit,in two-qubit depth at most 5n, for LNN connectivity.\n\nReference:\n    1. Kutin, S., Moulton, D. P., Smithline, L.,\n       *Computation at a distance*, Chicago J. Theor. Comput. Sci., vol. 2007, (2007),\n       `arXiv:quant-ph/0701194 <https://arxiv.org/abs/quant-ph/0701194>`_\n    2. Dmitri Maslov, Willers Yang, *CNOT circuits need little help to implement arbitrary\n       Hadamard-free Clifford transformations they generate*,\n       `arXiv:2210.16195 <https://arxiv.org/abs/2210.16195>`_.",
        "api_signature": "synth_cx_cz_depth_line_my(mat_x, mat_z)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/linear_phase/cx_cz_depth_lnn.py"
    },
    {
        "api_name": "synth_cnotdihedral_general",
        "full_api_name": "synth_cnotdihedral_general",
        "api_description": "Decompose a CNOTDihedral element into a QuantumCircuit.\n\nDecompose a general CNOTDihedral elements.\nThe number of CNOT gates is not necessarily optimal.\nFor a decomposition of a 1-qubit or 2-qubit element, call\nsynth_cnotdihedral_two_qubits.\n\nArgs:\n    elem (CNOTDihedral): a CNOTDihedral element.\n\nReturn:\n    QuantumCircuit: a circuit implementation of the CNOTDihedral element.\n\nRaises:\n    QiskitError: if the element could not be decomposed into a circuit.\n\nReference:\n    1. Andrew W. Cross, Easwar Magesan, Lev S. Bishop, John A. Smolin and Jay M. Gambetta,\n       *Scalable randomised benchmarking of non-Clifford gates*,\n       npj Quantum Inf 2, 16012 (2016).",
        "api_signature": "synth_cnotdihedral_general(elem)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/cnotdihedral/cnotdihedral_decompose_general.py"
    },
    {
        "api_name": "synth_cnotdihedral_full",
        "full_api_name": "synth_cnotdihedral_full",
        "api_description": "Decompose a CNOTDihedral element into a QuantumCircuit.\nFor N <= 2 qubits this is based on optimal CX cost decomposition from reference [1].\nFor N > 2 qubits this is done using the general non-optimal compilation routine from reference [2].\n\nArgs:\n    elem (CNOTDihedral): a CNOTDihedral element.\nReturn:\n    QuantumCircuit: a circuit implementation of the CNOTDihedral element.\n\nReferences:\n    1. Shelly Garion and Andrew W. Cross, *Synthesis of CNOT-Dihedral circuits\n       with optimal number of two qubit gates*, `Quantum 4(369), 2020\n       <https://quantum-journal.org/papers/q-2020-12-07-369/>`_\n    2. Andrew W. Cross, Easwar Magesan, Lev S. Bishop, John A. Smolin and Jay M. Gambetta,\n       *Scalable randomised benchmarking of non-Clifford gates*,\n       npj Quantum Inf 2, 16012 (2016).",
        "api_signature": "synth_cnotdihedral_full(elem)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/cnotdihedral/cnotdihedral_decompose_full.py"
    },
    {
        "api_name": "synth_cnotdihedral_two_qubits",
        "full_api_name": "synth_cnotdihedral_two_qubits",
        "api_description": "Decompose a CNOTDihedral element on a single qubit and two qubits into a QuantumCircuit.\nThis decomposition has an optimal number of CX gates.\n\nArgs:\n    elem (CNOTDihedral): a CNOTDihedral element.\n\nReturn:\n    QuantumCircuit: a circuit implementation of the CNOTDihedral element.\n\nRaises:\n    QiskitError: if the element in not 1-qubit or 2-qubit CNOTDihedral.\n\nReference:\n    1. Shelly Garion and Andrew W. Cross, *On the structure of the CNOT-Dihedral group*,\n       `arXiv:2006.12042 [quant-ph] <https://arxiv.org/abs/2006.12042>`_",
        "api_signature": "synth_cnotdihedral_two_qubits(elem)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/cnotdihedral/cnotdihedral_decompose_two_qubits.py"
    },
    {
        "api_name": "synth_cnot_count_full_pmh",
        "full_api_name": "synth_cnot_count_full_pmh",
        "api_description": "Synthesize linear reversible circuits for all-to-all architecture\nusing Patel, Markov and Hayes method.\n\nThis function is an implementation of the Patel, Markov and Hayes algorithm from [1]\nfor optimal synthesis of linear reversible circuits for all-to-all architecture,\nas specified by an n x n matrix.\n\nArgs:\n    state (list[list] or ndarray): n x n boolean invertible matrix, describing the state\n        of the input circuit\n    section_size (int): the size of each section, used in the\n        Patel\u2013Markov\u2013Hayes algorithm [1]. section_size must be a factor of num_qubits.\n\nReturns:\n    QuantumCircuit: a CX-only circuit implementing the linear transformation.\n\nRaises:\n    QiskitError: when variable \"state\" isn't of type numpy.ndarray\n\nReferences:\n    1. Patel, Ketan N., Igor L. Markov, and John P. Hayes,\n       *Optimal synthesis of linear reversible circuits*,\n       Quantum Information & Computation 8.3 (2008): 282-294.\n       `arXiv:quant-ph/0302002 [quant-ph] <https://arxiv.org/abs/quant-ph/0302002>`_",
        "api_signature": "synth_cnot_count_full_pmh(state, section_size)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/linear/cnot_synth.py"
    },
    {
        "api_name": "_lwr_cnot_synth",
        "full_api_name": "_lwr_cnot_synth",
        "api_description": "This function is a helper function of the algorithm for optimal synthesis\nof linear reversible circuits (the Patel\u2013Markov\u2013Hayes algorithm). It works\nlike gaussian elimination, except that it works a lot faster, and requires\nfewer steps (and therefore fewer CNOTs). It takes the matrix \"state\" and\nsplits it into sections of size section_size. Then it eliminates all non-zero\nsub-rows within each section, which are the same as a non-zero sub-row\nabove. Once this has been done, it continues with normal gaussian elimination.\nThe benefit is that with small section sizes (m), most of the sub-rows will\nbe cleared in the first step, resulting in a factor m fewer row row operations\nduring Gaussian elimination.\n\nThe algorithm is described in detail in the following paper\n\"Optimal synthesis of linear reversible circuits.\"\nPatel, Ketan N., Igor L. Markov, and John P. Hayes.\nQuantum Information & Computation 8.3 (2008): 282-294.\n\nNote:\nThis implementation tweaks the Patel, Markov, and Hayes algorithm by adding\na \"back reduce\" which adds rows below the pivot row with a high degree of\noverlap back to it. The intuition is to avoid a high-weight pivot row\nincreasing the weight of lower rows.\n\nArgs:\n    state (ndarray): n x n matrix, describing a linear quantum circuit\n    section_size (int): the section size the matrix columns are divided into\n\nReturns:\n    numpy.matrix: n by n matrix, describing the state of the output circuit\n    list: a k by 2 list of C-NOT operations that need to be applied",
        "api_signature": "_lwr_cnot_synth(state, section_size)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/linear/cnot_synth.py"
    },
    {
        "api_name": "transpose_cx_circ",
        "full_api_name": "transpose_cx_circ",
        "api_description": "Takes a circuit having only CX gates, and calculates its transpose.\nThis is done by recursively replacing CX(i, j) with CX(j, i) in all instructions.\n\nArgs:\n    qc: a QuantumCircuit containing only CX gates.\n\nReturns:\n    QuantumCircuit: the transposed circuit.\n\nRaises:\n    CircuitError: if qc has a non-CX gate.",
        "api_signature": "transpose_cx_circ(qc)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/linear/linear_circuits_utils.py"
    },
    {
        "api_name": "optimize_cx_4_options",
        "full_api_name": "optimize_cx_4_options",
        "api_description": "Get the best implementation of a circuit implementing a binary invertible matrix M,\nby considering all four options: M,M^(-1),M^T,M^(-1)^T.\nOptimizing either the CX count or the depth.\n\nArgs:\n    function: the synthesis function.\n    mat: a binary invertible matrix.\n    optimize_count: True if the number of CX gates in optimize, False if the depth is optimized.\n\nReturns:\n    QuantumCircuit: an optimized QuantumCircuit, has the best depth or CX count of the four options.\n\nRaises:\n    QiskitError: if mat is not an invertible matrix.",
        "api_signature": "optimize_cx_4_options(function, mat, optimize_count)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/linear/linear_circuits_utils.py"
    },
    {
        "api_name": "check_lnn_connectivity",
        "full_api_name": "check_lnn_connectivity",
        "api_description": "Check that the synthesized circuit qc fits linear nearest neighbor connectivity.\n\nArgs:\n    qc: a QuantumCircuit containing only CX and single qubit gates.\n\nReturns:\n    bool: True if the circuit has linear nearest neighbor connectivity.\n\nRaises:\n    CircuitError: if qc has a non-CX two-qubit gate.",
        "api_signature": "check_lnn_connectivity(qc)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/linear/linear_circuits_utils.py"
    },
    {
        "api_name": "check_invertible_binary_matrix",
        "full_api_name": "check_invertible_binary_matrix",
        "api_description": "Check that a binary matrix is invertible.\n\nArgs:\n    mat: a binary matrix.\n\nReturns:\n    bool: True if mat in invertible and False otherwise.",
        "api_signature": "check_invertible_binary_matrix(mat)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/linear/linear_matrix_utils.py"
    },
    {
        "api_name": "random_invertible_binary_matrix",
        "full_api_name": "random_invertible_binary_matrix",
        "api_description": "Generates a random invertible n x n binary matrix.\n\nArgs:\n    num_qubits: the matrix size.\n    seed: a random seed.\n\nReturns:\n    np.ndarray: A random invertible binary matrix of size num_qubits.",
        "api_signature": "random_invertible_binary_matrix(num_qubits, seed)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/linear/linear_matrix_utils.py"
    },
    {
        "api_name": "_gauss_elimination",
        "full_api_name": "_gauss_elimination",
        "api_description": "Gauss elimination of a matrix mat with m rows and n columns.\nIf full_elim = True, it allows full elimination of mat[:, 0 : ncols]\nReturns the matrix mat.",
        "api_signature": "_gauss_elimination(mat, ncols, full_elim)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/linear/linear_matrix_utils.py"
    },
    {
        "api_name": "_gauss_elimination_with_perm",
        "full_api_name": "_gauss_elimination_with_perm",
        "api_description": "Gauss elimination of a matrix mat with m rows and n columns.\nIf full_elim = True, it allows full elimination of mat[:, 0 : ncols]\nReturns the matrix mat, and the permutation perm that was done on the rows during the process.\nperm[0 : rank] represents the indices of linearly independent rows in the original matrix.",
        "api_signature": "_gauss_elimination_with_perm(mat, ncols, full_elim)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/linear/linear_matrix_utils.py"
    },
    {
        "api_name": "calc_inverse_matrix",
        "full_api_name": "calc_inverse_matrix",
        "api_description": "Given a square numpy(dtype=int) matrix mat, tries to compute its inverse.\n\nArgs:\n    mat: a boolean square matrix.\n    verify: if True asserts that the multiplication of mat and its inverse is the identity matrix.\n\nReturns:\n    np.ndarray: the inverse matrix.\n\nRaises:\n     QiskitError: if the matrix is not square.\n     QiskitError: if the matrix is not invertible.",
        "api_signature": "calc_inverse_matrix(mat, verify)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/linear/linear_matrix_utils.py"
    },
    {
        "api_name": "_compute_rank_after_gauss_elim",
        "full_api_name": "_compute_rank_after_gauss_elim",
        "api_description": "Given a matrix A after Gaussian elimination, computes its rank\n(i.e. simply the number of nonzero rows)",
        "api_signature": "_compute_rank_after_gauss_elim(mat)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/linear/linear_matrix_utils.py"
    },
    {
        "api_name": "_compute_rank",
        "full_api_name": "_compute_rank",
        "api_description": "Given a matrix A computes its rank",
        "api_signature": "_compute_rank(mat)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/linear/linear_matrix_utils.py"
    },
    {
        "api_name": "_row_op",
        "full_api_name": "_row_op",
        "api_description": "",
        "api_signature": "_row_op(mat, ctrl, trgt)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/linear/linear_matrix_utils.py"
    },
    {
        "api_name": "_col_op",
        "full_api_name": "_col_op",
        "api_description": "",
        "api_signature": "_col_op(mat, ctrl, trgt)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/linear/linear_matrix_utils.py"
    },
    {
        "api_name": "_row_op_update_instructions",
        "full_api_name": "_row_op_update_instructions",
        "api_description": "",
        "api_signature": "_row_op_update_instructions(cx_instructions, mat, a, b)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/linear/linear_depth_lnn.py"
    },
    {
        "api_name": "_get_lower_triangular",
        "full_api_name": "_get_lower_triangular",
        "api_description": "",
        "api_signature": "_get_lower_triangular(n, mat, mat_inv)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/linear/linear_depth_lnn.py"
    },
    {
        "api_name": "_get_label_arr",
        "full_api_name": "_get_label_arr",
        "api_description": "",
        "api_signature": "_get_label_arr(n, mat_t)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/linear/linear_depth_lnn.py"
    },
    {
        "api_name": "_in_linear_combination",
        "full_api_name": "_in_linear_combination",
        "api_description": "",
        "api_signature": "_in_linear_combination(label_arr_t, mat_inv_t, row, k)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/linear/linear_depth_lnn.py"
    },
    {
        "api_name": "_get_label_arr_t",
        "full_api_name": "_get_label_arr_t",
        "api_description": "",
        "api_signature": "_get_label_arr_t(n, label_arr)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/linear/linear_depth_lnn.py"
    },
    {
        "api_name": "_matrix_to_north_west",
        "full_api_name": "_matrix_to_north_west",
        "api_description": "",
        "api_signature": "_matrix_to_north_west(n, mat, mat_inv)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/linear/linear_depth_lnn.py"
    },
    {
        "api_name": "_north_west_to_identity",
        "full_api_name": "_north_west_to_identity",
        "api_description": "",
        "api_signature": "_north_west_to_identity(n, mat)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/linear/linear_depth_lnn.py"
    },
    {
        "api_name": "_optimize_cx_circ_depth_5n_line",
        "full_api_name": "_optimize_cx_circ_depth_5n_line",
        "api_description": "",
        "api_signature": "_optimize_cx_circ_depth_5n_line(mat)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/linear/linear_depth_lnn.py"
    },
    {
        "api_name": "synth_cnot_depth_line_kms",
        "full_api_name": "synth_cnot_depth_line_kms",
        "api_description": "Synthesize linear reversible circuit for linear nearest-neighbor architectures using\nKutin, Moulton, Smithline method.\n\nSynthesis algorithm for linear reversible circuits from [1], Chapter 7.\nSynthesizes any linear reversible circuit of n qubits over linear nearest-neighbor\narchitecture using CX gates with depth at most 5*n.\n\nArgs:\n    mat(np.ndarray]): A boolean invertible matrix.\n\nReturns:\n    QuantumCircuit: the synthesized quantum circuit.\n\nRaises:\n    QiskitError: if mat is not invertible.\n\nReferences:\n    1. Kutin, S., Moulton, D. P., Smithline, L.,\n       *Computation at a distance*, Chicago J. Theor. Comput. Sci., vol. 2007, (2007),\n       `arXiv:quant-ph/0701194 <https://arxiv.org/abs/quant-ph/0701194>`_",
        "api_signature": "synth_cnot_depth_line_kms(mat)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/linear/linear_depth_lnn.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BackendV1.__init__",
        "api_description": "Initialize a backend class\n\nArgs:\n    configuration (BackendConfiguration): A backend configuration\n        object for the backend object.\n    provider (qiskit.providers.Provider): Optionally, the provider\n        object that this Backend comes from.\n    fields: kwargs for the values to use to override the default\n        options.\nRaises:\n    AttributeError: if input field not a valid options\n\n..\n    This next bit is necessary just because autosummary generally won't summarise private\n    methods; changing that behaviour would have annoying knock-on effects through all the\n    rest of the documentation, so instead we just hard-code the automethod directive.\n\nIn addition to the public abstract methods, subclasses should also implement the following\nprivate methods:\n\n.. automethod:: _default_options\n   :noindex:",
        "api_signature": "__init__(self, configuration, provider)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend.py"
    },
    {
        "api_name": "_default_options",
        "full_api_name": "BackendV1._default_options",
        "api_description": "Return the default options\n\nThis method will return a :class:`qiskit.providers.Options`\nsubclass object that will be used for the default options. These\nshould be the default parameters to use for the options of the\nbackend.\n\nReturns:\n    qiskit.providers.Options: A options object with\n        default values set",
        "api_signature": "_default_options(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend.py"
    },
    {
        "api_name": "set_options",
        "full_api_name": "BackendV1.set_options",
        "api_description": "Set the options fields for the backend\n\nThis method is used to update the options of a backend. If\nyou need to change any of the options prior to running just\npass in the kwarg with the new value for the options.\n\nArgs:\n    fields: The fields to update the options\n\nRaises:\n    AttributeError: If the field passed in is not part of the\n        options",
        "api_signature": "set_options(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend.py"
    },
    {
        "api_name": "configuration",
        "full_api_name": "BackendV1.configuration",
        "api_description": "Return the backend configuration.\n\nReturns:\n    BackendConfiguration: the configuration for the backend.",
        "api_signature": "configuration(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend.py"
    },
    {
        "api_name": "properties",
        "full_api_name": "BackendV1.properties",
        "api_description": "Return the backend properties.\n\nReturns:\n    BackendProperties: the configuration for the backend. If the backend\n    does not support properties, it returns ``None``.",
        "api_signature": "properties(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend.py"
    },
    {
        "api_name": "provider",
        "full_api_name": "BackendV1.provider",
        "api_description": "Return the backend Provider.\n\nReturns:\n    Provider: the Provider responsible for the backend.",
        "api_signature": "provider(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend.py"
    },
    {
        "api_name": "status",
        "full_api_name": "BackendV1.status",
        "api_description": "Return the backend status.\n\nReturns:\n    BackendStatus: the status of the backend.",
        "api_signature": "status(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend.py"
    },
    {
        "api_name": "name",
        "full_api_name": "BackendV1.name",
        "api_description": "Return the backend name.\n\nReturns:\n    str: the name of the backend.",
        "api_signature": "name(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "BackendV1.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "BackendV1.__repr__",
        "api_description": "Official string representation of a Backend.\n\nNote that, by Qiskit convention, it is consciously *not* a fully valid\nPython expression. Subclasses should provide 'a string of the form\n<...some useful description...>'. [0]\n\n[0] https://docs.python.org/3/reference/datamodel.html#object.__repr__",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend.py"
    },
    {
        "api_name": "options",
        "full_api_name": "BackendV1.options",
        "api_description": "Return the options for the backend\n\nThe options of a backend are the dynamic parameters defining\nhow the backend is used. These are used to control the :meth:`run`\nmethod.",
        "api_signature": "options(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend.py"
    },
    {
        "api_name": "run",
        "full_api_name": "BackendV1.run",
        "api_description": "Run on the backend.\n\nThis method returns a :class:`~qiskit.providers.Job` object\nthat runs circuits. Depending on the backend this may be either an async\nor sync call. It is at the discretion of the provider to decide whether\nrunning should block until the execution is finished or not: the Job\nclass can handle either situation.\n\nArgs:\n    run_input (QuantumCircuit or Schedule or list): An individual or a\n        list of :class:`~qiskit.circuit.QuantumCircuit` or\n        :class:`~qiskit.pulse.Schedule` objects to run on the backend.\n        For legacy providers migrating to the new versioned providers,\n        provider interface a :class:`~qiskit.qobj.QasmQobj` or\n        :class:`~qiskit.qobj.PulseQobj` objects should probably be\n        supported too (but deprecated) for backwards compatibility. Be\n        sure to update the docstrings of subclasses implementing this\n        method to document that. New provider implementations should not\n        do this though as :mod:`qiskit.qobj` will be deprecated and\n        removed along with the legacy providers interface.\n    options: Any kwarg options to pass to the backend for running the\n        config. If a key is also present in the options\n        attribute/object then the expectation is that the value\n        specified will be used instead of what's set in the options\n        object.\nReturns:\n    Job: The job object for the run",
        "api_signature": "run(self, run_input)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QubitProperties.__init__",
        "api_description": "Create a new :class:`QubitProperties` object.\n\nArgs:\n    t1: The T1 time for a qubit in seconds\n    t2: The T2 time for a qubit in seconds\n    frequency: The frequency of a qubit in Hz",
        "api_signature": "__init__(self, t1, t2, frequency)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "QubitProperties.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BackendV2.__init__",
        "api_description": "Initialize a BackendV2 based backend\n\nArgs:\n    provider: An optional backwards reference to the\n        :class:`~qiskit.providers.Provider` object that the backend\n        is from\n    name: An optional name for the backend\n    description: An optional description of the backend\n    online_date: An optional datetime the backend was brought online\n    backend_version: An optional backend version string. This differs\n        from the :attr:`~qiskit.providers.BackendV2.version` attribute\n        as :attr:`~qiskit.providers.BackendV2.version` is for the\n        abstract :attr:`~qiskit.providers.Backend` abstract interface\n        version of the object while ``backend_version`` is for\n        versioning the backend itself.\n    fields: kwargs for the values to use to override the default\n        options.\n\nRaises:\n    AttributeError: If a field is specified that's outside the backend's\n        options",
        "api_signature": "__init__(self, provider, name, description, online_date, backend_version)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend.py"
    },
    {
        "api_name": "instructions",
        "full_api_name": "BackendV2.instructions",
        "api_description": "A list of Instruction tuples on the backend of the form ``(instruction, (qubits)``",
        "api_signature": "instructions(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend.py"
    },
    {
        "api_name": "operations",
        "full_api_name": "BackendV2.operations",
        "api_description": "A list of :class:`~qiskit.circuit.Instruction` instances that the backend supports.",
        "api_signature": "operations(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend.py"
    },
    {
        "api_name": "operation_names",
        "full_api_name": "BackendV2.operation_names",
        "api_description": "A list of instruction names that the backend supports.",
        "api_signature": "operation_names(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend.py"
    },
    {
        "api_name": "target",
        "full_api_name": "BackendV2.target",
        "api_description": "A :class:`qiskit.transpiler.Target` object for the backend.\n\n:rtype: Target",
        "api_signature": "target(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend.py"
    },
    {
        "api_name": "num_qubits",
        "full_api_name": "BackendV2.num_qubits",
        "api_description": "Return the number of qubits the backend has.",
        "api_signature": "num_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend.py"
    },
    {
        "api_name": "coupling_map",
        "full_api_name": "BackendV2.coupling_map",
        "api_description": "Return the :class:`~qiskit.transpiler.CouplingMap` object",
        "api_signature": "coupling_map(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend.py"
    },
    {
        "api_name": "instruction_durations",
        "full_api_name": "BackendV2.instruction_durations",
        "api_description": "Return the :class:`~qiskit.transpiler.InstructionDurations` object.",
        "api_signature": "instruction_durations(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend.py"
    },
    {
        "api_name": "max_circuits",
        "full_api_name": "BackendV2.max_circuits",
        "api_description": "The maximum number of circuits (or Pulse schedules) that can be\nrun in a single job.\n\nIf there is no limit this will return None",
        "api_signature": "max_circuits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend.py"
    },
    {
        "api_name": "_default_options",
        "full_api_name": "BackendV2._default_options",
        "api_description": "Return the default options\n\nThis method will return a :class:`qiskit.providers.Options`\nsubclass object that will be used for the default options. These\nshould be the default parameters to use for the options of the\nbackend.\n\nReturns:\n    qiskit.providers.Options: A options object with\n        default values set",
        "api_signature": "_default_options(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend.py"
    },
    {
        "api_name": "dt",
        "full_api_name": "BackendV2.dt",
        "api_description": "Return the system time resolution of input signals\n\nThis is required to be implemented if the backend supports Pulse\nscheduling.\n\nReturns:\n    The input signal timestep in seconds. If the backend doesn't define ``dt``, ``None`` will\n    be returned.",
        "api_signature": "dt(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend.py"
    },
    {
        "api_name": "dtm",
        "full_api_name": "BackendV2.dtm",
        "api_description": "Return the system time resolution of output signals\n\nReturns:\n    The output signal timestep in seconds.\n\nRaises:\n    NotImplementedError: if the backend doesn't support querying the\n        output signal timestep",
        "api_signature": "dtm(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend.py"
    },
    {
        "api_name": "meas_map",
        "full_api_name": "BackendV2.meas_map",
        "api_description": "Return the grouping of measurements which are multiplexed\n\nThis is required to be implemented if the backend supports Pulse\nscheduling.\n\nReturns:\n    The grouping of measurements which are multiplexed\n\nRaises:\n    NotImplementedError: if the backend doesn't support querying the\n        measurement mapping",
        "api_signature": "meas_map(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend.py"
    },
    {
        "api_name": "instruction_schedule_map",
        "full_api_name": "BackendV2.instruction_schedule_map",
        "api_description": "Return the :class:`~qiskit.pulse.InstructionScheduleMap` for the\ninstructions defined in this backend's target.",
        "api_signature": "instruction_schedule_map(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend.py"
    },
    {
        "api_name": "qubit_properties",
        "full_api_name": "BackendV2.qubit_properties",
        "api_description": "Return QubitProperties for a given qubit.\n\nIf there are no defined or the backend doesn't support querying these\ndetails this method does not need to be implemented.\n\nArgs:\n    qubit: The qubit to get the\n        :class:`.QubitProperties` object for. This can\n        be a single integer for 1 qubit or a list of qubits and a list\n        of :class:`.QubitProperties` objects will be\n        returned in the same order\nReturns:\n    The :class:`~.QubitProperties` object for the\n    specified qubit. If a list of qubits is provided a list will be\n    returned. If properties are missing for a qubit this can be\n    ``None``.\n\nRaises:\n    NotImplementedError: if the backend doesn't support querying the\n        qubit properties",
        "api_signature": "qubit_properties(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend.py"
    },
    {
        "api_name": "drive_channel",
        "full_api_name": "BackendV2.drive_channel",
        "api_description": "Return the drive channel for the given qubit.\n\nThis is required to be implemented if the backend supports Pulse\nscheduling.\n\nReturns:\n    DriveChannel: The Qubit drive channel\n\nRaises:\n    NotImplementedError: if the backend doesn't support querying the\n        measurement mapping",
        "api_signature": "drive_channel(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend.py"
    },
    {
        "api_name": "measure_channel",
        "full_api_name": "BackendV2.measure_channel",
        "api_description": "Return the measure stimulus channel for the given qubit.\n\nThis is required to be implemented if the backend supports Pulse\nscheduling.\n\nReturns:\n    MeasureChannel: The Qubit measurement stimulus line\n\nRaises:\n    NotImplementedError: if the backend doesn't support querying the\n        measurement mapping",
        "api_signature": "measure_channel(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend.py"
    },
    {
        "api_name": "acquire_channel",
        "full_api_name": "BackendV2.acquire_channel",
        "api_description": "Return the acquisition channel for the given qubit.\n\nThis is required to be implemented if the backend supports Pulse\nscheduling.\n\nReturns:\n    AcquireChannel: The Qubit measurement acquisition line.\n\nRaises:\n    NotImplementedError: if the backend doesn't support querying the\n        measurement mapping",
        "api_signature": "acquire_channel(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend.py"
    },
    {
        "api_name": "control_channel",
        "full_api_name": "BackendV2.control_channel",
        "api_description": "Return the secondary drive channel for the given qubit\n\nThis is typically utilized for controlling multiqubit interactions.\nThis channel is derived from other channels.\n\nThis is required to be implemented if the backend supports Pulse\nscheduling.\n\nArgs:\n    qubits: Tuple or list of qubits of the form\n        ``(control_qubit, target_qubit)``.\n\nReturns:\n    List[ControlChannel]: The multi qubit control line.\n\nRaises:\n    NotImplementedError: if the backend doesn't support querying the\n        measurement mapping",
        "api_signature": "control_channel(self, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend.py"
    },
    {
        "api_name": "set_options",
        "full_api_name": "BackendV2.set_options",
        "api_description": "Set the options fields for the backend\n\nThis method is used to update the options of a backend. If\nyou need to change any of the options prior to running just\npass in the kwarg with the new value for the options.\n\nArgs:\n    fields: The fields to update the options\n\nRaises:\n    AttributeError: If the field passed in is not part of the\n        options",
        "api_signature": "set_options(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend.py"
    },
    {
        "api_name": "options",
        "full_api_name": "BackendV2.options",
        "api_description": "Return the options for the backend\n\nThe options of a backend are the dynamic parameters defining\nhow the backend is used. These are used to control the :meth:`run`\nmethod.",
        "api_signature": "options(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend.py"
    },
    {
        "api_name": "provider",
        "full_api_name": "BackendV2.provider",
        "api_description": "Return the backend Provider.\n\nReturns:\n    Provider: the Provider responsible for the backend.",
        "api_signature": "provider(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend.py"
    },
    {
        "api_name": "run",
        "full_api_name": "BackendV2.run",
        "api_description": "Run on the backend.\n\nThis method returns a :class:`~qiskit.providers.Job` object\nthat runs circuits. Depending on the backend this may be either an async\nor sync call. It is at the discretion of the provider to decide whether\nrunning should block until the execution is finished or not: the Job\nclass can handle either situation.\n\nArgs:\n    run_input (QuantumCircuit or Schedule or ScheduleBlock or list): An\n        individual or a list of :class:`.QuantumCircuit`,\n        :class:`~qiskit.pulse.ScheduleBlock`, or :class:`~qiskit.pulse.Schedule` objects to\n        run on the backend.\n    options: Any kwarg options to pass to the backend for running the\n        config. If a key is also present in the options\n        attribute/object then the expectation is that the value\n        specified will be used instead of what's set in the options\n        object.\n\nReturns:\n    Job: The job object for the run",
        "api_signature": "run(self, run_input)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "JobV1.__init__",
        "api_description": "Initializes the asynchronous job.\n\nArgs:\n    backend: the backend used to run the job.\n    job_id: a unique id in the context of the backend used to run\n        the job.\n    kwargs: Any key value metadata to associate with this job.",
        "api_signature": "__init__(self, backend, job_id)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/job.py"
    },
    {
        "api_name": "job_id",
        "full_api_name": "JobV1.job_id",
        "api_description": "Return a unique id identifying the job.",
        "api_signature": "job_id(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/job.py"
    },
    {
        "api_name": "backend",
        "full_api_name": "JobV1.backend",
        "api_description": "Return the backend where this job was executed.",
        "api_signature": "backend(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/job.py"
    },
    {
        "api_name": "done",
        "full_api_name": "JobV1.done",
        "api_description": "Return whether the job has successfully run.",
        "api_signature": "done(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/job.py"
    },
    {
        "api_name": "running",
        "full_api_name": "JobV1.running",
        "api_description": "Return whether the job is actively running.",
        "api_signature": "running(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/job.py"
    },
    {
        "api_name": "cancelled",
        "full_api_name": "JobV1.cancelled",
        "api_description": "Return whether the job has been cancelled.",
        "api_signature": "cancelled(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/job.py"
    },
    {
        "api_name": "in_final_state",
        "full_api_name": "JobV1.in_final_state",
        "api_description": "Return whether the job is in a final job state such as ``DONE`` or ``ERROR``.",
        "api_signature": "in_final_state(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/job.py"
    },
    {
        "api_name": "wait_for_final_state",
        "full_api_name": "JobV1.wait_for_final_state",
        "api_description": "Poll the job status until it progresses to a final state such as ``DONE`` or ``ERROR``.\n\nArgs:\n    timeout: Seconds to wait for the job. If ``None``, wait indefinitely.\n    wait: Seconds between queries.\n    callback: Callback function invoked after each query.\n        The following positional arguments are provided to the callback function:\n\n        * job_id: Job ID\n        * job_status: Status of the job from the last query\n        * job: This BaseJob instance\n\n        Note: different subclass might provide different arguments to\n        the callback function.\n\nRaises:\n    JobTimeoutError: If the job does not reach a final state before the\n        specified timeout.",
        "api_signature": "wait_for_final_state(self, timeout, wait, callback)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/job.py"
    },
    {
        "api_name": "submit",
        "full_api_name": "JobV1.submit",
        "api_description": "Submit the job to the backend for execution.",
        "api_signature": "submit(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/job.py"
    },
    {
        "api_name": "result",
        "full_api_name": "JobV1.result",
        "api_description": "Return the results of the job.",
        "api_signature": "result(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/job.py"
    },
    {
        "api_name": "cancel",
        "full_api_name": "JobV1.cancel",
        "api_description": "Attempt to cancel the job.",
        "api_signature": "cancel(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/job.py"
    },
    {
        "api_name": "status",
        "full_api_name": "JobV1.status",
        "api_description": "Return the status of the job, among the values of ``JobStatus``.",
        "api_signature": "status(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/job.py"
    },
    {
        "api_name": "filter_backends",
        "full_api_name": "filter_backends",
        "api_description": "Return the backends matching the specified filtering.\n\nFilter the `backends` list by their `configuration` or `status`\nattributes, or from a boolean callable. The criteria for filtering can\nbe specified via `**kwargs` or as a callable via `filters`, and the\nbackends must fulfill all specified conditions.\n\nArgs:\n    backends (list[Backend]): list of backends.\n    filters (callable): filtering conditions as a callable.\n    **kwargs: dict of criteria.\n\nReturns:\n    list[Backend]: a list of backend instances matching the\n        conditions.",
        "api_signature": "filter_backends(backends, filters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/providerutils.py"
    },
    {
        "api_name": "_match_all",
        "full_api_name": "_match_all",
        "api_description": "Return True if all items in criteria matches items in obj.",
        "api_signature": "_match_all(obj, criteria)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/providerutils.py"
    },
    {
        "api_name": "resolve_backend_name",
        "full_api_name": "resolve_backend_name",
        "api_description": "Resolve backend name from a deprecated name or an alias.\n\nA group will be resolved in order of member priorities, depending on\navailability.\n\nArgs:\n    name (str): name of backend to resolve\n    backends (list[Backend]): list of available backends.\n    deprecated (dict[str: str]): dict of deprecated names.\n    aliased (dict[str: list[str]]): dict of aliased names.\n\nReturns:\n    str: resolved name (name of an available backend)\n\nRaises:\n    LookupError: if name cannot be resolved through regular available\n        names, nor deprecated, nor alias names.",
        "api_signature": "resolve_backend_name(name, backends, deprecated, aliased)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/providerutils.py"
    },
    {
        "api_name": "get_backend",
        "full_api_name": "ProviderV1.get_backend",
        "api_description": "Return a single backend matching the specified filtering.\n\nArgs:\n    name (str): name of the backend.\n    **kwargs: dict used for filtering.\n\nReturns:\n    Backend: a backend matching the filtering.\n\nRaises:\n    QiskitBackendNotFoundError: if no backend could be found or\n        more than one backend matches the filtering criteria.",
        "api_signature": "get_backend(self, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/provider.py"
    },
    {
        "api_name": "backends",
        "full_api_name": "ProviderV1.backends",
        "api_description": "Return a list of backends matching the specified filtering.\n\nArgs:\n    name (str): name of the backend.\n    **kwargs: dict used for filtering.\n\nReturns:\n    list[Backend]: a list of Backends that match the filtering\n        criteria.",
        "api_signature": "backends(self, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/provider.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "ProviderV1.__eq__",
        "api_description": "Equality comparison.\n\nBy default, it is assumed that two `Providers` from the same class are\nequal. Subclassed providers can override this behavior.",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/provider.py"
    },
    {
        "api_name": "__getitem__",
        "full_api_name": "Options.__getitem__",
        "api_description": "",
        "api_signature": "__getitem__(self, key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/options.py"
    },
    {
        "api_name": "__iter__",
        "full_api_name": "Options.__iter__",
        "api_description": "",
        "api_signature": "__iter__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/options.py"
    },
    {
        "api_name": "__len__",
        "full_api_name": "Options.__len__",
        "api_description": "",
        "api_signature": "__len__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/options.py"
    },
    {
        "api_name": "__setitem__",
        "full_api_name": "Options.__setitem__",
        "api_description": "",
        "api_signature": "__setitem__(self, key, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/options.py"
    },
    {
        "api_name": "__dict__",
        "full_api_name": "Options.__dict__",
        "api_description": "",
        "api_signature": "__dict__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/options.py"
    },
    {
        "api_name": "__getattr__",
        "full_api_name": "Options.__getattr__",
        "api_description": "",
        "api_signature": "__getattr__(self, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/options.py"
    },
    {
        "api_name": "__setattr__",
        "full_api_name": "Options.__setattr__",
        "api_description": "",
        "api_signature": "__setattr__(self, key, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/options.py"
    },
    {
        "api_name": "__getstate__",
        "full_api_name": "Options.__getstate__",
        "api_description": "",
        "api_signature": "__getstate__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/options.py"
    },
    {
        "api_name": "__setstate__",
        "full_api_name": "Options.__setstate__",
        "api_description": "",
        "api_signature": "__setstate__(self, state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/options.py"
    },
    {
        "api_name": "__copy__",
        "full_api_name": "Options.__copy__",
        "api_description": "Return a copy of the Options.\n\nThe returned option and validator values are shallow copies of the originals.",
        "api_signature": "__copy__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/options.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Options.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/options.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "Options.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/options.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "Options.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/options.py"
    },
    {
        "api_name": "set_validator",
        "full_api_name": "Options.set_validator",
        "api_description": "Set an optional validator for a field in the options\n\nSetting a validator enables changes to an options values to be\nvalidated for correctness when :meth:`~qiskit.providers.Options.update_options`\nis called. For example if you have a numeric field like\n``shots`` you can specify a bounds tuple that set an upper and lower\nbound on the value such as::\n\n    options.set_validator(\"shots\", (1, 4096))\n\nIn this case whenever the ``\"shots\"`` option is updated by the user\nit will enforce that the value is >=1 and <=4096. A ``ValueError`` will\nbe raised if it's outside those bounds. If a validator is already present\nfor the specified field it will be silently overridden.\n\nArgs:\n    field (str): The field name to set the validator on\n    validator_value (list or tuple or type): The value to use for the\n        validator depending on the type indicates on how the value for\n        a field is enforced. If a tuple is passed in it must have a\n        length of two and will enforce the min and max value\n        (inclusive) for an integer or float value option. If it's a\n        list it will list the valid values for a field. If it's a\n        ``type`` the validator will just enforce the value is of a\n        certain type.\nRaises:\n    KeyError: If field is not present in the options object\n    ValueError: If the ``validator_value`` has an invalid value for a\n        given type\n    TypeError: If ``validator_value`` is not a valid type",
        "api_signature": "set_validator(self, field, validator_value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/options.py"
    },
    {
        "api_name": "update_options",
        "full_api_name": "Options.update_options",
        "api_description": "Update options with kwargs",
        "api_signature": "update_options(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/options.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "Options.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/options.py"
    },
    {
        "api_name": "convert_to_target",
        "full_api_name": "convert_to_target",
        "api_description": "Uses configuration, properties and pulse defaults\nto construct and return Target class.\n\nIn order to convert with a ``defaults.instruction_schedule_map``,\nwhich has a custom calibration for an operation,\nthe operation name must be in ``configuration.basis_gates`` and\n``custom_name_mapping`` must be supplied for the operation.\nOtherwise, the operation will be dropped in the resulting ``Target`` object.\n\nThat suggests it is recommended to add custom calibrations **after** creating a target\nwith this function instead of adding them to ``defaults`` in advance. For example::\n\n    target.add_instruction(custom_gate, {(0, 1): InstructionProperties(calibration=custom_sched)})",
        "api_signature": "convert_to_target(configuration, properties, defaults, custom_name_mapping, add_delay, filter_faulty)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend_compat.py"
    },
    {
        "api_name": "qubit_props_list_from_props",
        "full_api_name": "qubit_props_list_from_props",
        "api_description": "Uses BackendProperties to construct\nand return a list of QubitProperties.",
        "api_signature": "qubit_props_list_from_props(properties)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend_compat.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BackendV2Converter.__init__",
        "api_description": "Initialize a BackendV2 converter instance based on a BackendV1 instance.\n\nArgs:\n    backend: The input :class:`~.BackendV1` based backend to wrap in a\n        :class:`~.BackendV2` interface\n    name_mapping: An optional dictionary that maps custom gate/operation names in\n        ``backend`` to an :class:`~.Operation` object representing that\n        gate/operation. By default most standard gates names are mapped to the\n        standard gate object from :mod:`qiskit.circuit.library` this only needs\n        to be specified if the input ``backend`` defines gates in names outside\n        that set.\n    add_delay: If set to true a :class:`~qiskit.circuit.Delay` operation\n        will be added to the target as a supported operation for all\n        qubits\n    filter_faulty: If the :class:`~.BackendProperties` object (if present) for\n        ``backend`` has any qubits or gates flagged as non-operational filter\n        those from the output target.",
        "api_signature": "__init__(self, backend, name_mapping, add_delay, filter_faulty)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend_compat.py"
    },
    {
        "api_name": "target",
        "full_api_name": "BackendV2Converter.target",
        "api_description": "A :class:`qiskit.transpiler.Target` object for the backend.\n\n:rtype: Target",
        "api_signature": "target(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend_compat.py"
    },
    {
        "api_name": "max_circuits",
        "full_api_name": "BackendV2Converter.max_circuits",
        "api_description": "",
        "api_signature": "max_circuits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend_compat.py"
    },
    {
        "api_name": "_default_options",
        "full_api_name": "BackendV2Converter._default_options",
        "api_description": "",
        "api_signature": "_default_options(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend_compat.py"
    },
    {
        "api_name": "dtm",
        "full_api_name": "BackendV2Converter.dtm",
        "api_description": "",
        "api_signature": "dtm(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend_compat.py"
    },
    {
        "api_name": "meas_map",
        "full_api_name": "BackendV2Converter.meas_map",
        "api_description": "",
        "api_signature": "meas_map(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend_compat.py"
    },
    {
        "api_name": "drive_channel",
        "full_api_name": "BackendV2Converter.drive_channel",
        "api_description": "",
        "api_signature": "drive_channel(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend_compat.py"
    },
    {
        "api_name": "measure_channel",
        "full_api_name": "BackendV2Converter.measure_channel",
        "api_description": "",
        "api_signature": "measure_channel(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend_compat.py"
    },
    {
        "api_name": "acquire_channel",
        "full_api_name": "BackendV2Converter.acquire_channel",
        "api_description": "",
        "api_signature": "acquire_channel(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend_compat.py"
    },
    {
        "api_name": "control_channel",
        "full_api_name": "BackendV2Converter.control_channel",
        "api_description": "",
        "api_signature": "control_channel(self, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend_compat.py"
    },
    {
        "api_name": "run",
        "full_api_name": "BackendV2Converter.run",
        "api_description": "",
        "api_signature": "run(self, run_input)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend_compat.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "FakeOpenPulse3Q.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_openpulse_3q.py"
    },
    {
        "api_name": "defaults",
        "full_api_name": "FakeOpenPulse3Q.defaults",
        "api_description": "",
        "api_signature": "defaults(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_openpulse_3q.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "FakeQobj.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_qobj.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "FakeJob.__init__",
        "api_description": "",
        "api_signature": "__init__(self, backend, job_id, fn)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_job.py"
    },
    {
        "api_name": "submit",
        "full_api_name": "FakeJob.submit",
        "api_description": "",
        "api_signature": "submit(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_job.py"
    },
    {
        "api_name": "result",
        "full_api_name": "FakeJob.result",
        "api_description": "",
        "api_signature": "result(self, timeout)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_job.py"
    },
    {
        "api_name": "cancel",
        "full_api_name": "FakeJob.cancel",
        "api_description": "",
        "api_signature": "cancel(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_job.py"
    },
    {
        "api_name": "status",
        "full_api_name": "FakeJob.status",
        "api_description": "",
        "api_signature": "status(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_job.py"
    },
    {
        "api_name": "job_id",
        "full_api_name": "FakeJob.job_id",
        "api_description": "",
        "api_signature": "job_id(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_job.py"
    },
    {
        "api_name": "backend",
        "full_api_name": "FakeJob.backend",
        "api_description": "",
        "api_signature": "backend(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_job.py"
    },
    {
        "api_name": "_cancelled",
        "full_api_name": "FakeJob._cancelled",
        "api_description": "",
        "api_signature": "_cancelled(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_job.py"
    },
    {
        "api_name": "_done",
        "full_api_name": "FakeJob._done",
        "api_description": "",
        "api_signature": "_done(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_job.py"
    },
    {
        "api_name": "_running",
        "full_api_name": "FakeJob._running",
        "api_description": "",
        "api_signature": "_running(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_job.py"
    },
    {
        "api_name": "_error",
        "full_api_name": "FakeJob._error",
        "api_description": "",
        "api_signature": "_error(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_job.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "FakeBackendV2.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_backend_v2.py"
    },
    {
        "api_name": "target",
        "full_api_name": "FakeBackendV2.target",
        "api_description": "",
        "api_signature": "target(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_backend_v2.py"
    },
    {
        "api_name": "max_circuits",
        "full_api_name": "FakeBackendV2.max_circuits",
        "api_description": "",
        "api_signature": "max_circuits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_backend_v2.py"
    },
    {
        "api_name": "_default_options",
        "full_api_name": "FakeBackendV2._default_options",
        "api_description": "",
        "api_signature": "_default_options(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_backend_v2.py"
    },
    {
        "api_name": "run",
        "full_api_name": "FakeBackendV2.run",
        "api_description": "",
        "api_signature": "run(self, run_input)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_backend_v2.py"
    },
    {
        "api_name": "qubit_properties",
        "full_api_name": "FakeBackendV2LegacyQubitProps.qubit_properties",
        "api_description": "",
        "api_signature": "qubit_properties(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_backend_v2.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "FakeBackend5QV2.__init__",
        "api_description": "",
        "api_signature": "__init__(self, bidirectional)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_backend_v2.py"
    },
    {
        "api_name": "target",
        "full_api_name": "FakeBackend5QV2.target",
        "api_description": "",
        "api_signature": "target(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_backend_v2.py"
    },
    {
        "api_name": "max_circuits",
        "full_api_name": "FakeBackend5QV2.max_circuits",
        "api_description": "",
        "api_signature": "max_circuits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_backend_v2.py"
    },
    {
        "api_name": "_default_options",
        "full_api_name": "FakeBackend5QV2._default_options",
        "api_description": "",
        "api_signature": "_default_options(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_backend_v2.py"
    },
    {
        "api_name": "run",
        "full_api_name": "FakeBackend5QV2.run",
        "api_description": "",
        "api_signature": "run(self, run_input)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_backend_v2.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "FakeBackendSimple.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_backend_v2.py"
    },
    {
        "api_name": "target",
        "full_api_name": "FakeBackendSimple.target",
        "api_description": "",
        "api_signature": "target(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_backend_v2.py"
    },
    {
        "api_name": "max_circuits",
        "full_api_name": "FakeBackendSimple.max_circuits",
        "api_description": "",
        "api_signature": "max_circuits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_backend_v2.py"
    },
    {
        "api_name": "_default_options",
        "full_api_name": "FakeBackendSimple._default_options",
        "api_description": "",
        "api_signature": "_default_options(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_backend_v2.py"
    },
    {
        "api_name": "run",
        "full_api_name": "FakeBackendSimple.run",
        "api_description": "",
        "api_signature": "run(self, run_input)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_backend_v2.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "FakeQasmSimulator.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_qasm_simulator.py"
    },
    {
        "api_name": "properties",
        "full_api_name": "FakeQasmSimulator.properties",
        "api_description": "",
        "api_signature": "properties(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_qasm_simulator.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "FakeMumbaiFractionalCX.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_mumbai_v2.py"
    },
    {
        "api_name": "target",
        "full_api_name": "FakeMumbaiFractionalCX.target",
        "api_description": "",
        "api_signature": "target(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_mumbai_v2.py"
    },
    {
        "api_name": "max_circuits",
        "full_api_name": "FakeMumbaiFractionalCX.max_circuits",
        "api_description": "",
        "api_signature": "max_circuits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_mumbai_v2.py"
    },
    {
        "api_name": "_default_options",
        "full_api_name": "FakeMumbaiFractionalCX._default_options",
        "api_description": "",
        "api_signature": "_default_options(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_mumbai_v2.py"
    },
    {
        "api_name": "run",
        "full_api_name": "FakeMumbaiFractionalCX.run",
        "api_description": "",
        "api_signature": "run(self, run_input)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_mumbai_v2.py"
    },
    {
        "api_name": "qubit_properties",
        "full_api_name": "FakeMumbaiFractionalCX.qubit_properties",
        "api_description": "",
        "api_signature": "qubit_properties(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_mumbai_v2.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "FakeProviderFactory.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_provider.py"
    },
    {
        "api_name": "load_account",
        "full_api_name": "FakeProviderFactory.load_account",
        "api_description": "Fake load_account method to mirror the IBMQ provider.",
        "api_signature": "load_account(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_provider.py"
    },
    {
        "api_name": "enable_account",
        "full_api_name": "FakeProviderFactory.enable_account",
        "api_description": "Fake enable_account method to mirror the IBMQ provider factory.",
        "api_signature": "enable_account(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_provider.py"
    },
    {
        "api_name": "disable_account",
        "full_api_name": "FakeProviderFactory.disable_account",
        "api_description": "Fake disable_account method to mirror the IBMQ provider factory.",
        "api_signature": "disable_account(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_provider.py"
    },
    {
        "api_name": "save_account",
        "full_api_name": "FakeProviderFactory.save_account",
        "api_description": "Fake save_account method to mirror the IBMQ provider factory.",
        "api_signature": "save_account(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_provider.py"
    },
    {
        "api_name": "delete_account",
        "full_api_name": "FakeProviderFactory.delete_account",
        "api_description": "Fake delete_account method to mirror the IBMQ provider factory.",
        "api_signature": "delete_account()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_provider.py"
    },
    {
        "api_name": "update_account",
        "full_api_name": "FakeProviderFactory.update_account",
        "api_description": "Fake update_account method to mirror the IBMQ provider factory.",
        "api_signature": "update_account(self, force)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_provider.py"
    },
    {
        "api_name": "providers",
        "full_api_name": "FakeProviderFactory.providers",
        "api_description": "Fake providers method to mirror the IBMQ provider.",
        "api_signature": "providers(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_provider.py"
    },
    {
        "api_name": "get_provider",
        "full_api_name": "FakeProviderFactory.get_provider",
        "api_description": "Fake get_provider method to mirror the IBMQ provider.",
        "api_signature": "get_provider(self, hub, group, project)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_provider.py"
    },
    {
        "api_name": "get_backend",
        "full_api_name": "FakeProviderForBackendV2.get_backend",
        "api_description": "",
        "api_signature": "get_backend(self, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_provider.py"
    },
    {
        "api_name": "backends",
        "full_api_name": "FakeProviderForBackendV2.backends",
        "api_description": "",
        "api_signature": "backends(self, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_provider.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "FakeProviderForBackendV2.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_provider.py"
    },
    {
        "api_name": "get_backend",
        "full_api_name": "FakeProvider.get_backend",
        "api_description": "",
        "api_signature": "get_backend(self, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_provider.py"
    },
    {
        "api_name": "backends",
        "full_api_name": "FakeProvider.backends",
        "api_description": "",
        "api_signature": "backends(self, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_provider.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "FakeProvider.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_provider.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "FakeOpenPulse2Q.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_openpulse_2q.py"
    },
    {
        "api_name": "defaults",
        "full_api_name": "FakeOpenPulse2Q.defaults",
        "api_description": "Return the default pulse-related settings provided by the backend (such as gate\nto Schedule mappings).",
        "api_signature": "defaults(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_openpulse_2q.py"
    },
    {
        "api_name": "properties",
        "full_api_name": "FakeOpenPulse2Q.properties",
        "api_description": "Return the measured characteristics of the backend.",
        "api_signature": "properties(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_openpulse_2q.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "FakeQasmBackend.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_qasm_backend.py"
    },
    {
        "api_name": "properties",
        "full_api_name": "FakeQasmBackend.properties",
        "api_description": "Returns a snapshot of device properties",
        "api_signature": "properties(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_qasm_backend.py"
    },
    {
        "api_name": "_get_conf_from_json",
        "full_api_name": "FakeQasmBackend._get_conf_from_json",
        "api_description": "",
        "api_signature": "_get_conf_from_json(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_qasm_backend.py"
    },
    {
        "api_name": "_set_props_from_json",
        "full_api_name": "FakeQasmBackend._set_props_from_json",
        "api_description": "",
        "api_signature": "_set_props_from_json(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_qasm_backend.py"
    },
    {
        "api_name": "_load_json",
        "full_api_name": "FakeQasmBackend._load_json",
        "api_description": "",
        "api_signature": "_load_json(self, filename)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_qasm_backend.py"
    },
    {
        "api_name": "_get_config_from_dict",
        "full_api_name": "FakeQasmBackend._get_config_from_dict",
        "api_description": "",
        "api_signature": "_get_config_from_dict(self, conf)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_qasm_backend.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Fake1Q.__init__",
        "api_description": "0",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_1q.py"
    },
    {
        "api_name": "defaults",
        "full_api_name": "FakePulseBackend.defaults",
        "api_description": "Returns a snapshot of device defaults",
        "api_signature": "defaults(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_pulse_backend.py"
    },
    {
        "api_name": "_set_defaults_from_json",
        "full_api_name": "FakePulseBackend._set_defaults_from_json",
        "api_description": "",
        "api_signature": "_set_defaults_from_json(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_pulse_backend.py"
    },
    {
        "api_name": "_get_config_from_dict",
        "full_api_name": "FakePulseBackend._get_config_from_dict",
        "api_description": "",
        "api_signature": "_get_config_from_dict(self, conf)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_pulse_backend.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "_Credentials.__init__",
        "api_description": "",
        "api_signature": "__init__(self, token, url)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_backend.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "FakeBackendV2.__init__",
        "api_description": "FakeBackendV2 initializer.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_backend.py"
    },
    {
        "api_name": "_parse_channels",
        "full_api_name": "FakeBackendV2._parse_channels",
        "api_description": "",
        "api_signature": "_parse_channels(self, channels)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_backend.py"
    },
    {
        "api_name": "_setup_sim",
        "full_api_name": "FakeBackendV2._setup_sim",
        "api_description": "",
        "api_signature": "_setup_sim(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_backend.py"
    },
    {
        "api_name": "_get_conf_dict_from_json",
        "full_api_name": "FakeBackendV2._get_conf_dict_from_json",
        "api_description": "",
        "api_signature": "_get_conf_dict_from_json(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_backend.py"
    },
    {
        "api_name": "_set_props_dict_from_json",
        "full_api_name": "FakeBackendV2._set_props_dict_from_json",
        "api_description": "",
        "api_signature": "_set_props_dict_from_json(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_backend.py"
    },
    {
        "api_name": "_set_defs_dict_from_json",
        "full_api_name": "FakeBackendV2._set_defs_dict_from_json",
        "api_description": "",
        "api_signature": "_set_defs_dict_from_json(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_backend.py"
    },
    {
        "api_name": "_load_json",
        "full_api_name": "FakeBackendV2._load_json",
        "api_description": "",
        "api_signature": "_load_json(self, filename)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_backend.py"
    },
    {
        "api_name": "target",
        "full_api_name": "FakeBackendV2.target",
        "api_description": "A :class:`qiskit.transpiler.Target` object for the backend.\n\n:rtype: Target",
        "api_signature": "target(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_backend.py"
    },
    {
        "api_name": "max_circuits",
        "full_api_name": "FakeBackendV2.max_circuits",
        "api_description": "",
        "api_signature": "max_circuits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_backend.py"
    },
    {
        "api_name": "_default_options",
        "full_api_name": "FakeBackendV2._default_options",
        "api_description": "Return the default options\n\nThis method will return a :class:`qiskit.providers.Options`\nsubclass object that will be used for the default options. These\nshould be the default parameters to use for the options of the\nbackend.\n\nReturns:\n    qiskit.providers.Options: A options object with\n        default values set",
        "api_signature": "_default_options(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_backend.py"
    },
    {
        "api_name": "dtm",
        "full_api_name": "FakeBackendV2.dtm",
        "api_description": "Return the system time resolution of output signals\n\nReturns:\n    The output signal timestep in seconds.",
        "api_signature": "dtm(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_backend.py"
    },
    {
        "api_name": "meas_map",
        "full_api_name": "FakeBackendV2.meas_map",
        "api_description": "Return the grouping of measurements which are multiplexed\nThis is required to be implemented if the backend supports Pulse\nscheduling.\n\nReturns:\n    The grouping of measurements which are multiplexed",
        "api_signature": "meas_map(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_backend.py"
    },
    {
        "api_name": "drive_channel",
        "full_api_name": "FakeBackendV2.drive_channel",
        "api_description": "Return the drive channel for the given qubit.\n\nThis is required to be implemented if the backend supports Pulse\nscheduling.\n\nReturns:\n    DriveChannel: The Qubit drive channel",
        "api_signature": "drive_channel(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_backend.py"
    },
    {
        "api_name": "measure_channel",
        "full_api_name": "FakeBackendV2.measure_channel",
        "api_description": "Return the measure stimulus channel for the given qubit.\n\nThis is required to be implemented if the backend supports Pulse\nscheduling.\n\nReturns:\n    MeasureChannel: The Qubit measurement stimulus line",
        "api_signature": "measure_channel(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_backend.py"
    },
    {
        "api_name": "acquire_channel",
        "full_api_name": "FakeBackendV2.acquire_channel",
        "api_description": "Return the acquisition channel for the given qubit.\n\nThis is required to be implemented if the backend supports Pulse\nscheduling.\n\nReturns:\n    AcquireChannel: The Qubit measurement acquisition line.",
        "api_signature": "acquire_channel(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_backend.py"
    },
    {
        "api_name": "control_channel",
        "full_api_name": "FakeBackendV2.control_channel",
        "api_description": "Return the secondary drive channel for the given qubit\n\nThis is typically utilized for controlling multiqubit interactions.\nThis channel is derived from other channels.\n\nThis is required to be implemented if the backend supports Pulse\nscheduling.\n\nArgs:\n    qubits: Tuple or list of qubits of the form\n        ``(control_qubit, target_qubit)``.\n\nReturns:\n    List[ControlChannel]: The multi qubit control line.",
        "api_signature": "control_channel(self, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_backend.py"
    },
    {
        "api_name": "run",
        "full_api_name": "FakeBackendV2.run",
        "api_description": "Run on the fake backend using a simulator.\n\nThis method runs circuit jobs (an individual or a list of QuantumCircuit\n) and pulse jobs (an individual or a list of Schedule or ScheduleBlock)\nusing BasicAer or Aer simulator and returns a\n:class:`~qiskit.providers.Job` object.\n\nIf qiskit-aer is installed, jobs will be run using AerSimulator with\nnoise model of the fake backend. Otherwise, jobs will be run using\nBasicAer simulator without noise.\n\nCurrently noisy simulation of a pulse job is not supported yet in\nFakeBackendV2.\n\nArgs:\n    run_input (QuantumCircuit or Schedule or ScheduleBlock or list): An\n        individual or a list of\n        :class:`~qiskit.circuit.QuantumCircuit`,\n        :class:`~qiskit.pulse.ScheduleBlock`, or\n        :class:`~qiskit.pulse.Schedule` objects to run on the backend.\n    options: Any kwarg options to pass to the backend for running the\n        config. If a key is also present in the options\n        attribute/object then the expectation is that the value\n        specified will be used instead of what's set in the options\n        object.\n\nReturns:\n    Job: The job object for the run\n\nRaises:\n    QiskitError: If a pulse job is supplied and qiskit-aer is not installed.",
        "api_signature": "run(self, run_input)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_backend.py"
    },
    {
        "api_name": "_get_noise_model_from_backend_v2",
        "full_api_name": "FakeBackendV2._get_noise_model_from_backend_v2",
        "api_description": "Build noise model from BackendV2.\n\nThis is a temporary fix until qiskit-aer supports building noise model\nfrom a BackendV2 object.",
        "api_signature": "_get_noise_model_from_backend_v2(self, gate_error, readout_error, thermal_relaxation, temperature, gate_lengths, gate_length_units)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_backend.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "FakeBackend.__init__",
        "api_description": "FakeBackend initializer.\n\nArgs:\n    configuration (BackendConfiguration): backend configuration\n    time_alive (int): time to wait before returning result",
        "api_signature": "__init__(self, configuration, time_alive)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_backend.py"
    },
    {
        "api_name": "_setup_sim",
        "full_api_name": "FakeBackend._setup_sim",
        "api_description": "",
        "api_signature": "_setup_sim(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_backend.py"
    },
    {
        "api_name": "properties",
        "full_api_name": "FakeBackend.properties",
        "api_description": "Return backend properties",
        "api_signature": "properties(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_backend.py"
    },
    {
        "api_name": "_default_options",
        "full_api_name": "FakeBackend._default_options",
        "api_description": "",
        "api_signature": "_default_options(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_backend.py"
    },
    {
        "api_name": "run",
        "full_api_name": "FakeBackend.run",
        "api_description": "Main job in simulator",
        "api_signature": "run(self, run_input)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_backend.py"
    },
    {
        "api_name": "convert_to_target",
        "full_api_name": "convert_to_target",
        "api_description": "Uses configuration, properties and pulse defaults dicts\nto construct and return Target class.",
        "api_signature": "convert_to_target(conf_dict, props_dict, defs_dict)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/utils/backend_converter.py"
    },
    {
        "api_name": "qubit_props_from_props",
        "full_api_name": "qubit_props_from_props",
        "api_description": "Returns a dictionary of `qiskit.providers.backend.QubitProperties` using\na backend properties dictionary created by loading props.json payload.",
        "api_signature": "qubit_props_from_props(properties)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/utils/backend_converter.py"
    },
    {
        "api_name": "decode_pulse_defaults",
        "full_api_name": "decode_pulse_defaults",
        "api_description": "Decode pulse defaults data.\n\nArgs:\n    defaults: A ``PulseDefaults`` in dictionary format.",
        "api_signature": "decode_pulse_defaults(defaults)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/utils/json_decoder.py"
    },
    {
        "api_name": "decode_backend_properties",
        "full_api_name": "decode_backend_properties",
        "api_description": "Decode backend properties.\n\nArgs:\n    properties: A ``BackendProperties`` in dictionary format.",
        "api_signature": "decode_backend_properties(properties)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/utils/json_decoder.py"
    },
    {
        "api_name": "decode_backend_configuration",
        "full_api_name": "decode_backend_configuration",
        "api_description": "Decode backend configuration.\n\nArgs:\n    config: A ``QasmBackendConfiguration`` or ``PulseBackendConfiguration``\n        in dictionary format.",
        "api_signature": "decode_backend_configuration(config)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/utils/json_decoder.py"
    },
    {
        "api_name": "_to_complex",
        "full_api_name": "_to_complex",
        "api_description": "Convert the input value to type ``complex``.\n\nArgs:\n    value: Value to be converted.\n\nReturns:\n    Input value in ``complex``.\n\nRaises:\n    TypeError: If the input value is not in the expected format.",
        "api_signature": "_to_complex(value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/utils/json_decoder.py"
    },
    {
        "api_name": "_decode_pulse_library_item",
        "full_api_name": "_decode_pulse_library_item",
        "api_description": "Decode a pulse library item.\n\nArgs:\n    pulse_library_item: A ``PulseLibraryItem`` in dictionary format.",
        "api_signature": "_decode_pulse_library_item(pulse_library_item)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/utils/json_decoder.py"
    },
    {
        "api_name": "_decode_pulse_qobj_instr",
        "full_api_name": "_decode_pulse_qobj_instr",
        "api_description": "Decode a pulse Qobj instruction.\n\nArgs:\n    pulse_qobj_instr: A ``PulseQobjInstruction`` in dictionary format.",
        "api_signature": "_decode_pulse_qobj_instr(pulse_qobj_instr)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/utils/json_decoder.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ConfigurableFakeBackend.__init__",
        "api_description": "Creates backend based on provided configuration.\n\nArgs:\n    name: Name of the backend.\n    n_qubits: Number of qubits in the backend.\n    version: Version of the fake backend.\n    coupling_map: Coupling map.\n    basis_gates: Basis gates of the backend.\n    qubit_t1: Longitudinal coherence times.\n    qubit_t2: Transverse coherence times.\n    qubit_frequency: Frequency of qubits.\n    qubit_readout_error: Readout error of qubits.\n    single_qubit_gates: List of single qubit gates for backend properties.\n    dt: Discretization of the input time sequences.\n    std: Standard deviation of the generated distributions.\n    seed: Random seed.",
        "api_signature": "__init__(self, name, n_qubits, version, coupling_map, basis_gates, qubit_t1, qubit_t2, qubit_frequency, qubit_readout_error, single_qubit_gates, dt, std, seed)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/utils/configurable_backend.py"
    },
    {
        "api_name": "defaults",
        "full_api_name": "ConfigurableFakeBackend.defaults",
        "api_description": "Return backend defaults.",
        "api_signature": "defaults(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/utils/configurable_backend.py"
    },
    {
        "api_name": "properties",
        "full_api_name": "ConfigurableFakeBackend.properties",
        "api_description": "Return backend properties",
        "api_signature": "properties(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/utils/configurable_backend.py"
    },
    {
        "api_name": "_generate_cmap",
        "full_api_name": "ConfigurableFakeBackend._generate_cmap",
        "api_description": "Generate default grid-like coupling map.",
        "api_signature": "_generate_cmap(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/utils/configurable_backend.py"
    },
    {
        "api_name": "_build_props",
        "full_api_name": "ConfigurableFakeBackend._build_props",
        "api_description": "Build properties for backend.",
        "api_signature": "_build_props(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/utils/configurable_backend.py"
    },
    {
        "api_name": "_build_conf",
        "full_api_name": "ConfigurableFakeBackend._build_conf",
        "api_description": "Build configuration for backend.",
        "api_signature": "_build_conf(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/utils/configurable_backend.py"
    },
    {
        "api_name": "_build_defaults",
        "full_api_name": "ConfigurableFakeBackend._build_defaults",
        "api_description": "Build backend defaults.",
        "api_signature": "_build_defaults(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/utils/configurable_backend.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "FakeMelbourne.__init__",
        "api_description": ".. code-block:: text\n\n    0 \u2190 1 \u2192  2 \u2192  3 \u2190  4 \u2190 5 \u2192 6\n        \u2191    \u2191    \u2191    \u2193   \u2193   \u2193\n       13 \u2192 12 \u2190 11 \u2192 10 \u2190 9 \u2192 8 \u2190 7",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/backends/melbourne/fake_melbourne.py"
    },
    {
        "api_name": "properties",
        "full_api_name": "FakeMelbourne.properties",
        "api_description": "Returns a snapshot of device properties",
        "api_signature": "properties(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/backends/melbourne/fake_melbourne.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "FakeTokyo.__init__",
        "api_description": ".. code-block:: text\n\n    00 \u2194 01 \u2194 02 \u2194 03 \u2194 04\n     \u2195    \u2195    \u2195    \u2195 \u292b  \u2195\n    05 \u2194 06 \u2194 07 \u2194 08 \u2194 09\n     \u2195 \u292b \u2195    \u2195 \u292b \u2195\n    10 \u2194 11 \u2194 12 \u2194 13 \u2194 14\n     \u2195    \u2195 \u292b      \u2195 \u292b  \u2195\n    15 \u2194 16 \u2194 17   18   19",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/backends/tokyo/fake_tokyo.py"
    },
    {
        "api_name": "properties",
        "full_api_name": "FakeTokyo.properties",
        "api_description": "Returns a snapshot of device properties as recorded on 8/30/19.",
        "api_signature": "properties(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/backends/tokyo/fake_tokyo.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "FakeTenerife.__init__",
        "api_description": ".. code-block:: text\n\n        1\n      \u2199 \u2191\n    0 \u2190 2 \u2190 3\n        \u2191 \u2199\n        4",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/backends/tenerife/fake_tenerife.py"
    },
    {
        "api_name": "properties",
        "full_api_name": "FakeTenerife.properties",
        "api_description": "Returns a snapshot of device properties as recorded on 8/30/19.",
        "api_signature": "properties(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/backends/tenerife/fake_tenerife.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "FakeRueschlikon.__init__",
        "api_description": ".. code-block:: text\n\n    1 \u2192  2 \u2192  3 \u2192  4 \u2190  5 \u2190  6 \u2192  7 \u2190 8\n    \u2193    \u2191    \u2193    \u2193    \u2191    \u2193    \u2193   \u2191\n    0 \u2190 15 \u2192 14 \u2190 13 \u2190 12 \u2192 11 \u2192 10 \u2190 9",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/backends/rueschlikon/fake_rueschlikon.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "FakeCambridgeAlternativeBasis.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/backends/cambridge/fake_cambridge.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "FakePoughkeepsie.__init__",
        "api_description": ".. code-block:: text\n\n    00 \u2194 01 \u2194 02 \u2194 03 \u2194 04\n     \u2195                   \u2195\n    05 \u2194 06 \u2194 07 \u2194 08 \u2194 09\n     \u2195         \u2195         \u2195\n    10 \u2194 11 \u2194 12 \u2194 13 \u2194 14\n     \u2195                   \u2195\n    15 \u2194 16 \u2194 17 \u2194 18 \u2194 19",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/backends/poughkeepsie/fake_poughkeepsie.py"
    },
    {
        "api_name": "properties",
        "full_api_name": "FakePoughkeepsie.properties",
        "api_description": "Returns a snapshot of device properties",
        "api_signature": "properties(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/backends/poughkeepsie/fake_poughkeepsie.py"
    },
    {
        "api_name": "single_gate_matrix",
        "full_api_name": "single_gate_matrix",
        "api_description": "Get the matrix for a single qubit.\n\nArgs:\n    gate: the single qubit gate name\n    params: the operation parameters op['params']\nReturns:\n    array: A numpy array representing the matrix\nRaises:\n    QiskitError: If a gate outside the supported set is passed in for the\n        ``Gate`` argument.",
        "api_signature": "single_gate_matrix(gate, params)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basicaer/basicaertools.py"
    },
    {
        "api_name": "cx_gate_matrix",
        "full_api_name": "cx_gate_matrix",
        "api_description": "Get the matrix for a controlled-NOT gate.",
        "api_signature": "cx_gate_matrix()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basicaer/basicaertools.py"
    },
    {
        "api_name": "einsum_matmul_index",
        "full_api_name": "einsum_matmul_index",
        "api_description": "Return the index string for Numpy.einsum matrix-matrix multiplication.\n\nThe returned indices are to perform a matrix multiplication A.B where\nthe matrix A is an M-qubit matrix, matrix B is an N-qubit matrix, and\nM <= N, and identity matrices are implied on the subsystems where A has no\nsupport on B.\n\nArgs:\n    gate_indices (list[int]): the indices of the right matrix subsystems\n                               to contract with the left matrix.\n    number_of_qubits (int): the total number of qubits for the right matrix.\n\nReturns:\n    str: An indices string for the Numpy.einsum function.",
        "api_signature": "einsum_matmul_index(gate_indices, number_of_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basicaer/basicaertools.py"
    },
    {
        "api_name": "einsum_vecmul_index",
        "full_api_name": "einsum_vecmul_index",
        "api_description": "Return the index string for Numpy.einsum matrix-vector multiplication.\n\nThe returned indices are to perform a matrix multiplication A.v where\nthe matrix A is an M-qubit matrix, vector v is an N-qubit vector, and\nM <= N, and identity matrices are implied on the subsystems where A has no\nsupport on v.\n\nArgs:\n    gate_indices (list[int]): the indices of the right matrix subsystems\n                              to contract with the left matrix.\n    number_of_qubits (int): the total number of qubits for the right matrix.\n\nReturns:\n    str: An indices string for the Numpy.einsum function.",
        "api_signature": "einsum_vecmul_index(gate_indices, number_of_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basicaer/basicaertools.py"
    },
    {
        "api_name": "_einsum_matmul_index_helper",
        "full_api_name": "_einsum_matmul_index_helper",
        "api_description": "Return the index string for Numpy.einsum matrix multiplication.\n\nThe returned indices are to perform a matrix multiplication A.v where\nthe matrix A is an M-qubit matrix, matrix v is an N-qubit vector, and\nM <= N, and identity matrices are implied on the subsystems where A has no\nsupport on v.\n\nArgs:\n    gate_indices (list[int]): the indices of the right matrix subsystems\n                               to contract with the left matrix.\n    number_of_qubits (int): the total number of qubits for the right matrix.\n\nReturns:\n    tuple: (mat_left, mat_right, tens_in, tens_out) of index strings for\n    that may be combined into a Numpy.einsum function string.\n\nRaises:\n    QiskitError: if the total number of qubits plus the number of\n    contracted indices is greater than 26.",
        "api_signature": "_einsum_matmul_index_helper(gate_indices, number_of_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basicaer/basicaertools.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BasicAerError.__init__",
        "api_description": "Set the error message.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basicaer/exceptions.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "BasicAerError.__str__",
        "api_description": "Return the message.",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basicaer/exceptions.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QasmSimulatorPy.__init__",
        "api_description": "",
        "api_signature": "__init__(self, configuration, provider)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basicaer/qasm_simulator.py"
    },
    {
        "api_name": "_default_options",
        "full_api_name": "QasmSimulatorPy._default_options",
        "api_description": "",
        "api_signature": "_default_options(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basicaer/qasm_simulator.py"
    },
    {
        "api_name": "_add_unitary",
        "full_api_name": "QasmSimulatorPy._add_unitary",
        "api_description": "Apply an N-qubit unitary matrix.\n\nArgs:\n    gate (matrix_like): an N-qubit unitary matrix\n    qubits (list): the list of N-qubits.",
        "api_signature": "_add_unitary(self, gate, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basicaer/qasm_simulator.py"
    },
    {
        "api_name": "_get_measure_outcome",
        "full_api_name": "QasmSimulatorPy._get_measure_outcome",
        "api_description": "Simulate the outcome of measurement of a qubit.\n\nArgs:\n    qubit (int): the qubit to measure\n\nReturn:\n    tuple: pair (outcome, probability) where outcome is '0' or '1' and\n    probability is the probability of the returned outcome.",
        "api_signature": "_get_measure_outcome(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basicaer/qasm_simulator.py"
    },
    {
        "api_name": "_add_sample_measure",
        "full_api_name": "QasmSimulatorPy._add_sample_measure",
        "api_description": "Generate memory samples from current statevector.\n\nArgs:\n    measure_params (list): List of (qubit, cmembit) values for\n                           measure instructions to sample.\n    num_samples (int): The number of memory samples to generate.\n\nReturns:\n    list: A list of memory values in hex format.",
        "api_signature": "_add_sample_measure(self, measure_params, num_samples)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basicaer/qasm_simulator.py"
    },
    {
        "api_name": "_add_qasm_measure",
        "full_api_name": "QasmSimulatorPy._add_qasm_measure",
        "api_description": "Apply a measure instruction to a qubit.\n\nArgs:\n    qubit (int): qubit is the qubit measured.\n    cmembit (int): is the classical memory bit to store outcome in.\n    cregbit (int, optional): is the classical register bit to store outcome in.",
        "api_signature": "_add_qasm_measure(self, qubit, cmembit, cregbit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basicaer/qasm_simulator.py"
    },
    {
        "api_name": "_add_qasm_reset",
        "full_api_name": "QasmSimulatorPy._add_qasm_reset",
        "api_description": "Apply a reset instruction to a qubit.\n\nArgs:\n    qubit (int): the qubit being rest\n\nThis is done by doing a simulating a measurement\noutcome and projecting onto the outcome state while\nrenormalizing.",
        "api_signature": "_add_qasm_reset(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basicaer/qasm_simulator.py"
    },
    {
        "api_name": "_validate_initial_statevector",
        "full_api_name": "QasmSimulatorPy._validate_initial_statevector",
        "api_description": "Validate an initial statevector",
        "api_signature": "_validate_initial_statevector(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basicaer/qasm_simulator.py"
    },
    {
        "api_name": "_set_options",
        "full_api_name": "QasmSimulatorPy._set_options",
        "api_description": "Set the backend options for all experiments in a qobj",
        "api_signature": "_set_options(self, qobj_config, backend_options)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basicaer/qasm_simulator.py"
    },
    {
        "api_name": "_initialize_statevector",
        "full_api_name": "QasmSimulatorPy._initialize_statevector",
        "api_description": "Set the initial statevector for simulation",
        "api_signature": "_initialize_statevector(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basicaer/qasm_simulator.py"
    },
    {
        "api_name": "_get_statevector",
        "full_api_name": "QasmSimulatorPy._get_statevector",
        "api_description": "Return the current statevector",
        "api_signature": "_get_statevector(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basicaer/qasm_simulator.py"
    },
    {
        "api_name": "_validate_measure_sampling",
        "full_api_name": "QasmSimulatorPy._validate_measure_sampling",
        "api_description": "Determine if measure sampling is allowed for an experiment\n\nArgs:\n    experiment (QasmQobjExperiment): a qobj experiment.",
        "api_signature": "_validate_measure_sampling(self, experiment)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basicaer/qasm_simulator.py"
    },
    {
        "api_name": "run",
        "full_api_name": "QasmSimulatorPy.run",
        "api_description": "Run on the backend.\n\nArgs:\n    run_input (QuantumCircuit or list): payload of the experiment\n    backend_options (dict): backend options\n\nReturns:\n    BasicAerJob: derived from BaseJob\n\nAdditional Information:\n    backend_options: Is a dict of options for the backend. It may contain\n        * \"initial_statevector\": vector_like\n\n    The \"initial_statevector\" option specifies a custom initial\n    initial statevector for the simulator to be used instead of the all\n    zero state. This size of this vector must be correct for the number\n    of qubits in ``run_input`` parameter.\n\n    Example::\n\n        backend_options = {\n            \"initial_statevector\": np.array([1, 0, 0, 1j]) / np.sqrt(2),\n        }",
        "api_signature": "run(self, run_input)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basicaer/qasm_simulator.py"
    },
    {
        "api_name": "_run_job",
        "full_api_name": "QasmSimulatorPy._run_job",
        "api_description": "Run experiments in qobj\n\nArgs:\n    job_id (str): unique id for the job.\n    qobj (Qobj): job description\n\nReturns:\n    Result: Result object",
        "api_signature": "_run_job(self, job_id, qobj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basicaer/qasm_simulator.py"
    },
    {
        "api_name": "run_experiment",
        "full_api_name": "QasmSimulatorPy.run_experiment",
        "api_description": "Run an experiment (circuit) and return a single experiment result.\n\nArgs:\n    experiment (QasmQobjExperiment): experiment from qobj experiments list\n\nReturns:\n     dict: A result dictionary which looks something like::\n\n        {\n        \"name\": name of this experiment (obtained from qobj.experiment header)\n        \"seed\": random seed used for simulation\n        \"shots\": number of shots used in the simulation\n        \"data\":\n            {\n            \"counts\": {'0x9: 5, ...},\n            \"memory\": ['0x9', '0xF', '0x1D', ..., '0x9']\n            },\n        \"status\": status string for the simulation\n        \"success\": boolean\n        \"time_taken\": simulation time of this single experiment\n        }\nRaises:\n    BasicAerError: if an error occurred.",
        "api_signature": "run_experiment(self, experiment)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basicaer/qasm_simulator.py"
    },
    {
        "api_name": "_validate",
        "full_api_name": "QasmSimulatorPy._validate",
        "api_description": "Semantic validations of the qobj which cannot be done via schemas.",
        "api_signature": "_validate(self, qobj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basicaer/qasm_simulator.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "StatevectorSimulatorPy.__init__",
        "api_description": "",
        "api_signature": "__init__(self, configuration, provider)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basicaer/statevector_simulator.py"
    },
    {
        "api_name": "_validate",
        "full_api_name": "StatevectorSimulatorPy._validate",
        "api_description": "Semantic validations of the qobj which cannot be done via schemas.\nSome of these may later move to backend schemas.\n\n1. No shots\n2. No measurements in the middle",
        "api_signature": "_validate(self, qobj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basicaer/statevector_simulator.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BasicAerProvider.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basicaer/basicaerprovider.py"
    },
    {
        "api_name": "get_backend",
        "full_api_name": "BasicAerProvider.get_backend",
        "api_description": "",
        "api_signature": "get_backend(self, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basicaer/basicaerprovider.py"
    },
    {
        "api_name": "backends",
        "full_api_name": "BasicAerProvider.backends",
        "api_description": "",
        "api_signature": "backends(self, name, filters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basicaer/basicaerprovider.py"
    },
    {
        "api_name": "_deprecated_backend_names",
        "full_api_name": "BasicAerProvider._deprecated_backend_names",
        "api_description": "Returns deprecated backend names.",
        "api_signature": "_deprecated_backend_names()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basicaer/basicaerprovider.py"
    },
    {
        "api_name": "_verify_backends",
        "full_api_name": "BasicAerProvider._verify_backends",
        "api_description": "Return the Basic Aer backends in `BACKENDS` that are\neffectively available (as some of them might depend on the presence\nof an optional dependency or on the existence of a binary).\n\nReturns:\n    dict[str:Backend]: a dict of Basic Aer backend instances for\n        the backends that could be instantiated, keyed by backend name.",
        "api_signature": "_verify_backends(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basicaer/basicaerprovider.py"
    },
    {
        "api_name": "_get_backend_instance",
        "full_api_name": "BasicAerProvider._get_backend_instance",
        "api_description": "Return an instance of a backend from its class.\n\nArgs:\n    backend_cls (class): backend class.\nReturns:\n    Backend: a backend instance.\nRaises:\n    QiskitError: if the backend could not be instantiated.",
        "api_signature": "_get_backend_instance(self, backend_cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basicaer/basicaerprovider.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "BasicAerProvider.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basicaer/basicaerprovider.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BasicAerJob.__init__",
        "api_description": "",
        "api_signature": "__init__(self, backend, job_id, result)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basicaer/basicaerjob.py"
    },
    {
        "api_name": "submit",
        "full_api_name": "BasicAerJob.submit",
        "api_description": "Submit the job to the backend for execution.\n\nRaises:\n    JobError: if trying to re-submit the job.",
        "api_signature": "submit(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basicaer/basicaerjob.py"
    },
    {
        "api_name": "result",
        "full_api_name": "BasicAerJob.result",
        "api_description": "Get job result .\n\nReturns:\n    qiskit.result.Result: Result object",
        "api_signature": "result(self, timeout)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basicaer/basicaerjob.py"
    },
    {
        "api_name": "status",
        "full_api_name": "BasicAerJob.status",
        "api_description": "Gets the status of the job by querying the Python's future\n\nReturns:\n    qiskit.providers.JobStatus: The current JobStatus",
        "api_signature": "status(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basicaer/basicaerjob.py"
    },
    {
        "api_name": "backend",
        "full_api_name": "BasicAerJob.backend",
        "api_description": "Return the instance of the backend used for this job.",
        "api_signature": "backend(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basicaer/basicaerjob.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "UnitarySimulatorPy.__init__",
        "api_description": "",
        "api_signature": "__init__(self, configuration, provider)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basicaer/unitary_simulator.py"
    },
    {
        "api_name": "_default_options",
        "full_api_name": "UnitarySimulatorPy._default_options",
        "api_description": "",
        "api_signature": "_default_options(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basicaer/unitary_simulator.py"
    },
    {
        "api_name": "_add_unitary",
        "full_api_name": "UnitarySimulatorPy._add_unitary",
        "api_description": "Apply an N-qubit unitary matrix.\n\nArgs:\n    gate (matrix_like): an N-qubit unitary matrix\n    qubits (list): the list of N-qubits.",
        "api_signature": "_add_unitary(self, gate, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basicaer/unitary_simulator.py"
    },
    {
        "api_name": "_validate_initial_unitary",
        "full_api_name": "UnitarySimulatorPy._validate_initial_unitary",
        "api_description": "Validate an initial unitary matrix",
        "api_signature": "_validate_initial_unitary(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basicaer/unitary_simulator.py"
    },
    {
        "api_name": "_set_options",
        "full_api_name": "UnitarySimulatorPy._set_options",
        "api_description": "Set the backend options for all experiments in a qobj",
        "api_signature": "_set_options(self, qobj_config, backend_options)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basicaer/unitary_simulator.py"
    },
    {
        "api_name": "_initialize_unitary",
        "full_api_name": "UnitarySimulatorPy._initialize_unitary",
        "api_description": "Set the initial unitary for simulation",
        "api_signature": "_initialize_unitary(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basicaer/unitary_simulator.py"
    },
    {
        "api_name": "_get_unitary",
        "full_api_name": "UnitarySimulatorPy._get_unitary",
        "api_description": "Return the current unitary",
        "api_signature": "_get_unitary(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basicaer/unitary_simulator.py"
    },
    {
        "api_name": "run",
        "full_api_name": "UnitarySimulatorPy.run",
        "api_description": "Run qobj asynchronously.\n\nArgs:\n    qobj (Qobj): payload of the experiment\n    backend_options (dict): backend options\n\nReturns:\n    BasicAerJob: derived from BaseJob\n\nAdditional Information::\n\n    backend_options: Is a dict of options for the backend. It may contain\n        * \"initial_unitary\": matrix_like\n        * \"chop_threshold\": double\n\n    The \"initial_unitary\" option specifies a custom initial unitary\n    matrix for the simulator to be used instead of the identity\n    matrix. This size of this matrix must be correct for the number\n    of qubits inall experiments in the qobj.\n\n    The \"chop_threshold\" option specifies a truncation value for\n    setting small values to zero in the output unitary. The default\n    value is 1e-15.\n\n    Example::\n\n        backend_options = {\n            \"initial_unitary\": np.array([[1, 0, 0, 0],\n                                         [0, 0, 0, 1],\n                                         [0, 0, 1, 0],\n                                         [0, 1, 0, 0]])\n            \"chop_threshold\": 1e-15\n        }",
        "api_signature": "run(self, qobj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basicaer/unitary_simulator.py"
    },
    {
        "api_name": "_run_job",
        "full_api_name": "UnitarySimulatorPy._run_job",
        "api_description": "Run experiments in qobj.\n\nArgs:\n    job_id (str): unique id for the job.\n    qobj (Qobj): job description\n\nReturns:\n    Result: Result object",
        "api_signature": "_run_job(self, job_id, qobj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basicaer/unitary_simulator.py"
    },
    {
        "api_name": "run_experiment",
        "full_api_name": "UnitarySimulatorPy.run_experiment",
        "api_description": "Run an experiment (circuit) and return a single experiment result.\n\nArgs:\n    experiment (QasmQobjExperiment): experiment from qobj experiments list\n\nReturns:\n    dict: A result dictionary which looks something like::\n\n        {\n        \"name\": name of this experiment (obtained from qobj.experiment header)\n        \"seed\": random seed used for simulation\n        \"shots\": number of shots used in the simulation\n        \"data\":\n            {\n            \"unitary\": [[[0.0, 0.0], [1.0, 0.0]],\n                        [[1.0, 0.0], [0.0, 0.0]]]\n            },\n        \"status\": status string for the simulation\n        \"success\": boolean\n        \"time taken\": simulation time of this single experiment\n        }\n\nRaises:\n    BasicAerError: if the number of qubits in the circuit is greater than 24.  Note that the\n        practical qubit limit is much lower than 24.",
        "api_signature": "run_experiment(self, experiment)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basicaer/unitary_simulator.py"
    },
    {
        "api_name": "_validate",
        "full_api_name": "UnitarySimulatorPy._validate",
        "api_description": "Semantic validations of the qobj which cannot be done via schemas.\nSome of these may later move to backend schemas.\n1. No shots\n2. No measurements in the middle",
        "api_signature": "_validate(self, qobj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basicaer/unitary_simulator.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "GateConfig.__init__",
        "api_description": "Initialize a GateConfig object\n\nArgs:\n    name (str): the gate name as it will be referred to in OpenQASM.\n    parameters (list): variable names for the gate parameters (if any)\n                       as a list of strings.\n    qasm_def (str): definition of this gate in terms of OpenQASM 2 primitives U and CX.\n    coupling_map (list): An optional coupling map for the gate. In\n        the form of a list of lists of integers representing the qubit\n        groupings which are coupled by this gate.\n    latency_map (list): An optional map of latency for the gate. In the\n        the form of a list of lists of integers of either 0 or 1\n        representing an array of dimension\n        len(coupling_map) X n_registers that specifies the register\n        latency (1: fast, 0: slow) conditional operations on the gate\n    conditional (bool): Optionally specify whether this gate supports\n        conditional operations (true/false). If this is not specified,\n        then the gate inherits the conditional property of the backend.\n    description (str): Description of the gate operation",
        "api_signature": "__init__(self, name, parameters, qasm_def, coupling_map, latency_map, conditional, description)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendconfiguration.py"
    },
    {
        "api_name": "from_dict",
        "full_api_name": "GateConfig.from_dict",
        "api_description": "Create a new GateConfig object from a dictionary.\n\nArgs:\n    data (dict): A dictionary representing the GateConfig to create.\n                 It will be in the same format as output by\n                 :func:`to_dict`.\n\nReturns:\n    GateConfig: The GateConfig from the input dictionary.",
        "api_signature": "from_dict(cls, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendconfiguration.py"
    },
    {
        "api_name": "to_dict",
        "full_api_name": "GateConfig.to_dict",
        "api_description": "Return a dictionary format representation of the GateConfig.\n\nReturns:\n    dict: The dictionary form of the GateConfig.",
        "api_signature": "to_dict(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendconfiguration.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "GateConfig.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendconfiguration.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "GateConfig.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendconfiguration.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "UchannelLO.__init__",
        "api_description": "Initialize a UchannelLOSchema object\n\nArgs:\n    q (int): Qubit that scale corresponds too. Must be >= 0.\n    scale (complex): Scale factor for qubit frequency.\n\nRaises:\n    QiskitError: If q is < 0",
        "api_signature": "__init__(self, q, scale)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendconfiguration.py"
    },
    {
        "api_name": "from_dict",
        "full_api_name": "UchannelLO.from_dict",
        "api_description": "Create a new UchannelLO object from a dictionary.\n\nArgs:\n    data (dict): A dictionary representing the UChannelLO to\n        create. It will be in the same format as output by\n        :func:`to_dict`.\n\nReturns:\n    UchannelLO: The UchannelLO from the input dictionary.",
        "api_signature": "from_dict(cls, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendconfiguration.py"
    },
    {
        "api_name": "to_dict",
        "full_api_name": "UchannelLO.to_dict",
        "api_description": "Return a dictionary format representation of the UChannelLO.\n\nReturns:\n    dict: The dictionary form of the UChannelLO.",
        "api_signature": "to_dict(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendconfiguration.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "UchannelLO.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendconfiguration.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "UchannelLO.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendconfiguration.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QasmBackendConfiguration.__init__",
        "api_description": "Initialize a QasmBackendConfiguration Object\n\nArgs:\n    backend_name (str): The backend name\n    backend_version (str): The backend version in the form X.Y.Z\n    n_qubits (int): the number of qubits for the backend\n    basis_gates (list): The list of strings for the basis gates of the\n        backends\n    gates (list): The list of GateConfig objects for the basis gates of\n        the backend\n    local (bool): True if the backend is local or False if remote\n    simulator (bool): True if the backend is a simulator\n    conditional (bool): True if the backend supports conditional\n        operations\n    open_pulse (bool): True if the backend supports OpenPulse\n    memory (bool): True if the backend supports memory\n    max_shots (int): The maximum number of shots allowed on the backend\n    coupling_map (list): The coupling map for the device\n    supported_instructions (List[str]): Instructions supported by the backend.\n    dynamic_reprate_enabled (bool): whether delay between programs can be set dynamically\n        (ie via ``rep_delay``). Defaults to False.\n    rep_delay_range (List[float]): 2d list defining supported range of repetition\n        delays for backend in \u03bcs. First entry is lower end of the range, second entry is\n        higher end of the range. Optional, but will be specified when\n        ``dynamic_reprate_enabled=True``.\n    default_rep_delay (float): Value of ``rep_delay`` if not specified by user and\n        ``dynamic_reprate_enabled=True``.\n    max_experiments (int): The maximum number of experiments per job\n    sample_name (str): Sample name for the backend\n    n_registers (int): Number of register slots available for feedback\n        (if conditional is True)\n    register_map (list): An array of dimension n_qubits X\n        n_registers that specifies whether a qubit can store a\n        measurement in a certain register slot.\n    configurable (bool): True if the backend is configurable, if the\n        backend is a simulator\n    credits_required (bool): True if backend requires credits to run a\n        job.\n    online_date (datetime.datetime): The date that the device went online\n    display_name (str): Alternate name field for the backend\n    description (str): A description for the backend\n    tags (list): A list of string tags to describe the backend\n    dt (float): Qubit drive channel timestep in nanoseconds.\n    dtm (float): Measurement drive channel timestep in nanoseconds.\n    processor_type (dict): Processor type for this backend. A dictionary of the\n        form ``{\"family\": <str>, \"revision\": <str>, segment: <str>}`` such as\n        ``{\"family\": \"Canary\", \"revision\": \"1.0\", segment: \"A\"}``.\n\n        - family: Processor family of this backend.\n        - revision: Revision version of this processor.\n        - segment: Segment this processor belongs to within a larger chip.\n    parametric_pulses (list): A list of pulse shapes which are supported on the backend.\n        For example: ``['gaussian', 'constant']``\n\n    **kwargs: optional fields",
        "api_signature": "__init__(self, backend_name, backend_version, n_qubits, basis_gates, gates, local, simulator, conditional, open_pulse, memory, max_shots, coupling_map, supported_instructions, dynamic_reprate_enabled, rep_delay_range, default_rep_delay, max_experiments, sample_name, n_registers, register_map, configurable, credits_required, online_date, display_name, description, tags, dt, dtm, processor_type, parametric_pulses)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendconfiguration.py"
    },
    {
        "api_name": "__getattr__",
        "full_api_name": "QasmBackendConfiguration.__getattr__",
        "api_description": "",
        "api_signature": "__getattr__(self, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendconfiguration.py"
    },
    {
        "api_name": "from_dict",
        "full_api_name": "QasmBackendConfiguration.from_dict",
        "api_description": "Create a new GateConfig object from a dictionary.\n\nArgs:\n    data (dict): A dictionary representing the GateConfig to create.\n                 It will be in the same format as output by\n                 :func:`to_dict`.\nReturns:\n    GateConfig: The GateConfig from the input dictionary.",
        "api_signature": "from_dict(cls, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendconfiguration.py"
    },
    {
        "api_name": "to_dict",
        "full_api_name": "QasmBackendConfiguration.to_dict",
        "api_description": "Return a dictionary format representation of the GateConfig.\n\nReturns:\n    dict: The dictionary form of the GateConfig.",
        "api_signature": "to_dict(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendconfiguration.py"
    },
    {
        "api_name": "num_qubits",
        "full_api_name": "QasmBackendConfiguration.num_qubits",
        "api_description": "Returns the number of qubits.\n\nIn future, `n_qubits` should be replaced in favor of `num_qubits` for consistent use\nthroughout Qiskit. Until this is properly refactored, this property serves as intermediate\nsolution.",
        "api_signature": "num_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendconfiguration.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "QasmBackendConfiguration.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendconfiguration.py"
    },
    {
        "api_name": "__contains__",
        "full_api_name": "QasmBackendConfiguration.__contains__",
        "api_description": "",
        "api_signature": "__contains__(self, item)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendconfiguration.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PulseBackendConfiguration.__init__",
        "api_description": "Initialize a backend configuration that contains all the extra configuration that is made\navailable for OpenPulse backends.\n\nArgs:\n    backend_name: backend name.\n    backend_version: backend version in the form X.Y.Z.\n    n_qubits: number of qubits.\n    basis_gates: list of basis gates names on the backend.\n    gates: list of basis gates on the backend.\n    local: backend is local or remote.\n    simulator: backend is a simulator.\n    conditional: backend supports conditional operations.\n    open_pulse: backend supports open pulse.\n    memory: backend supports memory.\n    max_shots: maximum number of shots supported.\n    coupling_map (list): The coupling map for the device\n    n_uchannels: Number of u-channels.\n    u_channel_lo: U-channel relationship on device los.\n    meas_levels: Supported measurement levels.\n    qubit_lo_range: Qubit lo ranges for each qubit with form (min, max) in GHz.\n    meas_lo_range: Measurement lo ranges for each qubit with form (min, max) in GHz.\n    dt: Qubit drive channel timestep in nanoseconds.\n    dtm: Measurement drive channel timestep in nanoseconds.\n    rep_times: Supported repetition times (program execution time) for backend in \u03bcs.\n    meas_kernels: Supported measurement kernels.\n    discriminators: Supported discriminators.\n    hamiltonian: An optional dictionary with fields characterizing the system hamiltonian.\n    channel_bandwidth (list): Bandwidth of all channels\n        (qubit, measurement, and U)\n    acquisition_latency (list): Array of dimension\n        n_qubits x n_registers. Latency (in units of dt) to write a\n        measurement result from qubit n into register slot m.\n    conditional_latency (list): Array of dimension n_channels\n        [d->u->m] x n_registers. Latency (in units of dt) to do a\n        conditional operation on channel n from register slot m\n    meas_map (list): Grouping of measurement which are multiplexed\n    max_experiments (int): The maximum number of experiments per job\n    sample_name (str): Sample name for the backend\n    n_registers (int): Number of register slots available for feedback\n        (if conditional is True)\n    register_map (list): An array of dimension n_qubits X\n        n_registers that specifies whether a qubit can store a\n        measurement in a certain register slot.\n    configurable (bool): True if the backend is configurable, if the\n        backend is a simulator\n    credits_required (bool): True if backend requires credits to run a\n        job.\n    online_date (datetime.datetime): The date that the device went online\n    display_name (str): Alternate name field for the backend\n    description (str): A description for the backend\n    tags (list): A list of string tags to describe the backend\n    channels: An optional dictionary containing information of each channel -- their\n        purpose, type, and qubits operated on.\n    **kwargs: Optional fields.",
        "api_signature": "__init__(self, backend_name, backend_version, n_qubits, basis_gates, gates, local, simulator, conditional, open_pulse, memory, max_shots, coupling_map, n_uchannels, u_channel_lo, meas_levels, qubit_lo_range, meas_lo_range, dt, dtm, rep_times, meas_kernels, discriminators, hamiltonian, channel_bandwidth, acquisition_latency, conditional_latency, meas_map, max_experiments, sample_name, n_registers, register_map, configurable, credits_required, online_date, display_name, description, tags, channels)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendconfiguration.py"
    },
    {
        "api_name": "from_dict",
        "full_api_name": "PulseBackendConfiguration.from_dict",
        "api_description": "Create a new GateConfig object from a dictionary.\n\nArgs:\n    data (dict): A dictionary representing the GateConfig to create.\n        It will be in the same format as output by :func:`to_dict`.\n\nReturns:\n    GateConfig: The GateConfig from the input dictionary.",
        "api_signature": "from_dict(cls, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendconfiguration.py"
    },
    {
        "api_name": "to_dict",
        "full_api_name": "PulseBackendConfiguration.to_dict",
        "api_description": "Return a dictionary format representation of the GateConfig.\n\nReturns:\n    dict: The dictionary form of the GateConfig.",
        "api_signature": "to_dict(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendconfiguration.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "PulseBackendConfiguration.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendconfiguration.py"
    },
    {
        "api_name": "sample_rate",
        "full_api_name": "PulseBackendConfiguration.sample_rate",
        "api_description": "Sample rate of the signal channels in Hz (1/dt).",
        "api_signature": "sample_rate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendconfiguration.py"
    },
    {
        "api_name": "control_channels",
        "full_api_name": "PulseBackendConfiguration.control_channels",
        "api_description": "Return the control channels",
        "api_signature": "control_channels(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendconfiguration.py"
    },
    {
        "api_name": "drive",
        "full_api_name": "PulseBackendConfiguration.drive",
        "api_description": "Return the drive channel for the given qubit.\n\nRaises:\n    BackendConfigurationError: If the qubit is not a part of the system.\n\nReturns:\n    Qubit drive channel.",
        "api_signature": "drive(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendconfiguration.py"
    },
    {
        "api_name": "measure",
        "full_api_name": "PulseBackendConfiguration.measure",
        "api_description": "Return the measure stimulus channel for the given qubit.\n\nRaises:\n    BackendConfigurationError: If the qubit is not a part of the system.\nReturns:\n    Qubit measurement stimulus line.",
        "api_signature": "measure(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendconfiguration.py"
    },
    {
        "api_name": "acquire",
        "full_api_name": "PulseBackendConfiguration.acquire",
        "api_description": "Return the acquisition channel for the given qubit.\n\nRaises:\n    BackendConfigurationError: If the qubit is not a part of the system.\nReturns:\n    Qubit measurement acquisition line.",
        "api_signature": "acquire(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendconfiguration.py"
    },
    {
        "api_name": "control",
        "full_api_name": "PulseBackendConfiguration.control",
        "api_description": "Return the secondary drive channel for the given qubit -- typically utilized for\ncontrolling multiqubit interactions. This channel is derived from other channels.\n\nArgs:\n    qubits: Tuple or list of qubits of the form `(control_qubit, target_qubit)`.\n\nRaises:\n    BackendConfigurationError: If the ``qubits`` is not a part of the system or if\n        the backend does not provide `channels` information in its configuration.\n\nReturns:\n    List of control channels.",
        "api_signature": "control(self, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendconfiguration.py"
    },
    {
        "api_name": "get_channel_qubits",
        "full_api_name": "PulseBackendConfiguration.get_channel_qubits",
        "api_description": "Return a list of indices for qubits which are operated on directly by the given ``channel``.\n\nRaises:\n    BackendConfigurationError: If ``channel`` is not a found or if\n        the backend does not provide `channels` information in its configuration.\n\nReturns:\n    List of qubits operated on my the given ``channel``.",
        "api_signature": "get_channel_qubits(self, channel)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendconfiguration.py"
    },
    {
        "api_name": "get_qubit_channels",
        "full_api_name": "PulseBackendConfiguration.get_qubit_channels",
        "api_description": "Return a list of channels which operate on the given ``qubit``.\n\nRaises:\n    BackendConfigurationError: If ``qubit`` is not a found or if\n        the backend does not provide `channels` information in its configuration.\n\nReturns:\n    List of ``Channel``\\s operated on my the given ``qubit``.",
        "api_signature": "get_qubit_channels(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendconfiguration.py"
    },
    {
        "api_name": "describe",
        "full_api_name": "PulseBackendConfiguration.describe",
        "api_description": "Return a basic description of the channel dependency. Derived channels are given weights\nwhich describe how their frames are linked to other frames.\nFor instance, the backend could be configured with this setting::\n\n    u_channel_lo = [\n        [UchannelLO(q=0, scale=1. + 0.j)],\n        [UchannelLO(q=0, scale=-1. + 0.j), UchannelLO(q=1, scale=1. + 0.j)]\n    ]\n\nThen, this method can be used as follows::\n\n    backend.configuration().describe(ControlChannel(1))\n    >>> {DriveChannel(0): -1, DriveChannel(1): 1}\n\nArgs:\n    channel: The derived channel to describe.\nRaises:\n    BackendConfigurationError: If channel is not a ControlChannel.\nReturns:\n    Control channel derivations.",
        "api_signature": "describe(self, channel)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendconfiguration.py"
    },
    {
        "api_name": "_parse_channels",
        "full_api_name": "PulseBackendConfiguration._parse_channels",
        "api_description": "Generates a dictionaries of ``Channel``\\s, and tuple of qubit(s) they operate on.\n\nArgs:\n    channels: An optional dictionary containing information of each channel -- their\n        purpose, type, and qubits operated on.\n\nReturns:\n    qubit_channel_map: Dictionary mapping tuple of qubit(s) to list of ``Channel``\\s.\n    channel_qubit_map: Dictionary mapping ``Channel`` to list of qubit(s).\n    control_channels: Dictionary mapping tuple of qubit(s), to list of\n        ``ControlChannel``\\s.",
        "api_signature": "_parse_channels(self, channels)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendconfiguration.py"
    },
    {
        "api_name": "_get_channel_prefix_index",
        "full_api_name": "PulseBackendConfiguration._get_channel_prefix_index",
        "api_description": "Return channel prefix and index from the given ``channel``.\n\nArgs:\n    channel: Name of channel.\n\nRaises:\n    BackendConfigurationError: If invalid channel name is found.\n\nReturn:\n    Channel name and index. For example, if ``channel=acquire0``, this method\n    returns ``acquire`` and ``0``.",
        "api_signature": "_get_channel_prefix_index(self, channel)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendconfiguration.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "JobStatus.__init__",
        "api_description": "",
        "api_signature": "__init__(self, job_id, status, status_msg)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/jobstatus.py"
    },
    {
        "api_name": "from_dict",
        "full_api_name": "JobStatus.from_dict",
        "api_description": "Create a new JobStatus object from a dictionary.\n\nArgs:\n    data (dict): A dictionary representing the JobStatus to create.\n                 It will be in the same format as output by\n                 :meth:`to_dict`.\n\nReturns:\n    JobStatus: The ``JobStatus`` from the input dictionary.",
        "api_signature": "from_dict(cls, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/jobstatus.py"
    },
    {
        "api_name": "to_dict",
        "full_api_name": "JobStatus.to_dict",
        "api_description": "Return a dictionary format representation of the JobStatus.\n\nReturns:\n    dict: The dictionary form of the JobStatus.",
        "api_signature": "to_dict(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/jobstatus.py"
    },
    {
        "api_name": "__getattr__",
        "full_api_name": "JobStatus.__getattr__",
        "api_description": "",
        "api_signature": "__getattr__(self, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/jobstatus.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Nduv.__init__",
        "api_description": "Initialize a new name-date-unit-value object\n\nArgs:\n    date (datetime.datetime): Date field\n    name (str): Name field\n    unit (str): Nduv unit\n    value (float): The value of the Nduv",
        "api_signature": "__init__(self, date, name, unit, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendproperties.py"
    },
    {
        "api_name": "from_dict",
        "full_api_name": "Nduv.from_dict",
        "api_description": "Create a new Nduv object from a dictionary.\n\nArgs:\n    data (dict): A dictionary representing the Nduv to create.\n                 It will be in the same format as output by\n                 :func:`to_dict`.\n\nReturns:\n    Nduv: The Nduv from the input dictionary.",
        "api_signature": "from_dict(cls, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendproperties.py"
    },
    {
        "api_name": "to_dict",
        "full_api_name": "Nduv.to_dict",
        "api_description": "Return a dictionary format representation of the object.\n\nReturns:\n    dict: The dictionary form of the Nduv.",
        "api_signature": "to_dict(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendproperties.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "Nduv.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendproperties.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "Nduv.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendproperties.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "GateProperties.__init__",
        "api_description": "Initialize a new :class:`GateProperties` object\n\nArgs:\n    qubits (list): A list of integers representing qubits\n    gate (str): The gates name\n    parameters (list): List of :class:`Nduv` objects for the\n        name-date-unit-value for the gate\n    kwargs: Optional additional fields",
        "api_signature": "__init__(self, qubits, gate, parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendproperties.py"
    },
    {
        "api_name": "__getattr__",
        "full_api_name": "GateProperties.__getattr__",
        "api_description": "",
        "api_signature": "__getattr__(self, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendproperties.py"
    },
    {
        "api_name": "from_dict",
        "full_api_name": "GateProperties.from_dict",
        "api_description": "Create a new Gate object from a dictionary.\n\nArgs:\n    data (dict): A dictionary representing the Gate to create.\n                 It will be in the same format as output by\n                 :func:`to_dict`.\n\nReturns:\n    GateProperties: The Nduv from the input dictionary.",
        "api_signature": "from_dict(cls, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendproperties.py"
    },
    {
        "api_name": "to_dict",
        "full_api_name": "GateProperties.to_dict",
        "api_description": "Return a dictionary format representation of the BackendStatus.\n\nReturns:\n    dict: The dictionary form of the Gate.",
        "api_signature": "to_dict(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendproperties.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "GateProperties.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendproperties.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BackendProperties.__init__",
        "api_description": "Initialize a BackendProperties instance.\n\nArgs:\n    backend_name (str): Backend name.\n    backend_version (str): Backend version in the form X.Y.Z.\n    last_update_date (datetime.datetime or str): Last date/time that a property was\n        updated. If specified as a ``str``, it must be in ISO format.\n    qubits (list): System qubit parameters as a list of lists of\n                   :class:`Nduv` objects\n    gates (list): System gate parameters as a list of :class:`GateProperties`\n                  objects\n    general (list): General parameters as a list of :class:`Nduv`\n                    objects\n    kwargs: optional additional fields",
        "api_signature": "__init__(self, backend_name, backend_version, last_update_date, qubits, gates, general)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendproperties.py"
    },
    {
        "api_name": "__getattr__",
        "full_api_name": "BackendProperties.__getattr__",
        "api_description": "",
        "api_signature": "__getattr__(self, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendproperties.py"
    },
    {
        "api_name": "from_dict",
        "full_api_name": "BackendProperties.from_dict",
        "api_description": "Create a new BackendProperties object from a dictionary.\n\nArgs:\n    data (dict): A dictionary representing the BackendProperties to create.  It will be in\n        the same format as output by :meth:`to_dict`.\n\nReturns:\n    BackendProperties: The BackendProperties from the input dictionary.",
        "api_signature": "from_dict(cls, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendproperties.py"
    },
    {
        "api_name": "to_dict",
        "full_api_name": "BackendProperties.to_dict",
        "api_description": "Return a dictionary format representation of the BackendProperties.\n\nReturns:\n    dict: The dictionary form of the BackendProperties.",
        "api_signature": "to_dict(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendproperties.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "BackendProperties.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendproperties.py"
    },
    {
        "api_name": "gate_property",
        "full_api_name": "BackendProperties.gate_property",
        "api_description": "Return the property of the given gate.\n\nArgs:\n    gate: Name of the gate.\n    qubits: The qubit to find the property for.\n    name: Optionally used to specify which gate property to return.\n\nReturns:\n    Gate property as a tuple of the value and the time it was measured.\n\nRaises:\n    BackendPropertyError: If the property is not found or name is\n                          specified but qubit is not.",
        "api_signature": "gate_property(self, gate, qubits, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendproperties.py"
    },
    {
        "api_name": "faulty_qubits",
        "full_api_name": "BackendProperties.faulty_qubits",
        "api_description": "Return a list of faulty qubits.",
        "api_signature": "faulty_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendproperties.py"
    },
    {
        "api_name": "faulty_gates",
        "full_api_name": "BackendProperties.faulty_gates",
        "api_description": "Return a list of faulty gates.",
        "api_signature": "faulty_gates(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendproperties.py"
    },
    {
        "api_name": "is_gate_operational",
        "full_api_name": "BackendProperties.is_gate_operational",
        "api_description": "Return the operational status of the given gate.\n\nArgs:\n    gate: Name of the gate.\n    qubits: The qubit to find the operational status for.\n\nReturns:\n    bool: Operational status of the given gate. True if the gate is operational,\n    False otherwise.",
        "api_signature": "is_gate_operational(self, gate, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendproperties.py"
    },
    {
        "api_name": "gate_error",
        "full_api_name": "BackendProperties.gate_error",
        "api_description": "Return gate error estimates from backend properties.\n\nArgs:\n    gate: The gate for which to get the error.\n    qubits: The specific qubits for the gate.\n\nReturns:\n    Gate error of the given gate and qubit(s).",
        "api_signature": "gate_error(self, gate, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendproperties.py"
    },
    {
        "api_name": "gate_length",
        "full_api_name": "BackendProperties.gate_length",
        "api_description": "Return the duration of the gate in units of seconds.\n\nArgs:\n    gate: The gate for which to get the duration.\n    qubits: The specific qubits for the gate.\n\nReturns:\n    Gate length of the given gate and qubit(s).",
        "api_signature": "gate_length(self, gate, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendproperties.py"
    },
    {
        "api_name": "qubit_property",
        "full_api_name": "BackendProperties.qubit_property",
        "api_description": "Return the property of the given qubit.\n\nArgs:\n    qubit: The property to look for.\n    name: Optionally used to specify within the hierarchy which property to return.\n\nReturns:\n    Qubit property as a tuple of the value and the time it was measured.\n\nRaises:\n    BackendPropertyError: If the property is not found.",
        "api_signature": "qubit_property(self, qubit, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendproperties.py"
    },
    {
        "api_name": "t1",
        "full_api_name": "BackendProperties.t1",
        "api_description": "Return the T1 time of the given qubit.\n\nArgs:\n    qubit: Qubit for which to return the T1 time of.\n\nReturns:\n    T1 time of the given qubit.",
        "api_signature": "t1(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendproperties.py"
    },
    {
        "api_name": "t2",
        "full_api_name": "BackendProperties.t2",
        "api_description": "Return the T2 time of the given qubit.\n\nArgs:\n    qubit: Qubit for which to return the T2 time of.\n\nReturns:\n    T2 time of the given qubit.",
        "api_signature": "t2(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendproperties.py"
    },
    {
        "api_name": "frequency",
        "full_api_name": "BackendProperties.frequency",
        "api_description": "Return the frequency of the given qubit.\n\nArgs:\n    qubit: Qubit for which to return frequency of.\n\nReturns:\n    Frequency of the given qubit.",
        "api_signature": "frequency(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendproperties.py"
    },
    {
        "api_name": "readout_error",
        "full_api_name": "BackendProperties.readout_error",
        "api_description": "Return the readout error of the given qubit.\n\nArgs:\n    qubit: Qubit for which to return the readout error of.\n\nReturn:\n    Readout error of the given qubit.",
        "api_signature": "readout_error(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendproperties.py"
    },
    {
        "api_name": "readout_length",
        "full_api_name": "BackendProperties.readout_length",
        "api_description": "Return the readout length [sec] of the given qubit.\n\nArgs:\n    qubit: Qubit for which to return the readout length of.\n\nReturn:\n    Readout length of the given qubit.",
        "api_signature": "readout_length(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendproperties.py"
    },
    {
        "api_name": "is_qubit_operational",
        "full_api_name": "BackendProperties.is_qubit_operational",
        "api_description": "Return the operational status of the given qubit.\n\nArgs:\n    qubit: Qubit for which to return operational status of.\n\nReturns:\n    Operational status of the given qubit.",
        "api_signature": "is_qubit_operational(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendproperties.py"
    },
    {
        "api_name": "_apply_prefix",
        "full_api_name": "BackendProperties._apply_prefix",
        "api_description": "Given a SI unit prefix and value, apply the prefix to convert to\nstandard SI unit.\n\nArgs:\n    value: The number to apply prefix to.\n    unit: String prefix.\n\nReturns:\n    Converted value.\n\nRaises:\n    BackendPropertyError: If the units aren't recognized.",
        "api_signature": "_apply_prefix(self, value, unit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendproperties.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "MeasurementKernel.__init__",
        "api_description": "Initialize a MeasurementKernel object\n\nArgs:\n    name (str): The name of the measurement kernel\n    params: The parameters of the measurement kernel",
        "api_signature": "__init__(self, name, params)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/pulsedefaults.py"
    },
    {
        "api_name": "to_dict",
        "full_api_name": "MeasurementKernel.to_dict",
        "api_description": "Return a dictionary format representation of the MeasurementKernel.\n\nReturns:\n    dict: The dictionary form of the MeasurementKernel.",
        "api_signature": "to_dict(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/pulsedefaults.py"
    },
    {
        "api_name": "from_dict",
        "full_api_name": "MeasurementKernel.from_dict",
        "api_description": "Create a new MeasurementKernel object from a dictionary.\n\nArgs:\n    data (dict): A dictionary representing the MeasurementKernel\n                 to create. It will be in the same format as output by\n                 :meth:`to_dict`.\n\nReturns:\n    MeasurementKernel: The MeasurementKernel from the input dictionary.",
        "api_signature": "from_dict(cls, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/pulsedefaults.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Discriminator.__init__",
        "api_description": "Initialize a Discriminator object\n\nArgs:\n    name (str): The name of the discriminator\n    params: The parameters of the discriminator",
        "api_signature": "__init__(self, name, params)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/pulsedefaults.py"
    },
    {
        "api_name": "to_dict",
        "full_api_name": "Discriminator.to_dict",
        "api_description": "Return a dictionary format representation of the Discriminator.\n\nReturns:\n    dict: The dictionary form of the Discriminator.",
        "api_signature": "to_dict(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/pulsedefaults.py"
    },
    {
        "api_name": "from_dict",
        "full_api_name": "Discriminator.from_dict",
        "api_description": "Create a new Discriminator object from a dictionary.\n\nArgs:\n    data (dict): A dictionary representing the Discriminator\n                 to create. It will be in the same format as output by\n                 :meth:`to_dict`.\n\nReturns:\n    Discriminator: The Discriminator from the input dictionary.",
        "api_signature": "from_dict(cls, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/pulsedefaults.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Command.__init__",
        "api_description": "Initialize a Command object\n\nArgs:\n    name (str): The name of the command\n    qubits: The qubits for the command\n    sequence (PulseQobjInstruction): The sequence for the Command\n    kwargs: Optional additional fields",
        "api_signature": "__init__(self, name, qubits, sequence)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/pulsedefaults.py"
    },
    {
        "api_name": "__getattr__",
        "full_api_name": "Command.__getattr__",
        "api_description": "",
        "api_signature": "__getattr__(self, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/pulsedefaults.py"
    },
    {
        "api_name": "to_dict",
        "full_api_name": "Command.to_dict",
        "api_description": "Return a dictionary format representation of the Command.\n\nReturns:\n    dict: The dictionary form of the Command.",
        "api_signature": "to_dict(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/pulsedefaults.py"
    },
    {
        "api_name": "from_dict",
        "full_api_name": "Command.from_dict",
        "api_description": "Create a new Command object from a dictionary.\n\nArgs:\n    data (dict): A dictionary representing the ``Command``\n                 to create. It will be in the same format as output by\n                 :meth:`to_dict`.\n\nReturns:\n    Command: The ``Command`` from the input dictionary.",
        "api_signature": "from_dict(cls, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/pulsedefaults.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PulseDefaults.__init__",
        "api_description": "Validate and reformat transport layer inputs to initialize.\nArgs:\n    qubit_freq_est: Estimated qubit frequencies in GHz.\n    meas_freq_est: Estimated measurement cavity frequencies in GHz.\n    buffer: Default buffer time (in units of dt) between pulses.\n    pulse_library: Pulse name and sample definitions.\n    cmd_def: Operation name and definition in terms of Commands.\n    meas_kernel: The measurement kernels\n    discriminator: The discriminators\n    **kwargs: Other attributes for the super class.",
        "api_signature": "__init__(self, qubit_freq_est, meas_freq_est, buffer, pulse_library, cmd_def, meas_kernel, discriminator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/pulsedefaults.py"
    },
    {
        "api_name": "__getattr__",
        "full_api_name": "PulseDefaults.__getattr__",
        "api_description": "",
        "api_signature": "__getattr__(self, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/pulsedefaults.py"
    },
    {
        "api_name": "to_dict",
        "full_api_name": "PulseDefaults.to_dict",
        "api_description": "Return a dictionary format representation of the PulseDefaults.\nReturns:\n    dict: The dictionary form of the PulseDefaults.",
        "api_signature": "to_dict(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/pulsedefaults.py"
    },
    {
        "api_name": "from_dict",
        "full_api_name": "PulseDefaults.from_dict",
        "api_description": "Create a new PulseDefaults object from a dictionary.\n\nArgs:\n    data (dict): A dictionary representing the PulseDefaults\n                 to create. It will be in the same format as output by\n                 :meth:`to_dict`.\nReturns:\n    PulseDefaults: The PulseDefaults from the input dictionary.",
        "api_signature": "from_dict(cls, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/pulsedefaults.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "PulseDefaults.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/pulsedefaults.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BackendStatus.__init__",
        "api_description": "Initialize a BackendStatus object\n\nArgs:\n    backend_name: The backend's name\n    backend_version: The backend's version of the form X.Y.Z\n    operational: True if the backend is operational\n    pending_jobs: The number of pending jobs on the backend\n    status_msg: The status msg for the backend\n\nRaises:\n    QiskitError: If the backend version is in an invalid format",
        "api_signature": "__init__(self, backend_name, backend_version, operational, pending_jobs, status_msg)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendstatus.py"
    },
    {
        "api_name": "from_dict",
        "full_api_name": "BackendStatus.from_dict",
        "api_description": "Create a new BackendStatus object from a dictionary.\n\nArgs:\n    data (dict): A dictionary representing the BaseBakend to create.\n                 It will be in the same format as output by\n                 :func:`to_dict`.\n\nReturns:\n    BackendStatus: The BackendStatus from the input dictionary.",
        "api_signature": "from_dict(cls, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendstatus.py"
    },
    {
        "api_name": "to_dict",
        "full_api_name": "BackendStatus.to_dict",
        "api_description": "Return a dictionary format representation of the BackendStatus.\n\nReturns:\n    dict: The dictionary form of the QobjHeader.",
        "api_signature": "to_dict(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendstatus.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "BackendStatus.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendstatus.py"
    },
    {
        "api_name": "_repr_html_",
        "full_api_name": "BackendStatus._repr_html_",
        "api_description": "Return html representation of the object\n\nReturns:\n    Representation used in Jupyter notebook and other IDE's that call the method",
        "api_signature": "_repr_html_(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendstatus.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "DAGCircuit.__init__",
        "api_description": "Create an empty circuit.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "wires",
        "full_api_name": "DAGCircuit.wires",
        "api_description": "Return a list of the wires in order.",
        "api_signature": "wires(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "node_counter",
        "full_api_name": "DAGCircuit.node_counter",
        "api_description": "Returns the number of nodes in the dag.",
        "api_signature": "node_counter(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "global_phase",
        "full_api_name": "DAGCircuit.global_phase",
        "api_description": "Return the global phase of the circuit.",
        "api_signature": "global_phase(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "global_phase",
        "full_api_name": "DAGCircuit.global_phase",
        "api_description": "Set the global phase of the circuit.\n\nArgs:\n    angle (float, ParameterExpression)",
        "api_signature": "global_phase(self, angle)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "calibrations",
        "full_api_name": "DAGCircuit.calibrations",
        "api_description": "Return calibration dictionary.\n\nThe custom pulse definition of a given gate is of the form\n    {'gate_name': {(qubits, params): schedule}}",
        "api_signature": "calibrations(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "calibrations",
        "full_api_name": "DAGCircuit.calibrations",
        "api_description": "Set the circuit calibration data from a dictionary of calibration definition.\n\nArgs:\n    calibrations (dict): A dictionary of input in the format\n        {'gate_name': {(qubits, gate_params): schedule}}",
        "api_signature": "calibrations(self, calibrations)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "add_calibration",
        "full_api_name": "DAGCircuit.add_calibration",
        "api_description": "Register a low-level, custom pulse definition for the given gate.\n\nArgs:\n    gate (Union[Gate, str]): Gate information.\n    qubits (Union[int, Tuple[int]]): List of qubits to be measured.\n    schedule (Schedule): Schedule information.\n    params (Optional[List[Union[float, Parameter]]]): A list of parameters.\n\nRaises:\n    Exception: if the gate is of type string and params is None.",
        "api_signature": "add_calibration(self, gate, qubits, schedule, params)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "_format",
        "full_api_name": "DAGCircuit._format",
        "api_description": "",
        "api_signature": "_format(operand)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "has_calibration_for",
        "full_api_name": "DAGCircuit.has_calibration_for",
        "api_description": "Return True if the dag has a calibration defined for the node operation. In this\ncase, the operation does not need to be translated to the device basis.",
        "api_signature": "has_calibration_for(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "remove_all_ops_named",
        "full_api_name": "DAGCircuit.remove_all_ops_named",
        "api_description": "Remove all operation nodes with the given name.",
        "api_signature": "remove_all_ops_named(self, opname)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "add_qubits",
        "full_api_name": "DAGCircuit.add_qubits",
        "api_description": "Add individual qubit wires.",
        "api_signature": "add_qubits(self, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "add_clbits",
        "full_api_name": "DAGCircuit.add_clbits",
        "api_description": "Add individual clbit wires.",
        "api_signature": "add_clbits(self, clbits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "add_qreg",
        "full_api_name": "DAGCircuit.add_qreg",
        "api_description": "Add all wires in a quantum register.",
        "api_signature": "add_qreg(self, qreg)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "add_creg",
        "full_api_name": "DAGCircuit.add_creg",
        "api_description": "Add all wires in a classical register.",
        "api_signature": "add_creg(self, creg)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "_add_wire",
        "full_api_name": "DAGCircuit._add_wire",
        "api_description": "Add a qubit or bit to the circuit.\n\nArgs:\n    wire (Bit): the wire to be added\n\n    This adds a pair of in and out nodes connected by an edge.\n\nRaises:\n    DAGCircuitError: if trying to add duplicate wire",
        "api_signature": "_add_wire(self, wire)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "find_bit",
        "full_api_name": "DAGCircuit.find_bit",
        "api_description": "Finds locations in the circuit, by mapping the Qubit and Clbit to positional index\nBitLocations is defined as: BitLocations = namedtuple(\"BitLocations\", (\"index\", \"registers\"))\n\nArgs:\n    bit (Bit): The bit to locate.\n\nReturns:\n    namedtuple(int, List[Tuple(Register, int)]): A 2-tuple. The first element (``index``)\n        contains the index at which the ``Bit`` can be found (in either\n        :obj:`~DAGCircuit.qubits`, :obj:`~DAGCircuit.clbits`, depending on its\n        type). The second element (``registers``) is a list of ``(register, index)``\n        pairs with an entry for each :obj:`~Register` in the circuit which contains the\n        :obj:`~Bit` (and the index in the :obj:`~Register` at which it can be found).\n\n  Raises:\n    DAGCircuitError: If the supplied :obj:`~Bit` was of an unknown type.\n    DAGCircuitError: If the supplied :obj:`~Bit` could not be found on the circuit.",
        "api_signature": "find_bit(self, bit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "remove_clbits",
        "full_api_name": "DAGCircuit.remove_clbits",
        "api_description": "Remove classical bits from the circuit. All bits MUST be idle.\nAny registers with references to at least one of the specified bits will\nalso be removed.\n\nArgs:\n    clbits (List[Clbit]): The bits to remove.\n\nRaises:\n    DAGCircuitError: a clbit is not a :obj:`.Clbit`, is not in the circuit,\n        or is not idle.",
        "api_signature": "remove_clbits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "remove_cregs",
        "full_api_name": "DAGCircuit.remove_cregs",
        "api_description": "Remove classical registers from the circuit, leaving underlying bits\nin place.\n\nRaises:\n    DAGCircuitError: a creg is not a ClassicalRegister, or is not in\n    the circuit.",
        "api_signature": "remove_cregs(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "remove_qubits",
        "full_api_name": "DAGCircuit.remove_qubits",
        "api_description": "Remove quantum bits from the circuit. All bits MUST be idle.\nAny registers with references to at least one of the specified bits will\nalso be removed.\n\nArgs:\n    qubits (List[Qubit]): The bits to remove.\n\nRaises:\n    DAGCircuitError: a qubit is not a :obj:`.Qubit`, is not in the circuit,\n        or is not idle.",
        "api_signature": "remove_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "remove_qregs",
        "full_api_name": "DAGCircuit.remove_qregs",
        "api_description": "Remove classical registers from the circuit, leaving underlying bits\nin place.\n\nRaises:\n    DAGCircuitError: a qreg is not a QuantumRegister, or is not in\n    the circuit.",
        "api_signature": "remove_qregs(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "_is_wire_idle",
        "full_api_name": "DAGCircuit._is_wire_idle",
        "api_description": "Check if a wire is idle.\n\nArgs:\n    wire (Bit): a wire in the circuit.\n\nReturns:\n    bool: true if the wire is idle, false otherwise.\n\nRaises:\n    DAGCircuitError: the wire is not in the circuit.",
        "api_signature": "_is_wire_idle(self, wire)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "_remove_idle_wire",
        "full_api_name": "DAGCircuit._remove_idle_wire",
        "api_description": "Remove an idle qubit or bit from the circuit.\n\nArgs:\n    wire (Bit): the wire to be removed, which MUST be idle.",
        "api_signature": "_remove_idle_wire(self, wire)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "_check_condition",
        "full_api_name": "DAGCircuit._check_condition",
        "api_description": "Verify that the condition is valid.\n\nArgs:\n    name (string): used for error reporting\n    condition (tuple or None): a condition tuple (ClassicalRegister, int) or (Clbit, bool)\n\nRaises:\n    DAGCircuitError: if conditioning on an invalid register",
        "api_signature": "_check_condition(self, name, condition)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "_check_bits",
        "full_api_name": "DAGCircuit._check_bits",
        "api_description": "Check the values of a list of (qu)bit arguments.\n\nFor each element of args, check that amap contains it.\n\nArgs:\n    args (list[Bit]): the elements to be checked\n    amap (dict): a dictionary keyed on Qubits/Clbits\n\nRaises:\n    DAGCircuitError: if a qubit is not contained in amap",
        "api_signature": "_check_bits(self, args, amap)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "_bits_in_operation",
        "full_api_name": "DAGCircuit._bits_in_operation",
        "api_description": "Return an iterable over the classical bits that are inherent to an instruction.  This\nincludes a `condition`, or the `target` of a :class:`.ControlFlowOp`.\n\nArgs:\n    instruction: the :class:`~.circuit.Instruction` instance for a node.\n\nReturns:\n    Iterable[Clbit]: the :class:`.Clbit`\\ s involved.",
        "api_signature": "_bits_in_operation(operation)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "_operation_may_have_bits",
        "full_api_name": "DAGCircuit._operation_may_have_bits",
        "api_description": "Return whether a given :class:`.Operation` may contain any :class:`.Clbit` instances\nin itself (e.g. a control-flow operation).\n\nArgs:\n    operation (qiskit.circuit.Operation): the operation to check.",
        "api_signature": "_operation_may_have_bits(operation)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "_increment_op",
        "full_api_name": "DAGCircuit._increment_op",
        "api_description": "",
        "api_signature": "_increment_op(self, op)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "_decrement_op",
        "full_api_name": "DAGCircuit._decrement_op",
        "api_description": "",
        "api_signature": "_decrement_op(self, op)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "copy_empty_like",
        "full_api_name": "DAGCircuit.copy_empty_like",
        "api_description": "Return a copy of self with the same structure but empty.\n\nThat structure includes:\n    * name and other metadata\n    * global phase\n    * duration\n    * all the qubits and clbits, including the registers.\n\nReturns:\n    DAGCircuit: An empty copy of self.",
        "api_signature": "copy_empty_like(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "apply_operation_back",
        "full_api_name": "DAGCircuit.apply_operation_back",
        "api_description": "Apply an operation to the output of the circuit.\n\nArgs:\n    op (qiskit.circuit.Operation): the operation associated with the DAG node\n    qargs (tuple[Qubit]): qubits that op will be applied to\n    cargs (tuple[Clbit]): cbits that op will be applied to\n    check (bool): If ``True`` (default), this function will enforce that the\n        :class:`.DAGCircuit` data-structure invariants are maintained (all ``qargs`` are\n        :class:`.Qubit`\\ s, all are in the DAG, etc).  If ``False``, the caller *must*\n        uphold these invariants itself, but the cost of several checks will be skipped.\n        This is most useful when building a new DAG from a source of known-good nodes.\nReturns:\n    DAGOpNode: the node for the op that was added to the dag\n\nRaises:\n    DAGCircuitError: if a leaf node is connected to multiple outputs",
        "api_signature": "apply_operation_back(self, op, qargs, cargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "apply_operation_front",
        "full_api_name": "DAGCircuit.apply_operation_front",
        "api_description": "Apply an operation to the input of the circuit.\n\nArgs:\n    op (qiskit.circuit.Operation): the operation associated with the DAG node\n    qargs (tuple[Qubit]): qubits that op will be applied to\n    cargs (tuple[Clbit]): cbits that op will be applied to\n    check (bool): If ``True`` (default), this function will enforce that the\n        :class:`.DAGCircuit` data-structure invariants are maintained (all ``qargs`` are\n        :class:`.Qubit`\\ s, all are in the DAG, etc).  If ``False``, the caller *must*\n        uphold these invariants itself, but the cost of several checks will be skipped.\n        This is most useful when building a new DAG from a source of known-good nodes.\nReturns:\n    DAGOpNode: the node for the op that was added to the dag\n\nRaises:\n    DAGCircuitError: if initial nodes connected to multiple out edges",
        "api_signature": "apply_operation_front(self, op, qargs, cargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "compose",
        "full_api_name": "DAGCircuit.compose",
        "api_description": "Compose the ``other`` circuit onto the output of this circuit.\n\nA subset of input wires of ``other`` are mapped\nto a subset of output wires of this circuit.\n\n``other`` can be narrower or of equal width to ``self``.\n\nArgs:\n    other (DAGCircuit): circuit to compose with self\n    qubits (list[Qubit|int]): qubits of self to compose onto.\n    clbits (list[Clbit|int]): clbits of self to compose onto.\n    front (bool): If True, front composition will be performed (not implemented yet)\n    inplace (bool): If True, modify the object. Otherwise return composed circuit.\n\nReturns:\n    DAGCircuit: the composed dag (returns None if inplace==True).\n\nRaises:\n    DAGCircuitError: if ``other`` is wider or there are duplicate edge mappings.",
        "api_signature": "compose(self, other, qubits, clbits, front, inplace)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "_reject_new_register",
        "full_api_name": "DAGCircuit._reject_new_register",
        "api_description": "",
        "api_signature": "_reject_new_register(reg)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "reverse_ops",
        "full_api_name": "DAGCircuit.reverse_ops",
        "api_description": "Reverse the operations in the ``self`` circuit.\n\nReturns:\n    DAGCircuit: the reversed dag.",
        "api_signature": "reverse_ops(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "idle_wires",
        "full_api_name": "DAGCircuit.idle_wires",
        "api_description": "Return idle wires.\n\nArgs:\n    ignore (list(str)): List of node names to ignore. Default: []\n\nYields:\n    Bit: Bit in idle wire.\n\nRaises:\n    DAGCircuitError: If the DAG is invalid",
        "api_signature": "idle_wires(self, ignore)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "size",
        "full_api_name": "DAGCircuit.size",
        "api_description": "Return the number of operations.  If there is control flow present, this count may only\nbe an estimate, as the complete control-flow path cannot be statically known.\n\nArgs:\n    recurse: if ``True``, then recurse into control-flow operations.  For loops with\n        known-length iterators are counted unrolled.  If-else blocks sum both of the two\n        branches.  While loops are counted as if the loop body runs once only.  Defaults to\n        ``False`` and raises :class:`.DAGCircuitError` if any control flow is present, to\n        avoid silently returning a mostly meaningless number.\n\nReturns:\n    int: the circuit size\n\nRaises:\n    DAGCircuitError: if an unknown :class:`.ControlFlowOp` is present in a call with\n        ``recurse=True``, or any control flow is present in a non-recursive call.",
        "api_signature": "size(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "depth",
        "full_api_name": "DAGCircuit.depth",
        "api_description": "Return the circuit depth.  If there is control flow present, this count may only be an\nestimate, as the complete control-flow path cannot be statically known.\n\nArgs:\n    recurse: if ``True``, then recurse into control-flow operations.  For loops\n        with known-length iterators are counted as if the loop had been manually unrolled\n        (*i.e.* with each iteration of the loop body written out explicitly).\n        If-else blocks take the longer case of the two branches.  While loops are counted as\n        if the loop body runs once only.  Defaults to ``False`` and raises\n        :class:`.DAGCircuitError` if any control flow is present, to avoid silently\n        returning a nonsensical number.\n\nReturns:\n    int: the circuit depth\n\nRaises:\n    DAGCircuitError: if not a directed acyclic graph\n    DAGCircuitError: if unknown control flow is present in a recursive call, or any control\n        flow is present in a non-recursive call.",
        "api_signature": "depth(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "weight_fn",
        "full_api_name": "DAGCircuit.weight_fn",
        "api_description": "",
        "api_signature": "weight_fn(_source, target, _edge)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "width",
        "full_api_name": "DAGCircuit.width",
        "api_description": "Return the total number of qubits + clbits used by the circuit.\nThis function formerly returned the number of qubits by the calculation\nreturn len(self._wires) - self.num_clbits()\nbut was changed by issue #2564 to return number of qubits + clbits\nwith the new function DAGCircuit.num_qubits replacing the former\nsemantic of DAGCircuit.width().",
        "api_signature": "width(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "num_qubits",
        "full_api_name": "DAGCircuit.num_qubits",
        "api_description": "Return the total number of qubits used by the circuit.\nnum_qubits() replaces former use of width().\nDAGCircuit.width() now returns qubits + clbits for\nconsistency with Circuit.width() [qiskit-terra #2564].",
        "api_signature": "num_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "num_clbits",
        "full_api_name": "DAGCircuit.num_clbits",
        "api_description": "Return the total number of classical bits used by the circuit.",
        "api_signature": "num_clbits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "num_tensor_factors",
        "full_api_name": "DAGCircuit.num_tensor_factors",
        "api_description": "Compute how many components the circuit can decompose into.",
        "api_signature": "num_tensor_factors(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "DAGCircuit.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "node_eq",
        "full_api_name": "DAGCircuit.node_eq",
        "api_description": "",
        "api_signature": "node_eq(node_self, node_other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "topological_nodes",
        "full_api_name": "DAGCircuit.topological_nodes",
        "api_description": "Yield nodes in topological order.\n\nArgs:\n    key (Callable): A callable which will take a DAGNode object and\n        return a string sort key. If not specified the\n        :attr:`~qiskit.dagcircuit.DAGNode.sort_key` attribute will be\n        used as the sort key for each node.\n\nReturns:\n    generator(DAGOpNode, DAGInNode, or DAGOutNode): node in topological order",
        "api_signature": "topological_nodes(self, key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "_key",
        "full_api_name": "DAGCircuit._key",
        "api_description": "",
        "api_signature": "_key(x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "topological_op_nodes",
        "full_api_name": "DAGCircuit.topological_op_nodes",
        "api_description": "Yield op nodes in topological order.\n\nAllowed to pass in specific key to break ties in top order\n\nArgs:\n    key (Callable): A callable which will take a DAGNode object and\n        return a string sort key. If not specified the\n        :attr:`~qiskit.dagcircuit.DAGNode.sort_key` attribute will be\n        used as the sort key for each node.\n\nReturns:\n    generator(DAGOpNode): op node in topological order",
        "api_signature": "topological_op_nodes(self, key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "replace_block_with_op",
        "full_api_name": "DAGCircuit.replace_block_with_op",
        "api_description": "Replace a block of nodes with a single node.\n\nThis is used to consolidate a block of DAGOpNodes into a single\noperation. A typical example is a block of gates being consolidated\ninto a single ``UnitaryGate`` representing the unitary matrix of the\nblock.\n\nArgs:\n    node_block (List[DAGNode]): A list of dag nodes that represents the\n        node block to be replaced\n    op (qiskit.circuit.Operation): The operation to replace the\n        block with\n    wire_pos_map (Dict[Bit, int]): The dictionary mapping the bits to their positions in the\n        output ``qargs`` or ``cargs``. This is necessary to reconstruct the arg order over\n        multiple gates in the combined single op node.  If a :class:`.Bit` is not in the\n        dictionary, it will not be added to the args; this can be useful when dealing with\n        control-flow operations that have inherent bits in their ``condition`` or ``target``\n        fields.\n    cycle_check (bool): When set to True this method will check that\n        replacing the provided ``node_block`` with a single node\n        would introduce a cycle (which would invalidate the\n        ``DAGCircuit``) and will raise a ``DAGCircuitError`` if a cycle\n        would be introduced. This checking comes with a run time\n        penalty. If you can guarantee that your input ``node_block`` is\n        a contiguous block and won't introduce a cycle when it's\n        contracted to a single node, this can be set to ``False`` to\n        improve the runtime performance of this method.\n\nRaises:\n    DAGCircuitError: if ``cycle_check`` is set to ``True`` and replacing\n        the specified block introduces a cycle or if ``node_block`` is\n        empty.\n\nReturns:\n    DAGOpNode: The op node that replaces the block.",
        "api_signature": "replace_block_with_op(self, node_block, op, wire_pos_map, cycle_check)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "substitute_node_with_dag",
        "full_api_name": "DAGCircuit.substitute_node_with_dag",
        "api_description": "Replace one node with dag.\n\nArgs:\n    node (DAGOpNode): node to substitute\n    input_dag (DAGCircuit): circuit that will substitute the node\n    wires (list[Bit] | Dict[Bit, Bit]): gives an order for (qu)bits\n        in the input circuit. If a list, then the bits refer to those in the ``input_dag``,\n        and the order gets matched to the node wires by qargs first, then cargs, then\n        conditions.  If a dictionary, then a mapping of bits in the ``input_dag`` to those\n        that the ``node`` acts on.\n    propagate_condition (bool): If ``True`` (default), then any ``condition`` attribute on\n        the operation within ``node`` is propagated to each node in the ``input_dag``.  If\n        ``False``, then the ``input_dag`` is assumed to faithfully implement suitable\n        conditional logic already.  This is ignored for :class:`.ControlFlowOp`\\ s (i.e.\n        treated as if it is ``False``); replacements of those must already fulfil the same\n        conditional logic or this function would be close to useless for them.\n\nReturns:\n    dict: maps node IDs from `input_dag` to their new node incarnations in `self`.\n\nRaises:\n    DAGCircuitError: if met with unexpected predecessor/successors",
        "api_signature": "substitute_node_with_dag(self, node, input_dag, wires, propagate_condition)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "filter_fn",
        "full_api_name": "DAGCircuit.filter_fn",
        "api_description": "",
        "api_signature": "filter_fn(node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "edge_map_fn",
        "full_api_name": "DAGCircuit.edge_map_fn",
        "api_description": "",
        "api_signature": "edge_map_fn(source, _target, self_wire)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "edge_weight_map",
        "full_api_name": "DAGCircuit.edge_weight_map",
        "api_description": "",
        "api_signature": "edge_weight_map(wire)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "substitute_node",
        "full_api_name": "DAGCircuit.substitute_node",
        "api_description": "Replace an DAGOpNode with a single operation. qargs, cargs and\nconditions for the new operation will be inferred from the node to be\nreplaced. The new operation will be checked to match the shape of the\nreplaced operation.\n\nArgs:\n    node (DAGOpNode): Node to be replaced\n    op (qiskit.circuit.Operation): The :class:`qiskit.circuit.Operation`\n        instance to be added to the DAG\n    inplace (bool): Optional, default False. If True, existing DAG node\n        will be modified to include op. Otherwise, a new DAG node will\n        be used.\n    propagate_condition (bool): Optional, default True.  If True, a condition on the\n        ``node`` to be replaced will be applied to the new ``op``.  This is the legacy\n        behaviour.  If either node is a control-flow operation, this will be ignored.  If\n        the ``op`` already has a condition, :exc:`.DAGCircuitError` is raised.\n\nReturns:\n    DAGOpNode: the new node containing the added operation.\n\nRaises:\n    DAGCircuitError: If replacement operation was incompatible with\n    location of target node.",
        "api_signature": "substitute_node(self, node, op, inplace, propagate_condition)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "separable_circuits",
        "full_api_name": "DAGCircuit.separable_circuits",
        "api_description": "Decompose the circuit into sets of qubits with no gates connecting them.\n\nArgs:\n    remove_idle_qubits (bool): Flag denoting whether to remove idle qubits from\n        the separated circuits. If ``False``, each output circuit will contain the\n        same number of qubits as ``self``.\n\nReturns:\n    List[DAGCircuit]: The circuits resulting from separating ``self`` into sets\n        of disconnected qubits\n\nEach :class:`~.DAGCircuit` instance returned by this method will contain the same number of\nclbits as ``self``. The global phase information in ``self`` will not be maintained\nin the subcircuits returned by this method.",
        "api_signature": "separable_circuits(self, remove_idle_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "_key",
        "full_api_name": "DAGCircuit._key",
        "api_description": "",
        "api_signature": "_key(x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "swap_nodes",
        "full_api_name": "DAGCircuit.swap_nodes",
        "api_description": "Swap connected nodes e.g. due to commutation.\n\nArgs:\n    node1 (OpNode): predecessor node\n    node2 (OpNode): successor node\n\nRaises:\n    DAGCircuitError: if either node is not an OpNode or nodes are not connected",
        "api_signature": "swap_nodes(self, node1, node2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "node",
        "full_api_name": "DAGCircuit.node",
        "api_description": "Get the node in the dag.\n\nArgs:\n    node_id(int): Node identifier.\n\nReturns:\n    node: the node.",
        "api_signature": "node(self, node_id)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "nodes",
        "full_api_name": "DAGCircuit.nodes",
        "api_description": "Iterator for node values.\n\nYield:\n    node: the node.",
        "api_signature": "nodes(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "edges",
        "full_api_name": "DAGCircuit.edges",
        "api_description": "Iterator for edge values and source and dest node\n\nThis works by returning the output edges from the specified nodes. If\nno nodes are specified all edges from the graph are returned.\n\nArgs:\n    nodes(DAGOpNode, DAGInNode, or DAGOutNode|list(DAGOpNode, DAGInNode, or DAGOutNode):\n        Either a list of nodes or a single input node. If none is specified,\n        all edges are returned from the graph.\n\nYield:\n    edge: the edge in the same format as out_edges the tuple\n        (source node, destination node, edge data)",
        "api_signature": "edges(self, nodes)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "op_nodes",
        "full_api_name": "DAGCircuit.op_nodes",
        "api_description": "Get the list of \"op\" nodes in the dag.\n\nArgs:\n    op (Type): :class:`qiskit.circuit.Operation` subclass op nodes to\n        return. If None, return all op nodes.\n    include_directives (bool): include `barrier`, `snapshot` etc.\n\nReturns:\n    list[DAGOpNode]: the list of node ids containing the given op.",
        "api_signature": "op_nodes(self, op, include_directives)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "gate_nodes",
        "full_api_name": "DAGCircuit.gate_nodes",
        "api_description": "Get the list of gate nodes in the dag.\n\nReturns:\n    list[DAGOpNode]: the list of DAGOpNodes that represent gates.",
        "api_signature": "gate_nodes(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "named_nodes",
        "full_api_name": "DAGCircuit.named_nodes",
        "api_description": "Get the set of \"op\" nodes with the given name.",
        "api_signature": "named_nodes(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "two_qubit_ops",
        "full_api_name": "DAGCircuit.two_qubit_ops",
        "api_description": "Get list of 2 qubit operations. Ignore directives like snapshot and barrier.",
        "api_signature": "two_qubit_ops(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "multi_qubit_ops",
        "full_api_name": "DAGCircuit.multi_qubit_ops",
        "api_description": "Get list of 3+ qubit operations. Ignore directives like snapshot and barrier.",
        "api_signature": "multi_qubit_ops(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "longest_path",
        "full_api_name": "DAGCircuit.longest_path",
        "api_description": "Returns the longest path in the dag as a list of DAGOpNodes, DAGInNodes, and DAGOutNodes.",
        "api_signature": "longest_path(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "successors",
        "full_api_name": "DAGCircuit.successors",
        "api_description": "Returns iterator of the successors of a node as DAGOpNodes and DAGOutNodes.",
        "api_signature": "successors(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "predecessors",
        "full_api_name": "DAGCircuit.predecessors",
        "api_description": "Returns iterator of the predecessors of a node as DAGOpNodes and DAGInNodes.",
        "api_signature": "predecessors(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "is_successor",
        "full_api_name": "DAGCircuit.is_successor",
        "api_description": "Checks if a second node is in the successors of node.",
        "api_signature": "is_successor(self, node, node_succ)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "is_predecessor",
        "full_api_name": "DAGCircuit.is_predecessor",
        "api_description": "Checks if a second node is in the predecessors of node.",
        "api_signature": "is_predecessor(self, node, node_pred)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "quantum_predecessors",
        "full_api_name": "DAGCircuit.quantum_predecessors",
        "api_description": "Returns iterator of the predecessors of a node that are\nconnected by a quantum edge as DAGOpNodes and DAGInNodes.",
        "api_signature": "quantum_predecessors(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "classical_predecessors",
        "full_api_name": "DAGCircuit.classical_predecessors",
        "api_description": "Returns iterator of the predecessors of a node that are\nconnected by a classical edge as DAGOpNodes and DAGInNodes.",
        "api_signature": "classical_predecessors(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "ancestors",
        "full_api_name": "DAGCircuit.ancestors",
        "api_description": "Returns set of the ancestors of a node as DAGOpNodes and DAGInNodes.",
        "api_signature": "ancestors(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "descendants",
        "full_api_name": "DAGCircuit.descendants",
        "api_description": "Returns set of the descendants of a node as DAGOpNodes and DAGOutNodes.",
        "api_signature": "descendants(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "bfs_successors",
        "full_api_name": "DAGCircuit.bfs_successors",
        "api_description": "Returns an iterator of tuples of (DAGNode, [DAGNodes]) where the DAGNode is the current node\nand [DAGNode] is its successors in  BFS order.",
        "api_signature": "bfs_successors(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "quantum_successors",
        "full_api_name": "DAGCircuit.quantum_successors",
        "api_description": "Returns iterator of the successors of a node that are\nconnected by a quantum edge as Opnodes and DAGOutNodes.",
        "api_signature": "quantum_successors(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "classical_successors",
        "full_api_name": "DAGCircuit.classical_successors",
        "api_description": "Returns iterator of the successors of a node that are\nconnected by a classical edge as DAGOpNodes and DAGInNodes.",
        "api_signature": "classical_successors(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "remove_op_node",
        "full_api_name": "DAGCircuit.remove_op_node",
        "api_description": "Remove an operation node n.\n\nAdd edges from predecessors to successors.",
        "api_signature": "remove_op_node(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "remove_ancestors_of",
        "full_api_name": "DAGCircuit.remove_ancestors_of",
        "api_description": "Remove all of the ancestor operation nodes of node.",
        "api_signature": "remove_ancestors_of(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "remove_descendants_of",
        "full_api_name": "DAGCircuit.remove_descendants_of",
        "api_description": "Remove all of the descendant operation nodes of node.",
        "api_signature": "remove_descendants_of(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "remove_nonancestors_of",
        "full_api_name": "DAGCircuit.remove_nonancestors_of",
        "api_description": "Remove all of the non-ancestors operation nodes of node.",
        "api_signature": "remove_nonancestors_of(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "remove_nondescendants_of",
        "full_api_name": "DAGCircuit.remove_nondescendants_of",
        "api_description": "Remove all of the non-descendants operation nodes of node.",
        "api_signature": "remove_nondescendants_of(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "front_layer",
        "full_api_name": "DAGCircuit.front_layer",
        "api_description": "Return a list of op nodes in the first layer of this dag.",
        "api_signature": "front_layer(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "layers",
        "full_api_name": "DAGCircuit.layers",
        "api_description": "Yield a shallow view on a layer of this DAGCircuit for all d layers of this circuit.\n\nA layer is a circuit whose gates act on disjoint qubits, i.e.,\na layer has depth 1. The total number of layers equals the\ncircuit depth d. The layers are indexed from 0 to d-1 with the\nearliest layer at index 0. The layers are constructed using a\ngreedy algorithm. Each returned layer is a dict containing\n{\"graph\": circuit graph, \"partition\": list of qubit lists}.\n\nThe returned layer contains new (but semantically equivalent) DAGOpNodes, DAGInNodes,\nand DAGOutNodes. These are not the same as nodes of the original dag, but are equivalent\nvia DAGNode.semantic_eq(node1, node2).\n\nTODO: Gates that use the same cbits will end up in different\nlayers as this is currently implemented. This may not be\nthe desired behavior.",
        "api_signature": "layers(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "serial_layers",
        "full_api_name": "DAGCircuit.serial_layers",
        "api_description": "Yield a layer for all gates of this circuit.\n\nA serial layer is a circuit with one gate. The layers have the\nsame structure as in layers().",
        "api_signature": "serial_layers(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "multigraph_layers",
        "full_api_name": "DAGCircuit.multigraph_layers",
        "api_description": "Yield layers of the multigraph.",
        "api_signature": "multigraph_layers(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "collect_runs",
        "full_api_name": "DAGCircuit.collect_runs",
        "api_description": "Return a set of non-conditional runs of \"op\" nodes with the given names.\n\nFor example, \"... h q[0]; cx q[0],q[1]; cx q[0],q[1]; h q[1]; ..\"\nwould produce the tuple of cx nodes as an element of the set returned\nfrom a call to collect_runs([\"cx\"]). If instead the cx nodes were\n\"cx q[0],q[1]; cx q[1],q[0];\", the method would still return the\npair in a tuple. The namelist can contain names that are not\nin the circuit's basis.\n\nNodes must have only one successor to continue the run.",
        "api_signature": "collect_runs(self, namelist)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "filter_fn",
        "full_api_name": "DAGCircuit.filter_fn",
        "api_description": "",
        "api_signature": "filter_fn(node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "collect_1q_runs",
        "full_api_name": "DAGCircuit.collect_1q_runs",
        "api_description": "Return a set of non-conditional runs of 1q \"op\" nodes.",
        "api_signature": "collect_1q_runs(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "filter_fn",
        "full_api_name": "DAGCircuit.filter_fn",
        "api_description": "",
        "api_signature": "filter_fn(node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "collect_2q_runs",
        "full_api_name": "DAGCircuit.collect_2q_runs",
        "api_description": "Return a set of non-conditional runs of 2q \"op\" nodes.",
        "api_signature": "collect_2q_runs(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "filter_fn",
        "full_api_name": "DAGCircuit.filter_fn",
        "api_description": "",
        "api_signature": "filter_fn(node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "color_fn",
        "full_api_name": "DAGCircuit.color_fn",
        "api_description": "",
        "api_signature": "color_fn(edge)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "nodes_on_wire",
        "full_api_name": "DAGCircuit.nodes_on_wire",
        "api_description": "Iterator for nodes that affect a given wire.\n\nArgs:\n    wire (Bit): the wire to be looked at.\n    only_ops (bool): True if only the ops nodes are wanted;\n                otherwise, all nodes are returned.\nYield:\n     Iterator: the successive nodes on the given wire\n\nRaises:\n    DAGCircuitError: if the given wire doesn't exist in the DAG",
        "api_signature": "nodes_on_wire(self, wire, only_ops)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "count_ops",
        "full_api_name": "DAGCircuit.count_ops",
        "api_description": "Count the occurrences of operation names.\n\nArgs:\n    recurse: if ``True`` (default), then recurse into control-flow operations.  In all\n        cases, this counts only the number of times the operation appears in any possible\n        block; both branches of if-elses are counted, and for- and while-loop blocks are\n        only counted once.\n\nReturns:\n    Mapping[str, int]: a mapping of operation names to the number of times it appears.",
        "api_signature": "count_ops(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "inner",
        "full_api_name": "DAGCircuit.inner",
        "api_description": "",
        "api_signature": "inner(dag, counts)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "count_ops_longest_path",
        "full_api_name": "DAGCircuit.count_ops_longest_path",
        "api_description": "Count the occurrences of operation names on the longest path.\n\nReturns a dictionary of counts keyed on the operation name.",
        "api_signature": "count_ops_longest_path(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "quantum_causal_cone",
        "full_api_name": "DAGCircuit.quantum_causal_cone",
        "api_description": "Returns causal cone of a qubit.\n\nA qubit's causal cone is the set of qubits that can influence the output of that\nqubit through interactions, whether through multi-qubit gates or operations. Knowing\nthe causal cone of a qubit can be useful when debugging faulty circuits, as it can\nhelp identify which wire(s) may be causing the problem.\n\nThis method does not consider any classical data dependency in the ``DAGCircuit``,\nclassical bit wires are ignored for the purposes of building the causal cone.\n\nArgs:\n    qubit (Qubit): The output qubit for which we want to find the causal cone.\n\nReturns:\n    Set[Qubit]: The set of qubits whose interactions affect ``qubit``.",
        "api_signature": "quantum_causal_cone(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "properties",
        "full_api_name": "DAGCircuit.properties",
        "api_description": "Return a dictionary of circuit properties.",
        "api_signature": "properties(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "draw",
        "full_api_name": "DAGCircuit.draw",
        "api_description": "Draws the dag circuit.\n\nThis function needs `pydot <https://github.com/erocarrera/pydot>`_, which in turn needs\n`Graphviz <https://www.graphviz.org/>`_ to be installed.\n\nArgs:\n    scale (float): scaling factor\n    filename (str): file path to save image to (format inferred from name)\n    style (str):\n        'plain': B&W graph;\n        'color' (default): color input/output/op nodes\n\nReturns:\n    Ipython.display.Image: if in Jupyter notebook and not saving to file,\n    otherwise None.",
        "api_signature": "draw(self, scale, filename, style)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "_warn_none_args",
        "full_api_name": "_warn_none_args",
        "api_description": "",
        "api_signature": "_warn_none_args()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "_legacy_condition_eq",
        "full_api_name": "_legacy_condition_eq",
        "api_description": "",
        "api_signature": "_legacy_condition_eq(cond1, cond2, bit_indices1, bit_indices2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagnode.py"
    },
    {
        "api_name": "_circuit_to_dag",
        "full_api_name": "_circuit_to_dag",
        "api_description": "Get a :class:`.DAGCircuit` of the given :class:`.QuantumCircuit`.  The bits in the output\nwill be ordered in a canonical order based on their indices in the outer DAG, as defined by the\n``bit_indices`` mapping and the ``node_{q,c}args`` arguments.",
        "api_signature": "_circuit_to_dag(circuit, node_qargs, node_cargs, bit_indices)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagnode.py"
    },
    {
        "api_name": "sort_key",
        "full_api_name": "sort_key",
        "api_description": "",
        "api_signature": "sort_key(bits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagnode.py"
    },
    {
        "api_name": "_make_expr_key",
        "full_api_name": "_make_expr_key",
        "api_description": "",
        "api_signature": "_make_expr_key(bit_indices)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagnode.py"
    },
    {
        "api_name": "key",
        "full_api_name": "key",
        "api_description": "",
        "api_signature": "key(var)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagnode.py"
    },
    {
        "api_name": "_condition_op_eq",
        "full_api_name": "_condition_op_eq",
        "api_description": "",
        "api_signature": "_condition_op_eq(node1, node2, bit_indices1, bit_indices2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagnode.py"
    },
    {
        "api_name": "_switch_case_eq",
        "full_api_name": "_switch_case_eq",
        "api_description": "",
        "api_signature": "_switch_case_eq(node1, node2, bit_indices1, bit_indices2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagnode.py"
    },
    {
        "api_name": "_for_loop_eq",
        "full_api_name": "_for_loop_eq",
        "api_description": "",
        "api_signature": "_for_loop_eq(node1, node2, bit_indices1, bit_indices2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagnode.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "DAGNode.__init__",
        "api_description": "Create a node",
        "api_signature": "__init__(self, nid)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagnode.py"
    },
    {
        "api_name": "__lt__",
        "full_api_name": "DAGNode.__lt__",
        "api_description": "",
        "api_signature": "__lt__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagnode.py"
    },
    {
        "api_name": "__gt__",
        "full_api_name": "DAGNode.__gt__",
        "api_description": "",
        "api_signature": "__gt__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagnode.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "DAGNode.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagnode.py"
    },
    {
        "api_name": "semantic_eq",
        "full_api_name": "DAGNode.semantic_eq",
        "api_description": "Check if DAG nodes are considered equivalent, e.g., as a node_match for\n:func:`rustworkx.is_isomorphic_node_match`.\n\nArgs:\n    node1 (DAGOpNode, DAGInNode, DAGOutNode): A node to compare.\n    node2 (DAGOpNode, DAGInNode, DAGOutNode): The other node to compare.\n    bit_indices1 (dict): Dictionary mapping Bit instances to their index\n        within the circuit containing node1\n    bit_indices2 (dict): Dictionary mapping Bit instances to their index\n        within the circuit containing node2\n\nReturn:\n    Bool: If node1 == node2",
        "api_signature": "semantic_eq(node1, node2, bit_indices1, bit_indices2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagnode.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "DAGOpNode.__init__",
        "api_description": "Create an Instruction node",
        "api_signature": "__init__(self, op, qargs, cargs, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagnode.py"
    },
    {
        "api_name": "name",
        "full_api_name": "DAGOpNode.name",
        "api_description": "Returns the Instruction name corresponding to the op for this node",
        "api_signature": "name(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagnode.py"
    },
    {
        "api_name": "name",
        "full_api_name": "DAGOpNode.name",
        "api_description": "Sets the Instruction name corresponding to the op for this node",
        "api_signature": "name(self, new_name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagnode.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "DAGOpNode.__repr__",
        "api_description": "Returns a representation of the DAGOpNode",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagnode.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "DAGInNode.__init__",
        "api_description": "Create an incoming node",
        "api_signature": "__init__(self, wire)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagnode.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "DAGInNode.__repr__",
        "api_description": "Returns a representation of the DAGInNode",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagnode.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "DAGOutNode.__init__",
        "api_description": "Create an outgoing node",
        "api_signature": "__init__(self, wire)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagnode.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "DAGOutNode.__repr__",
        "api_description": "Returns a representation of the DAGOutNode",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagnode.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "DAGDependency.__init__",
        "api_description": "Create an empty DAGDependency.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency.py"
    },
    {
        "api_name": "global_phase",
        "full_api_name": "DAGDependency.global_phase",
        "api_description": "Return the global phase of the circuit.",
        "api_signature": "global_phase(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency.py"
    },
    {
        "api_name": "global_phase",
        "full_api_name": "DAGDependency.global_phase",
        "api_description": "Set the global phase of the circuit.\n\nArgs:\n    angle (float, ParameterExpression)",
        "api_signature": "global_phase(self, angle)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency.py"
    },
    {
        "api_name": "calibrations",
        "full_api_name": "DAGDependency.calibrations",
        "api_description": "Return calibration dictionary.\n\nThe custom pulse definition of a given gate is of the form\n``{'gate_name': {(qubits, params): schedule}}``.",
        "api_signature": "calibrations(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency.py"
    },
    {
        "api_name": "calibrations",
        "full_api_name": "DAGDependency.calibrations",
        "api_description": "Set the circuit calibration data from a dictionary of calibration definition.\n\nArgs:\n    calibrations (dict): A dictionary of input in the format\n        {'gate_name': {(qubits, gate_params): schedule}}",
        "api_signature": "calibrations(self, calibrations)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency.py"
    },
    {
        "api_name": "to_retworkx",
        "full_api_name": "DAGDependency.to_retworkx",
        "api_description": "Returns the DAGDependency in retworkx format.",
        "api_signature": "to_retworkx(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency.py"
    },
    {
        "api_name": "size",
        "full_api_name": "DAGDependency.size",
        "api_description": "Returns the number of gates in the circuit",
        "api_signature": "size(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency.py"
    },
    {
        "api_name": "depth",
        "full_api_name": "DAGDependency.depth",
        "api_description": "Return the circuit depth.\nReturns:\n    int: the circuit depth",
        "api_signature": "depth(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency.py"
    },
    {
        "api_name": "add_qubits",
        "full_api_name": "DAGDependency.add_qubits",
        "api_description": "Add individual qubit wires.",
        "api_signature": "add_qubits(self, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency.py"
    },
    {
        "api_name": "add_clbits",
        "full_api_name": "DAGDependency.add_clbits",
        "api_description": "Add individual clbit wires.",
        "api_signature": "add_clbits(self, clbits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency.py"
    },
    {
        "api_name": "add_qreg",
        "full_api_name": "DAGDependency.add_qreg",
        "api_description": "Add qubits in a quantum register.",
        "api_signature": "add_qreg(self, qreg)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency.py"
    },
    {
        "api_name": "add_creg",
        "full_api_name": "DAGDependency.add_creg",
        "api_description": "Add clbits in a classical register.",
        "api_signature": "add_creg(self, creg)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency.py"
    },
    {
        "api_name": "_add_multi_graph_node",
        "full_api_name": "DAGDependency._add_multi_graph_node",
        "api_description": "Args:\n    node (DAGDepNode): considered node.\n\nReturns:\n    node_id(int): corresponding label to the added node.",
        "api_signature": "_add_multi_graph_node(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency.py"
    },
    {
        "api_name": "get_nodes",
        "full_api_name": "DAGDependency.get_nodes",
        "api_description": "Returns:\n    generator(dict): iterator over all the nodes.",
        "api_signature": "get_nodes(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency.py"
    },
    {
        "api_name": "get_node",
        "full_api_name": "DAGDependency.get_node",
        "api_description": "Args:\n    node_id (int): label of considered node.\n\nReturns:\n    node: corresponding to the label.",
        "api_signature": "get_node(self, node_id)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency.py"
    },
    {
        "api_name": "_add_multi_graph_edge",
        "full_api_name": "DAGDependency._add_multi_graph_edge",
        "api_description": "Function to add an edge from given data (dict) between two nodes.\n\nArgs:\n    src_id (int): label of the first node.\n    dest_id (int): label of the second node.\n    data (dict): data contained on the edge.",
        "api_signature": "_add_multi_graph_edge(self, src_id, dest_id, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency.py"
    },
    {
        "api_name": "get_edges",
        "full_api_name": "DAGDependency.get_edges",
        "api_description": "Edge enumeration between two nodes through method get_all_edge_data.\n\nArgs:\n    src_id (int): label of the first node.\n    dest_id (int): label of the second node.\n\nReturns:\n    List: corresponding to all edges between the two nodes.",
        "api_signature": "get_edges(self, src_id, dest_id)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency.py"
    },
    {
        "api_name": "get_all_edges",
        "full_api_name": "DAGDependency.get_all_edges",
        "api_description": "Enumeration of all edges.\n\nReturns:\n    List: corresponding to the label.",
        "api_signature": "get_all_edges(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency.py"
    },
    {
        "api_name": "get_in_edges",
        "full_api_name": "DAGDependency.get_in_edges",
        "api_description": "Enumeration of all incoming edges for a given node.\n\nArgs:\n    node_id (int): label of considered node.\n\nReturns:\n    List: corresponding incoming edges data.",
        "api_signature": "get_in_edges(self, node_id)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency.py"
    },
    {
        "api_name": "get_out_edges",
        "full_api_name": "DAGDependency.get_out_edges",
        "api_description": "Enumeration of all outgoing edges for a given node.\n\nArgs:\n    node_id (int): label of considered node.\n\nReturns:\n    List: corresponding outgoing edges data.",
        "api_signature": "get_out_edges(self, node_id)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency.py"
    },
    {
        "api_name": "direct_successors",
        "full_api_name": "DAGDependency.direct_successors",
        "api_description": "Direct successors id of a given node as sorted list.\n\nArgs:\n    node_id (int): label of considered node.\n\nReturns:\n    List: direct successors id as a sorted list",
        "api_signature": "direct_successors(self, node_id)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency.py"
    },
    {
        "api_name": "direct_predecessors",
        "full_api_name": "DAGDependency.direct_predecessors",
        "api_description": "Direct predecessors id of a given node as sorted list.\n\nArgs:\n    node_id (int): label of considered node.\n\nReturns:\n    List: direct predecessors id as a sorted list",
        "api_signature": "direct_predecessors(self, node_id)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency.py"
    },
    {
        "api_name": "successors",
        "full_api_name": "DAGDependency.successors",
        "api_description": "Successors id of a given node as sorted list.\n\nArgs:\n    node_id (int): label of considered node.\n\nReturns:\n    List: all successors id as a sorted list",
        "api_signature": "successors(self, node_id)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency.py"
    },
    {
        "api_name": "predecessors",
        "full_api_name": "DAGDependency.predecessors",
        "api_description": "Predecessors id of a given node as sorted list.\n\nArgs:\n    node_id (int): label of considered node.\n\nReturns:\n    List: all predecessors id as a sorted list",
        "api_signature": "predecessors(self, node_id)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency.py"
    },
    {
        "api_name": "topological_nodes",
        "full_api_name": "DAGDependency.topological_nodes",
        "api_description": "Yield nodes in topological order.\n\nReturns:\n    generator(DAGNode): node in topological order.",
        "api_signature": "topological_nodes(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency.py"
    },
    {
        "api_name": "_key",
        "full_api_name": "DAGDependency._key",
        "api_description": "",
        "api_signature": "_key(x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency.py"
    },
    {
        "api_name": "_create_op_node",
        "full_api_name": "DAGDependency._create_op_node",
        "api_description": "Creates a DAGDepNode to the graph and update the edges.\n\nArgs:\n    operation (qiskit.circuit.Operation): operation\n    qargs (list[Qubit]): list of qubits on which the operation acts\n    cargs (list[Clbit]): list of classical wires to attach to\n\nReturns:\n    DAGDepNode: the newly added node.",
        "api_signature": "_create_op_node(self, operation, qargs, cargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency.py"
    },
    {
        "api_name": "add_op_node",
        "full_api_name": "DAGDependency.add_op_node",
        "api_description": "Add a DAGDepNode to the graph and update the edges.\n\nArgs:\n    operation (qiskit.circuit.Operation): operation as a quantum gate\n    qargs (list[Qubit]): list of qubits on which the operation acts\n    cargs (list[Clbit]): list of classical wires to attach to",
        "api_signature": "add_op_node(self, operation, qargs, cargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency.py"
    },
    {
        "api_name": "_update_edges",
        "full_api_name": "DAGDependency._update_edges",
        "api_description": "Updates DagDependency by adding edges to the newly added node (max_node)\nfrom the previously added nodes.\nFor each previously added node (prev_node), an edge from prev_node to max_node\nis added if max_node is \"reachable\" from prev_node (this means that the two\nnodes can be made adjacent by commuting them with other nodes), but the two nodes\nthemselves do not commute.\n\nCurrently. this function is only used when creating a new DAGDependency from another\nrepresentation of a circuit, and hence there are no removed nodes (this is why\niterating over all nodes is fine).",
        "api_signature": "_update_edges(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency.py"
    },
    {
        "api_name": "_add_successors",
        "full_api_name": "DAGDependency._add_successors",
        "api_description": "Create the list of successors. Update DAGDependency 'successors' attribute. It has to\nbe used when the DAGDependency() object is complete (i.e. converters).",
        "api_signature": "_add_successors(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency.py"
    },
    {
        "api_name": "_add_predecessors",
        "full_api_name": "DAGDependency._add_predecessors",
        "api_description": "Create the list of predecessors for each node. Update DAGDependency\n'predecessors' attribute. It has to be used when the DAGDependency() object\nis complete (i.e. converters).",
        "api_signature": "_add_predecessors(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency.py"
    },
    {
        "api_name": "copy",
        "full_api_name": "DAGDependency.copy",
        "api_description": "Function to copy a DAGDependency object.\nReturns:\n    DAGDependency: a copy of a DAGDependency object.",
        "api_signature": "copy(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency.py"
    },
    {
        "api_name": "draw",
        "full_api_name": "DAGDependency.draw",
        "api_description": "Draws the DAGDependency graph.\n\nThis function needs `pydot <https://github.com/erocarrera/pydot>`, which in turn needs\nGraphviz <https://www.graphviz.org/>` to be installed.\n\nArgs:\n    scale (float): scaling factor\n    filename (str): file path to save image to (format inferred from name)\n    style (str): 'plain': B&W graph\n                 'color' (default): color input/output/op nodes\n\nReturns:\n    Ipython.display.Image: if in Jupyter notebook and not saving to file, otherwise None.",
        "api_signature": "draw(self, scale, filename, style)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency.py"
    },
    {
        "api_name": "replace_block_with_op",
        "full_api_name": "DAGDependency.replace_block_with_op",
        "api_description": "Replace a block of nodes with a single node.\n\nThis is used to consolidate a block of DAGDepNodes into a single\noperation. A typical example is a block of CX and SWAP gates consolidated\ninto a LinearFunction. This function is an adaptation of a similar\nfunction from DAGCircuit.\n\nIt is important that such consolidation preserves commutativity assumptions\npresent in DAGDependency. As an example, suppose that every node in a\nblock [A, B, C, D] commutes with another node E. Let F be the consolidated\nnode, F = A o B o C o D. Then F also commutes with E, and thus the result of\nreplacing [A, B, C, D] by F results in a valid DAGDependency. That is, any\ndeduction about commutativity in consolidated DAGDependency is correct.\nOn the other hand, suppose that at least one of the nodes, say B, does not commute\nwith E. Then the consolidated DAGDependency would imply that F does not commute\nwith E. Even though F and E may actually commute, it is still safe to assume that\nthey do not. That is, the current implementation of consolidation may lead to\nsuboptimal but not to incorrect results.\n\nArgs:\n    node_block (List[DAGDepNode]): A list of dag nodes that represents the\n        node block to be replaced\n    op (qiskit.circuit.Operation): The operation to replace the\n        block with\n    wire_pos_map (Dict[Qubit, int]): The dictionary mapping the qarg to\n        the position. This is necessary to reconstruct the qarg order\n        over multiple gates in the combined single op node.\n    cycle_check (bool): When set to True this method will check that\n        replacing the provided ``node_block`` with a single node\n        would introduce a cycle (which would invalidate the\n        ``DAGDependency``) and will raise a ``DAGDependencyError`` if a cycle\n        would be introduced. This checking comes with a run time\n        penalty. If you can guarantee that your input ``node_block`` is\n        a contiguous block and won't introduce a cycle when it's\n        contracted to a single node, this can be set to ``False`` to\n        improve the runtime performance of this method.\nRaises:\n    DAGDependencyError: if ``cycle_check`` is set to ``True`` and replacing\n        the specified block introduces a cycle or if ``node_block`` is\n        empty.",
        "api_signature": "replace_block_with_op(self, node_block, op, wire_pos_map, cycle_check)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency.py"
    },
    {
        "api_name": "merge_no_duplicates",
        "full_api_name": "merge_no_duplicates",
        "api_description": "Merge K list without duplicate using python heapq ordered merging\n\nArgs:\n    *iterables: A list of k sorted lists\n\nYields:\n    Iterator: List from the merging of the k ones (without duplicates",
        "api_signature": "merge_no_duplicates()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "DAGCircuitError.__init__",
        "api_description": "Set the error message.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/exceptions.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "DAGCircuitError.__str__",
        "api_description": "Return the message.",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/exceptions.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "DAGDependencyError.__init__",
        "api_description": "Set the error message.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/exceptions.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "DAGDependencyError.__str__",
        "api_description": "Return the message.",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/exceptions.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BlockCollector.__init__",
        "api_description": "Args:\n    dag (Union[DAGCircuit, DAGDependency]): The input DAG.\n\nRaises:\n    DAGCircuitError: the input object is not a DAG.",
        "api_signature": "__init__(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/collect_blocks.py"
    },
    {
        "api_name": "_setup_in_degrees",
        "full_api_name": "BlockCollector._setup_in_degrees",
        "api_description": "For an efficient implementation, for every node we keep the number of its\nunprocessed immediate predecessors (called ``_in_degree``). This ``_in_degree``\nis set up at the start and updated throughout the algorithm.\nA node is leaf (or input) node iff its ``_in_degree`` is 0.\nWhen a node is (marked as) collected, the ``_in_degree`` of each of its immediate\nsuccessor is updated by subtracting 1.\nAdditionally, ``_pending_nodes`` explicitly keeps the list of nodes whose\n``_in_degree`` is 0.",
        "api_signature": "_setup_in_degrees(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/collect_blocks.py"
    },
    {
        "api_name": "_op_nodes",
        "full_api_name": "BlockCollector._op_nodes",
        "api_description": "Returns DAG nodes.",
        "api_signature": "_op_nodes(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/collect_blocks.py"
    },
    {
        "api_name": "_direct_preds",
        "full_api_name": "BlockCollector._direct_preds",
        "api_description": "Returns direct predecessors of a node. This function takes into account the\ndirection of collecting blocks, that is node's predecessors when collecting\nbackwards are the direct successors of a node in the DAG.",
        "api_signature": "_direct_preds(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/collect_blocks.py"
    },
    {
        "api_name": "_direct_succs",
        "full_api_name": "BlockCollector._direct_succs",
        "api_description": "Returns direct successors of a node. This function takes into account the\ndirection of collecting blocks, that is node's successors when collecting\nbackwards are the direct predecessors of a node in the DAG.",
        "api_signature": "_direct_succs(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/collect_blocks.py"
    },
    {
        "api_name": "_have_uncollected_nodes",
        "full_api_name": "BlockCollector._have_uncollected_nodes",
        "api_description": "Returns whether there are uncollected (pending) nodes",
        "api_signature": "_have_uncollected_nodes(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/collect_blocks.py"
    },
    {
        "api_name": "collect_matching_block",
        "full_api_name": "BlockCollector.collect_matching_block",
        "api_description": "Iteratively collects the largest block of input nodes (that is, nodes with\n``_in_degree`` equal to 0) that match a given filtering function.\nExamples of this include collecting blocks of swap gates,\nblocks of linear gates (CXs and SWAPs), blocks of Clifford gates, blocks of single-qubit gates,\nblocks of two-qubit gates, etc.  Here 'iteratively' means that once a node is collected,\nthe ``_in_degree`` of each of its immediate successor is decreased by 1, allowing more nodes\nto become input and to be eligible for collecting into the current block.\nReturns the block of collected nodes.",
        "api_signature": "collect_matching_block(self, filter_fn)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/collect_blocks.py"
    },
    {
        "api_name": "collect_all_matching_blocks",
        "full_api_name": "BlockCollector.collect_all_matching_blocks",
        "api_description": "Collects all blocks that match a given filtering function filter_fn.\nThis iteratively finds the largest block that does not match filter_fn,\nthen the largest block that matches filter_fn, and so on, until no more uncollected\nnodes remain. Intuitively, finding larger blocks of non-matching nodes helps to\nfind larger blocks of matching nodes later on.\n\nAfter the blocks are collected, they can be optionally refined. The option\n``split_blocks`` allows to split collected blocks into sub-blocks over disjoint\nqubit subsets. The option ``split_layers`` allows to split collected blocks\ninto layers of non-overlapping instructions. The option ``min_block_size``\nspecifies the minimum number of gates in the block for the block to be collected.\n\nBy default, blocks are collected in the direction from the inputs towards the outputs\nof the circuit. The option ``collect_from_back`` allows to change this direction,\nthat is collect blocks from the outputs towards the inputs of the circuit.\n\nReturns the list of matching blocks only.",
        "api_signature": "collect_all_matching_blocks(self, filter_fn, split_blocks, min_block_size, split_layers, collect_from_back)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/collect_blocks.py"
    },
    {
        "api_name": "not_filter_fn",
        "full_api_name": "BlockCollector.not_filter_fn",
        "api_description": "Returns the opposite of filter_fn.",
        "api_signature": "not_filter_fn(node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/collect_blocks.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BlockSplitter.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/collect_blocks.py"
    },
    {
        "api_name": "find_leader",
        "full_api_name": "BlockSplitter.find_leader",
        "api_description": "Find in DSU.",
        "api_signature": "find_leader(self, index)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/collect_blocks.py"
    },
    {
        "api_name": "union_leaders",
        "full_api_name": "BlockSplitter.union_leaders",
        "api_description": "Union in DSU.",
        "api_signature": "union_leaders(self, index1, index2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/collect_blocks.py"
    },
    {
        "api_name": "run",
        "full_api_name": "BlockSplitter.run",
        "api_description": "Splits block of nodes into sub-blocks over disjoint qubits.",
        "api_signature": "run(self, block)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/collect_blocks.py"
    },
    {
        "api_name": "split_block_into_layers",
        "full_api_name": "split_block_into_layers",
        "api_description": "Splits a block of nodes into sub-blocks of non-overlapping instructions\n(or, in other words, into depth-1 sub-blocks).",
        "api_signature": "split_block_into_layers(block)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/collect_blocks.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BlockCollapser.__init__",
        "api_description": "Args:\n    dag (Union[DAGCircuit, DAGDependency]): The input DAG.",
        "api_signature": "__init__(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/collect_blocks.py"
    },
    {
        "api_name": "collapse_to_operation",
        "full_api_name": "BlockCollapser.collapse_to_operation",
        "api_description": "For each block, constructs a quantum circuit containing instructions in the block,\nthen uses collapse_fn to collapse this circuit into a single operation.",
        "api_signature": "collapse_to_operation(self, blocks, collapse_fn)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/collect_blocks.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "DAGDepNode.__init__",
        "api_description": "",
        "api_signature": "__init__(self, type, op, name, qargs, cargs, successors, predecessors, reachable, matchedwith, successorstovisit, isblocked, qindices, cindices, nid)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdepnode.py"
    },
    {
        "api_name": "op",
        "full_api_name": "DAGDepNode.op",
        "api_description": "Returns the Instruction object corresponding to the op for the node, else None",
        "api_signature": "op(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdepnode.py"
    },
    {
        "api_name": "op",
        "full_api_name": "DAGDepNode.op",
        "api_description": "",
        "api_signature": "op(self, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdepnode.py"
    },
    {
        "api_name": "qargs",
        "full_api_name": "DAGDepNode.qargs",
        "api_description": "Returns list of Qubit, else an empty list.",
        "api_signature": "qargs(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdepnode.py"
    },
    {
        "api_name": "qargs",
        "full_api_name": "DAGDepNode.qargs",
        "api_description": "Sets the qargs to be the given list of qargs.",
        "api_signature": "qargs(self, new_qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdepnode.py"
    },
    {
        "api_name": "semantic_eq",
        "full_api_name": "DAGDepNode.semantic_eq",
        "api_description": "Check if DAG nodes are considered equivalent, e.g., as a node_match for nx.is_isomorphic.\n\nArgs:\n    node1 (DAGDepNode): A node to compare.\n    node2 (DAGDepNode): The other node to compare.\n\nReturn:\n    Bool: If node1 == node2",
        "api_signature": "semantic_eq(node1, node2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdepnode.py"
    },
    {
        "api_name": "copy",
        "full_api_name": "DAGDepNode.copy",
        "api_description": "Function to copy a DAGDepNode object.\nReturns:\n    DAGDepNode: a copy of a DAGDepNode object.",
        "api_signature": "copy(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdepnode.py"
    },
    {
        "api_name": "plot_state_hinton",
        "full_api_name": "plot_state_hinton",
        "api_description": "Plot a hinton diagram for the density matrix of a quantum state.\n\nThe hinton diagram represents the values of a matrix using\nsquares, whose size indicate the magnitude of their corresponding value\nand their color, its sign. A white square means the value is positive and\na black one means negative.\n\nArgs:\n    state (Statevector or DensityMatrix or ndarray): An N-qubit quantum state.\n    title (str): a string that represents the plot title\n    figsize (tuple): Figure size in inches.\n    filename (str): file path to save image to.\n    ax_real (matplotlib.axes.Axes): An optional Axes object to be used for\n        the visualization output. If none is specified a new matplotlib\n        Figure will be created and used. If this is specified without an\n        ax_imag only the real component plot will be generated.\n        Additionally, if specified there will be no returned Figure since\n        it is redundant.\n    ax_imag (matplotlib.axes.Axes): An optional Axes object to be used for\n        the visualization output. If none is specified a new matplotlib\n        Figure will be created and used. If this is specified without an\n        ax_imag only the real component plot will be generated.\n        Additionally, if specified there will be no returned Figure since\n        it is redundant.\n\nReturns:\n    :class:`matplotlib:matplotlib.figure.Figure` :\n        The matplotlib.Figure of the visualization if\n        neither ax_real or ax_imag is set.\n\nRaises:\n    MissingOptionalLibraryError: Requires matplotlib.\n    VisualizationError: if input is not a valid N-qubit state.\n\nExamples:\n    .. plot::\n       :include-source:\n\n        import numpy as np\n        from qiskit import QuantumCircuit\n        from qiskit.quantum_info import DensityMatrix\n        from qiskit.visualization import plot_state_hinton\n\n        qc = QuantumCircuit(2)\n        qc.h([0, 1])\n        qc.cz(0,1)\n        qc.ry(np.pi/3 , 0)\n        qc.rx(np.pi/5, 1)\n\n        state = DensityMatrix(qc)\n        plot_state_hinton(state, title=\"New Hinton Plot\")",
        "api_signature": "plot_state_hinton(state, title, figsize, ax_real, ax_imag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/state_visualization.py"
    },
    {
        "api_name": "plot_bloch_vector",
        "full_api_name": "plot_bloch_vector",
        "api_description": "Plot the Bloch sphere.\n\nPlot a Bloch sphere with the specified coordinates, that can be given in both\ncartesian and spherical systems.\n\nArgs:\n    bloch (list[double]): array of three elements where [<x>, <y>, <z>] (Cartesian)\n        or [<r>, <theta>, <phi>] (spherical in radians)\n        <theta> is inclination angle from +z direction\n        <phi> is azimuth from +x direction\n    title (str): a string that represents the plot title\n    ax (matplotlib.axes.Axes): An Axes to use for rendering the bloch\n        sphere\n    figsize (tuple): Figure size in inches. Has no effect is passing ``ax``.\n    coord_type (str): a string that specifies coordinate type for bloch\n        (Cartesian or spherical), default is Cartesian\n    font_size (float): Font size.\n\nReturns:\n    :class:`matplotlib:matplotlib.figure.Figure` : A matplotlib figure instance if ``ax = None``.\n\nRaises:\n    MissingOptionalLibraryError: Requires matplotlib.\n\nExamples:\n    .. plot::\n       :include-source:\n\n       from qiskit.visualization import plot_bloch_vector\n\n       plot_bloch_vector([0,1,0], title=\"New Bloch Sphere\")\n\n    .. plot::\n       :include-source:\n\n       import numpy as np\n       from qiskit.visualization import plot_bloch_vector\n\n       # You can use spherical coordinates instead of cartesian.\n\n       plot_bloch_vector([1, np.pi/2, np.pi/3], coord_type='spherical')",
        "api_signature": "plot_bloch_vector(bloch, title, ax, figsize, coord_type, font_size)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/state_visualization.py"
    },
    {
        "api_name": "plot_bloch_multivector",
        "full_api_name": "plot_bloch_multivector",
        "api_description": "Plot a Bloch sphere for each qubit.\n\nEach component :math:`(x,y,z)` of the Bloch sphere labeled as 'qubit i' represents the expected\nvalue of the corresponding Pauli operator acting only on that qubit, that is, the expected value\nof :math:`I_{N-1} \\otimes\\dotsb\\otimes I_{i+1}\\otimes P_i \\otimes I_{i-1}\\otimes\\dotsb\\otimes\nI_0`, where :math:`N` is the number of qubits, :math:`P\\in \\{X,Y,Z\\}` and :math:`I` is the\nidentity operator.\n\nArgs:\n    state (Statevector or DensityMatrix or ndarray): an N-qubit quantum state.\n    title (str): a string that represents the plot title\n    figsize (tuple): size of each individual Bloch sphere figure, in inches.\n    reverse_bits (bool): If True, plots qubits following Qiskit's convention [Default:False].\n    font_size (float): Font size for the Bloch ball figures.\n    title_font_size (float): Font size for the title.\n    title_pad (float): Padding for the title (suptitle `y` position is `y=1+title_pad/100`).\n\nReturns:\n    :class:`matplotlib:matplotlib.figure.Figure` :\n        A matplotlib figure instance.\n\nRaises:\n    MissingOptionalLibraryError: Requires matplotlib.\n    VisualizationError: if input is not a valid N-qubit state.\n\nExamples:\n    .. plot::\n       :include-source:\n\n        from qiskit import QuantumCircuit\n        from qiskit.quantum_info import Statevector\n        from qiskit.visualization import plot_bloch_multivector\n\n        qc = QuantumCircuit(2)\n        qc.h(0)\n        qc.x(1)\n\n        state = Statevector(qc)\n        plot_bloch_multivector(state)\n\n    .. plot::\n       :include-source:\n\n       from qiskit import QuantumCircuit\n       from qiskit.quantum_info import Statevector\n       from qiskit.visualization import plot_bloch_multivector\n\n       qc = QuantumCircuit(2)\n       qc.h(0)\n       qc.x(1)\n\n       # You can reverse the order of the qubits.\n\n       from qiskit.quantum_info import DensityMatrix\n\n       qc = QuantumCircuit(2)\n       qc.h([0, 1])\n       qc.t(1)\n       qc.s(0)\n       qc.cx(0,1)\n\n       matrix = DensityMatrix(qc)\n       plot_bloch_multivector(matrix, title='My Bloch Spheres', reverse_bits=True)",
        "api_signature": "plot_bloch_multivector(state, title, figsize)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/state_visualization.py"
    },
    {
        "api_name": "plot_state_city",
        "full_api_name": "plot_state_city",
        "api_description": "Plot the cityscape of quantum state.\n\nPlot two 3d bar graphs (two dimensional) of the real and imaginary\npart of the density matrix rho.\n\nArgs:\n    state (Statevector or DensityMatrix or ndarray): an N-qubit quantum state.\n    title (str): a string that represents the plot title\n    figsize (tuple): Figure size in inches.\n    color (list): A list of len=2 giving colors for real and\n        imaginary components of matrix elements.\n    alpha (float): Transparency value for bars\n    ax_real (matplotlib.axes.Axes): An optional Axes object to be used for\n        the visualization output. If none is specified a new matplotlib\n        Figure will be created and used. If this is specified without an\n        ax_imag only the real component plot will be generated.\n        Additionally, if specified there will be no returned Figure since\n        it is redundant.\n    ax_imag (matplotlib.axes.Axes): An optional Axes object to be used for\n        the visualization output. If none is specified a new matplotlib\n        Figure will be created and used. If this is specified without an\n        ax_real only the imaginary component plot will be generated.\n        Additionally, if specified there will be no returned Figure since\n        it is redundant.\n\nReturns:\n    :class:`matplotlib:matplotlib.figure.Figure` :\n        The matplotlib.Figure of the visualization if the\n        ``ax_real`` and ``ax_imag`` kwargs are not set\n\nRaises:\n    MissingOptionalLibraryError: Requires matplotlib.\n    ValueError: When 'color' is not a list of len=2.\n    VisualizationError: if input is not a valid N-qubit state.\n\nExamples:\n    .. plot::\n       :include-source:\n\n       # You can choose different colors for the real and imaginary parts of the density matrix.\n\n       from qiskit import QuantumCircuit\n       from qiskit.quantum_info import DensityMatrix\n       from qiskit.visualization import plot_state_city\n\n       qc = QuantumCircuit(2)\n       qc.h(0)\n       qc.cx(0, 1)\n\n       state = DensityMatrix(qc)\n       plot_state_city(state, color=['midnightblue', 'crimson'], title=\"New State City\")\n\n    .. plot::\n       :include-source:\n\n       # You can make the bars more transparent to better see the ones that are behind\n       # if they overlap.\n\n       import numpy as np\n       from qiskit.quantum_info import Statevector\n       from qiskit.visualization import plot_state_city\n       from qiskit import QuantumCircuit\n\n       qc = QuantumCircuit(2)\n       qc.h(0)\n       qc.cx(0, 1)\n\n\n       qc = QuantumCircuit(2)\n       qc.h([0, 1])\n       qc.cz(0,1)\n       qc.ry(np.pi/3, 0)\n       qc.rx(np.pi/5, 1)\n\n       state = Statevector(qc)\n       plot_state_city(state, alpha=0.6)",
        "api_signature": "plot_state_city(state, title, figsize, color, alpha, ax_real, ax_imag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/state_visualization.py"
    },
    {
        "api_name": "plot_state_paulivec",
        "full_api_name": "plot_state_paulivec",
        "api_description": "Plot the Pauli-vector representation of a quantum state as bar graph.\n\nThe Pauli-vector of a density matrix :math:`\\rho` is defined by the expectation of each\npossible tensor product of single-qubit Pauli operators (including the identity), that is\n\n.. math ::\n\n    \\rho = \\frac{1}{2^n} \\sum_{\\sigma \\in \\{I, X, Y, Z\\}^{\\otimes n}}\n           \\mathrm{Tr}(\\sigma \\rho) \\sigma.\n\nThis function plots the coefficients :math:`\\mathrm{Tr}(\\sigma\\rho)` as bar graph.\n\nArgs:\n    state (Statevector or DensityMatrix or ndarray): an N-qubit quantum state.\n    title (str): a string that represents the plot title\n    figsize (tuple): Figure size in inches.\n    color (list or str): Color of the coefficient value bars.\n    ax (matplotlib.axes.Axes): An optional Axes object to be used for\n        the visualization output. If none is specified a new matplotlib\n        Figure will be created and used. Additionally, if specified there\n        will be no returned Figure since it is redundant.\n\nReturns:\n     :class:`matplotlib:matplotlib.figure.Figure` :\n        The matplotlib.Figure of the visualization if the\n        ``ax`` kwarg is not set\n\nRaises:\n    MissingOptionalLibraryError: Requires matplotlib.\n    VisualizationError: if input is not a valid N-qubit state.\n\nExamples:\n    .. plot::\n       :include-source:\n\n       # You can set a color for all the bars.\n\n       from qiskit import QuantumCircuit\n       from qiskit.quantum_info import Statevector\n       from qiskit.visualization import plot_state_paulivec\n\n       qc = QuantumCircuit(2)\n       qc.h(0)\n       qc.cx(0, 1)\n\n       state = Statevector(qc)\n       plot_state_paulivec(state, color='midnightblue', title=\"New PauliVec plot\")\n\n    .. plot::\n       :include-source:\n\n       # If you introduce a list with less colors than bars, the color of the bars will\n       # alternate following the sequence from the list.\n\n       import numpy as np\n       from qiskit.quantum_info import DensityMatrix\n       from qiskit import QuantumCircuit\n       from qiskit.visualization import plot_state_paulivec\n\n       qc = QuantumCircuit(2)\n       qc.h(0)\n       qc.cx(0, 1)\n\n       qc = QuantumCircuit(2)\n       qc.h([0, 1])\n       qc.cz(0, 1)\n       qc.ry(np.pi/3, 0)\n       qc.rx(np.pi/5, 1)\n\n       matrix = DensityMatrix(qc)\n       plot_state_paulivec(matrix, color=['crimson', 'midnightblue', 'seagreen'])",
        "api_signature": "plot_state_paulivec(state, title, figsize, color, ax)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/state_visualization.py"
    },
    {
        "api_name": "n_choose_k",
        "full_api_name": "n_choose_k",
        "api_description": "Return the number of combinations for n choose k.\n\nArgs:\n    n (int): the total number of options .\n    k (int): The number of elements.\n\nReturns:\n    int: returns the binomial coefficient",
        "api_signature": "n_choose_k(n, k)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/state_visualization.py"
    },
    {
        "api_name": "lex_index",
        "full_api_name": "lex_index",
        "api_description": "Return  the lex index of a combination..\n\nArgs:\n    n (int): the total number of options .\n    k (int): The number of elements.\n    lst (list): list\n\nReturns:\n    int: returns int index for lex order\n\nRaises:\n    VisualizationError: if length of list is not equal to k",
        "api_signature": "lex_index(n, k, lst)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/state_visualization.py"
    },
    {
        "api_name": "bit_string_index",
        "full_api_name": "bit_string_index",
        "api_description": "Return the index of a string of 0s and 1s.",
        "api_signature": "bit_string_index(s)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/state_visualization.py"
    },
    {
        "api_name": "phase_to_rgb",
        "full_api_name": "phase_to_rgb",
        "api_description": "Map a phase of a complexnumber to a color in (r,g,b).\n\ncomplex_number is phase is first mapped to angle in the range\n[0, 2pi] and then to the HSL color wheel",
        "api_signature": "phase_to_rgb(complex_number)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/state_visualization.py"
    },
    {
        "api_name": "plot_state_qsphere",
        "full_api_name": "plot_state_qsphere",
        "api_description": "Plot the qsphere representation of a quantum state.\nHere, the size of the points is proportional to the probability\nof the corresponding term in the state and the color represents\nthe phase.\n\nArgs:\n    state (Statevector or DensityMatrix or ndarray): an N-qubit quantum state.\n    figsize (tuple): Figure size in inches.\n    ax (matplotlib.axes.Axes): An optional Axes object to be used for\n        the visualization output. If none is specified a new matplotlib\n        Figure will be created and used. Additionally, if specified there\n        will be no returned Figure since it is redundant.\n    show_state_labels (bool): An optional boolean indicating whether to\n        show labels for each basis state.\n    show_state_phases (bool): An optional boolean indicating whether to\n        show the phase for each basis state.\n    use_degrees (bool): An optional boolean indicating whether to use\n        radians or degrees for the phase values in the plot.\n\nReturns:\n    :class:`matplotlib:matplotlib.figure.Figure` :\n        A matplotlib figure instance if the ``ax`` kwarg is not set\n\nRaises:\n    MissingOptionalLibraryError: Requires matplotlib.\n    VisualizationError: if input is not a valid N-qubit state.\n\n    QiskitError: Input statevector does not have valid dimensions.\n\nExamples:\n    .. plot::\n       :include-source:\n\n       from qiskit import QuantumCircuit\n       from qiskit.quantum_info import Statevector\n       from qiskit.visualization import plot_state_qsphere\n\n       qc = QuantumCircuit(2)\n       qc.h(0)\n       qc.cx(0, 1)\n\n       state = Statevector(qc)\n       plot_state_qsphere(state)\n\n    .. plot::\n       :include-source:\n\n       # You can show the phase of each state and use\n       # degrees instead of radians\n\n       from qiskit.quantum_info import DensityMatrix\n       import numpy as np\n       from qiskit import QuantumCircuit\n       from qiskit.visualization import plot_state_qsphere\n\n       qc = QuantumCircuit(2)\n       qc.h([0, 1])\n       qc.cz(0,1)\n       qc.ry(np.pi/3, 0)\n       qc.rx(np.pi/5, 1)\n       qc.z(1)\n\n       matrix = DensityMatrix(qc)\n       plot_state_qsphere(matrix,\n            show_state_phases = True, use_degrees = True)",
        "api_signature": "plot_state_qsphere(state, figsize, ax, show_state_labels, show_state_phases, use_degrees)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/state_visualization.py"
    },
    {
        "api_name": "generate_facecolors",
        "full_api_name": "generate_facecolors",
        "api_description": "Generates shaded facecolors for shaded bars.\n\nThis is here to work around a Matplotlib bug\nwhere alpha does not work in Bar3D.\n\nArgs:\n    x (array_like): The x- coordinates of the anchor point of the bars.\n    y (array_like): The y- coordinates of the anchor point of the bars.\n    z (array_like): The z- coordinates of the anchor point of the bars.\n    dx (array_like): Width of bars.\n    dy (array_like): Depth of bars.\n    dz (array_like): Height of bars.\n    color (array_like): sequence of valid color specifications, optional\nReturns:\n    list: Shaded colors for bars.\nRaises:\n    MissingOptionalLibraryError: If matplotlib is not installed",
        "api_signature": "generate_facecolors(x, y, z, dx, dy, dz, color)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/state_visualization.py"
    },
    {
        "api_name": "_generate_normals",
        "full_api_name": "_generate_normals",
        "api_description": "Takes a list of polygons and return an array of their normals.\n\nNormals point towards the viewer for a face with its vertices in\ncounterclockwise order, following the right hand rule.\nUses three points equally spaced around the polygon.\nThis normal of course might not make sense for polygons with more than\nthree points not lying in a plane, but it's a plausible and fast\napproximation.\n\nArgs:\n    polygons (list): list of (M_i, 3) array_like, or (..., M, 3) array_like\n        A sequence of polygons to compute normals for, which can have\n        varying numbers of vertices. If the polygons all have the same\n        number of vertices and array is passed, then the operation will\n        be vectorized.\nReturns:\n    normals: (..., 3) array_like\n        A normal vector estimated for the polygon.",
        "api_signature": "_generate_normals(polygons)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/state_visualization.py"
    },
    {
        "api_name": "_shade_colors",
        "full_api_name": "_shade_colors",
        "api_description": "Shade *color* using normal vectors given by *normals*.\n*color* can also be an array of the same length as *normals*.",
        "api_signature": "_shade_colors(color, normals, lightsource)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/state_visualization.py"
    },
    {
        "api_name": "mod",
        "full_api_name": "mod",
        "api_description": "",
        "api_signature": "mod(v)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/state_visualization.py"
    },
    {
        "api_name": "state_to_latex",
        "full_api_name": "state_to_latex",
        "api_description": "Return a Latex representation of a state. Wrapper function\nfor `qiskit.visualization.array_to_latex` for convention 'vector'.\nAdds dims if necessary.\nIntended for use within `state_drawer`.\n\nArgs:\n    state: State to be drawn\n    dims (bool): Whether to display the state's `dims`\n    convention (str): Either 'vector' or 'ket'. For 'ket' plot the state in the ket-notation.\n            Otherwise plot as a vector\n    **args: Arguments to be passed directly to `array_to_latex` for convention 'ket'\n\nReturns:\n    Latex representation of the state",
        "api_signature": "state_to_latex(state, dims, convention)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/state_visualization.py"
    },
    {
        "api_name": "num_to_latex_ket",
        "full_api_name": "num_to_latex_ket",
        "api_description": "Convert a complex number to latex code suitable for a ket expression\n\nArgs:\n    raw_value: Value to convert\n    first_term: If True then generate latex code for the first term in an expression\n    decimals: Number of decimal places to round to (default: 10).\nReturns:\n    String with latex code or None if no term is required",
        "api_signature": "num_to_latex_ket(raw_value, first_term, decimals)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/state_visualization.py"
    },
    {
        "api_name": "numbers_to_latex_terms",
        "full_api_name": "numbers_to_latex_terms",
        "api_description": "Convert a list of numbers to latex formatted terms\nThe first non-zero term is treated differently. For this term a leading + is suppressed.\nArgs:\n    numbers: List of numbers to format\n    decimals: Number of decimal places to round to (default: 10).\nReturns:\n    List of formatted terms",
        "api_signature": "numbers_to_latex_terms(numbers, decimals)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/state_visualization.py"
    },
    {
        "api_name": "_numbers_to_latex_terms",
        "full_api_name": "_numbers_to_latex_terms",
        "api_description": "Convert a list of numbers to latex formatted terms\n\nThe first non-zero term is treated differently. For this term a leading + is suppressed.\n\nArgs:\n    numbers: List of numbers to format\n    decimals: Number of decimal places to round to (default: 10).\nReturns:\n    List of formatted terms",
        "api_signature": "_numbers_to_latex_terms(numbers, decimals)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/state_visualization.py"
    },
    {
        "api_name": "_state_to_latex_ket",
        "full_api_name": "_state_to_latex_ket",
        "api_description": "Convert state vector to latex representation\n\nArgs:\n    data: State vector\n    max_size: Maximum number of non-zero terms in the expression. If the number of\n             non-zero terms is larger than the max_size, then the representation is truncated.\n    prefix: Latex string to be prepended to the latex, intended for labels.\n    decimals: Number of decimal places to round to (default: 10).\n\nReturns:\n    String with LaTeX representation of the state vector",
        "api_signature": "_state_to_latex_ket(data, max_size, prefix, decimals)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/state_visualization.py"
    },
    {
        "api_name": "ket_name",
        "full_api_name": "ket_name",
        "api_description": "",
        "api_signature": "ket_name(i)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/state_visualization.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "TextMatrix.__init__",
        "api_description": "",
        "api_signature": "__init__(self, state, max_size, dims, prefix, suffix)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/state_visualization.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "TextMatrix.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/state_visualization.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "TextMatrix.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/state_visualization.py"
    },
    {
        "api_name": "state_drawer",
        "full_api_name": "state_drawer",
        "api_description": "Returns a visualization of the state.\n\n**repr**: ASCII TextMatrix of the state's ``_repr_``.\n\n**text**: ASCII TextMatrix that can be printed in the console.\n\n**latex**: An IPython Latex object for displaying in Jupyter Notebooks.\n\n**latex_source**: Raw, uncompiled ASCII source to generate array using LaTeX.\n\n**qsphere**: Matplotlib figure, rendering of statevector using `plot_state_qsphere()`.\n\n**hinton**: Matplotlib figure, rendering of statevector using `plot_state_hinton()`.\n\n**bloch**: Matplotlib figure, rendering of statevector using `plot_bloch_multivector()`.\n\n**city**: Matplotlib figure, rendering of statevector using `plot_state_city()`.\n\n**paulivec**: Matplotlib figure, rendering of statevector using `plot_state_paulivec()`.\n\nArgs:\n    output (str): Select the output method to use for drawing the\n        circuit. Valid choices are ``text``, ``latex``, ``latex_source``,\n        ``qsphere``, ``hinton``, ``bloch``, ``city`` or ``paulivec``.\n        Default is `'text`'.\n    drawer_args: Arguments to be passed to the relevant drawer. For\n        'latex' and 'latex_source' see ``array_to_latex``\n\nReturns:\n    :class:`matplotlib.figure` or :class:`str` or\n    :class:`TextMatrix` or :class:`IPython.display.Latex`:\n    Drawing of the state.\n\nRaises:\n    MissingOptionalLibraryError: when `output` is `latex` and IPython is not installed.\n    ValueError: when `output` is not a valid selection.",
        "api_signature": "state_drawer(state, output)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/state_visualization.py"
    },
    {
        "api_name": "_bloch_multivector_data",
        "full_api_name": "_bloch_multivector_data",
        "api_description": "Return list of Bloch vectors for each qubit\n\nArgs:\n    state (DensityMatrix or Statevector): an N-qubit state.\n\nReturns:\n    list: list of Bloch vectors (x, y, z) for each qubit.\n\nRaises:\n    VisualizationError: if input is not an N-qubit state.",
        "api_signature": "_bloch_multivector_data(state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/state_visualization.py"
    },
    {
        "api_name": "_paulivec_data",
        "full_api_name": "_paulivec_data",
        "api_description": "Return paulivec data for plotting.\n\nArgs:\n    state (DensityMatrix or Statevector): an N-qubit state.\n\nReturns:\n    tuple: (labels, values) for Pauli vector.\n\nRaises:\n    VisualizationError: if input is not an N-qubit state.",
        "api_signature": "_paulivec_data(state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/state_visualization.py"
    },
    {
        "api_name": "_normalize",
        "full_api_name": "_normalize",
        "api_description": "Makes sure magnitude of the vector is 1 with given tolerance",
        "api_signature": "_normalize(v, tolerance)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/transition_visualization.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "_Quaternion.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/transition_visualization.py"
    },
    {
        "api_name": "from_axisangle",
        "full_api_name": "_Quaternion.from_axisangle",
        "api_description": "Create quaternion from axis",
        "api_signature": "from_axisangle(theta, v)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/transition_visualization.py"
    },
    {
        "api_name": "from_value",
        "full_api_name": "_Quaternion.from_value",
        "api_description": "Create quaternion from vector",
        "api_signature": "from_value(value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/transition_visualization.py"
    },
    {
        "api_name": "_axisangle_to_q",
        "full_api_name": "_Quaternion._axisangle_to_q",
        "api_description": "Convert axis and angle to quaternion",
        "api_signature": "_axisangle_to_q(self, theta, v)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/transition_visualization.py"
    },
    {
        "api_name": "__mul__",
        "full_api_name": "_Quaternion.__mul__",
        "api_description": "Multiplication of quaternion with quaternion or vector",
        "api_signature": "__mul__(self, b)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/transition_visualization.py"
    },
    {
        "api_name": "_multiply_with_quaternion",
        "full_api_name": "_Quaternion._multiply_with_quaternion",
        "api_description": "Multiplication of quaternion with quaternion",
        "api_signature": "_multiply_with_quaternion(self, q_2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/transition_visualization.py"
    },
    {
        "api_name": "_multiply_with_vector",
        "full_api_name": "_Quaternion._multiply_with_vector",
        "api_description": "Multiplication of quaternion with vector",
        "api_signature": "_multiply_with_vector(self, v)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/transition_visualization.py"
    },
    {
        "api_name": "get_conjugate",
        "full_api_name": "_Quaternion.get_conjugate",
        "api_description": "Conjugation of quaternion",
        "api_signature": "get_conjugate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/transition_visualization.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "_Quaternion.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/transition_visualization.py"
    },
    {
        "api_name": "get_axisangle",
        "full_api_name": "_Quaternion.get_axisangle",
        "api_description": "Returns angle and vector of quaternion",
        "api_signature": "get_axisangle(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/transition_visualization.py"
    },
    {
        "api_name": "tolist",
        "full_api_name": "_Quaternion.tolist",
        "api_description": "Converts quaternion to a list",
        "api_signature": "tolist(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/transition_visualization.py"
    },
    {
        "api_name": "vector_norm",
        "full_api_name": "_Quaternion.vector_norm",
        "api_description": "Calculates norm of quaternion",
        "api_signature": "vector_norm(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/transition_visualization.py"
    },
    {
        "api_name": "visualize_transition",
        "full_api_name": "visualize_transition",
        "api_description": "Creates animation showing transitions between states of a single\nqubit by applying quantum gates.\n\nArgs:\n    circuit (QuantumCircuit): Qiskit single-qubit QuantumCircuit. Gates supported are\n        h,x, y, z, rx, ry, rz, s, sdg, t, tdg and u1.\n    trace (bool): Controls whether to display tracing vectors - history of 10 past vectors\n        at each step of the animation.\n    saveas (str): User can choose to save the animation as a video to their filesystem.\n        This argument is a string of path with filename and extension (e.g. \"movie.mp4\" to\n        save the video in current working directory).\n    fpg (int): Frames per gate. Finer control over animation smoothness and computational\n        needs to render the animation. Works well for tkinter GUI as it is, for jupyter GUI\n        it might be preferable to choose fpg between 5-30.\n    spg (int): Seconds per gate. How many seconds should animation of individual gate\n        transitions take.\n\nReturns:\n    IPython.core.display.HTML:\n        If arg jupyter is set to True. Otherwise opens tkinter GUI and returns\n        after the GUI is closed.\n\nRaises:\n    MissingOptionalLibraryError: Must have Matplotlib (and/or IPython) installed.\n    VisualizationError: Given gate(s) are not supported.",
        "api_signature": "visualize_transition(circuit, trace, saveas, fpg, spg)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/transition_visualization.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Namespace.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/transition_visualization.py"
    },
    {
        "api_name": "animate",
        "full_api_name": "animate",
        "api_description": "",
        "api_signature": "animate(i)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/transition_visualization.py"
    },
    {
        "api_name": "init",
        "full_api_name": "init",
        "api_description": "",
        "api_signature": "init()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/transition_visualization.py"
    },
    {
        "api_name": "_trim",
        "full_api_name": "_trim",
        "api_description": "Trim a PIL image and remove white space.",
        "api_signature": "_trim(image)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/utils.py"
    },
    {
        "api_name": "matplotlib_close_if_inline",
        "full_api_name": "matplotlib_close_if_inline",
        "api_description": "Close the given matplotlib figure if the backend in use draws figures inline.\n\nIf the backend does not draw figures inline, this does nothing.  This function is to prevent\nduplicate images appearing; the inline backends will capture the figure in preparation and\ndisplay it as well, whereas the drawers want to return the figure to be displayed.",
        "api_signature": "matplotlib_close_if_inline(figure)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/utils.py"
    },
    {
        "api_name": "hamming_distance",
        "full_api_name": "hamming_distance",
        "api_description": "Calculate the Hamming distance between two bit strings\n\nArgs:\n    str1 (str): First string.\n    str2 (str): Second string.\nReturns:\n    int: Distance between strings.\nRaises:\n    VisualizationError: Strings not same length",
        "api_signature": "hamming_distance(str1, str2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/counts_visualization.py"
    },
    {
        "api_name": "_is_deprecated_data_format",
        "full_api_name": "_is_deprecated_data_format",
        "api_description": "",
        "api_signature": "_is_deprecated_data_format(data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/counts_visualization.py"
    },
    {
        "api_name": "plot_histogram",
        "full_api_name": "plot_histogram",
        "api_description": "Plot a histogram of input counts data.\n\nArgs:\n    data (list or dict): This is either a list of dictionaries or a single\n        dict containing the values to represent (ex ``{'001': 130}``)\n    figsize (tuple): Figure size in inches.\n    color (list or str): String or list of strings for histogram bar colors.\n    number_to_keep (int): The number of terms to plot per dataset.  The rest is made into a\n        single bar called 'rest'.  If multiple datasets are given, the ``number_to_keep``\n        applies to each dataset individually, which may result in more bars than\n        ``number_to_keep + 1``.  The ``number_to_keep`` applies to the total values, rather than\n        the x-axis sort.\n    sort (string): Could be `'asc'`, `'desc'`, `'hamming'`, `'value'`, or\n        `'value_desc'`. If set to `'value'` or `'value_desc'` the x axis\n        will be sorted by the number of counts for each bitstring.\n        Defaults to `'asc'`.\n    target_string (str): Target string if 'sort' is a distance measure.\n    legend(list): A list of strings to use for labels of the data.\n        The number of entries must match the length of data (if data is a\n        list or 1 if it's a dict)\n    bar_labels (bool): Label each bar in histogram with counts value.\n    title (str): A string to use for the plot title\n    ax (matplotlib.axes.Axes): An optional Axes object to be used for\n        the visualization output. If none is specified a new matplotlib\n        Figure will be created and used. Additionally, if specified there\n        will be no returned Figure since it is redundant.\n    filename (str): file path to save image to.\n\nReturns:\n    matplotlib.Figure:\n        A figure for the rendered histogram, if the ``ax``\n        kwarg is not set.\n\nRaises:\n    MissingOptionalLibraryError: Matplotlib not available.\n    VisualizationError: When legend is provided and the length doesn't\n        match the input data.\n    VisualizationError: Input must be Counts or a dict\n\nExamples:\n    .. plot::\n       :include-source:\n\n        # Plot two counts in the same figure with legends and colors specified.\n\n        from qiskit.visualization import plot_histogram\n\n        counts1 = {'00': 525, '11': 499}\n        counts2 = {'00': 511, '11': 514}\n\n        legend = ['First execution', 'Second execution']\n\n        plot_histogram([counts1, counts2], legend=legend, color=['crimson','midnightblue'],\n                        title=\"New Histogram\")\n\n        # You can sort the bitstrings using different methods.\n\n        counts = {'001': 596, '011': 211, '010': 50, '000': 117, '101': 33, '111': 8,\n                '100': 6, '110': 3}\n\n        # Sort by the counts in descending order\n        hist1 = plot_histogram(counts, sort='value_desc')\n\n        # Sort by the hamming distance (the number of bit flips to change from\n        # one bitstring to the other) from a target string.\n        hist2 = plot_histogram(counts, sort='hamming', target_string='001')",
        "api_signature": "plot_histogram(data, figsize, color, number_to_keep, sort, target_string, legend, bar_labels, title, ax, filename)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/counts_visualization.py"
    },
    {
        "api_name": "plot_distribution",
        "full_api_name": "plot_distribution",
        "api_description": "Plot a distribution from input sampled data.\n\nArgs:\n    data (list or dict): This is either a list of dictionaries or a single\n        dict containing the values to represent (ex {'001': 130})\n    figsize (tuple): Figure size in inches.\n    color (list or str): String or list of strings for distribution bar colors.\n    number_to_keep (int): The number of terms to plot per dataset.  The rest is made into a\n        single bar called 'rest'.  If multiple datasets are given, the ``number_to_keep``\n        applies to each dataset individually, which may result in more bars than\n        ``number_to_keep + 1``.  The ``number_to_keep`` applies to the total values, rather than\n        the x-axis sort.\n    sort (string): Could be `'asc'`, `'desc'`, `'hamming'`, `'value'`, or\n        `'value_desc'`. If set to `'value'` or `'value_desc'` the x axis\n        will be sorted by the maximum probability for each bitstring.\n        Defaults to `'asc'`.\n    target_string (str): Target string if 'sort' is a distance measure.\n    legend(list): A list of strings to use for labels of the data.\n        The number of entries must match the length of data (if data is a\n        list or 1 if it's a dict)\n    bar_labels (bool): Label each bar in histogram with probability value.\n    title (str): A string to use for the plot title\n    ax (matplotlib.axes.Axes): An optional Axes object to be used for\n        the visualization output. If none is specified a new matplotlib\n        Figure will be created and used. Additionally, if specified there\n        will be no returned Figure since it is redundant.\n    filename (str): file path to save image to.\n\nReturns:\n    matplotlib.Figure:\n        A figure for the rendered distribution, if the ``ax``\n        kwarg is not set.\n\nRaises:\n    MissingOptionalLibraryError: Matplotlib not available.\n    VisualizationError: When legend is provided and the length doesn't\n        match the input data.\n\nExamples:\n    .. plot::\n       :include-source:\n\n        # Plot two counts in the same figure with legends and colors specified.\n\n        from qiskit.visualization import plot_distribution\n\n        counts1 = {'00': 525, '11': 499}\n        counts2 = {'00': 511, '11': 514}\n\n        legend = ['First execution', 'Second execution']\n\n        plot_distribution([counts1, counts2], legend=legend, color=['crimson','midnightblue'],\n                        title=\"New Distribution\")\n\n        # You can sort the bitstrings using different methods.\n\n        counts = {'001': 596, '011': 211, '010': 50, '000': 117, '101': 33, '111': 8,\n                '100': 6, '110': 3}\n\n        # Sort by the counts in descending order\n        dist1 = plot_distribution(counts, sort='value_desc')\n\n        # Sort by the hamming distance (the number of bit flips to change from\n        # one bitstring to the other) from a target string.\n        dist2 = plot_distribution(counts, sort='hamming', target_string='001')",
        "api_signature": "plot_distribution(data, figsize, color, number_to_keep, sort, target_string, legend, bar_labels, title, ax, filename)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/counts_visualization.py"
    },
    {
        "api_name": "_plotting_core",
        "full_api_name": "_plotting_core",
        "api_description": "",
        "api_signature": "_plotting_core(data, figsize, color, number_to_keep, sort, target_string, legend, bar_labels, title, ax, filename, kind)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/counts_visualization.py"
    },
    {
        "api_name": "_keep_largest_items",
        "full_api_name": "_keep_largest_items",
        "api_description": "Keep only the largest values in a dictionary, and sum the rest into a new key 'rest'.",
        "api_signature": "_keep_largest_items(execution, number_to_keep)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/counts_visualization.py"
    },
    {
        "api_name": "_unify_labels",
        "full_api_name": "_unify_labels",
        "api_description": "Make all dictionaries in data have the same set of keys, using 0 for missing values.",
        "api_signature": "_unify_labels(data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/counts_visualization.py"
    },
    {
        "api_name": "_plot_data",
        "full_api_name": "_plot_data",
        "api_description": "Generate the data needed for plotting counts.\n\nParameters:\n    data (list or dict): This is either a list of dictionaries or a single\n        dict containing the values to represent (ex {'001': 130})\n    labels (list): The list of bitstring labels for the plot.\n    number_to_keep (int): The number of terms to plot and rest\n        is made into a single bar called 'rest'.\n    kind (str): One of 'counts' or 'distribution`\n\nReturns:\n    tuple: tuple containing:\n        (dict): The labels actually used in the plotting.\n        (list): List of ndarrays for the bars in each experiment.\n        (list): Indices for the locations of the bars for each\n                experiment.",
        "api_signature": "_plot_data(data, labels, number_to_keep, kind)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/counts_visualization.py"
    },
    {
        "api_name": "dag_drawer",
        "full_api_name": "dag_drawer",
        "api_description": "Plot the directed acyclic graph (dag) to represent operation dependencies\nin a quantum circuit.\n\nThis function calls the :func:`~rustworkx.visualization.graphviz_draw` function from the\n``rustworkx`` package to draw the DAG.\n\nArgs:\n    dag (DAGCircuit): The dag to draw.\n    scale (float): scaling factor\n    filename (str): file path to save image to (format inferred from name)\n    style (str): 'plain': B&W graph\n                 'color' (default): color input/output/op nodes\n\nReturns:\n    PIL.Image: if in Jupyter notebook and not saving to file,\n        otherwise None.\n\nRaises:\n    VisualizationError: when style is not recognized.\n    InvalidFileError: when filename provided is not valid\n\nExample:\n    .. plot::\n       :include-source:\n\n        from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit\n        from qiskit.dagcircuit import DAGCircuit\n        from qiskit.converters import circuit_to_dag\n        from qiskit.visualization import dag_drawer\n\n        q = QuantumRegister(3, 'q')\n        c = ClassicalRegister(3, 'c')\n        circ = QuantumCircuit(q, c)\n        circ.h(q[0])\n        circ.cx(q[0], q[1])\n        circ.measure(q[0], c[0])\n        circ.rz(0.5, q[1]).c_if(c, 2)\n\n        dag = circuit_to_dag(circ)\n        dag_drawer(dag)",
        "api_signature": "dag_drawer(dag, scale, filename, style)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/dag_visualization.py"
    },
    {
        "api_name": "node_attr_func",
        "full_api_name": "node_attr_func",
        "api_description": "",
        "api_signature": "node_attr_func(node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/dag_visualization.py"
    },
    {
        "api_name": "node_attr_func",
        "full_api_name": "node_attr_func",
        "api_description": "",
        "api_signature": "node_attr_func(node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/dag_visualization.py"
    },
    {
        "api_name": "edge_attr_func",
        "full_api_name": "edge_attr_func",
        "api_description": "",
        "api_signature": "edge_attr_func(edge)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/dag_visualization.py"
    },
    {
        "api_name": "_num_to_latex",
        "full_api_name": "_num_to_latex",
        "api_description": "Convert a complex number to latex code suitable for a ket expression\n\nArgs:\n    raw_value (complex): Value to convert.\n    decimals (int): Number of decimal places to round to (default 15).\n    coefficient (bool): Whether the number is to be used as a coefficient\n                        of a ket.\n    first_term (bool): If a coefficient, whether this number is the first\n                       coefficient in the expression.\nReturns:\n    str: latex code",
        "api_signature": "_num_to_latex(raw_value, decimals, first_term, coefficient)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/array.py"
    },
    {
        "api_name": "_matrix_to_latex",
        "full_api_name": "_matrix_to_latex",
        "api_description": "Latex representation of a complex numpy array (with maximum dimension 2)\n\nArgs:\n    matrix (ndarray): The matrix to be converted to latex, must have dimension 2.\n    decimals (int): For numbers not close to integers, the number of decimal places\n                     to round to.\n    prefix (str): Latex string to be prepended to the latex, intended for labels.\n    max_size (list(```int```)): Indexable containing two integers: Maximum width and maximum\n                      height of output Latex matrix (including dots characters). If the\n                      width and/or height of matrix exceeds the maximum, the centre values\n                      will be replaced with dots. Maximum width or height must be greater\n                      than 3.\n\nReturns:\n    str: Latex representation of the matrix\n\nRaises:\n    ValueError: If minimum value in max_size < 3",
        "api_signature": "_matrix_to_latex(matrix, decimals, prefix, max_size)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/array.py"
    },
    {
        "api_name": "_elements_to_latex",
        "full_api_name": "_elements_to_latex",
        "api_description": "",
        "api_signature": "_elements_to_latex(elements)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/array.py"
    },
    {
        "api_name": "_rows_to_latex",
        "full_api_name": "_rows_to_latex",
        "api_description": "",
        "api_signature": "_rows_to_latex(rows, max_width)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/array.py"
    },
    {
        "api_name": "array_to_latex",
        "full_api_name": "array_to_latex",
        "api_description": "Latex representation of a complex numpy array (with dimension 1 or 2)\n\nArgs:\n    array (ndarray): The array to be converted to latex, must have dimension 1 or 2 and\n                     contain only numerical data.\n    precision (int): For numbers not close to integers or common terms, the number of\n                     decimal places to round to.\n    prefix (str): Latex string to be prepended to the latex, intended for labels.\n    source (bool): If ``False``, will return IPython.display.Latex object. If display is\n                   ``True``, will instead return the LaTeX source string.\n    max_size (list(int) or int): The maximum size of the output Latex array.\n\n        * If list(``int``), then the 0th element of the list specifies the maximum\n          width (including dots characters) and the 1st specifies the maximum height\n          (also inc. dots characters).\n        * If a single ``int`` then this value sets the maximum width _and_ maximum\n          height.\n\nReturns:\n    str or IPython.display.Latex: If ``source`` is ``True``, a ``str`` of the LaTeX\n        representation of the array, else an ``IPython.display.Latex`` representation of\n        the array.\n\nRaises:\n    TypeError: If array can not be interpreted as a numerical numpy array.\n    ValueError: If the dimension of array is not 1 or 2.\n    MissingOptionalLibraryError: If ``source`` is ``False`` and ``IPython.display.Latex`` cannot be\n                 imported.",
        "api_signature": "array_to_latex(array, precision, prefix, source, max_size)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/array.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Arrow3D.__init__",
        "api_description": "",
        "api_signature": "__init__(self, xs, ys, zs, zdir)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/bloch.py"
    },
    {
        "api_name": "draw",
        "full_api_name": "Arrow3D.draw",
        "api_description": "",
        "api_signature": "draw(self, renderer)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/bloch.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Bloch.__init__",
        "api_description": "",
        "api_signature": "__init__(self, fig, axes, view, figsize, background, font_size)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/bloch.py"
    },
    {
        "api_name": "set_label_convention",
        "full_api_name": "Bloch.set_label_convention",
        "api_description": "Set x, y and z labels according to one of conventions.\n\nArgs:\n    convention (str):\n        One of the following:\n            - \"original\"\n            - \"xyz\"\n            - \"sx sy sz\"\n            - \"01\"\n            - \"polarization jones\"\n            - \"polarization jones letters\"\n            see also: http://en.wikipedia.org/wiki/Jones_calculus\n            - \"polarization stokes\"\n            see also: http://en.wikipedia.org/wiki/Stokes_parameters\nRaises:\n    Exception: If convention is not valid.",
        "api_signature": "set_label_convention(self, convention)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/bloch.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "Bloch.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/bloch.py"
    },
    {
        "api_name": "clear",
        "full_api_name": "Bloch.clear",
        "api_description": "Resets Bloch sphere data sets to empty.",
        "api_signature": "clear(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/bloch.py"
    },
    {
        "api_name": "add_points",
        "full_api_name": "Bloch.add_points",
        "api_description": "Add a list of data points to Bloch sphere.\n\nArgs:\n    points (array_like):\n        Collection of data points.\n    meth (str):\n        Type of points to plot, use 'm' for multicolored, 'l' for points\n        connected with a line.",
        "api_signature": "add_points(self, points, meth)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/bloch.py"
    },
    {
        "api_name": "add_vectors",
        "full_api_name": "Bloch.add_vectors",
        "api_description": "Add a list of vectors to Bloch sphere.\n\nArgs:\n    vectors (array_like):\n        Array with vectors of unit length or smaller.",
        "api_signature": "add_vectors(self, vectors)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/bloch.py"
    },
    {
        "api_name": "add_annotation",
        "full_api_name": "Bloch.add_annotation",
        "api_description": "Add a text or LaTeX annotation to Bloch sphere,\nparameterized by a qubit state or a vector.\n\nArgs:\n    state_or_vector (array_like):\n        Position for the annotation.\n        Qobj of a qubit or a vector of 3 elements.\n    text (str):\n        Annotation text.\n        You can use LaTeX, but remember to use raw string\n        e.g. r\"$\\langle x \\rangle$\"\n        or escape backslashes\n        e.g. \"$\\\\langle x \\\\rangle$\".\n    **kwargs:\n        Options as for mplot3d.axes3d.text, including:\n        fontsize, color, horizontalalignment, verticalalignment.\nRaises:\n    Exception: If input not array_like or tuple.",
        "api_signature": "add_annotation(self, state_or_vector, text)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/bloch.py"
    },
    {
        "api_name": "make_sphere",
        "full_api_name": "Bloch.make_sphere",
        "api_description": "Plots Bloch sphere and data sets.",
        "api_signature": "make_sphere(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/bloch.py"
    },
    {
        "api_name": "render",
        "full_api_name": "Bloch.render",
        "api_description": "Render the Bloch sphere and its data sets in on given figure and axes.",
        "api_signature": "render(self, title)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/bloch.py"
    },
    {
        "api_name": "plot_back",
        "full_api_name": "Bloch.plot_back",
        "api_description": "back half of sphere",
        "api_signature": "plot_back(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/bloch.py"
    },
    {
        "api_name": "plot_front",
        "full_api_name": "Bloch.plot_front",
        "api_description": "front half of sphere",
        "api_signature": "plot_front(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/bloch.py"
    },
    {
        "api_name": "plot_axes",
        "full_api_name": "Bloch.plot_axes",
        "api_description": "axes",
        "api_signature": "plot_axes(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/bloch.py"
    },
    {
        "api_name": "plot_axes_labels",
        "full_api_name": "Bloch.plot_axes_labels",
        "api_description": "axes labels",
        "api_signature": "plot_axes_labels(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/bloch.py"
    },
    {
        "api_name": "plot_vectors",
        "full_api_name": "Bloch.plot_vectors",
        "api_description": "Plot vector",
        "api_signature": "plot_vectors(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/bloch.py"
    },
    {
        "api_name": "plot_points",
        "full_api_name": "Bloch.plot_points",
        "api_description": "Plot points",
        "api_signature": "plot_points(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/bloch.py"
    },
    {
        "api_name": "plot_annotations",
        "full_api_name": "Bloch.plot_annotations",
        "api_description": "Plot annotations",
        "api_signature": "plot_annotations(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/bloch.py"
    },
    {
        "api_name": "show",
        "full_api_name": "Bloch.show",
        "api_description": "Display Bloch sphere and corresponding data sets.",
        "api_signature": "show(self, title)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/bloch.py"
    },
    {
        "api_name": "save",
        "full_api_name": "Bloch.save",
        "api_description": "Saves Bloch sphere to file of type ``format`` in directory ``dirc``.\n\nArgs:\n    name (str):\n        Name of saved image. Must include path and format as well.\n        i.e. '/Users/Paul/Desktop/bloch.png'\n        This overrides the 'format' and 'dirc' arguments.\n    output (str):\n        Format of output image.\n    dirc (str):\n        Directory for output images. Defaults to current working directory.",
        "api_signature": "save(self, name, output, dirc)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/bloch.py"
    },
    {
        "api_name": "_hide_tick_lines_and_labels",
        "full_api_name": "_hide_tick_lines_and_labels",
        "api_description": "Set visible property of ticklines and ticklabels of an axis to False",
        "api_signature": "_hide_tick_lines_and_labels(axis)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/bloch.py"
    },
    {
        "api_name": "pass_manager_drawer",
        "full_api_name": "pass_manager_drawer",
        "api_description": "Draws the pass manager.\n\nThis function needs `pydot <https://github.com/pydot/pydot>`__, which in turn needs\n`Graphviz <https://www.graphviz.org/>`__ to be installed.\n\nArgs:\n    pass_manager (PassManager): the pass manager to be drawn\n    filename (str): file path to save image to\n    style (dict or OrderedDict): keys are the pass classes and the values are\n        the colors to make them. An example can be seen in the DEFAULT_STYLE. An ordered\n        dict can be used to ensure a priority coloring when pass falls into multiple\n        categories. Any values not included in the provided dict will be filled in from\n        the default dict\n    raw (Bool) : True if you want to save the raw Dot output not an image. The\n        default is False.\nReturns:\n    PIL.Image or None: an in-memory representation of the pass manager. Or None if\n    no image was generated or PIL is not installed.\nRaises:\n    MissingOptionalLibraryError: when nxpd or pydot not installed.\n    VisualizationError: If raw=True and filename=None.\n\nExample:\n    .. code-block::\n\n         %matplotlib inline\n        from qiskit import QuantumCircuit\n        from qiskit.compiler import transpile\n        from qiskit.transpiler import PassManager\n        from qiskit.visualization import pass_manager_drawer\n        from qiskit.transpiler.passes import Unroller\n\n        circ = QuantumCircuit(3)\n        circ.ccx(0, 1, 2)\n        circ.draw()\n\n        pass_ = Unroller(['u1', 'u2', 'u3', 'cx'])\n        pm = PassManager(pass_)\n        new_circ = pm.run(circ)\n        new_circ.draw(output='mpl')\n\n        pass_manager_drawer(pm, \"passmanager.jpg\")",
        "api_signature": "pass_manager_drawer(pass_manager, filename, style, raw)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pass_manager_visualization.py"
    },
    {
        "api_name": "_get_node_color",
        "full_api_name": "_get_node_color",
        "api_description": "",
        "api_signature": "_get_node_color(pss, style)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pass_manager_visualization.py"
    },
    {
        "api_name": "staged_pass_manager_drawer",
        "full_api_name": "staged_pass_manager_drawer",
        "api_description": "Draws the staged pass manager.\n\n    This function needs `pydot <https://github.com/erocarrera/pydot>`__, which in turn needs\n`Graphviz <https://www.graphviz.org/>`__ to be installed.\n\nArgs:\n    pass_manager (StagedPassManager): the staged pass manager to be drawn\n    filename (str): file path to save image to\n    style (dict or OrderedDict): keys are the pass classes and the values are\n        the colors to make them. An example can be seen in the DEFAULT_STYLE. An ordered\n        dict can be used to ensure a priority coloring when pass falls into multiple\n        categories. Any values not included in the provided dict will be filled in from\n        the default dict\n    raw (Bool) : True if you want to save the raw Dot output not an image. The\n        default is False.\nReturns:\n    PIL.Image or None: an in-memory representation of the pass manager. Or None if\n    no image was generated or PIL is not installed.\nRaises:\n    MissingOptionalLibraryError: when nxpd or pydot not installed.\n    VisualizationError: If raw=True and filename=None.\n\nExample:\n    .. code-block::\n\n        %matplotlib inline\n        from qiskit.providers.fake_provider import FakeLagosV2\n        from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager\n\n        pass_manager = generate_preset_pass_manager(3, FakeLagosV2())\n        pass_manager.draw()",
        "api_signature": "staged_pass_manager_drawer(pass_manager, filename, style, raw)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pass_manager_visualization.py"
    },
    {
        "api_name": "draw_subgraph",
        "full_api_name": "draw_subgraph",
        "api_description": "Draw subgraph.",
        "api_signature": "draw_subgraph(controller_group, component_id, style, prev_node, idx)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pass_manager_visualization.py"
    },
    {
        "api_name": "make_output",
        "full_api_name": "make_output",
        "api_description": "Produce output for pass_manager.",
        "api_signature": "make_output(graph, raw, filename)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pass_manager_visualization.py"
    },
    {
        "api_name": "_get_backend_interface_version",
        "full_api_name": "_get_backend_interface_version",
        "api_description": "",
        "api_signature": "_get_backend_interface_version(backend)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/gate_map.py"
    },
    {
        "api_name": "plot_gate_map",
        "full_api_name": "plot_gate_map",
        "api_description": "Plots the gate map of a device.\n\nArgs:\n    backend (Backend): The backend instance that will be used to plot the device\n        gate map.\n    figsize (tuple): Output figure size (wxh) in inches.\n    plot_directed (bool): Plot directed coupling map.\n    label_qubits (bool): Label the qubits.\n    qubit_size (float): Size of qubit marker.\n    line_width (float): Width of lines.\n    font_size (int): Font size of qubit labels.\n    qubit_color (list): A list of colors for the qubits\n    qubit_labels (list): A list of qubit labels\n    line_color (list): A list of colors for each line from coupling_map.\n    font_color (str): The font color for the qubit labels.\n    ax (Axes): A Matplotlib axes instance.\n    filename (str): file path to save image to.\n    qubit_coordinates (Sequence): An optional sequence input (list or array being the\n        most common) of 2d coordinates for each qubit. The length of the\n        sequence much match the number of qubits on the backend. The sequence\n        should be the planar coordinates in a 0-based square grid where each\n        qubit is located.\n\nReturns:\n    Figure: A Matplotlib figure instance.\n\nRaises:\n    QiskitError: if tried to pass a simulator, or if the backend is None,\n        but one of num_qubits, mpl_data, or cmap is None.\n    MissingOptionalLibraryError: if matplotlib not installed.\n\nExample:\n\n    .. plot::\n       :include-source:\n\n       from qiskit import QuantumCircuit, execute\n       from qiskit.providers.fake_provider import FakeVigoV2\n       from qiskit.visualization import plot_gate_map\n\n       backend = FakeVigoV2()\n\n       plot_gate_map(backend)",
        "api_signature": "plot_gate_map(backend, figsize, plot_directed, label_qubits, qubit_size, line_width, font_size, qubit_color, qubit_labels, line_color, font_color, ax, filename, qubit_coordinates)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/gate_map.py"
    },
    {
        "api_name": "plot_coupling_map",
        "full_api_name": "plot_coupling_map",
        "api_description": "Plots an arbitrary coupling map of qubits (embedded in a plane).\n\nArgs:\n    num_qubits (int): The number of qubits defined and plotted.\n    qubit_coordinates (List[List[int]]): A list of two-element lists, with entries of each nested\n        list being the planar coordinates in a 0-based square grid where each qubit is located.\n    coupling_map (List[List[int]]): A list of two-element lists, with entries of each nested\n        list being the qubit numbers of the bonds to be plotted.\n    figsize (tuple): Output figure size (wxh) in inches.\n    plot_directed (bool): Plot directed coupling map.\n    label_qubits (bool): Label the qubits.\n    qubit_size (float): Size of qubit marker.\n    line_width (float): Width of lines.\n    font_size (int): Font size of qubit labels.\n    qubit_color (list): A list of colors for the qubits\n    qubit_labels (list): A list of qubit labels\n    line_color (list): A list of colors for each line from coupling_map.\n    font_color (str): The font color for the qubit labels.\n    ax (Axes): A Matplotlib axes instance.\n    filename (str): file path to save image to.\n\nReturns:\n    Figure: A Matplotlib figure instance.\n\nRaises:\n    MissingOptionalLibraryError: If matplotlib or graphviz is not installed.\n    QiskitError: If length of qubit labels does not match number of qubits.\n\nExample:\n\n    .. plot::\n       :include-source:\n\n        from qiskit.visualization import plot_coupling_map\n\n        num_qubits = 8\n        qubit_coordinates = [[0, 1], [1, 1], [1, 0], [1, 2], [2, 0], [2, 2], [2, 1], [3, 1]]\n        coupling_map = [[0, 1], [1, 2], [2, 3], [3, 5], [4, 5], [5, 6], [2, 4], [6, 7]]\n        plot_coupling_map(num_qubits, qubit_coordinates, coupling_map)",
        "api_signature": "plot_coupling_map(num_qubits, qubit_coordinates, coupling_map, figsize, plot_directed, label_qubits, qubit_size, line_width, font_size, qubit_color, qubit_labels, line_color, font_color, ax, filename)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/gate_map.py"
    },
    {
        "api_name": "color_node",
        "full_api_name": "color_node",
        "api_description": "",
        "api_signature": "color_node(node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/gate_map.py"
    },
    {
        "api_name": "color_edge",
        "full_api_name": "color_edge",
        "api_description": "",
        "api_signature": "color_edge(edge)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/gate_map.py"
    },
    {
        "api_name": "plot_circuit_layout",
        "full_api_name": "plot_circuit_layout",
        "api_description": "Plot the layout of a circuit transpiled for a given\ntarget backend.\n\nArgs:\n    circuit (QuantumCircuit): Input quantum circuit.\n    backend (Backend): Target backend.\n    view (str): Layout view: either 'virtual' or 'physical'.\n    qubit_coordinates (Sequence): An optional sequence input (list or array being the\n        most common) of 2d coordinates for each qubit. The length of the\n        sequence must match the number of qubits on the backend. The sequence\n        should be the planar coordinates in a 0-based square grid where each\n        qubit is located.\n\nReturns:\n    Figure: A matplotlib figure showing layout.\n\nRaises:\n    QiskitError: Invalid view type given.\n    VisualizationError: Circuit has no layout attribute.\n\nExample:\n    .. plot::\n       :include-source:\n\n        import numpy as np\n        from qiskit import QuantumCircuit, transpile\n        from qiskit.providers.fake_provider import FakeVigoV2\n        from qiskit.visualization import plot_circuit_layout\n        from qiskit.tools.monitor import job_monitor\n        from qiskit.providers.fake_provider import FakeVigoV2\n        import matplotlib.pyplot as plt\n\n        ghz = QuantumCircuit(3, 3)\n        ghz.h(0)\n        for idx in range(1,3):\n            ghz.cx(0,idx)\n        ghz.measure(range(3), range(3))\n\n        backend = FakeVigoV2()\n        new_circ_lv3 = transpile(ghz, backend=backend, optimization_level=3)\n        plot_circuit_layout(new_circ_lv3, backend)",
        "api_signature": "plot_circuit_layout(circuit, backend, view, qubit_coordinates)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/gate_map.py"
    },
    {
        "api_name": "plot_error_map",
        "full_api_name": "plot_error_map",
        "api_description": "Plots the error map of a given backend.\n\nArgs:\n    backend (Backend): Given backend.\n    figsize (tuple): Figure size in inches.\n    show_title (bool): Show the title or not.\n    qubit_coordinates (Sequence): An optional sequence input (list or array being the\n        most common) of 2d coordinates for each qubit. The length of the\n        sequence much mast the number of qubits on the backend. The sequence\n        should be the planar coordinates in a 0-based square grid where each\n        qubit is located.\n\nReturns:\n    Figure: A matplotlib figure showing error map.\n\nRaises:\n    VisualizationError: The backend does not provide gate errors for the 'sx' gate.\n    MissingOptionalLibraryError: If matplotlib or seaborn is not installed.\n\nExample:\n    .. plot::\n       :include-source:\n\n        from qiskit import QuantumCircuit, execute\n        from qiskit.visualization import plot_error_map\n        from qiskit.providers.fake_provider import FakeVigoV2\n\n        backend = FakeVigoV2()\n        plot_error_map(backend)",
        "api_signature": "plot_error_map(backend, figsize, show_title, qubit_coordinates)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/gate_map.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "WaveformChannel.__init__",
        "api_description": "Create new waveform channel.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/types.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ChannelEvents.__init__",
        "api_description": "Create new event manager.\n\nArgs:\n    waveforms: List of waveforms shown in this channel.\n    frames: List of frame change type instructions shown in this channel.\n    channel: Channel object associated with this manager.",
        "api_signature": "__init__(self, waveforms, frames, channel)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/events.py"
    },
    {
        "api_name": "load_program",
        "full_api_name": "ChannelEvents.load_program",
        "api_description": "Load a pulse program represented by ``Schedule``.\n\nArgs:\n    program: Target ``Schedule`` to visualize.\n    channel: The channel managed by this instance.\n\nReturns:\n    ChannelEvents: The channel event manager for the specified channel.",
        "api_signature": "load_program(cls, program, channel)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/events.py"
    },
    {
        "api_name": "set_config",
        "full_api_name": "ChannelEvents.set_config",
        "api_description": "Setup system status.\n\nArgs:\n    dt: Time resolution in sec.\n    init_frequency: Modulation frequency in Hz.\n    init_phase: Initial phase in rad.",
        "api_signature": "set_config(self, dt, init_frequency, init_phase)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/events.py"
    },
    {
        "api_name": "get_waveforms",
        "full_api_name": "ChannelEvents.get_waveforms",
        "api_description": "Return waveform type instructions with frame.",
        "api_signature": "get_waveforms(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/events.py"
    },
    {
        "api_name": "get_frame_changes",
        "full_api_name": "ChannelEvents.get_frame_changes",
        "api_description": "Return frame change type instructions with total frame change amount.",
        "api_signature": "get_frame_changes(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/events.py"
    },
    {
        "api_name": "_calculate_current_frame",
        "full_api_name": "ChannelEvents._calculate_current_frame",
        "api_description": "Calculate the current frame from the previous frame.\n\nIf parameter is unbound phase or frequency accumulation with this instruction is skipped.\n\nArgs:\n    frame_changes: List of frame change instructions at a specific time.\n    phase: Phase of previous frame.\n    frequency: Frequency of previous frame.\n\nReturns:\n    Phase and frequency of new frame.",
        "api_signature": "_calculate_current_frame(cls, frame_changes, phase, frequency)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/events.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QiskitPulseStyle.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/stylesheet.py"
    },
    {
        "api_name": "update",
        "full_api_name": "QiskitPulseStyle.update",
        "api_description": "",
        "api_signature": "update(self, __m)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/stylesheet.py"
    },
    {
        "api_name": "formatter",
        "full_api_name": "QiskitPulseStyle.formatter",
        "api_description": "Return formatter field of style dictionary.",
        "api_signature": "formatter(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/stylesheet.py"
    },
    {
        "api_name": "generator",
        "full_api_name": "QiskitPulseStyle.generator",
        "api_description": "Return generator field of style dictionary.",
        "api_signature": "generator(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/stylesheet.py"
    },
    {
        "api_name": "layout",
        "full_api_name": "QiskitPulseStyle.layout",
        "api_description": "Return layout field of style dictionary.",
        "api_signature": "layout(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/stylesheet.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "IQXStandard.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/stylesheet.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "IQXStandard.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/stylesheet.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "IQXSimple.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/stylesheet.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "IQXSimple.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/stylesheet.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "IQXDebugging.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/stylesheet.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "IQXDebugging.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/stylesheet.py"
    },
    {
        "api_name": "default_style",
        "full_api_name": "default_style",
        "api_description": "Define default values of the pulse stylesheet.",
        "api_signature": "default_style()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/stylesheet.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "DrawerBackendInfo.__init__",
        "api_description": "Create new backend information.\n\nArgs:\n    name: Name of the backend.\n    dt: System cycle time.\n    channel_frequency_map: Mapping of channel and associated frequency.\n    qubit_channel_map: Mapping of qubit and associated channels.",
        "api_signature": "__init__(self, name, dt, channel_frequency_map, qubit_channel_map)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/device_info.py"
    },
    {
        "api_name": "create_from_backend",
        "full_api_name": "DrawerBackendInfo.create_from_backend",
        "api_description": "Initialize a class with backend information provided by provider.\n\nArgs:\n    backend: Backend object.",
        "api_signature": "create_from_backend(cls, backend)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/device_info.py"
    },
    {
        "api_name": "dt",
        "full_api_name": "DrawerBackendInfo.dt",
        "api_description": "Return cycle time.",
        "api_signature": "dt(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/device_info.py"
    },
    {
        "api_name": "get_qubit_index",
        "full_api_name": "DrawerBackendInfo.get_qubit_index",
        "api_description": "Get associated qubit index of given channel object.",
        "api_signature": "get_qubit_index(self, chan)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/device_info.py"
    },
    {
        "api_name": "get_channel_frequency",
        "full_api_name": "DrawerBackendInfo.get_channel_frequency",
        "api_description": "Get frequency of given channel object.",
        "api_signature": "get_channel_frequency(self, chan)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/device_info.py"
    },
    {
        "api_name": "create_from_backend",
        "full_api_name": "OpenPulseBackendInfo.create_from_backend",
        "api_description": "Initialize a class with backend information provided by provider.\n\nArgs:\n    backend: Backend object.\n\nReturns:\n    OpenPulseBackendInfo: New configured instance.",
        "api_signature": "create_from_backend(cls, backend)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/device_info.py"
    },
    {
        "api_name": "draw",
        "full_api_name": "draw",
        "api_description": "Generate visualization data for pulse programs.\n\nArgs:\n    program: Program to visualize. This program can be arbitrary Qiskit Pulse program,\n        such as :py:class:`~qiskit.pulse.Waveform`, :py:class:`~qiskit.pulse.ParametricPulse`,\n        :py:class:`~qiskit.pulse.SymbolicPulse`, :py:class:`~qiskit.pulse.Schedule`\n        and :py:class:`~qiskit.pulse.ScheduleBlock`.\n    style: Stylesheet options. This can be dictionary or preset stylesheet classes. See\n        :py:class:`~qiskit.visualization.pulse_v2.stylesheets.IQXStandard`,\n        :py:class:`~qiskit.visualization.pulse_v2.stylesheets.IQXSimple`, and\n        :py:class:`~qiskit.visualization.pulse_v2.stylesheets.IQXDebugging` for details of\n        preset stylesheets. See also the stylesheet section for details of configuration keys.\n    backend: Backend object to play the input pulse program. If provided, the plotter\n        may use to make the visualization hardware aware.\n    time_range: Set horizontal axis limit. Tuple ``(tmin, tmax)``.\n    time_unit: The unit of specified time range either ``dt`` or ``ns``.\n        The unit of ``ns`` is available only when ``backend`` object is provided.\n    disable_channels: A control property to show specific pulse channel.\n        Pulse channel instances provided as a list is not shown in the output image.\n    show_snapshot: Show snapshot instructions.\n    show_framechange: Show frame change instructions. The frame change represents\n        instructions that modulate phase or frequency of pulse channels.\n    show_waveform_info: Show waveform annotations, i.e. name, of waveforms.\n        Set ``True`` to show additional information about waveforms.\n    show_barrier: Show barrier lines.\n    plotter: Name of plotter API to generate an output image.\n        One of following APIs should be specified::\n\n            mpl2d: Matplotlib API for 2D image generation.\n                Matplotlib API to generate 2D image. Charts are placed along y axis with\n                vertical offset. This API takes matplotlib.axes.Axes as `axis` input.\n\n        `axis` and `style` kwargs may depend on the plotter.\n    axis: Arbitrary object passed to the plotter. If this object is provided,\n        the plotters use a given ``axis`` instead of internally initializing\n        a figure object. This object format depends on the plotter.\n        See plotter argument for details.\n\nReturns:\n    Visualization output data.\n    The returned data type depends on the `plotter`.\n    If matplotlib family is specified, this will be a `matplotlib.pyplot.Figure` data.\n    The returned data is generated by the :meth:`get_image` method of the specified plotter API.\n\n.. _style-dict-doc:\n\n**Style Dict Details**\n\nThe stylesheet kwarg contains numerous options that define the style of the\noutput pulse visualization.\nThe stylesheet options can be classified into `formatter`, `generator` and `layout`.\nThose options available in the stylesheet are defined below:\n\nArgs:\n    formatter.general.fig_width: Width of output image (default `13`).\n    formatter.general.fig_chart_height: Height of output image per chart.\n        The height of each chart is multiplied with this factor and the\n        sum of all chart heights becomes the height of output image (default `1.5`).\n    formatter.general.vertical_resolution: Vertical resolution of the pulse envelope.\n        The change of data points below this limit is ignored (default `1e-6`).\n    formatter.general.max_scale: Maximum scaling factor of each chart. This factor is\n        considered when chart auto-scaling is enabled (default `100`).\n    formatter.color.waveforms: A dictionary of the waveform colors to use for\n        each element type in the output visualization. The default values are::\n\n            {\n                'W': `['#648fff', '#002999']`,\n                'D': `['#648fff', '#002999']`,\n                'U': `['#ffb000', '#994A00']`,\n                'M': `['#dc267f', '#760019']`,\n                'A': `['#dc267f', '#760019']`\n            }\n\n    formatter.color.baseline: Color code of lines of zero line of each chart\n        (default `'#000000'`).\n    formatter.color.barrier: Color code of lines of barrier (default `'#222222'`).\n    formatter.color.background: Color code of the face color of canvas\n        (default `'#f2f3f4'`).\n    formatter.color.fig_title: Color code of the figure title text\n        (default `'#000000'`).\n    formatter.color.annotate: Color code of annotation texts in the canvas\n        (default `'#222222'`).\n    formatter.color.frame_change: Color code of the symbol for frame changes\n        (default `'#000000'`).\n    formatter.color.snapshot: Color code of the symbol for snapshot\n        (default `'#000000'`)\n    formatter.color.opaque_shape: Color code of the face and edge of opaque shape box\n        (default `['#fffacd', '#000000']`)\n    formatter.color.axis_label: Color code of axis labels (default `'#000000'`).\n    formatter.alpha.fill_waveform: Transparency of waveforms. A value in the range from\n        `0` to `1`. The value `0` gives completely transparent waveforms (default `0.3`).\n    formatter.alpha.baseline: Transparency of base lines. A value in the range from\n        `0` to `1`. The value `0` gives completely transparent base lines (default `1.0`).\n    formatter.alpha.barrier: Transparency of barrier lines. A value in the range from\n        `0` to `1`. The value `0` gives completely transparent barrier lines (default `0.7`).\n    formatter.alpha.opaque_shape: Transparency of opaque shape box. A value in the range from\n        `0` to `1`. The value `0` gives completely transparent barrier lines (default `0.7`).\n    formatter.layer.fill_waveform: Layer index of waveforms. Larger number comes\n        in the front of the output image (default `2`).\n    formatter.layer.baseline: Layer index of baselines. Larger number comes\n        in the front of the output image (default `1`).\n    formatter.layer.barrier: Layer index of barrier lines. Larger number comes\n        in the front of the output image (default `1`).\n    formatter.layer.annotate: Layer index of annotations. Larger number comes\n        in the front of the output image (default `5`).\n    formatter.layer.axis_label: Layer index of axis labels. Larger number comes\n        in the front of the output image (default `5`).\n    formatter.layer.frame_change: Layer index of frame change symbols. Larger number comes\n        in the front of the output image (default `4`).\n    formatter.layer.snapshot: Layer index of snapshot symbols. Larger number comes\n        in the front of the output image (default `3`).\n    formatter.layer.fig_title: Layer index of the figure title. Larger number comes\n        in the front of the output image (default `6`).\n    formatter.margin.top: Margin from the top boundary of the figure canvas to\n        the surface of the first chart (default `0.5`).\n    formatter.margin.bottom: Margin from the bottom boundary of the figure canvas to\n        the surface of the last chart (default `0.5`).\n    formatter.margin.left_percent: Margin from the left boundary of the figure canvas to\n        the zero point of the horizontal axis. The value is in units of percentage of\n        the whole program duration. If the duration is 100 and the value of 0.5 is set,\n        this keeps left margin of 5 (default `0.05`).\n    formatter.margin.right_percent: Margin from the right boundary of the figure canvas to\n        the left limit of the horizontal axis. The value is in units of percentage of\n        the whole program duration. If the duration is 100 and the value of 0.5 is set,\n        this keeps right margin of 5 (default `0.05`).\n    formatter.margin.between_channel: Vertical margin between charts (default `0.2`).\n    formatter.label_offset.pulse_name: Offset of pulse name annotations from the\n        chart baseline (default `0.3`).\n    formatter.label_offset.chart_info: Offset of chart info annotations from the\n        chart baseline (default `0.3`).\n    formatter.label_offset.frame_change: Offset of frame change annotations from the\n        chart baseline (default `0.3`).\n    formatter.label_offset.snapshot: Offset of snapshot annotations from the\n        chart baseline (default `0.3`).\n    formatter.text_size.axis_label: Text size of axis labels (default `15`).\n    formatter.text_size.annotate: Text size of annotations (default `12`).\n    formatter.text_size.frame_change: Text size of frame change symbols (default `20`).\n    formatter.text_size.snapshot: Text size of snapshot symbols (default `20`).\n    formatter.text_size.fig_title: Text size of the figure title (default `15`).\n    formatter.text_size.axis_break_symbol: Text size of axis break symbols (default `15`).\n    formatter.line_width.fill_waveform: Line width of the fringe of filled waveforms\n        (default `0`).\n    formatter.line_width.axis_break: Line width of axis breaks.\n        The axis break line paints over other drawings with the background\n        face color (default `6`).\n    formatter.line_width.baseline: Line width of base lines (default `1`)\n    formatter.line_width.barrier: Line width of barrier lines (default `1`).\n    formatter.line_width.opaque_shape: Line width of opaque shape box (default `1`).\n    formatter.line_style.fill_waveform: Line style of the fringe of filled waveforms. This\n        conforms to the line style spec of matplotlib (default `'-'`).\n    formatter.line_style.baseline: Line style of base lines. This\n        conforms to the line style spec of matplotlib (default `'-'`).\n    formatter.line_style.barrier: Line style of barrier lines. This\n        conforms to the line style spec of matplotlib (default `':'`).\n    formatter.line_style.opaque_shape: Line style of opaque shape box. This\n        conforms to the line style spec of matplotlib (default `'--'`).\n    formatter.channel_scaling.drive: Default scaling value of drive channel\n        waveforms (default `1.0`).\n    formatter.channel_scaling.control: Default scaling value of control channel\n        waveforms (default `1.0`).\n    formatter.channel_scaling.measure: Default scaling value of measure channel\n        waveforms (default `1.0`).\n    formatter.channel_scaling.acquire: Default scaling value of acquire channel\n        waveforms (default `1.0`).\n    formatter.channel_scaling.pos_spacing: Minimum height of chart above the baseline.\n        Chart top is determined based on the maximum height of waveforms associated\n        with the chart. If the maximum height is below this value, this value is set\n        as the chart top (default 0.1).\n    formatter.channel_scaling.neg_spacing: Minimum height of chart below the baseline.\n        Chart bottom is determined based on the minimum height of waveforms associated\n        with the chart. If the minimum height is above this value, this value is set\n        as the chart bottom (default -0.1).\n    formatter.box_width.opaque_shape: Default box length of the waveform representation\n        when the instruction is parameterized and duration is not bound or not defined.\n        Value is units in dt (default: 150).\n    formatter.box_height.opaque_shape: Default box height of the waveform representation\n        when the instruction is parameterized (default: 0.4).\n    formatter.axis_break.length: Waveform or idle time duration that axis break is\n        applied. Intervals longer than this value are truncated.\n        The value is in units of data points (default `3000`).\n    formatter.axis_break.max_length: Length of new waveform or idle time duration\n        after axis break is applied. Longer intervals are truncated to this length\n        (default `1000`).\n    formatter.control.fill_waveform: Set `True` to fill waveforms with face color\n        (default `True`). When you disable this option, you should set finite line width\n        to `formatter.line_width.fill_waveform`, otherwise nothing will appear in the graph.\n    formatter.control.apply_phase_modulation: Set `True` to apply phase modulation\n        to the waveforms (default `True`).\n    formatter.control.show_snapshot_channel: Set `True` to show snapshot instructions\n        (default `True`).\n    formatter.control.show_acquire_channel: Set `True` to show acquire channels\n        (default `True`).\n    formatter.control.show_empty_channel: Set `True` to show charts without any waveforms\n        (default `True`).\n    formatter.control.auto_chart_scaling: Set `True` to apply auto-scaling to charts\n        (default `True`).\n    formatter.control.axis_break: Set `True` to apply axis break for long intervals\n        (default `True`).\n    formatter.unicode_symbol.frame_change: Text that represents the symbol of\n        frame change. This text is used when the plotter doesn't support latex\n        (default u'\u21ba').\n    formatter.unicode_symbol.snapshot: Text that represents the symbol of\n        snapshot. This text is used when the plotter doesn't support latex\n        (default u'\u21af').\n    formatter.unicode_symbol.phase_parameter: Text that represents the symbol of\n        parameterized phase value. This text is used when the plotter doesn't support latex\n        (default u'\u03b8').\n    formatter.unicode_symbol.freq_parameter: Text that represents the symbol of\n        parameterized frequency value. This text is used when the plotter doesn't support latex\n        (default 'f').\n    formatter.latex_symbol.frame_change: Latex text that represents the symbol of\n        frame change (default r'\\circlearrowleft').\n    formatter.latex_symbol.snapshot: Latex text that represents the symbol of\n        snapshot (default '').\n    formatter.latex_symbol.phase_parameter: Latex text that represents the symbol of\n        parameterized phase value (default r'       heta').\n    formatter.latex_symbol.freq_parameter: Latex text that represents the symbol of\n        parameterized frequency value (default 'f').\n    generator.waveform: List of callback functions that generates drawing\n        for waveforms. Arbitrary callback functions satisfying the generator format\n        can be set here. There are some default generators in the pulse drawer.\n        See :py:mod:`~qiskit.visualization.pulse_v2.generators.waveform` for more details.\n        No default generator is set.\n    generator.frame: List of callback functions that generates drawing\n        for frame changes. Arbitrary callback functions satisfying the generator format\n        can be set here. There are some default generators in the pulse drawer.\n        See :py:mod:`~qiskit.visualization.pulse_v2.generators.frame` for more details.\n        No default generator is set.\n    generator.chart: List of callback functions that generates drawing\n        for charts. Arbitrary callback functions satisfying the generator format\n        can be set here. There are some default generators in the pulse drawer.\n        See :py:mod:`~qiskit.visualization.pulse_v2.generators.chart` for more details.\n        No default generator is set.\n    generator.snapshot: List of callback functions that generates drawing\n        for snapshots. Arbitrary callback functions satisfying the generator format\n        can be set here. There are some default generators in the pulse drawer.\n        See :py:mod:`~qiskit.visualization.pulse_v2.generators.snapshot` for more details.\n        No default generator is set.\n    generator.barrier: List of callback functions that generates drawing\n        for barriers. Arbitrary callback functions satisfying the generator format\n        can be set here. There are some default generators in the pulse drawer.\n        See :py:mod:`~qiskit.visualization.pulse_v2.generators.barrier` for more details.\n        No default generator is set.\n    layout.chart_channel_map: Callback function that determines the relationship\n        between pulse channels and charts.\n        See :py:mod:`~qiskit.visualization.pulse_v2.layout` for more details.\n        No default layout is set.\n    layout.time_axis_map: Callback function that determines the layout of\n        horizontal axis labels.\n        See :py:mod:`~qiskit.visualization.pulse_v2.layout` for more details.\n        No default layout is set.\n    layout.figure_title: Callback function that generates a string for\n        the figure title.\n        See :py:mod:`~qiskit.visualization.pulse_v2.layout` for more details.\n        No default layout is set.\n\nExamples:\n    To visualize a pulse program, you can call this function with set of\n    control arguments. Most of appearance of the output image can be controlled by the\n    stylesheet.\n\n    Drawing with the default stylesheet.\n\n    .. plot::\n       :include-source:\n\n        from qiskit import QuantumCircuit, transpile, schedule\n        from qiskit.visualization.pulse_v2 import draw\n        from qiskit.providers.fake_provider import FakeBoeblingen\n\n        qc = QuantumCircuit(2)\n        qc.h(0)\n        qc.cx(0, 1)\n        qc.measure_all()\n        qc = transpile(qc, FakeBoeblingen(), layout_method='trivial')\n        sched = schedule(qc, FakeBoeblingen())\n\n        draw(sched, backend=FakeBoeblingen())\n\n    Drawing with the stylesheet suited for publication.\n\n    .. plot::\n       :include-source:\n\n        from qiskit import QuantumCircuit, transpile, schedule\n        from qiskit.visualization.pulse_v2 import draw, IQXSimple\n        from qiskit.providers.fake_provider import FakeBoeblingen\n\n        qc = QuantumCircuit(2)\n        qc.h(0)\n        qc.cx(0, 1)\n        qc.measure_all()\n        qc = transpile(qc, FakeBoeblingen(), layout_method='trivial')\n        sched = schedule(qc, FakeBoeblingen())\n\n        draw(sched, style=IQXSimple(), backend=FakeBoeblingen())\n\n    Drawing with the stylesheet suited for program debugging.\n\n    .. plot::\n       :include-source:\n\n        from qiskit import QuantumCircuit, transpile, schedule\n        from qiskit.visualization.pulse_v2 import draw, IQXDebugging\n        from qiskit.providers.fake_provider import FakeBoeblingen\n\n        qc = QuantumCircuit(2)\n        qc.h(0)\n        qc.cx(0, 1)\n        qc.measure_all()\n        qc = transpile(qc, FakeBoeblingen(), layout_method='trivial')\n        sched = schedule(qc, FakeBoeblingen())\n\n        draw(sched, style=IQXDebugging(), backend=FakeBoeblingen())\n\n    You can partially customize a preset stylesheet when initializing it.\n\n    .. code-block:: python\n\n        my_style = {\n            'formatter.channel_scaling.drive': 5,\n            'formatter.channel_scaling.control': 1,\n            'formatter.channel_scaling.measure': 5\n        }\n        style = IQXStandard(**my_style)\n        # draw\n        draw(sched, style=style, backend=FakeBoeblingen())\n\n    In the same way as above, you can create custom generator or layout functions\n    and update the existing stylesheet with custom functions.\n    This feature enables you to customize most of the appearance of the output image\n    without modifying the codebase.\n\nRaises:\n    MissingOptionalLibraryError: When required visualization package is not installed.\n    VisualizationError: When invalid plotter API or invalid time range is specified.",
        "api_signature": "draw(program, style, backend, time_range, time_unit, disable_channels, show_snapshot, show_framechange, show_waveform_info, show_barrier, plotter, axis)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/interface.py"
    },
    {
        "api_name": "channel_type_grouped_sort",
        "full_api_name": "channel_type_grouped_sort",
        "api_description": "Layout function for the channel assignment to the chart instance.\n\nAssign single channel per chart. Channels are grouped by type and\nsorted by index in ascending order.\n\nStylesheet key:\n    `chart_channel_map`\n\nFor example:\n    [D0, D2, C0, C2, M0, M2, A0, A2] -> [D0, D2, C0, C2, M0, M2, A0, A2]\n\nArgs:\n    channels: Channels to show.\n    formatter: Dictionary of stylesheet settings.\n    device: Backend configuration.\n\nYields:\n    Tuple of chart name and associated channels.",
        "api_signature": "channel_type_grouped_sort(channels, formatter, device)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/layouts.py"
    },
    {
        "api_name": "channel_index_grouped_sort",
        "full_api_name": "channel_index_grouped_sort",
        "api_description": "Layout function for the channel assignment to the chart instance.\n\nAssign single channel per chart. Channels are grouped by the same index and\nsorted by type.\n\nStylesheet key:\n    `chart_channel_map`\n\nFor example:\n    [D0, D2, C0, C2, M0, M2, A0, A2] -> [D0, D2, C0, C2, M0, M2, A0, A2]\n\nArgs:\n    channels: Channels to show.\n    formatter: Dictionary of stylesheet settings.\n    device: Backend configuration.\n\nYields:\n    Tuple of chart name and associated channels.",
        "api_signature": "channel_index_grouped_sort(channels, formatter, device)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/layouts.py"
    },
    {
        "api_name": "channel_index_grouped_sort_u",
        "full_api_name": "channel_index_grouped_sort_u",
        "api_description": "Layout function for the channel assignment to the chart instance.\n\nAssign single channel per chart. Channels are grouped by the same index and\nsorted by type except for control channels. Control channels are added to the\nend of other channels.\n\nStylesheet key:\n    `chart_channel_map`\n\nFor example:\n    [D0, D2, C0, C2, M0, M2, A0, A2] -> [D0, D2, C0, C2, M0, M2, A0, A2]\n\nArgs:\n    channels: Channels to show.\n    formatter: Dictionary of stylesheet settings.\n    device: Backend configuration.\n\nYields:\n    Tuple of chart name and associated channels.",
        "api_signature": "channel_index_grouped_sort_u(channels, formatter, device)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/layouts.py"
    },
    {
        "api_name": "qubit_index_sort",
        "full_api_name": "qubit_index_sort",
        "api_description": "Layout function for the channel assignment to the chart instance.\n\nAssign multiple channels per chart. Channels associated with the same qubit\nare grouped in the same chart and sorted by qubit index in ascending order.\n\nAcquire channels are not shown.\n\nStylesheet key:\n    `chart_channel_map`\n\nFor example:\n    [D0, D2, C0, C2, M0, M2, A0, A2] -> [Q0, Q1, Q2]\n\nArgs:\n    channels: Channels to show.\n    formatter: Dictionary of stylesheet settings.\n    device: Backend configuration.\n\nYields:\n    Tuple of chart name and associated channels.",
        "api_signature": "qubit_index_sort(channels, formatter, device)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/layouts.py"
    },
    {
        "api_name": "time_map_in_ns",
        "full_api_name": "time_map_in_ns",
        "api_description": "Layout function for the horizontal axis formatting.\n\nCalculate axis break and map true time to axis labels. Generate equispaced\n6 horizontal axis ticks. Convert into seconds if ``dt`` is provided.\n\nArgs:\n    time_window: Left and right edge of this graph.\n    axis_breaks: List of axis break period.\n    dt: Time resolution of system.\n\nReturns:\n    Axis formatter object.",
        "api_signature": "time_map_in_ns(time_window, axis_breaks, dt)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/layouts.py"
    },
    {
        "api_name": "detail_title",
        "full_api_name": "detail_title",
        "api_description": "Layout function for generating figure title.\n\nThis layout writes program name, program duration, and backend name in the title.",
        "api_signature": "detail_title(program, device)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/layouts.py"
    },
    {
        "api_name": "empty_title",
        "full_api_name": "empty_title",
        "api_description": "Layout function for generating an empty figure title.",
        "api_signature": "empty_title(program, device)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/layouts.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "DrawerCanvas.__init__",
        "api_description": "Create new data container with backend system information.\n\nArgs:\n    stylesheet: Stylesheet to decide appearance of output image.\n    device: Backend information to run the program.",
        "api_signature": "__init__(self, stylesheet, device)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/core.py"
    },
    {
        "api_name": "time_range",
        "full_api_name": "DrawerCanvas.time_range",
        "api_description": "Return current time range to draw.\n\nCalculate net duration and add side margin to edge location.\n\nReturns:\n    Time window considering side margin.",
        "api_signature": "time_range(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/core.py"
    },
    {
        "api_name": "time_range",
        "full_api_name": "DrawerCanvas.time_range",
        "api_description": "Update time range to draw.",
        "api_signature": "time_range(self, new_range)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/core.py"
    },
    {
        "api_name": "time_breaks",
        "full_api_name": "DrawerCanvas.time_breaks",
        "api_description": "Return time breaks with time range.\n\nIf an edge of time range is in the axis break period,\nthe axis break period is recalculated.\n\nRaises:\n    VisualizationError: When axis break is greater than time window.\n\nReturns:\n    List of axis break periods considering the time window edges.",
        "api_signature": "time_breaks(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/core.py"
    },
    {
        "api_name": "time_breaks",
        "full_api_name": "DrawerCanvas.time_breaks",
        "api_description": "Set new time breaks.",
        "api_signature": "time_breaks(self, new_breaks)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/core.py"
    },
    {
        "api_name": "load_program",
        "full_api_name": "DrawerCanvas.load_program",
        "api_description": "Load a program to draw.\n\nArgs:\n    program: Pulse program or waveform to draw.\n\nRaises:\n    VisualizationError: When input program is invalid data format.",
        "api_signature": "load_program(self, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/core.py"
    },
    {
        "api_name": "_waveform_loader",
        "full_api_name": "DrawerCanvas._waveform_loader",
        "api_description": "Load Waveform instance.\n\nThis function is sub-routine of py:method:`load_program`.\n\nArgs:\n    program: `Waveform` to draw.",
        "api_signature": "_waveform_loader(self, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/core.py"
    },
    {
        "api_name": "_schedule_loader",
        "full_api_name": "DrawerCanvas._schedule_loader",
        "api_description": "Load Schedule instance.\n\nThis function is sub-routine of py:method:`load_program`.\n\nArgs:\n    program: `Schedule` to draw.",
        "api_signature": "_schedule_loader(self, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/core.py"
    },
    {
        "api_name": "_calculate_axis_break",
        "full_api_name": "DrawerCanvas._calculate_axis_break",
        "api_description": "A helper function to calculate axis break of long pulse sequence.\n\nArgs:\n    program: A schedule to calculate axis break.\n\nReturns:\n    List of axis break periods.",
        "api_signature": "_calculate_axis_break(self, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/core.py"
    },
    {
        "api_name": "set_time_range",
        "full_api_name": "DrawerCanvas.set_time_range",
        "api_description": "Set time range to draw.\n\nAll child chart instances are updated when time range is updated.\n\nArgs:\n    t_start: Left boundary of drawing in units of cycle time or real time.\n    t_end: Right boundary of drawing in units of cycle time or real time.\n    seconds: Set `True` if times are given in SI unit rather than dt.\n\nRaises:\n    VisualizationError: When times are given in float without specifying dt.",
        "api_signature": "set_time_range(self, t_start, t_end, seconds)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/core.py"
    },
    {
        "api_name": "set_disable_channel",
        "full_api_name": "DrawerCanvas.set_disable_channel",
        "api_description": "Interface method to control visibility of pulse channels.\n\nSpecified object in the blocked list will not be shown.\n\nArgs:\n    channel: A pulse channel object to disable.\n    remove: Set `True` to disable, set `False` to enable.",
        "api_signature": "set_disable_channel(self, channel, remove)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/core.py"
    },
    {
        "api_name": "set_disable_type",
        "full_api_name": "DrawerCanvas.set_disable_type",
        "api_description": "Interface method to control visibility of data types.\n\nSpecified object in the blocked list will not be shown.\n\nArgs:\n    data_type: A drawing data type to disable.\n    remove: Set `True` to disable, set `False` to enable.",
        "api_signature": "set_disable_type(self, data_type, remove)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/core.py"
    },
    {
        "api_name": "update",
        "full_api_name": "DrawerCanvas.update",
        "api_description": "Update all associated charts and generate actual drawing data from template object.\n\nThis method should be called before the canvas is passed to the plotter.",
        "api_signature": "update(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/core.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Chart.__init__",
        "api_description": "Create new chart.\n\nArgs:\n    parent: `DrawerCanvas` that this `Chart` instance belongs to.\n    name: Name of this `Chart` instance.",
        "api_signature": "__init__(self, parent, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/core.py"
    },
    {
        "api_name": "add_data",
        "full_api_name": "Chart.add_data",
        "api_description": "Add drawing to collections.\n\nIf the given object already exists in the collections,\nthis interface replaces the old object instead of adding new entry.\n\nArgs:\n    data: New drawing to add.",
        "api_signature": "add_data(self, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/core.py"
    },
    {
        "api_name": "load_program",
        "full_api_name": "Chart.load_program",
        "api_description": "Load pulse schedule.\n\nThis method internally generates `ChannelEvents` to parse the program\nfor the specified pulse channel. This method is called once\n\nArgs:\n    program: Pulse schedule to load.\n    chan: A pulse channels associated with this instance.",
        "api_signature": "load_program(self, program, chan)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/core.py"
    },
    {
        "api_name": "update",
        "full_api_name": "Chart.update",
        "api_description": "Update vertical data range and scaling factor of this chart.\n\nThose parameters are updated based on current time range in the parent canvas.",
        "api_signature": "update(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/core.py"
    },
    {
        "api_name": "is_active",
        "full_api_name": "Chart.is_active",
        "api_description": "Check if there is any active waveform data in this entry.\n\nReturns:\n    Return `True` if there is any visible waveform in this chart.",
        "api_signature": "is_active(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/core.py"
    },
    {
        "api_name": "collections",
        "full_api_name": "Chart.collections",
        "api_description": "Return currently active entries from drawing data collection.\n\nThe object is returned with unique name as a key of an object handler.\nWhen the horizontal coordinate contains `AbstractCoordinate`,\nthe value is substituted by current time range preference.",
        "api_signature": "collections(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/core.py"
    },
    {
        "api_name": "channels",
        "full_api_name": "Chart.channels",
        "api_description": "Return a list of channels associated with this chart.\n\nReturns:\n    List of channels associated with this chart.",
        "api_signature": "channels(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/core.py"
    },
    {
        "api_name": "_truncate_data",
        "full_api_name": "Chart._truncate_data",
        "api_description": "A helper function to truncate drawings according to time breaks.\n\n# TODO: move this function to common module to support axis break for timeline.\n\nArgs:\n    data: Drawing object to truncate.\n\nReturns:\n    Set of truncated numpy arrays for x and y coordinate.",
        "api_signature": "_truncate_data(self, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/core.py"
    },
    {
        "api_name": "_truncate_pulse_labels",
        "full_api_name": "Chart._truncate_pulse_labels",
        "api_description": "A helper function to remove text according to time breaks.\n\nArgs:\n    xvals: Time points.\n    yvals: Data points.\n\nReturns:\n    Set of truncated numpy arrays for x and y coordinate.",
        "api_signature": "_truncate_pulse_labels(self, xvals, yvals)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/core.py"
    },
    {
        "api_name": "_truncate_boxes",
        "full_api_name": "Chart._truncate_boxes",
        "api_description": "A helper function to clip box object according to time breaks.\n\nArgs:\n    xvals: Time points.\n    yvals: Data points.\n\nReturns:\n    Set of truncated numpy arrays for x and y coordinate.",
        "api_signature": "_truncate_boxes(self, xvals, yvals)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/core.py"
    },
    {
        "api_name": "_truncate_vectors",
        "full_api_name": "Chart._truncate_vectors",
        "api_description": "A helper function to remove sequential data points according to time breaks.\n\nArgs:\n    xvals: Time points.\n    yvals: Data points.\n\nReturns:\n    Set of truncated numpy arrays for x and y coordinate.",
        "api_signature": "_truncate_vectors(self, xvals, yvals)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/core.py"
    },
    {
        "api_name": "_bind_coordinate",
        "full_api_name": "Chart._bind_coordinate",
        "api_description": "A helper function to bind actual coordinates to an `AbstractCoordinate`.\n\nArgs:\n    vals: Sequence of coordinate objects associated with a drawing.\n\nReturns:\n    Numpy data array with substituted values.",
        "api_signature": "_bind_coordinate(self, vals)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/core.py"
    },
    {
        "api_name": "substitute",
        "full_api_name": "Chart.substitute",
        "api_description": "",
        "api_signature": "substitute(val)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/core.py"
    },
    {
        "api_name": "_check_visible",
        "full_api_name": "Chart._check_visible",
        "api_description": "A helper function to check if the data is visible.\n\nArgs:\n    data: Drawing object to test.\n\nReturns:\n    Return `True` if the data is visible.",
        "api_signature": "_check_visible(self, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/core.py"
    },
    {
        "api_name": "_increment_cls_index",
        "full_api_name": "Chart._increment_cls_index",
        "api_description": "Increment counter of the chart.",
        "api_signature": "_increment_cls_index(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/core.py"
    },
    {
        "api_name": "_cls_index",
        "full_api_name": "Chart._cls_index",
        "api_description": "Return counter index of the chart.",
        "api_signature": "_cls_index(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/core.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ElementaryData.__init__",
        "api_description": "Create new drawing.\n\nArgs:\n    data_type: String representation of this drawing.\n    xvals: Series of horizontal coordinate that the object is drawn.\n    yvals: Series of vertical coordinate that the object is drawn.\n    channels: Pulse channel object bound to this drawing.\n    meta: Meta data dictionary of the object.\n    ignore_scaling: Set ``True`` to disable scaling.\n    styles: Style keyword args of the object. This conforms to `matplotlib`.",
        "api_signature": "__init__(self, data_type, xvals, yvals, channels, meta, ignore_scaling, styles)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/drawings.py"
    },
    {
        "api_name": "data_key",
        "full_api_name": "ElementaryData.data_key",
        "api_description": "Return unique hash of this object.",
        "api_signature": "data_key(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/drawings.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "ElementaryData.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/drawings.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "ElementaryData.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/drawings.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "LineData.__init__",
        "api_description": "Create new drawing.\n\nArgs:\n    data_type: String representation of this drawing.\n    channels: Pulse channel object bound to this drawing.\n    xvals: Series of horizontal coordinate that the object is drawn.\n    yvals: Series of vertical coordinate that the object is drawn.\n    fill: Set ``True`` to fill the area under curve.\n    meta: Meta data dictionary of the object.\n    ignore_scaling: Set ``True`` to disable scaling.\n    styles: Style keyword args of the object. This conforms to `matplotlib`.",
        "api_signature": "__init__(self, data_type, xvals, yvals, fill, channels, meta, ignore_scaling, styles)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/drawings.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "TextData.__init__",
        "api_description": "Create new drawing.\n\nArgs:\n    data_type: String representation of this drawing.\n    channels: Pulse channel object bound to this drawing.\n    xvals: Series of horizontal coordinate that the object is drawn.\n    yvals: Series of vertical coordinate that the object is drawn.\n    text: String to show in the canvas.\n    latex: Latex representation of the text (if backend supports latex drawing).\n    meta: Meta data dictionary of the object.\n    ignore_scaling: Set ``True`` to disable scaling.\n    styles: Style keyword args of the object. This conforms to `matplotlib`.",
        "api_signature": "__init__(self, data_type, xvals, yvals, text, latex, channels, meta, ignore_scaling, styles)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/drawings.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BoxData.__init__",
        "api_description": "Create new box.\n\nArgs:\n    data_type: String representation of this drawing.\n    xvals: Left and right coordinate that the object is drawn.\n    yvals: Top and bottom coordinate that the object is drawn.\n    channels: Pulse channel object bound to this drawing.\n    meta: Meta data dictionary of the object.\n    ignore_scaling: Set ``True`` to disable scaling.\n    styles: Style keyword args of the object. This conforms to `matplotlib`.\n\nRaises:\n    VisualizationError: When number of data points are not equals to 2.",
        "api_signature": "__init__(self, data_type, xvals, yvals, channels, meta, ignore_scaling, styles)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/drawings.py"
    },
    {
        "api_name": "gen_barrier",
        "full_api_name": "gen_barrier",
        "api_description": "Generate the barrier from provided relative barrier instruction.\n\nStylesheets:\n    - The `barrier` style is applied.\n\nArgs:\n    data: Barrier instruction data to draw.\n    formatter: Dictionary of stylesheet settings.\n    device: Backend configuration.\nReturns:\n    List of `LineData` drawings.",
        "api_signature": "gen_barrier(data, formatter, device)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/generators/barrier.py"
    },
    {
        "api_name": "gen_snapshot_name",
        "full_api_name": "gen_snapshot_name",
        "api_description": "Generate the name of snapshot.\n\nStylesheets:\n    - The `snapshot` style is applied for snapshot symbol.\n    - The `annotate` style is applied for label font size.\n\nArgs:\n    data: Snapshot instruction data to draw.\n    formatter: Dictionary of stylesheet settings.\n    device: Backend configuration.\n\nReturns:\n    List of `TextData` drawings.",
        "api_signature": "gen_snapshot_name(data, formatter, device)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/generators/snapshot.py"
    },
    {
        "api_name": "gen_snapshot_symbol",
        "full_api_name": "gen_snapshot_symbol",
        "api_description": "Generate a snapshot symbol with instruction meta data from provided snapshot instruction.\n\nStylesheets:\n    - The `snapshot` style is applied for snapshot symbol.\n    - The symbol type in unicode is specified in `formatter.unicode_symbol.snapshot`.\n    - The symbol type in latex is specified in `formatter.latex_symbol.snapshot`.\n\nArgs:\n    data: Snapshot instruction data to draw.\n    formatter: Dictionary of stylesheet settings.\n    device: Backend configuration.\n\nReturns:\n    List of `TextData` drawings.",
        "api_signature": "gen_snapshot_symbol(data, formatter, device)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/generators/snapshot.py"
    },
    {
        "api_name": "gen_formatted_phase",
        "full_api_name": "gen_formatted_phase",
        "api_description": "Generate the formatted virtual Z rotation label from provided frame instruction.\n\nRotation angle is expressed in units of pi.\nIf the denominator of fraction is larger than 10, the angle is expressed in units of radian.\n\nFor example:\n    - A value -3.14 is converted into `VZ(\\pi)`\n    - A value 1.57 is converted into `VZ(-\\frac{\\pi}{2})`\n    - A value 0.123 is converted into `VZ(-0.123 rad.)`\n\nStylesheets:\n    - The `frame_change` style is applied.\n    - The `annotate` style is applied for font size.\n\nNotes:\n    The phase operand of `PhaseShift` instruction has opposite sign to the Z gate definition.\n    Thus the sign of rotation angle is inverted.\n\nArgs:\n    data: Frame change instruction data to draw.\n    formatter: Dictionary of stylesheet settings.\n    device: Backend configuration.\n\nReturns:\n    List of `TextData` drawings.",
        "api_signature": "gen_formatted_phase(data, formatter, device)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/generators/frame.py"
    },
    {
        "api_name": "gen_formatted_freq_mhz",
        "full_api_name": "gen_formatted_freq_mhz",
        "api_description": "Generate the formatted frequency change label from provided frame instruction.\n\nFrequency change is expressed in units of MHz.\n\nFor example:\n    - A value 1,234,567 is converted into `\\Delta f = 1.23 MHz`\n\nStylesheets:\n    - The `frame_change` style is applied.\n    - The `annotate` style is applied for font size.\n\nArgs:\n    data: Frame change instruction data to draw.\n    formatter: Dictionary of stylesheet settings.\n    device: Backend configuration.\n\nReturns:\n    List of `TextData` drawings.",
        "api_signature": "gen_formatted_freq_mhz(data, formatter, device)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/generators/frame.py"
    },
    {
        "api_name": "gen_formatted_frame_values",
        "full_api_name": "gen_formatted_frame_values",
        "api_description": "Generate the formatted virtual Z rotation label and the frequency change label\nfrom provided frame instruction.\n\nPhase value is placed on top of the symbol, and frequency value is placed below the symbol.\nSee :py:func:`gen_formatted_phase` and :py:func:`gen_formatted_freq_mhz` for details.\n\nStylesheets:\n    - The `frame_change` style is applied.\n    - The `annotate` style is applied for font size.\n\nArgs:\n    data: Frame change instruction data to draw.\n    formatter: Dictionary of stylesheet settings.\n    device: Backend configuration.\n\nReturns:\n    List of `TextData` drawings.",
        "api_signature": "gen_formatted_frame_values(data, formatter, device)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/generators/frame.py"
    },
    {
        "api_name": "gen_raw_operand_values_compact",
        "full_api_name": "gen_raw_operand_values_compact",
        "api_description": "Generate the formatted virtual Z rotation label and the frequency change label\nfrom provided frame instruction.\n\nRaw operand values are shown in compact form. Frequency change is expressed\nin scientific notation. Values are shown in two lines.\n\nFor example:\n    - A phase change 1.57 and frequency change 1,234,567 are written by `1.57\\n1.2e+06`\n\nStylesheets:\n    - The `frame_change` style is applied.\n    - The `annotate` style is applied for font size.\n\nArgs:\n    data: Frame change instruction data to draw.\n    formatter: Dictionary of stylesheet settings.\n    device: Backend configuration.\n\nReturns:\n    List of `TextData` drawings.",
        "api_signature": "gen_raw_operand_values_compact(data, formatter, device)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/generators/frame.py"
    },
    {
        "api_name": "gen_frame_symbol",
        "full_api_name": "gen_frame_symbol",
        "api_description": "Generate a frame change symbol with instruction meta data from provided frame instruction.\n\nStylesheets:\n    - The `frame_change` style is applied.\n    - The symbol type in unicode is specified in `formatter.unicode_symbol.frame_change`.\n    - The symbol type in latex is specified in `formatter.latex_symbol.frame_change`.\n\nArgs:\n    data: Frame change instruction data to draw.\n    formatter: Dictionary of stylesheet settings.\n    device: Backend configuration.\n\nReturns:\n    List of `TextData` drawings.",
        "api_signature": "gen_frame_symbol(data, formatter, device)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/generators/frame.py"
    },
    {
        "api_name": "_phase_to_text",
        "full_api_name": "_phase_to_text",
        "api_description": "A helper function to convert a float value to text with pi.\n\nArgs:\n    formatter: Dictionary of stylesheet settings.\n    phase: A phase value in units of rad.\n    max_denom: Maximum denominator. Return raw value if exceed.\n    flip: Set `True` to flip the sign.\n\nReturns:\n    Standard text and latex text of phase value.",
        "api_signature": "_phase_to_text(formatter, phase, max_denom, flip)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/generators/frame.py"
    },
    {
        "api_name": "_freq_to_text",
        "full_api_name": "_freq_to_text",
        "api_description": "A helper function to convert a freq value to text with supplementary unit.\n\nArgs:\n    formatter: Dictionary of stylesheet settings.\n    freq: A frequency value in units of Hz.\n    unit: Supplementary unit. THz, GHz, MHz, kHz, Hz are supported.\n\nReturns:\n    Standard text and latex text of phase value.\n\nRaises:\n    VisualizationError: When unsupported unit is specified.",
        "api_signature": "_freq_to_text(formatter, freq, unit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/generators/frame.py"
    },
    {
        "api_name": "gen_baseline",
        "full_api_name": "gen_baseline",
        "api_description": "Generate the baseline associated with the chart.\n\nStylesheets:\n    - The `baseline` style is applied.\n\nArgs:\n    data: Chart axis data to draw.\n    formatter: Dictionary of stylesheet settings.\n    device: Backend configuration.\n\nReturns:\n    List of `LineData` drawings.",
        "api_signature": "gen_baseline(data, formatter, device)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/generators/chart.py"
    },
    {
        "api_name": "gen_chart_name",
        "full_api_name": "gen_chart_name",
        "api_description": "Generate the name of chart.\n\nStylesheets:\n    - The `axis_label` style is applied.\n\nArgs:\n    data: Chart axis data to draw.\n    formatter: Dictionary of stylesheet settings.\n    device: Backend configuration.\n\nReturns:\n    List of `TextData` drawings.",
        "api_signature": "gen_chart_name(data, formatter, device)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/generators/chart.py"
    },
    {
        "api_name": "gen_chart_scale",
        "full_api_name": "gen_chart_scale",
        "api_description": "Generate the current scaling value of the chart.\n\nStylesheets:\n    - The `axis_label` style is applied.\n    - The `annotate` style is partially applied for the font size.\n\nArgs:\n    data: Chart axis data to draw.\n    formatter: Dictionary of stylesheet settings.\n    device: Backend configuration.\n\nReturns:\n    List of `TextData` drawings.",
        "api_signature": "gen_chart_scale(data, formatter, device)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/generators/chart.py"
    },
    {
        "api_name": "gen_channel_freqs",
        "full_api_name": "gen_channel_freqs",
        "api_description": "Generate the frequency values of associated channels.\n\nStylesheets:\n    - The `axis_label` style is applied.\n    - The `annotate` style is partially applied for the font size.\n\nArgs:\n    data: Chart axis data to draw.\n    formatter: Dictionary of stylesheet settings.\n    device: Backend configuration.\n\nReturns:\n    List of `TextData` drawings.",
        "api_signature": "gen_channel_freqs(data, formatter, device)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/generators/chart.py"
    },
    {
        "api_name": "gen_filled_waveform_stepwise",
        "full_api_name": "gen_filled_waveform_stepwise",
        "api_description": "Generate filled area objects of the real and the imaginary part of waveform envelope.\n\nThe curve of envelope is not interpolated nor smoothed and presented\nas stepwise function at each data point.\n\nStylesheets:\n    - The `fill_waveform` style is applied.\n\nArgs:\n    data: Waveform instruction data to draw.\n    formatter: Dictionary of stylesheet settings.\n    device: Backend configuration.\n\nReturns:\n    List of `LineData`, `BoxData`, or `TextData` drawings.\n\nRaises:\n    VisualizationError: When the instruction parser returns invalid data format.",
        "api_signature": "gen_filled_waveform_stepwise(data, formatter, device)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/generators/waveform.py"
    },
    {
        "api_name": "gen_ibmq_latex_waveform_name",
        "full_api_name": "gen_ibmq_latex_waveform_name",
        "api_description": "Generate the formatted instruction name associated with the waveform.\n\nChannel name and ID string are removed and the rotation angle is expressed in units of pi.\nThe controlled rotation angle associated with the CR pulse name is divided by 2.\n\nNote that in many scientific articles the controlled rotation angle implies\nthe actual rotation angle, but in IQX backend the rotation angle represents\nthe difference between rotation angles with different control qubit states.\n\nFor example:\n    - 'X90p_d0_abcdefg' is converted into 'X(\\frac{\\pi}{2})'\n    - 'CR90p_u0_abcdefg` is converted into 'CR(\\frac{\\pi}{4})'\n\nStylesheets:\n    - The `annotate` style is applied.\n\nNotes:\n    This generator can convert pulse names used in the IQX backends.\n    If pulses are provided by the third party providers or the user defined,\n    the generator output may be the as-is pulse name.\n\nArgs:\n    data: Waveform instruction data to draw.\n    formatter: Dictionary of stylesheet settings.\n    device: Backend configuration.\n\nReturns:\n    List of `TextData` drawings.",
        "api_signature": "gen_ibmq_latex_waveform_name(data, formatter, device)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/generators/waveform.py"
    },
    {
        "api_name": "gen_waveform_max_value",
        "full_api_name": "gen_waveform_max_value",
        "api_description": "Generate the annotation for the maximum waveform height for\nthe real and the imaginary part of the waveform envelope.\n\nMaximum values smaller than the vertical resolution limit is ignored.\n\nStylesheets:\n    - The `annotate` style is applied.\n\nArgs:\n    data: Waveform instruction data to draw.\n    formatter: Dictionary of stylesheet settings.\n    device: Backend configuration.\n\nReturns:\n    List of `TextData` drawings.",
        "api_signature": "gen_waveform_max_value(data, formatter, device)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/generators/waveform.py"
    },
    {
        "api_name": "_draw_shaped_waveform",
        "full_api_name": "_draw_shaped_waveform",
        "api_description": "A private function that generates drawings of stepwise pulse lines.\n\nArgs:\n    xdata: Array of horizontal coordinate of waveform envelope.\n    ydata: Array of vertical coordinate of waveform envelope.\n    meta: Metadata dictionary of the waveform.\n    channel: Channel associated with the waveform to draw.\n    formatter: Dictionary of stylesheet settings.\n\nReturns:\n    List of drawings.\n\nRaises:\n    VisualizationError: When the waveform color for channel is not defined.",
        "api_signature": "_draw_shaped_waveform(xdata, ydata, meta, channel, formatter)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/generators/waveform.py"
    },
    {
        "api_name": "_draw_opaque_waveform",
        "full_api_name": "_draw_opaque_waveform",
        "api_description": "A private function that generates drawings of stepwise pulse lines.\n\nArgs:\n    init_time: Time when the opaque waveform starts.\n    duration: Duration of opaque waveform. This can be None or ParameterExpression.\n    pulse_shape: String that represents pulse shape.\n    pnames: List of parameter names.\n    meta: Metadata dictionary of the waveform.\n    channel: Channel associated with the waveform to draw.\n    formatter: Dictionary of stylesheet settings.\n\nReturns:\n    List of drawings.",
        "api_signature": "_draw_opaque_waveform(init_time, duration, pulse_shape, pnames, meta, channel, formatter)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/generators/waveform.py"
    },
    {
        "api_name": "_find_consecutive_index",
        "full_api_name": "_find_consecutive_index",
        "api_description": "A helper function to return non-consecutive index from the given list.\n\nThis drastically reduces memory footprint to represent a drawing,\nespecially for samples of very long flat-topped Gaussian pulses.\nTiny value fluctuation smaller than `resolution` threshold is removed.\n\nArgs:\n    data_array: The array of numbers.\n    resolution: Minimum resolution of sample values.\n\nReturns:\n    The compressed data array.",
        "api_signature": "_find_consecutive_index(data_array, resolution)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/generators/waveform.py"
    },
    {
        "api_name": "_parse_waveform",
        "full_api_name": "_parse_waveform",
        "api_description": "A helper function that generates an array for the waveform with\ninstruction metadata.\n\nArgs:\n    data: Instruction data set\n\nRaises:\n    VisualizationError: When invalid instruction type is loaded.\n\nReturns:\n    A data source to generate a drawing.",
        "api_signature": "_parse_waveform(data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/generators/waveform.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Mpl2DPlotter.__init__",
        "api_description": "Create new plotter.\n\nArgs:\n    canvas: Configured drawer canvas object. Canvas object should be updated\n        with `.update` method before set to the plotter API.\n    axis: Matplotlib axis object. When `axis` is provided, the plotter updates\n        given axis instead of creating and returning new matplotlib figure.",
        "api_signature": "__init__(self, canvas, axis)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/plotters/matplotlib.py"
    },
    {
        "api_name": "initialize_canvas",
        "full_api_name": "Mpl2DPlotter.initialize_canvas",
        "api_description": "Format appearance of matplotlib canvas.",
        "api_signature": "initialize_canvas(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/plotters/matplotlib.py"
    },
    {
        "api_name": "draw",
        "full_api_name": "Mpl2DPlotter.draw",
        "api_description": "Output drawings stored in canvas object.",
        "api_signature": "draw(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/plotters/matplotlib.py"
    },
    {
        "api_name": "get_image",
        "full_api_name": "Mpl2DPlotter.get_image",
        "api_description": "Get image data to return.\n\nArgs:\n    interactive: When set `True` show the circuit in a new window.\n        This depends on the matplotlib backend being used supporting this.\n\nReturns:\n    Matplotlib figure data.",
        "api_signature": "get_image(self, interactive)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/plotters/matplotlib.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BasePlotter.__init__",
        "api_description": "Create new plotter.\n\nArgs:\n    canvas: Configured drawer canvas object.",
        "api_signature": "__init__(self, canvas)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/plotters/base_plotter.py"
    },
    {
        "api_name": "initialize_canvas",
        "full_api_name": "BasePlotter.initialize_canvas",
        "api_description": "Format appearance of the canvas.",
        "api_signature": "initialize_canvas(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/plotters/base_plotter.py"
    },
    {
        "api_name": "draw",
        "full_api_name": "BasePlotter.draw",
        "api_description": "Output drawing objects stored in canvas object.",
        "api_signature": "draw(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/plotters/base_plotter.py"
    },
    {
        "api_name": "get_image",
        "full_api_name": "BasePlotter.get_image",
        "api_description": "Get image data to return.\n\nArgs:\n    interactive: When set `True` show the circuit in a new window.\n        This depends on the matplotlib backend being used supporting this.\n\nReturns:\n    Image data. This depends on the plotter API.",
        "api_signature": "get_image(self, interactive)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/plotters/base_plotter.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "EventsOutputChannels.__init__",
        "api_description": "Create new channel dataset.\n\nTODO: remove PV\n\nArgs:\n    t0: starting time of plot\n    tf: ending time of plot",
        "api_signature": "__init__(self, t0, tf)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse/matplotlib.py"
    },
    {
        "api_name": "add_instruction",
        "full_api_name": "EventsOutputChannels.add_instruction",
        "api_description": "Add new pulse instruction to channel.\n\nArgs:\n    start_time: Starting time of instruction\n    instruction: Instruction object to be added",
        "api_signature": "add_instruction(self, start_time, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse/matplotlib.py"
    },
    {
        "api_name": "waveform",
        "full_api_name": "EventsOutputChannels.waveform",
        "api_description": "Get waveform.",
        "api_signature": "waveform(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse/matplotlib.py"
    },
    {
        "api_name": "framechanges",
        "full_api_name": "EventsOutputChannels.framechanges",
        "api_description": "Get frame changes.",
        "api_signature": "framechanges(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse/matplotlib.py"
    },
    {
        "api_name": "setphase",
        "full_api_name": "EventsOutputChannels.setphase",
        "api_description": "Get the SetPhase phase values.",
        "api_signature": "setphase(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse/matplotlib.py"
    },
    {
        "api_name": "frequencychanges",
        "full_api_name": "EventsOutputChannels.frequencychanges",
        "api_description": "Get the frequency changes.",
        "api_signature": "frequencychanges(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse/matplotlib.py"
    },
    {
        "api_name": "frequencyshift",
        "full_api_name": "EventsOutputChannels.frequencyshift",
        "api_description": "Set the frequency changes.",
        "api_signature": "frequencyshift(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse/matplotlib.py"
    },
    {
        "api_name": "conditionals",
        "full_api_name": "EventsOutputChannels.conditionals",
        "api_description": "Get conditionals.",
        "api_signature": "conditionals(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse/matplotlib.py"
    },
    {
        "api_name": "snapshots",
        "full_api_name": "EventsOutputChannels.snapshots",
        "api_description": "Get snapshots.",
        "api_signature": "snapshots(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse/matplotlib.py"
    },
    {
        "api_name": "labels",
        "full_api_name": "EventsOutputChannels.labels",
        "api_description": "Get labels.",
        "api_signature": "labels(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse/matplotlib.py"
    },
    {
        "api_name": "is_empty",
        "full_api_name": "EventsOutputChannels.is_empty",
        "api_description": "Return if pulse is empty.\n\nReturns:\n    bool: if the channel has nothing to plot",
        "api_signature": "is_empty(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse/matplotlib.py"
    },
    {
        "api_name": "to_table",
        "full_api_name": "EventsOutputChannels.to_table",
        "api_description": "Get table contains.\n\nArgs:\n    name (str): name of channel\n\nReturns:\n    A list of events in the channel",
        "api_signature": "to_table(self, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse/matplotlib.py"
    },
    {
        "api_name": "_build_waveform",
        "full_api_name": "EventsOutputChannels._build_waveform",
        "api_description": "Create waveform from stored pulses.",
        "api_signature": "_build_waveform(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse/matplotlib.py"
    },
    {
        "api_name": "_trim",
        "full_api_name": "EventsOutputChannels._trim",
        "api_description": "Return events during given `time_range`.\n\nArgs:\n    events: time and operation of events.\n\nReturns:\n    Events within the specified time range.",
        "api_signature": "_trim(self, events)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse/matplotlib.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "WaveformDrawer.__init__",
        "api_description": "Create new figure.\n\nArgs:\n    style: Style sheet for pulse visualization.",
        "api_signature": "__init__(self, style)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse/matplotlib.py"
    },
    {
        "api_name": "draw",
        "full_api_name": "WaveformDrawer.draw",
        "api_description": "Draw figure.\n\nArgs:\n    pulse: Waveform to draw.\n    dt: time interval.\n    interp_method: interpolation function.\n    scale: Relative visual scaling of waveform amplitudes.\n    draw_title: Add a title to the plot when set to ``True``.\n\nReturns:\n    matplotlib.figure.Figure: A matplotlib figure object of the pulse envelope.\n\nRaises:\n    MissingOptionalLibraryError: If matplotlib is not installed",
        "api_signature": "draw(self, pulse, dt, interp_method, scale, draw_title)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse/matplotlib.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ScheduleDrawer.__init__",
        "api_description": "Create new figure.\n\nArgs:\n    style: Style sheet for pulse schedule visualization.\nRaises:\n    MissingOptionalLibraryError: If matplotlib is not installed",
        "api_signature": "__init__(self, style)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse/matplotlib.py"
    },
    {
        "api_name": "_build_channels",
        "full_api_name": "ScheduleDrawer._build_channels",
        "api_description": "Create event table of each pulse channels in the given schedule.\n\nArgs:\n    schedule: Schedule object to plot.\n    channels: Channels to plot.\n    t0: Start time of plot.\n    tf: End time of plot.\n    show_framechange_channels: Plot channels only with FrameChanges (ShiftPhase).\n\nReturns:\n    channels: All channels.\n    output_channels: All (D, M, U, A) channels.\n    snapshot_channels: Snapshots.",
        "api_signature": "_build_channels(self, schedule, channels, t0, tf, show_framechange_channels)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse/matplotlib.py"
    },
    {
        "api_name": "_scale_channels",
        "full_api_name": "ScheduleDrawer._scale_channels",
        "api_description": "Count number of channels that contains any instruction to show\nand find scale factor of that channel.\n\nArgs:\n    output_channels: Event table of channels to show.\n    scale: Global scale factor.\n    channel_scales: Channel specific scale factors.\n    channels: Specified channels to plot.\n    plot_all: Plot empty channel.\n\nReturns:\n    scale_dict: Scale factor of each channel.",
        "api_signature": "_scale_channels(output_channels, scale, channel_scales, channels, plot_all)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse/matplotlib.py"
    },
    {
        "api_name": "_draw_table",
        "full_api_name": "ScheduleDrawer._draw_table",
        "api_description": "Draw event table if events exist.\n\nArgs:\n    figure (matplotlib.figure.Figure): Figure object\n    channels: Dictionary of channel and event table\n    dt: Time interval\n\nReturns:\n    tuple[matplotlib.axes.Axes]: Axis objects for table and canvas of pulses.",
        "api_signature": "_draw_table(self, figure, channels, dt)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse/matplotlib.py"
    },
    {
        "api_name": "_draw_snapshots",
        "full_api_name": "ScheduleDrawer._draw_snapshots",
        "api_description": "Draw snapshots to given mpl axis.\n\nArgs:\n    ax (matplotlib.axes.Axes): axis object to draw snapshots.\n    snapshot_channels: Event table of snapshots.\n    y0: vertical position to draw the snapshots.",
        "api_signature": "_draw_snapshots(ax, snapshot_channels, y0)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse/matplotlib.py"
    },
    {
        "api_name": "_draw_framechanges",
        "full_api_name": "ScheduleDrawer._draw_framechanges",
        "api_description": "Draw frame change of given channel to given mpl axis.\n\nArgs:\n    ax (matplotlib.axes.Axes): axis object to draw frame changes.\n    fcs: Event table of frame changes.\n    y0: vertical position to draw the frame changes.",
        "api_signature": "_draw_framechanges(self, ax, fcs, y0)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse/matplotlib.py"
    },
    {
        "api_name": "_draw_frequency_changes",
        "full_api_name": "ScheduleDrawer._draw_frequency_changes",
        "api_description": "Draw set frequency of given channel to given mpl axis.\n\nArgs:\n    ax (matplotlib.axes.Axes): axis object to draw frame changes.\n    sf: Event table of set frequency.\n    y0: vertical position to draw the frame changes.",
        "api_signature": "_draw_frequency_changes(self, ax, sf, y0)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse/matplotlib.py"
    },
    {
        "api_name": "_get_channel_color",
        "full_api_name": "ScheduleDrawer._get_channel_color",
        "api_description": "Lookup table for waveform color.\n\nArgs:\n    channel: Type of channel.\n\nReturn:\n    Color code or name of color.",
        "api_signature": "_get_channel_color(self, channel)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse/matplotlib.py"
    },
    {
        "api_name": "_prev_label_at_time",
        "full_api_name": "ScheduleDrawer._prev_label_at_time",
        "api_description": "Check overlap of pulses with previous channels.\n\nArgs:\n    prev_labels: List of labels in previous channels.\n    time: Start time of current pulse instruction.\n\nReturns:\n    `True` if current instruction overlaps with others.",
        "api_signature": "_prev_label_at_time(prev_labels, time)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse/matplotlib.py"
    },
    {
        "api_name": "_draw_labels",
        "full_api_name": "ScheduleDrawer._draw_labels",
        "api_description": "Draw label of pulse instructions on given mpl axis.\n\nArgs:\n    ax (matplotlib.axes.Axes): axis object to draw labels.\n    labels: Pulse labels of channel.\n    prev_labels: Pulse labels of previous channels.\n    y0: vertical position to draw the labels.",
        "api_signature": "_draw_labels(self, ax, labels, prev_labels, y0)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse/matplotlib.py"
    },
    {
        "api_name": "_draw_channels",
        "full_api_name": "ScheduleDrawer._draw_channels",
        "api_description": "Draw pulse instructions on given mpl axis.\n\nArgs:\n    ax (matplotlib.axes.Axes): axis object to draw pulses.\n    output_channels: Event table of channels.\n    interp_method: Callback function for waveform interpolation.\n    t0: Start time of schedule.\n    tf: End time of schedule.\n    scale_dict: Scale factor for each channel.\n    label: When set `True` draw labels.\n    framechange: When set `True` draw frame change symbols.\n    frequencychange: When set `True` draw frequency change symbols.\n\nReturn:\n    Value of final vertical axis of canvas.",
        "api_signature": "_draw_channels(self, ax, output_channels, interp_method, t0, tf, scale_dict, label, framechange, frequencychange)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse/matplotlib.py"
    },
    {
        "api_name": "draw",
        "full_api_name": "ScheduleDrawer.draw",
        "api_description": "Draw figure.\n\nArgs:\n    schedule: schedule object to plot.\n    dt: Time interval of samples. Pulses are visualized in the unit of\n        cycle time if not provided.\n    interp_method: Interpolation function. See example.\n        Interpolation is disabled in default.\n        See `qiskit.visualization.pulse.interpolation` for more information.\n    plot_range: A tuple of time range to plot.\n    scale: Scaling of waveform amplitude. Pulses are automatically\n        scaled channel by channel if not provided.\n    channel_scales: Dictionary of scale factor for specific channels.\n        Scale of channels not specified here is overwritten by `scale`.\n    plot_all: When set `True` plot empty channels.\n    table: When set `True` draw event table for supported commands.\n    label: When set `True` draw label for individual instructions.\n    framechange: When set `True` draw framechange indicators.\n    channels: A list of channel names to plot.\n        All non-empty channels are shown if not provided.\n    show_framechange_channels: When set `True` plot channels\n        with only framechange instructions.\n    draw_title: Add a title to the plot when set to ``True``.\n\nReturns:\n    matplotlib.figure.Figure: A matplotlib figure object for the pulse envelope.\n\nRaises:\n    VisualizationError: When schedule cannot be drawn",
        "api_signature": "draw(self, schedule, dt, interp_method, plot_range, scale, channel_scales, plot_all, table, label, framechange, channels, show_framechange_channels, draw_title)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse/matplotlib.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SchedStyle.__init__",
        "api_description": "Deprecated.\n\nCreate new style sheet.\n\nFor any of the Optional fields, if that field is None then it will revert to its\nmatplotlib.rcParams counterpart. See for usage on rcParams.  Each argument that\nis optional also describes it's mapped rcParam key below.\n\nArgs:\n    figsize: Size of the figure.\n        If ``None``, will default to the figure size of the drawing backend.\n        If the output is ``matplotlib``, the default\n        parameter is ``rcParams['figure.figsize']``.\n    fig_unit_h_table: Height of row of event table. See Example.\n    use_table: When set `True` use event table.\n    table_columns: Number of event table columns.\n    table_font_size: Font size of event table.\n    axis_font_size: Font size of channel aliases.\n        If ``None``, will revert to the axis label size of the drawing backend.\n        If the output is ``matplotlib``, the default parameter is\n        ``rcParams['axes.titlesize']``.\n    label_font_size: Font size of labels in canvas.\n    icon_font_size: Size of symbols.\n    title_font_size: Font size of schedule name in title.\n        If ``None``, will default to the title font size of the drawing backend.\n        If the output is ``matplotlib``, the default\n        parameter is ``rcParams['figure.titlesize']``.\n    label_ch_linestyle: Line style for channel pulse label line.\n    label_ch_color: Color code or name of color for channel pulse label line.\n    label_ch_alpha: Transparency for channel pulse label line from 0 to 1.\n    d_ch_color: Color code or name of colors for real and imaginary part\n        of waveform at d channels.\n    u_ch_color: Color code or name of colors for real and imaginary part\n        of waveform at u channels.\n    m_ch_color: Color code or name of colors for real and imaginary part\n        of waveform at m channels.\n    s_ch_color: Color code or name of color for snapshot channel line.\n    s_ch_linestyle: Line style for snapshot line.\n    table_color: Color code or name of color for event table columns of\n        time, channel, event information.\n    bg_color: Color code or name of color for canvas background.\n    num_points: Number of points for interpolation of each channel.\n    dpi: Resolution in the unit of dot per inch to save image.\n        If ``None``, will revert to the DPI setting of the drawing backend.\n        If the output is ``matplotlib``, the default\n        parameter is ``rcParams['figure.dpi']``.\n    remove_spacing: Remove redundant spacing\n        when the waveform has no negative values.\n    max_table_ratio: Maximum portion of the plot the table can take up.\n        Limited to range between 0 and 1.\n    vertical_span: Spacing on top and bottom of pulse canvas.\n    axis_formatter: Format of horizontal axis of the plot. This is convenient when\n        you set ``dt`` option for the drawer. For example, formatter of ``%.3e`` gives you\n        horizontal axis values in the scientific notation with 3 digits.\n\nExample:\n    Height of the event table is decided by multiple parameters.::\n\n        figsize = (10.0, 12.0)\n        fig_unit_h_table = 0.4\n        table_columns = 2\n        max_table_ratio = 0.5\n\n    With this setup, events are shown in double-column style with\n    each line height of 0.4 inch and the table cannot exceed 5 inch.\n    Thus 12 lines are maximum and up to 24 events can be shown.\n    If you want to show more events, increase figure height or\n    reduce size of line height and table font size.",
        "api_signature": "__init__(self, figsize, fig_unit_h_table, use_table, table_columns, table_font_size, axis_font_size, label_font_size, icon_font_size, title_font_size, label_ch_linestyle, label_ch_color, label_ch_alpha, d_ch_color, u_ch_color, m_ch_color, s_ch_color, s_ch_linestyle, table_color, bg_color, num_points, dpi, remove_spacing, max_table_ratio, vertical_span, axis_formatter)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse/qcstyle.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PulseStyle.__init__",
        "api_description": "Create new style sheet.\n\nFor any of the Optional fields, if that field is None then it will revert to its\nmatplotlib.rcParams counterpart. See for usage on rcParams.  Each argument that\nis optional also describes it's mapped rcParam key below.\n\nArgs:\n    figsize: Size of the figure.\n        If ``None``, will default to the figure size of the drawing backend.\n        If the output is ``matplotlib``, the default\n        parameter is ``rcParams['figure.figsize']``.\n    title_font_size: Font size of schedule name in title.\n        If ``None``, will default to the title font size of the drawing backend.\n        If the output is ``matplotlib``, the default\n        parameter is ``rcParams['figure.titlesize']``.\n    wave_color: Color code or name of colors for\n        the real and imaginary parts of the waveform.\n    bg_color: Color code or name of color for pulse canvas background.\n    num_points: Number of points for interpolation.\n    dpi: Resolution in the unit of dot per inch to save image.\n        If ``None``, will revert to the DPI setting of the drawing backend.\n        If the output is ``matplotlib``, the default\n        parameter is ``rcParams['figure.dpi']``.",
        "api_signature": "__init__(self, figsize, title_font_size, wave_color, bg_color, num_points, dpi)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse/qcstyle.py"
    },
    {
        "api_name": "interp1d",
        "full_api_name": "interp1d",
        "api_description": "Deprecated.\n\nScipy interpolation wrapper.\n\nArgs:\n    time: Time vector with length of ``samples`` + 1.\n    samples: Complex pulse envelope.\n    nop: Number of data points for interpolation.\n    kind: Scipy interpolation type.\n        See ``scipy.interpolate.interp1d`` documentation for more information.\nReturns:\n    Interpolated time vector and real and imaginary part of waveform.",
        "api_signature": "interp1d(time, samples, nop, kind)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse/interpolation.py"
    },
    {
        "api_name": "step_wise",
        "full_api_name": "step_wise",
        "api_description": "Deprecated.\n\nKeep uniform variation between sample values. No interpolation is applied.\nArgs:\n    time: Time vector with length of ``samples`` + 1.\n    samples: Complex pulse envelope.\n    nop: This argument is not used.\nReturns:\n    Time vector and real and imaginary part of waveform.",
        "api_signature": "step_wise(time, samples, nop)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse/interpolation.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QiskitTimelineStyle.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/stylesheet.py"
    },
    {
        "api_name": "update",
        "full_api_name": "QiskitTimelineStyle.update",
        "api_description": "",
        "api_signature": "update(self, __m)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/stylesheet.py"
    },
    {
        "api_name": "formatter",
        "full_api_name": "QiskitTimelineStyle.formatter",
        "api_description": "Return formatter field of style dictionary.",
        "api_signature": "formatter(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/stylesheet.py"
    },
    {
        "api_name": "generator",
        "full_api_name": "QiskitTimelineStyle.generator",
        "api_description": "Return generator field of style dictionary.",
        "api_signature": "generator(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/stylesheet.py"
    },
    {
        "api_name": "layout",
        "full_api_name": "QiskitTimelineStyle.layout",
        "api_description": "Return layout field of style dictionary.",
        "api_signature": "layout(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/stylesheet.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "IQXStandard.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/stylesheet.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "IQXStandard.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/stylesheet.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "IQXSimple.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/stylesheet.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "IQXSimple.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/stylesheet.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "IQXDebugging.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/stylesheet.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "IQXDebugging.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/stylesheet.py"
    },
    {
        "api_name": "default_style",
        "full_api_name": "default_style",
        "api_description": "Define default values of the timeline stylesheet.",
        "api_signature": "default_style()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/stylesheet.py"
    },
    {
        "api_name": "draw",
        "full_api_name": "draw",
        "api_description": "Generate visualization data for scheduled circuit programs.\n\nArgs:\n    program: Program to visualize. This program should be a `QuantumCircuit` which is\n        transpiled with a scheduling_method, thus containing gate time information.\n    style: Stylesheet options. This can be dictionary or preset stylesheet classes. See\n        :py:class:`~qiskit.visualization.timeline.stylesheets.IQXStandard`,\n        :py:class:`~qiskit.visualization.timeline.stylesheets.IQXSimple`, and\n        :py:class:`~qiskit.visualization.timeline.stylesheets.IQXDebugging` for details of\n        preset stylesheets. See also the stylesheet section for details of configuration keys.\n    time_range: Set horizontal axis limit.\n    disable_bits: List of qubits of classical bits not shown in the output image.\n    show_clbits: A control property to show classical bits.\n        Set `True` to show classical bits.\n    show_idle: A control property to show idle timeline.\n        Set `True` to show timeline without gates.\n    show_barriers: A control property to show barrier instructions.\n        Set `True` to show barrier instructions.\n    show_delays: A control property to show delay instructions.\n        Set `True` to show delay instructions.\n    show_labels: A control property to show annotations, i.e. name, of gates.\n        Set `True` to show annotations.\n    plotter: Name of plotter API to generate an output image.\n        One of following APIs should be specified::\n\n            mpl: Matplotlib API\n                Matplotlib API to generate 2D image. Timelines are placed along y axis with\n                vertical offset. This API takes matplotlib.axes.Axes as `axis` input.\n\n        `axis` and `style` kwargs may depend on the plotter.\n    axis: Arbitrary object passed to the plotter. If this object is provided,\n        the plotters uses given `axis` instead of internally initializing a figure object.\n        This object format depends on the plotter. See plotters section for details.\n    filename: If provided the output image is dumped into a file under the filename.\n\nReturns:\n    Visualization output data.\n\n    The returned data type depends on the `plotter`.\n    If matplotlib family is specified, this will be a `matplotlib.pyplot.Figure` data.\n    The returned data is generated by the `.get_image` method of the specified plotter API.\n\nRaises:\n    MissingOptionalLibraryError: When required visualization package is not installed.\n    VisualizationError: When invalid plotter API is specified.\n\n.. _style-dict-doc:\n\n**Style Dict Details**\n\nThe stylesheet kwarg contains numerous options that define the style of the\noutput timeline visualization.\nThe stylesheet options can be classified into `formatter`, `generator` and `layout`.\nThose options available in the stylesheet are defined below:\n\nArgs:\n    formatter.general.fig_width: Width of output image (default `14`).\n    formatter.general.fig_unit_height: Height of output image per timeline.\n        The sum of all timeline becomes the height of the output image (default `0.8`).\n    formatter.general.dpi: Dot per inch of image if `filename` is set (default `150`).\n    formatter.margin.top: Margin from the top boundary of the figure canvas to\n        the zero line of the first time slot (default `0.5`).\n    formatter.margin.bottom: Margin from the bottom boundary of the figure canvas to\n        the zero lien of the last time slot (default `0.5`).\n    formatter.margin.left_percent:  Margin from the left boundary of the figure canvas to\n        the left limit of the horizontal axis. The value is in units of percentage of\n        the whole program duration. If the duration is 100 and the value of 0.5 is set,\n        this keeps left margin of 5 (default `0.02`).\n    formatter.margin.right_percent: Margin from the right boundary of the figure canvas to\n        the right limit of the horizontal axis. The value is in units of percentage of\n        the whole program duration. If the duration is 100 and the value of 0.5 is set,\n        this keeps right margin of 5 (default `0.02`).\n    formatter.margin.link_interval_percent: Allowed overlap of gate links.\n        If multiple gate links are drawing within this range, links are horizontally\n        shifted not to overlap with each other. The value is in units of percentage of\n        the whole program duration (default `0.01`).\n    formatter.time_bucket.edge_dt: The length of round edge of gate boxes. Gate boxes are\n        smoothly faded in and out from the zero line. This value is in units of\n        the system cycle time dt (default `10`).\n    formatter.margin.minimum_duration: Minimum scheduled circuit duration.\n        If the duration of input circuit is below this value, horizontal limit is\n        set based on this value. This value is in units of\n        the system cycle time dt (default `50`).\n    formatter.color.background: Color code of the face color of canvas (default `#FFFFFF`).\n    formatter.color.timeslot: Face color of the time slot box (default `#DDDDDD`).\n    formatter.color.gate_name: Text color of the gate name annotations (default `#000000`).\n    formatter.color.bit_name: Text color of the bit label annotations (default `#000000`).\n    formatter.color.barrier: Line color of barriers (default `#222222`).\n    formatter.color.gates: A dictionary of the gate box or gate symbol colors\n        to use for each element type in the output visualization. The default\n        values are::\n\n            {\n                'u0': '#FA74A6',\n                'u1': '#000000',\n                'u2': '#FA74A6',\n                'u3': '#FA74A6',\n                'id': '#05BAB6',\n                'sx': '#FA74A6',\n                'sxdg': '#FA74A6',\n                'x': '#05BAB6',\n                'y': '#05BAB6',\n                'z': '#05BAB6',\n                'h': '#6FA4FF',\n                'cx': '#6FA4FF',\n                'cy': '#6FA4FF',\n                'cz': '#6FA4FF',\n                'swap': '#6FA4FF',\n                's': '#6FA4FF',\n                'sdg': '#6FA4FF',\n                'dcx': '#6FA4FF',\n                'iswap': '#6FA4FF',\n                't': '#BB8BFF',\n                'tdg': '#BB8BFF',\n                'r': '#BB8BFF',\n                'rx': '#BB8BFF',\n                'ry': '#BB8BFF',\n                'rz': '#000000',\n                'reset': '#808080',\n                'measure': '#808080'\n            }\n\n        You must specify all the necessary values if using this. If a gate name is not\n        specified, the color in `formatter.color.default_gate` is applied.\n    formatter.color.default_gate: Default gate color. This color is applied when\n        a gate name to visualize is not contained in the dictionary of\n        `formatter.color.gates` (default `#BB8BFF`).\n    formatter.latex_symbol.gates: A dictionary of latex representation of gate names\n        to use for each element type in the output visualization. The default\n        values are::\n\n            {\n                'u0': r'{\\rm U}_0',\n                'u1': r'{\\rm U}_1',\n                'u2': r'{\\rm U}_2',\n                'u3': r'{\\rm U}_3',\n                'id': r'{\\rm Id}',\n                'x': r'{\\rm X}',\n                'y': r'{\\rm Y}',\n                'z': r'{\\rm Z}',\n                'h': r'{\\rm H}',\n                'cx': r'{\\rm CX}',\n                'cy': r'{\\rm CY}',\n                'cz': r'{\\rm CZ}',\n                'swap': r'{\\rm SWAP}',\n                's': r'{\\rm S}',\n                'sdg': r'{\\rm S}^\\dagger',\n                'sx': r'{\\rm \u221aX}',\n                'sxdg': r'{\\rm \u221aX}^\\dagger',\n                'dcx': r'{\\rm DCX}',\n                'iswap': r'{\\rm iSWAP}',\n                't': r'{\\rm T}',\n                'tdg': r'{\\rm T}^\\dagger',\n                'r': r'{\\rm R}',\n                'rx': r'{\\rm R}_x',\n                'ry': r'{\\rm R}_y',\n                'rz': r'{\\rm R}_z',\n                'reset': r'|0\\rangle',\n                'measure': r'{\\rm Measure}'\n            }\n\n        You must specify all the necessary values if using this. There is\n        no provision for passing an incomplete dict in.\n    formatter.latex_symbol.frame_change: Latex representation of\n        the frame change symbol (default r`\\circlearrowleft`).\n    formatter.unicode_symbol.frame_change: Unicode representation of\n        the frame change symbol (default u'\\u21BA').\n    formatter.box_height.gate: Height of gate box (default `0.5`).\n    formatter.box_height.timeslot: Height of time slot (default `0.6`).\n    formatter.layer.gate: Layer index of gate boxes. Larger number comes\n        in the front of the output image (default `3`).\n    formatter.layer.timeslot: Layer index of time slots. Larger number comes\n        in the front of the output image (default `0`).\n    formatter.layer.gate_name: Layer index of gate name annotations. Larger number comes\n        in the front of the output image (default `5`).\n    formatter.layer.bit_name: Layer index of bit labels. Larger number comes\n        in the front of the output image (default `5`).\n    formatter.layer.frame_change: Layer index of frame change symbols. Larger number comes\n        in the front of the output image (default `4`).\n    formatter.layer.barrier: Layer index of barrier lines. Larger number comes\n        in the front of the output image (default `1`).\n    formatter.layer.gate_link: Layer index of gate link lines. Larger number comes\n        in the front of the output image (default `2`).\n    formatter.alpha.gate: Transparency of gate boxes. A value in the range from\n        `0` to `1`. The value `0` gives completely transparent boxes (default `1.0`).\n    formatter.alpha.timeslot: Transparency of time slots. A value in the range from\n        `0` to `1`. The value `0` gives completely transparent boxes (default `0.7`).\n    formatter.alpha.barrier: Transparency of barrier lines. A value in the range from\n        `0` to `1`. The value `0` gives completely transparent lines (default `0.5`).\n    formatter.alpha.gate_link: Transparency of gate link lines. A value in the range from\n        `0` to `1`. The value `0` gives completely transparent lines (default `0.8`).\n    formatter.line_width.gate: Line width of the fringe of gate boxes (default `0`).\n    formatter.line_width.timeslot: Line width of the fringe of time slots (default `0`).\n    formatter.line_width.barrier: Line width of barrier lines (default `3`).\n    formatter.line_width.gate_link: Line width of gate links (default `3`).\n    formatter.line_style.barrier: Line style of barrier lines. This\n        conforms to the line style spec of matplotlib (default `'-'`).\n    formatter.line_style.gate_link: Line style of gate link lines. This\n        conforms to the line style spec of matplotlib (default `'-'`).\n    formatter.text_size.gate_name: Text size of gate name annotations (default `12`).\n    formatter.text_size.bit_name: Text size of bit labels (default `15`).\n    formatter.text_size.frame_change: Text size of frame change symbols (default `18`).\n    formatter.text_size.axis_label: Text size of axis labels (default `13`).\n    formatter.label_offset.frame_change: Offset of zero duration gate name annotations\n        from the zero line of time slot (default `0.25`).\n    formatter.control.show_idle: Set `True` to show time slots without gate (default `True`).\n    formatter.control.show_clbits: Set `True` to show time slots of\n        classical bits (default `True`).\n    formatter.control.show_barriers: Set `True` to show barriers (default `True`).\n    formatter.control.show_delays: Set `True` to show delay boxes (default `True`).\n    generator.gates: List of callback functions that generates drawings\n        for gates. Arbitrary callback functions satisfying the generator format\n        can be set here. There are some default generators in the timeline drawer. See\n        :py:mod:`~qiskit.visualization.timeline.generators` for more details.\n        No default generator is set (default `[]`).\n    generator.bits: List of callback functions that generates drawings for bit labels\n        and time slots. Arbitrary callback functions satisfying the generator format\n        can be set here. There are some default generators in the timeline drawer. See\n        :py:mod:`~qiskit.visualization.timeline.generators` for more details.\n        No default generator is set (default `[]`).\n    generator.barriers: List of callback functions that generates drawings\n        for barriers. Arbitrary callback functions satisfying the generator format\n        can be set here. There are some default generators in the timeline drawer. See\n        :py:mod:`~qiskit.visualization.timeline.generators` for more details.\n        No default generator is set (default `[]`).\n    generator.gate_links: List of callback functions that generates drawings\n        for gate links. Arbitrary callback functions satisfying the generator format\n        can be set here. There are some default generators in the timeline drawer. See\n        :py:mod:`~qiskit.visualization.timeline.generators` for more details.\n        No default generator is set (default `[]`).\n    layout.bit_arrange: Callback function that sorts bits. See\n        :py:mod:`~qiskit.visualization.timeline.layouts` for more details.\n        No default layout is set. (default `None`).\n    layout.time_axis_map: Callback function that determines the layout of\n        horizontal axis labels. See :py:mod:`~qiskit.visualization.timeline.layouts`\n        for more details. No default layout is set. (default `None`).\n\nExamples:\n    To visualize a scheduled circuit program, you can call this function with set of\n    control arguments. Most of appearance of the output image can be controlled by the\n    stylesheet.\n\n    Drawing with the default stylesheet.\n\n    .. plot::\n       :include-source:\n\n        from qiskit import QuantumCircuit, transpile, schedule\n        from qiskit.visualization.timeline import draw\n        from qiskit.providers.fake_provider import FakeBoeblingen\n\n        qc = QuantumCircuit(2)\n        qc.h(0)\n        qc.cx(0,1)\n\n        qc = transpile(qc, FakeBoeblingen(), scheduling_method='alap', layout_method='trivial')\n        draw(qc)\n\n    Drawing with the simple stylesheet.\n\n    .. plot::\n       :include-source:\n\n        from qiskit import QuantumCircuit, transpile, schedule\n        from qiskit.visualization.timeline import draw, IQXSimple\n        from qiskit.providers.fake_provider import FakeBoeblingen\n\n        qc = QuantumCircuit(2)\n        qc.h(0)\n        qc.cx(0,1)\n\n        qc = transpile(qc, FakeBoeblingen(), scheduling_method='alap', layout_method='trivial')\n        draw(qc, style=IQXSimple())\n\n    Drawing with the stylesheet suited for program debugging.\n\n    .. plot::\n       :include-source:\n\n        from qiskit import QuantumCircuit, transpile, schedule\n        from qiskit.visualization.timeline import draw, IQXDebugging\n        from qiskit.providers.fake_provider import FakeBoeblingen\n\n        qc = QuantumCircuit(2)\n        qc.h(0)\n        qc.cx(0,1)\n\n        qc = transpile(qc, FakeBoeblingen(), scheduling_method='alap', layout_method='trivial')\n        draw(qc, style=IQXDebugging())\n\n    You can partially customize a preset stylesheet when call it::\n\n        my_style = {\n            'formatter.general.fig_width': 16,\n            'formatter.general.fig_unit_height': 1\n        }\n        style = IQXStandard(**my_style)\n\n        # draw\n        draw(qc, style=style)\n\n    In the same way as above, you can create custom generator or layout functions\n    and update existing stylesheet with custom functions.\n    This feature enables you to control the most of appearance of the output image\n    without modifying the codebase of the scheduled circuit drawer.",
        "api_signature": "draw(program, style, time_range, disable_bits, show_clbits, show_idle, show_barriers, show_delays, show_labels, plotter, axis, filename)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/interface.py"
    },
    {
        "api_name": "qreg_creg_ascending",
        "full_api_name": "qreg_creg_ascending",
        "api_description": "Sort bits by ascending order.\n\nBit order becomes Q0, Q1, ..., Cl0, Cl1, ...\n\nArgs:\n    bits: List of bits to sort.\n\nReturns:\n    Sorted bits.",
        "api_signature": "qreg_creg_ascending(bits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/layouts.py"
    },
    {
        "api_name": "qreg_creg_descending",
        "full_api_name": "qreg_creg_descending",
        "api_description": "Sort bits by descending order.\n\nBit order becomes Q_N, Q_N-1, ..., Cl_N, Cl_N-1, ...\n\nArgs:\n    bits: List of bits to sort.\n\nReturns:\n    Sorted bits.",
        "api_signature": "qreg_creg_descending(bits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/layouts.py"
    },
    {
        "api_name": "time_map_in_dt",
        "full_api_name": "time_map_in_dt",
        "api_description": "Layout function for the horizontal axis formatting.\n\nGenerate equispaced 6 horizontal axis ticks.\n\nArgs:\n    time_window: Left and right edge of this graph.\n\nReturns:\n    Axis formatter object.",
        "api_signature": "time_map_in_dt(time_window)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/layouts.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "DrawerCanvas.__init__",
        "api_description": "Create new data container.",
        "api_signature": "__init__(self, stylesheet)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/core.py"
    },
    {
        "api_name": "time_range",
        "full_api_name": "DrawerCanvas.time_range",
        "api_description": "Return current time range to draw.\n\nCalculate net duration and add side margin to edge location.\n\nReturns:\n    Time window considering side margin.",
        "api_signature": "time_range(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/core.py"
    },
    {
        "api_name": "time_range",
        "full_api_name": "DrawerCanvas.time_range",
        "api_description": "Update time range to draw.",
        "api_signature": "time_range(self, new_range)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/core.py"
    },
    {
        "api_name": "collections",
        "full_api_name": "DrawerCanvas.collections",
        "api_description": "Return currently active entries from drawing data collection.\n\nThe object is returned with unique name as a key of an object handler.\nWhen the horizontal coordinate contains `AbstractCoordinate`,\nthe value is substituted by current time range preference.",
        "api_signature": "collections(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/core.py"
    },
    {
        "api_name": "add_data",
        "full_api_name": "DrawerCanvas.add_data",
        "api_description": "Add drawing to collections.\n\nIf the given object already exists in the collections,\nthis interface replaces the old object instead of adding new entry.\n\nArgs:\n    data: New drawing to add.",
        "api_signature": "add_data(self, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/core.py"
    },
    {
        "api_name": "load_program",
        "full_api_name": "DrawerCanvas.load_program",
        "api_description": "Load quantum circuit and create drawing..\n\nArgs:\n    program: Scheduled circuit object to draw.\n\nRaises:\n   VisualizationError: When circuit is not scheduled.",
        "api_signature": "load_program(self, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/core.py"
    },
    {
        "api_name": "set_time_range",
        "full_api_name": "DrawerCanvas.set_time_range",
        "api_description": "Set time range to draw.\n\nArgs:\n    t_start: Left boundary of drawing in units of cycle time.\n    t_end: Right boundary of drawing in units of cycle time.",
        "api_signature": "set_time_range(self, t_start, t_end)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/core.py"
    },
    {
        "api_name": "set_disable_bits",
        "full_api_name": "DrawerCanvas.set_disable_bits",
        "api_description": "Interface method to control visibility of bits.\n\nSpecified object in the blocked list will not be shown.\n\nArgs:\n    bit: A qubit or classical bit object to disable.\n    remove: Set `True` to disable, set `False` to enable.",
        "api_signature": "set_disable_bits(self, bit, remove)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/core.py"
    },
    {
        "api_name": "set_disable_type",
        "full_api_name": "DrawerCanvas.set_disable_type",
        "api_description": "Interface method to control visibility of data types.\n\nSpecified object in the blocked list will not be shown.\n\nArgs:\n    data_type: A drawing data type to disable.\n    remove: Set `True` to disable, set `False` to enable.",
        "api_signature": "set_disable_type(self, data_type, remove)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/core.py"
    },
    {
        "api_name": "update",
        "full_api_name": "DrawerCanvas.update",
        "api_description": "Update all collections.\n\nThis method should be called before the canvas is passed to the plotter.",
        "api_signature": "update(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/core.py"
    },
    {
        "api_name": "_check_data_visible",
        "full_api_name": "DrawerCanvas._check_data_visible",
        "api_description": "A helper function to check if the data is visible.\n\nArgs:\n    data: Drawing object to test.\n\nReturns:\n    Return `True` if the data is visible.",
        "api_signature": "_check_data_visible(self, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/core.py"
    },
    {
        "api_name": "_time_range_check",
        "full_api_name": "DrawerCanvas._time_range_check",
        "api_description": "If data is located outside the current time range.",
        "api_signature": "_time_range_check(_data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/core.py"
    },
    {
        "api_name": "_associated_bit_check",
        "full_api_name": "DrawerCanvas._associated_bit_check",
        "api_description": "If any associated bit is not shown.",
        "api_signature": "_associated_bit_check(_data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/core.py"
    },
    {
        "api_name": "_data_check",
        "full_api_name": "DrawerCanvas._data_check",
        "api_description": "If data is valid.",
        "api_signature": "_data_check(_data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/core.py"
    },
    {
        "api_name": "_check_bit_visible",
        "full_api_name": "DrawerCanvas._check_bit_visible",
        "api_description": "A helper function to check if the bit is visible.\n\nArgs:\n    bit: Bit object to test.\n\nReturns:\n    Return `True` if the bit is visible.",
        "api_signature": "_check_bit_visible(self, bit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/core.py"
    },
    {
        "api_name": "_bind_coordinate",
        "full_api_name": "DrawerCanvas._bind_coordinate",
        "api_description": "A helper function to bind actual coordinates to an `AbstractCoordinate`.\n\nArgs:\n    vals: Sequence of coordinate objects associated with a drawing.\n\nReturns:\n    Numpy data array with substituted values.",
        "api_signature": "_bind_coordinate(self, vals)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/core.py"
    },
    {
        "api_name": "substitute",
        "full_api_name": "DrawerCanvas.substitute",
        "api_description": "",
        "api_signature": "substitute(val)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/core.py"
    },
    {
        "api_name": "_check_link_overlap",
        "full_api_name": "DrawerCanvas._check_link_overlap",
        "api_description": "Helper method to check overlap of bit links.\n\nThis method dynamically shifts horizontal position of links if they are overlapped.",
        "api_signature": "_check_link_overlap(self, links)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/core.py"
    },
    {
        "api_name": "y_coords",
        "full_api_name": "DrawerCanvas.y_coords",
        "api_description": "",
        "api_signature": "y_coords(link)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/core.py"
    },
    {
        "api_name": "gen_sched_gate",
        "full_api_name": "gen_sched_gate",
        "api_description": "Generate time bucket or symbol of scheduled gate.\n\nIf gate duration is zero or frame change a symbol is generated instead of time box.\nThe face color of gates depends on the operand type.\n\nStylesheet:\n    - The `gate` style is applied for finite duration gate.\n    - The `frame_change` style is applied for zero duration gate.\n    - The `gate_face_color` style is applied for face color.\n\nArgs:\n    gate: Gate information source.\n    formatter: Dictionary of stylesheet settings.\n\nReturns:\n    List of `TextData` or `BoxData` drawings.",
        "api_signature": "gen_sched_gate(gate, formatter)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/generators.py"
    },
    {
        "api_name": "gen_full_gate_name",
        "full_api_name": "gen_full_gate_name",
        "api_description": "Generate gate name.\n\nParameters and associated bits are also shown.\n\nStylesheet:\n    - `gate_name` style is applied.\n    - `gate_latex_repr` key is used to find the latex representation of the gate name.\n\nArgs:\n    gate: Gate information source.\n    formatter: Dictionary of stylesheet settings.\n    program: Optional program that the bits are a part of.\n\nReturns:\n    List of `TextData` drawings.",
        "api_signature": "gen_full_gate_name(gate, formatter, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/generators.py"
    },
    {
        "api_name": "gen_short_gate_name",
        "full_api_name": "gen_short_gate_name",
        "api_description": "Generate gate name.\n\nOnly operand name is shown.\n\nStylesheet:\n    - `gate_name` style is applied.\n    - `gate_latex_repr` key is used to find the latex representation of the gate name.\n\nArgs:\n    gate: Gate information source.\n    formatter: Dictionary of stylesheet settings.\n\nReturns:\n    List of `TextData` drawings.",
        "api_signature": "gen_short_gate_name(gate, formatter)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/generators.py"
    },
    {
        "api_name": "gen_timeslot",
        "full_api_name": "gen_timeslot",
        "api_description": "Generate time slot of associated bit.\n\nStylesheet:\n    - `timeslot` style is applied.\n\nArgs:\n    bit: Bit object associated to this drawing.\n    formatter: Dictionary of stylesheet settings.\n\nReturns:\n    List of `BoxData` drawings.",
        "api_signature": "gen_timeslot(bit, formatter)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/generators.py"
    },
    {
        "api_name": "gen_bit_name",
        "full_api_name": "gen_bit_name",
        "api_description": "Generate bit label.\n\nStylesheet:\n    - `bit_name` style is applied.\n\nArgs:\n    bit: Bit object associated to this drawing.\n    formatter: Dictionary of stylesheet settings.\n    program: Optional program that the bits are a part of.\n\nReturns:\n    List of `TextData` drawings.",
        "api_signature": "gen_bit_name(bit, formatter, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/generators.py"
    },
    {
        "api_name": "gen_barrier",
        "full_api_name": "gen_barrier",
        "api_description": "Generate barrier line.\n\nStylesheet:\n    - `barrier` style is applied.\n\nArgs:\n    barrier: Barrier instruction.\n    formatter: Dictionary of stylesheet settings.\n\nReturns:\n    List of `LineData` drawings.",
        "api_signature": "gen_barrier(barrier, formatter)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/generators.py"
    },
    {
        "api_name": "gen_gate_link",
        "full_api_name": "gen_gate_link",
        "api_description": "Generate gate link line.\n\nLine color depends on the operand type.\n\nStylesheet:\n    - `gate_link` style is applied.\n    - The `gate_face_color` style is applied for line color.\n\nArgs:\n    link: Gate link object.\n    formatter: Dictionary of stylesheet settings.\n\nReturns:\n    List of `GateLinkData` drawings.",
        "api_signature": "gen_gate_link(link, formatter)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/generators.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ElementaryData.__init__",
        "api_description": "Create new drawing.\n\nArgs:\n    data_type: String representation of this drawing.\n    xvals: Series of horizontal coordinate that the object is drawn.\n    yvals: Series of vertical coordinate that the object is drawn.\n    bits: Qubit or Clbit object bound to this drawing.\n    meta: Meta data dictionary of the object.\n    styles: Style keyword args of the object. This conforms to `matplotlib`.",
        "api_signature": "__init__(self, data_type, xvals, yvals, bits, meta, styles)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/drawings.py"
    },
    {
        "api_name": "data_key",
        "full_api_name": "ElementaryData.data_key",
        "api_description": "Return unique hash of this object.",
        "api_signature": "data_key(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/drawings.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "ElementaryData.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/drawings.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "ElementaryData.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/drawings.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "LineData.__init__",
        "api_description": "Create new line.\n\nArgs:\n    data_type: String representation of this drawing.\n    xvals: Series of horizontal coordinate that the object is drawn.\n    yvals: Series of vertical coordinate that the object is drawn.\n    bit: Bit associated to this object.\n    meta: Meta data dictionary of the object.\n    styles: Style keyword args of the object. This conforms to `matplotlib`.",
        "api_signature": "__init__(self, data_type, xvals, yvals, bit, meta, styles)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/drawings.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BoxData.__init__",
        "api_description": "Create new box.\n\nArgs:\n    data_type: String representation of this drawing.\n    xvals: Left and right coordinate that the object is drawn.\n    yvals: Top and bottom coordinate that the object is drawn.\n    bit: Bit associated to this object.\n    meta: Meta data dictionary of the object.\n    styles: Style keyword args of the object. This conforms to `matplotlib`.\n\nRaises:\n    VisualizationError: When number of data points are not equals to 2.",
        "api_signature": "__init__(self, data_type, xvals, yvals, bit, meta, styles)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/drawings.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "TextData.__init__",
        "api_description": "Create new text.\n\nArgs:\n    data_type: String representation of this drawing.\n    xval: Horizontal coordinate that the object is drawn.\n    yval: Vertical coordinate that the object is drawn.\n    bit: Bit associated to this object.\n    text: A string to draw on the canvas.\n    latex: If set this string is used instead of `text`.\n    meta: Meta data dictionary of the object.\n    styles: Style keyword args of the object. This conforms to `matplotlib`.",
        "api_signature": "__init__(self, data_type, xval, yval, bit, text, latex, meta, styles)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/drawings.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "GateLinkData.__init__",
        "api_description": "Create new bit link.\n\nArgs:\n    xval: Horizontal coordinate that the object is drawn.\n    bits: Bit associated to this object.\n    styles: Style keyword args of the object. This conforms to `matplotlib`.",
        "api_signature": "__init__(self, xval, bits, styles)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/drawings.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "MplPlotter.__init__",
        "api_description": "Create new plotter.\n\nArgs:\n    canvas: Configured drawer canvas object. Canvas object should be updated\n        with `.update` method before initializing the plotter.\n    axis: Matplotlib axis object. When `axis` is provided, the plotter updates\n        given axis instead of creating and returning new matplotlib figure.",
        "api_signature": "__init__(self, canvas, axis)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/plotters/matplotlib.py"
    },
    {
        "api_name": "initialize_canvas",
        "full_api_name": "MplPlotter.initialize_canvas",
        "api_description": "Format appearance of matplotlib canvas.",
        "api_signature": "initialize_canvas(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/plotters/matplotlib.py"
    },
    {
        "api_name": "draw",
        "full_api_name": "MplPlotter.draw",
        "api_description": "Output drawings stored in canvas object.",
        "api_signature": "draw(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/plotters/matplotlib.py"
    },
    {
        "api_name": "_time_bucket_outline",
        "full_api_name": "MplPlotter._time_bucket_outline",
        "api_description": "Generate outline of time bucket. Edges are smoothly faded.\n\nArgs:\n    xvals: Left and right point coordinates.\n    yvals: Bottom and top point coordinates.\n\nReturns:\n    Coordinate vectors of time bucket fringe.",
        "api_signature": "_time_bucket_outline(self, xvals, yvals)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/plotters/matplotlib.py"
    },
    {
        "api_name": "save_file",
        "full_api_name": "MplPlotter.save_file",
        "api_description": "Save image to file.\nArgs:\n    filename: File path to output image data.",
        "api_signature": "save_file(self, filename)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/plotters/matplotlib.py"
    },
    {
        "api_name": "get_image",
        "full_api_name": "MplPlotter.get_image",
        "api_description": "Get image data to return.\nArgs:\n    interactive: When set `True` show the circuit in a new window.\n        This depends on the matplotlib backend being used supporting this.\nReturns:\n    Matplotlib figure data.",
        "api_signature": "get_image(self, interactive)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/plotters/matplotlib.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BasePlotter.__init__",
        "api_description": "Create new plotter.\nArgs:\n    canvas: Configured drawer canvas object.",
        "api_signature": "__init__(self, canvas)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/plotters/base_plotter.py"
    },
    {
        "api_name": "initialize_canvas",
        "full_api_name": "BasePlotter.initialize_canvas",
        "api_description": "Format appearance of the canvas.",
        "api_signature": "initialize_canvas(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/plotters/base_plotter.py"
    },
    {
        "api_name": "draw",
        "full_api_name": "BasePlotter.draw",
        "api_description": "Output drawings stored in canvas object.",
        "api_signature": "draw(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/plotters/base_plotter.py"
    },
    {
        "api_name": "save_file",
        "full_api_name": "BasePlotter.save_file",
        "api_description": "Save image to file.\nArgs:\n    filename: File path to output image data.",
        "api_signature": "save_file(self, filename)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/plotters/base_plotter.py"
    },
    {
        "api_name": "get_image",
        "full_api_name": "BasePlotter.get_image",
        "api_description": "Get image data to return.\nArgs:\n    interactive: When set `True` show the circuit in a new window.\n        This depends on the matplotlib backend being used supporting this.\nReturns:\n    Image data. This depends on the plotter API.",
        "api_signature": "get_image(self, interactive)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/plotters/base_plotter.py"
    },
    {
        "api_name": "circuit_drawer",
        "full_api_name": "circuit_drawer",
        "api_description": "Draw the quantum circuit. Use the output parameter to choose the drawing format:\n\n**text**: ASCII art TextDrawing that can be printed in the console.\n\n**matplotlib**: images with color rendered purely in Python.\n\n**latex**: high-quality images compiled via latex.\n\n**latex_source**: raw uncompiled latex output.\n\n.. warning::\n\n    Support for :class:`~.expr.Expr` nodes in conditions and :attr:`.SwitchCaseOp.target` fields\n    is preliminary and incomplete.  The ``text`` and ``mpl`` drawers will make a best-effort\n    attempt to show data dependencies, but the LaTeX-based drawers will skip these completely.\n\nArgs:\n    circuit (QuantumCircuit): the quantum circuit to draw\n    scale (float): scale of image to draw (shrink if < 1.0). Only used by\n        the `mpl`, `latex` and `latex_source` outputs. Defaults to 1.0.\n    filename (str): file path to save image to. Defaults to None.\n    style (dict or str): dictionary of style or file name of style json file.\n        This option is only used by the `mpl` or `latex` output type.\n        If `style` is a str, it is used as the path to a json file\n        which contains a style dict. The file will be opened, parsed, and\n        then any style elements in the dict will replace the default values\n        in the input dict. A file to be loaded must end in ``.json``, but\n        the name entered here can omit ``.json``. For example,\n        ``style='iqp.json'`` or ``style='iqp'``.\n        If `style` is a dict and the ``'name'`` key is set, that name\n        will be used to load a json file, followed by loading the other\n        items in the style dict. For example, ``style={'name': 'iqp'}``.\n        If `style` is not a str and `name` is not a key in the style dict,\n        then the default value from the user config file (usually\n        ``~/.qiskit/settings.conf``) will be used, for example,\n        ``circuit_mpl_style = iqp``.\n        If none of these are set, the `clifford` style will be used.\n        The search path for style json files can be specified in the user\n        config, for example,\n        ``circuit_mpl_style_path = /home/user/styles:/home/user``.\n        See: :class:`~qiskit.visualization.qcstyle.DefaultStyle` for more\n        information on the contents.\n    output (str): select the output method to use for drawing the circuit.\n        Valid choices are ``text``, ``mpl``, ``latex``, ``latex_source``.\n        By default, the `text` drawer is used unless the user config file\n        (usually ``~/.qiskit/settings.conf``) has an alternative backend set\n        as the default. For example, ``circuit_drawer = latex``. If the output\n        kwarg is set, that backend will always be used over the default in\n        the user config file.\n    interactive (bool): when set to true, show the circuit in a new window\n        (for `mpl` this depends on the matplotlib backend being used\n        supporting this). Note when used with either the `text` or the\n        `latex_source` output type this has no effect and will be silently\n        ignored. Defaults to False.\n    reverse_bits (bool): when set to True, reverse the bit order inside\n        registers for the output visualization. Defaults to False unless the\n        user config file (usually ``~/.qiskit/settings.conf``) has an\n        alternative value set. For example, ``circuit_reverse_bits = True``.\n    plot_barriers (bool): enable/disable drawing barriers in the output\n        circuit. Defaults to True.\n    justify (string): options are ``left``, ``right`` or ``none``. If\n        anything else is supplied, it defaults to left justified. It refers\n        to where gates should be placed in the output circuit if there is\n        an option. ``none`` results in each gate being placed in its own\n        column.\n    vertical_compression (string): ``high``, ``medium`` or ``low``. It\n        merges the lines generated by the `text` output so the drawing\n        will take less vertical room.  Default is ``medium``. Only used by\n        the `text` output, will be silently ignored otherwise.\n    idle_wires (bool): include idle wires (wires with no circuit elements)\n        in output visualization. Default is True.\n    with_layout (bool): include layout information, with labels on the\n        physical layout. Default is True.\n    fold (int): sets pagination. It can be disabled using -1. In `text`,\n        sets the length of the lines. This is useful when the drawing does\n        not fit in the console. If None (default), it will try to guess the\n        console width using ``shutil.get_terminal_size()``. However, if\n        running in jupyter, the default line length is set to 80 characters.\n        In `mpl`, it is the number of (visual) layers before folding.\n        Default is 25.\n    ax (matplotlib.axes.Axes): Only used by the `mpl` backend. An optional\n        Axes object to be used for the visualization output. If none is\n        specified, a new matplotlib Figure will be created and used.\n        Additionally, if specified there will be no returned Figure since\n        it is redundant.\n    initial_state (bool): Optional. Adds ``|0>`` in the beginning of the wire.\n        Default is False.\n    cregbundle (bool): Optional. If set True, bundle classical registers into a single wire.\n        Default is true if possible, and false if a block instruction needs to access an\n        individual bit from a register.\n    wire_order (list): Optional. A list of integers used to reorder the display\n        of the bits. The list must have an entry for every bit with the bits\n        in the range 0 to (num_qubits + num_clbits).\n    expr_len (int): Optional. The number of characters to display if an :class:`~.expr.Expr`\n        is used for the condition in a :class:`.ControlFlowOp`. If this number is exceeded,\n        the string will be truncated at that number and '...' added to the end.\n\nReturns:\n    :class:`TextDrawing` or :class:`matplotlib.figure` or :class:`PIL.Image` or\n    :class:`str`:\n\n    * `TextDrawing` (output='text')\n        A drawing that can be printed as ascii art.\n    * `matplotlib.figure.Figure` (output='mpl')\n        A matplotlib figure object for the circuit diagram.\n    * `PIL.Image` (output='latex')\n        An in-memory representation of the image of the circuit diagram.\n    * `str` (output='latex_source')\n        The LaTeX source code for visualizing the circuit diagram.\n\nRaises:\n    VisualizationError: when an invalid output method is selected\n    MissingOptionalLibraryError: when the output methods requires non-installed libraries.\n\nExample:\n    .. plot::\n       :include-source:\n\n        from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit\n        from qiskit.tools.visualization import circuit_drawer\n        q = QuantumRegister(1)\n        c = ClassicalRegister(1)\n        qc = QuantumCircuit(q, c)\n        qc.h(q)\n        qc.measure(q, c)\n        circuit_drawer(qc, output='mpl', style={'backgroundcolor': '#EEEEEE'})",
        "api_signature": "circuit_drawer(circuit, scale, filename, style, output, interactive, plot_barriers, reverse_bits, justify, vertical_compression, idle_wires, with_layout, fold, ax, initial_state, cregbundle, wire_order, expr_len)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/circuit_visualization.py"
    },
    {
        "api_name": "check_clbit_in_inst",
        "full_api_name": "check_clbit_in_inst",
        "api_description": "",
        "api_signature": "check_clbit_in_inst(circuit, cregbundle)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/circuit_visualization.py"
    },
    {
        "api_name": "_text_circuit_drawer",
        "full_api_name": "_text_circuit_drawer",
        "api_description": "Draws a circuit using ascii art.\n\nArgs:\n    circuit (QuantumCircuit): Input circuit\n    filename (str): Optional filename to write the result\n    reverse_bits (bool): Rearrange the bits in reverse order.\n    plot_barriers (bool): Draws the barriers when they are there.\n    justify (str) : `left`, `right` or `none`. Defaults to `left`. Says how\n        the circuit should be justified.\n    vertical_compression (string): `high`, `medium`, or `low`. It merges the\n        lines so the drawing will take less vertical room. Default is `high`.\n    idle_wires (bool): Include idle wires. Default is True.\n    with_layout (bool): Include layout information with labels on the physical\n        layout. Default: True\n    fold (int): Optional. Breaks the circuit drawing to this length. This\n        is useful when the drawing does not fit in the console. If\n        None (default), it will try to guess the console width using\n        `shutil.get_terminal_size()`. If you don't want pagination\n        at all, set `fold=-1`.\n    initial_state (bool): Optional. Adds |0> in the beginning of the line.\n        Default: `False`.\n    cregbundle (bool): Optional. If set True, bundle classical registers.\n        Default: ``True``.\n    encoding (str): Optional. Sets the encoding preference of the output.\n        Default: ``sys.stdout.encoding``.\n    wire_order (list): Optional. A list of integers used to reorder the display\n        of the bits. The list must have an entry for every bit with the bits\n        in the range 0 to (num_qubits + num_clbits).\n    expr_len (int): Optional. The number of characters to display if an :class:`~.expr.Expr`\n        is used for the condition in a :class:`.ControlFlowOp`. If this number is exceeded,\n        the string will be truncated at that number and '...' added to the end.\n\nReturns:\n    TextDrawing: An instance that, when printed, draws the circuit in ascii art.\n\nRaises:\n    VisualizationError: When the filename extension is not .txt.",
        "api_signature": "_text_circuit_drawer(circuit, filename, reverse_bits, plot_barriers, justify, vertical_compression, idle_wires, with_layout, fold, initial_state, cregbundle, encoding, wire_order, expr_len)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/circuit_visualization.py"
    },
    {
        "api_name": "_latex_circuit_drawer",
        "full_api_name": "_latex_circuit_drawer",
        "api_description": "Draw a quantum circuit based on latex (Qcircuit package)\n\nRequires version >=2.6.0 of the qcircuit LaTeX package.\n\nArgs:\n    circuit (QuantumCircuit): a quantum circuit\n    scale (float): scaling factor\n    style (dict or str): dictionary of style or file name of style file\n    filename (str): file path to save image to\n    reverse_bits (bool): When set to True reverse the bit order inside\n        registers for the output visualization.\n    plot_barriers (bool): Enable/disable drawing barriers in the output\n        circuit. Defaults to True.\n    justify (str) : `left`, `right` or `none`. Defaults to `left`. Says how\n        the circuit should be justified.\n    idle_wires (bool): Include idle wires. Default is True.\n    with_layout (bool): Include layout information, with labels on the physical\n        layout. Default: True\n    initial_state (bool): Optional. Adds |0> in the beginning of the line.\n        Default: `False`.\n    cregbundle (bool): Optional. If set True, bundle classical registers.  On by default, if\n        this is possible for the given circuit, otherwise off.\n    wire_order (list): Optional. A list of integers used to reorder the display\n        of the bits. The list must have an entry for every bit with the bits\n        in the range 0 to (num_qubits + num_clbits).\n\nReturns:\n    PIL.Image: an in-memory representation of the circuit diagram\n\nRaises:\n    MissingOptionalLibraryError: if pillow, pdflatex, or poppler are not installed\n    VisualizationError: if one of the conversion utilities failed for some internal or\n        file-access reason.",
        "api_signature": "_latex_circuit_drawer(circuit, scale, style, filename, plot_barriers, reverse_bits, justify, idle_wires, with_layout, initial_state, cregbundle, wire_order)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/circuit_visualization.py"
    },
    {
        "api_name": "_generate_latex_source",
        "full_api_name": "_generate_latex_source",
        "api_description": "Convert QuantumCircuit to LaTeX string.\n\nArgs:\n    circuit (QuantumCircuit): a quantum circuit\n    scale (float): scaling factor\n    style (dict or str): dictionary of style or file name of style file\n    filename (str): optional filename to write latex\n    reverse_bits (bool): When set to True reverse the bit order inside\n        registers for the output visualization.\n    plot_barriers (bool): Enable/disable drawing barriers in the output\n        circuit. Defaults to True.\n    justify (str) : `left`, `right` or `none`. Defaults to `left`. Says how\n        the circuit should be justified.\n    idle_wires (bool): Include idle wires. Default is True.\n    with_layout (bool): Include layout information, with labels on the physical\n        layout. Default: True\n    initial_state (bool): Optional. Adds |0> in the beginning of the line.\n        Default: `False`.\n    cregbundle (bool): Optional. If set True, bundle classical registers.\n    wire_order (list): Optional. A list of integers used to reorder the display\n        of the bits. The list must have an entry for every bit with the bits\n        in the range 0 to (num_qubits + num_clbits).\n\nReturns:\n    str: Latex string appropriate for writing to file.",
        "api_signature": "_generate_latex_source(circuit, filename, scale, style, reverse_bits, plot_barriers, justify, idle_wires, with_layout, initial_state, cregbundle, wire_order)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/circuit_visualization.py"
    },
    {
        "api_name": "_matplotlib_circuit_drawer",
        "full_api_name": "_matplotlib_circuit_drawer",
        "api_description": "Draw a quantum circuit based on matplotlib.\nIf `%matplotlib inline` is invoked in a Jupyter notebook, it visualizes a circuit inline.\nWe recommend `%config InlineBackend.figure_format = 'svg'` for the inline visualization.\n\nArgs:\n    circuit (QuantumCircuit): a quantum circuit\n    scale (float): scaling factor\n    filename (str): file path to save image to\n    style (dict or str): dictionary of style or file name of style file\n    reverse_bits (bool): When set to True, reverse the bit order inside\n        registers for the output visualization.\n    plot_barriers (bool): Enable/disable drawing barriers in the output\n        circuit. Defaults to True.\n    justify (str): `left`, `right` or `none`. Defaults to `left`. Says how\n        the circuit should be justified.\n    idle_wires (bool): Include idle wires. Default is True.\n    with_layout (bool): Include layout information, with labels on the physical\n        layout. Default: True.\n    fold (int): Number of vertical layers allowed before folding. Default is 25.\n    ax (matplotlib.axes.Axes): An optional Axes object to be used for\n        the visualization output. If none is specified, a new matplotlib\n        Figure will be created and used. Additionally, if specified there\n        will be no returned Figure since it is redundant.\n    initial_state (bool): Optional. Adds |0> in the beginning of the line.\n        Default: `False`.\n    cregbundle (bool): Optional. If set True bundle classical registers.\n        Default: ``True``.\n    wire_order (list): Optional. A list of integers used to reorder the display\n        of the bits. The list must have an entry for every bit with the bits\n        in the range 0 to (num_qubits + num_clbits).\n    expr_len (int): Optional. The number of characters to display if an :class:`~.expr.Expr`\n        is used for the condition in a :class:`.ControlFlowOp`. If this number is exceeded,\n        the string will be truncated at that number and '...' added to the end.\n\nReturns:\n    matplotlib.figure: a matplotlib figure object for the circuit diagram\n        if the ``ax`` kwarg is not set.",
        "api_signature": "_matplotlib_circuit_drawer(circuit, scale, filename, style, plot_barriers, reverse_bits, justify, idle_wires, with_layout, fold, ax, initial_state, cregbundle, wire_order, expr_len)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/circuit_visualization.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "MatplotlibDrawer.__init__",
        "api_description": "",
        "api_signature": "__init__(self, qubits, clbits, nodes, circuit, scale, style, reverse_bits, plot_barriers, fold, ax, initial_state, cregbundle, with_layout, expr_len)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/matplotlib.py"
    },
    {
        "api_name": "draw",
        "full_api_name": "MatplotlibDrawer.draw",
        "api_description": "Main entry point to 'matplotlib' ('mpl') drawer. Called from\n``visualization.circuit_drawer`` and from ``QuantumCircuit.draw`` through circuit_drawer.",
        "api_signature": "draw(self, filename, verbose)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/matplotlib.py"
    },
    {
        "api_name": "_get_layer_widths",
        "full_api_name": "MatplotlibDrawer._get_layer_widths",
        "api_description": "Compute the layer_widths for the layers",
        "api_signature": "_get_layer_widths(self, node_data, wire_map, outer_circuit, glob_data, builder)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/matplotlib.py"
    },
    {
        "api_name": "_set_bit_reg_info",
        "full_api_name": "MatplotlibDrawer._set_bit_reg_info",
        "api_description": "Get all the info for drawing bit/reg names and numbers",
        "api_signature": "_set_bit_reg_info(self, wire_map, qubits_dict, clbits_dict, glob_data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/matplotlib.py"
    },
    {
        "api_name": "_get_coords",
        "full_api_name": "MatplotlibDrawer._get_coords",
        "api_description": "Load all the coordinate info needed to place the gates on the drawing.",
        "api_signature": "_get_coords(self, node_data, wire_map, outer_circuit, layer_widths, qubits_dict, clbits_dict, glob_data, flow_parent)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/matplotlib.py"
    },
    {
        "api_name": "_get_text_width",
        "full_api_name": "MatplotlibDrawer._get_text_width",
        "api_description": "Compute the width of a string in the default font",
        "api_signature": "_get_text_width(self, text, glob_data, fontsize, param, reg_remove_under)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/matplotlib.py"
    },
    {
        "api_name": "_draw_regs_wires",
        "full_api_name": "MatplotlibDrawer._draw_regs_wires",
        "api_description": "Draw the register names and numbers, wires, and vertical lines at the ends",
        "api_signature": "_draw_regs_wires(self, num_folds, xmax, max_x_index, qubits_dict, clbits_dict, glob_data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/matplotlib.py"
    },
    {
        "api_name": "_add_nodes_and_coords",
        "full_api_name": "MatplotlibDrawer._add_nodes_and_coords",
        "api_description": "Add the nodes from ControlFlowOps and their coordinates to the main circuit",
        "api_signature": "_add_nodes_and_coords(self, nodes, node_data, wire_map, outer_circuit, layer_widths, qubits_dict, clbits_dict, glob_data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/matplotlib.py"
    },
    {
        "api_name": "_draw_ops",
        "full_api_name": "MatplotlibDrawer._draw_ops",
        "api_description": "Draw the gates in the circuit",
        "api_signature": "_draw_ops(self, nodes, node_data, wire_map, outer_circuit, layer_widths, qubits_dict, clbits_dict, glob_data, verbose)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/matplotlib.py"
    },
    {
        "api_name": "_get_colors",
        "full_api_name": "MatplotlibDrawer._get_colors",
        "api_description": "Get all the colors needed for drawing the circuit",
        "api_signature": "_get_colors(self, node, node_data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/matplotlib.py"
    },
    {
        "api_name": "_condition",
        "full_api_name": "MatplotlibDrawer._condition",
        "api_description": "Add a conditional to a gate",
        "api_signature": "_condition(self, node, node_data, wire_map, outer_circuit, cond_xy, glob_data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/matplotlib.py"
    },
    {
        "api_name": "_measure",
        "full_api_name": "MatplotlibDrawer._measure",
        "api_description": "Draw the measure symbol and the line to the clbit",
        "api_signature": "_measure(self, node, node_data, outer_circuit, glob_data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/matplotlib.py"
    },
    {
        "api_name": "_barrier",
        "full_api_name": "MatplotlibDrawer._barrier",
        "api_description": "Draw a barrier",
        "api_signature": "_barrier(self, node, node_data, glob_data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/matplotlib.py"
    },
    {
        "api_name": "_gate",
        "full_api_name": "MatplotlibDrawer._gate",
        "api_description": "Draw a 1-qubit gate",
        "api_signature": "_gate(self, node, node_data, glob_data, xy)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/matplotlib.py"
    },
    {
        "api_name": "_multiqubit_gate",
        "full_api_name": "MatplotlibDrawer._multiqubit_gate",
        "api_description": "Draw a gate covering more than one qubit",
        "api_signature": "_multiqubit_gate(self, node, node_data, glob_data, xy)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/matplotlib.py"
    },
    {
        "api_name": "_flow_op_gate",
        "full_api_name": "MatplotlibDrawer._flow_op_gate",
        "api_description": "Draw the box for a flow op circuit",
        "api_signature": "_flow_op_gate(self, node, node_data, glob_data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/matplotlib.py"
    },
    {
        "api_name": "_control_gate",
        "full_api_name": "MatplotlibDrawer._control_gate",
        "api_description": "Draw a controlled gate",
        "api_signature": "_control_gate(self, node, node_data, glob_data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/matplotlib.py"
    },
    {
        "api_name": "_set_ctrl_bits",
        "full_api_name": "MatplotlibDrawer._set_ctrl_bits",
        "api_description": "Determine which qubits are controls and whether they are open or closed",
        "api_signature": "_set_ctrl_bits(self, ctrl_state, num_ctrl_qubits, qbit, glob_data, ec, tc, text, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/matplotlib.py"
    },
    {
        "api_name": "_ctrl_qubit",
        "full_api_name": "MatplotlibDrawer._ctrl_qubit",
        "api_description": "Draw a control circle and if top or bottom control, draw control label",
        "api_signature": "_ctrl_qubit(self, xy, glob_data, fc, ec, tc, text, text_top)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/matplotlib.py"
    },
    {
        "api_name": "_x_tgt_qubit",
        "full_api_name": "MatplotlibDrawer._x_tgt_qubit",
        "api_description": "Draw the cnot target symbol",
        "api_signature": "_x_tgt_qubit(self, xy, glob_data, ec, ac)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/matplotlib.py"
    },
    {
        "api_name": "_symmetric_gate",
        "full_api_name": "MatplotlibDrawer._symmetric_gate",
        "api_description": "Draw symmetric gates for cz, cu1, cp, and rzz",
        "api_signature": "_symmetric_gate(self, node, node_data, base_type, glob_data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/matplotlib.py"
    },
    {
        "api_name": "_swap",
        "full_api_name": "MatplotlibDrawer._swap",
        "api_description": "Draw a Swap gate",
        "api_signature": "_swap(self, xy, node, node_data, color)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/matplotlib.py"
    },
    {
        "api_name": "_swap_cross",
        "full_api_name": "MatplotlibDrawer._swap_cross",
        "api_description": "Draw the Swap cross symbol",
        "api_signature": "_swap_cross(self, xy, color)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/matplotlib.py"
    },
    {
        "api_name": "_sidetext",
        "full_api_name": "MatplotlibDrawer._sidetext",
        "api_description": "Draw the sidetext for symmetric gates",
        "api_signature": "_sidetext(self, node, node_data, xy, tc, text)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/matplotlib.py"
    },
    {
        "api_name": "_line",
        "full_api_name": "MatplotlibDrawer._line",
        "api_description": "Draw a line from xy0 to xy1",
        "api_signature": "_line(self, xy0, xy1, lc, ls, zorder)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/matplotlib.py"
    },
    {
        "api_name": "_plot_coord",
        "full_api_name": "MatplotlibDrawer._plot_coord",
        "api_description": "Get the coord positions for an index",
        "api_signature": "_plot_coord(self, x_index, y_index, gate_width, glob_data, flow_op)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/matplotlib.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "NodeData.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/matplotlib.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QCircuitImage.__init__",
        "api_description": "QCircuitImage initializer.\n\nArgs:\n    qubits (list[Qubit]): list of qubits\n    clbits (list[Clbit]): list of clbits\n    nodes (list[list[DAGNode]]): list of circuit instructions, grouped by layer\n    scale (float): image scaling\n    style (dict or str): dictionary of style or file name of style file\n    reverse_bits (bool): when True, reverse the bit ordering of the registers\n    plot_barriers (bool): Enable/disable drawing barriers in the output\n       circuit. Defaults to True.\n    initial_state (bool): Optional. Adds |0> in the beginning of the line. Default: `False`.\n    cregbundle (bool): Optional. If set True bundle classical registers.\n    circuit (QuantumCircuit): the circuit that's being displayed\nRaises:\n    ImportError: If pylatexenc is not installed",
        "api_signature": "__init__(self, qubits, clbits, nodes, scale, style, reverse_bits, plot_barriers, initial_state, cregbundle, with_layout, circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/latex.py"
    },
    {
        "api_name": "latex",
        "full_api_name": "QCircuitImage.latex",
        "api_description": "Return LaTeX string representation of circuit.",
        "api_signature": "latex(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/latex.py"
    },
    {
        "api_name": "_initialize_latex_array",
        "full_api_name": "QCircuitImage._initialize_latex_array",
        "api_description": "Initialize qubit and clbit labels and set wire separation",
        "api_signature": "_initialize_latex_array(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/latex.py"
    },
    {
        "api_name": "_get_image_depth",
        "full_api_name": "QCircuitImage._get_image_depth",
        "api_description": "Get depth information for the circuit.",
        "api_signature": "_get_image_depth(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/latex.py"
    },
    {
        "api_name": "_get_beamer_page",
        "full_api_name": "QCircuitImage._get_beamer_page",
        "api_description": "Get height, width & scale attributes for the beamer page.",
        "api_signature": "_get_beamer_page(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/latex.py"
    },
    {
        "api_name": "_build_latex_array",
        "full_api_name": "QCircuitImage._build_latex_array",
        "api_description": "Returns an array of strings containing \\LaTeX for this circuit.",
        "api_signature": "_build_latex_array(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/latex.py"
    },
    {
        "api_name": "_build_multi_gate",
        "full_api_name": "QCircuitImage._build_multi_gate",
        "api_description": "Add a multiple wire gate to the _latex list",
        "api_signature": "_build_multi_gate(self, op, gate_text, wire_list, cwire_list, col)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/latex.py"
    },
    {
        "api_name": "_build_ctrl_gate",
        "full_api_name": "QCircuitImage._build_ctrl_gate",
        "api_description": "Add a gate with multiple controls to the _latex list",
        "api_signature": "_build_ctrl_gate(self, op, gate_text, wire_list, col)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/latex.py"
    },
    {
        "api_name": "_build_symmetric_gate",
        "full_api_name": "QCircuitImage._build_symmetric_gate",
        "api_description": "Add symmetric gates for cu1, cp, swap, and rzz",
        "api_signature": "_build_symmetric_gate(self, op, gate_text, wire_list, col)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/latex.py"
    },
    {
        "api_name": "_build_measure",
        "full_api_name": "QCircuitImage._build_measure",
        "api_description": "Build a meter and the lines to the creg",
        "api_signature": "_build_measure(self, node, col)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/latex.py"
    },
    {
        "api_name": "_build_barrier",
        "full_api_name": "QCircuitImage._build_barrier",
        "api_description": "Build a partial or full barrier if plot_barriers set",
        "api_signature": "_build_barrier(self, node, col)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/latex.py"
    },
    {
        "api_name": "_add_controls",
        "full_api_name": "QCircuitImage._add_controls",
        "api_description": "Add one or more controls to a gate",
        "api_signature": "_add_controls(self, wire_list, ctrlqargs, ctrl_state, col)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/latex.py"
    },
    {
        "api_name": "_add_condition",
        "full_api_name": "QCircuitImage._add_condition",
        "api_description": "Add a condition to the _latex list",
        "api_signature": "_add_condition(self, op, wire_list, col)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/latex.py"
    },
    {
        "api_name": "_truncate_float",
        "full_api_name": "QCircuitImage._truncate_float",
        "api_description": "Truncate long floats.",
        "api_signature": "_truncate_float(self, matchobj, ndigits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/latex.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "DefaultStyle.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/qcstyle.py"
    },
    {
        "api_name": "load_style",
        "full_api_name": "load_style",
        "api_description": "Utility function to load style from json files and call set_style.",
        "api_signature": "load_style(style)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/qcstyle.py"
    },
    {
        "api_name": "set_style",
        "full_api_name": "set_style",
        "api_description": "Utility function to take elements in new_style and\nwrite them into current_style.",
        "api_signature": "set_style(current_style, new_style)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/qcstyle.py"
    },
    {
        "api_name": "_is_boolean_expression",
        "full_api_name": "_is_boolean_expression",
        "api_description": "",
        "api_signature": "_is_boolean_expression(gate_text, op)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/_utils.py"
    },
    {
        "api_name": "get_gate_ctrl_text",
        "full_api_name": "get_gate_ctrl_text",
        "api_description": "Load the gate_text and ctrl_text strings based on names and labels",
        "api_signature": "get_gate_ctrl_text(op, drawer, style, calibrations)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/_utils.py"
    },
    {
        "api_name": "get_param_str",
        "full_api_name": "get_param_str",
        "api_description": "Get the params as a string to add to the gate text display",
        "api_signature": "get_param_str(op, drawer, ndigits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/_utils.py"
    },
    {
        "api_name": "get_wire_map",
        "full_api_name": "get_wire_map",
        "api_description": "Map the bits and registers to the index from the top of the drawing.\nThe key to the dict is either the (Qubit, Clbit) or if cregbundle True,\nthe register that is being bundled.\n\nArgs:\n    circuit (QuantumCircuit): the circuit being drawn\n    bits (list(Qubit, Clbit)): the Qubit's and Clbit's in the circuit\n    cregbundle (bool): if True bundle classical registers. Default: ``True``.\n\nReturns:\n    dict((Qubit, Clbit, ClassicalRegister): index): map of bits/registers\n        to index",
        "api_signature": "get_wire_map(circuit, bits, cregbundle)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/_utils.py"
    },
    {
        "api_name": "get_bit_register",
        "full_api_name": "get_bit_register",
        "api_description": "Get the register for a bit if there is one\n\nArgs:\n    circuit (QuantumCircuit): the circuit being drawn\n    bit (Qubit, Clbit): the bit to use to find the register and indexes\n\nReturns:\n    ClassicalRegister: register associated with the bit",
        "api_signature": "get_bit_register(circuit, bit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/_utils.py"
    },
    {
        "api_name": "get_bit_reg_index",
        "full_api_name": "get_bit_reg_index",
        "api_description": "Get the register for a bit if there is one, and the index of the bit\nfrom the top of the circuit, or the index of the bit within a register.\n\nArgs:\n    circuit (QuantumCircuit): the circuit being drawn\n    bit (Qubit, Clbit): the bit to use to find the register and indexes\n    reverse_bits (bool): deprecated option to reverse order of the bits\n\nReturns:\n    (ClassicalRegister, None): register associated with the bit\n    int: index of the bit from the top of the circuit\n    int: index of the bit within the register, if there is a register",
        "api_signature": "get_bit_reg_index(circuit, bit, reverse_bits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/_utils.py"
    },
    {
        "api_name": "get_wire_label",
        "full_api_name": "get_wire_label",
        "api_description": "Get the bit labels to display to the left of the wires.\n\nArgs:\n    drawer (str): which drawer is calling (\"text\", \"mpl\", or \"latex\")\n    register (QuantumRegister or ClassicalRegister): get wire_label for this register\n    index (int): index of bit in register\n    layout (Layout): Optional. mapping of virtual to physical bits\n    cregbundle (bool): Optional. if set True bundle classical registers.\n        Default: ``True``.\n\nReturns:\n    str: label to display for the register/index",
        "api_signature": "get_wire_label(drawer, register, index, layout, cregbundle)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/_utils.py"
    },
    {
        "api_name": "get_condition_label_val",
        "full_api_name": "get_condition_label_val",
        "api_description": "Get the label and value list to display a condition\n\nArgs:\n    condition (Union[Clbit, ClassicalRegister], int): classical condition\n    circuit (QuantumCircuit): the circuit that is being drawn\n    cregbundle (bool): if set True bundle classical registers\n    reverse_bits (bool): deprecated option to reverse order of the bits\n\nReturns:\n    str: label to display for the condition\n    list(str): list of 1's and 0's indicating values of condition",
        "api_signature": "get_condition_label_val(condition, circuit, cregbundle, reverse_bits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/_utils.py"
    },
    {
        "api_name": "fix_special_characters",
        "full_api_name": "fix_special_characters",
        "api_description": "Convert any special characters for mpl and latex drawers.\nCurrently only checks for multiple underscores in register names\nand uses wider space for mpl and latex drawers.\n\nArgs:\n    label (str): the label to fix\n\nReturns:\n    str: label to display",
        "api_signature": "fix_special_characters(label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/_utils.py"
    },
    {
        "api_name": "generate_latex_label",
        "full_api_name": "generate_latex_label",
        "api_description": "Convert a label to a valid latex string.",
        "api_signature": "generate_latex_label(label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/_utils.py"
    },
    {
        "api_name": "_get_layered_instructions",
        "full_api_name": "_get_layered_instructions",
        "api_description": "Given a circuit, return a tuple (qubits, clbits, nodes) where\nqubits and clbits are the quantum and classical registers\nin order (based on reverse_bits or wire_order) and nodes\nis a list of DAGOpNodes.\n\nArgs:\n    circuit (QuantumCircuit): From where the information is extracted.\n    reverse_bits (bool): If true the order of the bits in the registers is\n        reversed.\n    justify (str) : `left`, `right` or `none`. Defaults to `left`. Says how\n        the circuit should be justified.\n    idle_wires (bool): Include idle wires. Default is True.\n    wire_order (list): A list of ints that modifies the order of the bits\n\nReturns:\n    Tuple(list,list,list): To be consumed by the visualizer directly.\n\nRaises:\n    VisualizationError: if both reverse_bits and wire_order are entered.",
        "api_signature": "_get_layered_instructions(circuit, reverse_bits, justify, idle_wires, wire_order, wire_map)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/_utils.py"
    },
    {
        "api_name": "_sorted_nodes",
        "full_api_name": "_sorted_nodes",
        "api_description": "Convert DAG layer into list of nodes sorted by node_id\nqiskit-terra #2802",
        "api_signature": "_sorted_nodes(dag_layer)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/_utils.py"
    },
    {
        "api_name": "_get_gate_span",
        "full_api_name": "_get_gate_span",
        "api_description": "Get the list of qubits drawing this gate would cover\nqiskit-terra #2802",
        "api_signature": "_get_gate_span(qubits, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/_utils.py"
    },
    {
        "api_name": "_any_crossover",
        "full_api_name": "_any_crossover",
        "api_description": "Return True .IFF. 'node' crosses over any 'nodes'.",
        "api_signature": "_any_crossover(qubits, node, nodes)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/_utils.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "_LayerSpooler.__init__",
        "api_description": "Create spool",
        "api_signature": "__init__(self, dag, justification, measure_map)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/_utils.py"
    },
    {
        "api_name": "is_found_in",
        "full_api_name": "_LayerSpooler.is_found_in",
        "api_description": "Is any qreq in node found in any of nodes?",
        "api_signature": "is_found_in(self, node, nodes)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/_utils.py"
    },
    {
        "api_name": "insertable",
        "full_api_name": "_LayerSpooler.insertable",
        "api_description": "True .IFF. we can add 'node' to layer 'nodes'",
        "api_signature": "insertable(self, node, nodes)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/_utils.py"
    },
    {
        "api_name": "slide_from_left",
        "full_api_name": "_LayerSpooler.slide_from_left",
        "api_description": "Insert node into first layer where there is no conflict going l > r",
        "api_signature": "slide_from_left(self, node, index)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/_utils.py"
    },
    {
        "api_name": "slide_from_right",
        "full_api_name": "_LayerSpooler.slide_from_right",
        "api_description": "Insert node into rightmost layer as long there is no conflict.",
        "api_signature": "slide_from_right(self, node, index)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/_utils.py"
    },
    {
        "api_name": "add",
        "full_api_name": "_LayerSpooler.add",
        "api_description": "Add 'node' where it belongs, starting the try at 'index'.",
        "api_signature": "add(self, node, index)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/_utils.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "DrawElement.__init__",
        "api_description": "",
        "api_signature": "__init__(self, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "top",
        "full_api_name": "DrawElement.top",
        "api_description": "Constructs the top line of the element",
        "api_signature": "top(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "mid",
        "full_api_name": "DrawElement.mid",
        "api_description": "Constructs the middle line of the element",
        "api_signature": "mid(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "bot",
        "full_api_name": "DrawElement.bot",
        "api_description": "Constructs the bottom line of the element",
        "api_signature": "bot(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "length",
        "full_api_name": "DrawElement.length",
        "api_description": "Returns the length of the element, including the box around.",
        "api_signature": "length(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "width",
        "full_api_name": "DrawElement.width",
        "api_description": "Returns the width of the label, including padding",
        "api_signature": "width(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "width",
        "full_api_name": "DrawElement.width",
        "api_description": "",
        "api_signature": "width(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "connect",
        "full_api_name": "DrawElement.connect",
        "api_description": "Connects boxes and elements using wire_char and setting proper connectors.\n\nArgs:\n    wire_char (char): For example '\u2551' or '\u2502'.\n    where (list[\"top\", \"bot\"]): Where the connector should be set.\n    label (string): Some connectors have a label (see cu1, for example).",
        "api_signature": "connect(self, wire_char, where, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BoxOnClWire.__init__",
        "api_description": "",
        "api_signature": "__init__(self, label, top_connect, bot_connect)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BoxOnQuWire.__init__",
        "api_description": "",
        "api_signature": "__init__(self, label, top_connect, conditional)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "MeasureTo.__init__",
        "api_description": "",
        "api_signature": "__init__(self, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "MeasureFrom.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "center_label",
        "full_api_name": "MultiBox.center_label",
        "api_description": "In multi-bit elements, the label is centered vertically.\n\nArgs:\n    input_length (int): Rhe amount of wires affected.\n    order (int): Which middle element is this one?",
        "api_signature": "center_label(self, input_length, order)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "width",
        "full_api_name": "MultiBox.width",
        "api_description": "Returns the width of the label, including padding",
        "api_signature": "width(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BoxOnQuWireTop.__init__",
        "api_description": "",
        "api_signature": "__init__(self, label, top_connect, wire_label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BoxOnWireMid.__init__",
        "api_description": "",
        "api_signature": "__init__(self, label, input_length, order, wire_label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BoxOnQuWireMid.__init__",
        "api_description": "",
        "api_signature": "__init__(self, label, input_length, order, wire_label, control_label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BoxOnQuWireBot.__init__",
        "api_description": "",
        "api_signature": "__init__(self, label, input_length, bot_connect, wire_label, conditional)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "FlowOnQuWire.__init__",
        "api_description": "",
        "api_signature": "__init__(self, section, label, top_connect, conditional)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "FlowOnQuWireTop.__init__",
        "api_description": "",
        "api_signature": "__init__(self, section, label, top_connect, wire_label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "FlowOnQuWireMid.__init__",
        "api_description": "",
        "api_signature": "__init__(self, section, label, input_length, order, wire_label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "FlowOnQuWireBot.__init__",
        "api_description": "",
        "api_signature": "__init__(self, section, label, input_length, bot_connect, wire_label, conditional)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BoxOnClWireTop.__init__",
        "api_description": "",
        "api_signature": "__init__(self, label, top_connect, wire_label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BoxOnClWireMid.__init__",
        "api_description": "",
        "api_signature": "__init__(self, label, input_length, order, wire_label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BoxOnClWireBot.__init__",
        "api_description": "",
        "api_signature": "__init__(self, label, input_length, bot_connect, wire_label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "DirectOnQuWire.__init__",
        "api_description": "",
        "api_signature": "__init__(self, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Barrier.__init__",
        "api_description": "",
        "api_signature": "__init__(self, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Ex.__init__",
        "api_description": "",
        "api_signature": "__init__(self, bot_connect, top_connect, conditional)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ResetDisplay.__init__",
        "api_description": "",
        "api_signature": "__init__(self, conditional)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Bullet.__init__",
        "api_description": "",
        "api_signature": "__init__(self, top_connect, bot_connect, conditional, label, bottom)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "OpenBullet.__init__",
        "api_description": "",
        "api_signature": "__init__(self, top_connect, bot_connect, conditional, label, bottom)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "DirectOnClWire.__init__",
        "api_description": "",
        "api_signature": "__init__(self, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ClBullet.__init__",
        "api_description": "",
        "api_signature": "__init__(self, top_connect, bot_connect, conditional, label, bottom)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ClOpenBullet.__init__",
        "api_description": "",
        "api_signature": "__init__(self, top_connect, bot_connect, conditional, label, bottom)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "EmptyWire.__init__",
        "api_description": "",
        "api_signature": "__init__(self, wire)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "fillup_layer",
        "full_api_name": "EmptyWire.fillup_layer",
        "api_description": "Given a layer, replace the Nones in it with EmptyWire elements.\n\nArgs:\n    layer (list): The layer that contains Nones.\n    first_clbit (int): The first wire that is classic.\n\nReturns:\n    list: The new layer, with no Nones.",
        "api_signature": "fillup_layer(layer, first_clbit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BreakWire.__init__",
        "api_description": "",
        "api_signature": "__init__(self, arrow_char)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "fillup_layer",
        "full_api_name": "BreakWire.fillup_layer",
        "api_description": "Creates a layer with BreakWire elements.\n\nArgs:\n    layer_length (int): The length of the layer to create\n    arrow_char (char): The char used to create the BreakWire element.\n\nReturns:\n    list: The new layer.",
        "api_signature": "fillup_layer(layer_length, arrow_char)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "InputWire.__init__",
        "api_description": "",
        "api_signature": "__init__(self, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "fillup_layer",
        "full_api_name": "InputWire.fillup_layer",
        "api_description": "Creates a layer with InputWire elements.\n\nArgs:\n    names (list): List of names for the wires.\n\nReturns:\n    list: The new layer",
        "api_signature": "fillup_layer(names)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "TextDrawing.__init__",
        "api_description": "",
        "api_signature": "__init__(self, qubits, clbits, nodes, circuit, reverse_bits, plotbarriers, line_length, vertical_compression, initial_state, cregbundle, encoding, with_layout, expr_len)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "TextDrawing.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "_repr_html_",
        "full_api_name": "TextDrawing._repr_html_",
        "api_description": "",
        "api_signature": "_repr_html_(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "TextDrawing.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "single_string",
        "full_api_name": "TextDrawing.single_string",
        "api_description": "Creates a long string with the ascii art.\nReturns:\n    str: The lines joined by a newline (``\\n``)",
        "api_signature": "single_string(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "dump",
        "full_api_name": "TextDrawing.dump",
        "api_description": "Dumps the ascii art in the file.\n\nArgs:\n    filename (str): File to dump the ascii art.\n    encoding (str): Optional. Force encoding, instead of self.encoding.",
        "api_signature": "dump(self, filename, encoding)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "lines",
        "full_api_name": "TextDrawing.lines",
        "api_description": "Generates a list with lines. These lines form the text drawing.\n\nArgs:\n    line_length (int): Optional. Breaks the circuit drawing to this length. This is\n                       useful when the drawing does not fit in the console. If\n                       None (default), it will try to guess the console width using\n                       shutil.get_terminal_size(). If you don't want pagination\n                       at all, set line_length=-1.\n\nReturns:\n    list: A list of lines with the text drawing.",
        "api_signature": "lines(self, line_length)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "wire_names",
        "full_api_name": "TextDrawing.wire_names",
        "api_description": "Returns a list of names for each wire.\n\nArgs:\n    with_initial_state (bool): Optional (Default: False). If true, adds\n        the initial value to the name.\n\nReturns:\n    List: The list of wire names.",
        "api_signature": "wire_names(self, with_initial_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "should_compress",
        "full_api_name": "TextDrawing.should_compress",
        "api_description": "Decides if the top_line and bot_line should be merged,\nbased on `self.vertical_compression`.",
        "api_signature": "should_compress(self, top_line, bot_line)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "draw_wires",
        "full_api_name": "TextDrawing.draw_wires",
        "api_description": "Given a list of wires, creates a list of lines with the text drawing.\n\nArgs:\n    wires (list): A list of wires with nodes.\nReturns:\n    list: A list of lines with the text drawing.",
        "api_signature": "draw_wires(self, wires)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "special_label",
        "full_api_name": "TextDrawing.special_label",
        "api_description": "Some instructions have special labels",
        "api_signature": "special_label(node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "merge_lines",
        "full_api_name": "TextDrawing.merge_lines",
        "api_description": "Merges two lines (top and bot) in a way that the overlapping makes sense.\n\nArgs:\n    top (str): the top line\n    bot (str): the bottom line\n    icod (top or bot): in case of doubt, which line should have priority? Default: \"top\".\nReturns:\n    str: The merge of both lines.",
        "api_signature": "merge_lines(top, bot, icod)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "normalize_width",
        "full_api_name": "TextDrawing.normalize_width",
        "api_description": "When the elements of the layer have different widths, sets the width to the max elements.\n\nArgs:\n    layer (list): A list of elements.",
        "api_signature": "normalize_width(layer)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "controlled_wires",
        "full_api_name": "TextDrawing.controlled_wires",
        "api_description": "Analyzes the node in the layer and checks if the controlled arguments are in\nthe box or out of the box.\n\nArgs:\n    node (DAGNode): node to analyse\n    wire_map (dict): map of qubits/clbits to position\n\nReturns:\n    Tuple(list, list, list):\n      - tuple: controlled arguments on top of the \"node box\", and its status\n      - tuple: controlled arguments on bottom of the \"node box\", and its status\n      - tuple: controlled arguments in the \"node box\", and its status\n      - the rest of the arguments",
        "api_signature": "controlled_wires(node, wire_map)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "_set_ctrl_state",
        "full_api_name": "TextDrawing._set_ctrl_state",
        "api_description": "Takes the ctrl_state from node.op and appends Bullet or OpenBullet\nto gates depending on whether the bit in ctrl_state is 1 or 0. Returns gates",
        "api_signature": "_set_ctrl_state(self, node, conditional, ctrl_text, bottom)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "_node_to_gate",
        "full_api_name": "TextDrawing._node_to_gate",
        "api_description": "Convert a dag op node into its corresponding Gate object, and establish\nany connections it introduces between qubits. gate_wire_map is the flow_wire_map\nif gate is inside a ControlFlowOp, else it's self._wire_map",
        "api_signature": "_node_to_gate(self, node, layer, gate_wire_map)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "add_connected_gate",
        "full_api_name": "TextDrawing.add_connected_gate",
        "api_description": "",
        "api_signature": "add_connected_gate(node, gates, layer, current_cons, gate_wire_map)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "build_layers",
        "full_api_name": "TextDrawing.build_layers",
        "api_description": "Constructs layers.\nReturns:\n    list: List of DrawElements.\nRaises:\n    VisualizationError: When the drawing is, for some reason, impossible to be drawn.",
        "api_signature": "build_layers(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "add_control_flow",
        "full_api_name": "TextDrawing.add_control_flow",
        "api_description": "Add control flow ops to the circuit drawing.",
        "api_signature": "add_control_flow(self, node, layers, wire_map)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "draw_flow_box",
        "full_api_name": "TextDrawing.draw_flow_box",
        "api_description": "Draw the left, middle, or right of a control flow box",
        "api_signature": "draw_flow_box(self, node, flow_wire_map, section, circ_num)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Layer.__init__",
        "api_description": "",
        "api_signature": "__init__(self, qubits, clbits, cregbundle, circuit, wire_map)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "full_layer",
        "full_api_name": "Layer.full_layer",
        "api_description": "Returns the composition of qubits and classic wires.\nReturns:\n    String: self.qubit_layer + self.clbit_layer",
        "api_signature": "full_layer(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "set_qubit",
        "full_api_name": "Layer.set_qubit",
        "api_description": "Sets the qubit to the element.\n\nArgs:\n    qubit (qbit): Element of self.qubits.\n    element (DrawElement): Element to set in the qubit",
        "api_signature": "set_qubit(self, qubit, element)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "set_clbit",
        "full_api_name": "Layer.set_clbit",
        "api_description": "Sets the clbit to the element.\n\nArgs:\n    clbit (cbit): Element of self.clbits.\n    element (DrawElement): Element to set in the clbit",
        "api_signature": "set_clbit(self, clbit, element)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "_set_multibox",
        "full_api_name": "Layer._set_multibox",
        "api_description": "",
        "api_signature": "_set_multibox(self, label, qargs, cargs, top_connect, bot_connect, conditional, controlled_edge)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "set_cl_multibox",
        "full_api_name": "Layer.set_cl_multibox",
        "api_description": "Sets the multi clbit box.\n\nArgs:\n    condition (list[Union(Clbit, ClassicalRegister), int]): The condition\n    wire_map (dict): Map of bits to indices\n    top_connect (char): The char to connect the box on the top.\n\nReturns:\n    List: list of tuples of connections between clbits for multi-bit conditions",
        "api_signature": "set_cl_multibox(self, condition, wire_map, top_connect)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "set_cond_bullets",
        "full_api_name": "Layer.set_cond_bullets",
        "api_description": "Sets bullets for classical conditioning when cregbundle=False.\n\nArgs:\n    label (str): String to display below the condition\n    val_bits (list(int)): A list of bit values\n    clbits (list[Clbit]): The list of classical bits on\n        which the instruction is conditioned.\n    wire_map (dict): Map of bits to indices\n\nReturns:\n    List: list of tuples of open or closed bullets for condition bits",
        "api_signature": "set_cond_bullets(self, label, val_bits, clbits, wire_map)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "set_qu_multibox",
        "full_api_name": "Layer.set_qu_multibox",
        "api_description": "Sets the multi qubit box.\n\nArgs:\n    bits (list[int]): A list of affected bits.\n    label (string): The label for the multi qubit box.\n    top_connect (char): None or a char connector on the top\n    bot_connect (char): None or a char connector on the bottom\n    conditional (bool): If the box has a conditional\n    controlled_edge (list): A list of bit that are controlled (to draw them at the edge)\nReturn:\n    List: A list of indexes of the box.",
        "api_signature": "set_qu_multibox(self, bits, label, top_connect, bot_connect, conditional, controlled_edge)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "connect_with",
        "full_api_name": "Layer.connect_with",
        "api_description": "Connects the elements in the layer using wire_char.\n\nArgs:\n    wire_char (char): For example '\u2551' or '\u2502'.",
        "api_signature": "connect_with(self, wire_char)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "StabilizerState.__init__",
        "api_description": "Initialize a StabilizerState object.\n\nArgs:\n    data (StabilizerState or Clifford or Pauli or QuantumCircuit or\n          qiskit.circuit.Instruction):\n        Data from which the stabilizer state can be constructed.\n    validate (boolean): validate that the stabilizer state data is\n        a valid Clifford.",
        "api_signature": "__init__(self, data, validate)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/stabilizerstate.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "StabilizerState.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/stabilizerstate.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "StabilizerState.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/stabilizerstate.py"
    },
    {
        "api_name": "clifford",
        "full_api_name": "StabilizerState.clifford",
        "api_description": "Return StabilizerState Clifford data",
        "api_signature": "clifford(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/stabilizerstate.py"
    },
    {
        "api_name": "is_valid",
        "full_api_name": "StabilizerState.is_valid",
        "api_description": "Return True if a valid StabilizerState.",
        "api_signature": "is_valid(self, atol, rtol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/stabilizerstate.py"
    },
    {
        "api_name": "_add",
        "full_api_name": "StabilizerState._add",
        "api_description": "",
        "api_signature": "_add(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/stabilizerstate.py"
    },
    {
        "api_name": "_multiply",
        "full_api_name": "StabilizerState._multiply",
        "api_description": "",
        "api_signature": "_multiply(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/stabilizerstate.py"
    },
    {
        "api_name": "trace",
        "full_api_name": "StabilizerState.trace",
        "api_description": "Return the trace of the stabilizer state as a density matrix,\nwhich equals to 1, since it is always a pure state.\n\nReturns:\n    float: the trace (should equal 1).\n\nRaises:\n    QiskitError: if input is not a StabilizerState.",
        "api_signature": "trace(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/stabilizerstate.py"
    },
    {
        "api_name": "purity",
        "full_api_name": "StabilizerState.purity",
        "api_description": "Return the purity of the quantum state,\nwhich equals to 1, since it is always a pure state.\n\nReturns:\n    float: the purity (should equal 1).\n\nRaises:\n    QiskitError: if input is not a StabilizerState.",
        "api_signature": "purity(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/stabilizerstate.py"
    },
    {
        "api_name": "to_operator",
        "full_api_name": "StabilizerState.to_operator",
        "api_description": "Convert state to matrix operator class",
        "api_signature": "to_operator(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/stabilizerstate.py"
    },
    {
        "api_name": "conjugate",
        "full_api_name": "StabilizerState.conjugate",
        "api_description": "Return the conjugate of the operator.",
        "api_signature": "conjugate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/stabilizerstate.py"
    },
    {
        "api_name": "tensor",
        "full_api_name": "StabilizerState.tensor",
        "api_description": "Return the tensor product stabilizer state self \u2297 other.\n\nArgs:\n    other (StabilizerState): a stabilizer state object.\n\nReturns:\n    StabilizerState: the tensor product operator self \u2297 other.\n\nRaises:\n    QiskitError: if other is not a StabilizerState.",
        "api_signature": "tensor(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/stabilizerstate.py"
    },
    {
        "api_name": "expand",
        "full_api_name": "StabilizerState.expand",
        "api_description": "Return the tensor product stabilizer state other \u2297 self.\n\nArgs:\n    other (StabilizerState): a stabilizer state object.\n\nReturns:\n    StabilizerState: the tensor product operator other \u2297 self.\n\nRaises:\n    QiskitError: if other is not a StabilizerState.",
        "api_signature": "expand(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/stabilizerstate.py"
    },
    {
        "api_name": "evolve",
        "full_api_name": "StabilizerState.evolve",
        "api_description": "Evolve a stabilizer state by a Clifford operator.\n\nArgs:\n    other (Clifford or QuantumCircuit or qiskit.circuit.Instruction):\n        The Clifford operator to evolve by.\n    qargs (list): a list of stabilizer subsystem positions to apply the operator on.\n\nReturns:\n    StabilizerState: the output stabilizer state.\n\nRaises:\n    QiskitError: if other is not a StabilizerState.\n    QiskitError: if the operator dimension does not match the\n                 specified StabilizerState subsystem dimensions.",
        "api_signature": "evolve(self, other, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/stabilizerstate.py"
    },
    {
        "api_name": "expectation_value",
        "full_api_name": "StabilizerState.expectation_value",
        "api_description": "Compute the expectation value of a Pauli operator.\n\nArgs:\n    oper (Pauli): a Pauli operator to evaluate expval.\n    qargs (None or list): subsystems to apply the operator on.\n\nReturns:\n    complex: the expectation value (only 0 or 1 or -1 or i or -i).\n\nRaises:\n    QiskitError: if oper is not a Pauli operator.",
        "api_signature": "expectation_value(self, oper, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/stabilizerstate.py"
    },
    {
        "api_name": "equiv",
        "full_api_name": "StabilizerState.equiv",
        "api_description": "Return True if the two generating sets generate the same stabilizer group.\n\nArgs:\n    other (StabilizerState): another StabilizerState.\n\nReturns:\n    bool: True if other has a generating set that generates the same StabilizerState.",
        "api_signature": "equiv(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/stabilizerstate.py"
    },
    {
        "api_name": "probabilities",
        "full_api_name": "StabilizerState.probabilities",
        "api_description": "Return the subsystem measurement probability vector.\n\nMeasurement probabilities are with respect to measurement in the\ncomputation (diagonal) basis.\n\nArgs:\n    qargs (None or list): subsystems to return probabilities for,\n        if None return for all subsystems (Default: None).\n    decimals (None or int): the number of decimal places to round\n        values. If None no rounding is done (Default: None).\n\nReturns:\n    np.array: The Numpy vector array of probabilities.",
        "api_signature": "probabilities(self, qargs, decimals)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/stabilizerstate.py"
    },
    {
        "api_name": "probabilities_dict",
        "full_api_name": "StabilizerState.probabilities_dict",
        "api_description": "Return the subsystem measurement probability dictionary.\n\nMeasurement probabilities are with respect to measurement in the\ncomputation (diagonal) basis.\n\nThis dictionary representation uses a Ket-like notation where the\ndictionary keys are qudit strings for the subsystem basis vectors.\nIf any subsystem has a dimension greater than 10 comma delimiters are\ninserted between integers so that subsystems can be distinguished.\n\nArgs:\n    qargs (None or list): subsystems to return probabilities for,\n        if None return for all subsystems (Default: None).\n    decimals (None or int): the number of decimal places to round\n        values. If None no rounding is done (Default: None).\n\nReturns:\n    dict: The measurement probabilities in dict (ket) form.",
        "api_signature": "probabilities_dict(self, qargs, decimals)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/stabilizerstate.py"
    },
    {
        "api_name": "reset",
        "full_api_name": "StabilizerState.reset",
        "api_description": "Reset state or subsystems to the 0-state.\n\nArgs:\n    qargs (list or None): subsystems to reset, if None all\n                          subsystems will be reset to their 0-state\n                          (Default: None).\n\nReturns:\n    StabilizerState: the reset state.\n\nAdditional Information:\n    If all subsystems are reset this will return the ground state\n    on all subsystems. If only some subsystems are reset this\n    function will perform a measurement on those subsystems and\n    evolve the subsystems so that the collapsed post-measurement\n    states are rotated to the 0-state. The RNG seed for this\n    sampling can be set using the :meth:`seed` method.",
        "api_signature": "reset(self, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/stabilizerstate.py"
    },
    {
        "api_name": "measure",
        "full_api_name": "StabilizerState.measure",
        "api_description": "Measure subsystems and return outcome and post-measure state.\n\nNote that this function uses the QuantumStates internal random\nnumber generator for sampling the measurement outcome. The RNG\nseed can be set using the :meth:`seed` method.\n\nArgs:\n    qargs (list or None): subsystems to sample measurements for,\n                          if None sample measurement of all\n                          subsystems (Default: None).\n\nReturns:\n    tuple: the pair ``(outcome, state)`` where ``outcome`` is the\n           measurement outcome string label, and ``state`` is the\n           collapsed post-measurement stabilizer state for the\n           corresponding outcome.",
        "api_signature": "measure(self, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/stabilizerstate.py"
    },
    {
        "api_name": "sample_memory",
        "full_api_name": "StabilizerState.sample_memory",
        "api_description": "Sample a list of qubit measurement outcomes in the computational basis.\n\nArgs:\n    shots (int): number of samples to generate.\n    qargs (None or list): subsystems to sample measurements for,\n                        if None sample measurement of all\n                        subsystems (Default: None).\n\nReturns:\n    np.array: list of sampled counts if the order sampled.\n\nAdditional Information:\n\n    This function implements the measurement :meth:`measure` method.\n\n    The seed for random number generator used for sampling can be\n    set to a fixed value by using the stats :meth:`seed` method.",
        "api_signature": "sample_memory(self, shots, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/stabilizerstate.py"
    },
    {
        "api_name": "_measure_and_update",
        "full_api_name": "StabilizerState._measure_and_update",
        "api_description": "Measure a single qubit and return outcome and post-measure state.\n\nNote that this function uses the QuantumStates internal random\nnumber generator for sampling the measurement outcome. The RNG\nseed can be set using the :meth:`seed` method.\n\nNote that stabilizer state measurements only have three probabilities:\n(p0, p1) = (0.5, 0.5), (1, 0), or (0, 1)\nThe random case happens if there is a row anti-commuting with Z[qubit]",
        "api_signature": "_measure_and_update(self, qubit, randbit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/stabilizerstate.py"
    },
    {
        "api_name": "_phase_exponent",
        "full_api_name": "StabilizerState._phase_exponent",
        "api_description": "Exponent g of i such that Pauli(x1,z1) * Pauli(x2,z2) = i^g Pauli(x1+x2,z1+z2)",
        "api_signature": "_phase_exponent(x1, z1, x2, z2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/stabilizerstate.py"
    },
    {
        "api_name": "_rowsum",
        "full_api_name": "StabilizerState._rowsum",
        "api_description": "Aaronson-Gottesman rowsum helper function",
        "api_signature": "_rowsum(accum_pauli, accum_phase, row_pauli, row_phase)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/stabilizerstate.py"
    },
    {
        "api_name": "_rowsum_nondeterministic",
        "full_api_name": "StabilizerState._rowsum_nondeterministic",
        "api_description": "Updating StabilizerState Clifford in the\nnon-deterministic rowsum calculation.\nrow and accum are rows in the StabilizerState Clifford.",
        "api_signature": "_rowsum_nondeterministic(clifford, accum, row)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/stabilizerstate.py"
    },
    {
        "api_name": "_rowsum_deterministic",
        "full_api_name": "StabilizerState._rowsum_deterministic",
        "api_description": "Updating an auxilary Pauli aux_pauli in the\ndeterministic rowsum calculation.\nThe StabilizerState itself is not updated.",
        "api_signature": "_rowsum_deterministic(clifford, aux_pauli, row)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/stabilizerstate.py"
    },
    {
        "api_name": "_get_probablities",
        "full_api_name": "StabilizerState._get_probablities",
        "api_description": "Recursive helper function for calculating the probabilities",
        "api_signature": "_get_probablities(self, qubits, outcome, outcome_prob, probs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/stabilizerstate.py"
    },
    {
        "api_name": "partial_trace",
        "full_api_name": "partial_trace",
        "api_description": "Return reduced density matrix by tracing out part of quantum state.\n\nIf all subsystems are traced over this returns the\n:meth:`~qiskit.quantum_info.DensityMatrix.trace` of the\ninput state.\n\nArgs:\n    state (Statevector or DensityMatrix): the input state.\n    qargs (list): The subsystems to trace over.\n\nReturns:\n    DensityMatrix: The reduced density matrix.\n\nRaises:\n    QiskitError: if input state is invalid.",
        "api_signature": "partial_trace(state, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/utils.py"
    },
    {
        "api_name": "shannon_entropy",
        "full_api_name": "shannon_entropy",
        "api_description": "Compute the Shannon entropy of a probability vector.\n\nThe shannon entropy of a probability vector\n:math:`\\vec{p} = [p_0, ..., p_{n-1}]` is defined as\n\n.. math::\n\n    H(\\vec{p}) = \\sum_{i=0}^{n-1} p_i \\log_b(p_i)\n\nwhere :math:`b` is the log base and (default 2), and\n:math:`0 \\log_b(0) \\equiv 0`.\n\nArgs:\n    pvec (array_like): a probability vector.\n    base (int): the base of the logarithm [Default: 2].\n\nReturns:\n    float: The Shannon entropy H(pvec).",
        "api_signature": "shannon_entropy(pvec, base)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/utils.py"
    },
    {
        "api_name": "logfn",
        "full_api_name": "logfn",
        "api_description": "",
        "api_signature": "logfn(x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/utils.py"
    },
    {
        "api_name": "logfn",
        "full_api_name": "logfn",
        "api_description": "",
        "api_signature": "logfn(x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/utils.py"
    },
    {
        "api_name": "logfn",
        "full_api_name": "logfn",
        "api_description": "",
        "api_signature": "logfn(x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/utils.py"
    },
    {
        "api_name": "schmidt_decomposition",
        "full_api_name": "schmidt_decomposition",
        "api_description": "Return the Schmidt Decomposition of a pure quantum state.\n\nFor an arbitrary bipartite state:\n\n.. math::\n     |\\psi\\rangle_{AB} = \\sum_{i,j} c_{ij}\n                         |x_i\\rangle_A \\otimes |y_j\\rangle_B,\n\nits Schmidt Decomposition is given by the single-index sum over k:\n\n.. math::\n    |\\psi\\rangle_{AB} = \\sum_{k} \\lambda_{k}\n                        |u_k\\rangle_A \\otimes |v_k\\rangle_B\n\nwhere :math:`|u_k\\rangle_A` and :math:`|v_k\\rangle_B` are an\northonormal set of vectors in their respective spaces :math:`A` and :math:`B`,\nand the Schmidt coefficients :math:`\\lambda_k` are positive real values.\n\nArgs:\n    state (Statevector or DensityMatrix): the input state.\n    qargs (list): the list of Input state positions corresponding to subsystem :math:`B`.\n\nReturns:\n    list: list of tuples ``(s, u, v)``, where ``s`` (float) are the Schmidt coefficients\n    :math:`\\lambda_k`, and ``u`` (Statevector), ``v`` (Statevector) are the Schmidt vectors\n    :math:`|u_k\\rangle_A`, :math:`|u_k\\rangle_B`, respectively.\n\nRaises:\n    QiskitError: if Input qargs is not a list of positions of the Input state.\n    QiskitError: if Input qargs is not a proper subset of Input state.\n\n.. note::\n    In Qiskit, qubits are ordered using little-endian notation, with the least significant\n    qubits having smaller indices. For example, a four-qubit system is represented as\n    :math:`|q_3q_2q_1q_0\\rangle`. Using this convention, setting ``qargs=[0]`` will partition the\n    state as :math:`|q_3q_2q_1\\rangle_A\\otimes|q_0\\rangle_B`. Furthermore, qubits will be organized\n    in this notation regardless of the order they are passed. For instance, passing either\n    ``qargs=[1,2]`` or ``qargs=[2,1]`` will result in partitioning the state as\n    :math:`|q_3q_0\\rangle_A\\otimes|q_2q_1\\rangle_B`.",
        "api_signature": "schmidt_decomposition(state, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/utils.py"
    },
    {
        "api_name": "_format_state",
        "full_api_name": "_format_state",
        "api_description": "Format input state into class object",
        "api_signature": "_format_state(state, validate)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/utils.py"
    },
    {
        "api_name": "_funm_svd",
        "full_api_name": "_funm_svd",
        "api_description": "Apply real scalar function to singular values of a matrix.\n\nArgs:\n    matrix (array_like): (N, N) Matrix at which to evaluate the function.\n    func (callable): Callable object that evaluates a scalar function f.\n\nReturns:\n    ndarray: funm (N, N) Value of the matrix function specified by func\n             evaluated at `A`.",
        "api_signature": "_funm_svd(matrix, func)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/utils.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QuantumState.__init__",
        "api_description": "Initialize a QuantumState object.\n\nArgs:\n    op_shape (OpShape): Optional, an OpShape object for state dimensions.\n\n.. note::\n\n    If `op_shape`` is specified it will take precedence over other\n    kwargs.",
        "api_signature": "__init__(self, op_shape)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/quantum_state.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "QuantumState.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/quantum_state.py"
    },
    {
        "api_name": "dim",
        "full_api_name": "QuantumState.dim",
        "api_description": "Return total state dimension.",
        "api_signature": "dim(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/quantum_state.py"
    },
    {
        "api_name": "num_qubits",
        "full_api_name": "QuantumState.num_qubits",
        "api_description": "Return the number of qubits if a N-qubit state or None otherwise.",
        "api_signature": "num_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/quantum_state.py"
    },
    {
        "api_name": "_rng",
        "full_api_name": "QuantumState._rng",
        "api_description": "",
        "api_signature": "_rng(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/quantum_state.py"
    },
    {
        "api_name": "dims",
        "full_api_name": "QuantumState.dims",
        "api_description": "Return tuple of input dimension for specified subsystems.",
        "api_signature": "dims(self, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/quantum_state.py"
    },
    {
        "api_name": "copy",
        "full_api_name": "QuantumState.copy",
        "api_description": "Make a copy of current operator.",
        "api_signature": "copy(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/quantum_state.py"
    },
    {
        "api_name": "seed",
        "full_api_name": "QuantumState.seed",
        "api_description": "Set the seed for the quantum state RNG.",
        "api_signature": "seed(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/quantum_state.py"
    },
    {
        "api_name": "is_valid",
        "full_api_name": "QuantumState.is_valid",
        "api_description": "Return True if a valid quantum state.",
        "api_signature": "is_valid(self, atol, rtol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/quantum_state.py"
    },
    {
        "api_name": "to_operator",
        "full_api_name": "QuantumState.to_operator",
        "api_description": "Convert state to matrix operator class",
        "api_signature": "to_operator(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/quantum_state.py"
    },
    {
        "api_name": "conjugate",
        "full_api_name": "QuantumState.conjugate",
        "api_description": "Return the conjugate of the operator.",
        "api_signature": "conjugate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/quantum_state.py"
    },
    {
        "api_name": "trace",
        "full_api_name": "QuantumState.trace",
        "api_description": "Return the trace of the quantum state as a density matrix.",
        "api_signature": "trace(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/quantum_state.py"
    },
    {
        "api_name": "purity",
        "full_api_name": "QuantumState.purity",
        "api_description": "Return the purity of the quantum state.",
        "api_signature": "purity(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/quantum_state.py"
    },
    {
        "api_name": "tensor",
        "full_api_name": "QuantumState.tensor",
        "api_description": "Return the tensor product state self \u2297 other.\n\nArgs:\n    other (QuantumState): a quantum state object.\n\nReturns:\n    QuantumState: the tensor product operator self \u2297 other.\n\nRaises:\n    QiskitError: if other is not a quantum state.",
        "api_signature": "tensor(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/quantum_state.py"
    },
    {
        "api_name": "expand",
        "full_api_name": "QuantumState.expand",
        "api_description": "Return the tensor product state other \u2297 self.\n\nArgs:\n    other (QuantumState): a quantum state object.\n\nReturns:\n    QuantumState: the tensor product state other \u2297 self.\n\nRaises:\n    QiskitError: if other is not a quantum state.",
        "api_signature": "expand(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/quantum_state.py"
    },
    {
        "api_name": "_add",
        "full_api_name": "QuantumState._add",
        "api_description": "Return the linear combination self + other.\n\nArgs:\n    other (QuantumState): a state object.\n\nReturns:\n    QuantumState: the linear combination self + other.\n\nRaises:\n    NotImplementedError: if subclass does not support addition.",
        "api_signature": "_add(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/quantum_state.py"
    },
    {
        "api_name": "_multiply",
        "full_api_name": "QuantumState._multiply",
        "api_description": "Return the scalar multipled state other * self.\n\nArgs:\n    other (complex): a complex number.\n\nReturns:\n    QuantumState: the scalar multipled state other * self.\n\nRaises:\n    NotImplementedError: if subclass does not support scala\n                         multiplication.",
        "api_signature": "_multiply(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/quantum_state.py"
    },
    {
        "api_name": "evolve",
        "full_api_name": "QuantumState.evolve",
        "api_description": "Evolve a quantum state by the operator.\n\nArgs:\n    other (Operator or QuantumChannel): The operator to evolve by.\n    qargs (list): a list of QuantumState subsystem positions to apply\n                   the operator on.\n\nReturns:\n    QuantumState: the output quantum state.\n\nRaises:\n    QiskitError: if the operator dimension does not match the\n                 specified QuantumState subsystem dimensions.",
        "api_signature": "evolve(self, other, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/quantum_state.py"
    },
    {
        "api_name": "expectation_value",
        "full_api_name": "QuantumState.expectation_value",
        "api_description": "Compute the expectation value of an operator.\n\nArgs:\n    oper (BaseOperator): an operator to evaluate expval.\n    qargs (None or list): subsystems to apply the operator on.\n\nReturns:\n    complex: the expectation value.",
        "api_signature": "expectation_value(self, oper, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/quantum_state.py"
    },
    {
        "api_name": "probabilities",
        "full_api_name": "QuantumState.probabilities",
        "api_description": "Return the subsystem measurement probability vector.\n\nMeasurement probabilities are with respect to measurement in the\ncomputation (diagonal) basis.\n\nArgs:\n    qargs (None or list): subsystems to return probabilities for,\n        if None return for all subsystems (Default: None).\n    decimals (None or int): the number of decimal places to round\n        values. If None no rounding is done (Default: None).\n\nReturns:\n    np.array: The Numpy vector array of probabilities.",
        "api_signature": "probabilities(self, qargs, decimals)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/quantum_state.py"
    },
    {
        "api_name": "probabilities_dict",
        "full_api_name": "QuantumState.probabilities_dict",
        "api_description": "Return the subsystem measurement probability dictionary.\n\nMeasurement probabilities are with respect to measurement in the\ncomputation (diagonal) basis.\n\nThis dictionary representation uses a Ket-like notation where the\ndictionary keys are qudit strings for the subsystem basis vectors.\nIf any subsystem has a dimension greater than 10 comma delimiters are\ninserted between integers so that subsystems can be distinguished.\n\nArgs:\n    qargs (None or list): subsystems to return probabilities for,\n        if None return for all subsystems (Default: None).\n    decimals (None or int): the number of decimal places to round\n        values. If None no rounding is done (Default: None).\n\nReturns:\n    dict: The measurement probabilities in dict (ket) form.",
        "api_signature": "probabilities_dict(self, qargs, decimals)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/quantum_state.py"
    },
    {
        "api_name": "sample_memory",
        "full_api_name": "QuantumState.sample_memory",
        "api_description": "Sample a list of qubit measurement outcomes in the computational basis.\n\nArgs:\n    shots (int): number of samples to generate.\n    qargs (None or list): subsystems to sample measurements for,\n                        if None sample measurement of all\n                        subsystems (Default: None).\n\nReturns:\n    np.array: list of sampled counts if the order sampled.\n\nAdditional Information:\n\n    This function *samples* measurement outcomes using the measure\n    :meth:`probabilities` for the current state and `qargs`. It does\n    not actually implement the measurement so the current state is\n    not modified.\n\n    The seed for random number generator used for sampling can be\n    set to a fixed value by using the stats :meth:`seed` method.",
        "api_signature": "sample_memory(self, shots, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/quantum_state.py"
    },
    {
        "api_name": "sample_counts",
        "full_api_name": "QuantumState.sample_counts",
        "api_description": "Sample a dict of qubit measurement outcomes in the computational basis.\n\nArgs:\n    shots (int): number of samples to generate.\n    qargs (None or list): subsystems to sample measurements for,\n                        if None sample measurement of all\n                        subsystems (Default: None).\n\nReturns:\n    Counts: sampled counts dictionary.\n\nAdditional Information:\n\n    This function *samples* measurement outcomes using the measure\n    :meth:`probabilities` for the current state and `qargs`. It does\n    not actually implement the measurement so the current state is\n    not modified.\n\n    The seed for random number generator used for sampling can be\n    set to a fixed value by using the stats :meth:`seed` method.",
        "api_signature": "sample_counts(self, shots, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/quantum_state.py"
    },
    {
        "api_name": "measure",
        "full_api_name": "QuantumState.measure",
        "api_description": "Measure subsystems and return outcome and post-measure state.\n\nNote that this function uses the QuantumStates internal random\nnumber generator for sampling the measurement outcome. The RNG\nseed can be set using the :meth:`seed` method.\n\nArgs:\n    qargs (list or None): subsystems to sample measurements for,\n                          if None sample measurement of all\n                          subsystems (Default: None).\n\nReturns:\n    tuple: the pair ``(outcome, state)`` where ``outcome`` is the\n           measurement outcome string label, and ``state`` is the\n           collapsed post-measurement state for the corresponding\n           outcome.",
        "api_signature": "measure(self, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/quantum_state.py"
    },
    {
        "api_name": "_index_to_ket_array",
        "full_api_name": "QuantumState._index_to_ket_array",
        "api_description": "Convert an index array into a ket array.\n\nArgs:\n    inds (np.array): an integer index array.\n    dims (tuple): a list of subsystem dimensions.\n    string_labels (bool): return ket as string if True, otherwise\n                          return as index array (Default: False).\n\nReturns:\n    np.array: an array of ket strings if string_label=True, otherwise\n              an array of ket lists.",
        "api_signature": "_index_to_ket_array(inds, dims, string_labels)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/quantum_state.py"
    },
    {
        "api_name": "_vector_to_dict",
        "full_api_name": "QuantumState._vector_to_dict",
        "api_description": "Convert a vector to a ket dictionary.\n\nThis representation will not show zero values in the output dict.\n\nArgs:\n    vec (array): a Numpy vector array.\n    dims (tuple): subsystem dimensions.\n    decimals (None or int): number of decimal places to round to.\n                            (See Numpy.round), if None no rounding\n                            is done (Default: None).\n    string_labels (bool): return ket as string if True, otherwise\n                          return as index array (Default: False).\n\nReturns:\n    dict: the vector in dictionary `ket` form.",
        "api_signature": "_vector_to_dict(vec, dims, decimals, string_labels)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/quantum_state.py"
    },
    {
        "api_name": "_matrix_to_dict",
        "full_api_name": "QuantumState._matrix_to_dict",
        "api_description": "Convert a matrix to a ket dictionary.\n\nThis representation will not show zero values in the output dict.\n\nArgs:\n    mat (array): a Numpy matrix array.\n    dims (tuple): subsystem dimensions.\n    decimals (None or int): number of decimal places to round to.\n                            (See Numpy.round), if None no rounding\n                            is done (Default: None).\n    string_labels (bool): return ket as string if True, otherwise\n                          return as index array (Default: False).\n\nReturns:\n    dict: the matrix in dictionary `ket` form.",
        "api_signature": "_matrix_to_dict(mat, dims, decimals, string_labels)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/quantum_state.py"
    },
    {
        "api_name": "_subsystem_probabilities",
        "full_api_name": "QuantumState._subsystem_probabilities",
        "api_description": "Marginalize a probability vector according to subsystems.\n\nArgs:\n    probs (np.array): a probability vector Numpy array.\n    dims (tuple): subsystem dimensions.\n    qargs (None or list): a list of subsystems to return\n        marginalized probabilities for. If None return all\n        probabilities (Default: None).\n\nReturns:\n    np.array: the marginalized probability vector flattened\n              for the specified qargs.",
        "api_signature": "_subsystem_probabilities(probs, dims, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/quantum_state.py"
    },
    {
        "api_name": "__and__",
        "full_api_name": "QuantumState.__and__",
        "api_description": "",
        "api_signature": "__and__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/quantum_state.py"
    },
    {
        "api_name": "__xor__",
        "full_api_name": "QuantumState.__xor__",
        "api_description": "",
        "api_signature": "__xor__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/quantum_state.py"
    },
    {
        "api_name": "__mul__",
        "full_api_name": "QuantumState.__mul__",
        "api_description": "",
        "api_signature": "__mul__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/quantum_state.py"
    },
    {
        "api_name": "__truediv__",
        "full_api_name": "QuantumState.__truediv__",
        "api_description": "",
        "api_signature": "__truediv__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/quantum_state.py"
    },
    {
        "api_name": "__rmul__",
        "full_api_name": "QuantumState.__rmul__",
        "api_description": "",
        "api_signature": "__rmul__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/quantum_state.py"
    },
    {
        "api_name": "__add__",
        "full_api_name": "QuantumState.__add__",
        "api_description": "",
        "api_signature": "__add__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/quantum_state.py"
    },
    {
        "api_name": "__sub__",
        "full_api_name": "QuantumState.__sub__",
        "api_description": "",
        "api_signature": "__sub__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/quantum_state.py"
    },
    {
        "api_name": "__neg__",
        "full_api_name": "QuantumState.__neg__",
        "api_description": "",
        "api_signature": "__neg__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/quantum_state.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "DensityMatrix.__init__",
        "api_description": "Initialize a density matrix object.\n\nArgs:\n    data (np.ndarray or list or matrix_like or QuantumCircuit or\n          qiskit.circuit.Instruction):\n        A statevector, quantum instruction or an object with a ``to_operator`` or\n        ``to_matrix`` method from which the density matrix can be constructed.\n        If a vector the density matrix is constructed as the projector of that vector.\n        If a quantum instruction, the density matrix is constructed by assuming all\n        qubits are initialized in the zero state.\n    dims (int or tuple or list): Optional. The subsystem dimension\n            of the state (See additional information).\n\nRaises:\n    QiskitError: if input data is not valid.\n\nAdditional Information:\n    The ``dims`` kwarg can be None, an integer, or an iterable of\n    integers.\n\n    * ``Iterable`` -- the subsystem dimensions are the values in the list\n      with the total number of subsystems given by the length of the list.\n\n    * ``Int`` or ``None`` -- the leading dimension of the input matrix\n      specifies the total dimension of the density matrix. If it is a\n      power of two the state will be initialized as an N-qubit state.\n      If it is not a power of two the state will have a single\n      d-dimensional subsystem.",
        "api_signature": "__init__(self, data, dims)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/densitymatrix.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "DensityMatrix.__array__",
        "api_description": "",
        "api_signature": "__array__(self, dtype)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/densitymatrix.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "DensityMatrix.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/densitymatrix.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "DensityMatrix.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/densitymatrix.py"
    },
    {
        "api_name": "settings",
        "full_api_name": "DensityMatrix.settings",
        "api_description": "Return settings.",
        "api_signature": "settings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/densitymatrix.py"
    },
    {
        "api_name": "draw",
        "full_api_name": "DensityMatrix.draw",
        "api_description": "Return a visualization of the Statevector.\n\n**repr**: ASCII TextMatrix of the state's ``__repr__``.\n\n**text**: ASCII TextMatrix that can be printed in the console.\n\n**latex**: An IPython Latex object for displaying in Jupyter Notebooks.\n\n**latex_source**: Raw, uncompiled ASCII source to generate array using LaTeX.\n\n**qsphere**: Matplotlib figure, rendering of density matrix using `plot_state_qsphere()`.\n\n**hinton**: Matplotlib figure, rendering of density matrix using `plot_state_hinton()`.\n\n**bloch**: Matplotlib figure, rendering of density matrix using `plot_bloch_multivector()`.\n\nArgs:\n    output (str): Select the output method to use for drawing the\n        state. Valid choices are `repr`, `text`, `latex`, `latex_source`,\n        `qsphere`, `hinton`, or `bloch`. Default is `repr`. Default can\n        be changed by adding the line ``state_drawer = <default>`` to\n        ``~/.qiskit/settings.conf`` under ``[default]``.\n    drawer_args: Arguments to be passed directly to the relevant drawing\n        function or constructor (`TextMatrix()`, `array_to_latex()`,\n        `plot_state_qsphere()`, `plot_state_hinton()` or `plot_bloch_multivector()`).\n        See the relevant function under `qiskit.visualization` for that function's\n        documentation.\n\nReturns:\n    :class:`matplotlib.Figure` or :class:`str` or\n    :class:`TextMatrix` or :class:`IPython.display.Latex`:\n    Drawing of the Statevector.\n\nRaises:\n    ValueError: when an invalid output method is selected.",
        "api_signature": "draw(self, output)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/densitymatrix.py"
    },
    {
        "api_name": "_ipython_display_",
        "full_api_name": "DensityMatrix._ipython_display_",
        "api_description": "",
        "api_signature": "_ipython_display_(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/densitymatrix.py"
    },
    {
        "api_name": "data",
        "full_api_name": "DensityMatrix.data",
        "api_description": "Return data.",
        "api_signature": "data(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/densitymatrix.py"
    },
    {
        "api_name": "is_valid",
        "full_api_name": "DensityMatrix.is_valid",
        "api_description": "Return True if trace 1 and positive semidefinite.",
        "api_signature": "is_valid(self, atol, rtol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/densitymatrix.py"
    },
    {
        "api_name": "to_operator",
        "full_api_name": "DensityMatrix.to_operator",
        "api_description": "Convert to Operator",
        "api_signature": "to_operator(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/densitymatrix.py"
    },
    {
        "api_name": "conjugate",
        "full_api_name": "DensityMatrix.conjugate",
        "api_description": "Return the conjugate of the density matrix.",
        "api_signature": "conjugate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/densitymatrix.py"
    },
    {
        "api_name": "trace",
        "full_api_name": "DensityMatrix.trace",
        "api_description": "Return the trace of the density matrix.",
        "api_signature": "trace(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/densitymatrix.py"
    },
    {
        "api_name": "purity",
        "full_api_name": "DensityMatrix.purity",
        "api_description": "Return the purity of the quantum state.",
        "api_signature": "purity(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/densitymatrix.py"
    },
    {
        "api_name": "tensor",
        "full_api_name": "DensityMatrix.tensor",
        "api_description": "Return the tensor product state self \u2297 other.\n\nArgs:\n    other (DensityMatrix): a quantum state object.\n\nReturns:\n    DensityMatrix: the tensor product operator self \u2297 other.\n\nRaises:\n    QiskitError: if other is not a quantum state.",
        "api_signature": "tensor(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/densitymatrix.py"
    },
    {
        "api_name": "expand",
        "full_api_name": "DensityMatrix.expand",
        "api_description": "Return the tensor product state other \u2297 self.\n\nArgs:\n    other (DensityMatrix): a quantum state object.\n\nReturns:\n    DensityMatrix: the tensor product state other \u2297 self.\n\nRaises:\n    QiskitError: if other is not a quantum state.",
        "api_signature": "expand(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/densitymatrix.py"
    },
    {
        "api_name": "_add",
        "full_api_name": "DensityMatrix._add",
        "api_description": "Return the linear combination self + other.\n\nArgs:\n    other (DensityMatrix): a quantum state object.\n\nReturns:\n    DensityMatrix: the linear combination self + other.\n\nRaises:\n    QiskitError: if other is not a quantum state, or has\n                 incompatible dimensions.",
        "api_signature": "_add(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/densitymatrix.py"
    },
    {
        "api_name": "_multiply",
        "full_api_name": "DensityMatrix._multiply",
        "api_description": "Return the scalar multiplied state other * self.\n\nArgs:\n    other (complex): a complex number.\n\nReturns:\n    DensityMatrix: the scalar multiplied state other * self.\n\nRaises:\n    QiskitError: if other is not a valid complex number.",
        "api_signature": "_multiply(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/densitymatrix.py"
    },
    {
        "api_name": "evolve",
        "full_api_name": "DensityMatrix.evolve",
        "api_description": "Evolve a quantum state by an operator.\n\nArgs:\n    other (Operator or QuantumChannel\n           or Instruction or Circuit): The operator to evolve by.\n    qargs (list): a list of QuantumState subsystem positions to apply\n                   the operator on.\n\nReturns:\n    DensityMatrix: the output density matrix.\n\nRaises:\n    QiskitError: if the operator dimension does not match the\n                 specified QuantumState subsystem dimensions.",
        "api_signature": "evolve(self, other, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/densitymatrix.py"
    },
    {
        "api_name": "reverse_qargs",
        "full_api_name": "DensityMatrix.reverse_qargs",
        "api_description": "Return a DensityMatrix with reversed subsystem ordering.\n\nFor a tensor product state this is equivalent to reversing the order\nof tensor product subsystems. For a density matrix\n:math:`\\rho = \\rho_{n-1} \\otimes ... \\otimes \\rho_0`\nthe returned state will be\n:math:`\\rho_0 \\otimes ... \\otimes \\rho_{n-1}`.\n\nReturns:\n    DensityMatrix: the state with reversed subsystem order.",
        "api_signature": "reverse_qargs(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/densitymatrix.py"
    },
    {
        "api_name": "_expectation_value_pauli",
        "full_api_name": "DensityMatrix._expectation_value_pauli",
        "api_description": "Compute the expectation value of a Pauli.\n\nArgs:\n    pauli (Pauli): a Pauli operator to evaluate expval of.\n    qargs (None or list): subsystems to apply operator on.\n\nReturns:\n    complex: the expectation value.",
        "api_signature": "_expectation_value_pauli(self, pauli, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/densitymatrix.py"
    },
    {
        "api_name": "expectation_value",
        "full_api_name": "DensityMatrix.expectation_value",
        "api_description": "Compute the expectation value of an operator.\n\nArgs:\n    oper (Operator): an operator to evaluate expval.\n    qargs (None or list): subsystems to apply the operator on.\n\nReturns:\n    complex: the expectation value.",
        "api_signature": "expectation_value(self, oper, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/densitymatrix.py"
    },
    {
        "api_name": "probabilities",
        "full_api_name": "DensityMatrix.probabilities",
        "api_description": "Return the subsystem measurement probability vector.\n\nMeasurement probabilities are with respect to measurement in the\ncomputation (diagonal) basis.\n\nArgs:\n    qargs (None or list): subsystems to return probabilities for,\n        if None return for all subsystems (Default: None).\n    decimals (None or int): the number of decimal places to round\n        values. If None no rounding is done (Default: None).\n\nReturns:\n    np.array: The Numpy vector array of probabilities.\n\nExamples:\n\n    Consider a 2-qubit product state :math:`\\rho=\\rho_1\\otimes\\rho_0`\n    with :math:`\\rho_1=|+\\rangle\\!\\langle+|`,\n    :math:`\\rho_0=|0\\rangle\\!\\langle0|`.\n\n    .. code-block::\n\n        from qiskit.quantum_info import DensityMatrix\n\n        rho = DensityMatrix.from_label('+0')\n\n        # Probabilities for measuring both qubits\n        probs = rho.probabilities()\n        print('probs: {}'.format(probs))\n\n        # Probabilities for measuring only qubit-0\n        probs_qubit_0 = rho.probabilities([0])\n        print('Qubit-0 probs: {}'.format(probs_qubit_0))\n\n        # Probabilities for measuring only qubit-1\n        probs_qubit_1 = rho.probabilities([1])\n        print('Qubit-1 probs: {}'.format(probs_qubit_1))\n\n    .. parsed-literal::\n\n        probs: [0.5 0.  0.5 0. ]\n        Qubit-0 probs: [1. 0.]\n        Qubit-1 probs: [0.5 0.5]\n\n    We can also permute the order of qubits in the ``qargs`` list\n    to change the qubit position in the probabilities output\n\n    .. code-block::\n\n        from qiskit.quantum_info import DensityMatrix\n\n        rho = DensityMatrix.from_label('+0')\n\n        # Probabilities for measuring both qubits\n        probs = rho.probabilities([0, 1])\n        print('probs: {}'.format(probs))\n\n        # Probabilities for measuring both qubits\n        # but swapping qubits 0 and 1 in output\n        probs_swapped = rho.probabilities([1, 0])\n        print('Swapped probs: {}'.format(probs_swapped))\n\n    .. parsed-literal::\n\n        probs: [0.5 0.  0.5 0. ]\n        Swapped probs: [0.5 0.5 0.  0. ]",
        "api_signature": "probabilities(self, qargs, decimals)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/densitymatrix.py"
    },
    {
        "api_name": "reset",
        "full_api_name": "DensityMatrix.reset",
        "api_description": "Reset state or subsystems to the 0-state.\n\nArgs:\n    qargs (list or None): subsystems to reset, if None all\n                          subsystems will be reset to their 0-state\n                          (Default: None).\n\nReturns:\n    DensityMatrix: the reset state.\n\nAdditional Information:\n    If all subsystems are reset this will return the ground state\n    on all subsystems. If only a some subsystems are reset this\n    function will perform evolution by the reset\n    :class:`~qiskit.quantum_info.SuperOp` of the reset subsystems.",
        "api_signature": "reset(self, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/densitymatrix.py"
    },
    {
        "api_name": "from_label",
        "full_api_name": "DensityMatrix.from_label",
        "api_description": "Return a tensor product of Pauli X,Y,Z eigenstates.\n\n.. list-table:: Single-qubit state labels\n   :header-rows: 1\n\n   * - Label\n     - Statevector\n   * - ``\"0\"``\n     - :math:`\\begin{pmatrix} 1 & 0 \\\\ 0 & 0 \\end{pmatrix}`\n   * - ``\"1\"``\n     - :math:`\\begin{pmatrix} 0 & 0 \\\\ 0 & 1 \\end{pmatrix}`\n   * - ``\"+\"``\n     - :math:`\\frac{1}{2}\\begin{pmatrix} 1 & 1 \\\\ 1 & 1 \\end{pmatrix}`\n   * - ``\"-\"``\n     - :math:`\\frac{1}{2}\\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix}`\n   * - ``\"r\"``\n     - :math:`\\frac{1}{2}\\begin{pmatrix} 1 & -i \\\\ i & 1 \\end{pmatrix}`\n   * - ``\"l\"``\n     - :math:`\\frac{1}{2}\\begin{pmatrix} 1 & i \\\\ -i & 1 \\end{pmatrix}`\n\nArgs:\n    label (string): a eigenstate string ket label (see table for\n                    allowed values).\n\nReturns:\n    DensityMatrix: The N-qubit basis state density matrix.\n\nRaises:\n    QiskitError: if the label contains invalid characters, or the length\n                 of the label is larger than an explicitly specified num_qubits.",
        "api_signature": "from_label(cls, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/densitymatrix.py"
    },
    {
        "api_name": "from_int",
        "full_api_name": "DensityMatrix.from_int",
        "api_description": "Return a computational basis state density matrix.\n\nArgs:\n    i (int): the basis state element.\n    dims (int or tuple or list): The subsystem dimensions of the statevector\n                                 (See additional information).\n\nReturns:\n    DensityMatrix: The computational basis state :math:`|i\\rangle\\!\\langle i|`.\n\nAdditional Information:\n    The ``dims`` kwarg can be an integer or an iterable of integers.\n\n    * ``Iterable`` -- the subsystem dimensions are the values in the list\n      with the total number of subsystems given by the length of the list.\n\n    * ``Int`` -- the integer specifies the total dimension of the\n      state. If it is a power of two the state will be initialized\n      as an N-qubit state. If it is not a power of  two the state\n      will have a single d-dimensional subsystem.",
        "api_signature": "from_int(i, dims)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/densitymatrix.py"
    },
    {
        "api_name": "from_instruction",
        "full_api_name": "DensityMatrix.from_instruction",
        "api_description": "Return the output density matrix of an instruction.\n\nThe statevector is initialized in the state :math:`|{0,\\ldots,0}\\rangle` of\nthe same number of qubits as the input instruction or circuit, evolved\nby the input instruction, and the output statevector returned.\n\nArgs:\n    instruction (qiskit.circuit.Instruction or QuantumCircuit): instruction or circuit\n\nReturns:\n    DensityMatrix: the final density matrix.\n\nRaises:\n    QiskitError: if the instruction contains invalid instructions for\n                 density matrix simulation.",
        "api_signature": "from_instruction(cls, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/densitymatrix.py"
    },
    {
        "api_name": "to_dict",
        "full_api_name": "DensityMatrix.to_dict",
        "api_description": "Convert the density matrix to dictionary form.\n\nThis dictionary representation uses a Ket-like notation where the\ndictionary keys are qudit strings for the subsystem basis vectors.\nIf any subsystem has a dimension greater than 10 comma delimiters are\ninserted between integers so that subsystems can be distinguished.\n\nArgs:\n    decimals (None or int): the number of decimal places to round\n                            values. If None no rounding is done\n                            (Default: None).\n\nReturns:\n    dict: the dictionary form of the DensityMatrix.\n\nExamples:\n\n    The ket-form of a 2-qubit density matrix\n    :math:`rho = |-\\rangle\\!\\langle -|\\otimes |0\\rangle\\!\\langle 0|`\n\n    .. code-block::\n\n        from qiskit.quantum_info import DensityMatrix\n\n        rho = DensityMatrix.from_label('-0')\n        print(rho.to_dict())\n\n    .. parsed-literal::\n\n       {\n           '00|00': (0.4999999999999999+0j),\n           '10|00': (-0.4999999999999999-0j),\n           '00|10': (-0.4999999999999999+0j),\n           '10|10': (0.4999999999999999+0j)\n       }\n\n    For non-qubit subsystems the integer range can go from 0 to 9. For\n    example in a qutrit system\n\n    .. code-block::\n\n        import numpy as np\n        from qiskit.quantum_info import DensityMatrix\n\n        mat = np.zeros((9, 9))\n        mat[0, 0] = 0.25\n        mat[3, 3] = 0.25\n        mat[6, 6] = 0.25\n        mat[-1, -1] = 0.25\n        rho = DensityMatrix(mat, dims=(3, 3))\n        print(rho.to_dict())\n\n    .. parsed-literal::\n\n        {'00|00': (0.25+0j), '10|10': (0.25+0j), '20|20': (0.25+0j), '22|22': (0.25+0j)}\n\n    For large subsystem dimensions delimiters are required. The\n    following example is for a 20-dimensional system consisting of\n    a qubit and 10-dimensional qudit.\n\n    .. code-block::\n\n        import numpy as np\n        from qiskit.quantum_info import DensityMatrix\n\n        mat = np.zeros((2 * 10, 2 * 10))\n        mat[0, 0] = 0.5\n        mat[-1, -1] = 0.5\n        rho = DensityMatrix(mat, dims=(2, 10))\n        print(rho.to_dict())\n\n    .. parsed-literal::\n\n        {'00|00': (0.5+0j), '91|91': (0.5+0j)}",
        "api_signature": "to_dict(self, decimals)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/densitymatrix.py"
    },
    {
        "api_name": "_evolve_operator",
        "full_api_name": "DensityMatrix._evolve_operator",
        "api_description": "Evolve density matrix by an operator",
        "api_signature": "_evolve_operator(self, other, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/densitymatrix.py"
    },
    {
        "api_name": "_append_instruction",
        "full_api_name": "DensityMatrix._append_instruction",
        "api_description": "Update the current Statevector by applying an instruction.",
        "api_signature": "_append_instruction(self, other, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/densitymatrix.py"
    },
    {
        "api_name": "_evolve_instruction",
        "full_api_name": "DensityMatrix._evolve_instruction",
        "api_description": "Return a new statevector by applying an instruction.",
        "api_signature": "_evolve_instruction(self, obj, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/densitymatrix.py"
    },
    {
        "api_name": "to_statevector",
        "full_api_name": "DensityMatrix.to_statevector",
        "api_description": "Return a statevector from a pure density matrix.\n\nArgs:\n    atol (float): Absolute tolerance for checking operation validity.\n    rtol (float): Relative tolerance for checking operation validity.\n\nReturns:\n    Statevector: The pure density matrix's corresponding statevector.\n        Corresponds to the eigenvector of the only non-zero eigenvalue.\n\nRaises:\n    QiskitError: if the state is not pure.",
        "api_signature": "to_statevector(self, atol, rtol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/densitymatrix.py"
    },
    {
        "api_name": "partial_transpose",
        "full_api_name": "DensityMatrix.partial_transpose",
        "api_description": "Return partially transposed density matrix.\n\nArgs:\n    qargs (list): The subsystems to be transposed.\n\nReturns:\n    DensityMatrix: The partially transposed density matrix.",
        "api_signature": "partial_transpose(self, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/densitymatrix.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Statevector.__init__",
        "api_description": "Initialize a statevector object.\n\nArgs:\n    data (np.array or list or Statevector or Operator or QuantumCircuit or\n          qiskit.circuit.Instruction):\n        Data from which the statevector can be constructed. This can be either a complex\n        vector, another statevector, a ``Operator`` with only one column or a\n        ``QuantumCircuit`` or ``Instruction``.  If the data is a circuit or instruction,\n        the statevector is constructed by assuming that all qubits are initialized to the\n        zero state.\n    dims (int or tuple or list): Optional. The subsystem dimension of\n                                 the state (See additional information).\n\nRaises:\n    QiskitError: if input data is not valid.\n\nAdditional Information:\n    The ``dims`` kwarg can be None, an integer, or an iterable of\n    integers.\n\n    * ``Iterable`` -- the subsystem dimensions are the values in the list\n      with the total number of subsystems given by the length of the list.\n\n    * ``Int`` or ``None`` -- the length of the input vector\n      specifies the total dimension of the density matrix. If it is a\n      power of two the state will be initialized as an N-qubit state.\n      If it is not a power of two the state will have a single\n      d-dimensional subsystem.",
        "api_signature": "__init__(self, data, dims)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/statevector.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "Statevector.__array__",
        "api_description": "",
        "api_signature": "__array__(self, dtype)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/statevector.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "Statevector.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/statevector.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "Statevector.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/statevector.py"
    },
    {
        "api_name": "settings",
        "full_api_name": "Statevector.settings",
        "api_description": "Return settings.",
        "api_signature": "settings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/statevector.py"
    },
    {
        "api_name": "draw",
        "full_api_name": "Statevector.draw",
        "api_description": "Return a visualization of the Statevector.\n\n**repr**: ASCII TextMatrix of the state's ``__repr__``.\n\n**text**: ASCII TextMatrix that can be printed in the console.\n\n**latex**: An IPython Latex object for displaying in Jupyter Notebooks.\n\n**latex_source**: Raw, uncompiled ASCII source to generate array using LaTeX.\n\n**qsphere**: Matplotlib figure, rendering of statevector using `plot_state_qsphere()`.\n\n**hinton**: Matplotlib figure, rendering of statevector using `plot_state_hinton()`.\n\n**bloch**: Matplotlib figure, rendering of statevector using `plot_bloch_multivector()`.\n\n**city**: Matplotlib figure, rendering of statevector using `plot_state_city()`.\n\n**paulivec**: Matplotlib figure, rendering of statevector using `plot_state_paulivec()`.\n\nArgs:\n    output (str): Select the output method to use for drawing the\n        state. Valid choices are `repr`, `text`, `latex`, `latex_source`,\n        `qsphere`, `hinton`, `bloch`, `city`, or `paulivec`. Default is `repr`.\n        Default can be changed by adding the line ``state_drawer = <default>`` to\n        ``~/.qiskit/settings.conf`` under ``[default]``.\n    drawer_args: Arguments to be passed directly to the relevant drawing\n        function or constructor (`TextMatrix()`, `array_to_latex()`,\n        `plot_state_qsphere()`, `plot_state_hinton()` or `plot_bloch_multivector()`).\n        See the relevant function under `qiskit.visualization` for that function's\n        documentation.\n\nReturns:\n    :class:`matplotlib.Figure` or :class:`str` or\n    :class:`TextMatrix` or :class:`IPython.display.Latex`:\n    Drawing of the Statevector.\n\nRaises:\n    ValueError: when an invalid output method is selected.\n\nExamples:\n\n    Plot one of the Bell states\n\n    .. plot::\n       :include-source:\n\n        from numpy import sqrt\n        from qiskit.quantum_info import Statevector\n        sv=Statevector([1/sqrt(2), 0, 0, -1/sqrt(2)])\n        sv.draw(output='hinton')",
        "api_signature": "draw(self, output)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/statevector.py"
    },
    {
        "api_name": "_ipython_display_",
        "full_api_name": "Statevector._ipython_display_",
        "api_description": "",
        "api_signature": "_ipython_display_(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/statevector.py"
    },
    {
        "api_name": "__getitem__",
        "full_api_name": "Statevector.__getitem__",
        "api_description": "Return Statevector item either by index or binary label\nArgs:\n    key (int or str): index or corresponding binary label, e.g. '01' = 1.\n\nReturns:\n    numpy.complex128: Statevector item.\n\nRaises:\n    QiskitError: if key is not valid.",
        "api_signature": "__getitem__(self, key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/statevector.py"
    },
    {
        "api_name": "__iter__",
        "full_api_name": "Statevector.__iter__",
        "api_description": "",
        "api_signature": "__iter__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/statevector.py"
    },
    {
        "api_name": "__len__",
        "full_api_name": "Statevector.__len__",
        "api_description": "",
        "api_signature": "__len__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/statevector.py"
    },
    {
        "api_name": "data",
        "full_api_name": "Statevector.data",
        "api_description": "Return data.",
        "api_signature": "data(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/statevector.py"
    },
    {
        "api_name": "is_valid",
        "full_api_name": "Statevector.is_valid",
        "api_description": "Return True if a Statevector has norm 1.",
        "api_signature": "is_valid(self, atol, rtol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/statevector.py"
    },
    {
        "api_name": "to_operator",
        "full_api_name": "Statevector.to_operator",
        "api_description": "Convert state to a rank-1 projector operator",
        "api_signature": "to_operator(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/statevector.py"
    },
    {
        "api_name": "conjugate",
        "full_api_name": "Statevector.conjugate",
        "api_description": "Return the conjugate of the operator.",
        "api_signature": "conjugate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/statevector.py"
    },
    {
        "api_name": "trace",
        "full_api_name": "Statevector.trace",
        "api_description": "Return the trace of the quantum state as a density matrix.",
        "api_signature": "trace(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/statevector.py"
    },
    {
        "api_name": "purity",
        "full_api_name": "Statevector.purity",
        "api_description": "Return the purity of the quantum state.",
        "api_signature": "purity(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/statevector.py"
    },
    {
        "api_name": "tensor",
        "full_api_name": "Statevector.tensor",
        "api_description": "Return the tensor product state self \u2297 other.\n\nArgs:\n    other (Statevector): a quantum state object.\n\nReturns:\n    Statevector: the tensor product operator self \u2297 other.\n\nRaises:\n    QiskitError: if other is not a quantum state.",
        "api_signature": "tensor(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/statevector.py"
    },
    {
        "api_name": "inner",
        "full_api_name": "Statevector.inner",
        "api_description": "Return the inner product of self and other as\n:math:`\\langle self| other \\rangle`.\n\nArgs:\n    other (Statevector): a quantum state object.\n\nReturns:\n    np.complex128: the inner product of self and other, :math:`\\langle self| other \\rangle`.\n\nRaises:\n    QiskitError: if other is not a quantum state or has different dimension.",
        "api_signature": "inner(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/statevector.py"
    },
    {
        "api_name": "expand",
        "full_api_name": "Statevector.expand",
        "api_description": "Return the tensor product state other \u2297 self.\n\nArgs:\n    other (Statevector): a quantum state object.\n\nReturns:\n    Statevector: the tensor product state other \u2297 self.\n\nRaises:\n    QiskitError: if other is not a quantum state.",
        "api_signature": "expand(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/statevector.py"
    },
    {
        "api_name": "_add",
        "full_api_name": "Statevector._add",
        "api_description": "Return the linear combination self + other.\n\nArgs:\n    other (Statevector): a quantum state object.\n\nReturns:\n    Statevector: the linear combination self + other.\n\nRaises:\n    QiskitError: if other is not a quantum state, or has\n                 incompatible dimensions.",
        "api_signature": "_add(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/statevector.py"
    },
    {
        "api_name": "_multiply",
        "full_api_name": "Statevector._multiply",
        "api_description": "Return the scalar multiplied state self * other.\n\nArgs:\n    other (complex): a complex number.\n\nReturns:\n    Statevector: the scalar multiplied state other * self.\n\nRaises:\n    QiskitError: if other is not a valid complex number.",
        "api_signature": "_multiply(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/statevector.py"
    },
    {
        "api_name": "evolve",
        "full_api_name": "Statevector.evolve",
        "api_description": "Evolve a quantum state by the operator.\n\nArgs:\n    other (Operator | QuantumCircuit | circuit.Instruction): The operator to evolve by.\n    qargs (list): a list of Statevector subsystem positions to apply\n                   the operator on.\n\nReturns:\n    Statevector: the output quantum state.\n\nRaises:\n    QiskitError: if the operator dimension does not match the\n                 specified Statevector subsystem dimensions.",
        "api_signature": "evolve(self, other, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/statevector.py"
    },
    {
        "api_name": "equiv",
        "full_api_name": "Statevector.equiv",
        "api_description": "Return True if other is equivalent as a statevector up to global phase.\n\n.. note::\n\n    If other is not a Statevector, but can be used to initialize a statevector object,\n    this will check that Statevector(other) is equivalent to the current statevector up\n    to global phase.\n\nArgs:\n    other (Statevector): an object from which a ``Statevector`` can be constructed.\n    rtol (float): relative tolerance value for comparison.\n    atol (float): absolute tolerance value for comparison.\n\nReturns:\n    bool: True if statevectors are equivalent up to global phase.",
        "api_signature": "equiv(self, other, rtol, atol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/statevector.py"
    },
    {
        "api_name": "reverse_qargs",
        "full_api_name": "Statevector.reverse_qargs",
        "api_description": "Return a Statevector with reversed subsystem ordering.\n\nFor a tensor product state this is equivalent to reversing the order\nof tensor product subsystems. For a statevector\n:math:`|\\psi \\rangle = |\\psi_{n-1} \\rangle \\otimes ... \\otimes |\\psi_0 \\rangle`\nthe returned statevector will be\n:math:`|\\psi_{0} \\rangle \\otimes ... \\otimes |\\psi_{n-1} \\rangle`.\n\nReturns:\n    Statevector: the Statevector with reversed subsystem order.",
        "api_signature": "reverse_qargs(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/statevector.py"
    },
    {
        "api_name": "_expectation_value_pauli",
        "full_api_name": "Statevector._expectation_value_pauli",
        "api_description": "Compute the expectation value of a Pauli.\n\nArgs:\n    pauli (Pauli): a Pauli operator to evaluate expval of.\n    qargs (None or list): subsystems to apply operator on.\n\nReturns:\n    complex: the expectation value.",
        "api_signature": "_expectation_value_pauli(self, pauli, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/statevector.py"
    },
    {
        "api_name": "expectation_value",
        "full_api_name": "Statevector.expectation_value",
        "api_description": "Compute the expectation value of an operator.\n\nArgs:\n    oper (Operator): an operator to evaluate expval of.\n    qargs (None or list): subsystems to apply operator on.\n\nReturns:\n    complex: the expectation value.",
        "api_signature": "expectation_value(self, oper, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/statevector.py"
    },
    {
        "api_name": "probabilities",
        "full_api_name": "Statevector.probabilities",
        "api_description": "Return the subsystem measurement probability vector.\n\nMeasurement probabilities are with respect to measurement in the\ncomputation (diagonal) basis.\n\nArgs:\n    qargs (None or list): subsystems to return probabilities for,\n        if None return for all subsystems (Default: None).\n    decimals (None or int): the number of decimal places to round\n        values. If None no rounding is done (Default: None).\n\nReturns:\n    np.array: The Numpy vector array of probabilities.\n\nExamples:\n\n    Consider a 2-qubit product state\n    :math:`|\\psi\\rangle=|+\\rangle\\otimes|0\\rangle`.\n\n    .. code-block::\n\n        from qiskit.quantum_info import Statevector\n\n        psi = Statevector.from_label('+0')\n\n        # Probabilities for measuring both qubits\n        probs = psi.probabilities()\n        print('probs: {}'.format(probs))\n\n        # Probabilities for measuring only qubit-0\n        probs_qubit_0 = psi.probabilities([0])\n        print('Qubit-0 probs: {}'.format(probs_qubit_0))\n\n        # Probabilities for measuring only qubit-1\n        probs_qubit_1 = psi.probabilities([1])\n        print('Qubit-1 probs: {}'.format(probs_qubit_1))\n\n    .. parsed-literal::\n\n        probs: [0.5 0.  0.5 0. ]\n        Qubit-0 probs: [1. 0.]\n        Qubit-1 probs: [0.5 0.5]\n\n    We can also permute the order of qubits in the ``qargs`` list\n    to change the qubit position in the probabilities output\n\n    .. code-block::\n\n        from qiskit.quantum_info import Statevector\n\n        psi = Statevector.from_label('+0')\n\n        # Probabilities for measuring both qubits\n        probs = psi.probabilities([0, 1])\n        print('probs: {}'.format(probs))\n\n        # Probabilities for measuring both qubits\n        # but swapping qubits 0 and 1 in output\n        probs_swapped = psi.probabilities([1, 0])\n        print('Swapped probs: {}'.format(probs_swapped))\n\n    .. parsed-literal::\n\n        probs: [0.5 0.  0.5 0. ]\n        Swapped probs: [0.5 0.5 0.  0. ]",
        "api_signature": "probabilities(self, qargs, decimals)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/statevector.py"
    },
    {
        "api_name": "reset",
        "full_api_name": "Statevector.reset",
        "api_description": "Reset state or subsystems to the 0-state.\n\nArgs:\n    qargs (list or None): subsystems to reset, if None all\n                          subsystems will be reset to their 0-state\n                          (Default: None).\n\nReturns:\n    Statevector: the reset state.\n\nAdditional Information:\n    If all subsystems are reset this will return the ground state\n    on all subsystems. If only a some subsystems are reset this\n    function will perform a measurement on those subsystems and\n    evolve the subsystems so that the collapsed post-measurement\n    states are rotated to the 0-state. The RNG seed for this\n    sampling can be set using the :meth:`seed` method.",
        "api_signature": "reset(self, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/statevector.py"
    },
    {
        "api_name": "from_label",
        "full_api_name": "Statevector.from_label",
        "api_description": "Return a tensor product of Pauli X,Y,Z eigenstates.\n\n.. list-table:: Single-qubit state labels\n   :header-rows: 1\n\n   * - Label\n     - Statevector\n   * - ``\"0\"``\n     - :math:`[1, 0]`\n   * - ``\"1\"``\n     - :math:`[0, 1]`\n   * - ``\"+\"``\n     - :math:`[1 / \\sqrt{2},  1 / \\sqrt{2}]`\n   * - ``\"-\"``\n     - :math:`[1 / \\sqrt{2},  -1 / \\sqrt{2}]`\n   * - ``\"r\"``\n     - :math:`[1 / \\sqrt{2},  i / \\sqrt{2}]`\n   * - ``\"l\"``\n     - :math:`[1 / \\sqrt{2},  -i / \\sqrt{2}]`\n\nArgs:\n    label (string): a eigenstate string ket label (see table for\n                    allowed values).\n\nReturns:\n    Statevector: The N-qubit basis state density matrix.\n\nRaises:\n    QiskitError: if the label contains invalid characters, or the\n                 length of the label is larger than an explicitly\n                 specified num_qubits.",
        "api_signature": "from_label(cls, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/statevector.py"
    },
    {
        "api_name": "from_int",
        "full_api_name": "Statevector.from_int",
        "api_description": "Return a computational basis statevector.\n\nArgs:\n    i (int): the basis state element.\n    dims (int or tuple or list): The subsystem dimensions of the statevector\n                                 (See additional information).\n\nReturns:\n    Statevector: The computational basis state :math:`|i\\rangle`.\n\nAdditional Information:\n    The ``dims`` kwarg can be an integer or an iterable of integers.\n\n    * ``Iterable`` -- the subsystem dimensions are the values in the list\n      with the total number of subsystems given by the length of the list.\n\n    * ``Int`` -- the integer specifies the total dimension of the\n      state. If it is a power of two the state will be initialized\n      as an N-qubit state. If it is not a power of  two the state\n      will have a single d-dimensional subsystem.",
        "api_signature": "from_int(i, dims)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/statevector.py"
    },
    {
        "api_name": "from_instruction",
        "full_api_name": "Statevector.from_instruction",
        "api_description": "Return the output statevector of an instruction.\n\nThe statevector is initialized in the state :math:`|{0,\\ldots,0}\\rangle` of the\nsame number of qubits as the input instruction or circuit, evolved\nby the input instruction, and the output statevector returned.\n\nArgs:\n    instruction (qiskit.circuit.Instruction or QuantumCircuit): instruction or circuit\n\nReturns:\n    Statevector: The final statevector.\n\nRaises:\n    QiskitError: if the instruction contains invalid instructions for\n                 the statevector simulation.",
        "api_signature": "from_instruction(cls, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/statevector.py"
    },
    {
        "api_name": "to_dict",
        "full_api_name": "Statevector.to_dict",
        "api_description": "Convert the statevector to dictionary form.\n\nThis dictionary representation uses a Ket-like notation where the\ndictionary keys are qudit strings for the subsystem basis vectors.\nIf any subsystem has a dimension greater than 10 comma delimiters are\ninserted between integers so that subsystems can be distinguished.\n\nArgs:\n    decimals (None or int): the number of decimal places to round\n                            values. If None no rounding is done\n                            (Default: None).\n\nReturns:\n    dict: the dictionary form of the Statevector.\n\nExample:\n\n    The ket-form of a 2-qubit statevector\n    :math:`|\\psi\\rangle = |-\\rangle\\otimes |0\\rangle`\n\n    .. code-block::\n\n        from qiskit.quantum_info import Statevector\n\n        psi = Statevector.from_label('-0')\n        print(psi.to_dict())\n\n    .. parsed-literal::\n\n        {'00': (0.7071067811865475+0j), '10': (-0.7071067811865475+0j)}\n\n    For non-qubit subsystems the integer range can go from 0 to 9. For\n    example in a qutrit system\n\n    .. code-block::\n\n        import numpy as np\n        from qiskit.quantum_info import Statevector\n\n        vec = np.zeros(9)\n        vec[0] = 1 / np.sqrt(2)\n        vec[-1] = 1 / np.sqrt(2)\n        psi = Statevector(vec, dims=(3, 3))\n        print(psi.to_dict())\n\n    .. parsed-literal::\n\n        {'00': (0.7071067811865475+0j), '22': (0.7071067811865475+0j)}\n\n    For large subsystem dimensions delimiters are required. The\n    following example is for a 20-dimensional system consisting of\n    a qubit and 10-dimensional qudit.\n\n    .. code-block::\n\n        import numpy as np\n        from qiskit.quantum_info import Statevector\n\n        vec = np.zeros(2 * 10)\n        vec[0] = 1 / np.sqrt(2)\n        vec[-1] = 1 / np.sqrt(2)\n        psi = Statevector(vec, dims=(2, 10))\n        print(psi.to_dict())\n\n    .. parsed-literal::\n\n        {'00': (0.7071067811865475+0j), '91': (0.7071067811865475+0j)}",
        "api_signature": "to_dict(self, decimals)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/statevector.py"
    },
    {
        "api_name": "_evolve_operator",
        "full_api_name": "Statevector._evolve_operator",
        "api_description": "Evolve a qudit statevector",
        "api_signature": "_evolve_operator(statevec, oper, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/statevector.py"
    },
    {
        "api_name": "_evolve_instruction",
        "full_api_name": "Statevector._evolve_instruction",
        "api_description": "Update the current Statevector by applying an instruction.",
        "api_signature": "_evolve_instruction(statevec, obj, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/statevector.py"
    },
    {
        "api_name": "random_statevector",
        "full_api_name": "random_statevector",
        "api_description": "Generator a random Statevector.\n\nThe statevector is sampled from the uniform distribution. This is the measure\ninduced by the Haar measure on unitary matrices.\n\nArgs:\n    dims (int or tuple): the dimensions of the state.\n    seed (int or np.random.Generator): Optional. Set a fixed seed or\n                                       generator for RNG.\n\nReturns:\n    Statevector: the random statevector.\n\nReference:\n    K. Zyczkowski and H. Sommers (2001), \"Induced measures in the space of mixed quantum states\",\n    `J. Phys. A: Math. Gen. 34 7111 <https://arxiv.org/abs/quant-ph/0012101>`__.",
        "api_signature": "random_statevector(dims, seed)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/random.py"
    },
    {
        "api_name": "random_density_matrix",
        "full_api_name": "random_density_matrix",
        "api_description": "Generator a random DensityMatrix.\n\nArgs:\n    dims (int or tuple): the dimensions of the DensityMatrix.\n    rank (int or None): Optional, the rank of the density matrix.\n                        The default value is full-rank.\n    method (string): Optional. The method to use.\n        'Hilbert-Schmidt': (Default) sample from the Hilbert-Schmidt metric.\n        'Bures': sample from the Bures metric.\n    seed (int or np.random.Generator): Optional. Set a fixed seed or\n                                       generator for RNG.\n\nReturns:\n    DensityMatrix: the random density matrix.\n\nRaises:\n    QiskitError: if the method is not valid.",
        "api_signature": "random_density_matrix(dims, rank, method, seed)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/random.py"
    },
    {
        "api_name": "_ginibre_matrix",
        "full_api_name": "_ginibre_matrix",
        "api_description": "Return a normally distributed complex random matrix.\n\nArgs:\n    nrow (int): number of rows in output matrix.\n    ncol (int): number of columns in output matrix.\n    seed(int or np.random.Generator): default rng.\n\nReturns:\n    ndarray: A complex rectangular matrix where each real and imaginary\n        entry is sampled from the normal distribution.",
        "api_signature": "_ginibre_matrix(nrow, ncol, seed)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/random.py"
    },
    {
        "api_name": "_random_density_hs",
        "full_api_name": "_random_density_hs",
        "api_description": "Generate a random density matrix from the Hilbert-Schmidt metric.\n\nArgs:\n    dim (int): the dimensions of the density matrix.\n    rank (int or None): the rank of the density matrix. The default\n        value is full-rank.\n    seed (int or np.random.Generator): default rng.\n\nReturns:\n    ndarray: rho (N,N)  a density matrix.",
        "api_signature": "_random_density_hs(dim, rank, seed)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/random.py"
    },
    {
        "api_name": "_random_density_bures",
        "full_api_name": "_random_density_bures",
        "api_description": "Generate a random density matrix from the Bures metric.\n\nArgs:\n    dim (int): the length of the density matrix.\n    rank (int or None): the rank of the density matrix. The default\n        value is full-rank.\n    seed (int or np.random.Generator): default rng.\n\nReturns:\n    ndarray: rho (N,N) a density matrix.",
        "api_signature": "_random_density_bures(dim, rank, seed)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/random.py"
    },
    {
        "api_name": "state_fidelity",
        "full_api_name": "state_fidelity",
        "api_description": "Return the state fidelity between two quantum states.\n\nThe state fidelity :math:`F` for density matrix input states\n:math:`\\rho_1, \\rho_2` is given by\n\n.. math::\n    F(\\rho_1, \\rho_2) = Tr[\\sqrt{\\sqrt{\\rho_1}\\rho_2\\sqrt{\\rho_1}}]^2.\n\nIf one of the states is a pure state this simplifies to\n:math:`F(\\rho_1, \\rho_2) = \\langle\\psi_1|\\rho_2|\\psi_1\\rangle`, where\n:math:`\\rho_1 = |\\psi_1\\rangle\\!\\langle\\psi_1|`.\n\nArgs:\n    state1 (Statevector or DensityMatrix): the first quantum state.\n    state2 (Statevector or DensityMatrix): the second quantum state.\n    validate (bool): check if the inputs are valid quantum states\n                     [Default: True]\n\nReturns:\n    float: The state fidelity :math:`F(\\rho_1, \\rho_2)`.\n\nRaises:\n    QiskitError: if ``validate=True`` and the inputs are invalid quantum states.",
        "api_signature": "state_fidelity(state1, state2, validate)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/measures.py"
    },
    {
        "api_name": "purity",
        "full_api_name": "purity",
        "api_description": "Calculate the purity of a quantum state.\n\nThe purity of a density matrix :math:`\\rho` is\n\n.. math::\n\n    \\text{Purity}(\\rho) = Tr[\\rho^2]\n\nArgs:\n    state (Statevector or DensityMatrix): a quantum state.\n    validate (bool): check if input state is valid [Default: True]\n\nReturns:\n    float: the purity :math:`Tr[\\rho^2]`.\n\nRaises:\n    QiskitError: if the input isn't a valid quantum state.",
        "api_signature": "purity(state, validate)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/measures.py"
    },
    {
        "api_name": "entropy",
        "full_api_name": "entropy",
        "api_description": "Calculate the von-Neumann entropy of a quantum state.\n\nThe entropy :math:`S` is given by\n\n.. math::\n\n    S(\\rho) = - Tr[\\rho \\log(\\rho)]\n\nArgs:\n    state (Statevector or DensityMatrix): a quantum state.\n    base (int): the base of the logarithm [Default: 2].\n\nReturns:\n    float: The von-Neumann entropy S(rho).\n\nRaises:\n    QiskitError: if the input state is not a valid QuantumState.",
        "api_signature": "entropy(state, base)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/measures.py"
    },
    {
        "api_name": "mutual_information",
        "full_api_name": "mutual_information",
        "api_description": "Calculate the mutual information of a bipartite state.\n\nThe mutual information :math:`I` is given by:\n\n.. math::\n\n    I(\\rho_{AB}) = S(\\rho_A) + S(\\rho_B) - S(\\rho_{AB})\n\nwhere :math:`\\rho_A=Tr_B[\\rho_{AB}], \\rho_B=Tr_A[\\rho_{AB}]`, are the\nreduced density matrices of the bipartite state :math:`\\rho_{AB}`.\n\nArgs:\n    state (Statevector or DensityMatrix): a bipartite state.\n    base (int): the base of the logarithm [Default: 2].\n\nReturns:\n    float: The mutual information :math:`I(\\rho_{AB})`.\n\nRaises:\n    QiskitError: if the input state is not a valid QuantumState.\n    QiskitError: if input is not a bipartite QuantumState.",
        "api_signature": "mutual_information(state, base)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/measures.py"
    },
    {
        "api_name": "concurrence",
        "full_api_name": "concurrence",
        "api_description": "Calculate the concurrence of a quantum state.\n\nThe concurrence of a bipartite\n:class:`~qiskit.quantum_info.Statevector` :math:`|\\psi\\rangle` is\ngiven by\n\n.. math::\n\n    C(|\\psi\\rangle) = \\sqrt{2(1 - Tr[\\rho_0^2])}\n\nwhere :math:`\\rho_0 = Tr_1[|\\psi\\rangle\\!\\langle\\psi|]` is the\nreduced state from by taking the\n:func:`~qiskit.quantum_info.partial_trace` of the input state.\n\nFor density matrices the concurrence is only defined for\n2-qubit states, it is given by:\n\n.. math::\n\n    C(\\rho) = \\max(0, \\lambda_1 - \\lambda_2 - \\lambda_3 - \\lambda_4)\n\nwhere  :math:`\\lambda _1 \\ge \\lambda _2 \\ge \\lambda _3 \\ge \\lambda _4`\nare the ordered eigenvalues of the matrix\n:math:`R=\\sqrt{\\sqrt{\\rho }(Y\\otimes Y)\\overline{\\rho}(Y\\otimes Y)\\sqrt{\\rho}}`.\n\nArgs:\n    state (Statevector or DensityMatrix): a 2-qubit quantum state.\n\nReturns:\n    float: The concurrence.\n\nRaises:\n    QiskitError: if the input state is not a valid QuantumState.\n    QiskitError: if input is not a bipartite QuantumState.\n    QiskitError: if density matrix input is not a 2-qubit state.",
        "api_signature": "concurrence(state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/measures.py"
    },
    {
        "api_name": "entanglement_of_formation",
        "full_api_name": "entanglement_of_formation",
        "api_description": "Calculate the entanglement of formation of quantum state.\n\nThe input quantum state must be either a bipartite state vector, or a\n2-qubit density matrix.\n\nArgs:\n    state (Statevector or DensityMatrix): a 2-qubit quantum state.\n\nReturns:\n    float: The entanglement of formation.\n\nRaises:\n    QiskitError: if the input state is not a valid QuantumState.\n    QiskitError: if input is not a bipartite QuantumState.\n    QiskitError: if density matrix input is not a 2-qubit state.",
        "api_signature": "entanglement_of_formation(state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/measures.py"
    },
    {
        "api_name": "negativity",
        "full_api_name": "negativity",
        "api_description": "Calculates the negativity\n\nThe mathematical expression for negativity is given by:\n.. math::\n    {\\cal{N}}(\\rho) = \\frac{|| \\rho^{T_A}|| - 1 }{2}\n\nArgs:\n    state (Statevector or DensityMatrix): a quantum state.\n    qargs (list): The subsystems to be transposed.\n\nReturns:\n    negv (float): Negativity value of the quantum state\n\nRaises:\n    QiskitError: if the input state is not a valid QuantumState.",
        "api_signature": "negativity(state, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/measures.py"
    },
    {
        "api_name": "make_dict_observable",
        "full_api_name": "make_dict_observable",
        "api_description": "Convert an observable in matrix form to dictionary form.\n\nTakes in a diagonal observable as a matrix and converts it to a dictionary\nform. Can also handle a list sorted of the diagonal elements.\n\nArgs:\n    matrix_observable (list): The observable to be converted to dictionary\n    form. Can be a matrix or just an ordered list of observed values\n\nReturns:\n    Dict: A dictionary with all observable states as keys, and corresponding\n    values being the observed value for that state",
        "api_signature": "make_dict_observable(matrix_observable)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/analysis/make_observable.py"
    },
    {
        "api_name": "hellinger_distance",
        "full_api_name": "hellinger_distance",
        "api_description": "Computes the Hellinger distance between\ntwo counts distributions.\n\nParameters:\n    dist_p (dict): First dict of counts.\n    dist_q (dict): Second dict of counts.\n\nReturns:\n    float: Distance\n\nReferences:\n    `Hellinger Distance @ wikipedia <https://en.wikipedia.org/wiki/Hellinger_distance>`_",
        "api_signature": "hellinger_distance(dist_p, dist_q)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/analysis/distance.py"
    },
    {
        "api_name": "hellinger_fidelity",
        "full_api_name": "hellinger_fidelity",
        "api_description": "Computes the Hellinger fidelity between\ntwo counts distributions.\n\nThe fidelity is defined as :math:`\\left(1-H^{2}\\right)^{2}` where H is the\nHellinger distance.  This value is bounded in the range [0, 1].\n\nThis is equivalent to the standard classical fidelity\n:math:`F(Q,P)=\\left(\\sum_{i}\\sqrt{p_{i}q_{i}}\\right)^{2}` that in turn\nis equal to the quantum state fidelity for diagonal density matrices.\n\nParameters:\n    dist_p (dict): First dict of counts.\n    dist_q (dict): Second dict of counts.\n\nReturns:\n    float: Fidelity\n\nExample:\n\n    .. code-block::\n\n        from qiskit import QuantumCircuit, execute, BasicAer\n        from qiskit.quantum_info.analysis import hellinger_fidelity\n\n        qc = QuantumCircuit(5, 5)\n        qc.h(2)\n        qc.cx(2, 1)\n        qc.cx(2, 3)\n        qc.cx(3, 4)\n        qc.cx(1, 0)\n        qc.measure(range(5), range(5))\n\n        sim = BasicAer.get_backend('qasm_simulator')\n        res1 = execute(qc, sim).result()\n        res2 = execute(qc, sim).result()\n\n        hellinger_fidelity(res1.get_counts(), res2.get_counts())\n\nReferences:\n    `Quantum Fidelity @ wikipedia <https://en.wikipedia.org/wiki/Fidelity_of_quantum_states>`_\n    `Hellinger Distance @ wikipedia <https://en.wikipedia.org/wiki/Hellinger_distance>`_",
        "api_signature": "hellinger_fidelity(dist_p, dist_q)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/analysis/distance.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Z2Symmetries.__init__",
        "api_description": "Args:\n    symmetries: Object representing the list of $Z_2$ symmetries. These correspond to\n        the generators of the symmetry group $\\langle \\tau_1, \\tau_2\\dots \\rangle>$.\n    sq_paulis: Object representing the list of single-qubit Pauli $\\sigma^x_{q(i)}$\n        anti-commuting with the symmetry $\\tau_i$ and commuting with all the other symmetries\n        $\\tau_{j\\neq i}$. These operators are used to construct the unitary Clifford operators.\n    sq_list: The list of indices $q(i)$ of the single-qubit Pauli operators used to build the\n        Clifford operators.\n    tapering_values: List of eigenvalues determining the symmetry sector for each symmetry.\n    tol: Tolerance threshold for ignoring real and complex parts of a coefficient.\n\nRaises:\n    QiskitError: Invalid paulis. The lists of symmetries, single-qubit paulis support paulis\n        and tapering values must be of equal length. This length is the number of applied\n        symmetries and translates directly to the number of eliminated qubits.",
        "api_signature": "__init__(self, symmetries, sq_paulis, sq_list, tapering_values)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/analysis/z2_symmetries.py"
    },
    {
        "api_name": "symmetries",
        "full_api_name": "Z2Symmetries.symmetries",
        "api_description": "Return symmetries.",
        "api_signature": "symmetries(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/analysis/z2_symmetries.py"
    },
    {
        "api_name": "sq_paulis",
        "full_api_name": "Z2Symmetries.sq_paulis",
        "api_description": "Return sq paulis.",
        "api_signature": "sq_paulis(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/analysis/z2_symmetries.py"
    },
    {
        "api_name": "cliffords",
        "full_api_name": "Z2Symmetries.cliffords",
        "api_description": "Get clifford operators, built based on symmetries and single-qubit X.\n\nReturns:\n    A list of unitaries used to diagonalize the Hamiltonian.",
        "api_signature": "cliffords(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/analysis/z2_symmetries.py"
    },
    {
        "api_name": "sq_list",
        "full_api_name": "Z2Symmetries.sq_list",
        "api_description": "Return sq list.",
        "api_signature": "sq_list(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/analysis/z2_symmetries.py"
    },
    {
        "api_name": "settings",
        "full_api_name": "Z2Symmetries.settings",
        "api_description": "Return operator settings.",
        "api_signature": "settings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/analysis/z2_symmetries.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "Z2Symmetries.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/analysis/z2_symmetries.py"
    },
    {
        "api_name": "is_empty",
        "full_api_name": "Z2Symmetries.is_empty",
        "api_description": "Check the z2_symmetries is empty or not.\n\nReturns:\n    Empty or not.",
        "api_signature": "is_empty(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/analysis/z2_symmetries.py"
    },
    {
        "api_name": "find_z2_symmetries",
        "full_api_name": "Z2Symmetries.find_z2_symmetries",
        "api_description": "Finds Z2 Pauli-type symmetries of a :class:`.SparsePauliOp`.\n\nReturns:\n    A ``Z2Symmetries`` instance.",
        "api_signature": "find_z2_symmetries(cls, operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/analysis/z2_symmetries.py"
    },
    {
        "api_name": "_test_symmetry_row_col",
        "full_api_name": "Z2Symmetries._test_symmetry_row_col",
        "api_description": "Utility method that determines how to build the list of single-qubit Pauli X operators and\nthe list of corresponding qubit indices from the stacked symmetries.\nThis method is successively applied to Z type, X type and Y type symmetries (in this order)\nto build the letter at position (col) of the Pauli word corresponding to the symmetry at\nposition (row).\n\nArgs:\n    row (int): Index of the symmetry for which the single-qubit Pauli X operator is being\n        built.\n    col (int): Index of the letter in the Pauli word corresponding to the single-qubit Pauli\n        X operator.\n    idx_test (list): List of possibilities for the stacked symmetries at all other rows\n        than row.\n    row_test (list): List of possibilities for the stacked symmetries at row.\n\nReturns:\n    Whether or not this symmetry type should be used to build this letter of this\n    single-qubit Pauli X operator.",
        "api_signature": "_test_symmetry_row_col(row, col, idx_test, row_test)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/analysis/z2_symmetries.py"
    },
    {
        "api_name": "convert_clifford",
        "full_api_name": "Z2Symmetries.convert_clifford",
        "api_description": "This method operates the first part of the tapering.\nIt converts the operator by composing it with the clifford unitaries defined in the current\nsymmetry.\n\nArgs:\n    operator: The to-be-tapered operator.\n\nReturns:\n    ``SparsePauliOp`` corresponding to the converted operator.",
        "api_signature": "convert_clifford(self, operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/analysis/z2_symmetries.py"
    },
    {
        "api_name": "taper_clifford",
        "full_api_name": "Z2Symmetries.taper_clifford",
        "api_description": "Operate the second part of the tapering.\nThis function assumes that the input operators have already been transformed using\n:meth:`convert_clifford`. The redundant qubits due to the symmetries are dropped and\nreplaced by their two possible eigenvalues.\n\nArgs:\n    operator: Partially tapered operator resulting from a call to :meth:`convert_clifford`.\n\nReturns:\n    If tapering_values is None: [:class:`SparsePauliOp`]; otherwise, :class:`SparsePauliOp`.",
        "api_signature": "taper_clifford(self, operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/analysis/z2_symmetries.py"
    },
    {
        "api_name": "taper",
        "full_api_name": "Z2Symmetries.taper",
        "api_description": "Taper an operator based on the z2_symmetries info and sector defined by `tapering_values`.\nReturns operator if the symmetry object is empty.\n\nThe tapering is a two-step algorithm which first converts the operator into a\n:class:`SparsePauliOp` with same eigenvalues but where some qubits are only acted upon\nwith the Pauli operators I or X.\nThe number M of these redundant qubits is equal to the number M of identified symmetries.\n\nThe second step of the reduction consists in replacing these qubits with the possible\neigenvalues of the corresponding Pauli X, giving 2^M new operators with M less qubits.\nIf an eigenvalue sector was previously identified for the solution, then this reduces to\n1 new operator with M less qubits.\n\nArgs:\n    operator: The to-be-tapered operator.\n\nReturns:\n    If tapering_values is None: [:class:`SparsePauliOp`]; otherwise, :class:`SparsePauliOp`.",
        "api_signature": "taper(self, operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/analysis/z2_symmetries.py"
    },
    {
        "api_name": "_taper",
        "full_api_name": "Z2Symmetries._taper",
        "api_description": "",
        "api_signature": "_taper(self, op, curr_tapering_values)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/analysis/z2_symmetries.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "Z2Symmetries.__eq__",
        "api_description": "Overload `==` operation to evaluate equality between Z2Symmetries.\n\nArgs:\n    other: The `Z2Symmetries` to compare to self.\n\nReturns:\n    A bool equal to the equality of self and other.",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/analysis/z2_symmetries.py"
    },
    {
        "api_name": "_kernel_f2",
        "full_api_name": "_kernel_f2",
        "api_description": "Compute the kernel of a binary matrix on the binary finite field.\n\nArgs:\n    matrix_in (numpy.ndarray): Binary matrix.\n\nReturns:\n    The list of kernel vectors.",
        "api_signature": "_kernel_f2(matrix_in)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/analysis/z2_symmetries.py"
    },
    {
        "api_name": "_row_echelon_f2",
        "full_api_name": "_row_echelon_f2",
        "api_description": "Compute the row Echelon form of a binary matrix on the binary finite field.\n\nArgs:\n    matrix_in (numpy.ndarray): Binary matrix.\n\nReturns:\n    Matrix_in in Echelon row form.",
        "api_signature": "_row_echelon_f2(matrix_in)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/analysis/z2_symmetries.py"
    },
    {
        "api_name": "_sparse_pauli_op_is_zero",
        "full_api_name": "_sparse_pauli_op_is_zero",
        "api_description": "Returns whether or not this operator represents a zero operation.",
        "api_signature": "_sparse_pauli_op_is_zero(op)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/analysis/z2_symmetries.py"
    },
    {
        "api_name": "average_data",
        "full_api_name": "average_data",
        "api_description": "Compute the mean value of an diagonal observable.\n\nTakes in a diagonal observable in dictionary, list or matrix format and then\ncalculates the sum_i value(i) P(i) where value(i) is the value of the\nobservable for state i.\n\nArgs:\n    counts (dict): a dict of outcomes from an experiment\n    observable (dict or matrix or list): The observable to be averaged over.\n    As an example, ZZ on qubits can be given as:\n    * dict: {\"00\": 1, \"11\": 1, \"01\": -1, \"10\": -1}\n    * matrix: [[1, 0, 0, 0], [0, -1, 0, 0, ], [0, 0, -1, 0], [0, 0, 0, 1]]\n    * matrix diagonal (list): [1, -1, -1, 1]\n\nReturns:\n    Double: Average of the observable",
        "api_signature": "average_data(counts, observable)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/analysis/average.py"
    },
    {
        "api_name": "decompose_clifford",
        "full_api_name": "decompose_clifford",
        "api_description": "DEPRECATED: Decompose a Clifford operator into a QuantumCircuit.\n\nFor N <= 3 qubits this is based on optimal CX cost decomposition\nfrom reference [1]. For N > 3 qubits this is done using the general\nnon-optimal greedy compilation routine from reference [3],\nwhich typically yields better CX cost compared to the AG method in [2].\n\nArgs:\n    clifford (Clifford): a clifford operator.\n    method (str):  Optional, a synthesis method ('AG' or 'greedy').\n         If set this overrides optimal decomposition for N <=3 qubits.\n\nReturn:\n    QuantumCircuit: a circuit implementation of the Clifford.\n\nReferences:\n    1. S. Bravyi, D. Maslov, *Hadamard-free circuits expose the\n       structure of the Clifford group*,\n       `arXiv:2003.09412 [quant-ph] <https://arxiv.org/abs/2003.09412>`_\n\n    2. S. Aaronson, D. Gottesman, *Improved Simulation of Stabilizer Circuits*,\n       Phys. Rev. A 70, 052328 (2004).\n       `arXiv:quant-ph/0406196 <https://arxiv.org/abs/quant-ph/0406196>`_\n\n    3. Sergey Bravyi, Shaohan Hu, Dmitri Maslov, Ruslan Shaydulin,\n       *Clifford Circuit Optimization with Templates and Symbolic Pauli Gates*,\n       `arXiv:2105.02291 [quant-ph] <https://arxiv.org/abs/2105.02291>`_",
        "api_signature": "decompose_clifford(clifford, method)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/clifford_decompose.py"
    },
    {
        "api_name": "two_qubit_local_invariants",
        "full_api_name": "two_qubit_local_invariants",
        "api_description": "Computes the local invariants for a two-qubit unitary.\n\nArgs:\n    U (ndarray): Input two-qubit unitary.\n\nReturns:\n    ndarray: NumPy array of local invariants [g0, g1, g2].\n\nRaises:\n    ValueError: Input not a 2q unitary.\n\nNotes:\n    Y. Makhlin, Quant. Info. Proc. 1, 243-252 (2002).\n    Zhang et al., Phys Rev A. 67, 042313 (2003).",
        "api_signature": "two_qubit_local_invariants(U)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/local_invariance.py"
    },
    {
        "api_name": "local_equivalence",
        "full_api_name": "local_equivalence",
        "api_description": "Computes the equivalent local invariants from the\nWeyl coordinates.\n\nArgs:\n    weyl (ndarray): Weyl coordinates.\n\nReturns:\n    ndarray: Local equivalent coordinates [g0, g1, g3].\n\nNotes:\n    This uses Eq. 30 from Zhang et al, PRA 67, 042313 (2003),\n    but we multiply weyl coordinates by 2 since we are\n    working in the reduced chamber.",
        "api_signature": "local_equivalence(weyl)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/local_invariance.py"
    },
    {
        "api_name": "qs_decomposition",
        "full_api_name": "qs_decomposition",
        "api_description": "Decomposes unitary matrix into one and two qubit gates using Quantum Shannon Decomposition.\n\n   \u250c\u2500\u2500\u2500\u2510               \u250c\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2510\n  \u2500\u2524   \u251c\u2500       \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 Rz\u251c\u2500\u2500\u2500\u2500\u2500\u2524 Ry\u251c\u2500\u2500\u2500\u2500\u2500\u2524 Rz\u251c\u2500\u2500\u2500\u2500\u2500\n   \u2502   \u2502    \u2243     \u250c\u2500\u2500\u2500\u2510\u2514\u2500\u252c\u2500\u2518\u250c\u2500\u2500\u2500\u2510\u2514\u2500\u252c\u2500\u2518\u250c\u2500\u2500\u2500\u2510\u2514\u2500\u252c\u2500\u2518\u250c\u2500\u2500\u2500\u2510\n /\u2500\u2524   \u251c\u2500       /\u2500\u2524   \u251c\u2500\u2500\u25a1\u2500\u2500\u2524   \u251c\u2500\u2500\u25a1\u2500\u2500\u2524   \u251c\u2500\u2500\u25a1\u2500\u2500\u2524   \u251c\n   \u2514\u2500\u2500\u2500\u2518          \u2514\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2518\n\nThe number of CX gates generated with the decomposition without optimizations is,\n\n.. math::\n\n    \frac{9}{16} 4^n - frac{3}{2} 2^n\n\nIf opt_a1 = True, the default, the CX count is reduced by,\n\n.. math::\n\n    \frac{1}{3} 4^{n - 2} - 1.\n\nIf opt_a2 = True, the default, the CX count is reduced by,\n\n.. math::\n\n    4^{n-2} - 1.\n\nThis decomposition is described in arXiv:quant-ph/0406176.\n\nArguments:\n   mat (ndarray): unitary matrix to decompose\n   opt_a1 (bool): whether to try optimization A.1 from Shende. This should eliminate 1 cnot\n      per call. If True CZ gates are left in the output. If desired these can be further decomposed\n      to CX.\n   opt_a2 (bool): whether to try optimization A.2 from Shende. This decomposes two qubit\n      unitaries into a diagonal gate and a two cx unitary and reduces overal cx count by\n      4^(n-2) - 1.\n   decomposer_1q (None or Object): optional 1Q decomposer. If None, uses\n      :class:`~qiskit.quantum_info.synthesis.one_qubit_decomposer.OneQubitEulerDecomser`\n   decomposer_2q (None or Object): optional 2Q decomposer. If None, uses\n      :class:`~qiskit.quantum_info.synthesis.two_qubit_decomposer.two_qubit_cnot_decompose\n\nReturn:\n   QuantumCircuit: Decomposed quantum circuit.",
        "api_signature": "qs_decomposition(mat, opt_a1, opt_a2, decomposer_1q, decomposer_2q)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/qsd.py"
    },
    {
        "api_name": "decomp_2q",
        "full_api_name": "decomp_2q",
        "api_description": "",
        "api_signature": "decomp_2q(mat)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/qsd.py"
    },
    {
        "api_name": "_demultiplex",
        "full_api_name": "_demultiplex",
        "api_description": "Decompose a generic multiplexer.\n\n      \u2500\u2500\u2500\u2500\u25a1\u2500\u2500\u2500\u2500\n       \u250c\u2500\u2500\u2534\u2500\u2500\u2510\n     /\u2500\u2524     \u251c\u2500\n       \u2514\u2500\u2500\u2500\u2500\u2500\u2518\n\nrepresented by the block diagonal matrix\n\n        \u250f         \u2513\n        \u2503 um0     \u2503\n        \u2503     um1 \u2503\n        \u2517         \u251b\n\nto\n           \u250c\u2500\u2500\u2500\u2510\n    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 Rz\u251c\u2500\u2500\u2500\u2500\u2500\u2500\n      \u250c\u2500\u2500\u2500\u2510\u2514\u2500\u252c\u2500\u2518\u250c\u2500\u2500\u2500\u2510\n    /\u2500\u2524 w \u251c\u2500\u2500\u25a1\u2500\u2500\u2524 v \u251c\u2500\n      \u2514\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2518\n\nwhere v and w are general unitaries determined from decomposition.\n\nArgs:\n   um0 (ndarray): applied if MSB is 0\n   um1 (ndarray): applied if MSB is 1\n   opt_a1 (bool): whether to try optimization A.1 from Shende. This should elliminate 1 cnot\n      per call. If True CZ gates are left in the output. If desired these can be further decomposed\n   opt_a2 (bool): whether to try  optimization A.2 from Shende. This decomposes two qubit\n      unitaries into a diagonal gate and a two cx unitary and reduces overal cx count by\n      4^(n-2) - 1.\n   _depth (int): This is an internal variable to track the recursion depth.\n\nReturns:\n    QuantumCircuit: decomposed circuit",
        "api_signature": "_demultiplex(um0, um1, opt_a1, opt_a2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/qsd.py"
    },
    {
        "api_name": "_get_ucry_cz",
        "full_api_name": "_get_ucry_cz",
        "api_description": "Get uniformly controlled Ry gate in in CZ-Ry as in UCPauliRotGate.",
        "api_signature": "_get_ucry_cz(nqubits, angles)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/qsd.py"
    },
    {
        "api_name": "_apply_a2",
        "full_api_name": "_apply_a2",
        "api_description": "",
        "api_signature": "_apply_a2(circ)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/qsd.py"
    },
    {
        "api_name": "decompose_two_qubit_product_gate",
        "full_api_name": "decompose_two_qubit_product_gate",
        "api_description": "Decompose U = Ul\u2297Ur where U in SU(4), and Ul, Ur in SU(2).\nThrows QiskitError if this isn't possible.",
        "api_signature": "decompose_two_qubit_product_gate(special_unitary_matrix)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/two_qubit_decompose.py"
    },
    {
        "api_name": "__init_subclass__",
        "full_api_name": "TwoQubitWeylDecomposition.__init_subclass__",
        "api_description": "Subclasses should be concrete, not factories.\n\nMake explicitly-instantiated subclass __new__  call base __new__ with fidelity=None",
        "api_signature": "__init_subclass__(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/two_qubit_decompose.py"
    },
    {
        "api_name": "__new__",
        "full_api_name": "TwoQubitWeylDecomposition.__new__",
        "api_description": "Perform the Weyl chamber decomposition, and optionally choose a specialized subclass.\n\nThe flip into the Weyl Chamber is described in B. Kraus and J. I. Cirac, Phys. Rev. A 63,\n062309 (2001).\n\nFIXME: There's a cleaner-seeming method based on choosing branch cuts carefully, in Andrew\nM. Childs, Henry L. Haselgrove, and Michael A. Nielsen, Phys. Rev. A 68, 052311, but I\nwasn't able to get that to work.\n\nThe overall decomposition scheme is taken from Drury and Love, arXiv:0806.4015 [quant-ph].",
        "api_signature": "__new__(cls, unitary_matrix)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/two_qubit_decompose.py"
    },
    {
        "api_name": "is_close",
        "full_api_name": "TwoQubitWeylDecomposition.is_close",
        "api_description": "",
        "api_signature": "is_close(ap, bp, cp)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/two_qubit_decompose.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "TwoQubitWeylDecomposition.__init__",
        "api_description": "",
        "api_signature": "__init__(self, unitary_matrix, fidelity)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/two_qubit_decompose.py"
    },
    {
        "api_name": "specialize",
        "full_api_name": "TwoQubitWeylDecomposition.specialize",
        "api_description": "Make changes to the decomposition to comply with any specialization.\n\nDo update a, b, c, k1l, k1r, k2l, k2r, _is_flipped_from_original to round to the\nspecialization. Do not update the global phase, since this gets done in generic\n__init__()",
        "api_signature": "specialize(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/two_qubit_decompose.py"
    },
    {
        "api_name": "circuit",
        "full_api_name": "TwoQubitWeylDecomposition.circuit",
        "api_description": "Returns Weyl decomposition in circuit form.\n\nsimplify, atol arguments are passed to OneQubitEulerDecomposer",
        "api_signature": "circuit(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/two_qubit_decompose.py"
    },
    {
        "api_name": "_weyl_gate",
        "full_api_name": "TwoQubitWeylDecomposition._weyl_gate",
        "api_description": "Appends Ud(a, b, c) to the circuit.\n\nCan be overridden in subclasses for special cases",
        "api_signature": "_weyl_gate(self, simplify, circ, atol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/two_qubit_decompose.py"
    },
    {
        "api_name": "actual_fidelity",
        "full_api_name": "TwoQubitWeylDecomposition.actual_fidelity",
        "api_description": "Calculates the actual fidelity of the decomposed circuit to the input unitary",
        "api_signature": "actual_fidelity(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/two_qubit_decompose.py"
    },
    {
        "api_name": "__getnewargs_ex__",
        "full_api_name": "TwoQubitWeylDecomposition.__getnewargs_ex__",
        "api_description": "",
        "api_signature": "__getnewargs_ex__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/two_qubit_decompose.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "TwoQubitWeylDecomposition.__repr__",
        "api_description": "Represent with enough precision to allow copy-paste debugging of all corner cases",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/two_qubit_decompose.py"
    },
    {
        "api_name": "from_bytes",
        "full_api_name": "TwoQubitWeylDecomposition.from_bytes",
        "api_description": "Decode bytes into TwoQubitWeylDecomposition. Used by __repr__",
        "api_signature": "from_bytes(cls, bytes_in)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/two_qubit_decompose.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "TwoQubitWeylDecomposition.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/two_qubit_decompose.py"
    },
    {
        "api_name": "specialize",
        "full_api_name": "TwoQubitWeylIdEquiv.specialize",
        "api_description": "",
        "api_signature": "specialize(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/two_qubit_decompose.py"
    },
    {
        "api_name": "specialize",
        "full_api_name": "TwoQubitWeylSWAPEquiv.specialize",
        "api_description": "",
        "api_signature": "specialize(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/two_qubit_decompose.py"
    },
    {
        "api_name": "_weyl_gate",
        "full_api_name": "TwoQubitWeylSWAPEquiv._weyl_gate",
        "api_description": "",
        "api_signature": "_weyl_gate(self, simplify, circ, atol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/two_qubit_decompose.py"
    },
    {
        "api_name": "_closest_partial_swap",
        "full_api_name": "_closest_partial_swap",
        "api_description": "A good approximation to the best value x to get the minimum\ntrace distance for Ud(x, x, x) from Ud(a, b, c)",
        "api_signature": "_closest_partial_swap(a, b, c)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/two_qubit_decompose.py"
    },
    {
        "api_name": "specialize",
        "full_api_name": "TwoQubitWeylPartialSWAPEquiv.specialize",
        "api_description": "",
        "api_signature": "specialize(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/two_qubit_decompose.py"
    },
    {
        "api_name": "specialize",
        "full_api_name": "TwoQubitWeylPartialSWAPFlipEquiv.specialize",
        "api_description": "",
        "api_signature": "specialize(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/two_qubit_decompose.py"
    },
    {
        "api_name": "specialize",
        "full_api_name": "TwoQubitWeylControlledEquiv.specialize",
        "api_description": "",
        "api_signature": "specialize(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/two_qubit_decompose.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "TwoQubitControlledUDecomposer.__init__",
        "api_description": "Initialize the KAK decomposition.\n\nArgs:\n    rxx_equivalent_gate: Gate that is locally equivalent to an RXXGate:\n    U ~ Ud(\u03b1, 0, 0) ~ Ctrl-U gate.\nRaises:\n    QiskitError: If the gate is not locally equivalent to an RXXGate.",
        "api_signature": "__init__(self, rxx_equivalent_gate)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/two_qubit_decompose.py"
    },
    {
        "api_name": "__call__",
        "full_api_name": "TwoQubitControlledUDecomposer.__call__",
        "api_description": "Returns the Weyl decomposition in circuit form.\n\nNote: atol ist passed to OneQubitEulerDecomposer.",
        "api_signature": "__call__(self, unitary)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/two_qubit_decompose.py"
    },
    {
        "api_name": "_to_rxx_gate",
        "full_api_name": "TwoQubitControlledUDecomposer._to_rxx_gate",
        "api_description": "Takes an angle and returns the circuit equivalent to an RXXGate with the\nRXX equivalent gate as the two-qubit unitary.\n\nArgs:\n    angle: Rotation angle (in this case one of the Weyl parameters a, b, or c)\n\nReturns:\n    Circuit: Circuit equivalent to an RXXGate.\n\nRaises:\n    QiskitError: If the circuit is not equivalent to an RXXGate.",
        "api_signature": "_to_rxx_gate(self, angle)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/two_qubit_decompose.py"
    },
    {
        "api_name": "_weyl_gate",
        "full_api_name": "TwoQubitControlledUDecomposer._weyl_gate",
        "api_description": "Appends Ud(a, b, c) to the circuit.",
        "api_signature": "_weyl_gate(self, circ, atol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/two_qubit_decompose.py"
    },
    {
        "api_name": "specialize",
        "full_api_name": "TwoQubitWeylMirrorControlledEquiv.specialize",
        "api_description": "",
        "api_signature": "specialize(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/two_qubit_decompose.py"
    },
    {
        "api_name": "_weyl_gate",
        "full_api_name": "TwoQubitWeylMirrorControlledEquiv._weyl_gate",
        "api_description": "",
        "api_signature": "_weyl_gate(self, simplify, circ, atol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/two_qubit_decompose.py"
    },
    {
        "api_name": "specialize",
        "full_api_name": "TwoQubitWeylfSimaabEquiv.specialize",
        "api_description": "",
        "api_signature": "specialize(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/two_qubit_decompose.py"
    },
    {
        "api_name": "specialize",
        "full_api_name": "TwoQubitWeylfSimabbEquiv.specialize",
        "api_description": "",
        "api_signature": "specialize(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/two_qubit_decompose.py"
    },
    {
        "api_name": "specialize",
        "full_api_name": "TwoQubitWeylfSimabmbEquiv.specialize",
        "api_description": "",
        "api_signature": "specialize(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/two_qubit_decompose.py"
    },
    {
        "api_name": "specialize",
        "full_api_name": "TwoQubitWeylGeneral.specialize",
        "api_description": "",
        "api_signature": "specialize(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/two_qubit_decompose.py"
    },
    {
        "api_name": "Ud",
        "full_api_name": "Ud",
        "api_description": "Generates the array Exp(i(a xx + b yy + c zz))",
        "api_signature": "Ud(a, b, c)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/two_qubit_decompose.py"
    },
    {
        "api_name": "trace_to_fid",
        "full_api_name": "trace_to_fid",
        "api_description": "Average gate fidelity is :math:`Fbar = (d + |Tr (Utarget \\cdot U^dag)|^2) / d(d+1)`\nM. Horodecki, P. Horodecki and R. Horodecki, PRA 60, 1888 (1999)",
        "api_signature": "trace_to_fid(trace)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/two_qubit_decompose.py"
    },
    {
        "api_name": "rz_array",
        "full_api_name": "rz_array",
        "api_description": "Return numpy array for Rz(theta).\n\nRz(theta) = diag(exp(-i*theta/2),exp(i*theta/2))",
        "api_signature": "rz_array(theta)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/two_qubit_decompose.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "TwoQubitBasisDecomposer.__init__",
        "api_description": "",
        "api_signature": "__init__(self, gate, basis_fidelity, euler_basis, pulse_optimize)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/two_qubit_decompose.py"
    },
    {
        "api_name": "traces",
        "full_api_name": "TwoQubitBasisDecomposer.traces",
        "api_description": "Give the expected traces :math:`|Tr(U \\cdot Utarget^dag)|` for different number of\nbasis gates.",
        "api_signature": "traces(self, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/two_qubit_decompose.py"
    },
    {
        "api_name": "decomp0",
        "full_api_name": "TwoQubitBasisDecomposer.decomp0",
        "api_description": "Decompose target ~Ud(x, y, z) with 0 uses of the basis gate.\nResult Ur has trace:\n:math:`|Tr(Ur.Utarget^dag)| = 4|(cos(x)cos(y)cos(z)+ j sin(x)sin(y)sin(z)|`,\nwhich is optimal for all targets and bases",
        "api_signature": "decomp0(target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/two_qubit_decompose.py"
    },
    {
        "api_name": "decomp1",
        "full_api_name": "TwoQubitBasisDecomposer.decomp1",
        "api_description": "Decompose target ~Ud(x, y, z) with 1 uses of the basis gate ~Ud(a, b, c).\nResult Ur has trace:\n.. math::\n\n    |Tr(Ur.Utarget^dag)| = 4|cos(x-a)cos(y-b)cos(z-c) + j sin(x-a)sin(y-b)sin(z-c)|\n\nwhich is optimal for all targets and bases with z==0 or c==0",
        "api_signature": "decomp1(self, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/two_qubit_decompose.py"
    },
    {
        "api_name": "decomp2_supercontrolled",
        "full_api_name": "TwoQubitBasisDecomposer.decomp2_supercontrolled",
        "api_description": "Decompose target ~Ud(x, y, z) with 2 uses of the basis gate.\n\nFor supercontrolled basis ~Ud(pi/4, b, 0), all b, result Ur has trace\n.. math::\n\n    |Tr(Ur.Utarget^dag)| = 4cos(z)\n\nwhich is the optimal approximation for basis of CNOT-class ``~Ud(pi/4, 0, 0)``\nor DCNOT-class ``~Ud(pi/4, pi/4, 0)`` and any target.\nMay be sub-optimal for b!=0 (e.g. there exists exact decomposition for any target using B\n``B~Ud(pi/4, pi/8, 0)``, but not this decomposition.)\nThis is an exact decomposition for supercontrolled basis and target ``~Ud(x, y, 0)``.\nNo guarantees for non-supercontrolled basis.",
        "api_signature": "decomp2_supercontrolled(self, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/two_qubit_decompose.py"
    },
    {
        "api_name": "decomp3_supercontrolled",
        "full_api_name": "TwoQubitBasisDecomposer.decomp3_supercontrolled",
        "api_description": "Decompose target with 3 uses of the basis.\nThis is an exact decomposition for supercontrolled basis ~Ud(pi/4, b, 0), all b,\nand any target. No guarantees for non-supercontrolled basis.",
        "api_signature": "decomp3_supercontrolled(self, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/two_qubit_decompose.py"
    },
    {
        "api_name": "__call__",
        "full_api_name": "TwoQubitBasisDecomposer.__call__",
        "api_description": "Decompose a two-qubit `unitary` over fixed basis + SU(2) using the best approximation given\nthat each basis application has a finite `basis_fidelity`.\n\nArgs:\n    unitary (Operator or ndarray): 4x4 unitary to synthesize.\n    basis_fidelity (float or None): Fidelity to be assumed for applications of KAK Gate.\n        If given, overrides basis_fidelity given at init.\n    approximate (bool): Approximates if basis fidelities are less than 1.0.\n    _num_basis_uses (int): force a particular approximation by passing a number in [0, 3].\nReturns:\n    QuantumCircuit: Synthesized circuit.\nRaises:\n    QiskitError: if pulse_optimize is True but we don't know how to do it.",
        "api_signature": "__call__(self, unitary, basis_fidelity, approximate)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/two_qubit_decompose.py"
    },
    {
        "api_name": "_pulse_optimal_chooser",
        "full_api_name": "TwoQubitBasisDecomposer._pulse_optimal_chooser",
        "api_description": "Determine method to find pulse optimal circuit. This method may be\nremoved once a more general approach is used.\n\nReturns:\n    QuantumCircuit: pulse optimal quantum circuit.\n    None: Probably nbasis=1 and original circuit is fine.\n\nRaises:\n    QiskitError: Decomposition for selected basis not implemented.",
        "api_signature": "_pulse_optimal_chooser(self, best_nbasis, decomposition, target_decomposed)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/two_qubit_decompose.py"
    },
    {
        "api_name": "_get_sx_vz_2cx_efficient_euler",
        "full_api_name": "TwoQubitBasisDecomposer._get_sx_vz_2cx_efficient_euler",
        "api_description": "Decomposition of SU(4) gate for device with SX, virtual RZ, and CNOT gates assuming\ntwo CNOT gates are needed.\n\nThis first decomposes each unitary from the KAK decomposition into ZXZ on the source\nqubit of the CNOTs and XZX on the targets in order to commute operators to beginning and\nend of decomposition. The beginning and ending single qubit gates are then\ncollapsed and re-decomposed with the single qubit decomposer. This last step could be avoided\nif performance is a concern.",
        "api_signature": "_get_sx_vz_2cx_efficient_euler(self, decomposition, target_decomposed)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/two_qubit_decompose.py"
    },
    {
        "api_name": "_get_sx_vz_3cx_efficient_euler",
        "full_api_name": "TwoQubitBasisDecomposer._get_sx_vz_3cx_efficient_euler",
        "api_description": "Decomposition of SU(4) gate for device with SX, virtual RZ, and CNOT gates assuming\nthree CNOT gates are needed.\n\nThis first decomposes each unitary from the KAK decomposition into ZXZ on the source\nqubit of the CNOTs and XZX on the targets in order commute operators to beginning and\nend of decomposition. Inserting Hadamards reverses the direction of the CNOTs and transforms\na variable Rx -> variable virtual Rz. The beginning and ending single qubit gates are then\ncollapsed and re-decomposed with the single qubit decomposer. This last step could be avoided\nif performance is a concern.",
        "api_signature": "_get_sx_vz_3cx_efficient_euler(self, decomposition, target_decomposed)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/two_qubit_decompose.py"
    },
    {
        "api_name": "num_basis_gates",
        "full_api_name": "TwoQubitBasisDecomposer.num_basis_gates",
        "api_description": "Computes the number of basis gates needed in\na decomposition of input unitary",
        "api_signature": "num_basis_gates(self, unitary)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/two_qubit_decompose.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "TwoQubitDecomposeUpToDiagonal.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/two_qubit_decompose.py"
    },
    {
        "api_name": "_u4_to_su4",
        "full_api_name": "TwoQubitDecomposeUpToDiagonal._u4_to_su4",
        "api_description": "",
        "api_signature": "_u4_to_su4(self, u4)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/two_qubit_decompose.py"
    },
    {
        "api_name": "_gamma",
        "full_api_name": "TwoQubitDecomposeUpToDiagonal._gamma",
        "api_description": "proposition II.1: this invariant characterizes when two operators in U(4),\nsay u, v, are equivalent up to single qubit gates:\n\n   u \u2261 v -> Det(\u03b3(u)) = Det(\u00b1(\u03b3(v)))",
        "api_signature": "_gamma(self, mat)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/two_qubit_decompose.py"
    },
    {
        "api_name": "_cx0_test",
        "full_api_name": "TwoQubitDecomposeUpToDiagonal._cx0_test",
        "api_description": "",
        "api_signature": "_cx0_test(self, mat)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/two_qubit_decompose.py"
    },
    {
        "api_name": "_cx1_test",
        "full_api_name": "TwoQubitDecomposeUpToDiagonal._cx1_test",
        "api_description": "",
        "api_signature": "_cx1_test(self, mat)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/two_qubit_decompose.py"
    },
    {
        "api_name": "_cx2_test",
        "full_api_name": "TwoQubitDecomposeUpToDiagonal._cx2_test",
        "api_description": "",
        "api_signature": "_cx2_test(self, mat)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/two_qubit_decompose.py"
    },
    {
        "api_name": "_real_trace_transform",
        "full_api_name": "TwoQubitDecomposeUpToDiagonal._real_trace_transform",
        "api_description": "Determine diagonal gate such that\n\nU3 = D U2\n\nWhere U3 is a general two-qubit gate which takes 3 cnots, D is a\ndiagonal gate, and U2 is a gate which takes 2 cnots.",
        "api_signature": "_real_trace_transform(self, mat)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/two_qubit_decompose.py"
    },
    {
        "api_name": "__call__",
        "full_api_name": "TwoQubitDecomposeUpToDiagonal.__call__",
        "api_description": "do the decomposition",
        "api_signature": "__call__(self, mat)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/two_qubit_decompose.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "_LazyTwoQubitCXDecomposer.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/two_qubit_decompose.py"
    },
    {
        "api_name": "_load",
        "full_api_name": "_LazyTwoQubitCXDecomposer._load",
        "api_description": "",
        "api_signature": "_load(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/two_qubit_decompose.py"
    },
    {
        "api_name": "__call__",
        "full_api_name": "_LazyTwoQubitCXDecomposer.__call__",
        "api_description": "",
        "api_signature": "__call__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/two_qubit_decompose.py"
    },
    {
        "api_name": "traces",
        "full_api_name": "_LazyTwoQubitCXDecomposer.traces",
        "api_description": "",
        "api_signature": "traces(self, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/two_qubit_decompose.py"
    },
    {
        "api_name": "decomp1",
        "full_api_name": "_LazyTwoQubitCXDecomposer.decomp1",
        "api_description": "",
        "api_signature": "decomp1(self, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/two_qubit_decompose.py"
    },
    {
        "api_name": "decomp2_supercontrolled",
        "full_api_name": "_LazyTwoQubitCXDecomposer.decomp2_supercontrolled",
        "api_description": "",
        "api_signature": "decomp2_supercontrolled(self, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/two_qubit_decompose.py"
    },
    {
        "api_name": "decomp3_supercontrolled",
        "full_api_name": "_LazyTwoQubitCXDecomposer.decomp3_supercontrolled",
        "api_description": "",
        "api_signature": "decomp3_supercontrolled(self, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/two_qubit_decompose.py"
    },
    {
        "api_name": "num_basis_gates",
        "full_api_name": "_LazyTwoQubitCXDecomposer.num_basis_gates",
        "api_description": "",
        "api_signature": "num_basis_gates(self, unitary)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/two_qubit_decompose.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Quaternion.__init__",
        "api_description": "",
        "api_signature": "__init__(self, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/quaternion.py"
    },
    {
        "api_name": "__call__",
        "full_api_name": "Quaternion.__call__",
        "api_description": "",
        "api_signature": "__call__(self, idx)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/quaternion.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "Quaternion.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/quaternion.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "Quaternion.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/quaternion.py"
    },
    {
        "api_name": "__mul__",
        "full_api_name": "Quaternion.__mul__",
        "api_description": "",
        "api_signature": "__mul__(self, r)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/quaternion.py"
    },
    {
        "api_name": "norm",
        "full_api_name": "Quaternion.norm",
        "api_description": "Norm of quaternion.",
        "api_signature": "norm(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/quaternion.py"
    },
    {
        "api_name": "normalize",
        "full_api_name": "Quaternion.normalize",
        "api_description": "Normalizes a Quaternion to unit length\nso that it represents a valid rotation.\n\nArgs:\n    inplace (bool): Do an inplace normalization.\n\nReturns:\n    Quaternion: Normalized quaternion.",
        "api_signature": "normalize(self, inplace)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/quaternion.py"
    },
    {
        "api_name": "to_matrix",
        "full_api_name": "Quaternion.to_matrix",
        "api_description": "Converts a unit-length quaternion to a rotation matrix.\n\nReturns:\n    ndarray: Rotation matrix.",
        "api_signature": "to_matrix(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/quaternion.py"
    },
    {
        "api_name": "to_zyz",
        "full_api_name": "Quaternion.to_zyz",
        "api_description": "Converts a unit-length quaternion to a sequence\nof ZYZ Euler angles.\n\nReturns:\n    ndarray: Array of Euler angles.",
        "api_signature": "to_zyz(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/quaternion.py"
    },
    {
        "api_name": "from_axis_rotation",
        "full_api_name": "Quaternion.from_axis_rotation",
        "api_description": "Return quaternion for rotation about given axis.\n\nArgs:\n    angle (float): Angle in radians.\n    axis (str): Axis for rotation\n\nReturns:\n    Quaternion: Quaternion for axis rotation.\n\nRaises:\n    ValueError: Invalid input axis.",
        "api_signature": "from_axis_rotation(cls, angle, axis)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/quaternion.py"
    },
    {
        "api_name": "from_euler",
        "full_api_name": "Quaternion.from_euler",
        "api_description": "Generate a quaternion from a set of Euler angles.\n\nArgs:\n    angles (array_like): Array of Euler angles.\n    order (str): Order of Euler rotations.  'yzy' is default.\n\nReturns:\n    Quaternion: Quaternion representation of Euler rotation.",
        "api_signature": "from_euler(cls, angles, order)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/quaternion.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "OneQubitEulerDecomposer.__init__",
        "api_description": "Initialize decomposer\n\nSupported bases are: 'U', 'PSX', 'ZSXX', 'ZSX', 'U321', 'U3', 'U1X', 'RR', 'ZYZ', 'ZXZ',\n'XYX', 'XZX'.\n\nArgs:\n    basis (str): the decomposition basis [Default: 'U3']\n    use_dag (bool): If true the output from calls to the decomposer\n        will be a :class:`~qiskit.dagcircuit.DAGCircuit` object instead of\n        :class:`~qiskit.circuit.QuantumCircuit`.\n\nRaises:\n    QiskitError: If input basis is not recognized.",
        "api_signature": "__init__(self, basis, use_dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/one_qubit_decompose.py"
    },
    {
        "api_name": "build_circuit",
        "full_api_name": "OneQubitEulerDecomposer.build_circuit",
        "api_description": "Return the circuit or dag object from a list of gates.",
        "api_signature": "build_circuit(self, gates, global_phase)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/one_qubit_decompose.py"
    },
    {
        "api_name": "__call__",
        "full_api_name": "OneQubitEulerDecomposer.__call__",
        "api_description": "Decompose single qubit gate into a circuit.\n\nArgs:\n    unitary (Operator or Gate or array): 1-qubit unitary matrix\n    simplify (bool): reduce gate count in decomposition [Default: True].\n    atol (float): absolute tolerance for checking angles when simplifying\n                 returned circuit [Default: 1e-12].\nReturns:\n    QuantumCircuit: the decomposed single-qubit gate circuit\n\nRaises:\n    QiskitError: if input is invalid or synthesis fails.",
        "api_signature": "__call__(self, unitary, simplify, atol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/one_qubit_decompose.py"
    },
    {
        "api_name": "_decompose",
        "full_api_name": "OneQubitEulerDecomposer._decompose",
        "api_description": "",
        "api_signature": "_decompose(self, unitary, simplify, atol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/one_qubit_decompose.py"
    },
    {
        "api_name": "basis",
        "full_api_name": "OneQubitEulerDecomposer.basis",
        "api_description": "The decomposition basis.",
        "api_signature": "basis(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/one_qubit_decompose.py"
    },
    {
        "api_name": "basis",
        "full_api_name": "OneQubitEulerDecomposer.basis",
        "api_description": "Set the decomposition basis.",
        "api_signature": "basis(self, basis)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/one_qubit_decompose.py"
    },
    {
        "api_name": "angles",
        "full_api_name": "OneQubitEulerDecomposer.angles",
        "api_description": "Return the Euler angles for input array.\n\nArgs:\n    unitary (np.ndarray): 2x2 unitary matrix.\n\nReturns:\n    tuple: (theta, phi, lambda).",
        "api_signature": "angles(self, unitary)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/one_qubit_decompose.py"
    },
    {
        "api_name": "angles_and_phase",
        "full_api_name": "OneQubitEulerDecomposer.angles_and_phase",
        "api_description": "Return the Euler angles and phase for input array.\n\nArgs:\n    unitary (np.ndarray): 2x2 unitary matrix.\n\nReturns:\n    tuple: (theta, phi, lambda, phase).",
        "api_signature": "angles_and_phase(self, unitary)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/one_qubit_decompose.py"
    },
    {
        "api_name": "decompose_cnotdihedral",
        "full_api_name": "decompose_cnotdihedral",
        "api_description": "DEPRECATED: Decompose a CNOTDihedral element into a QuantumCircuit.\n\nArgs:\n    elem (CNOTDihedral): a CNOTDihedral element.\nReturn:\n    QuantumCircuit: a circuit implementation of the CNOTDihedral element.\n\nReferences:\n    1. Shelly Garion and Andrew W. Cross, *Synthesis of CNOT-Dihedral circuits\n       with optimal number of two qubit gates*, `Quantum 4(369), 2020\n       <https://quantum-journal.org/papers/q-2020-12-07-369/>`_\n    2. Andrew W. Cross, Easwar Magesan, Lev S. Bishop, John A. Smolin and Jay M. Gambetta,\n       *Scalable randomised benchmarking of non-Clifford gates*,\n       npj Quantum Inf 2, 16012 (2016).",
        "api_signature": "decompose_cnotdihedral(elem)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/cnotdihedral_decompose.py"
    },
    {
        "api_name": "transform_to_magic_basis",
        "full_api_name": "transform_to_magic_basis",
        "api_description": "Transform the 4-by-4 matrix ``U`` into the magic basis.\n\nThis method internally uses non-normalized versions of the basis to minimize the floating-point\nerrors that arise during the transformation.\n\nArgs:\n    U (np.ndarray): 4-by-4 matrix to transform.\n    reverse (bool): Whether to do the transformation forwards (``B @ U @ B.conj().T``, the\n    default) or backwards (``B.conj().T @ U @ B``).\n\nReturns:\n    np.ndarray: The transformed 4-by-4 matrix.",
        "api_signature": "transform_to_magic_basis(U, reverse)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/weyl.py"
    },
    {
        "api_name": "weyl_coordinates",
        "full_api_name": "weyl_coordinates",
        "api_description": "Computes the Weyl coordinates for a given two-qubit unitary matrix.\n\nArgs:\n    U (np.ndarray): Input two-qubit unitary.\n\nReturns:\n    np.ndarray: Array of the 3 Weyl coordinates.",
        "api_signature": "weyl_coordinates(U)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/weyl.py"
    },
    {
        "api_name": "cnot_rxx_decompose",
        "full_api_name": "cnot_rxx_decompose",
        "api_description": "Decomposition of CNOT gate.\n\nNOTE: this differs to CNOT by a global phase.\nThe matrix returned is given by exp(1j * pi/4) * CNOT\n\nArgs:\n    plus_ry (bool): positive initial RY rotation\n    plus_rxx (bool): positive RXX rotation.\n\nReturns:\n    QuantumCircuit: The decomposed circuit for CNOT gate (up to\n    global phase).",
        "api_signature": "cnot_rxx_decompose(plus_ry, plus_rxx)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/ion_decompose.py"
    },
    {
        "api_name": "get_augmented_coordinate",
        "full_api_name": "get_augmented_coordinate",
        "api_description": "Assembles a coordinate in the system used by `xx_region_polytope`.",
        "api_signature": "get_augmented_coordinate(target_coordinate, strengths)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/xx_decompose/paths.py"
    },
    {
        "api_name": "decomposition_hop",
        "full_api_name": "decomposition_hop",
        "api_description": "Given a `target_coordinate` and a list of interaction `strengths`, produces a new canonical\ncoordinate which is one step back along `strengths`.\n\n`target_coordinate` is taken to be in positive canonical coordinates, and the entries of\nstrengths are taken to be [0, pi], so that (sj / 2, 0, 0) is a positive canonical coordinate.",
        "api_signature": "decomposition_hop(target_coordinate, strengths)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/xx_decompose/paths.py"
    },
    {
        "api_name": "_average_infidelity",
        "full_api_name": "_average_infidelity",
        "api_description": "Computes the infidelity distance between two points p, q expressed in positive canonical\ncoordinates.",
        "api_signature": "_average_infidelity(p, q)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/xx_decompose/decomposer.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "XXDecomposer.__init__",
        "api_description": "",
        "api_signature": "__init__(self, basis_fidelity, euler_basis, embodiments, backup_optimizer)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/xx_decompose/decomposer.py"
    },
    {
        "api_name": "_default_embodiment",
        "full_api_name": "XXDecomposer._default_embodiment",
        "api_description": "If the user does not provide a custom implementation of XX(strength), then this routine\ndefines a default implementation using RZX.",
        "api_signature": "_default_embodiment(strength)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/xx_decompose/decomposer.py"
    },
    {
        "api_name": "_check_embodiments",
        "full_api_name": "XXDecomposer._check_embodiments",
        "api_description": "Checks that `self.embodiments` is populated with legal circuit embodiments: the key-value\npair (angle, circuit) satisfies Operator(circuit) approx RXX(angle).to_matrix().",
        "api_signature": "_check_embodiments(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/xx_decompose/decomposer.py"
    },
    {
        "api_name": "_best_decomposition",
        "full_api_name": "XXDecomposer._best_decomposition",
        "api_description": "Finds the cheapest sequence of `available_strengths` which supports the best approximation\nto `canonical_coordinate`. Returns a dictionary with keys \"cost\", \"point\", and \"operations\".\n\nNOTE: `canonical_coordinate` is a positive canonical coordinate. `strengths` is a dictionary\n      mapping the available strengths to their (infidelity) costs, with the strengths\n      themselves normalized so that pi/2 represents CX = RZX(pi/2).",
        "api_signature": "_best_decomposition(canonical_coordinate, available_strengths)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/xx_decompose/decomposer.py"
    },
    {
        "api_name": "num_basis_gates",
        "full_api_name": "XXDecomposer.num_basis_gates",
        "api_description": "Counts the number of gates that would be emitted during re-synthesis.\n\nNOTE: Used by ConsolidateBlocks.",
        "api_signature": "num_basis_gates(self, unitary)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/xx_decompose/decomposer.py"
    },
    {
        "api_name": "_strength_to_infidelity",
        "full_api_name": "XXDecomposer._strength_to_infidelity",
        "api_description": "Converts a dictionary mapping XX strengths to fidelities to a dictionary mapping XX\nstrengths to infidelities. Also supports one of the other formats Qiskit uses: if only a\nlone float is supplied, it extends it from CX over CX/2 and CX/3 by linear decay.",
        "api_signature": "_strength_to_infidelity(basis_fidelity, approximate)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/xx_decompose/decomposer.py"
    },
    {
        "api_name": "__call__",
        "full_api_name": "XXDecomposer.__call__",
        "api_description": "Fashions a circuit which (perhaps `approximate`ly) models the special unitary operation\n`unitary`, using the circuit templates supplied at initialization as `embodiments`.  The\nroutine uses `basis_fidelity` to select the optimal circuit template, including when\nperforming exact synthesis; the contents of `basis_fidelity` is a dictionary mapping\ninteraction strengths (scaled so that CX = RZX(pi/2) corresponds to pi/2) to circuit\nfidelities.\n\nArgs:\n    unitary (Operator or ndarray): 4x4 unitary to synthesize.\n    basis_fidelity (dict or float): Fidelity of basis gates. Can be either (1) a dictionary\n        mapping XX angle values to fidelity at that angle; or (2) a single float f,\n        interpreted as {pi: f, pi/2: f/2, pi/3: f/3}.\n        If given, overrides the basis_fidelity given at init.\n    approximate (bool): Approximates if basis fidelities are less than 1.0 .\nReturns:\n    QuantumCircuit: Synthesized circuit.",
        "api_signature": "__call__(self, unitary, basis_fidelity, approximate)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/xx_decompose/decomposer.py"
    },
    {
        "api_name": "safe_arccos",
        "full_api_name": "safe_arccos",
        "api_description": "Computes arccos(n/d) with different (better?) numerical stability.",
        "api_signature": "safe_arccos(numerator, denominator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/xx_decompose/utilities.py"
    },
    {
        "api_name": "decompose_xxyy_into_xxyy_xx",
        "full_api_name": "decompose_xxyy_into_xxyy_xx",
        "api_description": "Consumes a target canonical interaction CAN(a_target, b_target) and source interactions\nCAN(a1, b1), CAN(a2), then manufactures a circuit identity of the form\n\nCAN(a_target, b_target) = (Zr, Zs) CAN(a_source, b_source) (Zu, Zv) CAN(interaction) (Zx, Zy).\n\nReturns the 6-tuple (r, s, u, v, x, y).",
        "api_signature": "decompose_xxyy_into_xxyy_xx(a_target, b_target, a_source, b_source, interaction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/xx_decompose/circuits.py"
    },
    {
        "api_name": "xx_circuit_step",
        "full_api_name": "xx_circuit_step",
        "api_description": "Builds a single step in an XX-based circuit.\n\n`source` and `target` are positive canonical coordinates; `strength` is the interaction strength\nat this step in the circuit as a canonical coordinate (so that CX = RZX(pi/2) corresponds to\npi/4); and `embodiment` is a Qiskit circuit which enacts the canonical gate of the prescribed\ninteraction `strength`.",
        "api_signature": "xx_circuit_step(source, strength, target, embodiment)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/xx_decompose/circuits.py"
    },
    {
        "api_name": "canonical_xx_circuit",
        "full_api_name": "canonical_xx_circuit",
        "api_description": "Assembles a Qiskit circuit from a specified `strength_sequence` of XX-type interactions which\nemulates the canonical gate at canonical coordinate `target`.  The circuits supplied by\n`basis_embodiments` are used to instantiate the individual XX actions.\n\nNOTE: The elements of `strength_sequence` are expected to be normalized so that np.pi/2\n    corresponds to RZX(np.pi/2) = CX; `target` is taken to be a positive canonical coordinate;\n    and `basis_embodiments` maps `strength_sequence` elements to circuits which instantiate\n    these gates.",
        "api_signature": "canonical_xx_circuit(target, strength_sequence, basis_embodiments)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/xx_decompose/circuits.py"
    },
    {
        "api_name": "apply_reflection",
        "full_api_name": "apply_reflection",
        "api_description": "Given a reflection type and a canonical coordinate, applies the reflection\nand describes a circuit which enacts the reflection + a global phase shift.",
        "api_signature": "apply_reflection(reflection_name, coordinate)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/xx_decompose/weyl.py"
    },
    {
        "api_name": "apply_shift",
        "full_api_name": "apply_shift",
        "api_description": "Given a shift type and a canonical coordinate, applies the shift and\ndescribes a circuit which enacts the shift + a global phase shift.",
        "api_signature": "apply_shift(shift_name, coordinate)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/xx_decompose/weyl.py"
    },
    {
        "api_name": "canonical_rotation_circuit",
        "full_api_name": "canonical_rotation_circuit",
        "api_description": "Given a pair of distinct indices 0 \u2264 (first_index, second_index) \u2264 2,\nproduces a two-qubit circuit which rotates a canonical gate\n\n    a0 XX + a1 YY + a2 ZZ\n\ninto\n\n    a[first] XX + a[second] YY + a[other] ZZ .",
        "api_signature": "canonical_rotation_circuit(first_index, second_index)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/xx_decompose/weyl.py"
    },
    {
        "api_name": "polytope_has_element",
        "full_api_name": "polytope_has_element",
        "api_description": "Tests whether `polytope` contains `point.",
        "api_signature": "polytope_has_element(polytope, point)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/xx_decompose/polytopes.py"
    },
    {
        "api_name": "manual_get_vertex",
        "full_api_name": "manual_get_vertex",
        "api_description": "Returns a single random vertex from `polytope`.",
        "api_signature": "manual_get_vertex(polytope, seed)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/xx_decompose/polytopes.py"
    },
    {
        "api_name": "from_strengths",
        "full_api_name": "XXPolytope.from_strengths",
        "api_description": "Constructs an XXPolytope from a sequence of strengths.",
        "api_signature": "from_strengths(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/xx_decompose/polytopes.py"
    },
    {
        "api_name": "add_strength",
        "full_api_name": "XXPolytope.add_strength",
        "api_description": "Returns a new XXPolytope with one new XX interaction appended.",
        "api_signature": "add_strength(self, new_strength)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/xx_decompose/polytopes.py"
    },
    {
        "api_name": "_offsets",
        "full_api_name": "XXPolytope._offsets",
        "api_description": "Returns b with A*x + b \u2265 0 iff x belongs to the XXPolytope.",
        "api_signature": "_offsets(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/xx_decompose/polytopes.py"
    },
    {
        "api_name": "member",
        "full_api_name": "XXPolytope.member",
        "api_description": "Returns True when `point` is a member of `self`.",
        "api_signature": "member(self, point)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/xx_decompose/polytopes.py"
    },
    {
        "api_name": "nearest",
        "full_api_name": "XXPolytope.nearest",
        "api_description": "Finds the nearest point (in Euclidean or infidelity distance) to `self`.",
        "api_signature": "nearest(self, point)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/synthesis/xx_decompose/polytopes.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ScalarOp.__init__",
        "api_description": "Initialize an operator object.\n\nArgs:\n    dims (int or tuple): subsystem dimensions.\n    coeff (Number): scalar coefficient for the identity\n                    operator (Default: 1).\n\nRaises:\n    QiskitError: If the optional coefficient is invalid.",
        "api_signature": "__init__(self, dims, coeff)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/scalar_op.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "ScalarOp.__array__",
        "api_description": "",
        "api_signature": "__array__(self, dtype)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/scalar_op.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "ScalarOp.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/scalar_op.py"
    },
    {
        "api_name": "coeff",
        "full_api_name": "ScalarOp.coeff",
        "api_description": "Return the coefficient",
        "api_signature": "coeff(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/scalar_op.py"
    },
    {
        "api_name": "conjugate",
        "full_api_name": "ScalarOp.conjugate",
        "api_description": "",
        "api_signature": "conjugate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/scalar_op.py"
    },
    {
        "api_name": "transpose",
        "full_api_name": "ScalarOp.transpose",
        "api_description": "",
        "api_signature": "transpose(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/scalar_op.py"
    },
    {
        "api_name": "is_unitary",
        "full_api_name": "ScalarOp.is_unitary",
        "api_description": "Return True if operator is a unitary matrix.",
        "api_signature": "is_unitary(self, atol, rtol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/scalar_op.py"
    },
    {
        "api_name": "to_matrix",
        "full_api_name": "ScalarOp.to_matrix",
        "api_description": "Convert to a Numpy matrix.",
        "api_signature": "to_matrix(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/scalar_op.py"
    },
    {
        "api_name": "to_operator",
        "full_api_name": "ScalarOp.to_operator",
        "api_description": "Convert to an Operator object.",
        "api_signature": "to_operator(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/scalar_op.py"
    },
    {
        "api_name": "compose",
        "full_api_name": "ScalarOp.compose",
        "api_description": "",
        "api_signature": "compose(self, other, qargs, front)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/scalar_op.py"
    },
    {
        "api_name": "power",
        "full_api_name": "ScalarOp.power",
        "api_description": "Return the power of the ScalarOp.\n\nArgs:\n    n (float): the exponent for the scalar op.\n\nReturns:\n    ScalarOp: the ``coeff ** n`` ScalarOp.",
        "api_signature": "power(self, n)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/scalar_op.py"
    },
    {
        "api_name": "tensor",
        "full_api_name": "ScalarOp.tensor",
        "api_description": "",
        "api_signature": "tensor(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/scalar_op.py"
    },
    {
        "api_name": "expand",
        "full_api_name": "ScalarOp.expand",
        "api_description": "",
        "api_signature": "expand(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/scalar_op.py"
    },
    {
        "api_name": "_add",
        "full_api_name": "ScalarOp._add",
        "api_description": "Return the operator self + other.\n\nIf ``qargs`` are specified the other operator will be added\nassuming it is identity on all other subsystems.\n\nArgs:\n    other (BaseOperator): an operator object.\n    qargs (None or list): optional subsystems to subtract on\n                          (Default: None)\n\nReturns:\n    ScalarOp: if other is an ScalarOp.\n    BaseOperator: if other is not an ScalarOp.\n\nRaises:\n    QiskitError: if other has incompatible dimensions.",
        "api_signature": "_add(self, other, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/scalar_op.py"
    },
    {
        "api_name": "_multiply",
        "full_api_name": "ScalarOp._multiply",
        "api_description": "Return the ScalarOp other * self.\n\nArgs:\n    other (Number): a complex number.\n\nReturns:\n    ScalarOp: the scaled identity operator other * self.\n\nRaises:\n    QiskitError: if other is not a valid complex number.",
        "api_signature": "_multiply(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/scalar_op.py"
    },
    {
        "api_name": "_pad_with_identity",
        "full_api_name": "ScalarOp._pad_with_identity",
        "api_description": "Pad another operator with identities.\n\nArgs:\n    current (BaseOperator): current operator.\n    other (BaseOperator): other operator.\n    qargs (None or list): qargs\n\nReturns:\n    BaseOperator: the padded operator.",
        "api_signature": "_pad_with_identity(current, other, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/scalar_op.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Operator.__init__",
        "api_description": "Initialize an operator object.\n\nArgs:\n    data (QuantumCircuit or Operation or BaseOperator or matrix):\n                        data to initialize operator.\n    input_dims (tuple): the input subsystem dimensions.\n                        [Default: None]\n    output_dims (tuple): the output subsystem dimensions.\n                         [Default: None]\n\nRaises:\n    QiskitError: if input data cannot be initialized as an operator.\n\nAdditional Information:\n    If the input or output dimensions are None, they will be\n    automatically determined from the input data. If the input data is\n    a Numpy array of shape (2**N, 2**N) qubit systems will be used. If\n    the input operator is not an N-qubit operator, it will assign a\n    single subsystem with dimension specified by the shape of the input.",
        "api_signature": "__init__(self, data, input_dims, output_dims)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/operator.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "Operator.__array__",
        "api_description": "",
        "api_signature": "__array__(self, dtype)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/operator.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "Operator.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/operator.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "Operator.__eq__",
        "api_description": "Test if two Operators are equal.",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/operator.py"
    },
    {
        "api_name": "data",
        "full_api_name": "Operator.data",
        "api_description": "The underlying Numpy array.",
        "api_signature": "data(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/operator.py"
    },
    {
        "api_name": "settings",
        "full_api_name": "Operator.settings",
        "api_description": "Return operator settings.",
        "api_signature": "settings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/operator.py"
    },
    {
        "api_name": "draw",
        "full_api_name": "Operator.draw",
        "api_description": "Return a visualization of the Operator.\n\n**repr**: String of the state's ``__repr__``.\n\n**text**: ASCII TextMatrix that can be printed in the console.\n\n**latex**: An IPython Latex object for displaying in Jupyter Notebooks.\n\n**latex_source**: Raw, uncompiled ASCII source to generate array using LaTeX.\n\nArgs:\n    output (str): Select the output method to use for drawing the\n        state. Valid choices are `repr`, `text`, `latex`, `latex_source`,\n        Default is `repr`.\n    drawer_args: Arguments to be passed directly to the relevant drawing\n        function or constructor (`TextMatrix()`, `array_to_latex()`).\n        See the relevant function under `qiskit.visualization` for that function's\n        documentation.\n\nReturns:\n    :class:`str` or :class:`TextMatrix` or :class:`IPython.display.Latex`:\n    Drawing of the Operator.\n\nRaises:\n    ValueError: when an invalid output method is selected.",
        "api_signature": "draw(self, output)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/operator.py"
    },
    {
        "api_name": "_ipython_display_",
        "full_api_name": "Operator._ipython_display_",
        "api_description": "",
        "api_signature": "_ipython_display_(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/operator.py"
    },
    {
        "api_name": "from_label",
        "full_api_name": "Operator.from_label",
        "api_description": "Return a tensor product of single-qubit operators.\n\nArgs:\n    label (string): single-qubit operator string.\n\nReturns:\n    Operator: The N-qubit operator.\n\nRaises:\n    QiskitError: if the label contains invalid characters, or the\n                 length of the label is larger than an explicitly\n                 specified num_qubits.\n\nAdditional Information:\n    The labels correspond to the single-qubit matrices:\n    'I': [[1, 0], [0, 1]]\n    'X': [[0, 1], [1, 0]]\n    'Y': [[0, -1j], [1j, 0]]\n    'Z': [[1, 0], [0, -1]]\n    'H': [[1, 1], [1, -1]] / sqrt(2)\n    'S': [[1, 0], [0 , 1j]]\n    'T': [[1, 0], [0, (1+1j) / sqrt(2)]]\n    '0': [[1, 0], [0, 0]]\n    '1': [[0, 0], [0, 1]]\n    '+': [[0.5, 0.5], [0.5 , 0.5]]\n    '-': [[0.5, -0.5], [-0.5 , 0.5]]\n    'r': [[0.5, -0.5j], [0.5j , 0.5]]\n    'l': [[0.5, 0.5j], [-0.5j , 0.5]]",
        "api_signature": "from_label(cls, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/operator.py"
    },
    {
        "api_name": "apply_permutation",
        "full_api_name": "Operator.apply_permutation",
        "api_description": "Modifies operator's data by composing it with a permutation.\n\nArgs:\n    perm (list): permutation pattern, describing which qubits\n        occupy the positions 0, 1, 2, etc. after applying the permutation.\n    front (bool): When set to ``True`` the permutation is applied before the\n        operator, when set to ``False`` the permutation is applied after the\n        operator.\nReturns:\n    Operator: The modified operator.\n\nRaises:\n    QiskitError: if the size of the permutation pattern does not match the\n        dimensions of the operator.",
        "api_signature": "apply_permutation(self, perm, front)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/operator.py"
    },
    {
        "api_name": "from_circuit",
        "full_api_name": "Operator.from_circuit",
        "api_description": "Create a new Operator object from a :class:`.QuantumCircuit`\n\nWhile a :class:`~.QuantumCircuit` object can passed directly as ``data``\nto the class constructor this provides no options on how the circuit\nis used to create an :class:`.Operator`. This constructor method lets\nyou control how the :class:`.Operator` is created so it can be adjusted\nfor a particular use case.\n\nBy default this constructor method will permute the qubits based on a\nconfigured initial layout (i.e. after it was transpiled). It also\nprovides an option to manually provide a :class:`.Layout` object\ndirectly.\n\nArgs:\n    circuit (QuantumCircuit): The :class:`.QuantumCircuit` to create an Operator\n        object from.\n    ignore_set_layout (bool): When set to ``True`` if the input ``circuit``\n        has a layout set it will be ignored\n    layout (Layout): If specified this kwarg can be used to specify a\n        particular layout to use to permute the qubits in the created\n        :class:`.Operator`. If this is specified it will be used instead\n        of a layout contained in the ``circuit`` input. If specified\n        the virtual bits in the :class:`~.Layout` must be present in the\n        ``circuit`` input.\n    final_layout (Layout): If specified this kwarg can be used to represent the\n        output permutation caused by swap insertions during the routing stage\n        of the transpiler.\nReturns:\n    Operator: An operator representing the input circuit",
        "api_signature": "from_circuit(cls, circuit, ignore_set_layout, layout, final_layout)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/operator.py"
    },
    {
        "api_name": "is_unitary",
        "full_api_name": "Operator.is_unitary",
        "api_description": "Return True if operator is a unitary matrix.",
        "api_signature": "is_unitary(self, atol, rtol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/operator.py"
    },
    {
        "api_name": "to_operator",
        "full_api_name": "Operator.to_operator",
        "api_description": "Convert operator to matrix operator class",
        "api_signature": "to_operator(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/operator.py"
    },
    {
        "api_name": "to_instruction",
        "full_api_name": "Operator.to_instruction",
        "api_description": "Convert to a UnitaryGate instruction.",
        "api_signature": "to_instruction(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/operator.py"
    },
    {
        "api_name": "conjugate",
        "full_api_name": "Operator.conjugate",
        "api_description": "",
        "api_signature": "conjugate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/operator.py"
    },
    {
        "api_name": "transpose",
        "full_api_name": "Operator.transpose",
        "api_description": "",
        "api_signature": "transpose(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/operator.py"
    },
    {
        "api_name": "compose",
        "full_api_name": "Operator.compose",
        "api_description": "",
        "api_signature": "compose(self, other, qargs, front)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/operator.py"
    },
    {
        "api_name": "power",
        "full_api_name": "Operator.power",
        "api_description": "Return the matrix power of the operator.\n\nArgs:\n    n (float): the power to raise the matrix to.\n\nReturns:\n    Operator: the resulting operator ``O ** n``.\n\nRaises:\n    QiskitError: if the input and output dimensions of the operator\n                 are not equal.",
        "api_signature": "power(self, n)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/operator.py"
    },
    {
        "api_name": "tensor",
        "full_api_name": "Operator.tensor",
        "api_description": "",
        "api_signature": "tensor(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/operator.py"
    },
    {
        "api_name": "expand",
        "full_api_name": "Operator.expand",
        "api_description": "",
        "api_signature": "expand(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/operator.py"
    },
    {
        "api_name": "_tensor",
        "full_api_name": "Operator._tensor",
        "api_description": "",
        "api_signature": "_tensor(cls, a, b)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/operator.py"
    },
    {
        "api_name": "_add",
        "full_api_name": "Operator._add",
        "api_description": "Return the operator self + other.\n\nIf ``qargs`` are specified the other operator will be added\nassuming it is identity on all other subsystems.\n\nArgs:\n    other (Operator): an operator object.\n    qargs (None or list): optional subsystems to add on\n                          (Default: None)\n\nReturns:\n    Operator: the operator self + other.\n\nRaises:\n    QiskitError: if other is not an operator, or has incompatible\n                 dimensions.",
        "api_signature": "_add(self, other, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/operator.py"
    },
    {
        "api_name": "_multiply",
        "full_api_name": "Operator._multiply",
        "api_description": "Return the operator self * other.\n\nArgs:\n    other (complex): a complex number.\n\nReturns:\n    Operator: the operator other * self.\n\nRaises:\n    QiskitError: if other is not a valid complex number.",
        "api_signature": "_multiply(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/operator.py"
    },
    {
        "api_name": "equiv",
        "full_api_name": "Operator.equiv",
        "api_description": "Return True if operators are equivalent up to global phase.\n\nArgs:\n    other (Operator): an operator object.\n    rtol (float): relative tolerance value for comparison.\n    atol (float): absolute tolerance value for comparison.\n\nReturns:\n    bool: True if operators are equivalent up to global phase.",
        "api_signature": "equiv(self, other, rtol, atol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/operator.py"
    },
    {
        "api_name": "reverse_qargs",
        "full_api_name": "Operator.reverse_qargs",
        "api_description": "Return an Operator with reversed subsystem ordering.\n\nFor a tensor product operator this is equivalent to reversing\nthe order of tensor product subsystems. For an operator\n:math:`A = A_{n-1} \\otimes ... \\otimes A_0`\nthe returned operator will be\n:math:`A_0 \\otimes ... \\otimes A_{n-1}`.\n\nReturns:\n    Operator: the operator with reversed subsystem order.",
        "api_signature": "reverse_qargs(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/operator.py"
    },
    {
        "api_name": "to_matrix",
        "full_api_name": "Operator.to_matrix",
        "api_description": "Convert operator to NumPy matrix.",
        "api_signature": "to_matrix(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/operator.py"
    },
    {
        "api_name": "_einsum_matmul",
        "full_api_name": "Operator._einsum_matmul",
        "api_description": "Perform a contraction using Numpy.einsum\n\nArgs:\n    tensor (np.array): a vector or matrix reshaped to a rank-N tensor.\n    mat (np.array): a matrix reshaped to a rank-2M tensor.\n    indices (list): tensor indices to contract with mat.\n    shift (int): shift for indices of tensor to contract [Default: 0].\n    right_mul (bool): if True right multiply tensor by mat\n                      (else left multiply) [Default: False].\n\nReturns:\n    Numpy.ndarray: the matrix multiplied rank-N tensor.\n\nRaises:\n    QiskitError: if mat is not an even rank tensor.",
        "api_signature": "_einsum_matmul(cls, tensor, mat, indices, shift, right_mul)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/operator.py"
    },
    {
        "api_name": "_init_instruction",
        "full_api_name": "Operator._init_instruction",
        "api_description": "Convert a QuantumCircuit or Operation to an Operator.",
        "api_signature": "_init_instruction(cls, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/operator.py"
    },
    {
        "api_name": "_instruction_to_matrix",
        "full_api_name": "Operator._instruction_to_matrix",
        "api_description": "Return Operator for instruction if defined or None otherwise.",
        "api_signature": "_instruction_to_matrix(cls, obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/operator.py"
    },
    {
        "api_name": "_append_instruction",
        "full_api_name": "Operator._append_instruction",
        "api_description": "Update the current Operator by apply an instruction.",
        "api_signature": "_append_instruction(self, obj, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/operator.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BaseOperator.__init__",
        "api_description": "Initialize a BaseOperator shape\n\nArgs:\n    input_dims (tuple or int or None): Optional, input dimensions.\n    output_dims (tuple or int or None): Optional, output dimensions.\n    num_qubits (int): Optional, the number of qubits of the operator.\n    shape (tuple): Optional, matrix shape for automatically determining\n                   qubit dimensions.\n    op_shape (OpShape): Optional, an OpShape object for operator dimensions.\n\n.. note::\n\n    If `op_shape`` is specified it will take precedence over other\n    kwargs.",
        "api_signature": "__init__(self, input_dims, output_dims, num_qubits, shape, op_shape)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/base_operator.py"
    },
    {
        "api_name": "__call__",
        "full_api_name": "BaseOperator.__call__",
        "api_description": "Return a shallow copy with qargs attribute set",
        "api_signature": "__call__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/base_operator.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "BaseOperator.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/base_operator.py"
    },
    {
        "api_name": "qargs",
        "full_api_name": "BaseOperator.qargs",
        "api_description": "Return the qargs for the operator.",
        "api_signature": "qargs(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/base_operator.py"
    },
    {
        "api_name": "dim",
        "full_api_name": "BaseOperator.dim",
        "api_description": "Return tuple (input_shape, output_shape).",
        "api_signature": "dim(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/base_operator.py"
    },
    {
        "api_name": "num_qubits",
        "full_api_name": "BaseOperator.num_qubits",
        "api_description": "Return the number of qubits if a N-qubit operator or None otherwise.",
        "api_signature": "num_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/base_operator.py"
    },
    {
        "api_name": "_input_dim",
        "full_api_name": "BaseOperator._input_dim",
        "api_description": "Return the total input dimension.",
        "api_signature": "_input_dim(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/base_operator.py"
    },
    {
        "api_name": "_output_dim",
        "full_api_name": "BaseOperator._output_dim",
        "api_description": "Return the total input dimension.",
        "api_signature": "_output_dim(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/base_operator.py"
    },
    {
        "api_name": "reshape",
        "full_api_name": "BaseOperator.reshape",
        "api_description": "Return a shallow copy with reshaped input and output subsystem dimensions.\n\nArgs:\n    input_dims (None or tuple): new subsystem input dimensions.\n        If None the original input dims will be preserved [Default: None].\n    output_dims (None or tuple): new subsystem output dimensions.\n        If None the original output dims will be preserved [Default: None].\n    num_qubits (None or int): reshape to an N-qubit operator [Default: None].\n\nReturns:\n    BaseOperator: returns self with reshaped input and output dimensions.\n\nRaises:\n    QiskitError: if combined size of all subsystem input dimension or\n                 subsystem output dimensions is not constant.",
        "api_signature": "reshape(self, input_dims, output_dims, num_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/base_operator.py"
    },
    {
        "api_name": "input_dims",
        "full_api_name": "BaseOperator.input_dims",
        "api_description": "Return tuple of input dimension for specified subsystems.",
        "api_signature": "input_dims(self, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/base_operator.py"
    },
    {
        "api_name": "output_dims",
        "full_api_name": "BaseOperator.output_dims",
        "api_description": "Return tuple of output dimension for specified subsystems.",
        "api_signature": "output_dims(self, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/base_operator.py"
    },
    {
        "api_name": "copy",
        "full_api_name": "BaseOperator.copy",
        "api_description": "Make a deep copy of current operator.",
        "api_signature": "copy(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/base_operator.py"
    },
    {
        "api_name": "matrix_equal",
        "full_api_name": "matrix_equal",
        "api_description": "",
        "api_signature": "matrix_equal(mat1, mat2, ignore_phase, rtol, atol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/predicates.py"
    },
    {
        "api_name": "is_square_matrix",
        "full_api_name": "is_square_matrix",
        "api_description": "Test if an array is a square matrix.",
        "api_signature": "is_square_matrix(mat)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/predicates.py"
    },
    {
        "api_name": "is_diagonal_matrix",
        "full_api_name": "is_diagonal_matrix",
        "api_description": "Test if an array is a diagonal matrix",
        "api_signature": "is_diagonal_matrix(mat, rtol, atol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/predicates.py"
    },
    {
        "api_name": "is_symmetric_matrix",
        "full_api_name": "is_symmetric_matrix",
        "api_description": "Test if an array is a symmetric matrix",
        "api_signature": "is_symmetric_matrix(op, rtol, atol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/predicates.py"
    },
    {
        "api_name": "is_hermitian_matrix",
        "full_api_name": "is_hermitian_matrix",
        "api_description": "Test if an array is a Hermitian matrix",
        "api_signature": "is_hermitian_matrix(mat, rtol, atol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/predicates.py"
    },
    {
        "api_name": "is_positive_semidefinite_matrix",
        "full_api_name": "is_positive_semidefinite_matrix",
        "api_description": "Test if a matrix is positive semidefinite",
        "api_signature": "is_positive_semidefinite_matrix(mat, rtol, atol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/predicates.py"
    },
    {
        "api_name": "is_identity_matrix",
        "full_api_name": "is_identity_matrix",
        "api_description": "Test if an array is an identity matrix.",
        "api_signature": "is_identity_matrix(mat, ignore_phase, rtol, atol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/predicates.py"
    },
    {
        "api_name": "is_unitary_matrix",
        "full_api_name": "is_unitary_matrix",
        "api_description": "Test if an array is a unitary matrix.",
        "api_signature": "is_unitary_matrix(mat, rtol, atol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/predicates.py"
    },
    {
        "api_name": "is_isometry",
        "full_api_name": "is_isometry",
        "api_description": "Test if an array is an isometry.",
        "api_signature": "is_isometry(mat, rtol, atol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/predicates.py"
    },
    {
        "api_name": "random_unitary",
        "full_api_name": "random_unitary",
        "api_description": "Return a random unitary Operator.\n\nThe operator is sampled from the unitary Haar measure.\n\nArgs:\n    dims (int or tuple): the input dimensions of the Operator.\n    seed (int or np.random.Generator): Optional. Set a fixed seed or\n                                       generator for RNG.\n\nReturns:\n    Operator: a unitary operator.",
        "api_signature": "random_unitary(dims, seed)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/random.py"
    },
    {
        "api_name": "random_hermitian",
        "full_api_name": "random_hermitian",
        "api_description": "Return a random hermitian Operator.\n\nThe operator is sampled from Gaussian Unitary Ensemble.\n\nArgs:\n    dims (int or tuple): the input dimension of the Operator.\n    traceless (bool): Optional. If True subtract diagonal entries to\n                      return a traceless hermitian operator\n                      (Default: False).\n    seed (int or np.random.Generator): Optional. Set a fixed seed or\n                                       generator for RNG.\n\nReturns:\n    Operator: a Hermitian operator.",
        "api_signature": "random_hermitian(dims, traceless, seed)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/random.py"
    },
    {
        "api_name": "random_quantum_channel",
        "full_api_name": "random_quantum_channel",
        "api_description": "Return a random CPTP quantum channel.\n\nThis constructs the Stinespring operator for the quantum channel by\nsampling a random isometry from the unitary Haar measure.\n\nArgs:\n    input_dims (int or tuple): the input dimension of the channel.\n    output_dims (int or tuple): the input dimension of the channel.\n    rank (int): Optional. The rank of the quantum channel Choi-matrix.\n    seed (int or np.random.Generator): Optional. Set a fixed seed or\n                                       generator for RNG.\n\nReturns:\n    Stinespring: a quantum channel operator.\n\nRaises:\n    QiskitError: if rank or dimensions are invalid.",
        "api_signature": "random_quantum_channel(input_dims, output_dims, rank, seed)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/random.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "OpShape.__init__",
        "api_description": "Initialize an operator object.",
        "api_signature": "__init__(self, dims_l, dims_r, num_qargs_l, num_qargs_r)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/op_shape.py"
    },
    {
        "api_name": "settings",
        "full_api_name": "OpShape.settings",
        "api_description": "Return the settings of the ``OpShape`` as dictionary.",
        "api_signature": "settings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/op_shape.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "OpShape.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/op_shape.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "OpShape.__eq__",
        "api_description": "Check types and subsystem dimensions are equal",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/op_shape.py"
    },
    {
        "api_name": "copy",
        "full_api_name": "OpShape.copy",
        "api_description": "Make a deep copy of current operator.",
        "api_signature": "copy(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/op_shape.py"
    },
    {
        "api_name": "size",
        "full_api_name": "OpShape.size",
        "api_description": "Return the combined dimensions of the object",
        "api_signature": "size(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/op_shape.py"
    },
    {
        "api_name": "num_qubits",
        "full_api_name": "OpShape.num_qubits",
        "api_description": "Return number of qubits if shape is N-qubit.\n\nIf Shape is not N-qubit return None",
        "api_signature": "num_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/op_shape.py"
    },
    {
        "api_name": "num_qargs",
        "full_api_name": "OpShape.num_qargs",
        "api_description": "Return a tuple of the number of left and right wires",
        "api_signature": "num_qargs(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/op_shape.py"
    },
    {
        "api_name": "shape",
        "full_api_name": "OpShape.shape",
        "api_description": "Return a tuple of the matrix shape",
        "api_signature": "shape(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/op_shape.py"
    },
    {
        "api_name": "tensor_shape",
        "full_api_name": "OpShape.tensor_shape",
        "api_description": "Return a tuple of the tensor shape",
        "api_signature": "tensor_shape(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/op_shape.py"
    },
    {
        "api_name": "is_square",
        "full_api_name": "OpShape.is_square",
        "api_description": "Return True if the left and right dimensions are equal.",
        "api_signature": "is_square(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/op_shape.py"
    },
    {
        "api_name": "dims_r",
        "full_api_name": "OpShape.dims_r",
        "api_description": "Return tuple of input dimension for specified subsystems.",
        "api_signature": "dims_r(self, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/op_shape.py"
    },
    {
        "api_name": "dims_l",
        "full_api_name": "OpShape.dims_l",
        "api_description": "Return tuple of output dimension for specified subsystems.",
        "api_signature": "dims_l(self, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/op_shape.py"
    },
    {
        "api_name": "_dim_r",
        "full_api_name": "OpShape._dim_r",
        "api_description": "Return the total input dimension.",
        "api_signature": "_dim_r(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/op_shape.py"
    },
    {
        "api_name": "_dim_l",
        "full_api_name": "OpShape._dim_l",
        "api_description": "Return the total input dimension.",
        "api_signature": "_dim_l(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/op_shape.py"
    },
    {
        "api_name": "validate_shape",
        "full_api_name": "OpShape.validate_shape",
        "api_description": "Raise an exception if shape is not valid for the OpShape",
        "api_signature": "validate_shape(self, shape)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/op_shape.py"
    },
    {
        "api_name": "_validate",
        "full_api_name": "OpShape._validate",
        "api_description": "Validate OpShape against a matrix or vector shape.",
        "api_signature": "_validate(self, shape, raise_exception)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/op_shape.py"
    },
    {
        "api_name": "auto",
        "full_api_name": "OpShape.auto",
        "api_description": "Construct TensorShape with automatic checking of qubit dimensions",
        "api_signature": "auto(cls, shape, dims_l, dims_r, dims, num_qubits_l, num_qubits_r, num_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/op_shape.py"
    },
    {
        "api_name": "subset",
        "full_api_name": "OpShape.subset",
        "api_description": "Return the reduced OpShape of the specified qargs",
        "api_signature": "subset(self, qargs, qargs_l, qargs_r)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/op_shape.py"
    },
    {
        "api_name": "remove",
        "full_api_name": "OpShape.remove",
        "api_description": "Return a new :class:`OpShape` with the specified qargs removed",
        "api_signature": "remove(self, qargs, qargs_l, qargs_r)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/op_shape.py"
    },
    {
        "api_name": "reverse",
        "full_api_name": "OpShape.reverse",
        "api_description": "Reverse order of left and right qargs",
        "api_signature": "reverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/op_shape.py"
    },
    {
        "api_name": "transpose",
        "full_api_name": "OpShape.transpose",
        "api_description": "Return the transposed OpShape.",
        "api_signature": "transpose(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/op_shape.py"
    },
    {
        "api_name": "tensor",
        "full_api_name": "OpShape.tensor",
        "api_description": "Return the tensor product OpShape",
        "api_signature": "tensor(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/op_shape.py"
    },
    {
        "api_name": "expand",
        "full_api_name": "OpShape.expand",
        "api_description": "Return the expand product OpShape",
        "api_signature": "expand(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/op_shape.py"
    },
    {
        "api_name": "_tensor",
        "full_api_name": "OpShape._tensor",
        "api_description": "Return the tensor product OpShape",
        "api_signature": "_tensor(cls, a, b)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/op_shape.py"
    },
    {
        "api_name": "compose",
        "full_api_name": "OpShape.compose",
        "api_description": "Return composed OpShape.",
        "api_signature": "compose(self, other, qargs, front)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/op_shape.py"
    },
    {
        "api_name": "dot",
        "full_api_name": "OpShape.dot",
        "api_description": "Return the dot product operator OpShape",
        "api_signature": "dot(self, other, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/op_shape.py"
    },
    {
        "api_name": "_validate_add",
        "full_api_name": "OpShape._validate_add",
        "api_description": "",
        "api_signature": "_validate_add(self, other, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/op_shape.py"
    },
    {
        "api_name": "process_fidelity",
        "full_api_name": "process_fidelity",
        "api_description": "Return the process fidelity of a noisy quantum channel.\n\n\nThe process fidelity :math:`F_{\\text{pro}}(\\mathcal{E}, \\mathcal{F})`\nbetween two quantum channels :math:`\\mathcal{E}, \\mathcal{F}` is given by\n\n.. math::\n    F_{\\text{pro}}(\\mathcal{E}, \\mathcal{F})\n        = F(\\rho_{\\mathcal{E}}, \\rho_{\\mathcal{F}})\n\nwhere :math:`F` is the :func:`~qiskit.quantum_info.state_fidelity`,\n:math:`\\rho_{\\mathcal{E}} = \\Lambda_{\\mathcal{E}} / d` is the\nnormalized :class:`~qiskit.quantum_info.Choi` matrix for the channel\n:math:`\\mathcal{E}`, and :math:`d` is the input dimension of\n:math:`\\mathcal{E}`.\n\nWhen the target channel is unitary this is equivalent to\n\n.. math::\n    F_{\\text{pro}}(\\mathcal{E}, U)\n        = \\frac{Tr[S_U^\\dagger S_{\\mathcal{E}}]}{d^2}\n\nwhere :math:`S_{\\mathcal{E}}, S_{U}` are the\n:class:`~qiskit.quantum_info.SuperOp` matrices for the *input* quantum\nchannel :math:`\\mathcal{E}` and *target* unitary :math:`U` respectively,\nand :math:`d` is the input dimension of the channel.\n\nArgs:\n    channel (Operator or QuantumChannel): input quantum channel.\n    target (Operator or QuantumChannel or None): target quantum channel.\n        If `None` target is the identity operator [Default: None].\n    require_cp (bool): check if input and target channels are\n                       completely-positive and if non-CP log warning\n                       containing negative eigenvalues of Choi-matrix\n                       [Default: True].\n    require_tp (bool): check if input and target channels are\n                       trace-preserving and if non-TP log warning\n                       containing negative eigenvalues of partial\n                       Choi-matrix :math:`Tr_{\\mbox{out}}[\\mathcal{E}] - I`\n                       [Default: True].\n\nReturns:\n    float: The process fidelity :math:`F_{\\text{pro}}`.\n\nRaises:\n    QiskitError: if the channel and target do not have the same dimensions.",
        "api_signature": "process_fidelity(channel, target, require_cp, require_tp)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/measures.py"
    },
    {
        "api_name": "average_gate_fidelity",
        "full_api_name": "average_gate_fidelity",
        "api_description": "Return the average gate fidelity of a noisy quantum channel.\n\nThe average gate fidelity :math:`F_{\\text{ave}}` is given by\n\n.. math::\n    F_{\\text{ave}}(\\mathcal{E}, U)\n        &= \\int d\\psi \\langle\\psi|U^\\dagger\n            \\mathcal{E}(|\\psi\\rangle\\!\\langle\\psi|)U|\\psi\\rangle \\\\\n        &= \\frac{d F_{\\text{pro}}(\\mathcal{E}, U) + 1}{d + 1}\n\nwhere :math:`F_{\\text{pro}}(\\mathcal{E}, U)` is the\n:meth:`~qiskit.quantum_info.process_fidelity` of the input quantum\n*channel* :math:`\\mathcal{E}` with a *target* unitary :math:`U`, and\n:math:`d` is the dimension of the *channel*.\n\nArgs:\n    channel (QuantumChannel or Operator): noisy quantum channel.\n    target (Operator or None): target unitary operator.\n        If `None` target is the identity operator [Default: None].\n    require_cp (bool): check if input and target channels are\n                       completely-positive and if non-CP log warning\n                       containing negative eigenvalues of Choi-matrix\n                       [Default: True].\n    require_tp (bool): check if input and target channels are\n                       trace-preserving and if non-TP log warning\n                       containing negative eigenvalues of partial\n                       Choi-matrix :math:`Tr_{\\mbox{out}}[\\mathcal{E}] - I`\n                       [Default: True].\n\nReturns:\n    float: The average gate fidelity :math:`F_{\\text{ave}}`.\n\nRaises:\n    QiskitError: if the channel and target do not have the same dimensions,\n                 or have different input and output dimensions.",
        "api_signature": "average_gate_fidelity(channel, target, require_cp, require_tp)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/measures.py"
    },
    {
        "api_name": "gate_error",
        "full_api_name": "gate_error",
        "api_description": "Return the gate error of a noisy quantum channel.\n\nThe gate error :math:`E` is given by the average gate infidelity\n\n.. math::\n    E(\\mathcal{E}, U) = 1 - F_{\\text{ave}}(\\mathcal{E}, U)\n\nwhere :math:`F_{\\text{ave}}(\\mathcal{E}, U)` is the\n:meth:`~qiskit.quantum_info.average_gate_fidelity` of the input\nquantum *channel* :math:`\\mathcal{E}` with a *target* unitary\n:math:`U`.\n\nArgs:\n    channel (QuantumChannel): noisy quantum channel.\n    target (Operator or None): target unitary operator.\n        If `None` target is the identity operator [Default: None].\n    require_cp (bool): check if input and target channels are\n                       completely-positive and if non-CP log warning\n                       containing negative eigenvalues of Choi-matrix\n                       [Default: True].\n    require_tp (bool): check if input and target channels are\n                       trace-preserving and if non-TP log warning\n                       containing negative eigenvalues of partial\n                       Choi-matrix :math:`Tr_{\\mbox{out}}[\\mathcal{E}] - I`\n                       [Default: True].\n\nReturns:\n    float: The average gate error :math:`E`.\n\nRaises:\n    QiskitError: if the channel and target do not have the same dimensions,\n                 or have different input and output dimensions.",
        "api_signature": "gate_error(channel, target, require_cp, require_tp)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/measures.py"
    },
    {
        "api_name": "diamond_norm",
        "full_api_name": "diamond_norm",
        "api_description": "Return the diamond norm of the input quantum channel object.\n\nThis function computes the completely-bounded trace-norm (often\nreferred to as the diamond-norm) of the input quantum channel object\nusing the semidefinite-program from reference [1].\n\nArgs:\n    choi(Choi or QuantumChannel): a quantum channel object or\n                                  Choi-matrix array.\n    solver (str): The solver to use.\n    kwargs: optional arguments to pass to CVXPY solver.\n\nReturns:\n    float: The completely-bounded trace norm :math:`\\|\\mathcal{E}\\|_{\\diamond}`.\n\nRaises:\n    QiskitError: if CVXPY package cannot be found.\n\nAdditional Information:\n    The input to this function is typically *not* a CPTP quantum\n    channel, but rather the *difference* between two quantum channels\n    :math:`\\|\\Delta\\mathcal{E}\\|_\\diamond` where\n    :math:`\\Delta\\mathcal{E} = \\mathcal{E}_1 - \\mathcal{E}_2`.\n\nReference:\n    J. Watrous. \"Simpler semidefinite programs for completely bounded\n    norms\", arXiv:1207.5726 [quant-ph] (2012).\n\n.. note::\n\n    This function requires the optional CVXPY package to be installed.\n    Any additional kwargs will be passed to the ``cvxpy.solve``\n    function. See the CVXPY documentation for information on available\n    SDP solvers.",
        "api_signature": "diamond_norm(choi, solver)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/measures.py"
    },
    {
        "api_name": "cvx_bmat",
        "full_api_name": "cvx_bmat",
        "api_description": "Block matrix for embedding complex matrix in reals",
        "api_signature": "cvx_bmat(mat_r, mat_i)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/measures.py"
    },
    {
        "api_name": "_cvxpy_check",
        "full_api_name": "_cvxpy_check",
        "api_description": "Check that a supported CVXPY version is installed",
        "api_signature": "_cvxpy_check(name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/measures.py"
    },
    {
        "api_name": "_input_formatter",
        "full_api_name": "_input_formatter",
        "api_description": "Formatting function for input conversion",
        "api_signature": "_input_formatter(obj, fallback_class, func_name, arg_name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/measures.py"
    },
    {
        "api_name": "_cp_condition",
        "full_api_name": "_cp_condition",
        "api_description": "Return Choi-matrix eigenvalues for checking if channel is CP",
        "api_signature": "_cp_condition(channel)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/measures.py"
    },
    {
        "api_name": "_tp_condition",
        "full_api_name": "_tp_condition",
        "api_description": "Return partial tr Choi-matrix eigenvalues for checking if channel is TP",
        "api_signature": "_tp_condition(channel)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/measures.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CustomIterator.__init__",
        "api_description": "",
        "api_signature": "__init__(self, obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/custom_iterator.py"
    },
    {
        "api_name": "__getitem__",
        "full_api_name": "CustomIterator.__getitem__",
        "api_description": "Get next item",
        "api_signature": "__getitem__(self, key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/custom_iterator.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "CustomIterator.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/custom_iterator.py"
    },
    {
        "api_name": "__len__",
        "full_api_name": "CustomIterator.__len__",
        "api_description": "",
        "api_signature": "__len__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/custom_iterator.py"
    },
    {
        "api_name": "__iter__",
        "full_api_name": "CustomIterator.__iter__",
        "api_description": "",
        "api_signature": "__iter__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/custom_iterator.py"
    },
    {
        "api_name": "__next__",
        "full_api_name": "CustomIterator.__next__",
        "api_description": "",
        "api_signature": "__next__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/custom_iterator.py"
    },
    {
        "api_name": "double_commutator",
        "full_api_name": "double_commutator",
        "api_description": "Compute symmetric double commutator of a, b and c.\n\nSee also Equation (13.6.18) in [1].\n\nIf `commutator` is `True`, it returns\n\n.. math::\n\n     [[A, B], C]/2 + [A, [B, C]]/2\n     = (2ABC + 2CBA - BAC - CAB - ACB - BCA)/2.\n\nIf `commutator` is `False`, it returns\n\n.. math::\n     \\lbrace[A, B], C\\rbrace/2 + \\lbrace A, [B, C]\\rbrace/2\n     = (2ABC - 2CBA - BAC + CAB - ACB + BCA)/2.\n\nArgs:\n    a: Operator a.\n    b: Operator b.\n    c: Operator c.\n    commutator: If ``True`` compute the double commutator,\n        if ``False`` the double anti-commutator.\n\nReturns:\n    The double commutator\n\nReferences:\n\n    [1]: R. McWeeny.\n        Methods of Molecular Quantum Mechanics.\n        2nd Edition, Academic Press, 1992.\n        ISBN 0-12-486552-6.",
        "api_signature": "double_commutator(a, b, c)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/utils/double_commutator.py"
    },
    {
        "api_name": "anti_commutator",
        "full_api_name": "anti_commutator",
        "api_description": "Compute anti-commutator of a and b.\n\n.. math::\n\n    ab + ba.\n\nArgs:\n    a: Operator a.\n    b: Operator b.\nReturns:\n    The anti-commutator",
        "api_signature": "anti_commutator(a, b)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/utils/anti_commutator.py"
    },
    {
        "api_name": "commutator",
        "full_api_name": "commutator",
        "api_description": "Compute commutator of a and b.\n\n.. math::\n\n    ab - ba.\n\nArgs:\n    a: Operator a.\n    b: Operator b.\nReturns:\n    The commutator",
        "api_signature": "commutator(a, b)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/utils/commutator.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QuantumChannel.__init__",
        "api_description": "Initialize a quantum channel Superoperator operator.\n\nArgs:\n    data (array or list): quantum channel data array.\n    op_shape (OpShape): the operator shape of the channel.\n    num_qubits (int): the number of qubits if the channel is N-qubit.\n\nRaises:\n    QiskitError: if arguments are invalid.",
        "api_signature": "__init__(self, data, num_qubits, op_shape)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/quantum_channel.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "QuantumChannel.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/quantum_channel.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "QuantumChannel.__eq__",
        "api_description": "Test if two QuantumChannels are equal.",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/quantum_channel.py"
    },
    {
        "api_name": "data",
        "full_api_name": "QuantumChannel.data",
        "api_description": "Return data.",
        "api_signature": "data(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/quantum_channel.py"
    },
    {
        "api_name": "_channel_rep",
        "full_api_name": "QuantumChannel._channel_rep",
        "api_description": "Return channel representation string",
        "api_signature": "_channel_rep(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/quantum_channel.py"
    },
    {
        "api_name": "settings",
        "full_api_name": "QuantumChannel.settings",
        "api_description": "Return settings.",
        "api_signature": "settings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/quantum_channel.py"
    },
    {
        "api_name": "conjugate",
        "full_api_name": "QuantumChannel.conjugate",
        "api_description": "Return the conjugate quantum channel.\n\n.. note::\n    This is equivalent to the matrix complex conjugate in the\n    :class:`~qiskit.quantum_info.SuperOp` representation\n    ie. for a channel :math:`\\mathcal{E}`, the SuperOp of\n    the conjugate channel :math:`\\overline{{\\mathcal{{E}}}}` is\n    :math:`S_{\\overline{\\mathcal{E}^\\dagger}} = \\overline{S_{\\mathcal{E}}}`.",
        "api_signature": "conjugate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/quantum_channel.py"
    },
    {
        "api_name": "transpose",
        "full_api_name": "QuantumChannel.transpose",
        "api_description": "Return the transpose quantum channel.\n\n.. note::\n    This is equivalent to the matrix transpose in the\n    :class:`~qiskit.quantum_info.SuperOp` representation,\n    ie. for a channel :math:`\\mathcal{E}`, the SuperOp of\n    the transpose channel :math:`\\mathcal{{E}}^T` is\n    :math:`S_{mathcal{E}^T} = S_{\\mathcal{E}}^T`.",
        "api_signature": "transpose(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/quantum_channel.py"
    },
    {
        "api_name": "adjoint",
        "full_api_name": "QuantumChannel.adjoint",
        "api_description": "Return the adjoint quantum channel.\n\n.. note::\n    This is equivalent to the matrix Hermitian conjugate in the\n    :class:`~qiskit.quantum_info.SuperOp` representation\n    ie. for a channel :math:`\\mathcal{E}`, the SuperOp of\n    the adjoint channel :math:`\\mathcal{{E}}^\\dagger` is\n    :math:`S_{\\mathcal{E}^\\dagger} = S_{\\mathcal{E}}^\\dagger`.",
        "api_signature": "adjoint(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/quantum_channel.py"
    },
    {
        "api_name": "power",
        "full_api_name": "QuantumChannel.power",
        "api_description": "Return the power of the quantum channel.\n\nArgs:\n    n (float): the power exponent.\n\nReturns:\n    CLASS: the channel :math:`\\mathcal{{E}} ^n`.\n\nRaises:\n    QiskitError: if the input and output dimensions of the\n                 CLASS are not equal.\n\n.. note::\n    For non-positive or non-integer exponents the power is\n    defined as the matrix power of the\n    :class:`~qiskit.quantum_info.SuperOp` representation\n    ie. for a channel :math:`\\mathcal{{E}}`, the SuperOp of\n    the powered channel :math:`\\mathcal{{E}}^\\n` is\n    :math:`S_{{\\mathcal{{E}}^n}} = S_{{\\mathcal{{E}}}}^n`.",
        "api_signature": "power(self, n)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/quantum_channel.py"
    },
    {
        "api_name": "__sub__",
        "full_api_name": "QuantumChannel.__sub__",
        "api_description": "",
        "api_signature": "__sub__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/quantum_channel.py"
    },
    {
        "api_name": "_add",
        "full_api_name": "QuantumChannel._add",
        "api_description": "",
        "api_signature": "_add(self, other, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/quantum_channel.py"
    },
    {
        "api_name": "_multiply",
        "full_api_name": "QuantumChannel._multiply",
        "api_description": "",
        "api_signature": "_multiply(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/quantum_channel.py"
    },
    {
        "api_name": "is_cptp",
        "full_api_name": "QuantumChannel.is_cptp",
        "api_description": "Return True if completely-positive trace-preserving (CPTP).",
        "api_signature": "is_cptp(self, atol, rtol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/quantum_channel.py"
    },
    {
        "api_name": "is_tp",
        "full_api_name": "QuantumChannel.is_tp",
        "api_description": "Test if a channel is trace-preserving (TP)",
        "api_signature": "is_tp(self, atol, rtol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/quantum_channel.py"
    },
    {
        "api_name": "is_cp",
        "full_api_name": "QuantumChannel.is_cp",
        "api_description": "Test if Choi-matrix is completely-positive (CP)",
        "api_signature": "is_cp(self, atol, rtol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/quantum_channel.py"
    },
    {
        "api_name": "is_unitary",
        "full_api_name": "QuantumChannel.is_unitary",
        "api_description": "Return True if QuantumChannel is a unitary channel.",
        "api_signature": "is_unitary(self, atol, rtol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/quantum_channel.py"
    },
    {
        "api_name": "to_operator",
        "full_api_name": "QuantumChannel.to_operator",
        "api_description": "Try to convert channel to a unitary representation Operator.",
        "api_signature": "to_operator(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/quantum_channel.py"
    },
    {
        "api_name": "to_instruction",
        "full_api_name": "QuantumChannel.to_instruction",
        "api_description": "Convert to a Kraus or UnitaryGate circuit instruction.\n\nIf the channel is unitary it will be added as a unitary gate,\notherwise it will be added as a kraus simulator instruction.\n\nReturns:\n    qiskit.circuit.Instruction: A kraus instruction for the channel.\n\nRaises:\n    QiskitError: if input data is not an N-qubit CPTP quantum channel.",
        "api_signature": "to_instruction(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/quantum_channel.py"
    },
    {
        "api_name": "_is_cp_helper",
        "full_api_name": "QuantumChannel._is_cp_helper",
        "api_description": "Test if a channel is completely-positive (CP)",
        "api_signature": "_is_cp_helper(self, choi, atol, rtol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/quantum_channel.py"
    },
    {
        "api_name": "_is_tp_helper",
        "full_api_name": "QuantumChannel._is_tp_helper",
        "api_description": "Test if Choi-matrix is trace-preserving (TP)",
        "api_signature": "_is_tp_helper(self, choi, atol, rtol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/quantum_channel.py"
    },
    {
        "api_name": "_format_state",
        "full_api_name": "QuantumChannel._format_state",
        "api_description": "Format input state so it is statevector or density matrix",
        "api_signature": "_format_state(self, state, density_matrix)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/quantum_channel.py"
    },
    {
        "api_name": "_evolve",
        "full_api_name": "QuantumChannel._evolve",
        "api_description": "Evolve a quantum state by the quantum channel.\n\nArgs:\n    state (DensityMatrix or Statevector): The input state.\n    qargs (list): a list of quantum state subsystem positions to apply\n                   the quantum channel on.\n\nReturns:\n    DensityMatrix: the output quantum state as a density matrix.\n\nRaises:\n    QiskitError: if the quantum channel dimension does not match the\n                 specified quantum state subsystem dimensions.",
        "api_signature": "_evolve(self, state, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/quantum_channel.py"
    },
    {
        "api_name": "_init_transformer",
        "full_api_name": "QuantumChannel._init_transformer",
        "api_description": "Convert input into a QuantumChannel subclass object or Operator object",
        "api_signature": "_init_transformer(cls, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/quantum_channel.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Choi.__init__",
        "api_description": "Initialize a quantum channel Choi matrix operator.\n\nArgs:\n    data (QuantumCircuit or\n          Instruction or\n          BaseOperator or\n          matrix): data to initialize superoperator.\n    input_dims (tuple): the input subsystem dimensions.\n                        [Default: None]\n    output_dims (tuple): the output subsystem dimensions.\n                         [Default: None]\n\nRaises:\n    QiskitError: if input data cannot be initialized as a\n                 Choi matrix.\n\nAdditional Information:\n    If the input or output dimensions are None, they will be\n    automatically determined from the input data. If the input data is\n    a Numpy array of shape (4**N, 4**N) qubit systems will be used. If\n    the input operator is not an N-qubit operator, it will assign a\n    single subsystem with dimension specified by the shape of the input.",
        "api_signature": "__init__(self, data, input_dims, output_dims)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/choi.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "Choi.__array__",
        "api_description": "",
        "api_signature": "__array__(self, dtype)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/choi.py"
    },
    {
        "api_name": "_bipartite_shape",
        "full_api_name": "Choi._bipartite_shape",
        "api_description": "Return the shape for bipartite matrix",
        "api_signature": "_bipartite_shape(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/choi.py"
    },
    {
        "api_name": "_evolve",
        "full_api_name": "Choi._evolve",
        "api_description": "",
        "api_signature": "_evolve(self, state, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/choi.py"
    },
    {
        "api_name": "conjugate",
        "full_api_name": "Choi.conjugate",
        "api_description": "",
        "api_signature": "conjugate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/choi.py"
    },
    {
        "api_name": "transpose",
        "full_api_name": "Choi.transpose",
        "api_description": "",
        "api_signature": "transpose(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/choi.py"
    },
    {
        "api_name": "compose",
        "full_api_name": "Choi.compose",
        "api_description": "",
        "api_signature": "compose(self, other, qargs, front)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/choi.py"
    },
    {
        "api_name": "tensor",
        "full_api_name": "Choi.tensor",
        "api_description": "",
        "api_signature": "tensor(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/choi.py"
    },
    {
        "api_name": "expand",
        "full_api_name": "Choi.expand",
        "api_description": "",
        "api_signature": "expand(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/choi.py"
    },
    {
        "api_name": "_tensor",
        "full_api_name": "Choi._tensor",
        "api_description": "",
        "api_signature": "_tensor(cls, a, b)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/choi.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Chi.__init__",
        "api_description": "Initialize a quantum channel Chi-matrix operator.\n\nArgs:\n    data (QuantumCircuit or\n          Instruction or\n          BaseOperator or\n          matrix): data to initialize superoperator.\n    input_dims (tuple): the input subsystem dimensions.\n                        [Default: None]\n    output_dims (tuple): the output subsystem dimensions.\n                         [Default: None]\n\nRaises:\n    QiskitError: if input data is not an N-qubit channel or\n                 cannot be initialized as a Chi-matrix.\n\nAdditional Information:\n    If the input or output dimensions are None, they will be\n    automatically determined from the input data. The Chi matrix\n    representation is only valid for N-qubit channels.",
        "api_signature": "__init__(self, data, input_dims, output_dims)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/chi.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "Chi.__array__",
        "api_description": "",
        "api_signature": "__array__(self, dtype)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/chi.py"
    },
    {
        "api_name": "_bipartite_shape",
        "full_api_name": "Chi._bipartite_shape",
        "api_description": "Return the shape for bipartite matrix",
        "api_signature": "_bipartite_shape(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/chi.py"
    },
    {
        "api_name": "_evolve",
        "full_api_name": "Chi._evolve",
        "api_description": "",
        "api_signature": "_evolve(self, state, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/chi.py"
    },
    {
        "api_name": "conjugate",
        "full_api_name": "Chi.conjugate",
        "api_description": "",
        "api_signature": "conjugate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/chi.py"
    },
    {
        "api_name": "transpose",
        "full_api_name": "Chi.transpose",
        "api_description": "",
        "api_signature": "transpose(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/chi.py"
    },
    {
        "api_name": "adjoint",
        "full_api_name": "Chi.adjoint",
        "api_description": "",
        "api_signature": "adjoint(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/chi.py"
    },
    {
        "api_name": "compose",
        "full_api_name": "Chi.compose",
        "api_description": "",
        "api_signature": "compose(self, other, qargs, front)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/chi.py"
    },
    {
        "api_name": "tensor",
        "full_api_name": "Chi.tensor",
        "api_description": "",
        "api_signature": "tensor(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/chi.py"
    },
    {
        "api_name": "expand",
        "full_api_name": "Chi.expand",
        "api_description": "",
        "api_signature": "expand(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/chi.py"
    },
    {
        "api_name": "_tensor",
        "full_api_name": "Chi._tensor",
        "api_description": "",
        "api_signature": "_tensor(cls, a, b)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/chi.py"
    },
    {
        "api_name": "_transform_rep",
        "full_api_name": "_transform_rep",
        "api_description": "Transform a QuantumChannel between representation.",
        "api_signature": "_transform_rep(input_rep, output_rep, data, input_dim, output_dim)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/transformations.py"
    },
    {
        "api_name": "_to_choi",
        "full_api_name": "_to_choi",
        "api_description": "Transform a QuantumChannel to the Choi representation.",
        "api_signature": "_to_choi(rep, data, input_dim, output_dim)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/transformations.py"
    },
    {
        "api_name": "_to_superop",
        "full_api_name": "_to_superop",
        "api_description": "Transform a QuantumChannel to the SuperOp representation.",
        "api_signature": "_to_superop(rep, data, input_dim, output_dim)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/transformations.py"
    },
    {
        "api_name": "_to_kraus",
        "full_api_name": "_to_kraus",
        "api_description": "Transform a QuantumChannel to the Kraus representation.",
        "api_signature": "_to_kraus(rep, data, input_dim, output_dim)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/transformations.py"
    },
    {
        "api_name": "_to_chi",
        "full_api_name": "_to_chi",
        "api_description": "Transform a QuantumChannel to the Chi representation.",
        "api_signature": "_to_chi(rep, data, input_dim, output_dim)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/transformations.py"
    },
    {
        "api_name": "_to_ptm",
        "full_api_name": "_to_ptm",
        "api_description": "Transform a QuantumChannel to the PTM representation.",
        "api_signature": "_to_ptm(rep, data, input_dim, output_dim)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/transformations.py"
    },
    {
        "api_name": "_to_stinespring",
        "full_api_name": "_to_stinespring",
        "api_description": "Transform a QuantumChannel to the Stinespring representation.",
        "api_signature": "_to_stinespring(rep, data, input_dim, output_dim)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/transformations.py"
    },
    {
        "api_name": "_to_operator",
        "full_api_name": "_to_operator",
        "api_description": "Transform a QuantumChannel to the Operator representation.",
        "api_signature": "_to_operator(rep, data, input_dim, output_dim)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/transformations.py"
    },
    {
        "api_name": "_from_operator",
        "full_api_name": "_from_operator",
        "api_description": "Transform Operator representation to other representation.",
        "api_signature": "_from_operator(rep, data, input_dim, output_dim)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/transformations.py"
    },
    {
        "api_name": "_kraus_to_operator",
        "full_api_name": "_kraus_to_operator",
        "api_description": "Transform Kraus representation to Operator representation.",
        "api_signature": "_kraus_to_operator(data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/transformations.py"
    },
    {
        "api_name": "_stinespring_to_operator",
        "full_api_name": "_stinespring_to_operator",
        "api_description": "Transform Stinespring representation to Operator representation.",
        "api_signature": "_stinespring_to_operator(data, output_dim)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/transformations.py"
    },
    {
        "api_name": "_superop_to_choi",
        "full_api_name": "_superop_to_choi",
        "api_description": "Transform SuperOp representation to Choi representation.",
        "api_signature": "_superop_to_choi(data, input_dim, output_dim)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/transformations.py"
    },
    {
        "api_name": "_choi_to_superop",
        "full_api_name": "_choi_to_superop",
        "api_description": "Transform Choi to SuperOp representation.",
        "api_signature": "_choi_to_superop(data, input_dim, output_dim)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/transformations.py"
    },
    {
        "api_name": "_kraus_to_choi",
        "full_api_name": "_kraus_to_choi",
        "api_description": "Transform Kraus representation to Choi representation.",
        "api_signature": "_kraus_to_choi(data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/transformations.py"
    },
    {
        "api_name": "_choi_to_kraus",
        "full_api_name": "_choi_to_kraus",
        "api_description": "Transform Choi representation to Kraus representation.",
        "api_signature": "_choi_to_kraus(data, input_dim, output_dim, atol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/transformations.py"
    },
    {
        "api_name": "_stinespring_to_kraus",
        "full_api_name": "_stinespring_to_kraus",
        "api_description": "Transform Stinespring representation to Kraus representation.",
        "api_signature": "_stinespring_to_kraus(data, output_dim)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/transformations.py"
    },
    {
        "api_name": "_stinespring_to_choi",
        "full_api_name": "_stinespring_to_choi",
        "api_description": "Transform Stinespring representation to Choi representation.",
        "api_signature": "_stinespring_to_choi(data, input_dim, output_dim)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/transformations.py"
    },
    {
        "api_name": "_stinespring_to_superop",
        "full_api_name": "_stinespring_to_superop",
        "api_description": "Transform Stinespring representation to SuperOp representation.",
        "api_signature": "_stinespring_to_superop(data, input_dim, output_dim)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/transformations.py"
    },
    {
        "api_name": "_kraus_to_stinespring",
        "full_api_name": "_kraus_to_stinespring",
        "api_description": "Transform Kraus representation to Stinespring representation.",
        "api_signature": "_kraus_to_stinespring(data, input_dim, output_dim)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/transformations.py"
    },
    {
        "api_name": "_kraus_to_superop",
        "full_api_name": "_kraus_to_superop",
        "api_description": "Transform Kraus representation to SuperOp representation.",
        "api_signature": "_kraus_to_superop(data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/transformations.py"
    },
    {
        "api_name": "_chi_to_choi",
        "full_api_name": "_chi_to_choi",
        "api_description": "Transform Chi representation to a Choi representation.",
        "api_signature": "_chi_to_choi(data, input_dim)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/transformations.py"
    },
    {
        "api_name": "_choi_to_chi",
        "full_api_name": "_choi_to_chi",
        "api_description": "Transform Choi representation to the Chi representation.",
        "api_signature": "_choi_to_chi(data, input_dim)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/transformations.py"
    },
    {
        "api_name": "_ptm_to_superop",
        "full_api_name": "_ptm_to_superop",
        "api_description": "Transform PTM representation to SuperOp representation.",
        "api_signature": "_ptm_to_superop(data, input_dim)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/transformations.py"
    },
    {
        "api_name": "_superop_to_ptm",
        "full_api_name": "_superop_to_ptm",
        "api_description": "Transform SuperOp representation to PTM representation.",
        "api_signature": "_superop_to_ptm(data, input_dim)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/transformations.py"
    },
    {
        "api_name": "_bipartite_tensor",
        "full_api_name": "_bipartite_tensor",
        "api_description": "Tensor product (A \u2297 B) to bipartite matrices and reravel indices.\n\nThis is used for tensor product of superoperators and Choi matrices.\n\nArgs:\n    mat1 (matrix_like): a bipartite matrix A\n    mat2 (matrix_like): a bipartite matrix B\n    shape1 (tuple): bipartite-shape for matrix A (a0, a1, a2, a3)\n    shape2 (tuple): bipartite-shape for matrix B (b0, b1, b2, b3)\n\nReturns:\n    np.array: a bipartite matrix for reravel(A \u2297 B).\n\nRaises:\n    QiskitError: if input matrices are wrong shape.",
        "api_signature": "_bipartite_tensor(mat1, mat2, shape1, shape2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/transformations.py"
    },
    {
        "api_name": "_reravel",
        "full_api_name": "_reravel",
        "api_description": "Reravel two bipartite matrices.",
        "api_signature": "_reravel(mat1, mat2, shape1, shape2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/transformations.py"
    },
    {
        "api_name": "_transform_to_pauli",
        "full_api_name": "_transform_to_pauli",
        "api_description": "Change of basis of bipartite matrix representation.",
        "api_signature": "_transform_to_pauli(data, num_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/transformations.py"
    },
    {
        "api_name": "_transform_from_pauli",
        "full_api_name": "_transform_from_pauli",
        "api_description": "Change of basis of bipartite matrix representation.",
        "api_signature": "_transform_from_pauli(data, num_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/transformations.py"
    },
    {
        "api_name": "_reshuffle",
        "full_api_name": "_reshuffle",
        "api_description": "Reshuffle the indices of a bipartite matrix A[ij,kl] -> A[lj,ki].",
        "api_signature": "_reshuffle(mat, shape)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/transformations.py"
    },
    {
        "api_name": "_check_nqubit_dim",
        "full_api_name": "_check_nqubit_dim",
        "api_description": "Return true if dims correspond to an n-qubit channel.",
        "api_signature": "_check_nqubit_dim(input_dim, output_dim)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/transformations.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Stinespring.__init__",
        "api_description": "Initialize a quantum channel Stinespring operator.\n\nArgs:\n    data (QuantumCircuit or\n          Instruction or\n          BaseOperator or\n          matrix): data to initialize superoperator.\n    input_dims (tuple): the input subsystem dimensions.\n                        [Default: None]\n    output_dims (tuple): the output subsystem dimensions.\n                         [Default: None]\n\nRaises:\n    QiskitError: if input data cannot be initialized as a\n                 a list of Kraus matrices.\n\nAdditional Information:\n    If the input or output dimensions are None, they will be\n    automatically determined from the input data. This can fail for the\n    Stinespring operator if the output dimension cannot be automatically\n    determined.",
        "api_signature": "__init__(self, data, input_dims, output_dims)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/stinespring.py"
    },
    {
        "api_name": "data",
        "full_api_name": "Stinespring.data",
        "api_description": "",
        "api_signature": "data(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/stinespring.py"
    },
    {
        "api_name": "is_cptp",
        "full_api_name": "Stinespring.is_cptp",
        "api_description": "Return True if completely-positive trace-preserving.",
        "api_signature": "is_cptp(self, atol, rtol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/stinespring.py"
    },
    {
        "api_name": "_evolve",
        "full_api_name": "Stinespring._evolve",
        "api_description": "",
        "api_signature": "_evolve(self, state, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/stinespring.py"
    },
    {
        "api_name": "conjugate",
        "full_api_name": "Stinespring.conjugate",
        "api_description": "",
        "api_signature": "conjugate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/stinespring.py"
    },
    {
        "api_name": "transpose",
        "full_api_name": "Stinespring.transpose",
        "api_description": "",
        "api_signature": "transpose(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/stinespring.py"
    },
    {
        "api_name": "compose",
        "full_api_name": "Stinespring.compose",
        "api_description": "",
        "api_signature": "compose(self, other, qargs, front)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/stinespring.py"
    },
    {
        "api_name": "tensor",
        "full_api_name": "Stinespring.tensor",
        "api_description": "",
        "api_signature": "tensor(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/stinespring.py"
    },
    {
        "api_name": "expand",
        "full_api_name": "Stinespring.expand",
        "api_description": "",
        "api_signature": "expand(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/stinespring.py"
    },
    {
        "api_name": "_tensor",
        "full_api_name": "Stinespring._tensor",
        "api_description": "",
        "api_signature": "_tensor(cls, a, b)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/stinespring.py"
    },
    {
        "api_name": "__add__",
        "full_api_name": "Stinespring.__add__",
        "api_description": "",
        "api_signature": "__add__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/stinespring.py"
    },
    {
        "api_name": "__sub__",
        "full_api_name": "Stinespring.__sub__",
        "api_description": "",
        "api_signature": "__sub__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/stinespring.py"
    },
    {
        "api_name": "_add",
        "full_api_name": "Stinespring._add",
        "api_description": "",
        "api_signature": "_add(self, other, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/stinespring.py"
    },
    {
        "api_name": "_multiply",
        "full_api_name": "Stinespring._multiply",
        "api_description": "",
        "api_signature": "_multiply(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/stinespring.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PTM.__init__",
        "api_description": "Initialize a PTM quantum channel operator.\n\nArgs:\n    data (QuantumCircuit or\n          Instruction or\n          BaseOperator or\n          matrix): data to initialize superoperator.\n    input_dims (tuple): the input subsystem dimensions.\n                        [Default: None]\n    output_dims (tuple): the output subsystem dimensions.\n                         [Default: None]\n\nRaises:\n    QiskitError: if input data is not an N-qubit channel or\n                 cannot be initialized as a PTM.\n\nAdditional Information:\n    If the input or output dimensions are None, they will be\n    automatically determined from the input data. The PTM\n    representation is only valid for N-qubit channels.",
        "api_signature": "__init__(self, data, input_dims, output_dims)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/ptm.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "PTM.__array__",
        "api_description": "",
        "api_signature": "__array__(self, dtype)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/ptm.py"
    },
    {
        "api_name": "_bipartite_shape",
        "full_api_name": "PTM._bipartite_shape",
        "api_description": "Return the shape for bipartite matrix",
        "api_signature": "_bipartite_shape(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/ptm.py"
    },
    {
        "api_name": "_evolve",
        "full_api_name": "PTM._evolve",
        "api_description": "",
        "api_signature": "_evolve(self, state, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/ptm.py"
    },
    {
        "api_name": "conjugate",
        "full_api_name": "PTM.conjugate",
        "api_description": "",
        "api_signature": "conjugate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/ptm.py"
    },
    {
        "api_name": "transpose",
        "full_api_name": "PTM.transpose",
        "api_description": "",
        "api_signature": "transpose(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/ptm.py"
    },
    {
        "api_name": "adjoint",
        "full_api_name": "PTM.adjoint",
        "api_description": "",
        "api_signature": "adjoint(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/ptm.py"
    },
    {
        "api_name": "compose",
        "full_api_name": "PTM.compose",
        "api_description": "",
        "api_signature": "compose(self, other, qargs, front)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/ptm.py"
    },
    {
        "api_name": "tensor",
        "full_api_name": "PTM.tensor",
        "api_description": "",
        "api_signature": "tensor(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/ptm.py"
    },
    {
        "api_name": "expand",
        "full_api_name": "PTM.expand",
        "api_description": "",
        "api_signature": "expand(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/ptm.py"
    },
    {
        "api_name": "_tensor",
        "full_api_name": "PTM._tensor",
        "api_description": "",
        "api_signature": "_tensor(cls, a, b)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/ptm.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Kraus.__init__",
        "api_description": "Initialize a quantum channel Kraus operator.\n\nArgs:\n    data: data to initialize superoperator.\n    input_dims: the input subsystem dimensions.\n    output_dims: the output subsystem dimensions.\n\nRaises:\n    QiskitError: if input data cannot be initialized as a list of Kraus matrices.\n\nAdditional Information:\n    If the input or output dimensions are None, they will be\n    automatically determined from the input data. If the input data is\n    a list of Numpy arrays of shape :math:`(2^N,\\,2^N)` qubit systems will be\n    used. If the input does not correspond to an N-qubit channel, it\n    will assign a single subsystem with dimension specified by the\n    shape of the input.",
        "api_signature": "__init__(self, data, input_dims, output_dims)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/kraus.py"
    },
    {
        "api_name": "data",
        "full_api_name": "Kraus.data",
        "api_description": "Return list of Kraus matrices for channel.",
        "api_signature": "data(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/kraus.py"
    },
    {
        "api_name": "is_cptp",
        "full_api_name": "Kraus.is_cptp",
        "api_description": "Return True if completely-positive trace-preserving.",
        "api_signature": "is_cptp(self, atol, rtol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/kraus.py"
    },
    {
        "api_name": "_evolve",
        "full_api_name": "Kraus._evolve",
        "api_description": "",
        "api_signature": "_evolve(self, state, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/kraus.py"
    },
    {
        "api_name": "conjugate",
        "full_api_name": "Kraus.conjugate",
        "api_description": "",
        "api_signature": "conjugate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/kraus.py"
    },
    {
        "api_name": "transpose",
        "full_api_name": "Kraus.transpose",
        "api_description": "",
        "api_signature": "transpose(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/kraus.py"
    },
    {
        "api_name": "adjoint",
        "full_api_name": "Kraus.adjoint",
        "api_description": "",
        "api_signature": "adjoint(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/kraus.py"
    },
    {
        "api_name": "compose",
        "full_api_name": "Kraus.compose",
        "api_description": "",
        "api_signature": "compose(self, other, qargs, front)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/kraus.py"
    },
    {
        "api_name": "tensor",
        "full_api_name": "Kraus.tensor",
        "api_description": "",
        "api_signature": "tensor(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/kraus.py"
    },
    {
        "api_name": "expand",
        "full_api_name": "Kraus.expand",
        "api_description": "",
        "api_signature": "expand(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/kraus.py"
    },
    {
        "api_name": "_tensor",
        "full_api_name": "Kraus._tensor",
        "api_description": "",
        "api_signature": "_tensor(cls, a, b)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/kraus.py"
    },
    {
        "api_name": "__add__",
        "full_api_name": "Kraus.__add__",
        "api_description": "",
        "api_signature": "__add__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/kraus.py"
    },
    {
        "api_name": "__sub__",
        "full_api_name": "Kraus.__sub__",
        "api_description": "",
        "api_signature": "__sub__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/kraus.py"
    },
    {
        "api_name": "_add",
        "full_api_name": "Kraus._add",
        "api_description": "",
        "api_signature": "_add(self, other, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/kraus.py"
    },
    {
        "api_name": "_multiply",
        "full_api_name": "Kraus._multiply",
        "api_description": "",
        "api_signature": "_multiply(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/kraus.py"
    },
    {
        "api_name": "_is_matrix",
        "full_api_name": "_is_matrix",
        "api_description": "",
        "api_signature": "_is_matrix(data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/kraus.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SuperOp.__init__",
        "api_description": "Initialize a quantum channel Superoperator operator.\n\nArgs:\n    data (QuantumCircuit or\n          Instruction or\n          BaseOperator or\n          matrix): data to initialize superoperator.\n    input_dims (tuple): the input subsystem dimensions.\n                        [Default: None]\n    output_dims (tuple): the output subsystem dimensions.\n                         [Default: None]\n\nRaises:\n    QiskitError: if input data cannot be initialized as a\n                 superoperator.\n\nAdditional Information:\n    If the input or output dimensions are None, they will be\n    automatically determined from the input data. If the input data is\n    a Numpy array of shape (4**N, 4**N) qubit systems will be used. If\n    the input operator is not an N-qubit operator, it will assign a\n    single subsystem with dimension specified by the shape of the input.",
        "api_signature": "__init__(self, data, input_dims, output_dims)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/superop.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "SuperOp.__array__",
        "api_description": "",
        "api_signature": "__array__(self, dtype)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/superop.py"
    },
    {
        "api_name": "_tensor_shape",
        "full_api_name": "SuperOp._tensor_shape",
        "api_description": "Return the tensor shape of the superoperator matrix",
        "api_signature": "_tensor_shape(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/superop.py"
    },
    {
        "api_name": "_bipartite_shape",
        "full_api_name": "SuperOp._bipartite_shape",
        "api_description": "Return the shape for bipartite matrix",
        "api_signature": "_bipartite_shape(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/superop.py"
    },
    {
        "api_name": "conjugate",
        "full_api_name": "SuperOp.conjugate",
        "api_description": "",
        "api_signature": "conjugate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/superop.py"
    },
    {
        "api_name": "transpose",
        "full_api_name": "SuperOp.transpose",
        "api_description": "",
        "api_signature": "transpose(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/superop.py"
    },
    {
        "api_name": "adjoint",
        "full_api_name": "SuperOp.adjoint",
        "api_description": "",
        "api_signature": "adjoint(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/superop.py"
    },
    {
        "api_name": "tensor",
        "full_api_name": "SuperOp.tensor",
        "api_description": "",
        "api_signature": "tensor(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/superop.py"
    },
    {
        "api_name": "expand",
        "full_api_name": "SuperOp.expand",
        "api_description": "",
        "api_signature": "expand(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/superop.py"
    },
    {
        "api_name": "_tensor",
        "full_api_name": "SuperOp._tensor",
        "api_description": "",
        "api_signature": "_tensor(cls, a, b)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/superop.py"
    },
    {
        "api_name": "compose",
        "full_api_name": "SuperOp.compose",
        "api_description": "",
        "api_signature": "compose(self, other, qargs, front)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/superop.py"
    },
    {
        "api_name": "_evolve",
        "full_api_name": "SuperOp._evolve",
        "api_description": "Evolve a quantum state by the quantum channel.\n\nArgs:\n    state (DensityMatrix or Statevector): The input state.\n    qargs (list): a list of quantum state subsystem positions to apply\n                   the quantum channel on.\n\nReturns:\n    DensityMatrix: the output quantum state as a density matrix.\n\nRaises:\n    QiskitError: if the quantum channel dimension does not match the\n                 specified quantum state subsystem dimensions.",
        "api_signature": "_evolve(self, state, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/superop.py"
    },
    {
        "api_name": "_init_instruction",
        "full_api_name": "SuperOp._init_instruction",
        "api_description": "Convert a QuantumCircuit or Instruction to a SuperOp.",
        "api_signature": "_init_instruction(cls, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/superop.py"
    },
    {
        "api_name": "_instruction_to_superop",
        "full_api_name": "SuperOp._instruction_to_superop",
        "api_description": "Return superop for instruction if defined or None otherwise.",
        "api_signature": "_instruction_to_superop(cls, obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/superop.py"
    },
    {
        "api_name": "_append_instruction",
        "full_api_name": "SuperOp._append_instruction",
        "api_description": "Update the current Operator by apply an instruction.",
        "api_signature": "_append_instruction(self, obj, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/superop.py"
    },
    {
        "api_name": "_append_circuit",
        "full_api_name": "_append_circuit",
        "api_description": "Update a CNOTDihedral element inplace by applying a CNOTDihedral circuit.\n\nArgs:\n    elem (CNOTDihedral): the CNOTDihedral element to update.\n    circuit (QuantumCircuit or Instruction): the gate or composite gate to apply.\n    qargs (list or None): The qubits to apply gates to.\nReturns:\n    CNOTDihedral: the updated CNOTDihedral.\nRaises:\n    QiskitError: if input gates cannot be decomposed into CNOTDihedral gates.",
        "api_signature": "_append_circuit(elem, circuit, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/dihedral_circuits.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CNOTDihedral.__init__",
        "api_description": "Initialize a CNOTDihedral operator object.\n\nArgs:\n    data (CNOTDihedral or QuantumCircuit or ~qiskit.circuit.Instruction):\n        Optional, operator to initialize.\n    num_qubits (int): Optional, initialize an empty CNOTDihedral operator.\n    validate (bool): if True, validates the CNOTDihedral element.\n\nRaises:\n    QiskitError: if the type is invalid.\n    QiskitError: if validate=True and the CNOTDihedral element is invalid.",
        "api_signature": "__init__(self, data, num_qubits, validate)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/dihedral.py"
    },
    {
        "api_name": "name",
        "full_api_name": "CNOTDihedral.name",
        "api_description": "Unique string identifier for operation type.",
        "api_signature": "name(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/dihedral.py"
    },
    {
        "api_name": "num_clbits",
        "full_api_name": "CNOTDihedral.num_clbits",
        "api_description": "Number of classical bits.",
        "api_signature": "num_clbits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/dihedral.py"
    },
    {
        "api_name": "_z2matmul",
        "full_api_name": "CNOTDihedral._z2matmul",
        "api_description": "Compute product of two n x n z2 matrices.",
        "api_signature": "_z2matmul(self, left, right)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/dihedral.py"
    },
    {
        "api_name": "_z2matvecmul",
        "full_api_name": "CNOTDihedral._z2matvecmul",
        "api_description": "Compute mat*vec of n x n z2 matrix and vector.",
        "api_signature": "_z2matvecmul(self, mat, vec)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/dihedral.py"
    },
    {
        "api_name": "_dot",
        "full_api_name": "CNOTDihedral._dot",
        "api_description": "Left multiplication self * other.",
        "api_signature": "_dot(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/dihedral.py"
    },
    {
        "api_name": "_compose",
        "full_api_name": "CNOTDihedral._compose",
        "api_description": "Right multiplication other * self.",
        "api_signature": "_compose(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/dihedral.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "CNOTDihedral.__eq__",
        "api_description": "Test equality.",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/dihedral.py"
    },
    {
        "api_name": "_append_cx",
        "full_api_name": "CNOTDihedral._append_cx",
        "api_description": "Apply a CX gate to this element.\nLeft multiply the element by CX(i, j).",
        "api_signature": "_append_cx(self, i, j)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/dihedral.py"
    },
    {
        "api_name": "_append_phase",
        "full_api_name": "CNOTDihedral._append_phase",
        "api_description": "Apply an k-th power of T to this element.\nLeft multiply the element by T_i^k.",
        "api_signature": "_append_phase(self, k, i)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/dihedral.py"
    },
    {
        "api_name": "_append_x",
        "full_api_name": "CNOTDihedral._append_x",
        "api_description": "Apply X to this element.\nLeft multiply the element by X(i).",
        "api_signature": "_append_x(self, i)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/dihedral.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "CNOTDihedral.__str__",
        "api_description": "Return formatted string representation.",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/dihedral.py"
    },
    {
        "api_name": "to_circuit",
        "full_api_name": "CNOTDihedral.to_circuit",
        "api_description": "Return a QuantumCircuit implementing the CNOT-Dihedral element.\n\nReturn:\n    QuantumCircuit: a circuit implementation of the CNOTDihedral object.\n\nReferences:\n    1. Shelly Garion and Andrew W. Cross, *Synthesis of CNOT-Dihedral circuits\n       with optimal number of two qubit gates*, `Quantum 4(369), 2020\n       <https://quantum-journal.org/papers/q-2020-12-07-369/>`_\n    2. Andrew W. Cross, Easwar Magesan, Lev S. Bishop, John A. Smolin and Jay M. Gambetta,\n       *Scalable randomised benchmarking of non-Clifford gates*,\n       npj Quantum Inf 2, 16012 (2016).",
        "api_signature": "to_circuit(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/dihedral.py"
    },
    {
        "api_name": "to_instruction",
        "full_api_name": "CNOTDihedral.to_instruction",
        "api_description": "Return a Gate instruction implementing the CNOTDihedral object.",
        "api_signature": "to_instruction(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/dihedral.py"
    },
    {
        "api_name": "_from_circuit",
        "full_api_name": "CNOTDihedral._from_circuit",
        "api_description": "Initialize from a QuantumCircuit or Instruction.\n\nArgs:\n    circuit (QuantumCircuit or ~qiskit.circuit.Instruction):\n        instruction to initialize.\nReturns:\n    CNOTDihedral: the CNOTDihedral object for the circuit.\nRaises:\n    QiskitError: if the input instruction is not CNOTDihedral or contains\n                 classical register instruction.",
        "api_signature": "_from_circuit(self, circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/dihedral.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "CNOTDihedral.__array__",
        "api_description": "",
        "api_signature": "__array__(self, dtype)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/dihedral.py"
    },
    {
        "api_name": "to_matrix",
        "full_api_name": "CNOTDihedral.to_matrix",
        "api_description": "Convert operator to Numpy matrix.",
        "api_signature": "to_matrix(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/dihedral.py"
    },
    {
        "api_name": "to_operator",
        "full_api_name": "CNOTDihedral.to_operator",
        "api_description": "Convert to an Operator object.",
        "api_signature": "to_operator(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/dihedral.py"
    },
    {
        "api_name": "compose",
        "full_api_name": "CNOTDihedral.compose",
        "api_description": "",
        "api_signature": "compose(self, other, qargs, front)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/dihedral.py"
    },
    {
        "api_name": "_tensor",
        "full_api_name": "CNOTDihedral._tensor",
        "api_description": "Returns the tensor product operator.",
        "api_signature": "_tensor(self, other, reverse)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/dihedral.py"
    },
    {
        "api_name": "tensor",
        "full_api_name": "CNOTDihedral.tensor",
        "api_description": "",
        "api_signature": "tensor(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/dihedral.py"
    },
    {
        "api_name": "expand",
        "full_api_name": "CNOTDihedral.expand",
        "api_description": "",
        "api_signature": "expand(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/dihedral.py"
    },
    {
        "api_name": "adjoint",
        "full_api_name": "CNOTDihedral.adjoint",
        "api_description": "",
        "api_signature": "adjoint(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/dihedral.py"
    },
    {
        "api_name": "conjugate",
        "full_api_name": "CNOTDihedral.conjugate",
        "api_description": "",
        "api_signature": "conjugate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/dihedral.py"
    },
    {
        "api_name": "transpose",
        "full_api_name": "CNOTDihedral.transpose",
        "api_description": "",
        "api_signature": "transpose(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/dihedral.py"
    },
    {
        "api_name": "_is_valid",
        "full_api_name": "CNOTDihedral._is_valid",
        "api_description": "Return True if input is a CNOTDihedral element.",
        "api_signature": "_is_valid(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/dihedral.py"
    },
    {
        "api_name": "random_cnotdihedral",
        "full_api_name": "random_cnotdihedral",
        "api_description": "Return a random CNOTDihedral element.\n\nArgs:\n    num_qubits (int): the number of qubits for the CNOTDihedral object.\n    seed (int or RandomState): Optional. Set a fixed seed or\n                               generator for RNG.\nReturns:\n    CNOTDihedral: a random CNOTDihedral element.",
        "api_signature": "random_cnotdihedral(num_qubits, seed)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/random.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SpecialPolynomial.__init__",
        "api_description": "Construct the zero polynomial on n_vars variables.",
        "api_signature": "__init__(self, n_vars)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/polynomial.py"
    },
    {
        "api_name": "mul_monomial",
        "full_api_name": "SpecialPolynomial.mul_monomial",
        "api_description": "Multiply by a monomial given by indices.\n\nReturns the product.",
        "api_signature": "mul_monomial(self, indices)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/polynomial.py"
    },
    {
        "api_name": "__mul__",
        "full_api_name": "SpecialPolynomial.__mul__",
        "api_description": "Multiply two polynomials.",
        "api_signature": "__mul__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/polynomial.py"
    },
    {
        "api_name": "__rmul__",
        "full_api_name": "SpecialPolynomial.__rmul__",
        "api_description": "Right multiplication.\n\nThis operation is commutative.",
        "api_signature": "__rmul__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/polynomial.py"
    },
    {
        "api_name": "__add__",
        "full_api_name": "SpecialPolynomial.__add__",
        "api_description": "Add two polynomials.",
        "api_signature": "__add__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/polynomial.py"
    },
    {
        "api_name": "evaluate",
        "full_api_name": "SpecialPolynomial.evaluate",
        "api_description": "Evaluate the multinomial at xval.\n\nif xval is a length n z2 vector, return element of Z8.\nif xval is a length n vector of multinomials, return\na multinomial. The multinomials must all be on n vars.",
        "api_signature": "evaluate(self, xval)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/polynomial.py"
    },
    {
        "api_name": "set_pj",
        "full_api_name": "SpecialPolynomial.set_pj",
        "api_description": "Set to special form polynomial on subset of variables.\n\np_J(x) := sum_{a subseteq J,|a| neq 0} (-2)^{|a|-1}x^a",
        "api_signature": "set_pj(self, indices)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/polynomial.py"
    },
    {
        "api_name": "get_term",
        "full_api_name": "SpecialPolynomial.get_term",
        "api_description": "Get the value of a term given the list of variables.\n\nExample: indices = [] returns the constant\n         indices = [0] returns the coefficient of x_0\n         indices = [0,3] returns the coefficient of x_0x_3\n         indices = [0,1,3] returns the coefficient of x_0x_1x_3\n\nIf len(indices) > 3 the method fails.\nIf the indices are out of bounds the method fails.\nIf the indices are not increasing the method fails.",
        "api_signature": "get_term(self, indices)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/polynomial.py"
    },
    {
        "api_name": "set_term",
        "full_api_name": "SpecialPolynomial.set_term",
        "api_description": "Set the value of a term given the list of variables.\n\nExample: indices = [] returns the constant\n         indices = [0] returns the coefficient of x_0\n         indices = [0,3] returns the coefficient of x_0x_3\n         indices = [0,1,3] returns the coefficient of x_0x_1x_3\n\nIf len(indices) > 3 the method fails.\nIf the indices are out of bounds the method fails.\nIf the indices are not increasing the method fails.\nThe value is reduced modulo 8.",
        "api_signature": "set_term(self, indices, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/polynomial.py"
    },
    {
        "api_name": "key",
        "full_api_name": "SpecialPolynomial.key",
        "api_description": "Return a string representation.",
        "api_signature": "key(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/polynomial.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "SpecialPolynomial.__eq__",
        "api_description": "Test equality.",
        "api_signature": "__eq__(self, x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/polynomial.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "SpecialPolynomial.__str__",
        "api_description": "Return formatted string representation.",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/polynomial.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SparsePauliOp.__init__",
        "api_description": "Initialize an operator object.\n\nArgs:\n    data (PauliList or SparsePauliOp or Pauli or list or str): Pauli list of\n        terms.  A list of Pauli strings or a Pauli string is also allowed.\n    coeffs (np.ndarray): complex coefficients for Pauli terms.\n\n        .. note::\n\n            If ``data`` is a :obj:`~SparsePauliOp` and ``coeffs`` is not ``None``, the value\n            of the ``SparsePauliOp.coeffs`` will be ignored, and only the passed keyword\n            argument ``coeffs`` will be used.\n\n    ignore_pauli_phase (bool): if true, any ``phase`` component of a given :obj:`~PauliList`\n        will be assumed to be zero.  This is more efficient in cases where a\n        :obj:`~PauliList` has been constructed purely for this object, and it is already\n        known that the phases in the ZX-convention are zero.  It only makes sense to pass\n        this option when giving :obj:`~PauliList` data.  (Default: False)\n    copy (bool): copy the input data if True, otherwise assign it directly, if possible.\n        (Default: True)\n\nRaises:\n    QiskitError: If the input data or coeffs are invalid.",
        "api_signature": "__init__(self, data, coeffs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "SparsePauliOp.__array__",
        "api_description": "",
        "api_signature": "__array__(self, dtype)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "SparsePauliOp.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "SparsePauliOp.__eq__",
        "api_description": "Entrywise comparison of two SparsePauliOp operators",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "equiv",
        "full_api_name": "SparsePauliOp.equiv",
        "api_description": "Check if two SparsePauliOp operators are equivalent.\n\nArgs:\n    other (SparsePauliOp): an operator object.\n    atol: Absolute numerical tolerance for checking equivalence.\n\nReturns:\n    bool: True if the operator is equivalent to ``self``.",
        "api_signature": "equiv(self, other, atol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "settings",
        "full_api_name": "SparsePauliOp.settings",
        "api_description": "Return settings.",
        "api_signature": "settings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "size",
        "full_api_name": "SparsePauliOp.size",
        "api_description": "The number of Pauli of Pauli terms in the operator.",
        "api_signature": "size(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "__len__",
        "full_api_name": "SparsePauliOp.__len__",
        "api_description": "Return the size.",
        "api_signature": "__len__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "paulis",
        "full_api_name": "SparsePauliOp.paulis",
        "api_description": "Return the PauliList.",
        "api_signature": "paulis(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "paulis",
        "full_api_name": "SparsePauliOp.paulis",
        "api_description": "",
        "api_signature": "paulis(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "coeffs",
        "full_api_name": "SparsePauliOp.coeffs",
        "api_description": "Return the Pauli coefficients.",
        "api_signature": "coeffs(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "coeffs",
        "full_api_name": "SparsePauliOp.coeffs",
        "api_description": "Set Pauli coefficients.",
        "api_signature": "coeffs(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "__getitem__",
        "full_api_name": "SparsePauliOp.__getitem__",
        "api_description": "Return a view of the SparsePauliOp.",
        "api_signature": "__getitem__(self, key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "__setitem__",
        "full_api_name": "SparsePauliOp.__setitem__",
        "api_description": "Update SparsePauliOp.",
        "api_signature": "__setitem__(self, key, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "conjugate",
        "full_api_name": "SparsePauliOp.conjugate",
        "api_description": "",
        "api_signature": "conjugate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "transpose",
        "full_api_name": "SparsePauliOp.transpose",
        "api_description": "",
        "api_signature": "transpose(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "adjoint",
        "full_api_name": "SparsePauliOp.adjoint",
        "api_description": "",
        "api_signature": "adjoint(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "compose",
        "full_api_name": "SparsePauliOp.compose",
        "api_description": "",
        "api_signature": "compose(self, other, qargs, front)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "tensor",
        "full_api_name": "SparsePauliOp.tensor",
        "api_description": "",
        "api_signature": "tensor(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "expand",
        "full_api_name": "SparsePauliOp.expand",
        "api_description": "",
        "api_signature": "expand(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "_tensor",
        "full_api_name": "SparsePauliOp._tensor",
        "api_description": "",
        "api_signature": "_tensor(cls, a, b)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "_add",
        "full_api_name": "SparsePauliOp._add",
        "api_description": "",
        "api_signature": "_add(self, other, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "_multiply",
        "full_api_name": "SparsePauliOp._multiply",
        "api_description": "",
        "api_signature": "_multiply(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "is_unitary",
        "full_api_name": "SparsePauliOp.is_unitary",
        "api_description": "Return True if operator is a unitary matrix.\n\nArgs:\n    atol (float): Optional. Absolute tolerance for checking if\n                  coefficients are zero (Default: 1e-8).\n    rtol (float): Optional. relative tolerance for checking if\n                  coefficients are zero (Default: 1e-5).\n\nReturns:\n    bool: True if the operator is unitary, False otherwise.",
        "api_signature": "is_unitary(self, atol, rtol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "simplify",
        "full_api_name": "SparsePauliOp.simplify",
        "api_description": "Simplify PauliList by combining duplicates and removing zeros.\n\nArgs:\n    atol (float): Optional. Absolute tolerance for checking if\n                  coefficients are zero (Default: 1e-8).\n    rtol (float): Optional. relative tolerance for checking if\n                  coefficients are zero (Default: 1e-5).\n\nReturns:\n    SparsePauliOp: the simplified SparsePauliOp operator.",
        "api_signature": "simplify(self, atol, rtol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "to_complex",
        "full_api_name": "SparsePauliOp.to_complex",
        "api_description": "",
        "api_signature": "to_complex(coeff)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "argsort",
        "full_api_name": "SparsePauliOp.argsort",
        "api_description": "Return indices for sorting the rows of the table.\n\nReturns the composition of permutations in the order of sorting\nby coefficient and sorting by Pauli.\nBy using the `weight` kwarg the output can additionally be sorted\nby the number of non-identity terms in the Pauli, where the set of\nall Pauli's of a given weight are still ordered lexicographically.\n\n**Example**\n\nHere is an example of how to use SparsePauliOp argsort.\n\n.. code-block::\n\n    import numpy as np\n    from qiskit.quantum_info import SparsePauliOp\n\n    # 2-qubit labels\n    labels = [\"XX\", \"XX\", \"XX\", \"YI\", \"II\", \"XZ\", \"XY\", \"XI\"]\n    # coeffs\n    coeffs = [2.+1.j, 2.+2.j, 3.+0.j, 3.+0.j, 4.+0.j, 5.+0.j, 6.+0.j, 7.+0.j]\n\n    # init\n    spo = SparsePauliOp(labels, coeffs)\n    print('Initial Ordering')\n    print(spo)\n\n    # Lexicographic Ordering\n    srt = spo.argsort()\n    print('Lexicographically sorted')\n    print(srt)\n\n    # Lexicographic Ordering\n    srt = spo.argsort(weight=False)\n    print('Lexicographically sorted')\n    print(srt)\n\n    # Weight Ordering\n    srt = spo.argsort(weight=True)\n    print('Weight sorted')\n    print(srt)\n\n.. parsed-literal::\n\n    Initial Ordering\n    SparsePauliOp(['XX', 'XX', 'XX', 'YI', 'II', 'XZ', 'XY', 'XI'],\n                  coeffs=[2.+1.j, 2.+2.j, 3.+0.j, 3.+0.j, 4.+0.j, 5.+0.j, 6.+0.j, 7.+0.j])\n    Lexicographically sorted\n    [4 7 0 1 2 6 5 3]\n    Lexicographically sorted\n    [4 7 0 1 2 6 5 3]\n    Weight sorted\n    [4 7 3 0 1 2 6 5]\n\nArgs:\n    weight (bool): optionally sort by weight if True (Default: False).\n    By using the weight kwarg the output can additionally be sorted\n    by the number of non-identity terms in the Pauli.\n\nReturns:\n    array: the indices for sorting the table.",
        "api_signature": "argsort(self, weight)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "sort",
        "full_api_name": "SparsePauliOp.sort",
        "api_description": "Sort the rows of the table.\n\nAfter sorting the coefficients using numpy's argsort, sort by Pauli.\nPauli sort takes precedence.\nIf Pauli is the same, it will be sorted by coefficient.\nBy using the `weight` kwarg the output can additionally be sorted\nby the number of non-identity terms in the Pauli, where the set of\nall Pauli's of a given weight are still ordered lexicographically.\n\n**Example**\n\nHere is an example of how to use SparsePauliOp sort.\n\n.. code-block::\n\n    import numpy as np\n    from qiskit.quantum_info import SparsePauliOp\n\n    # 2-qubit labels\n    labels = [\"XX\", \"XX\", \"XX\", \"YI\", \"II\", \"XZ\", \"XY\", \"XI\"]\n    # coeffs\n    coeffs = [2.+1.j, 2.+2.j, 3.+0.j, 3.+0.j, 4.+0.j, 5.+0.j, 6.+0.j, 7.+0.j]\n\n    # init\n    spo = SparsePauliOp(labels, coeffs)\n    print('Initial Ordering')\n    print(spo)\n\n    # Lexicographic Ordering\n    srt = spo.sort()\n    print('Lexicographically sorted')\n    print(srt)\n\n    # Lexicographic Ordering\n    srt = spo.sort(weight=False)\n    print('Lexicographically sorted')\n    print(srt)\n\n    # Weight Ordering\n    srt = spo.sort(weight=True)\n    print('Weight sorted')\n    print(srt)\n\n.. parsed-literal::\n\n    Initial Ordering\n    SparsePauliOp(['XX', 'XX', 'XX', 'YI', 'II', 'XZ', 'XY', 'XI'],\n                  coeffs=[2.+1.j, 2.+2.j, 3.+0.j, 3.+0.j, 4.+0.j, 5.+0.j, 6.+0.j, 7.+0.j])\n    Lexicographically sorted\n    SparsePauliOp(['II', 'XI', 'XX', 'XX', 'XX', 'XY', 'XZ', 'YI'],\n                  coeffs=[4.+0.j, 7.+0.j, 2.+1.j, 2.+2.j, 3.+0.j, 6.+0.j, 5.+0.j, 3.+0.j])\n    Lexicographically sorted\n    SparsePauliOp(['II', 'XI', 'XX', 'XX', 'XX', 'XY', 'XZ', 'YI'],\n                  coeffs=[4.+0.j, 7.+0.j, 2.+1.j, 2.+2.j, 3.+0.j, 6.+0.j, 5.+0.j, 3.+0.j])\n    Weight sorted\n    SparsePauliOp(['II', 'XI', 'YI', 'XX', 'XX', 'XX', 'XY', 'XZ'],\n                  coeffs=[4.+0.j, 7.+0.j, 3.+0.j, 2.+1.j, 2.+2.j, 3.+0.j, 6.+0.j, 5.+0.j])\n\nArgs:\n    weight (bool): optionally sort by weight if True (Default: False).\n    By using the weight kwarg the output can additionally be sorted\n    by the number of non-identity terms in the Pauli.\n\nReturns:\n    SparsePauliOp: a sorted copy of the original table.",
        "api_signature": "sort(self, weight)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "chop",
        "full_api_name": "SparsePauliOp.chop",
        "api_description": "Set real and imaginary parts of the coefficients to 0 if ``< tol`` in magnitude.\n\nFor example, the operator representing ``1+1e-17j X + 1e-17 Y`` with a tolerance larger\nthan ``1e-17`` will be reduced to ``1 X`` whereas :meth:`.SparsePauliOp.simplify` would\nreturn ``1+1e-17j X``.\n\nIf a both the real and imaginary part of a coefficient is 0 after chopping, the\ncorresponding Pauli is removed from the operator.\n\nArgs:\n    tol (float): The absolute tolerance to check whether a real or imaginary part should\n        be set to 0.\n\nReturns:\n    SparsePauliOp: This operator with chopped coefficients.",
        "api_signature": "chop(self, tol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "sum",
        "full_api_name": "SparsePauliOp.sum",
        "api_description": "Sum of SparsePauliOps.\n\nThis is a specialized version of the builtin ``sum`` function for SparsePauliOp\nwith smaller overhead.\n\nArgs:\n    ops (list[SparsePauliOp]): a list of SparsePauliOps.\n\nReturns:\n    SparsePauliOp: the SparsePauliOp representing the sum of the input list.\n\nRaises:\n    QiskitError: if the input list is empty.\n    QiskitError: if the input list includes an object that is not SparsePauliOp.\n    QiskitError: if the numbers of qubits of the objects in the input list do not match.",
        "api_signature": "sum(ops)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "from_operator",
        "full_api_name": "SparsePauliOp.from_operator",
        "api_description": "Construct from an Operator objector.\n\nNote that the cost of this construction is exponential as it involves\ntaking inner products with every element of the N-qubit Pauli basis.\n\nArgs:\n    obj (Operator): an N-qubit operator.\n    atol (float): Optional. Absolute tolerance for checking if\n                  coefficients are zero (Default: 1e-8).\n    rtol (float): Optional. relative tolerance for checking if\n                  coefficients are zero (Default: 1e-5).\n\nReturns:\n    SparsePauliOp: the SparsePauliOp representation of the operator.\n\nRaises:\n    QiskitError: if the input operator is not an N-qubit operator.",
        "api_signature": "from_operator(obj, atol, rtol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "from_list",
        "full_api_name": "SparsePauliOp.from_list",
        "api_description": "Construct from a list of Pauli strings and coefficients.\n\nFor example, the 5-qubit Hamiltonian\n\n.. math::\n\n    H = Z_1 X_4 + 2 Y_0 Y_3\n\ncan be constructed as\n\n.. code-block:: python\n\n    # via tuples and the full Pauli string\n    op = SparsePauliOp.from_list([(\"XIIZI\", 1), (\"IYIIY\", 2)])\n\nArgs:\n    obj (Iterable[Tuple[str, complex]]): The list of 2-tuples specifying the Pauli terms.\n    dtype (type): The dtype of coeffs (Default: complex).\n    num_qubits (int): The number of qubits of the operator (Default: None).\n\nReturns:\n    SparsePauliOp: The SparsePauliOp representation of the Pauli terms.\n\nRaises:\n    QiskitError: If an empty list is passed and num_qubits is None.\n    QiskitError: If num_qubits and the objects in the input list do not match.",
        "api_signature": "from_list(obj, dtype)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "from_sparse_list",
        "full_api_name": "SparsePauliOp.from_sparse_list",
        "api_description": "Construct from a list of local Pauli strings and coefficients.\n\nEach list element is a 3-tuple of a local Pauli string, indices where to apply it,\nand a coefficient.\n\nFor example, the 5-qubit Hamiltonian\n\n.. math::\n\n    H = Z_1 X_4 + 2 Y_0 Y_3\n\ncan be constructed as\n\n.. code-block:: python\n\n    # via triples and local Paulis with indices\n    op = SparsePauliOp.from_sparse_list([(\"ZX\", [1, 4], 1), (\"YY\", [0, 3], 2)], num_qubits=5)\n\n    # equals the following construction from \"dense\" Paulis\n    op = SparsePauliOp.from_list([(\"XIIZI\", 1), (\"IYIIY\", 2)])\n\nArgs:\n    obj (Iterable[tuple[str, list[int], complex]]): The list 3-tuples specifying the Paulis.\n    num_qubits (int): The number of qubits of the operator.\n    do_checks (bool): The flag of checking if the input indices are not duplicated\n    (Default: True).\n    dtype (type): The dtype of coeffs (Default: complex).\n\nReturns:\n    SparsePauliOp: The SparsePauliOp representation of the Pauli terms.\n\nRaises:\n    QiskitError: If the number of qubits is incompatible with the indices of the Pauli terms.\n    QiskitError: If the designated qubit is already assigned.",
        "api_signature": "from_sparse_list(obj, num_qubits, do_checks, dtype)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "to_list",
        "full_api_name": "SparsePauliOp.to_list",
        "api_description": "Convert to a list Pauli string labels and coefficients.\n\nFor operators with a lot of terms converting using the ``array=True``\nkwarg will be more efficient since it allocates memory for\nthe full Numpy array of labels in advance.\n\nArgs:\n    array (bool): return a Numpy array if True, otherwise\n                  return a list (Default: False).\n\nReturns:\n    list or array: List of pairs (label, coeff) for rows of the PauliList.",
        "api_signature": "to_list(self, array)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "to_matrix",
        "full_api_name": "SparsePauliOp.to_matrix",
        "api_description": "Convert to a dense or sparse matrix.\n\nArgs:\n    sparse (bool): if True return a sparse CSR matrix, otherwise\n                   return dense Numpy array (Default: False).\n\nReturns:\n    array: A dense matrix if `sparse=False`.\n    csr_matrix: A sparse matrix in CSR format if `sparse=True`.",
        "api_signature": "to_matrix(self, sparse)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "to_operator",
        "full_api_name": "SparsePauliOp.to_operator",
        "api_description": "Convert to a matrix Operator object",
        "api_signature": "to_operator(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "label_iter",
        "full_api_name": "SparsePauliOp.label_iter",
        "api_description": "Return a label representation iterator.\n\nThis is a lazy iterator that converts each term in the SparsePauliOp\ninto a tuple (label, coeff). To convert the entire table to labels\nuse the :meth:`to_labels` method.\n\nReturns:\n    LabelIterator: label iterator object for the SparsePauliOp.",
        "api_signature": "label_iter(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "LabelIterator.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "__getitem__",
        "full_api_name": "LabelIterator.__getitem__",
        "api_description": "",
        "api_signature": "__getitem__(self, key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "matrix_iter",
        "full_api_name": "matrix_iter",
        "api_description": "Return a matrix representation iterator.\n\nThis is a lazy iterator that converts each term in the SparsePauliOp\ninto a matrix as it is used. To convert to a single matrix use the\n:meth:`to_matrix` method.\n\nArgs:\n    sparse (bool): optionally return sparse CSR matrices if True,\n                   otherwise return Numpy array matrices\n                   (Default: False)\n\nReturns:\n    MatrixIterator: matrix iterator object for the PauliList.",
        "api_signature": "matrix_iter(self, sparse)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "MatrixIterator.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "__getitem__",
        "full_api_name": "MatrixIterator.__getitem__",
        "api_description": "",
        "api_signature": "__getitem__(self, key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "_create_graph",
        "full_api_name": "_create_graph",
        "api_description": "Transform measurement operator grouping problem into graph coloring problem\n\nArgs:\n    qubit_wise (bool): whether the commutation rule is applied to the whole operator,\n        or on a per-qubit basis.\n\nReturns:\n    rustworkx.PyGraph: A class of undirected graphs",
        "api_signature": "_create_graph(self, qubit_wise)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "group_commuting",
        "full_api_name": "group_commuting",
        "api_description": "Partition a SparsePauliOp into sets of commuting Pauli strings.\n\nArgs:\n    qubit_wise (bool): whether the commutation rule is applied to the whole operator,\n        or on a per-qubit basis.  For example:\n\n        .. code-block:: python\n\n            >>> op = SparsePauliOp.from_list([(\"XX\", 2), (\"YY\", 1), (\"IZ\",2j), (\"ZZ\",1j)])\n            >>> op.group_commuting()\n            [SparsePauliOp([\"IZ\", \"ZZ\"], coeffs=[0.+2.j, 0.+1j]),\n             SparsePauliOp([\"XX\", \"YY\"], coeffs=[2.+0.j, 1.+0.j])]\n            >>> op.group_commuting(qubit_wise=True)\n            [SparsePauliOp(['XX'], coeffs=[2.+0.j]),\n             SparsePauliOp(['YY'], coeffs=[1.+0.j]),\n             SparsePauliOp(['IZ', 'ZZ'], coeffs=[0.+2.j, 0.+1.j])]\n\nReturns:\n    list[SparsePauliOp]: List of SparsePauliOp where each SparsePauliOp contains\n        commuting Pauli operators.",
        "api_signature": "group_commuting(self, qubit_wise)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "parameters",
        "full_api_name": "parameters",
        "api_description": "Return the free ``Parameter``\\s in the coefficients.",
        "api_signature": "parameters(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "assign_parameters",
        "full_api_name": "assign_parameters",
        "api_description": "Bind the free ``Parameter``\\s in the coefficients to provided values.\n\nArgs:\n    parameters: The values to bind the parameters to.\n    inplace: If ``False``, a copy of the operator with the bound parameters is returned.\n        If ``True`` the operator itself is modified.\n\nReturns:\n    A copy of the operator with bound parameters, if ``inplace`` is ``False``, otherwise\n    ``None``.",
        "api_signature": "assign_parameters(self, parameters, inplace)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "apply_layout",
        "full_api_name": "apply_layout",
        "api_description": "Apply a transpiler layout to this :class:`~.SparsePauliOp`\n\nArgs:\n    layout: Either a :class:`~.TranspileLayout` or a list of integers.\n    num_qubits: The number of qubits to expand the operator to. If not\n        provided then if ``layout`` is a :class:`~.TranspileLayout` the\n        number of the transpiler output circuit qubits will be used by\n        default. If ``layout`` is a list of integers the permutation\n        specified will be applied without any expansion.\n\n\nReturns:\n    A new :class:`.SparsePauliOp` with the provided layout applied",
        "api_signature": "apply_layout(self, layout, num_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PauliList.__init__",
        "api_description": "Initialize the PauliList.\n\nArgs:\n    data (Pauli or list): input data for Paulis. If input is a list each item in the list\n                          must be a Pauli object or Pauli str.\n\nRaises:\n    QiskitError: if input array is invalid shape.\n\nAdditional Information:\n    The input array is not copied so multiple Pauli tables\n    can share the same underlying array.",
        "api_signature": "__init__(self, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "settings",
        "full_api_name": "PauliList.settings",
        "api_description": "Return settings.",
        "api_signature": "settings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "PauliList.__array__",
        "api_description": "Convert to numpy array",
        "api_signature": "__array__(self, dtype)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "_from_paulis",
        "full_api_name": "PauliList._from_paulis",
        "api_description": "Construct a PauliList from a list of Pauli data.\n\nArgs:\n    data (iterable): list of Pauli data.\n\nReturns:\n    PauliList: the constructed PauliList.\n\nRaises:\n    QiskitError: If the input list is empty or contains invalid\n    Pauli strings.",
        "api_signature": "_from_paulis(data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "PauliList.__repr__",
        "api_description": "Display representation.",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "PauliList.__str__",
        "api_description": "Print representation.",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "_truncated_str",
        "full_api_name": "PauliList._truncated_str",
        "api_description": "",
        "api_signature": "_truncated_str(self, show_class)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "PauliList.__eq__",
        "api_description": "Entrywise comparison of Pauli equality.",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "equiv",
        "full_api_name": "PauliList.equiv",
        "api_description": "Entrywise comparison of Pauli equivalence up to global phase.\n\nArgs:\n    other (PauliList or Pauli): a comparison object.\n\nReturns:\n    np.ndarray: An array of ``True`` or ``False`` for entrywise equivalence\n                of the current table.",
        "api_signature": "equiv(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "phase",
        "full_api_name": "PauliList.phase",
        "api_description": "Return the phase exponent of the PauliList.",
        "api_signature": "phase(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "phase",
        "full_api_name": "PauliList.phase",
        "api_description": "",
        "api_signature": "phase(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "x",
        "full_api_name": "PauliList.x",
        "api_description": "The x array for the symplectic representation.",
        "api_signature": "x(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "x",
        "full_api_name": "PauliList.x",
        "api_description": "",
        "api_signature": "x(self, val)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "z",
        "full_api_name": "PauliList.z",
        "api_description": "The z array for the symplectic representation.",
        "api_signature": "z(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "z",
        "full_api_name": "PauliList.z",
        "api_description": "",
        "api_signature": "z(self, val)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "shape",
        "full_api_name": "PauliList.shape",
        "api_description": "The full shape of the :meth:`array`",
        "api_signature": "shape(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "size",
        "full_api_name": "PauliList.size",
        "api_description": "The number of Pauli rows in the table.",
        "api_signature": "size(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "__len__",
        "full_api_name": "PauliList.__len__",
        "api_description": "Return the number of Pauli rows in the table.",
        "api_signature": "__len__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "__getitem__",
        "full_api_name": "PauliList.__getitem__",
        "api_description": "Return a view of the PauliList.",
        "api_signature": "__getitem__(self, index)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "__setitem__",
        "full_api_name": "PauliList.__setitem__",
        "api_description": "Update PauliList.",
        "api_signature": "__setitem__(self, index, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "delete",
        "full_api_name": "PauliList.delete",
        "api_description": "Return a copy with Pauli rows deleted from table.\n\nWhen deleting qubits the qubit index is the same as the\ncolumn index of the underlying :attr:`X` and :attr:`Z` arrays.\n\nArgs:\n    ind (int or list): index(es) to delete.\n    qubit (bool): if ``True`` delete qubit columns, otherwise delete\n                  Pauli rows (Default: ``False``).\n\nReturns:\n    PauliList: the resulting table with the entries removed.\n\nRaises:\n    QiskitError: if ``ind`` is out of bounds for the array size or\n                 number of qubits.",
        "api_signature": "delete(self, ind, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "insert",
        "full_api_name": "PauliList.insert",
        "api_description": "Insert Paulis into the table.\n\nWhen inserting qubits the qubit index is the same as the\ncolumn index of the underlying :attr:`X` and :attr:`Z` arrays.\n\nArgs:\n    ind (int): index to insert at.\n    value (PauliList): values to insert.\n    qubit (bool): if ``True`` insert qubit columns, otherwise insert\n                  Pauli rows (Default: ``False``).\n\nReturns:\n    PauliList: the resulting table with the entries inserted.\n\nRaises:\n    QiskitError: if the insertion index is invalid.",
        "api_signature": "insert(self, ind, value, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "argsort",
        "full_api_name": "PauliList.argsort",
        "api_description": "Return indices for sorting the rows of the table.\n\nThe default sort method is lexicographic sorting by qubit number.\nBy using the `weight` kwarg the output can additionally be sorted\nby the number of non-identity terms in the Pauli, where the set of\nall Paulis of a given weight are still ordered lexicographically.\n\nArgs:\n    weight (bool): Optionally sort by weight if ``True`` (Default: ``False``).\n    phase (bool): Optionally sort by phase before weight or order\n                  (Default: ``False``).\n\nReturns:\n    array: the indices for sorting the table.",
        "api_signature": "argsort(self, weight, phase)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "sort",
        "full_api_name": "PauliList.sort",
        "api_description": "Sort the rows of the table.\n\nThe default sort method is lexicographic sorting by qubit number.\nBy using the `weight` kwarg the output can additionally be sorted\nby the number of non-identity terms in the Pauli, where the set of\nall Paulis of a given weight are still ordered lexicographically.\n\n**Example**\n\nConsider sorting all a random ordering of all 2-qubit Paulis\n\n.. code-block::\n\n    from numpy.random import shuffle\n    from qiskit.quantum_info.operators import PauliList\n\n    # 2-qubit labels\n    labels = ['II', 'IX', 'IY', 'IZ', 'XI', 'XX', 'XY', 'XZ',\n              'YI', 'YX', 'YY', 'YZ', 'ZI', 'ZX', 'ZY', 'ZZ']\n    # Shuffle Labels\n    shuffle(labels)\n    pt = PauliList(labels)\n    print('Initial Ordering')\n    print(pt)\n\n    # Lexicographic Ordering\n    srt = pt.sort()\n    print('Lexicographically sorted')\n    print(srt)\n\n    # Weight Ordering\n    srt = pt.sort(weight=True)\n    print('Weight sorted')\n    print(srt)\n\n.. parsed-literal::\n\n    Initial Ordering\n    ['YX', 'ZZ', 'XZ', 'YI', 'YZ', 'II', 'XX', 'XI', 'XY', 'YY', 'IX', 'IZ',\n     'ZY', 'ZI', 'ZX', 'IY']\n    Lexicographically sorted\n    ['II', 'IX', 'IY', 'IZ', 'XI', 'XX', 'XY', 'XZ', 'YI', 'YX', 'YY', 'YZ',\n     'ZI', 'ZX', 'ZY', 'ZZ']\n    Weight sorted\n    ['II', 'IX', 'IY', 'IZ', 'XI', 'YI', 'ZI', 'XX', 'XY', 'XZ', 'YX', 'YY',\n     'YZ', 'ZX', 'ZY', 'ZZ']\n\nArgs:\n    weight (bool): optionally sort by weight if ``True`` (Default: ``False``).\n    phase (bool): Optionally sort by phase before weight or order\n                  (Default: ``False``).\n\nReturns:\n    PauliList: a sorted copy of the original table.",
        "api_signature": "sort(self, weight, phase)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "unique",
        "full_api_name": "PauliList.unique",
        "api_description": "Return unique Paulis from the table.\n\n**Example**\n\n.. code-block::\n\n    from qiskit.quantum_info.operators import PauliList\n\n    pt = PauliList(['X', 'Y', '-X', 'I', 'I', 'Z', 'X', 'iZ'])\n    unique = pt.unique()\n    print(unique)\n\n.. parsed-literal::\n\n    ['X', 'Y', '-X', 'I', 'Z', 'iZ']\n\nArgs:\n    return_index (bool): If ``True``, also return the indices that\n                         result in the unique array.\n                         (Default: ``False``)\n    return_counts (bool): If ``True``, also return the number of times\n                          each unique item appears in the table.\n\nReturns:\n    PauliList: unique\n        the table of the unique rows.\n\n    unique_indices: np.ndarray, optional\n        The indices of the first occurrences of the unique values in\n        the original array. Only provided if ``return_index`` is ``True``.\n\n    unique_counts: np.array, optional\n        The number of times each of the unique values comes up in the\n        original array. Only provided if ``return_counts`` is ``True``.",
        "api_signature": "unique(self, return_index, return_counts)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "tensor",
        "full_api_name": "PauliList.tensor",
        "api_description": "Return the tensor product with each Pauli in the list.\n\nArgs:\n    other (PauliList): another PauliList.\n\nReturns:\n    PauliList: the list of tensor product Paulis.\n\nRaises:\n    QiskitError: if other cannot be converted to a PauliList, does\n                 not have either 1 or the same number of Paulis as\n                 the current list.",
        "api_signature": "tensor(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "expand",
        "full_api_name": "PauliList.expand",
        "api_description": "Return the expand product of each Pauli in the list.\n\nArgs:\n    other (PauliList): another PauliList.\n\nReturns:\n    PauliList: the list of tensor product Paulis.\n\nRaises:\n    QiskitError: if other cannot be converted to a PauliList, does\n                 not have either 1 or the same number of Paulis as\n                 the current list.",
        "api_signature": "expand(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "compose",
        "full_api_name": "PauliList.compose",
        "api_description": "Return the composition self\u2218other for each Pauli in the list.\n\nArgs:\n    other (PauliList): another PauliList.\n    qargs (None or list): qubits to apply dot product on (Default: ``None``).\n    front (bool): If True use `dot` composition method [default: ``False``].\n    inplace (bool): If ``True`` update in-place (default: ``False``).\n\nReturns:\n    PauliList: the list of composed Paulis.\n\nRaises:\n    QiskitError: if other cannot be converted to a PauliList, does\n                 not have either 1 or the same number of Paulis as\n                 the current list, or has the wrong number of qubits\n                 for the specified ``qargs``.",
        "api_signature": "compose(self, other, qargs, front, inplace)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "dot",
        "full_api_name": "PauliList.dot",
        "api_description": "Return the composition other\u2218self for each Pauli in the list.\n\nArgs:\n    other (PauliList): another PauliList.\n    qargs (None or list): qubits to apply dot product on (Default: ``None``).\n    inplace (bool): If True update in-place (default: ``False``).\n\nReturns:\n    PauliList: the list of composed Paulis.\n\nRaises:\n    QiskitError: if other cannot be converted to a PauliList, does\n                 not have either 1 or the same number of Paulis as\n                 the current list, or has the wrong number of qubits\n                 for the specified ``qargs``.",
        "api_signature": "dot(self, other, qargs, inplace)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "_add",
        "full_api_name": "PauliList._add",
        "api_description": "Append two PauliLists.\n\nIf ``qargs`` are specified the other operator will be added\nassuming it is identity on all other subsystems.\n\nArgs:\n    other (PauliList): another table.\n    qargs (None or list): optional subsystems to add on\n                          (Default: ``None``)\n\nReturns:\n    PauliList: the concatenated list ``self`` + ``other``.",
        "api_signature": "_add(self, other, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "_multiply",
        "full_api_name": "PauliList._multiply",
        "api_description": "Multiply each Pauli in the list by a phase.\n\nArgs:\n    other (complex or array): a complex number in [1, -1j, -1, 1j]\n\nReturns:\n    PauliList: the list of Paulis other * self.\n\nRaises:\n    QiskitError: if the phase is not in the set [1, -1j, -1, 1j].",
        "api_signature": "_multiply(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "conjugate",
        "full_api_name": "PauliList.conjugate",
        "api_description": "Return the conjugate of each Pauli in the list.",
        "api_signature": "conjugate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "transpose",
        "full_api_name": "PauliList.transpose",
        "api_description": "Return the transpose of each Pauli in the list.",
        "api_signature": "transpose(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "adjoint",
        "full_api_name": "PauliList.adjoint",
        "api_description": "Return the adjoint of each Pauli in the list.",
        "api_signature": "adjoint(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "PauliList.inverse",
        "api_description": "Return the inverse of each Pauli in the list.",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "commutes",
        "full_api_name": "PauliList.commutes",
        "api_description": "Return True for each Pauli that commutes with other.\n\nArgs:\n    other (PauliList): another PauliList operator.\n    qargs (list): qubits to apply dot product on (default: ``None``).\n\nReturns:\n    bool: ``True`` if Paulis commute, ``False`` if they anti-commute.",
        "api_signature": "commutes(self, other, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "anticommutes",
        "full_api_name": "PauliList.anticommutes",
        "api_description": "Return ``True`` if other Pauli that anticommutes with other.\n\nArgs:\n    other (PauliList): another PauliList operator.\n    qargs (list): qubits to apply dot product on (default: ``None``).\n\nReturns:\n    bool: ``True`` if Paulis anticommute, ``False`` if they commute.",
        "api_signature": "anticommutes(self, other, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "commutes_with_all",
        "full_api_name": "PauliList.commutes_with_all",
        "api_description": "Return indexes of rows that commute ``other``.\n\nIf ``other`` is a multi-row Pauli list the returned vector indexes rows\nof the current PauliList that commute with *all* Paulis in other.\nIf no rows satisfy the condition the returned array will be empty.\n\nArgs:\n    other (PauliList): a single Pauli or multi-row PauliList.\n\nReturns:\n    array: index array of the commuting rows.",
        "api_signature": "commutes_with_all(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "anticommutes_with_all",
        "full_api_name": "PauliList.anticommutes_with_all",
        "api_description": "Return indexes of rows that commute other.\n\nIf ``other`` is a multi-row Pauli list the returned vector indexes rows\nof the current PauliList that anti-commute with *all* Paulis in other.\nIf no rows satisfy the condition the returned array will be empty.\n\nArgs:\n    other (PauliList): a single Pauli or multi-row PauliList.\n\nReturns:\n    array: index array of the anti-commuting rows.",
        "api_signature": "anticommutes_with_all(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "_commutes_with_all",
        "full_api_name": "PauliList._commutes_with_all",
        "api_description": "Return row indexes that commute with all rows in another PauliList.\n\nArgs:\n    other (PauliList): a PauliList.\n    anti (bool): if ``True`` return rows that anti-commute, otherwise\n                 return rows that commute (Default: ``False``).\n\nReturns:\n    array: index array of commuting or anti-commuting row.",
        "api_signature": "_commutes_with_all(self, other, anti)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "evolve",
        "full_api_name": "PauliList.evolve",
        "api_description": "Performs either Heisenberg (default) or Schr\u00f6dinger picture\nevolution of the Pauli by a Clifford and returns the evolved Pauli.\n\nSchr\u00f6dinger picture evolution can be chosen by passing parameter ``frame='s'``.\nThis option yields a faster calculation.\n\nHeisenberg picture evolves the Pauli as :math:`P^\\prime = C^\\dagger.P.C`.\n\nSchr\u00f6dinger picture evolves the Pauli as :math:`P^\\prime = C.P.C^\\dagger`.\n\nArgs:\n    other (Pauli or Clifford or QuantumCircuit): The Clifford operator to evolve by.\n    qargs (list): a list of qubits to apply the Clifford to.\n    frame (string): ``'h'`` for Heisenberg (default) or ``'s'`` for Schr\u00f6dinger framework.\n\nReturns:\n    PauliList: the Pauli :math:`C^\\dagger.P.C` (Heisenberg picture)\n    or the Pauli :math:`C.P.C^\\dagger` (Schr\u00f6dinger picture).\n\nRaises:\n    QiskitError: if the Clifford number of qubits and qargs don't match.",
        "api_signature": "evolve(self, other, qargs, frame)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "to_labels",
        "full_api_name": "PauliList.to_labels",
        "api_description": "Convert a PauliList to a list Pauli string labels.\n\nFor large PauliLists converting using the ``array=True``\nkwarg will be more efficient since it allocates memory for\nthe full Numpy array of labels in advance.\n\n.. list-table:: Pauli Representations\n    :header-rows: 1\n\n    * - Label\n      - Symplectic\n      - Matrix\n    * - ``\"I\"``\n      - :math:`[0, 0]`\n      - :math:`\\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\end{bmatrix}`\n    * - ``\"X\"``\n      - :math:`[1, 0]`\n      - :math:`\\begin{bmatrix} 0 & 1 \\\\ 1 & 0  \\end{bmatrix}`\n    * - ``\"Y\"``\n      - :math:`[1, 1]`\n      - :math:`\\begin{bmatrix} 0 & -i \\\\ i & 0  \\end{bmatrix}`\n    * - ``\"Z\"``\n      - :math:`[0, 1]`\n      - :math:`\\begin{bmatrix} 1 & 0 \\\\ 0 & -1  \\end{bmatrix}`\n\nArgs:\n    array (bool): return a Numpy array if ``True``, otherwise\n                  return a list (Default: ``False``).\n\nReturns:\n    list or array: The rows of the PauliList in label form.",
        "api_signature": "to_labels(self, array)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "to_matrix",
        "full_api_name": "PauliList.to_matrix",
        "api_description": "Convert to a list or array of Pauli matrices.\n\nFor large PauliLists converting using the ``array=True``\nkwarg will be more efficient since it allocates memory a full\nrank-3 Numpy array of matrices in advance.\n\n.. list-table:: Pauli Representations\n    :header-rows: 1\n\n    * - Label\n      - Symplectic\n      - Matrix\n    * - ``\"I\"``\n      - :math:`[0, 0]`\n      - :math:`\\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\end{bmatrix}`\n    * - ``\"X\"``\n      - :math:`[1, 0]`\n      - :math:`\\begin{bmatrix} 0 & 1 \\\\ 1 & 0  \\end{bmatrix}`\n    * - ``\"Y\"``\n      - :math:`[1, 1]`\n      - :math:`\\begin{bmatrix} 0 & -i \\\\ i & 0  \\end{bmatrix}`\n    * - ``\"Z\"``\n      - :math:`[0, 1]`\n      - :math:`\\begin{bmatrix} 1 & 0 \\\\ 0 & -1  \\end{bmatrix}`\n\nArgs:\n    sparse (bool): if ``True`` return sparse CSR matrices, otherwise\n                   return dense Numpy arrays (Default: ``False``).\n    array (bool): return as rank-3 numpy array if ``True``, otherwise\n                  return a list of Numpy arrays (Default: ``False``).\n\nReturns:\n    list: A list of dense Pauli matrices if ``array=False` and ``sparse=False`.\n    list: A list of sparse Pauli matrices if ``array=False`` and ``sparse=True``.\n    array: A dense rank-3 array of Pauli matrices if ``array=True``.",
        "api_signature": "to_matrix(self, sparse, array)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "label_iter",
        "full_api_name": "PauliList.label_iter",
        "api_description": "Return a label representation iterator.\n\nThis is a lazy iterator that converts each row into the string\nlabel only as it is used. To convert the entire table to labels use\nthe :meth:`to_labels` method.\n\nReturns:\n    LabelIterator: label iterator object for the PauliList.",
        "api_signature": "label_iter(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "LabelIterator.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "__getitem__",
        "full_api_name": "LabelIterator.__getitem__",
        "api_description": "",
        "api_signature": "__getitem__(self, key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "matrix_iter",
        "full_api_name": "matrix_iter",
        "api_description": "Return a matrix representation iterator.\n\nThis is a lazy iterator that converts each row into the Pauli matrix\nrepresentation only as it is used. To convert the entire table to\nmatrices use the :meth:`to_matrix` method.\n\nArgs:\n    sparse (bool): optionally return sparse CSR matrices if ``True``,\n                   otherwise return Numpy array matrices\n                   (Default: ``False``)\n\nReturns:\n    MatrixIterator: matrix iterator object for the PauliList.",
        "api_signature": "matrix_iter(self, sparse)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "MatrixIterator.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "__getitem__",
        "full_api_name": "MatrixIterator.__getitem__",
        "api_description": "",
        "api_signature": "__getitem__(self, key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "from_symplectic",
        "full_api_name": "from_symplectic",
        "api_description": "Construct a PauliList from a symplectic data.\n\nArgs:\n    z (np.ndarray): 2D boolean Numpy array.\n    x (np.ndarray): 2D boolean Numpy array.\n    phase (np.ndarray or None): Optional, 1D integer array from Z_4.\n\nReturns:\n    PauliList: the constructed PauliList.",
        "api_signature": "from_symplectic(cls, z, x, phase)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "_noncommutation_graph",
        "full_api_name": "_noncommutation_graph",
        "api_description": "Create an edge list representing the non-commutation graph (Pauli Graph).\n\nAn edge (i, j) is present if i and j are not commutable.\n\nArgs:\n    qubit_wise (bool): whether the commutation rule is applied to the whole operator,\n        or on a per-qubit basis.\n\nReturns:\n    list[tuple[int,int]]: A list of pairs of indices of the PauliList that are not commutable.",
        "api_signature": "_noncommutation_graph(self, qubit_wise)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "_create_graph",
        "full_api_name": "_create_graph",
        "api_description": "Transform measurement operator grouping problem into graph coloring problem\n\nArgs:\n    qubit_wise (bool): whether the commutation rule is applied to the whole operator,\n        or on a per-qubit basis.\n\nReturns:\n    rustworkx.PyGraph: A class of undirected graphs",
        "api_signature": "_create_graph(self, qubit_wise)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "group_qubit_wise_commuting",
        "full_api_name": "group_qubit_wise_commuting",
        "api_description": "Partition a PauliList into sets of mutually qubit-wise commuting Pauli strings.\n\nReturns:\n    list[PauliList]: List of PauliLists where each PauliList contains commutable Pauli operators.",
        "api_signature": "group_qubit_wise_commuting(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "group_commuting",
        "full_api_name": "group_commuting",
        "api_description": "Partition a PauliList into sets of commuting Pauli strings.\n\nArgs:\n    qubit_wise (bool): whether the commutation rule is applied to the whole operator,\n        or on a per-qubit basis.  For example:\n\n        .. code-block:: python\n\n            >>> from qiskit.quantum_info import PauliList\n            >>> op = PauliList([\"XX\", \"YY\", \"IZ\", \"ZZ\"])\n            >>> op.group_commuting()\n            [PauliList(['XX', 'YY']), PauliList(['IZ', 'ZZ'])]\n            >>> op.group_commuting(qubit_wise=True)\n            [PauliList(['XX']), PauliList(['YY']), PauliList(['IZ', 'ZZ'])]\n\nReturns:\n    list[PauliList]: List of PauliLists where each PauliList contains commuting Pauli operators.",
        "api_signature": "group_commuting(self, qubit_wise)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BasePauli.__init__",
        "api_description": "Initialize the BasePauli.\n\nThis is an array of M N-qubit Paulis defined as\nP = (-i)^phase Z^z X^x.\n\nArgs:\n    z (np.ndarray): input z matrix.\n    x (np.ndarray): input x matrix.\n    phase (np.ndarray): input phase vector.",
        "api_signature": "__init__(self, z, x, phase)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/base_pauli.py"
    },
    {
        "api_name": "copy",
        "full_api_name": "BasePauli.copy",
        "api_description": "Make a deep copy of current operator.",
        "api_signature": "copy(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/base_pauli.py"
    },
    {
        "api_name": "tensor",
        "full_api_name": "BasePauli.tensor",
        "api_description": "",
        "api_signature": "tensor(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/base_pauli.py"
    },
    {
        "api_name": "expand",
        "full_api_name": "BasePauli.expand",
        "api_description": "",
        "api_signature": "expand(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/base_pauli.py"
    },
    {
        "api_name": "_tensor",
        "full_api_name": "BasePauli._tensor",
        "api_description": "",
        "api_signature": "_tensor(cls, a, b)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/base_pauli.py"
    },
    {
        "api_name": "compose",
        "full_api_name": "BasePauli.compose",
        "api_description": "",
        "api_signature": "compose(self, other, qargs, front, inplace)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/base_pauli.py"
    },
    {
        "api_name": "_multiply",
        "full_api_name": "BasePauli._multiply",
        "api_description": "",
        "api_signature": "_multiply(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/base_pauli.py"
    },
    {
        "api_name": "conjugate",
        "full_api_name": "BasePauli.conjugate",
        "api_description": "Return the conjugate of each Pauli in the list.",
        "api_signature": "conjugate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/base_pauli.py"
    },
    {
        "api_name": "transpose",
        "full_api_name": "BasePauli.transpose",
        "api_description": "Return the transpose of each Pauli in the list.",
        "api_signature": "transpose(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/base_pauli.py"
    },
    {
        "api_name": "commutes",
        "full_api_name": "BasePauli.commutes",
        "api_description": "Return ``True`` if Pauli commutes with ``other``.\n\nArgs:\n    other (BasePauli): another BasePauli operator.\n    qargs (list): qubits to apply dot product on (default: ``None``).\n\nReturns:\n    np.array: Boolean array of ``True`` if Paulis commute, ``False`` if\n              they anti-commute.\n\nRaises:\n    QiskitError: if number of qubits of ``other`` does not match ``qargs``.",
        "api_signature": "commutes(self, other, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/base_pauli.py"
    },
    {
        "api_name": "evolve",
        "full_api_name": "BasePauli.evolve",
        "api_description": "Performs either Heisenberg (default) or Schr\u00f6dinger picture\nevolution of the Pauli by a Clifford and returns the evolved Pauli.\n\nSchr\u00f6dinger picture evolution can be chosen by passing parameter ``frame='s'``.\nThis option yields a faster calculation.\n\nHeisenberg picture evolves the Pauli as :math:`P^\\prime = C^\\dagger.P.C`.\n\nSchr\u00f6dinger picture evolves the Pauli as :math:`P^\\prime = C.P.C^\\dagger`.\n\nArgs:\n    other (BasePauli or QuantumCircuit): The Clifford circuit to evolve by.\n    qargs (list): a list of qubits to apply the Clifford to.\n    frame (string): ``'h'`` for Heisenberg or ``'s'`` for Schr\u00f6dinger framework.\n\nReturns:\n    BasePauli: the Pauli :math:`C^\\dagger.P.C` (Heisenberg picture)\n    or the Pauli :math:`C.P.C^\\dagger` (Schr\u00f6dinger picture).\n\nRaises:\n    QiskitError: if the Clifford number of qubits and ``qargs`` don't match.",
        "api_signature": "evolve(self, other, qargs, frame)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/base_pauli.py"
    },
    {
        "api_name": "_evolve_clifford",
        "full_api_name": "BasePauli._evolve_clifford",
        "api_description": "Heisenberg picture evolution of a Pauli by a Clifford.",
        "api_signature": "_evolve_clifford(self, other, qargs, frame)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/base_pauli.py"
    },
    {
        "api_name": "_eq",
        "full_api_name": "BasePauli._eq",
        "api_description": "Entrywise comparison of Pauli equality.",
        "api_signature": "_eq(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/base_pauli.py"
    },
    {
        "api_name": "__imul__",
        "full_api_name": "BasePauli.__imul__",
        "api_description": "",
        "api_signature": "__imul__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/base_pauli.py"
    },
    {
        "api_name": "__neg__",
        "full_api_name": "BasePauli.__neg__",
        "api_description": "",
        "api_signature": "__neg__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/base_pauli.py"
    },
    {
        "api_name": "_count_y",
        "full_api_name": "BasePauli._count_y",
        "api_description": "Count the number of I Paulis",
        "api_signature": "_count_y(self, dtype)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/base_pauli.py"
    },
    {
        "api_name": "_stack",
        "full_api_name": "BasePauli._stack",
        "api_description": "Stack array.",
        "api_signature": "_stack(array, size, vertical)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/base_pauli.py"
    },
    {
        "api_name": "_phase_from_complex",
        "full_api_name": "BasePauli._phase_from_complex",
        "api_description": "Return the phase from a label",
        "api_signature": "_phase_from_complex(coeff)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/base_pauli.py"
    },
    {
        "api_name": "_from_array",
        "full_api_name": "BasePauli._from_array",
        "api_description": "Convert array data to BasePauli data.",
        "api_signature": "_from_array(z, x, phase)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/base_pauli.py"
    },
    {
        "api_name": "_to_matrix",
        "full_api_name": "BasePauli._to_matrix",
        "api_description": "Return the matrix from symplectic representation.\n\nThe Pauli is defined as :math:`P = (-i)^{phase + z.x} * Z^z.x^x`\nwhere ``array = [x, z]``.\n\nArgs:\n    z (array): The symplectic representation z vector.\n    x (array): The symplectic representation x vector.\n    phase (int): Pauli phase.\n    group_phase (bool): Optional. If ``True`` use group-phase convention\n                        instead of BasePauli ZX-phase convention.\n                        (default: ``False``).\n    sparse (bool): Optional. Of ``True`` return a sparse CSR matrix,\n                   otherwise return a dense Numpy array\n                   (default: ``False``).\n\nReturns:\n    array: if ``sparse=False``.\n    csr_matrix: if ``sparse=True``.",
        "api_signature": "_to_matrix(z, x, phase, group_phase, sparse)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/base_pauli.py"
    },
    {
        "api_name": "_to_label",
        "full_api_name": "BasePauli._to_label",
        "api_description": "Return the label string for a Pauli.\n\nArgs:\n    z (array): The symplectic representation z vector.\n    x (array): The symplectic representation x vector.\n    phase (int): Pauli phase.\n    group_phase (bool): Optional. If ``True`` use group-phase convention\n                        instead of BasePauli ZX-phase convention.\n                        (default: ``False``).\n    full_group (bool): If True return the Pauli label from the full Pauli group\n        including complex coefficient from [1, -1, 1j, -1j]. If\n        ``False`` return the unsigned Pauli label with coefficient 1\n        (default: ``True``).\n    return_phase (bool): If ``True`` return the adjusted phase for the coefficient\n        of the returned Pauli label. This can be used even if\n        ``full_group=False``.\n\nReturns:\n    str: the Pauli label from the full Pauli group (if ``full_group=True``) or\n        from the unsigned Pauli group (if ``full_group=False``).\n    tuple[str, int]: if ``return_phase=True`` returns a tuple of the Pauli\n                    label (from either the full or unsigned Pauli group) and\n                    the phase ``q`` for the coefficient :math:`(-i)^(q + x.z)`\n                    for the label from the full Pauli group.",
        "api_signature": "_to_label(z, x, phase, group_phase, full_group, return_phase)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/base_pauli.py"
    },
    {
        "api_name": "_append_circuit",
        "full_api_name": "BasePauli._append_circuit",
        "api_description": "Update BasePauli inplace by applying a Clifford circuit.\n\nArgs:\n    circuit (QuantumCircuit or Instruction): the gate or composite gate to apply.\n    qargs (list or None): The qubits to apply gate to.\n\nReturns:\n    BasePauli: the updated Pauli.\n\nRaises:\n    QiskitError: if input gate cannot be decomposed into Clifford gates.",
        "api_signature": "_append_circuit(self, circuit, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/base_pauli.py"
    },
    {
        "api_name": "_evolve_h",
        "full_api_name": "_evolve_h",
        "api_description": "Update P -> H.P.H",
        "api_signature": "_evolve_h(base_pauli, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/base_pauli.py"
    },
    {
        "api_name": "_evolve_s",
        "full_api_name": "_evolve_s",
        "api_description": "Update P -> S.P.Sdg",
        "api_signature": "_evolve_s(base_pauli, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/base_pauli.py"
    },
    {
        "api_name": "_evolve_sdg",
        "full_api_name": "_evolve_sdg",
        "api_description": "Update P -> Sdg.P.S",
        "api_signature": "_evolve_sdg(base_pauli, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/base_pauli.py"
    },
    {
        "api_name": "_evolve_i",
        "full_api_name": "_evolve_i",
        "api_description": "Update P -> P",
        "api_signature": "_evolve_i(base_pauli, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/base_pauli.py"
    },
    {
        "api_name": "_evolve_x",
        "full_api_name": "_evolve_x",
        "api_description": "Update P -> X.P.X",
        "api_signature": "_evolve_x(base_pauli, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/base_pauli.py"
    },
    {
        "api_name": "_evolve_y",
        "full_api_name": "_evolve_y",
        "api_description": "Update P -> Y.P.Y",
        "api_signature": "_evolve_y(base_pauli, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/base_pauli.py"
    },
    {
        "api_name": "_evolve_z",
        "full_api_name": "_evolve_z",
        "api_description": "Update P -> Z.P.Z",
        "api_signature": "_evolve_z(base_pauli, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/base_pauli.py"
    },
    {
        "api_name": "_evolve_cx",
        "full_api_name": "_evolve_cx",
        "api_description": "Update P -> CX.P.CX",
        "api_signature": "_evolve_cx(base_pauli, qctrl, qtrgt)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/base_pauli.py"
    },
    {
        "api_name": "_evolve_cz",
        "full_api_name": "_evolve_cz",
        "api_description": "Update P -> CZ.P.CZ",
        "api_signature": "_evolve_cz(base_pauli, q1, q2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/base_pauli.py"
    },
    {
        "api_name": "_evolve_cy",
        "full_api_name": "_evolve_cy",
        "api_description": "Update P -> CY.P.CY",
        "api_signature": "_evolve_cy(base_pauli, qctrl, qtrgt)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/base_pauli.py"
    },
    {
        "api_name": "_evolve_swap",
        "full_api_name": "_evolve_swap",
        "api_description": "Update P -> SWAP.P.SWAP",
        "api_signature": "_evolve_swap(base_pauli, q1, q2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/base_pauli.py"
    },
    {
        "api_name": "_count_y",
        "full_api_name": "_count_y",
        "api_description": "Count the number of I Paulis",
        "api_signature": "_count_y(x, z, dtype)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/base_pauli.py"
    },
    {
        "api_name": "_append_circuit",
        "full_api_name": "_append_circuit",
        "api_description": "Update Clifford inplace by applying a Clifford circuit.\n\nArgs:\n    clifford (Clifford): The Clifford to update.\n    circuit (QuantumCircuit): The circuit to apply.\n    qargs (list or None): The qubits to apply circuit to.\n\nReturns:\n    Clifford: the updated Clifford.\n\nRaises:\n    QiskitError: if input circuit cannot be decomposed into Clifford operations.",
        "api_signature": "_append_circuit(clifford, circuit, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford_circuits.py"
    },
    {
        "api_name": "_append_operation",
        "full_api_name": "_append_operation",
        "api_description": "Update Clifford inplace by applying a Clifford operation.\n\nArgs:\n    clifford (Clifford): The Clifford to update.\n    operation (Instruction or Clifford or str): The operation or composite operation to apply.\n    qargs (list or None): The qubits to apply operation to.\n\nReturns:\n    Clifford: the updated Clifford.\n\nRaises:\n    QiskitError: if input operation cannot be converted into Clifford operations.",
        "api_signature": "_append_operation(clifford, operation, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford_circuits.py"
    },
    {
        "api_name": "_n_half_pis",
        "full_api_name": "_n_half_pis",
        "api_description": "",
        "api_signature": "_n_half_pis(param)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford_circuits.py"
    },
    {
        "api_name": "_append_rz",
        "full_api_name": "_append_rz",
        "api_description": "Apply an Rz gate to a Clifford.\n\nArgs:\n    clifford (Clifford): a Clifford.\n    qubit (int): gate qubit index.\n    multiple (int): z-rotation angle in a multiple of pi/2\n\nReturns:\n    Clifford: the updated Clifford.",
        "api_signature": "_append_rz(clifford, qubit, multiple)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford_circuits.py"
    },
    {
        "api_name": "_append_i",
        "full_api_name": "_append_i",
        "api_description": "Apply an I gate to a Clifford.\n\nArgs:\n    clifford (Clifford): a Clifford.\n    qubit (int): gate qubit index.\n\nReturns:\n    Clifford: the updated Clifford.",
        "api_signature": "_append_i(clifford, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford_circuits.py"
    },
    {
        "api_name": "_append_x",
        "full_api_name": "_append_x",
        "api_description": "Apply an X gate to a Clifford.\n\nArgs:\n    clifford (Clifford): a Clifford.\n    qubit (int): gate qubit index.\n\nReturns:\n    Clifford: the updated Clifford.",
        "api_signature": "_append_x(clifford, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford_circuits.py"
    },
    {
        "api_name": "_append_y",
        "full_api_name": "_append_y",
        "api_description": "Apply a Y gate to a Clifford.\n\nArgs:\n    clifford (Clifford): a Clifford.\n    qubit (int): gate qubit index.\n\nReturns:\n    Clifford: the updated Clifford.",
        "api_signature": "_append_y(clifford, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford_circuits.py"
    },
    {
        "api_name": "_append_z",
        "full_api_name": "_append_z",
        "api_description": "Apply an Z gate to a Clifford.\n\nArgs:\n    clifford (Clifford): a Clifford.\n    qubit (int): gate qubit index.\n\nReturns:\n    Clifford: the updated Clifford.",
        "api_signature": "_append_z(clifford, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford_circuits.py"
    },
    {
        "api_name": "_append_h",
        "full_api_name": "_append_h",
        "api_description": "Apply a H gate to a Clifford.\n\nArgs:\n    clifford (Clifford): a Clifford.\n    qubit (int): gate qubit index.\n\nReturns:\n    Clifford: the updated Clifford.",
        "api_signature": "_append_h(clifford, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford_circuits.py"
    },
    {
        "api_name": "_append_s",
        "full_api_name": "_append_s",
        "api_description": "Apply an S gate to a Clifford.\n\nArgs:\n    clifford (Clifford): a Clifford.\n    qubit (int): gate qubit index.\n\nReturns:\n    Clifford: the updated Clifford.",
        "api_signature": "_append_s(clifford, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford_circuits.py"
    },
    {
        "api_name": "_append_sdg",
        "full_api_name": "_append_sdg",
        "api_description": "Apply an Sdg gate to a Clifford.\n\nArgs:\n    clifford (Clifford): a Clifford.\n    qubit (int): gate qubit index.\n\nReturns:\n    Clifford: the updated Clifford.",
        "api_signature": "_append_sdg(clifford, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford_circuits.py"
    },
    {
        "api_name": "_append_sx",
        "full_api_name": "_append_sx",
        "api_description": "Apply an SX gate to a Clifford.\n\nArgs:\n    clifford (Clifford): a Clifford.\n    qubit (int): gate qubit index.\n\nReturns:\n    Clifford: the updated Clifford.",
        "api_signature": "_append_sx(clifford, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford_circuits.py"
    },
    {
        "api_name": "_append_sxdg",
        "full_api_name": "_append_sxdg",
        "api_description": "Apply an SXdg gate to a Clifford.\n\nArgs:\n    clifford (Clifford): a Clifford.\n    qubit (int): gate qubit index.\n\nReturns:\n    Clifford: the updated Clifford.",
        "api_signature": "_append_sxdg(clifford, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford_circuits.py"
    },
    {
        "api_name": "_append_v",
        "full_api_name": "_append_v",
        "api_description": "Apply a V gate to a Clifford.\n\nThis is equivalent to an Sdg gate followed by a H gate.\n\nArgs:\n    clifford (Clifford): a Clifford.\n    qubit (int): gate qubit index.\n\nReturns:\n    Clifford: the updated Clifford.",
        "api_signature": "_append_v(clifford, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford_circuits.py"
    },
    {
        "api_name": "_append_w",
        "full_api_name": "_append_w",
        "api_description": "Apply a W gate to a Clifford.\n\nThis is equivalent to two V gates.\n\nArgs:\n    clifford (Clifford): a Clifford.\n    qubit (int): gate qubit index.\n\nReturns:\n    Clifford: the updated Clifford.",
        "api_signature": "_append_w(clifford, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford_circuits.py"
    },
    {
        "api_name": "_append_cx",
        "full_api_name": "_append_cx",
        "api_description": "Apply a CX gate to a Clifford.\n\nArgs:\n    clifford (Clifford): a Clifford.\n    control (int): gate control qubit index.\n    target (int): gate target qubit index.\n\nReturns:\n    Clifford: the updated Clifford.",
        "api_signature": "_append_cx(clifford, control, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford_circuits.py"
    },
    {
        "api_name": "_append_cz",
        "full_api_name": "_append_cz",
        "api_description": "Apply a CZ gate to a Clifford.\n\nArgs:\n    clifford (Clifford): a Clifford.\n    control (int): gate control qubit index.\n    target (int): gate target qubit index.\n\nReturns:\n    Clifford: the updated Clifford.",
        "api_signature": "_append_cz(clifford, control, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford_circuits.py"
    },
    {
        "api_name": "_append_cy",
        "full_api_name": "_append_cy",
        "api_description": "Apply a CY gate to a Clifford.\n\nArgs:\n    clifford (Clifford): a Clifford.\n    control (int): gate control qubit index.\n    target (int): gate target qubit index.\n\nReturns:\n    Clifford: the updated Clifford.",
        "api_signature": "_append_cy(clifford, control, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford_circuits.py"
    },
    {
        "api_name": "_append_swap",
        "full_api_name": "_append_swap",
        "api_description": "Apply a Swap gate to a Clifford.\n\nArgs:\n    clifford (Clifford): a Clifford.\n    qubit0 (int): first qubit index.\n    qubit1 (int): second  qubit index.\n\nReturns:\n    Clifford: the updated Clifford.",
        "api_signature": "_append_swap(clifford, qubit0, qubit1)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford_circuits.py"
    },
    {
        "api_name": "_append_iswap",
        "full_api_name": "_append_iswap",
        "api_description": "Apply a iSwap gate to a Clifford.\n\nArgs:\n    clifford (Clifford): a Clifford.\n    qubit0 (int): first qubit index.\n    qubit1 (int): second  qubit index.\n\nReturns:\n    Clifford: the updated Clifford.",
        "api_signature": "_append_iswap(clifford, qubit0, qubit1)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford_circuits.py"
    },
    {
        "api_name": "_append_dcx",
        "full_api_name": "_append_dcx",
        "api_description": "Apply a DCX gate to a Clifford.\n\nArgs:\n    clifford (Clifford): a Clifford.\n    qubit0 (int): first qubit index.\n    qubit1 (int): second  qubit index.\n\nReturns:\n    Clifford: the updated Clifford.",
        "api_signature": "_append_dcx(clifford, qubit0, qubit1)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford_circuits.py"
    },
    {
        "api_name": "_append_ecr",
        "full_api_name": "_append_ecr",
        "api_description": "Apply an ECR gate to a Clifford.\n\nArgs:\n    clifford (Clifford): a Clifford.\n    qubit0 (int): first qubit index.\n    qubit1 (int): second  qubit index.\n\nReturns:\n    Clifford: the updated Clifford.",
        "api_signature": "_append_ecr(clifford, qubit0, qubit1)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford_circuits.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "Clifford.__array__",
        "api_description": "",
        "api_signature": "__array__(self, dtype)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Clifford.__init__",
        "api_description": "Initialize an operator object.",
        "api_signature": "__init__(self, data, validate, copy)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "name",
        "full_api_name": "Clifford.name",
        "api_description": "Unique string identifier for operation type.",
        "api_signature": "name(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "num_clbits",
        "full_api_name": "Clifford.num_clbits",
        "api_description": "Number of classical bits.",
        "api_signature": "num_clbits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "Clifford.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "Clifford.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "Clifford.__eq__",
        "api_description": "Check if two Clifford tables are equal",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "copy",
        "full_api_name": "Clifford.copy",
        "api_description": "",
        "api_signature": "copy(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "__getitem__",
        "full_api_name": "Clifford.__getitem__",
        "api_description": "Return a stabilizer Pauli row",
        "api_signature": "__getitem__(self, key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "__setitem__",
        "full_api_name": "Clifford.__setitem__",
        "api_description": "Set a stabilizer Pauli row",
        "api_signature": "__setitem__(self, key, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "symplectic_matrix",
        "full_api_name": "Clifford.symplectic_matrix",
        "api_description": "Return boolean symplectic matrix.",
        "api_signature": "symplectic_matrix(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "symplectic_matrix",
        "full_api_name": "Clifford.symplectic_matrix",
        "api_description": "",
        "api_signature": "symplectic_matrix(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "phase",
        "full_api_name": "Clifford.phase",
        "api_description": "Return phase with boolean representation.",
        "api_signature": "phase(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "phase",
        "full_api_name": "Clifford.phase",
        "api_description": "",
        "api_signature": "phase(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "x",
        "full_api_name": "Clifford.x",
        "api_description": "The x array for the symplectic representation.",
        "api_signature": "x(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "x",
        "full_api_name": "Clifford.x",
        "api_description": "",
        "api_signature": "x(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "z",
        "full_api_name": "Clifford.z",
        "api_description": "The z array for the symplectic representation.",
        "api_signature": "z(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "z",
        "full_api_name": "Clifford.z",
        "api_description": "",
        "api_signature": "z(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "destab",
        "full_api_name": "Clifford.destab",
        "api_description": "The destabilizer array for the symplectic representation.",
        "api_signature": "destab(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "destab",
        "full_api_name": "Clifford.destab",
        "api_description": "",
        "api_signature": "destab(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "destab_x",
        "full_api_name": "Clifford.destab_x",
        "api_description": "The destabilizer x array for the symplectic representation.",
        "api_signature": "destab_x(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "destab_x",
        "full_api_name": "Clifford.destab_x",
        "api_description": "",
        "api_signature": "destab_x(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "destab_z",
        "full_api_name": "Clifford.destab_z",
        "api_description": "The destabilizer z array for the symplectic representation.",
        "api_signature": "destab_z(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "destab_z",
        "full_api_name": "Clifford.destab_z",
        "api_description": "",
        "api_signature": "destab_z(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "destab_phase",
        "full_api_name": "Clifford.destab_phase",
        "api_description": "Return phase of destabilizer with boolean representation.",
        "api_signature": "destab_phase(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "destab_phase",
        "full_api_name": "Clifford.destab_phase",
        "api_description": "",
        "api_signature": "destab_phase(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "stab",
        "full_api_name": "Clifford.stab",
        "api_description": "The stabilizer array for the symplectic representation.",
        "api_signature": "stab(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "stab",
        "full_api_name": "Clifford.stab",
        "api_description": "",
        "api_signature": "stab(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "stab_x",
        "full_api_name": "Clifford.stab_x",
        "api_description": "The stabilizer x array for the symplectic representation.",
        "api_signature": "stab_x(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "stab_x",
        "full_api_name": "Clifford.stab_x",
        "api_description": "",
        "api_signature": "stab_x(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "stab_z",
        "full_api_name": "Clifford.stab_z",
        "api_description": "The stabilizer array for the symplectic representation.",
        "api_signature": "stab_z(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "stab_z",
        "full_api_name": "Clifford.stab_z",
        "api_description": "",
        "api_signature": "stab_z(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "stab_phase",
        "full_api_name": "Clifford.stab_phase",
        "api_description": "Return phase of stabilizer with boolean representation.",
        "api_signature": "stab_phase(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "stab_phase",
        "full_api_name": "Clifford.stab_phase",
        "api_description": "",
        "api_signature": "stab_phase(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "is_unitary",
        "full_api_name": "Clifford.is_unitary",
        "api_description": "Return True if the Clifford table is valid.",
        "api_signature": "is_unitary(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "conjugate",
        "full_api_name": "Clifford.conjugate",
        "api_description": "",
        "api_signature": "conjugate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "adjoint",
        "full_api_name": "Clifford.adjoint",
        "api_description": "",
        "api_signature": "adjoint(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "transpose",
        "full_api_name": "Clifford.transpose",
        "api_description": "",
        "api_signature": "transpose(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "tensor",
        "full_api_name": "Clifford.tensor",
        "api_description": "",
        "api_signature": "tensor(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "expand",
        "full_api_name": "Clifford.expand",
        "api_description": "",
        "api_signature": "expand(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "_tensor",
        "full_api_name": "Clifford._tensor",
        "api_description": "",
        "api_signature": "_tensor(cls, a, b)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "compose",
        "full_api_name": "Clifford.compose",
        "api_description": "",
        "api_signature": "compose(self, other, qargs, front)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "_compose_general",
        "full_api_name": "Clifford._compose_general",
        "api_description": "",
        "api_signature": "_compose_general(cls, first, second)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "_compose_1q",
        "full_api_name": "Clifford._compose_1q",
        "api_description": "",
        "api_signature": "_compose_1q(cls, first, second)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "_compose_lookup",
        "full_api_name": "Clifford._compose_lookup",
        "api_description": "",
        "api_signature": "_compose_lookup(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "to_dict",
        "full_api_name": "Clifford.to_dict",
        "api_description": "Return dictionary representation of Clifford object.",
        "api_signature": "to_dict(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "from_dict",
        "full_api_name": "Clifford.from_dict",
        "api_description": "Load a Clifford from a dictionary",
        "api_signature": "from_dict(cls, obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "to_matrix",
        "full_api_name": "Clifford.to_matrix",
        "api_description": "Convert operator to Numpy matrix.",
        "api_signature": "to_matrix(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "from_matrix",
        "full_api_name": "Clifford.from_matrix",
        "api_description": "Create a Clifford from a unitary matrix.\n\nNote that this function takes exponentially long time w.r.t. the number of qubits.\n\nArgs:\n    matrix (np.array): A unitary matrix representing a Clifford to be converted.\n\nReturns:\n    Clifford: the Clifford object for the unitary matrix.\n\nRaises:\n    QiskitError: if the input is not a Clifford matrix.",
        "api_signature": "from_matrix(cls, matrix)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "from_linear_function",
        "full_api_name": "Clifford.from_linear_function",
        "api_description": "Create a Clifford from a Linear Function.\n\nIf the linear function is represented by a nxn binary invertible matrix A,\nthen the corresponding Clifford has symplectic matrix [[A^t, 0], [0, A^{-1}]].\n\nArgs:\n    linear_function (LinearFunction): A linear function to be converted.\n\nReturns:\n    Clifford: the Clifford object for this linear function.",
        "api_signature": "from_linear_function(cls, linear_function)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "from_permutation",
        "full_api_name": "Clifford.from_permutation",
        "api_description": "Create a Clifford from a PermutationGate.\n\nArgs:\n    permutation_gate (PermutationGate): A permutation to be converted.\n\nReturns:\n    Clifford: the Clifford object for this permutation.",
        "api_signature": "from_permutation(cls, permutation_gate)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "to_operator",
        "full_api_name": "Clifford.to_operator",
        "api_description": "Convert to an Operator object.",
        "api_signature": "to_operator(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "from_operator",
        "full_api_name": "Clifford.from_operator",
        "api_description": "Create a Clifford from a operator.\n\nNote that this function takes exponentially long time w.r.t. the number of qubits.\n\nArgs:\n    operator (Operator): An operator representing a Clifford to be converted.\n\nReturns:\n    Clifford: the Clifford object for the operator.\n\nRaises:\n    QiskitError: if the input is not a Clifford operator.",
        "api_signature": "from_operator(cls, operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "to_circuit",
        "full_api_name": "Clifford.to_circuit",
        "api_description": "Return a QuantumCircuit implementing the Clifford.\n\nFor N <= 3 qubits this is based on optimal CX cost decomposition\nfrom reference [1]. For N > 3 qubits this is done using the general\nnon-optimal compilation routine from reference [2].\n\nReturn:\n    QuantumCircuit: a circuit implementation of the Clifford.\n\nReferences:\n    1. S. Bravyi, D. Maslov, *Hadamard-free circuits expose the\n       structure of the Clifford group*,\n       `arXiv:2003.09412 [quant-ph] <https://arxiv.org/abs/2003.09412>`_\n\n    2. S. Aaronson, D. Gottesman, *Improved Simulation of Stabilizer Circuits*,\n       Phys. Rev. A 70, 052328 (2004).\n       `arXiv:quant-ph/0406196 <https://arxiv.org/abs/quant-ph/0406196>`_",
        "api_signature": "to_circuit(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "to_instruction",
        "full_api_name": "Clifford.to_instruction",
        "api_description": "Return a Gate instruction implementing the Clifford.",
        "api_signature": "to_instruction(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "from_circuit",
        "full_api_name": "Clifford.from_circuit",
        "api_description": "Initialize from a QuantumCircuit or Instruction.\n\nArgs:\n    circuit (QuantumCircuit or ~qiskit.circuit.Instruction):\n        instruction to initialize.\n\nReturns:\n    Clifford: the Clifford object for the instruction.\n\nRaises:\n    QiskitError: if the input instruction is non-Clifford or contains\n                 classical register instruction.",
        "api_signature": "from_circuit(circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "from_label",
        "full_api_name": "Clifford.from_label",
        "api_description": "Return a tensor product of single-qubit Clifford gates.\n\nArgs:\n    label (string): single-qubit operator string.\n\nReturns:\n    Clifford: The N-qubit Clifford operator.\n\nRaises:\n    QiskitError: if the label contains invalid characters.\n\nAdditional Information:\n    The labels correspond to the single-qubit Cliffords are\n\n    * - Label\n      - Stabilizer\n      - Destabilizer\n    * - ``\"I\"``\n      - +Z\n      - +X\n    * - ``\"X\"``\n      - -Z\n      - +X\n    * - ``\"Y\"``\n      - -Z\n      - -X\n    * - ``\"Z\"``\n      - +Z\n      - -X\n    * - ``\"H\"``\n      - +X\n      - +Z\n    * - ``\"S\"``\n      - +Z\n      - +Y",
        "api_signature": "from_label(label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "to_labels",
        "full_api_name": "Clifford.to_labels",
        "api_description": "Convert a Clifford to a list Pauli (de)stabilizer string labels.\n\nFor large Clifford converting using the ``array=True``\nkwarg will be more efficient since it allocates memory for\nthe full Numpy array of labels in advance.\n\n.. list-table:: Stabilizer Representations\n    :header-rows: 1\n\n    * - Label\n      - Phase\n      - Symplectic\n      - Matrix\n      - Pauli\n    * - ``\"+I\"``\n      - 0\n      - :math:`[0, 0]`\n      - :math:`\\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\end{bmatrix}`\n      - :math:`I`\n    * - ``\"-I\"``\n      - 1\n      - :math:`[0, 0]`\n      - :math:`\\begin{bmatrix} -1 & 0 \\\\ 0 & -1 \\end{bmatrix}`\n      - :math:`-I`\n    * - ``\"X\"``\n      - 0\n      - :math:`[1, 0]`\n      - :math:`\\begin{bmatrix} 0 & 1 \\\\ 1 & 0  \\end{bmatrix}`\n      - :math:`X`\n    * - ``\"-X\"``\n      - 1\n      - :math:`[1, 0]`\n      - :math:`\\begin{bmatrix} 0 & -1 \\\\ -1 & 0  \\end{bmatrix}`\n      - :math:`-X`\n    * - ``\"Y\"``\n      - 0\n      - :math:`[1, 1]`\n      - :math:`\\begin{bmatrix} 0 & 1 \\\\ -1 & 0  \\end{bmatrix}`\n      - :math:`iY`\n    * - ``\"-Y\"``\n      - 1\n      - :math:`[1, 1]`\n      - :math:`\\begin{bmatrix} 0 & -1 \\\\ 1 & 0  \\end{bmatrix}`\n      - :math:`-iY`\n    * - ``\"Z\"``\n      - 0\n      - :math:`[0, 1]`\n      - :math:`\\begin{bmatrix} 1 & 0 \\\\ 0 & -1  \\end{bmatrix}`\n      - :math:`Z`\n    * - ``\"-Z\"``\n      - 1\n      - :math:`[0, 1]`\n      - :math:`\\begin{bmatrix} -1 & 0 \\\\ 0 & 1  \\end{bmatrix}`\n      - :math:`-Z`\n\nArgs:\n    array (bool): return a Numpy array if True, otherwise\n                  return a list (Default: False).\n    mode (Literal[\"S\", \"D\", \"B\"]): return both stabilizer and destabilizer if \"B\",\n        return only stabilizer if \"S\" and return only destabilizer if \"D\".\n\nReturns:\n    list or array: The rows of the StabilizerTable in label form.\nRaises:\n    QiskitError: if stabilizer and destabilizer are both False.",
        "api_signature": "to_labels(self, array, mode)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "_hash",
        "full_api_name": "Clifford._hash",
        "api_description": "Produce a hashable value that is unique for each different Clifford.  This should only be\nused internally when the classes being hashed are under our control, because classes of this\ntype are mutable.",
        "api_signature": "_hash(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "_is_symplectic",
        "full_api_name": "Clifford._is_symplectic",
        "api_description": "Return True if input is symplectic matrix.",
        "api_signature": "_is_symplectic(mat)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "_conjugate_transpose",
        "full_api_name": "Clifford._conjugate_transpose",
        "api_description": "Return the adjoint, conjugate, or transpose of the Clifford.\n\nArgs:\n    clifford (Clifford): a clifford object.\n    method (str): what function to apply 'A', 'C', or 'T'.\n\nReturns:\n    Clifford: the modified clifford.",
        "api_signature": "_conjugate_transpose(clifford, method)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "_pad_with_identity",
        "full_api_name": "Clifford._pad_with_identity",
        "api_description": "Pad Clifford with identities on other subsystems.",
        "api_signature": "_pad_with_identity(self, clifford, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "_stack_table_phase",
        "full_api_name": "Clifford._stack_table_phase",
        "api_description": "",
        "api_signature": "_stack_table_phase(table, phase)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "_from_label",
        "full_api_name": "Clifford._from_label",
        "api_description": "",
        "api_signature": "_from_label(label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "_pauli_matrix_to_row",
        "full_api_name": "Clifford._pauli_matrix_to_row",
        "api_description": "Generate a binary vector (a row of tableau representation) from a Pauli matrix.\nReturn None if the non-Pauli matrix is supplied.",
        "api_signature": "_pauli_matrix_to_row(mat, num_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "find_one_index",
        "full_api_name": "Clifford.find_one_index",
        "api_description": "",
        "api_signature": "find_one_index(x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "bitvector",
        "full_api_name": "Clifford.bitvector",
        "api_description": "",
        "api_signature": "bitvector(n, num_bits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "_unitary_matrix_to_tableau",
        "full_api_name": "Clifford._unitary_matrix_to_tableau",
        "api_description": "",
        "api_signature": "_unitary_matrix_to_tableau(matrix)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "random_pauli",
        "full_api_name": "random_pauli",
        "api_description": "Return a random Pauli.\n\nArgs:\n    num_qubits (int): the number of qubits.\n    group_phase (bool): Optional. If True generate random phase.\n                        Otherwise the phase will be set so that the\n                        Pauli coefficient is +1 (default: False).\n    seed (int or np.random.Generator): Optional. Set a fixed seed or\n                                       generator for RNG.\n\nReturns:\n    Pauli: a random Pauli",
        "api_signature": "random_pauli(num_qubits, group_phase, seed)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/random.py"
    },
    {
        "api_name": "random_pauli_list",
        "full_api_name": "random_pauli_list",
        "api_description": "Return a random PauliList.\n\nArgs:\n    num_qubits (int): the number of qubits.\n    size (int): Optional. The length of the Pauli list (Default: 1).\n    seed (int or np.random.Generator): Optional. Set a fixed seed or generator for RNG.\n    phase (bool): If True the Pauli phases are randomized, otherwise the phases are fixed to 0.\n                 [Default: True]\n\nReturns:\n    PauliList: a random PauliList.",
        "api_signature": "random_pauli_list(num_qubits, size, seed, phase)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/random.py"
    },
    {
        "api_name": "random_clifford",
        "full_api_name": "random_clifford",
        "api_description": "Return a random Clifford operator.\n\nThe Clifford is sampled using the method of Reference [1].\n\nArgs:\n    num_qubits (int): the number of qubits for the Clifford\n    seed (int or np.random.Generator): Optional. Set a fixed seed or\n                                       generator for RNG.\n\nReturns:\n    Clifford: a random Clifford operator.\n\nReference:\n    1. S. Bravyi and D. Maslov, *Hadamard-free circuits expose the\n       structure of the Clifford group*.\n       `arXiv:2003.09412 [quant-ph] <https://arxiv.org/abs/2003.09412>`_",
        "api_signature": "random_clifford(num_qubits, seed)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/random.py"
    },
    {
        "api_name": "_sample_qmallows",
        "full_api_name": "_sample_qmallows",
        "api_description": "Sample from the quantum Mallows distribution",
        "api_signature": "_sample_qmallows(n, rng)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/random.py"
    },
    {
        "api_name": "_fill_tril",
        "full_api_name": "_fill_tril",
        "api_description": "Add symmetric random ints to off diagonals",
        "api_signature": "_fill_tril(mat, rng, symmetric)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/random.py"
    },
    {
        "api_name": "_inverse_tril",
        "full_api_name": "_inverse_tril",
        "api_description": "Invert a lower-triangular matrix with unit diagonal.",
        "api_signature": "_inverse_tril(mat, block_inverse_threshold)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/random.py"
    },
    {
        "api_name": "pauli_basis",
        "full_api_name": "pauli_basis",
        "api_description": "Return the ordered PauliList for the n-qubit Pauli basis.\n\nArgs:\n    num_qubits (int): number of qubits\n    weight (bool): if True optionally return the basis sorted by Pauli weight\n                   rather than lexicographic order (Default: False)\n\nReturns:\n    PauliList: the Paulis for the basis",
        "api_signature": "pauli_basis(num_qubits, weight)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_utils.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Pauli.__init__",
        "api_description": "Initialize the Pauli.\n\nWhen using the symplectic array input data both z and x arguments must\nbe provided, however the first (z) argument can be used alone for string\nlabel, Pauli operator, or ScalarOp input data.\n\nArgs:\n    data (str or tuple or Pauli or ScalarOp): input data for Pauli. If input is\n        a tuple it must be of the form ``(z, x)`` or (z, x, phase)`` where\n        ``z`` and ``x`` are boolean Numpy arrays, and phase is an integer from Z_4.\n        If input is a string, it must be a concatenation of a phase and a Pauli string\n        (e.g. 'XYZ', '-iZIZ') where a phase string is a combination of at most three\n        characters from ['+', '-', ''], ['1', ''], and ['i', 'j', ''] in this order,\n        e.g. '', '-1j' while a Pauli string is 1 or more characters of 'I', 'X', 'Y' or 'Z',\n        e.g. 'Z', 'XIYY'.\n\nRaises:\n    QiskitError: if input array is invalid shape.",
        "api_signature": "__init__(self, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "name",
        "full_api_name": "Pauli.name",
        "api_description": "Unique string identifier for operation type.",
        "api_signature": "name(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "num_clbits",
        "full_api_name": "Pauli.num_clbits",
        "api_description": "Number of classical bits.",
        "api_signature": "num_clbits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "Pauli.__repr__",
        "api_description": "Display representation.",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "Pauli.__str__",
        "api_description": "Print representation.",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "Pauli.__array__",
        "api_description": "",
        "api_signature": "__array__(self, dtype)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "set_truncation",
        "full_api_name": "Pauli.set_truncation",
        "api_description": "Set the max number of Pauli characters to display before truncation/\n\nArgs:\n    val (int): the number of characters.\n\n.. note::\n\n    Truncation will be disabled if the truncation value is set to 0.",
        "api_signature": "set_truncation(cls, val)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "Pauli.__eq__",
        "api_description": "Test if two Paulis are equal.",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "equiv",
        "full_api_name": "Pauli.equiv",
        "api_description": "Return True if Pauli's are equivalent up to group phase.\n\nArgs:\n    other (Pauli): an operator object.\n\nReturns:\n    bool: True if the Pauli's are equivalent up to group phase.",
        "api_signature": "equiv(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "settings",
        "full_api_name": "Pauli.settings",
        "api_description": "Return settings.",
        "api_signature": "settings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "phase",
        "full_api_name": "Pauli.phase",
        "api_description": "Return the group phase exponent for the Pauli.",
        "api_signature": "phase(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "phase",
        "full_api_name": "Pauli.phase",
        "api_description": "",
        "api_signature": "phase(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "x",
        "full_api_name": "Pauli.x",
        "api_description": "The x vector for the Pauli.",
        "api_signature": "x(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "x",
        "full_api_name": "Pauli.x",
        "api_description": "",
        "api_signature": "x(self, val)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "z",
        "full_api_name": "Pauli.z",
        "api_description": "The z vector for the Pauli.",
        "api_signature": "z(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "z",
        "full_api_name": "Pauli.z",
        "api_description": "",
        "api_signature": "z(self, val)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "__len__",
        "full_api_name": "Pauli.__len__",
        "api_description": "Return the number of qubits in the Pauli.",
        "api_signature": "__len__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "__getitem__",
        "full_api_name": "Pauli.__getitem__",
        "api_description": "Return the unsigned Pauli group Pauli for subset of qubits.",
        "api_signature": "__getitem__(self, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "__setitem__",
        "full_api_name": "Pauli.__setitem__",
        "api_description": "Update the Pauli for a subset of qubits.",
        "api_signature": "__setitem__(self, qubits, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "delete",
        "full_api_name": "Pauli.delete",
        "api_description": "Return a Pauli with qubits deleted.\n\nArgs:\n    qubits (int or list): qubits to delete from Pauli.\n\nReturns:\n    Pauli: the resulting Pauli with the specified qubits removed.\n\nRaises:\n    QiskitError: if ind is out of bounds for the array size or\n                 number of qubits.",
        "api_signature": "delete(self, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "insert",
        "full_api_name": "Pauli.insert",
        "api_description": "Insert a Pauli at specific qubit value.\n\nArgs:\n    qubits (int or list): qubits index to insert at.\n    value (Pauli): value to insert.\n\nReturns:\n    Pauli: the resulting Pauli with the entries inserted.\n\nRaises:\n    QiskitError: if the insertion qubits are invalid.",
        "api_signature": "insert(self, qubits, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "__hash__",
        "full_api_name": "Pauli.__hash__",
        "api_description": "Make hashable based on string representation.",
        "api_signature": "__hash__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "to_label",
        "full_api_name": "Pauli.to_label",
        "api_description": "Convert a Pauli to a string label.\n\n.. note::\n\n    The difference between `to_label` and :meth:`__str__` is that\n    the later will truncate the output for large numbers of qubits.\n\nReturns:\n    str: the Pauli string label.",
        "api_signature": "to_label(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "to_matrix",
        "full_api_name": "Pauli.to_matrix",
        "api_description": "Convert to a Numpy array or sparse CSR matrix.\n\nArgs:\n    sparse (bool): if True return sparse CSR matrices, otherwise\n                   return dense Numpy arrays (default: False).\n\nReturns:\n    array: The Pauli matrix.",
        "api_signature": "to_matrix(self, sparse)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "to_instruction",
        "full_api_name": "Pauli.to_instruction",
        "api_description": "Convert to Pauli circuit instruction.",
        "api_signature": "to_instruction(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "compose",
        "full_api_name": "Pauli.compose",
        "api_description": "Return the operator composition with another Pauli.\n\nArgs:\n    other (Pauli): a Pauli object.\n    qargs (list or None): Optional, qubits to apply dot product\n                          on (default: None).\n    front (bool): If True compose using right operator multiplication,\n                  instead of left multiplication [default: False].\n    inplace (bool): If True update in-place (default: False).\n\nReturns:\n    Pauli: The composed Pauli.\n\nRaises:\n    QiskitError: if other cannot be converted to an operator, or has\n                 incompatible dimensions for specified subsystems.\n\n.. note::\n    Composition (``&``) by default is defined as `left` matrix multiplication for\n    matrix operators, while :meth:`dot` is defined as `right` matrix\n    multiplication. That is that ``A & B == A.compose(B)`` is equivalent to\n    ``B.dot(A)`` when ``A`` and ``B`` are of the same type.\n\n    Setting the ``front=True`` kwarg changes this to `right` matrix\n    multiplication and is equivalent to the :meth:`dot` method\n    ``A.dot(B) == A.compose(B, front=True)``.",
        "api_signature": "compose(self, other, qargs, front, inplace)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "dot",
        "full_api_name": "Pauli.dot",
        "api_description": "Return the right multiplied operator self * other.\n\nArgs:\n    other (Pauli): an operator object.\n    qargs (list or None): Optional, qubits to apply dot product\n                          on (default: None).\n    inplace (bool): If True update in-place (default: False).\n\nReturns:\n    Pauli: The operator self * other.",
        "api_signature": "dot(self, other, qargs, inplace)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "tensor",
        "full_api_name": "Pauli.tensor",
        "api_description": "",
        "api_signature": "tensor(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "expand",
        "full_api_name": "Pauli.expand",
        "api_description": "",
        "api_signature": "expand(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "_multiply",
        "full_api_name": "Pauli._multiply",
        "api_description": "",
        "api_signature": "_multiply(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "conjugate",
        "full_api_name": "Pauli.conjugate",
        "api_description": "",
        "api_signature": "conjugate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "transpose",
        "full_api_name": "Pauli.transpose",
        "api_description": "",
        "api_signature": "transpose(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "adjoint",
        "full_api_name": "Pauli.adjoint",
        "api_description": "",
        "api_signature": "adjoint(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "Pauli.inverse",
        "api_description": "Return the inverse of the Pauli.",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "commutes",
        "full_api_name": "Pauli.commutes",
        "api_description": "Return True if the Pauli commutes with other.\n\nArgs:\n    other (Pauli or PauliList): another Pauli operator.\n    qargs (list): qubits to apply dot product on (default: None).\n\nReturns:\n    bool: True if Pauli's commute, False if they anti-commute.",
        "api_signature": "commutes(self, other, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "anticommutes",
        "full_api_name": "Pauli.anticommutes",
        "api_description": "Return True if other Pauli anticommutes with self.\n\nArgs:\n    other (Pauli): another Pauli operator.\n    qargs (list): qubits to apply dot product on (default: None).\n\nReturns:\n    bool: True if Pauli's anticommute, False if they commute.",
        "api_signature": "anticommutes(self, other, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "evolve",
        "full_api_name": "Pauli.evolve",
        "api_description": "Performs either Heisenberg (default) or Schr\u00f6dinger picture\nevolution of the Pauli by a Clifford and returns the evolved Pauli.\n\nSchr\u00f6dinger picture evolution can be chosen by passing parameter ``frame='s'``.\nThis option yields a faster calculation.\n\nHeisenberg picture evolves the Pauli as :math:`P^\\prime = C^\\dagger.P.C`.\n\nSchr\u00f6dinger picture evolves the Pauli as :math:`P^\\prime = C.P.C^\\dagger`.\n\nArgs:\n    other (Pauli or Clifford or QuantumCircuit): The Clifford operator to evolve by.\n    qargs (list): a list of qubits to apply the Clifford to.\n    frame (string): ``'h'`` for Heisenberg (default) or ``'s'`` for\n    Schr\u00f6dinger framework.\n\nReturns:\n    Pauli: the Pauli :math:`C^\\dagger.P.C` (Heisenberg picture)\n    or the Pauli :math:`C.P.C^\\dagger` (Schr\u00f6dinger picture).\n\nRaises:\n    QiskitError: if the Clifford number of qubits and qargs don't match.",
        "api_signature": "evolve(self, other, qargs, frame)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "_from_label",
        "full_api_name": "Pauli._from_label",
        "api_description": "Return the symplectic representation of Pauli string.\n\nArgs:\n    label (str): the Pauli string label.\n\nReturns:\n    BasePauli: the BasePauli corresponding to the label.\n\nRaises:\n    QiskitError: if Pauli string is not valid.",
        "api_signature": "_from_label(label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "_from_scalar_op",
        "full_api_name": "Pauli._from_scalar_op",
        "api_description": "Convert a ScalarOp to BasePauli data.",
        "api_signature": "_from_scalar_op(cls, op)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "_from_pauli_instruction",
        "full_api_name": "Pauli._from_pauli_instruction",
        "api_description": "Convert a Pauli instruction to BasePauli data.",
        "api_signature": "_from_pauli_instruction(cls, instr)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "_from_circuit",
        "full_api_name": "Pauli._from_circuit",
        "api_description": "Convert a Pauli circuit to BasePauli data.",
        "api_signature": "_from_circuit(cls, instr)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "adjoint",
        "full_api_name": "AdjointMixin.adjoint",
        "api_description": "Return the adjoint of the CLASS.",
        "api_signature": "adjoint(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/mixins/adjoint.py"
    },
    {
        "api_name": "conjugate",
        "full_api_name": "AdjointMixin.conjugate",
        "api_description": "Return the conjugate of the CLASS.",
        "api_signature": "conjugate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/mixins/adjoint.py"
    },
    {
        "api_name": "transpose",
        "full_api_name": "AdjointMixin.transpose",
        "api_description": "Return the transpose of the CLASS.",
        "api_signature": "transpose(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/mixins/adjoint.py"
    },
    {
        "api_name": "__and__",
        "full_api_name": "GroupMixin.__and__",
        "api_description": "",
        "api_signature": "__and__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/mixins/group.py"
    },
    {
        "api_name": "__pow__",
        "full_api_name": "GroupMixin.__pow__",
        "api_description": "",
        "api_signature": "__pow__(self, n)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/mixins/group.py"
    },
    {
        "api_name": "__xor__",
        "full_api_name": "GroupMixin.__xor__",
        "api_description": "",
        "api_signature": "__xor__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/mixins/group.py"
    },
    {
        "api_name": "__matmul__",
        "full_api_name": "GroupMixin.__matmul__",
        "api_description": "",
        "api_signature": "__matmul__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/mixins/group.py"
    },
    {
        "api_name": "tensor",
        "full_api_name": "GroupMixin.tensor",
        "api_description": "Return the tensor product with another CLASS.\n\nArgs:\n    other (CLASS): a CLASS object.\n\nReturns:\n    CLASS: the tensor product :math:`a \\otimes b`, where :math:`a`\n        is the current CLASS, and :math:`b` is the other CLASS.\n\n.. note::\n    The tensor product can be obtained using the ``^`` binary operator.\n    Hence ``a.tensor(b)`` is equivalent to ``a ^ b``.\n\n.. note:\n    Tensor uses reversed operator ordering to :meth:`expand`.\n    For two operators of the same type ``a.tensor(b) = b.expand(a)``.",
        "api_signature": "tensor(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/mixins/group.py"
    },
    {
        "api_name": "expand",
        "full_api_name": "GroupMixin.expand",
        "api_description": "Return the reverse-order tensor product with another CLASS.\n\nArgs:\n    other (CLASS): a CLASS object.\n\nReturns:\n    CLASS: the tensor product :math:`b \\otimes a`, where :math:`a`\n        is the current CLASS, and :math:`b` is the other CLASS.\n\n.. note:\n    Expand is the opposite operator ordering to :meth:`tensor`.\n    For two operators of the same type ``a.expand(b) = b.tensor(a)``.",
        "api_signature": "expand(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/mixins/group.py"
    },
    {
        "api_name": "compose",
        "full_api_name": "GroupMixin.compose",
        "api_description": "Return the operator composition with another CLASS.\n\nArgs:\n    other (CLASS): a CLASS object.\n    qargs (list or None): Optional, a list of subsystem positions to\n                          apply other on. If None apply on all\n                          subsystems (default: None).\n    front (bool): If True compose using right operator multiplication,\n                  instead of left multiplication [default: False].\n\nReturns:\n    CLASS: The composed CLASS.\n\nRaises:\n    QiskitError: if other cannot be converted to an operator, or has\n                 incompatible dimensions for specified subsystems.\n\n.. note::\n    Composition (``&``) by default is defined as `left` matrix multiplication for\n    matrix operators, while ``@`` (equivalent to :meth:`dot`) is defined as `right` matrix\n    multiplication. That is that ``A & B == A.compose(B)`` is equivalent to\n    ``B @ A == B.dot(A)`` when ``A`` and ``B`` are of the same type.\n\n    Setting the ``front=True`` kwarg changes this to `right` matrix\n    multiplication and is equivalent to the :meth:`dot` method\n    ``A.dot(B) == A.compose(B, front=True)``.",
        "api_signature": "compose(self, other, qargs, front)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/mixins/group.py"
    },
    {
        "api_name": "dot",
        "full_api_name": "GroupMixin.dot",
        "api_description": "Return the right multiplied operator self * other.\n\nArgs:\n    other (CLASS): an operator object.\n    qargs (list or None): Optional, a list of subsystem positions to\n                          apply other on. If None apply on all\n                          subsystems (default: None).\n\nReturns:\n    CLASS: The right matrix multiplied CLASS.\n\n.. note::\n    The dot product can be obtained using the ``@`` binary operator.\n    Hence ``a.dot(b)`` is equivalent to ``a @ b``.",
        "api_signature": "dot(self, other, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/mixins/group.py"
    },
    {
        "api_name": "power",
        "full_api_name": "GroupMixin.power",
        "api_description": "Return the compose of a operator with itself n times.\n\nArgs:\n    n (int): the number of times to compose with self (n>0).\n\nReturns:\n    CLASS: the n-times composed operator.\n\nRaises:\n    QiskitError: if the input and output dimensions of the operator\n                 are not equal, or the power is not a positive integer.",
        "api_signature": "power(self, n)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/mixins/group.py"
    },
    {
        "api_name": "generate_apidocs",
        "full_api_name": "generate_apidocs",
        "api_description": "Decorator to format API docstrings for classes using Mixins.\n\nThis runs string replacement on the docstrings of the mixin\nmethods to replace the placeholder CLASS with the class\nname `cls.__name__`.\n\nArgs:\n    cls (type): The class to format docstrings.\n\nReturns:\n    cls: the original class with updated docstrings.",
        "api_signature": "generate_apidocs(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/mixins/__init__.py"
    },
    {
        "api_name": "_replace_name",
        "full_api_name": "_replace_name",
        "api_description": "",
        "api_signature": "_replace_name(mixin, methods)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/mixins/__init__.py"
    },
    {
        "api_name": "__rmul__",
        "full_api_name": "MultiplyMixin.__rmul__",
        "api_description": "",
        "api_signature": "__rmul__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/mixins/multiply.py"
    },
    {
        "api_name": "__mul__",
        "full_api_name": "MultiplyMixin.__mul__",
        "api_description": "",
        "api_signature": "__mul__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/mixins/multiply.py"
    },
    {
        "api_name": "__truediv__",
        "full_api_name": "MultiplyMixin.__truediv__",
        "api_description": "",
        "api_signature": "__truediv__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/mixins/multiply.py"
    },
    {
        "api_name": "__neg__",
        "full_api_name": "MultiplyMixin.__neg__",
        "api_description": "",
        "api_signature": "__neg__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/mixins/multiply.py"
    },
    {
        "api_name": "_multiply",
        "full_api_name": "MultiplyMixin._multiply",
        "api_description": "Return the CLASS other * self.\n\nArgs:\n    other (complex): a complex number.\n\nReturns:\n    CLASS: the CLASS other * self.",
        "api_signature": "_multiply(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/mixins/multiply.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "TolerancesMeta.__init__",
        "api_description": "",
        "api_signature": "__init__(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/mixins/tolerances.py"
    },
    {
        "api_name": "_check_value",
        "full_api_name": "TolerancesMeta._check_value",
        "api_description": "Check if value is within valid ranges",
        "api_signature": "_check_value(cls, value, value_name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/mixins/tolerances.py"
    },
    {
        "api_name": "atol",
        "full_api_name": "TolerancesMeta.atol",
        "api_description": "Default absolute tolerance parameter for float comparisons.",
        "api_signature": "atol(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/mixins/tolerances.py"
    },
    {
        "api_name": "atol",
        "full_api_name": "TolerancesMeta.atol",
        "api_description": "Set default absolute tolerance parameter for float comparisons.",
        "api_signature": "atol(cls, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/mixins/tolerances.py"
    },
    {
        "api_name": "rtol",
        "full_api_name": "TolerancesMeta.rtol",
        "api_description": "Default relative tolerance parameter for float comparisons.",
        "api_signature": "rtol(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/mixins/tolerances.py"
    },
    {
        "api_name": "rtol",
        "full_api_name": "TolerancesMeta.rtol",
        "api_description": "Set default relative tolerance parameter for float comparisons.",
        "api_signature": "rtol(cls, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/mixins/tolerances.py"
    },
    {
        "api_name": "atol",
        "full_api_name": "TolerancesMixin.atol",
        "api_description": "Default absolute tolerance parameter for float comparisons.",
        "api_signature": "atol(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/mixins/tolerances.py"
    },
    {
        "api_name": "rtol",
        "full_api_name": "TolerancesMixin.rtol",
        "api_description": "Default relative tolerance parameter for float comparisons.",
        "api_signature": "rtol(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/mixins/tolerances.py"
    },
    {
        "api_name": "__add__",
        "full_api_name": "LinearMixin.__add__",
        "api_description": "",
        "api_signature": "__add__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/mixins/linear.py"
    },
    {
        "api_name": "__radd__",
        "full_api_name": "LinearMixin.__radd__",
        "api_description": "",
        "api_signature": "__radd__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/mixins/linear.py"
    },
    {
        "api_name": "__sub__",
        "full_api_name": "LinearMixin.__sub__",
        "api_description": "",
        "api_signature": "__sub__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/mixins/linear.py"
    },
    {
        "api_name": "__rsub__",
        "full_api_name": "LinearMixin.__rsub__",
        "api_description": "",
        "api_signature": "__rsub__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/mixins/linear.py"
    },
    {
        "api_name": "_add",
        "full_api_name": "LinearMixin._add",
        "api_description": "Return the CLASS self + other.\n\nIf ``qargs`` are specified the other operator will be added\nassuming it is identity on all other subsystems.\n\nArgs:\n    other (CLASS): an operator object.\n    qargs (None or list): optional subsystems to add on\n                          (Default: None)\n\nReturns:\n    CLASS: the CLASS self + other.",
        "api_signature": "_add(self, other, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/mixins/linear.py"
    }
]