[
    {
        "api_name": "__init__",
        "full_api_name": "UserConfig.__init__",
        "api_description": "Create a UserConfig\n\nArgs:\n    filename (str): The path to the user config file. If one isn't\n        specified, ~/.qiskit/settings.conf is used.",
        "api_signature": "__init__(self, filename)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/user_config.py"
    },
    {
        "api_name": "read_config_file",
        "full_api_name": "UserConfig.read_config_file",
        "api_description": "Read config file and parse the contents into the settings attr.",
        "api_signature": "read_config_file(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/user_config.py"
    },
    {
        "api_name": "set_config",
        "full_api_name": "set_config",
        "api_description": "Adds or modifies a user configuration\n\nIt will add configuration to the currently configured location\nor the value of file argument.\n\nOnly valid user config can be set in 'default' section. Custom\nuser config can be added in any other sections.\n\nChanges to the existing config file will not be reflected in\nthe current session since the config file is parsed at import time.\n\nArgs:\n    key (str): name of the config\n    value (obj): value of the config\n    section (str, optional): if not specified, adds it to the\n        `default` section of the config file.\n    file_path (str, optional): the file to which config is added.\n        If not specified, adds it to the default config file or\n        if set, the value of `QISKIT_SETTINGS` env variable.\n\nRaises:\n    QiskitUserConfigError: if the config is invalid",
        "api_signature": "set_config(key, value, section, file_path)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/user_config.py"
    },
    {
        "api_name": "get_config",
        "full_api_name": "get_config",
        "api_description": "Read the config file from the default location or env var\n\nIt will read a config file at either the default location\n~/.qiskit/settings.conf or if set the value of the QISKIT_SETTINGS env var.\n\nIt will return the parsed settings dict from the parsed config file.\nReturns:\n    dict: The settings dict from the parsed config file.",
        "api_signature": "get_config()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/user_config.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QiskitError.__init__",
        "api_description": "Set the error message.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/exceptions.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "QiskitError.__str__",
        "api_description": "Return the message.",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/exceptions.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "MissingOptionalLibraryError.__init__",
        "api_description": "Set the error message.\nArgs:\n    libname: Name of missing library\n    name: Name of class, function, module that uses this library\n    pip_install: pip install command, if any\n    msg: Descriptive message, if any",
        "api_signature": "__init__(self, libname, name, pip_install, msg)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/exceptions.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "MissingOptionalLibraryError.__str__",
        "api_description": "Return the message.",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/exceptions.py"
    },
    {
        "api_name": "_minimal_ext_cmd",
        "full_api_name": "_minimal_ext_cmd",
        "api_description": "",
        "api_signature": "_minimal_ext_cmd(cmd)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/version.py"
    },
    {
        "api_name": "git_version",
        "full_api_name": "git_version",
        "api_description": "Get the current git head sha1.",
        "api_signature": "git_version()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/version.py"
    },
    {
        "api_name": "get_version_info",
        "full_api_name": "get_version_info",
        "api_description": "Get the full version string.",
        "api_signature": "get_version_info()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/version.py"
    },
    {
        "api_name": "__new__",
        "full_api_name": "_lift_to_method.__new__",
        "api_description": "",
        "api_signature": "__new__(cls, method)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/classtools.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "_lift_to_method.__init__",
        "api_description": "",
        "api_signature": "__init__(self, method)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/classtools.py"
    },
    {
        "api_name": "__get__",
        "full_api_name": "_lift_to_method.__get__",
        "api_description": "",
        "api_signature": "__get__(self, obj, objtype)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/classtools.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "_WrappedMethod.__init__",
        "api_description": "",
        "api_signature": "__init__(self, method, before, after)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/classtools.py"
    },
    {
        "api_name": "__get__",
        "full_api_name": "_WrappedMethod.__get__",
        "api_description": "",
        "api_signature": "__get__(self, obj, objtype)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/classtools.py"
    },
    {
        "api_name": "out",
        "full_api_name": "_WrappedMethod.out",
        "api_description": "",
        "api_signature": "out()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/classtools.py"
    },
    {
        "api_name": "wrap_method",
        "full_api_name": "wrap_method",
        "api_description": "Wrap the functionality the instance- or class method ``cls.name`` with additional behavior\n``before`` and ``after``.\n\nThis mutates ``cls``, replacing the attribute ``name`` with the new functionality.  This is\nuseful when creating class decorators.  The method is allowed to be defined on any parent class\ninstead.\n\nIf either ``before`` or ``after`` are given, they should be callables with a compatible\nsignature to the method referred to.  They will be called immediately before or after the method\nas appropriate, and any return value will be ignored.\n\nArgs:\n    cls: the class to modify.\n    name: the name of the method on the class to wrap.\n    before: a callable that should be called before the method that is being wrapped.\n    after: a callable that should be called after the method that is being wrapped.\n\nRaises:\n    ValueError: if the named method is not defined on the class or any parent class.",
        "api_signature": "wrap_method(cls, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/classtools.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "_RequireNow.__init__",
        "api_description": "",
        "api_signature": "__init__(self, tester, feature)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/lazy_tester.py"
    },
    {
        "api_name": "__call__",
        "full_api_name": "_RequireNow.__call__",
        "api_description": "",
        "api_signature": "__call__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/lazy_tester.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "LazyDependencyManager.__init__",
        "api_description": "Args:\n    name: the name of this optional dependency.\n    callback: a callback that is called immediately after the availability of the library is\n        tested with the result.  This will only be called once.\n    install: how to install this optional dependency.  Passed to\n        :class:`.MissingOptionalLibraryError` as the ``pip_install`` parameter.\n    msg: an extra message to include in the error raised if this is required.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/lazy_tester.py"
    },
    {
        "api_name": "_is_available",
        "full_api_name": "LazyDependencyManager._is_available",
        "api_description": "Subclasses of :class:`LazyDependencyManager` should override this method to implement the\nactual test of availability.  This method should return a Boolean, where ``True`` indicates\nthat the dependency was available.  This method will only ever be called once.\n\n:meta public:",
        "api_signature": "_is_available(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/lazy_tester.py"
    },
    {
        "api_name": "__bool__",
        "full_api_name": "LazyDependencyManager.__bool__",
        "api_description": "",
        "api_signature": "__bool__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/lazy_tester.py"
    },
    {
        "api_name": "require_in_call",
        "full_api_name": "LazyDependencyManager.require_in_call",
        "api_description": "",
        "api_signature": "require_in_call(self, feature_or_callable)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/lazy_tester.py"
    },
    {
        "api_name": "require_in_call",
        "full_api_name": "LazyDependencyManager.require_in_call",
        "api_description": "",
        "api_signature": "require_in_call(self, feature_or_callable)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/lazy_tester.py"
    },
    {
        "api_name": "require_in_call",
        "full_api_name": "LazyDependencyManager.require_in_call",
        "api_description": "Create a decorator for callables that requires that the dependency is available when the\ndecorated function or method is called.\n\nArgs:\n    feature_or_callable (str or Callable): the name of the feature that requires these\n        dependencies.  If this function is called directly as a decorator (for example\n        ``@HAS_X.require_in_call`` as opposed to\n        ``@HAS_X.require_in_call(\"my feature\")``), then the feature name will be taken to be\n        the function name, or class and method name as appropriate.\n\nReturns:\n    Callable: a decorator that will make its argument require this dependency before it is\n    called.",
        "api_signature": "require_in_call(self, feature_or_callable)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/lazy_tester.py"
    },
    {
        "api_name": "decorator",
        "full_api_name": "LazyDependencyManager.decorator",
        "api_description": "",
        "api_signature": "decorator(function)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/lazy_tester.py"
    },
    {
        "api_name": "out",
        "full_api_name": "LazyDependencyManager.out",
        "api_description": "",
        "api_signature": "out()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/lazy_tester.py"
    },
    {
        "api_name": "out",
        "full_api_name": "LazyDependencyManager.out",
        "api_description": "",
        "api_signature": "out()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/lazy_tester.py"
    },
    {
        "api_name": "require_in_instance",
        "full_api_name": "LazyDependencyManager.require_in_instance",
        "api_description": "",
        "api_signature": "require_in_instance(self, feature_or_class)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/lazy_tester.py"
    },
    {
        "api_name": "require_in_instance",
        "full_api_name": "LazyDependencyManager.require_in_instance",
        "api_description": "",
        "api_signature": "require_in_instance(self, feature_or_class)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/lazy_tester.py"
    },
    {
        "api_name": "require_in_instance",
        "full_api_name": "LazyDependencyManager.require_in_instance",
        "api_description": "A class decorator that requires the dependency is available when the class is\ninitialized.  This decorator can be used even if the class does not define an ``__init__``\nmethod.\n\nArgs:\n    feature_or_class (str or Type): the name of the feature that requires these\n        dependencies.  If this function is called directly as a decorator (for example\n        ``@HAS_X.require_in_instance`` as opposed to\n        ``@HAS_X.require_in_instance(\"my feature\")``), then the feature name will be taken\n        as the name of the class.\n\nReturns:\n    Callable: a class decorator that ensures that the wrapped feature is present if the\n    class is initialized.",
        "api_signature": "require_in_instance(self, feature_or_class)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/lazy_tester.py"
    },
    {
        "api_name": "decorator",
        "full_api_name": "LazyDependencyManager.decorator",
        "api_description": "",
        "api_signature": "decorator(class_)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/lazy_tester.py"
    },
    {
        "api_name": "require_now",
        "full_api_name": "LazyDependencyManager.require_now",
        "api_description": "Eagerly attempt to import the dependencies in this object, and raise an exception if they\ncannot be imported.\n\nArgs:\n    feature: the name of the feature that is requiring these dependencies.\n\nRaises:\n    MissingOptionalLibraryError: if the dependencies cannot be imported.",
        "api_signature": "require_now(self, feature)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/lazy_tester.py"
    },
    {
        "api_name": "disable_locally",
        "full_api_name": "LazyDependencyManager.disable_locally",
        "api_description": "Create a context, during which the value of the dependency manager will be ``False``.  This\nmeans that within the context, any calls to this object will behave as if the dependency is\nnot available, including raising errors.  It is valid to call this method whether or not the\ndependency has already been evaluated.  This is most useful in tests.",
        "api_signature": "disable_locally(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/lazy_tester.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "LazyImportTester.__init__",
        "api_description": "Args:\n    name_map_or_modules: if a name map, then a dictionary where the keys are modules or\n        packages, and the values are iterables of names to try and import from that\n        module.  It should be valid to write ``from <module> import <name1>, <name2>, ...``.\n        If simply a string or iterable of strings, then it should be valid to write\n        ``import <module>`` for each of them.\n\nRaises:\n    ValueError: if no modules are given.",
        "api_signature": "__init__(self, name_map_or_modules)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/lazy_tester.py"
    },
    {
        "api_name": "_is_available",
        "full_api_name": "LazyImportTester._is_available",
        "api_description": "",
        "api_signature": "_is_available(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/lazy_tester.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "LazySubprocessTester.__init__",
        "api_description": "Args:\n    command: the strings that make up the command to be run.  For example,\n        ``[\"pdflatex\", \"-version\"]``.\n\nRaises:\n    ValueError: if an empty command is given.",
        "api_signature": "__init__(self, command)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/lazy_tester.py"
    },
    {
        "api_name": "_is_available",
        "full_api_name": "LazySubprocessTester._is_available",
        "api_description": "",
        "api_signature": "_is_available(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/lazy_tester.py"
    },
    {
        "api_name": "apply_prefix",
        "full_api_name": "apply_prefix",
        "api_description": "Given a SI unit prefix and value, apply the prefix to convert to\nstandard SI unit.\n\nArgs:\n    value: The number to apply prefix to.\n    unit: String prefix.\n\nReturns:\n    Converted value.\n\n.. note::\n\n    This may induce tiny value error due to internal representation of float object.\n    See https://docs.python.org/3/tutorial/floatingpoint.html for details.\n\nRaises:\n    ValueError: If the ``units`` aren't recognized.",
        "api_signature": "apply_prefix(value, unit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/units.py"
    },
    {
        "api_name": "detach_prefix",
        "full_api_name": "detach_prefix",
        "api_description": "Given a SI unit value, find the most suitable prefix to scale the value.\n\nFor example, the ``value = 1.3e8`` will be converted into a tuple of ``(130.0, \"M\")``,\nwhich represents a scaled value and auxiliary unit that may be used to display the value.\nIn above example, that value might be displayed as ``130 MHz`` (unit is arbitrary here).\n\nExample:\n\n    >>> value, prefix = detach_prefix(1e4)\n    >>> print(f\"{value} {prefix}Hz\")\n    10 kHz\n\nArgs:\n    value: The number to find prefix.\n    decimal: Optional. An arbitrary integer number to represent a precision of the value.\n        If specified, it tries to round the mantissa and adjust the prefix to rounded value.\n        For example, 999_999.91 will become 999.9999 k with ``decimal=4``,\n        while 1.0 M with ``decimal=3`` or less.\n\nReturns:\n    A tuple of scaled value and prefix.\n\n.. note::\n\n    This may induce tiny value error due to internal representation of float object.\n    See https://docs.python.org/3/tutorial/floatingpoint.html for details.\n\nRaises:\n    ValueError: If the ``value`` is out of range.\n    ValueError: If the ``value`` is not real number.",
        "api_signature": "detach_prefix(value, decimal)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/units.py"
    },
    {
        "api_name": "local_hardware_info",
        "full_api_name": "local_hardware_info",
        "api_description": "Basic hardware information about the local machine.\n\nGives actual number of CPU's in the machine, even when hyperthreading is\nturned on. CPU count defaults to 1 when true count can't be determined.\n\nReturns:\n    dict: The hardware information.",
        "api_signature": "local_hardware_info()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/multiprocessing.py"
    },
    {
        "api_name": "is_main_process",
        "full_api_name": "is_main_process",
        "api_description": "Checks whether the current process is the main one",
        "api_signature": "is_main_process()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/multiprocessing.py"
    },
    {
        "api_name": "deprecate_func",
        "full_api_name": "deprecate_func",
        "api_description": "Decorator to indicate a function has been deprecated.\n\nIt should be placed beneath other decorators like `@staticmethod` and property decorators.\n\nWhen deprecating a class, set this decorator on its `__init__` function.\n\nArgs:\n    since: The version the deprecation started at. If the deprecation is pending, set\n        the version to when that started; but later, when switching from pending to\n        deprecated, update ``since`` to the new version.\n    additional_msg: Put here any additional information, such as what to use instead.\n        For example, \"Instead, use the function ``new_func`` from the module\n        ``<my_module>.<my_submodule>``, which is similar but uses GPU acceleration.\"\n    pending: Set to ``True`` if the deprecation is still pending.\n    package_name: The PyPI package name, e.g. \"qiskit-nature\".\n    removal_timeline: How soon can this deprecation be removed? Expects a value\n        like \"no sooner than 6 months after the latest release\" or \"in release 9.99\".\n    is_property: If the deprecated function is a `@property`, set this to True so that the\n        generated message correctly describes it as such. (This isn't necessary for\n        property setters, as their docstring is ignored by Python.)\n    stacklevel: Stack level passed to :func:`warnings.warn`.\nReturns:\n    Callable: The decorated callable.",
        "api_signature": "deprecate_func()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/deprecation.py"
    },
    {
        "api_name": "decorator",
        "full_api_name": "decorator",
        "api_description": "",
        "api_signature": "decorator(func)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/deprecation.py"
    },
    {
        "api_name": "wrapper",
        "full_api_name": "wrapper",
        "api_description": "",
        "api_signature": "wrapper()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/deprecation.py"
    },
    {
        "api_name": "deprecate_arg",
        "full_api_name": "deprecate_arg",
        "api_description": "Decorator to indicate an argument has been deprecated in some way.\n\nThis decorator may be used multiple times on the same function, once per deprecated argument.\nIt should be placed beneath other decorators like ``@staticmethod`` and property decorators.\n\nArgs:\n    name: The name of the deprecated argument.\n    since: The version the deprecation started at. If the deprecation is pending, set\n        the version to when that started; but later, when switching from pending to\n        deprecated, update `since` to the new version.\n    deprecation_description: What is being deprecated? E.g. \"Setting my_func()'s `my_arg`\n        argument to `None`.\" If not set, will default to \"{func_name}'s argument `{name}`\".\n    additional_msg: Put here any additional information, such as what to use instead\n        (if new_alias is not set). For example, \"Instead, use the argument `new_arg`,\n        which is similar but does not impact the circuit's setup.\"\n    pending: Set to `True` if the deprecation is still pending.\n    package_name: The PyPI package name, e.g. \"qiskit-nature\".\n    new_alias: If the arg has simply been renamed, set this to the new name. The decorator will\n        dynamically update the `kwargs` so that when the user sets the old arg, it will be\n        passed in as the `new_alias` arg.\n    predicate: Only log the runtime warning if the predicate returns True. This is useful to\n        deprecate certain values or types for an argument, e.g.\n        `lambda my_arg: isinstance(my_arg, dict)`. Regardless of if a predicate is set, the\n        runtime warning will only log when the user specifies the argument.\n    removal_timeline: How soon can this deprecation be removed? Expects a value\n        like \"no sooner than 6 months after the latest release\" or \"in release 9.99\".\n\nReturns:\n    Callable: The decorated callable.",
        "api_signature": "deprecate_arg(name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/deprecation.py"
    },
    {
        "api_name": "decorator",
        "full_api_name": "decorator",
        "api_description": "",
        "api_signature": "decorator(func)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/deprecation.py"
    },
    {
        "api_name": "wrapper",
        "full_api_name": "wrapper",
        "api_description": "",
        "api_signature": "wrapper()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/deprecation.py"
    },
    {
        "api_name": "deprecate_arguments",
        "full_api_name": "deprecate_arguments",
        "api_description": "Deprecated. Instead, use `@deprecate_arg`.\n\nArgs:\n    kwarg_map: A dictionary of the old argument name to the new name.\n    category: Usually either DeprecationWarning or PendingDeprecationWarning.\n    since: The version the deprecation started at. Only Optional for backwards\n        compatibility - this should always be set. If the deprecation is pending, set\n        the version to when that started; but later, when switching from pending to\n        deprecated, update `since` to the new version.\n\nReturns:\n    Callable: The decorated callable.",
        "api_signature": "deprecate_arguments(kwarg_map, category)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/deprecation.py"
    },
    {
        "api_name": "decorator",
        "full_api_name": "decorator",
        "api_description": "",
        "api_signature": "decorator(func)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/deprecation.py"
    },
    {
        "api_name": "wrapper",
        "full_api_name": "wrapper",
        "api_description": "",
        "api_signature": "wrapper()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/deprecation.py"
    },
    {
        "api_name": "deprecate_function",
        "full_api_name": "deprecate_function",
        "api_description": "Deprecated. Instead, use `@deprecate_func`.\n\nArgs:\n    msg: Warning message to emit.\n    stacklevel: The warning stacklevel to use, defaults to 2.\n    category: Usually either DeprecationWarning or PendingDeprecationWarning.\n    since: The version the deprecation started at. Only Optional for backwards\n        compatibility - this should always be set. If the deprecation is pending, set\n        the version to when that started; but later, when switching from pending to\n        deprecated, update `since` to the new version.\n\nReturns:\n    Callable: The decorated, deprecated callable.",
        "api_signature": "deprecate_function(msg, stacklevel, category)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/deprecation.py"
    },
    {
        "api_name": "decorator",
        "full_api_name": "decorator",
        "api_description": "",
        "api_signature": "decorator(func)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/deprecation.py"
    },
    {
        "api_name": "wrapper",
        "full_api_name": "wrapper",
        "api_description": "",
        "api_signature": "wrapper()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/deprecation.py"
    },
    {
        "api_name": "_maybe_warn_and_rename_kwarg",
        "full_api_name": "_maybe_warn_and_rename_kwarg",
        "api_description": "",
        "api_signature": "_maybe_warn_and_rename_kwarg(args, kwargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/deprecation.py"
    },
    {
        "api_name": "_write_deprecation_msg",
        "full_api_name": "_write_deprecation_msg",
        "api_description": "",
        "api_signature": "_write_deprecation_msg()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/deprecation.py"
    },
    {
        "api_name": "add_deprecation_to_docstring",
        "full_api_name": "add_deprecation_to_docstring",
        "api_description": "Dynamically insert the deprecation message into ``func``'s docstring.\n\nArgs:\n    func: The function to modify.\n    msg: The full deprecation message.\n    since: The version the deprecation started at.\n    pending: Is the deprecation still pending?",
        "api_signature": "add_deprecation_to_docstring(func, msg)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/deprecation.py"
    },
    {
        "api_name": "get_platform_parallel_default",
        "full_api_name": "get_platform_parallel_default",
        "api_description": "Returns the default parallelism flag value for the current platform.\n\nReturns:\n    parallel_default: The default parallelism flag value for the\n    current platform.",
        "api_signature": "get_platform_parallel_default()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/parallel.py"
    },
    {
        "api_name": "_task_wrapper",
        "full_api_name": "_task_wrapper",
        "api_description": "",
        "api_signature": "_task_wrapper(param)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/parallel.py"
    },
    {
        "api_name": "should_run_in_parallel",
        "full_api_name": "should_run_in_parallel",
        "api_description": "Return whether the current parallelisation configuration suggests that we should run things\nlike :func:`parallel_map` in parallel (``True``) or degrade to serial (``False``).\n\nArgs:\n    num_processes: the number of processes requested for use (if given).",
        "api_signature": "should_run_in_parallel(num_processes)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/parallel.py"
    },
    {
        "api_name": "parallel_map",
        "full_api_name": "parallel_map",
        "api_description": "Parallel execution of a mapping of `values` to the function `task`. This\nis functionally equivalent to::\n\n    result = [task(value, *task_args, **task_kwargs) for value in values]\n\nThis will parallelise the results if the number of ``values`` is greater than one, and the\ncurrent system configuration permits parallelization.\n\nArgs:\n    task (func): Function that is to be called for each value in ``values``.\n    values (array_like): List or array of values for which the ``task`` function is to be\n        evaluated.\n    task_args (list): Optional additional arguments to the ``task`` function.\n    task_kwargs (dict): Optional additional keyword argument to the ``task`` function.\n    num_processes (int): Number of processes to spawn.\n\nReturns:\n    result: The result list contains the value of ``task(value, *task_args, **task_kwargs)`` for\n    each value in ``values``.\n\nRaises:\n    QiskitError: If user interrupts via keyboard.\n\nExamples:\n\n    .. code-block:: python\n\n        import time\n        from qiskit.utils import parallel_map\n        def func(_):\n                time.sleep(0.1)\n                return 0\n        parallel_map(func, list(range(10)));",
        "api_signature": "parallel_map(task, values, task_args, task_kwargs, num_processes)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/utils/parallel.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ScheduleConfig.__init__",
        "api_description": "Container for information needed to schedule a QuantumCircuit into a pulse Schedule.\n\nArgs:\n    inst_map: The schedule definition of all gates supported on a backend.\n    meas_map: A list of groups of qubits which have to be measured together.\n    dt: Sample duration.",
        "api_signature": "__init__(self, inst_map, meas_map, dt)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/scheduler/config.py"
    },
    {
        "api_name": "lower_gates",
        "full_api_name": "lower_gates",
        "api_description": "Return a list of Schedules and the qubits they operate on, for each element encountered in the\ninput circuit.\n\nWithout concern for the final schedule, extract and return a list of Schedules and the qubits\nthey operate on, for each element encountered in the input circuit. Measures are grouped when\npossible, so ``qc.measure(q0, c0)`` or ``qc.measure(q1, c1)`` will generate a synchronous\nmeasurement pulse.\n\nArgs:\n    circuit: The quantum circuit to translate.\n    schedule_config: Backend specific parameters used for building the Schedule.\n    backend: Pass in the backend used to build the Schedule, the backend could be BackendV1\n             or BackendV2\n\nReturns:\n    A list of CircuitPulseDefs: the pulse definition for each circuit element.\n\nRaises:\n    QiskitError: If circuit uses a command that isn't defined in config.inst_map.",
        "api_signature": "lower_gates(circuit, schedule_config, backend)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/scheduler/lowering.py"
    },
    {
        "api_name": "get_measure_schedule",
        "full_api_name": "get_measure_schedule",
        "api_description": "Create a schedule to measure the qubits queued for measuring.",
        "api_signature": "get_measure_schedule(qubit_mem_slots)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/scheduler/lowering.py"
    },
    {
        "api_name": "sequence",
        "full_api_name": "sequence",
        "api_description": "Return the pulse Schedule which implements the input scheduled circuit.\n\nAssume all measurements are done at once at the last of the circuit.\nSchedules according to the command definition given by the schedule_config.\n\nArgs:\n    scheduled_circuit: The scheduled quantum circuit to translate.\n    schedule_config: Backend specific parameters used for building the Schedule.\n    backend: A backend used to build the Schedule, the backend could be BackendV1\n             or BackendV2\n\nReturns:\n    A schedule corresponding to the input ``circuit``.\n\nRaises:\n    QiskitError: If invalid scheduled circuit is supplied.",
        "api_signature": "sequence(scheduled_circuit, schedule_config, backend)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/scheduler/sequence.py"
    },
    {
        "api_name": "_meas_start_time",
        "full_api_name": "_meas_start_time",
        "api_description": "",
        "api_signature": "_meas_start_time()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/scheduler/sequence.py"
    },
    {
        "api_name": "schedule_circuit",
        "full_api_name": "schedule_circuit",
        "api_description": "Basic scheduling pass from a circuit to a pulse Schedule, using the backend. If no method is\nspecified, then a basic, as late as possible scheduling pass is performed, i.e. pulses are\nscheduled to occur as late as possible.\n\nSupported methods:\n\n    * ``'as_soon_as_possible'``: Schedule pulses greedily, as early as possible on a\n      qubit resource. (alias: ``'asap'``)\n    * ``'as_late_as_possible'``: Schedule pulses late-- keep qubits in the ground state when\n      possible. (alias: ``'alap'``)\n\nArgs:\n    circuit: The quantum circuit to translate.\n    schedule_config: Backend specific parameters used for building the Schedule.\n    method: The scheduling pass method to use.\n    backend: A backend used to build the Schedule, the backend could be BackendV1\n             or BackendV2.\n\nReturns:\n    Schedule corresponding to the input circuit.\n\nRaises:\n    QiskitError: If method isn't recognized.",
        "api_signature": "schedule_circuit(circuit, schedule_config, method, backend)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/scheduler/schedule_circuit.py"
    },
    {
        "api_name": "as_soon_as_possible",
        "full_api_name": "as_soon_as_possible",
        "api_description": "Return the pulse Schedule which implements the input circuit using an \"as soon as possible\"\n(asap) scheduling policy.\n\nCircuit instructions are first each mapped to equivalent pulse\nSchedules according to the command definition given by the schedule_config. Then, this circuit\ninstruction-equivalent Schedule is appended at the earliest time at which all qubits involved\nin the instruction are available.\n\nArgs:\n    circuit: The quantum circuit to translate.\n    schedule_config: Backend specific parameters used for building the Schedule.\n    backend: A backend used to build the Schedule, the backend could be BackendV1\n             or BackendV2.\n\nReturns:\n    A schedule corresponding to the input ``circuit`` with pulses occurring as early as\n    possible.",
        "api_signature": "as_soon_as_possible(circuit, schedule_config, backend)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/scheduler/methods/basic.py"
    },
    {
        "api_name": "update_times",
        "full_api_name": "update_times",
        "api_description": "Update the time tracker for all inst_qubits to the given time.",
        "api_signature": "update_times(inst_qubits, time)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/scheduler/methods/basic.py"
    },
    {
        "api_name": "as_late_as_possible",
        "full_api_name": "as_late_as_possible",
        "api_description": "Return the pulse Schedule which implements the input circuit using an \"as late as possible\"\n(alap) scheduling policy.\n\nCircuit instructions are first each mapped to equivalent pulse\nSchedules according to the command definition given by the schedule_config. Then, this circuit\ninstruction-equivalent Schedule is appended at the latest time that it can be without allowing\nunnecessary time between instructions or allowing instructions with common qubits to overlap.\n\nThis method should improves the outcome fidelity over ASAP scheduling, because we may\nmaximize the time that the qubit remains in the ground state.\n\nArgs:\n    circuit: The quantum circuit to translate.\n    schedule_config: Backend specific parameters used for building the Schedule.\n    backend: A backend used to build the Schedule, the backend could be BackendV1\n             or BackendV2.\n\nReturns:\n    A schedule corresponding to the input ``circuit`` with pulses occurring as late as\n    possible.",
        "api_signature": "as_late_as_possible(circuit, schedule_config, backend)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/scheduler/methods/basic.py"
    },
    {
        "api_name": "update_times",
        "full_api_name": "update_times",
        "api_description": "Update the time tracker for all inst_qubits to the given time.",
        "api_signature": "update_times(inst_qubits, time)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/scheduler/methods/basic.py"
    },
    {
        "api_name": "dagdependency_to_circuit",
        "full_api_name": "dagdependency_to_circuit",
        "api_description": "Build a ``QuantumCircuit`` object from a ``DAGDependency``.\n\nArgs:\n    dagdependency (DAGDependency): the input dag.\n\nReturn:\n    QuantumCircuit: the circuit representing the input dag dependency.",
        "api_signature": "dagdependency_to_circuit(dagdependency)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/converters/dagdependency_to_circuit.py"
    },
    {
        "api_name": "circuit_to_instruction",
        "full_api_name": "circuit_to_instruction",
        "api_description": "Build an :class:`~.circuit.Instruction` object from a :class:`.QuantumCircuit`.\n\nThe instruction is anonymous (not tied to a named quantum register),\nand so can be inserted into another circuit. The instruction will\nhave the same string name as the circuit.\n\nArgs:\n    circuit (QuantumCircuit): the input circuit.\n    parameter_map (dict): For parameterized circuits, a mapping from\n       parameters in the circuit to parameters to be used in the instruction.\n       If None, existing circuit parameters will also parameterize the\n       instruction.\n    equivalence_library (EquivalenceLibrary): Optional equivalence library\n       where the converted instruction will be registered.\n    label (str): Optional instruction label.\n\nRaises:\n    QiskitError: if parameter_map is not compatible with circuit\n\nReturn:\n    qiskit.circuit.Instruction: an instruction equivalent to the action of the\n    input circuit. Upon decomposition, this instruction will\n    yield the components comprising the original circuit.\n\nExample:\n    .. code-block::\n\n        from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit\n        from qiskit.converters import circuit_to_instruction\n\n        q = QuantumRegister(3, 'q')\n        c = ClassicalRegister(3, 'c')\n        circ = QuantumCircuit(q, c)\n        circ.h(q[0])\n        circ.cx(q[0], q[1])\n        circ.measure(q[0], c[0])\n        circ.rz(0.5, q[1]).c_if(c, 2)\n        circuit_to_instruction(circ)",
        "api_signature": "circuit_to_instruction(circuit, parameter_map, equivalence_library, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/converters/circuit_to_instruction.py"
    },
    {
        "api_name": "fix_condition",
        "full_api_name": "fix_condition",
        "api_description": "",
        "api_signature": "fix_condition(op)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/converters/circuit_to_instruction.py"
    },
    {
        "api_name": "dagdependency_to_dag",
        "full_api_name": "dagdependency_to_dag",
        "api_description": "Build a ``DAGCircuit`` object from a ``DAGDependency``.\n\nArgs:\n    dag dependency (DAGDependency): the input dag.\n\nReturn:\n    DAGCircuit: the DAG representing the input circuit.",
        "api_signature": "dagdependency_to_dag(dagdependency)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/converters/dagdependency_to_dag.py"
    },
    {
        "api_name": "dag_to_dagdependency",
        "full_api_name": "dag_to_dagdependency",
        "api_description": "Build a ``DAGDependency`` object from a ``DAGCircuit``.\n\nArgs:\n    dag (DAGCircuit): the input dag.\n    create_preds_and_succs (bool): whether to construct lists of\n        predecessors and successors for every node.\n\nReturn:\n    DAGDependency: the DAG representing the input circuit as a dag dependency.",
        "api_signature": "dag_to_dagdependency(dag, create_preds_and_succs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/converters/dag_to_dagdependency.py"
    },
    {
        "api_name": "dag_to_circuit",
        "full_api_name": "dag_to_circuit",
        "api_description": "Build a ``QuantumCircuit`` object from a ``DAGCircuit``.\n\nArgs:\n    dag (DAGCircuit): the input dag.\n    copy_operations (bool): Deep copy the operation objects\n        in the :class:`~.DAGCircuit` for the output :class:`~.QuantumCircuit`.\n        This should only be set to ``False`` if the input :class:`~.DAGCircuit`\n        will not be used anymore as the operations in the output\n        :class:`~.QuantumCircuit` will be shared instances and\n        modifications to operations in the :class:`~.DAGCircuit` will\n        be reflected in the :class:`~.QuantumCircuit` (and vice versa).\n\nReturn:\n    QuantumCircuit: the circuit representing the input dag.\n\nExample:\n    .. plot::\n       :include-source:\n\n       from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit\n       from qiskit.dagcircuit import DAGCircuit\n       from qiskit.converters import circuit_to_dag\n       from qiskit.circuit.library.standard_gates import CHGate, U2Gate, CXGate\n       from qiskit.converters import dag_to_circuit\n\n       q = QuantumRegister(3, 'q')\n       c = ClassicalRegister(3, 'c')\n       circ = QuantumCircuit(q, c)\n       circ.h(q[0])\n       circ.cx(q[0], q[1])\n       circ.measure(q[0], c[0])\n       circ.rz(0.5, q[1]).c_if(c, 2)\n       dag = circuit_to_dag(circ)\n       circuit = dag_to_circuit(dag)\n       circuit.draw('mpl')",
        "api_signature": "dag_to_circuit(dag, copy_operations)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/converters/dag_to_circuit.py"
    },
    {
        "api_name": "_dag_to_dagdependency_v2",
        "full_api_name": "_dag_to_dagdependency_v2",
        "api_description": "Build a ``_DAGDependencyV2`` object from a ``DAGCircuit``.\n\nArgs:\n    dag (DAGCircuit): the input dag.\n\nReturn:\n    _DAGDependencyV2: the DAG representing the input circuit as a dag dependency.",
        "api_signature": "_dag_to_dagdependency_v2(dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/converters/dag_to_dagdependency_v2.py"
    },
    {
        "api_name": "_check_is_gate",
        "full_api_name": "_check_is_gate",
        "api_description": "Checks whether op can be converted to Gate.",
        "api_signature": "_check_is_gate(op)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/converters/circuit_to_gate.py"
    },
    {
        "api_name": "circuit_to_gate",
        "full_api_name": "circuit_to_gate",
        "api_description": "Build a :class:`.Gate` object from a :class:`.QuantumCircuit`.\n\nThe gate is anonymous (not tied to a named quantum register),\nand so can be inserted into another circuit. The gate will\nhave the same string name as the circuit.\n\nArgs:\n    circuit (QuantumCircuit): the input circuit.\n    parameter_map (dict): For parameterized circuits, a mapping from\n       parameters in the circuit to parameters to be used in the gate.\n       If None, existing circuit parameters will also parameterize the\n       Gate.\n    equivalence_library (EquivalenceLibrary): Optional equivalence library\n       where the converted gate will be registered.\n    label (str): Optional gate label.\n\nRaises:\n    QiskitError: if circuit is non-unitary or if\n        parameter_map is not compatible with circuit\n\nReturn:\n    Gate: a Gate equivalent to the action of the\n    input circuit. Upon decomposition, this gate will\n    yield the components comprising the original circuit.",
        "api_signature": "circuit_to_gate(circuit, parameter_map, equivalence_library, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/converters/circuit_to_gate.py"
    },
    {
        "api_name": "circuit_to_dagdependency",
        "full_api_name": "circuit_to_dagdependency",
        "api_description": "Build a ``DAGDependency`` object from a :class:`~.QuantumCircuit`.\n\nArgs:\n    circuit (QuantumCircuit): the input circuit.\n    create_preds_and_succs (bool): whether to construct lists of\n        predecessors and successors for every node.\n\nReturn:\n    DAGDependency: the DAG representing the input circuit as a dag dependency.",
        "api_signature": "circuit_to_dagdependency(circuit, create_preds_and_succs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/converters/circuit_to_dagdependency.py"
    },
    {
        "api_name": "isinstanceint",
        "full_api_name": "isinstanceint",
        "api_description": "Like isinstance(obj,int), but with casting. Except for strings.",
        "api_signature": "isinstanceint(obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/converters/__init__.py"
    },
    {
        "api_name": "isinstancelist",
        "full_api_name": "isinstancelist",
        "api_description": "Like isinstance(obj, list), but with casting. Except for strings and dicts.",
        "api_signature": "isinstancelist(obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/converters/__init__.py"
    },
    {
        "api_name": "circuit_to_dag",
        "full_api_name": "circuit_to_dag",
        "api_description": "Build a :class:`.DAGCircuit` object from a :class:`.QuantumCircuit`.\n\nArgs:\n    circuit (QuantumCircuit): the input circuit.\n    copy_operations (bool): Deep copy the operation objects\n        in the :class:`~.QuantumCircuit` for the output :class:`~.DAGCircuit`.\n        This should only be set to ``False`` if the input :class:`~.QuantumCircuit`\n        will not be used anymore as the operations in the output\n        :class:`~.DAGCircuit` will be shared instances and modifications to\n        operations in the :class:`~.DAGCircuit` will be reflected in the\n        :class:`~.QuantumCircuit` (and vice versa).\n    qubit_order (Iterable[~qiskit.circuit.Qubit] or None): the order that the qubits should be\n        indexed in the output DAG.  Defaults to the same order as in the circuit.\n    clbit_order (Iterable[Clbit] or None): the order that the clbits should be indexed in the\n        output DAG.  Defaults to the same order as in the circuit.\n\nReturn:\n    DAGCircuit: the DAG representing the input circuit.\n\nRaises:\n    ValueError: if the ``qubit_order`` or ``clbit_order`` parameters do not match the bits in\n        the circuit.\n\nExample:\n    .. code-block::\n\n        from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit\n        from qiskit.dagcircuit import DAGCircuit\n        from qiskit.converters import circuit_to_dag\n\n        q = QuantumRegister(3, 'q')\n        c = ClassicalRegister(3, 'c')\n        circ = QuantumCircuit(q, c)\n        circ.h(q[0])\n        circ.cx(q[0], q[1])\n        circ.measure(q[0], c[0])\n        circ.rz(0.5, q[1]).c_if(c, 2)\n        dag = circuit_to_dag(circ)",
        "api_signature": "circuit_to_dag(circuit, copy_operations)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/converters/circuit_to_dag.py"
    },
    {
        "api_name": "_circuit_to_dagdependency_v2",
        "full_api_name": "_circuit_to_dagdependency_v2",
        "api_description": "Build a ``_DAGDependencyV2`` object from a :class:`~.QuantumCircuit`.\n\nArgs:\n    circuit (QuantumCircuit): the input circuit.\n\nReturn:\n    _DAGDependencyV2: the DAG representing the input circuit as a dag dependency.",
        "api_signature": "_circuit_to_dagdependency_v2(circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/converters/circuit_to_dagdependency_v2.py"
    },
    {
        "api_name": "read_generic_typed_data",
        "full_api_name": "read_generic_typed_data",
        "api_description": "Read a single data chunk from the file like object.\n\nArgs:\n    file_obj (File): A file like object that contains the QPY binary data.\n\nReturns:\n    tuple: Tuple of type key binary and the bytes object of the single data.",
        "api_signature": "read_generic_typed_data(file_obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/common.py"
    },
    {
        "api_name": "read_sequence",
        "full_api_name": "read_sequence",
        "api_description": "Read a sequence of data from the file like object.\n\nArgs:\n    file_obj (File): A file like object that contains the QPY binary data.\n    deserializer (Callable): Deserializer callback that can handle input object type.\n        This must take type key and binary data of the element and return object.\n    kwargs: Options set to the deserializer.\n\nReturns:\n    list: Deserialized object.",
        "api_signature": "read_sequence(file_obj, deserializer)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/common.py"
    },
    {
        "api_name": "read_mapping",
        "full_api_name": "read_mapping",
        "api_description": "Read a mapping from the file like object.\n\n.. note::\n\n    This function must be used to make a binary data of mapping\n    which include QPY serialized values.\n    It's easier to use JSON serializer followed by encoding for standard data formats.\n    This only supports flat dictionary and key must be string.\n\nArgs:\n    file_obj (File): A file like object that contains the QPY binary data.\n    deserializer (Callable): Deserializer callback that can handle mapping item.\n        This must take type key and binary data of the mapping value and return object.\n    kwargs: Options set to the deserializer.\n\nReturns:\n    dict: Deserialized object.",
        "api_signature": "read_mapping(file_obj, deserializer)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/common.py"
    },
    {
        "api_name": "read_type_key",
        "full_api_name": "read_type_key",
        "api_description": "Read a type key from the file like object.\n\nArgs:\n    file_obj (File): A file like object that contains the QPY binary data.\n\nReturns:\n    bytes: Type key.",
        "api_signature": "read_type_key(file_obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/common.py"
    },
    {
        "api_name": "write_generic_typed_data",
        "full_api_name": "write_generic_typed_data",
        "api_description": "Write statically typed binary data to the file like object.\n\nArgs:\n    file_obj (File): A file like object to write data.\n    type_key (Enum): Object type of the data.\n    data_binary (bytes): Binary data to write.",
        "api_signature": "write_generic_typed_data(file_obj, type_key, data_binary)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/common.py"
    },
    {
        "api_name": "write_sequence",
        "full_api_name": "write_sequence",
        "api_description": "Write a sequence of data in the file like object.\n\nArgs:\n    file_obj (File): A file like object to write data.\n    sequence (Sequence): Object to serialize.\n    serializer (Callable): Serializer callback that can handle input object type.\n        This must return type key and binary data of each element.\n    kwargs: Options set to the serializer.",
        "api_signature": "write_sequence(file_obj, sequence, serializer)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/common.py"
    },
    {
        "api_name": "write_mapping",
        "full_api_name": "write_mapping",
        "api_description": "Write a mapping in the file like object.\n\n.. note::\n\n    This function must be used to make a binary data of mapping\n    which include QPY serialized values.\n    It's easier to use JSON serializer followed by encoding for standard data formats.\n    This only supports flat dictionary and key must be string.\n\nArgs:\n    file_obj (File): A file like object to write data.\n    mapping (Mapping): Object to serialize.\n    serializer (Callable): Serializer callback that can handle mapping item.\n        This must return type key and binary data of the mapping value.\n    kwargs: Options set to the serializer.",
        "api_signature": "write_mapping(file_obj, mapping, serializer)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/common.py"
    },
    {
        "api_name": "write_type_key",
        "full_api_name": "write_type_key",
        "api_description": "Write a type key in the file like object.\n\nArgs:\n    file_obj (File): A file like object that contains the QPY binary data.\n    type_key (bytes): Type key to write.",
        "api_signature": "write_type_key(file_obj, type_key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/common.py"
    },
    {
        "api_name": "data_to_binary",
        "full_api_name": "data_to_binary",
        "api_description": "Convert object into binary data with specified serializer.\n\nArgs:\n    obj (any): Object to serialize.\n    serializer (Callable): Serializer callback that can handle input object type.\n    kwargs: Options set to the serializer.\n\nReturns:\n    bytes: Binary data.",
        "api_signature": "data_to_binary(obj, serializer)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/common.py"
    },
    {
        "api_name": "sequence_to_binary",
        "full_api_name": "sequence_to_binary",
        "api_description": "Convert sequence into binary data with specified serializer.\n\nArgs:\n    sequence (Sequence): Object to serialize.\n    serializer (Callable): Serializer callback that can handle input object type.\n        This must return type key and binary data of each element.\n    kwargs: Options set to the serializer.\n\nReturns:\n    bytes: Binary data.",
        "api_signature": "sequence_to_binary(sequence, serializer)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/common.py"
    },
    {
        "api_name": "mapping_to_binary",
        "full_api_name": "mapping_to_binary",
        "api_description": "Convert mapping into binary data with specified serializer.\n\n.. note::\n\n    This function must be used to make a binary data of mapping\n    which include QPY serialized values.\n    It's easier to use JSON serializer followed by encoding for standard data formats.\n    This only supports flat dictionary and key must be string.\n\nArgs:\n    mapping (Mapping): Object to serialize.\n    serializer (Callable): Serializer callback that can handle mapping item.\n        This must return type key and binary data of the mapping value.\n    kwargs: Options set to the serializer.\n\nReturns:\n    bytes: Binary data.",
        "api_signature": "mapping_to_binary(mapping, serializer)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/common.py"
    },
    {
        "api_name": "data_from_binary",
        "full_api_name": "data_from_binary",
        "api_description": "Load object from binary data with specified deserializer.\n\nArgs:\n    binary_data (bytes): Binary data to deserialize.\n    deserializer (Callable): Deserializer callback that can handle input object type.\n    kwargs: Options set to the deserializer.\n\nReturns:\n    any: Deserialized object.",
        "api_signature": "data_from_binary(binary_data, deserializer)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/common.py"
    },
    {
        "api_name": "sequence_from_binary",
        "full_api_name": "sequence_from_binary",
        "api_description": "Load object from binary sequence with specified deserializer.\n\nArgs:\n    binary_data (bytes): Binary data to deserialize.\n    deserializer (Callable): Deserializer callback that can handle input object type.\n        This must take type key and binary data of the element and return object.\n    kwargs: Options set to the deserializer.\n\nReturns:\n    any: Deserialized sequence.",
        "api_signature": "sequence_from_binary(binary_data, deserializer)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/common.py"
    },
    {
        "api_name": "mapping_from_binary",
        "full_api_name": "mapping_from_binary",
        "api_description": "Load object from binary mapping with specified deserializer.\n\n.. note::\n\n    This function must be used to make a binary data of mapping\n    which include QPY serialized values.\n    It's easier to use JSON serializer followed by encoding for standard data formats.\n    This only supports flat dictionary and key must be string.\n\nArgs:\n    binary_data (bytes): Binary data to deserialize.\n    deserializer (Callable): Deserializer callback that can handle mapping item.\n        This must take type key and binary data of the mapping value and return object.\n    kwargs: Options set to the deserializer.\n\nReturns:\n    dict: Deserialized object.",
        "api_signature": "mapping_from_binary(binary_data, deserializer)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/common.py"
    },
    {
        "api_name": "dump",
        "full_api_name": "dump",
        "api_description": "Write QPY binary data to a file\n\nThis function is used to save a circuit to a file for later use or transfer\nbetween machines. The QPY format is backwards compatible and can be\nloaded with future versions of Qiskit.\n\nFor example:\n\n.. code-block:: python\n\n    from qiskit.circuit import QuantumCircuit\n    from qiskit import qpy\n\n    qc = QuantumCircuit(2, name='Bell', metadata={'test': True})\n    qc.h(0)\n    qc.cx(0, 1)\n    qc.measure_all()\n\nfrom this you can write the qpy data to a file:\n\n.. code-block:: python\n\n    with open('bell.qpy', 'wb') as fd:\n        qpy.dump(qc, fd)\n\nor a gzip compressed file:\n\n.. code-block:: python\n\n    import gzip\n\n    with gzip.open('bell.qpy.gz', 'wb') as fd:\n        qpy.dump(qc, fd)\n\nWhich will save the qpy serialized circuit to the provided file.\n\nArgs:\n    programs: QPY supported object(s) to store in the specified file like object.\n        QPY supports :class:`.QuantumCircuit` and :class:`.ScheduleBlock`.\n        Different data types must be separately serialized.\n    file_obj: The file like object to write the QPY data too\n    metadata_serializer: An optional JSONEncoder class that\n        will be passed the ``.metadata`` attribute for each program in ``programs`` and will be\n        used as the ``cls`` kwarg on the `json.dump()`` call to JSON serialize that dictionary.\n    use_symengine: If True, all objects containing symbolic expressions will be serialized\n        using symengine's native mechanism. This is a faster serialization alternative,\n        but not supported in all platforms. Please check that your target platform is supported\n        by the symengine library before setting this option, as it will be required by qpy to\n        deserialize the payload. For this reason, the option defaults to False.\n    version: The QPY format version to emit. By default this defaults to\n        the latest supported format of :attr:`~.qpy.QPY_VERSION`, however for\n        compatibility reasons if you need to load the generated QPY payload with an older\n        version of Qiskit you can also select an older QPY format version down to the minimum\n        supported export version, which only can change during a Qiskit major version release,\n        to generate an older QPY format version.  You can access the current QPY version and\n        minimum compatible version with :attr:`.qpy.QPY_VERSION` and\n        :attr:`.qpy.QPY_COMPATIBILITY_VERSION` respectively.\n\n        .. note::\n\n            If specified with an older version of QPY the limitations and potential bugs stemming\n            from the QPY format at that version will persist. This should only be used if\n            compatibility with loading the payload with an older version of Qiskit is necessary.\n\nRaises:\n    QpyError: When multiple data format is mixed in the output.\n    TypeError: When invalid data type is input.\n    ValueError: When an unsupported version number is passed in for the ``version`` argument",
        "api_signature": "dump(programs, file_obj, metadata_serializer, use_symengine, version)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/interface.py"
    },
    {
        "api_name": "load",
        "full_api_name": "load",
        "api_description": "Load a QPY binary file\n\nThis function is used to load a serialized QPY Qiskit program file and create\n:class:`~qiskit.circuit.QuantumCircuit` objects or\n:class:`~qiskit.pulse.schedule.ScheduleBlock` objects from its contents.\nFor example:\n\n.. code-block:: python\n\n    from qiskit import qpy\n\n    with open('bell.qpy', 'rb') as fd:\n        circuits = qpy.load(fd)\n\nor with a gzip compressed file:\n\n.. code-block:: python\n\n    import gzip\n    from qiskit import qpy\n\n    with gzip.open('bell.qpy.gz', 'rb') as fd:\n        circuits = qpy.load(fd)\n\nwhich will read the contents of the qpy and return a list of\n:class:`~qiskit.circuit.QuantumCircuit` objects or\n:class:`~qiskit.pulse.schedule.ScheduleBlock` objects from the file.\n\nArgs:\n    file_obj: A file like object that contains the QPY binary\n        data for a circuit or pulse schedule.\n    metadata_deserializer: An optional JSONDecoder class\n        that will be used for the ``cls`` kwarg on the internal\n        ``json.load`` call used to deserialize the JSON payload used for\n        the ``.metadata`` attribute for any programs in the QPY file.\n        If this is not specified the circuit metadata will\n        be parsed as JSON with the stdlib ``json.load()`` function using\n        the default ``JSONDecoder`` class.\n\nReturns:\n    The list of Qiskit programs contained in the QPY data.\n    A list is always returned, even if there is only 1 program in the QPY data.\n\nRaises:\n    QiskitError: if ``file_obj`` is not a valid QPY file\n    TypeError: When invalid data type is loaded.",
        "api_signature": "load(file_obj, metadata_deserializer)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/interface.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QpyError.__init__",
        "api_description": "Set the error message.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/exceptions.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "QpyError.__str__",
        "api_description": "Return the message.",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/exceptions.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "UnsupportedFeatureForVersion.__init__",
        "api_description": "Args:\n    feature: a description of the problematic feature.\n    required: the minimum version of QPY that would be required to represent this\n        feature.\n    target: the version of QPY that is being used in the serialization.",
        "api_signature": "__init__(self, feature, required, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/exceptions.py"
    },
    {
        "api_name": "assign",
        "full_api_name": "TypeKeyBase.assign",
        "api_description": "Assign type key to given object.\n\nArgs:\n    obj (any): Arbitrary object to evaluate.\n\nReturns:\n    TypeKey: Corresponding key object.",
        "api_signature": "assign(cls, obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/type_keys.py"
    },
    {
        "api_name": "retrieve",
        "full_api_name": "TypeKeyBase.retrieve",
        "api_description": "Get a class from given type key.\n\nArgs:\n    type_key (bytes): Object type key.\n\nReturns:\n    any: Corresponding class.",
        "api_signature": "retrieve(cls, type_key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/type_keys.py"
    },
    {
        "api_name": "assign",
        "full_api_name": "Value.assign",
        "api_description": "",
        "api_signature": "assign(cls, obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/type_keys.py"
    },
    {
        "api_name": "retrieve",
        "full_api_name": "Value.retrieve",
        "api_description": "",
        "api_signature": "retrieve(cls, type_key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/type_keys.py"
    },
    {
        "api_name": "assign",
        "full_api_name": "Container.assign",
        "api_description": "",
        "api_signature": "assign(cls, obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/type_keys.py"
    },
    {
        "api_name": "retrieve",
        "full_api_name": "Container.retrieve",
        "api_description": "",
        "api_signature": "retrieve(cls, type_key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/type_keys.py"
    },
    {
        "api_name": "assign",
        "full_api_name": "CircuitInstruction.assign",
        "api_description": "",
        "api_signature": "assign(cls, obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/type_keys.py"
    },
    {
        "api_name": "retrieve",
        "full_api_name": "CircuitInstruction.retrieve",
        "api_description": "",
        "api_signature": "retrieve(cls, type_key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/type_keys.py"
    },
    {
        "api_name": "assign",
        "full_api_name": "ScheduleAlignment.assign",
        "api_description": "",
        "api_signature": "assign(cls, obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/type_keys.py"
    },
    {
        "api_name": "retrieve",
        "full_api_name": "ScheduleAlignment.retrieve",
        "api_description": "",
        "api_signature": "retrieve(cls, type_key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/type_keys.py"
    },
    {
        "api_name": "assign",
        "full_api_name": "ScheduleInstruction.assign",
        "api_description": "",
        "api_signature": "assign(cls, obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/type_keys.py"
    },
    {
        "api_name": "retrieve",
        "full_api_name": "ScheduleInstruction.retrieve",
        "api_description": "",
        "api_signature": "retrieve(cls, type_key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/type_keys.py"
    },
    {
        "api_name": "assign",
        "full_api_name": "ScheduleOperand.assign",
        "api_description": "",
        "api_signature": "assign(cls, obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/type_keys.py"
    },
    {
        "api_name": "retrieve",
        "full_api_name": "ScheduleOperand.retrieve",
        "api_description": "",
        "api_signature": "retrieve(cls, type_key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/type_keys.py"
    },
    {
        "api_name": "assign",
        "full_api_name": "ScheduleChannel.assign",
        "api_description": "",
        "api_signature": "assign(cls, obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/type_keys.py"
    },
    {
        "api_name": "retrieve",
        "full_api_name": "ScheduleChannel.retrieve",
        "api_description": "",
        "api_signature": "retrieve(cls, type_key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/type_keys.py"
    },
    {
        "api_name": "assign",
        "full_api_name": "Program.assign",
        "api_description": "",
        "api_signature": "assign(cls, obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/type_keys.py"
    },
    {
        "api_name": "retrieve",
        "full_api_name": "Program.retrieve",
        "api_description": "",
        "api_signature": "retrieve(cls, type_key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/type_keys.py"
    },
    {
        "api_name": "assign",
        "full_api_name": "Expression.assign",
        "api_description": "",
        "api_signature": "assign(cls, obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/type_keys.py"
    },
    {
        "api_name": "retrieve",
        "full_api_name": "Expression.retrieve",
        "api_description": "",
        "api_signature": "retrieve(cls, type_key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/type_keys.py"
    },
    {
        "api_name": "assign",
        "full_api_name": "ExprVarDeclaration.assign",
        "api_description": "",
        "api_signature": "assign(cls, obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/type_keys.py"
    },
    {
        "api_name": "retrieve",
        "full_api_name": "ExprVarDeclaration.retrieve",
        "api_description": "",
        "api_signature": "retrieve(cls, type_key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/type_keys.py"
    },
    {
        "api_name": "assign",
        "full_api_name": "ExprType.assign",
        "api_description": "",
        "api_signature": "assign(cls, obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/type_keys.py"
    },
    {
        "api_name": "retrieve",
        "full_api_name": "ExprType.retrieve",
        "api_description": "",
        "api_signature": "retrieve(cls, type_key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/type_keys.py"
    },
    {
        "api_name": "assign",
        "full_api_name": "ExprVar.assign",
        "api_description": "",
        "api_signature": "assign(cls, obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/type_keys.py"
    },
    {
        "api_name": "retrieve",
        "full_api_name": "ExprVar.retrieve",
        "api_description": "",
        "api_signature": "retrieve(cls, type_key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/type_keys.py"
    },
    {
        "api_name": "assign",
        "full_api_name": "ExprValue.assign",
        "api_description": "",
        "api_signature": "assign(cls, obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/type_keys.py"
    },
    {
        "api_name": "retrieve",
        "full_api_name": "ExprValue.retrieve",
        "api_description": "",
        "api_signature": "retrieve(cls, type_key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/type_keys.py"
    },
    {
        "api_name": "assign",
        "full_api_name": "SymExprEncoding.assign",
        "api_description": "",
        "api_signature": "assign(cls, obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/type_keys.py"
    },
    {
        "api_name": "retrieve",
        "full_api_name": "SymExprEncoding.retrieve",
        "api_description": "",
        "api_signature": "retrieve(cls, type_key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/type_keys.py"
    },
    {
        "api_name": "_write_parameter",
        "full_api_name": "_write_parameter",
        "api_description": "",
        "api_signature": "_write_parameter(file_obj, obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/value.py"
    },
    {
        "api_name": "_write_parameter_vec",
        "full_api_name": "_write_parameter_vec",
        "api_description": "",
        "api_signature": "_write_parameter_vec(file_obj, obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/value.py"
    },
    {
        "api_name": "_write_parameter_expression",
        "full_api_name": "_write_parameter_expression",
        "api_description": "",
        "api_signature": "_write_parameter_expression(file_obj, obj, use_symengine)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/value.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "_ExprWriter.__init__",
        "api_description": "",
        "api_signature": "__init__(self, file_obj, clbit_indices, standalone_var_indices, version)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/value.py"
    },
    {
        "api_name": "visit_generic",
        "full_api_name": "_ExprWriter.visit_generic",
        "api_description": "",
        "api_signature": "visit_generic()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/value.py"
    },
    {
        "api_name": "visit_var",
        "full_api_name": "_ExprWriter.visit_var",
        "api_description": "",
        "api_signature": "visit_var()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/value.py"
    },
    {
        "api_name": "visit_value",
        "full_api_name": "_ExprWriter.visit_value",
        "api_description": "",
        "api_signature": "visit_value()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/value.py"
    },
    {
        "api_name": "visit_cast",
        "full_api_name": "_ExprWriter.visit_cast",
        "api_description": "",
        "api_signature": "visit_cast()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/value.py"
    },
    {
        "api_name": "visit_unary",
        "full_api_name": "_ExprWriter.visit_unary",
        "api_description": "",
        "api_signature": "visit_unary()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/value.py"
    },
    {
        "api_name": "visit_binary",
        "full_api_name": "_ExprWriter.visit_binary",
        "api_description": "",
        "api_signature": "visit_binary()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/value.py"
    },
    {
        "api_name": "visit_index",
        "full_api_name": "_ExprWriter.visit_index",
        "api_description": "",
        "api_signature": "visit_index()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/value.py"
    },
    {
        "api_name": "_write_expr",
        "full_api_name": "_write_expr",
        "api_description": "",
        "api_signature": "_write_expr(file_obj, node, clbit_indices, standalone_var_indices, version)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/value.py"
    },
    {
        "api_name": "_write_expr_type",
        "full_api_name": "_write_expr_type",
        "api_description": "",
        "api_signature": "_write_expr_type(file_obj, type_)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/value.py"
    },
    {
        "api_name": "_read_parameter",
        "full_api_name": "_read_parameter",
        "api_description": "",
        "api_signature": "_read_parameter(file_obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/value.py"
    },
    {
        "api_name": "_read_parameter_vec",
        "full_api_name": "_read_parameter_vec",
        "api_description": "",
        "api_signature": "_read_parameter_vec(file_obj, vectors)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/value.py"
    },
    {
        "api_name": "_read_parameter_expression",
        "full_api_name": "_read_parameter_expression",
        "api_description": "",
        "api_signature": "_read_parameter_expression(file_obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/value.py"
    },
    {
        "api_name": "_read_parameter_expression_v3",
        "full_api_name": "_read_parameter_expression_v3",
        "api_description": "",
        "api_signature": "_read_parameter_expression_v3(file_obj, vectors, use_symengine)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/value.py"
    },
    {
        "api_name": "_read_expr",
        "full_api_name": "_read_expr",
        "api_description": "",
        "api_signature": "_read_expr(file_obj, clbits, cregs, standalone_vars)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/value.py"
    },
    {
        "api_name": "_read_expr_type",
        "full_api_name": "_read_expr_type",
        "api_description": "",
        "api_signature": "_read_expr_type(file_obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/value.py"
    },
    {
        "api_name": "read_standalone_vars",
        "full_api_name": "read_standalone_vars",
        "api_description": "Read the ``num_vars`` standalone variable declarations from the file.\n\nArgs:\n    file_obj (File): a file-like object to read from.\n    num_vars (int): the number of variables to read.\n\nReturns:\n    tuple[dict, list]: the first item is a mapping of the ``ExprVarDeclaration`` type keys to\n    the variables defined by that type key, and the second is the total order of variable\n    declarations.",
        "api_signature": "read_standalone_vars(file_obj, num_vars)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/value.py"
    },
    {
        "api_name": "_write_standalone_var",
        "full_api_name": "_write_standalone_var",
        "api_description": "",
        "api_signature": "_write_standalone_var(file_obj, var, type_key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/value.py"
    },
    {
        "api_name": "write_standalone_vars",
        "full_api_name": "write_standalone_vars",
        "api_description": "Write the standalone variables out from a circuit.\n\nArgs:\n    file_obj (File): the file-like object to write to.\n    circuit (QuantumCircuit): the circuit to take the variables from.\n\nReturns:\n    dict[expr.Var, int]: a mapping of the variables written to the index that they were written\n    at.",
        "api_signature": "write_standalone_vars(file_obj, circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/value.py"
    },
    {
        "api_name": "dumps_value",
        "full_api_name": "dumps_value",
        "api_description": "Serialize input value object.\n\nArgs:\n    obj (any): Arbitrary value object to serialize.\n    version (int): the target QPY version for the dump.\n    index_map (dict): Dictionary with two keys, \"q\" and \"c\".  Each key has a value that is a\n        dictionary mapping :class:`.Qubit` or :class:`.Clbit` instances (respectively) to their\n        integer indices.\n    use_symengine (bool): If True, symbolic objects will be serialized using symengine's\n        native mechanism. This is a faster serialization alternative, but not supported in all\n        platforms. Please check that your target platform is supported by the symengine library\n        before setting this option, as it will be required by qpy to deserialize the payload.\n    standalone_var_indices (dict): Dictionary that maps standalone :class:`.expr.Var` entries to\n        the index that should be used to refer to them.\n\nReturns:\n    tuple: TypeKey and binary data.\n\nRaises:\n    QpyError: Serializer for given format is not ready.",
        "api_signature": "dumps_value(obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/value.py"
    },
    {
        "api_name": "write_value",
        "full_api_name": "write_value",
        "api_description": "Write a value to the file like object.\n\nArgs:\n    file_obj (File): A file like object to write data.\n    obj (any): Value to write.\n    version (int): the target QPY version for the dump.\n    index_map (dict): Dictionary with two keys, \"q\" and \"c\".  Each key has a value that is a\n        dictionary mapping :class:`.Qubit` or :class:`.Clbit` instances (respectively) to their\n        integer indices.\n    use_symengine (bool): If True, symbolic objects will be serialized using symengine's\n        native mechanism. This is a faster serialization alternative, but not supported in all\n        platforms. Please check that your target platform is supported by the symengine library\n        before setting this option, as it will be required by qpy to deserialize the payload.\n    standalone_var_indices (dict): Dictionary that maps standalone :class:`.expr.Var` entries to\n        the index that should be used to refer to them.",
        "api_signature": "write_value(file_obj, obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/value.py"
    },
    {
        "api_name": "loads_value",
        "full_api_name": "loads_value",
        "api_description": "Deserialize input binary data to value object.\n\nArgs:\n    type_key (ValueTypeKey): Type enum information.\n    binary_data (bytes): Data to deserialize.\n    version (int): QPY version.\n    vectors (dict): ParameterVector in current scope.\n    clbits (Sequence[Clbit]): Clbits in the current scope.\n    cregs (Mapping[str, ClassicalRegister]): Classical registers in the current scope.\n    use_symengine (bool): If True, symbolic objects will be de-serialized using symengine's\n        native mechanism. This is a faster serialization alternative, but not supported in all\n        platforms. Please check that your target platform is supported by the symengine library\n        before setting this option, as it will be required by qpy to deserialize the payload.\n    standalone_vars (Sequence[Var]): standalone :class:`.expr.Var` nodes in the order that they\n        were declared by the circuit header.\n\nReturns:\n    any: Deserialized value object.\n\nRaises:\n    QpyError: Serializer for given format is not ready.",
        "api_signature": "loads_value(type_key, binary_data, version, vectors)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/value.py"
    },
    {
        "api_name": "read_value",
        "full_api_name": "read_value",
        "api_description": "Read a value from the file like object.\n\nArgs:\n    file_obj (File): A file like object to write data.\n    version (int): QPY version.\n    vectors (dict): ParameterVector in current scope.\n    clbits (Sequence[Clbit]): Clbits in the current scope.\n    cregs (Mapping[str, ClassicalRegister]): Classical registers in the current scope.\n    use_symengine (bool): If True, symbolic objects will be de-serialized using symengine's\n        native mechanism. This is a faster serialization alternative, but not supported in all\n        platforms. Please check that your target platform is supported by the symengine library\n        before setting this option, as it will be required by qpy to deserialize the payload.\n    standalone_vars (Sequence[expr.Var]): standalone variables in the order they were defined in\n        the QPY payload.\n\nReturns:\n    any: Deserialized value object.",
        "api_signature": "read_value(file_obj, version, vectors)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/value.py"
    },
    {
        "api_name": "_read_header_v12",
        "full_api_name": "_read_header_v12",
        "api_description": "",
        "api_signature": "_read_header_v12(file_obj, version, vectors, metadata_deserializer)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/circuits.py"
    },
    {
        "api_name": "_read_header_v2",
        "full_api_name": "_read_header_v2",
        "api_description": "",
        "api_signature": "_read_header_v2(file_obj, version, vectors, metadata_deserializer)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/circuits.py"
    },
    {
        "api_name": "_read_header",
        "full_api_name": "_read_header",
        "api_description": "",
        "api_signature": "_read_header(file_obj, metadata_deserializer)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/circuits.py"
    },
    {
        "api_name": "_read_registers_v4",
        "full_api_name": "_read_registers_v4",
        "api_description": "",
        "api_signature": "_read_registers_v4(file_obj, num_registers)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/circuits.py"
    },
    {
        "api_name": "_read_registers",
        "full_api_name": "_read_registers",
        "api_description": "",
        "api_signature": "_read_registers(file_obj, num_registers)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/circuits.py"
    },
    {
        "api_name": "_loads_instruction_parameter",
        "full_api_name": "_loads_instruction_parameter",
        "api_description": "",
        "api_signature": "_loads_instruction_parameter(type_key, data_bytes, version, vectors, registers, circuit, use_symengine, standalone_vars)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/circuits.py"
    },
    {
        "api_name": "_loads_register_param",
        "full_api_name": "_loads_register_param",
        "api_description": "",
        "api_signature": "_loads_register_param(data_bytes, circuit, registers)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/circuits.py"
    },
    {
        "api_name": "_read_instruction",
        "full_api_name": "_read_instruction",
        "api_description": "",
        "api_signature": "_read_instruction(file_obj, circuit, registers, custom_operations, version, vectors, use_symengine, standalone_vars)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/circuits.py"
    },
    {
        "api_name": "_parse_custom_operation",
        "full_api_name": "_parse_custom_operation",
        "api_description": "",
        "api_signature": "_parse_custom_operation(custom_operations, gate_name, params, version, vectors, registers, use_symengine, standalone_vars)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/circuits.py"
    },
    {
        "api_name": "_read_pauli_evolution_gate",
        "full_api_name": "_read_pauli_evolution_gate",
        "api_description": "",
        "api_signature": "_read_pauli_evolution_gate(file_obj, version, vectors)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/circuits.py"
    },
    {
        "api_name": "_read_modifier",
        "full_api_name": "_read_modifier",
        "api_description": "",
        "api_signature": "_read_modifier(file_obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/circuits.py"
    },
    {
        "api_name": "_read_custom_operations",
        "full_api_name": "_read_custom_operations",
        "api_description": "",
        "api_signature": "_read_custom_operations(file_obj, version, vectors)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/circuits.py"
    },
    {
        "api_name": "_read_calibrations",
        "full_api_name": "_read_calibrations",
        "api_description": "",
        "api_signature": "_read_calibrations(file_obj, version, vectors, metadata_deserializer)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/circuits.py"
    },
    {
        "api_name": "_dumps_register",
        "full_api_name": "_dumps_register",
        "api_description": "",
        "api_signature": "_dumps_register(register, index_map)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/circuits.py"
    },
    {
        "api_name": "_dumps_instruction_parameter",
        "full_api_name": "_dumps_instruction_parameter",
        "api_description": "",
        "api_signature": "_dumps_instruction_parameter(param, index_map, use_symengine)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/circuits.py"
    },
    {
        "api_name": "_write_instruction",
        "full_api_name": "_write_instruction",
        "api_description": "",
        "api_signature": "_write_instruction(file_obj, instruction, custom_operations, index_map, use_symengine, version, standalone_var_indices)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/circuits.py"
    },
    {
        "api_name": "_write_pauli_evolution_gate",
        "full_api_name": "_write_pauli_evolution_gate",
        "api_description": "",
        "api_signature": "_write_pauli_evolution_gate(file_obj, evolution_gate, version)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/circuits.py"
    },
    {
        "api_name": "_write_elem",
        "full_api_name": "_write_elem",
        "api_description": "",
        "api_signature": "_write_elem(buffer, op)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/circuits.py"
    },
    {
        "api_name": "_write_modifier",
        "full_api_name": "_write_modifier",
        "api_description": "",
        "api_signature": "_write_modifier(file_obj, modifier)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/circuits.py"
    },
    {
        "api_name": "_write_custom_operation",
        "full_api_name": "_write_custom_operation",
        "api_description": "",
        "api_signature": "_write_custom_operation(file_obj, name, operation, custom_operations, use_symengine, version)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/circuits.py"
    },
    {
        "api_name": "_write_calibrations",
        "full_api_name": "_write_calibrations",
        "api_description": "",
        "api_signature": "_write_calibrations(file_obj, calibrations, metadata_serializer, version)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/circuits.py"
    },
    {
        "api_name": "_write_registers",
        "full_api_name": "_write_registers",
        "api_description": "",
        "api_signature": "_write_registers(file_obj, in_circ_regs, full_bits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/circuits.py"
    },
    {
        "api_name": "_write_layout",
        "full_api_name": "_write_layout",
        "api_description": "",
        "api_signature": "_write_layout(file_obj, circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/circuits.py"
    },
    {
        "api_name": "_read_layout",
        "full_api_name": "_read_layout",
        "api_description": "",
        "api_signature": "_read_layout(file_obj, circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/circuits.py"
    },
    {
        "api_name": "_read_common_layout",
        "full_api_name": "_read_common_layout",
        "api_description": "",
        "api_signature": "_read_common_layout(file_obj, header, circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/circuits.py"
    },
    {
        "api_name": "_read_layout_v2",
        "full_api_name": "_read_layout_v2",
        "api_description": "",
        "api_signature": "_read_layout_v2(file_obj, circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/circuits.py"
    },
    {
        "api_name": "write_circuit",
        "full_api_name": "write_circuit",
        "api_description": "Write a single QuantumCircuit object in the file like object.\n\nArgs:\n    file_obj (FILE): The file like object to write the circuit data in.\n    circuit (QuantumCircuit): The circuit data to write.\n    metadata_serializer (JSONEncoder): An optional JSONEncoder class that\n        will be passed the :attr:`.QuantumCircuit.metadata` dictionary for\n        ``circuit`` and will be used as the ``cls`` kwarg\n        on the ``json.dump()`` call to JSON serialize that dictionary.\n    use_symengine (bool): If True, symbolic objects will be serialized using symengine's\n        native mechanism. This is a faster serialization alternative, but not supported in all\n        platforms. Please check that your target platform is supported by the symengine library\n        before setting this option, as it will be required by qpy to deserialize the payload.\n    version (int): The QPY format version to use for serializing this circuit",
        "api_signature": "write_circuit(file_obj, circuit, metadata_serializer, use_symengine, version)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/circuits.py"
    },
    {
        "api_name": "read_circuit",
        "full_api_name": "read_circuit",
        "api_description": "Read a single QuantumCircuit object from the file like object.\n\nArgs:\n    file_obj (FILE): The file like object to read the circuit data from.\n    version (int): QPY version.\n    metadata_deserializer (JSONDecoder): An optional JSONDecoder class\n        that will be used for the ``cls`` kwarg on the internal\n        ``json.load`` call used to deserialize the JSON payload used for\n        the :attr:`.QuantumCircuit.metadata` attribute for a circuit\n        in the file-like object. If this is not specified the circuit metadata will\n        be parsed as JSON with the stdlib ``json.load()`` function using\n        the default ``JSONDecoder`` class.\n    use_symengine (bool): If True, symbolic objects will be de-serialized using\n        symengine's native mechanism. This is a faster serialization alternative, but not\n        supported in all platforms. Please check that your target platform is supported by\n        the symengine library before setting this option, as it will be required by qpy to\n        deserialize the payload.\nReturns:\n    QuantumCircuit: The circuit object from the file.\n\nRaises:\n    QpyError: Invalid register.",
        "api_signature": "read_circuit(file_obj, version, metadata_deserializer, use_symengine)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/circuits.py"
    },
    {
        "api_name": "_read_channel",
        "full_api_name": "_read_channel",
        "api_description": "",
        "api_signature": "_read_channel(file_obj, version)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/schedules.py"
    },
    {
        "api_name": "_read_waveform",
        "full_api_name": "_read_waveform",
        "api_description": "",
        "api_signature": "_read_waveform(file_obj, version)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/schedules.py"
    },
    {
        "api_name": "_loads_obj",
        "full_api_name": "_loads_obj",
        "api_description": "Wraps `value.loads_value` to deserialize binary data to dictionary\nor list objects which are not supported by `value.loads_value`.",
        "api_signature": "_loads_obj(type_key, binary_data, version, vectors)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/schedules.py"
    },
    {
        "api_name": "_read_kernel",
        "full_api_name": "_read_kernel",
        "api_description": "",
        "api_signature": "_read_kernel(file_obj, version)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/schedules.py"
    },
    {
        "api_name": "_read_discriminator",
        "full_api_name": "_read_discriminator",
        "api_description": "",
        "api_signature": "_read_discriminator(file_obj, version)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/schedules.py"
    },
    {
        "api_name": "_loads_symbolic_expr",
        "full_api_name": "_loads_symbolic_expr",
        "api_description": "",
        "api_signature": "_loads_symbolic_expr(expr_bytes, use_symengine)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/schedules.py"
    },
    {
        "api_name": "_read_symbolic_pulse",
        "full_api_name": "_read_symbolic_pulse",
        "api_description": "",
        "api_signature": "_read_symbolic_pulse(file_obj, version)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/schedules.py"
    },
    {
        "api_name": "_read_symbolic_pulse_v6",
        "full_api_name": "_read_symbolic_pulse_v6",
        "api_description": "",
        "api_signature": "_read_symbolic_pulse_v6(file_obj, version, use_symengine)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/schedules.py"
    },
    {
        "api_name": "_read_alignment_context",
        "full_api_name": "_read_alignment_context",
        "api_description": "",
        "api_signature": "_read_alignment_context(file_obj, version)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/schedules.py"
    },
    {
        "api_name": "_loads_operand",
        "full_api_name": "_loads_operand",
        "api_description": "",
        "api_signature": "_loads_operand(type_key, data_bytes, version, use_symengine)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/schedules.py"
    },
    {
        "api_name": "_read_element",
        "full_api_name": "_read_element",
        "api_description": "",
        "api_signature": "_read_element(file_obj, version, metadata_deserializer, use_symengine)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/schedules.py"
    },
    {
        "api_name": "_loads_reference_item",
        "full_api_name": "_loads_reference_item",
        "api_description": "",
        "api_signature": "_loads_reference_item(type_key, data_bytes, metadata_deserializer, version)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/schedules.py"
    },
    {
        "api_name": "_write_channel",
        "full_api_name": "_write_channel",
        "api_description": "",
        "api_signature": "_write_channel(file_obj, data, version)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/schedules.py"
    },
    {
        "api_name": "_write_waveform",
        "full_api_name": "_write_waveform",
        "api_description": "",
        "api_signature": "_write_waveform(file_obj, data, version)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/schedules.py"
    },
    {
        "api_name": "_dumps_obj",
        "full_api_name": "_dumps_obj",
        "api_description": "Wraps `value.dumps_value` to serialize dictionary and list objects\nwhich are not supported by `value.dumps_value`.",
        "api_signature": "_dumps_obj(obj, version)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/schedules.py"
    },
    {
        "api_name": "_write_kernel",
        "full_api_name": "_write_kernel",
        "api_description": "",
        "api_signature": "_write_kernel(file_obj, data, version)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/schedules.py"
    },
    {
        "api_name": "_write_discriminator",
        "full_api_name": "_write_discriminator",
        "api_description": "",
        "api_signature": "_write_discriminator(file_obj, data, version)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/schedules.py"
    },
    {
        "api_name": "_dumps_symbolic_expr",
        "full_api_name": "_dumps_symbolic_expr",
        "api_description": "",
        "api_signature": "_dumps_symbolic_expr(expr, use_symengine)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/schedules.py"
    },
    {
        "api_name": "_write_symbolic_pulse",
        "full_api_name": "_write_symbolic_pulse",
        "api_description": "",
        "api_signature": "_write_symbolic_pulse(file_obj, data, use_symengine, version)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/schedules.py"
    },
    {
        "api_name": "_write_alignment_context",
        "full_api_name": "_write_alignment_context",
        "api_description": "",
        "api_signature": "_write_alignment_context(file_obj, context, version)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/schedules.py"
    },
    {
        "api_name": "_dumps_operand",
        "full_api_name": "_dumps_operand",
        "api_description": "",
        "api_signature": "_dumps_operand(operand, use_symengine, version)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/schedules.py"
    },
    {
        "api_name": "_write_element",
        "full_api_name": "_write_element",
        "api_description": "",
        "api_signature": "_write_element(file_obj, element, metadata_serializer, use_symengine, version)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/schedules.py"
    },
    {
        "api_name": "_dumps_reference_item",
        "full_api_name": "_dumps_reference_item",
        "api_description": "",
        "api_signature": "_dumps_reference_item(schedule, metadata_serializer, version)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/schedules.py"
    },
    {
        "api_name": "read_schedule_block",
        "full_api_name": "read_schedule_block",
        "api_description": "Read a single ScheduleBlock from the file like object.\n\nArgs:\n    file_obj (File): A file like object that contains the QPY binary data.\n    version (int): QPY version.\n    metadata_deserializer (JSONDecoder): An optional JSONDecoder class\n        that will be used for the ``cls`` kwarg on the internal\n        ``json.load`` call used to deserialize the JSON payload used for\n        the :attr:`.ScheduleBlock.metadata` attribute for a schedule block\n        in the file-like object. If this is not specified the circuit metadata will\n        be parsed as JSON with the stdlib ``json.load()`` function using\n        the default ``JSONDecoder`` class.\n    use_symengine (bool): If True, symbolic objects will be serialized using symengine's\n        native mechanism. This is a faster serialization alternative, but not supported in all\n        platforms. Please check that your target platform is supported by the symengine library\n        before setting this option, as it will be required by qpy to deserialize the payload.\nReturns:\n    ScheduleBlock: The schedule block object from the file.\n\nRaises:\n    TypeError: If any of the instructions is invalid data format.\n    QiskitError: QPY version is earlier than block support.",
        "api_signature": "read_schedule_block(file_obj, version, metadata_deserializer, use_symengine)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/schedules.py"
    },
    {
        "api_name": "write_schedule_block",
        "full_api_name": "write_schedule_block",
        "api_description": "Write a single ScheduleBlock object in the file like object.\n\nArgs:\n    file_obj (File): The file like object to write the circuit data in.\n    block (ScheduleBlock): A schedule block data to write.\n    metadata_serializer (JSONEncoder): An optional JSONEncoder class that\n        will be passed the :attr:`.ScheduleBlock.metadata` dictionary for\n        ``block`` and will be used as the ``cls`` kwarg\n        on the ``json.dump()`` call to JSON serialize that dictionary.\n    use_symengine (bool): If True, symbolic objects will be serialized using symengine's\n        native mechanism. This is a faster serialization alternative, but not supported in all\n        platforms. Please check that your target platform is supported by the symengine library\n        before setting this option, as it will be required by qpy to deserialize the payload.\n    version (int): The QPY format version to use for serializing this circuit block\nRaises:\n    TypeError: If any of the instructions is invalid data format.",
        "api_signature": "write_schedule_block(file_obj, block, metadata_serializer, use_symengine, version)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qpy/binary_io/schedules.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "InstructionScheduleMap.__init__",
        "api_description": "Initialize a circuit instruction to schedule mapper instance.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instruction_schedule_map.py"
    },
    {
        "api_name": "has_custom_gate",
        "full_api_name": "InstructionScheduleMap.has_custom_gate",
        "api_description": "Return ``True`` if the map has user provided instruction.",
        "api_signature": "has_custom_gate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instruction_schedule_map.py"
    },
    {
        "api_name": "instructions",
        "full_api_name": "InstructionScheduleMap.instructions",
        "api_description": "Return all instructions which have definitions.\n\nBy default, these are typically the basis gates along with other instructions such as\nmeasure and reset.\n\nReturns:\n    The names of all the circuit instructions which have Schedule definitions in this.",
        "api_signature": "instructions(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instruction_schedule_map.py"
    },
    {
        "api_name": "qubits_with_instruction",
        "full_api_name": "InstructionScheduleMap.qubits_with_instruction",
        "api_description": "Return a list of the qubits for which the given instruction is defined. Single qubit\ninstructions return a flat list, and multiqubit instructions return a list of ordered\ntuples.\n\nArgs:\n    instruction: The name of the circuit instruction.\n\nReturns:\n    Qubit indices which have the given instruction defined. This is a list of tuples if the\n    instruction has an arity greater than 1, or a flat list of ints otherwise.\n\nRaises:\n    PulseError: If the instruction is not found.",
        "api_signature": "qubits_with_instruction(self, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instruction_schedule_map.py"
    },
    {
        "api_name": "qubit_instructions",
        "full_api_name": "InstructionScheduleMap.qubit_instructions",
        "api_description": "Return a list of the instruction names that are defined by the backend for the given\nqubit or qubits.\n\nArgs:\n    qubits: A qubit index, or a list or tuple of indices.\n\nReturns:\n    All the instructions which are defined on the qubits.\n\n    For 1 qubit, all the 1Q instructions defined. For multiple qubits, all the instructions\n    which apply to that whole set of qubits (e.g. ``qubits=[0, 1]`` may return ``['cx']``).",
        "api_signature": "qubit_instructions(self, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instruction_schedule_map.py"
    },
    {
        "api_name": "has",
        "full_api_name": "InstructionScheduleMap.has",
        "api_description": "Is the instruction defined for the given qubits?\n\nArgs:\n    instruction: The instruction for which to look.\n    qubits: The specific qubits for the instruction.\n\nReturns:\n    True iff the instruction is defined.",
        "api_signature": "has(self, instruction, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instruction_schedule_map.py"
    },
    {
        "api_name": "assert_has",
        "full_api_name": "InstructionScheduleMap.assert_has",
        "api_description": "Error if the given instruction is not defined.\n\nArgs:\n    instruction: The instruction for which to look.\n    qubits: The specific qubits for the instruction.\n\nRaises:\n    PulseError: If the instruction is not defined on the qubits.",
        "api_signature": "assert_has(self, instruction, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instruction_schedule_map.py"
    },
    {
        "api_name": "get",
        "full_api_name": "InstructionScheduleMap.get",
        "api_description": "Return the defined :py:class:`~qiskit.pulse.Schedule` or\n:py:class:`~qiskit.pulse.ScheduleBlock` for the given instruction on the given qubits.\n\nIf all keys are not specified this method returns schedule with unbound parameters.\n\nArgs:\n    instruction: Name of the instruction or the instruction itself.\n    qubits: The qubits for the instruction.\n    *params: Command parameters for generating the output schedule.\n    **kwparams: Keyworded command parameters for generating the schedule.\n\nReturns:\n    The Schedule defined for the input.",
        "api_signature": "get(self, instruction, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instruction_schedule_map.py"
    },
    {
        "api_name": "_get_calibration_entry",
        "full_api_name": "InstructionScheduleMap._get_calibration_entry",
        "api_description": "Return the :class:`.CalibrationEntry` without generating schedule.\n\nWhen calibration entry is un-parsed Pulse Qobj, this returns calibration\nwithout parsing it. :meth:`CalibrationEntry.get_schedule` method\nmust be manually called with assigned parameters to get corresponding pulse schedule.\n\nThis method is expected be directly used internally by the V2 backend converter\nfor faster loading of the backend calibrations.\n\nArgs:\n    instruction: Name of the instruction or the instruction itself.\n    qubits: The qubits for the instruction.\n\nReturns:\n    The calibration entry.",
        "api_signature": "_get_calibration_entry(self, instruction, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instruction_schedule_map.py"
    },
    {
        "api_name": "add",
        "full_api_name": "InstructionScheduleMap.add",
        "api_description": "Add a new known instruction for the given qubits and its mapping to a pulse schedule.\n\nArgs:\n    instruction: The name of the instruction to add.\n    qubits: The qubits which the instruction applies to.\n    schedule: The Schedule that implements the given instruction.\n    arguments: List of parameter names to create a parameter-bound schedule from the\n        associated gate instruction. If :py:meth:`get` is called with arguments rather\n        than keyword arguments, this parameter list is used to map the input arguments to\n        parameter objects stored in the target schedule.\n\nRaises:\n    PulseError: If the qubits are provided as an empty iterable.",
        "api_signature": "add(self, instruction, qubits, schedule, arguments)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instruction_schedule_map.py"
    },
    {
        "api_name": "_add",
        "full_api_name": "InstructionScheduleMap._add",
        "api_description": "A method to resister calibration entry.\n\n.. note::\n\n    This is internal fast-path function, and caller must ensure\n    the entry is properly formatted. This function may be used by other programs\n    that load backend calibrations to create Qiskit representation of it.\n\nArgs:\n    instruction_name: Name of instruction.\n    qubits: List of qubits that this calibration is applied.\n    entry: Calibration entry to register.\n\n:meta public:",
        "api_signature": "_add(self, instruction_name, qubits, entry)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instruction_schedule_map.py"
    },
    {
        "api_name": "remove",
        "full_api_name": "InstructionScheduleMap.remove",
        "api_description": "Remove the given instruction from the listing of instructions defined in self.\n\nArgs:\n    instruction: The name of the instruction to add.\n    qubits: The qubits which the instruction applies to.",
        "api_signature": "remove(self, instruction, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instruction_schedule_map.py"
    },
    {
        "api_name": "pop",
        "full_api_name": "InstructionScheduleMap.pop",
        "api_description": "Remove and return the defined schedule for the given instruction on the given\nqubits.\n\nArgs:\n    instruction: Name of the instruction.\n    qubits: The qubits for the instruction.\n    *params: Command parameters for generating the output schedule.\n    **kwparams: Keyworded command parameters for generating the schedule.\n\nReturns:\n    The Schedule defined for the input.",
        "api_signature": "pop(self, instruction, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instruction_schedule_map.py"
    },
    {
        "api_name": "get_parameters",
        "full_api_name": "InstructionScheduleMap.get_parameters",
        "api_description": "Return the list of parameters taken by the given instruction on the given qubits.\n\nArgs:\n    instruction: Name of the instruction.\n    qubits: The qubits for the instruction.\n\nReturns:\n    The names of the parameters required by the instruction.",
        "api_signature": "get_parameters(self, instruction, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instruction_schedule_map.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "InstructionScheduleMap.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instruction_schedule_map.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "InstructionScheduleMap.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instruction_schedule_map.py"
    },
    {
        "api_name": "_to_tuple",
        "full_api_name": "_to_tuple",
        "api_description": "Return the input as a tuple.\n\nArgs:\n    values: An integer, or iterable of integers.\n\nReturns:\n    The input values as a sorted tuple.",
        "api_signature": "_to_tuple(values)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instruction_schedule_map.py"
    },
    {
        "api_name": "_get_instruction_string",
        "full_api_name": "_get_instruction_string",
        "api_description": "",
        "api_signature": "_get_instruction_string(inst)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instruction_schedule_map.py"
    },
    {
        "api_name": "format_meas_map",
        "full_api_name": "format_meas_map",
        "api_description": "Return a mapping from qubit label to measurement group given the nested list meas_map returned\nby a backend configuration. (Qubits can not always be measured independently.) Sorts the\nmeasurement group for consistency.\n\nArgs:\n    meas_map: Groups of qubits that get measured together, for example: [[0, 1], [2, 3, 4]]\nReturns:\n    Measure map in map format",
        "api_signature": "format_meas_map(meas_map)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/utils.py"
    },
    {
        "api_name": "format_parameter_value",
        "full_api_name": "format_parameter_value",
        "api_description": "Convert ParameterExpression into the most suitable data type.\n\nArgs:\n    operand: Operand value in arbitrary data type including ParameterExpression.\n    decimal: Number of digit to round returned value.\n\nReturns:\n    Value casted to non-parameter data type, when possible.",
        "api_signature": "format_parameter_value(operand, decimal)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/utils.py"
    },
    {
        "api_name": "instruction_duration_validation",
        "full_api_name": "instruction_duration_validation",
        "api_description": "Validate instruction duration.\n\nArgs:\n    duration: Instruction duration value to validate.\n\nRaises:\n    UnassignedDurationError: When duration is unassigned.\n    QiskitError: When invalid duration is assigned.",
        "api_signature": "instruction_duration_validation(duration)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/utils.py"
    },
    {
        "api_name": "_validate_parameter_vector",
        "full_api_name": "_validate_parameter_vector",
        "api_description": "Validate parameter vector and its value.",
        "api_signature": "_validate_parameter_vector(parameter, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/utils.py"
    },
    {
        "api_name": "_validate_single_parameter",
        "full_api_name": "_validate_single_parameter",
        "api_description": "Validate single parameter and its value.",
        "api_signature": "_validate_single_parameter(parameter, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/utils.py"
    },
    {
        "api_name": "_validate_parameter_value",
        "full_api_name": "_validate_parameter_value",
        "api_description": "Validate parameter and its value.",
        "api_signature": "_validate_parameter_value(parameter, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/utils.py"
    },
    {
        "api_name": "define",
        "full_api_name": "CalibrationEntry.define",
        "api_description": "Attach definition to the calibration entry.\n\nArgs:\n    definition: Definition of this entry.\n    user_provided: If this entry is defined by user.\n        If the flag is set, this calibration may appear in the wire format\n        as an inline calibration, to override the backend instruction set architecture.",
        "api_signature": "define(self, definition, user_provided)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/calibration_entries.py"
    },
    {
        "api_name": "get_signature",
        "full_api_name": "CalibrationEntry.get_signature",
        "api_description": "Return signature object associated with entry definition.\n\nReturns:\n    Signature object.",
        "api_signature": "get_signature(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/calibration_entries.py"
    },
    {
        "api_name": "get_schedule",
        "full_api_name": "CalibrationEntry.get_schedule",
        "api_description": "Generate schedule from entry definition.\n\nIf the pulse program is templated with :class:`.Parameter` objects,\nyou can provide corresponding parameter values for this method\nto get a particular pulse program with assigned parameters.\n\nArgs:\n    args: Command parameters.\n    kwargs: Command keyword parameters.\n\nReturns:\n    Pulse schedule with assigned parameters.",
        "api_signature": "get_schedule(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/calibration_entries.py"
    },
    {
        "api_name": "user_provided",
        "full_api_name": "CalibrationEntry.user_provided",
        "api_description": "Return if this entry is user defined.",
        "api_signature": "user_provided(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/calibration_entries.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ScheduleDef.__init__",
        "api_description": "Define an empty entry.\n\nArgs:\n    arguments: User provided argument names for this entry, if parameterized.\n\nRaises:\n    PulseError: When `arguments` is not a sequence of string.",
        "api_signature": "__init__(self, arguments)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/calibration_entries.py"
    },
    {
        "api_name": "user_provided",
        "full_api_name": "ScheduleDef.user_provided",
        "api_description": "",
        "api_signature": "user_provided(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/calibration_entries.py"
    },
    {
        "api_name": "_parse_argument",
        "full_api_name": "ScheduleDef._parse_argument",
        "api_description": "Generate signature from program and user provided argument names.",
        "api_signature": "_parse_argument(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/calibration_entries.py"
    },
    {
        "api_name": "define",
        "full_api_name": "ScheduleDef.define",
        "api_description": "",
        "api_signature": "define(self, definition, user_provided)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/calibration_entries.py"
    },
    {
        "api_name": "get_signature",
        "full_api_name": "ScheduleDef.get_signature",
        "api_description": "",
        "api_signature": "get_signature(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/calibration_entries.py"
    },
    {
        "api_name": "get_schedule",
        "full_api_name": "ScheduleDef.get_schedule",
        "api_description": "",
        "api_signature": "get_schedule(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/calibration_entries.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "ScheduleDef.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/calibration_entries.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "ScheduleDef.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/calibration_entries.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CallableDef.__init__",
        "api_description": "Define an empty entry.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/calibration_entries.py"
    },
    {
        "api_name": "user_provided",
        "full_api_name": "CallableDef.user_provided",
        "api_description": "",
        "api_signature": "user_provided(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/calibration_entries.py"
    },
    {
        "api_name": "define",
        "full_api_name": "CallableDef.define",
        "api_description": "",
        "api_signature": "define(self, definition, user_provided)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/calibration_entries.py"
    },
    {
        "api_name": "get_signature",
        "full_api_name": "CallableDef.get_signature",
        "api_description": "",
        "api_signature": "get_signature(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/calibration_entries.py"
    },
    {
        "api_name": "get_schedule",
        "full_api_name": "CallableDef.get_schedule",
        "api_description": "",
        "api_signature": "get_schedule(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/calibration_entries.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "CallableDef.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/calibration_entries.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "CallableDef.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/calibration_entries.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PulseQobjDef.__init__",
        "api_description": "Define an empty entry.\n\nArgs:\n    arguments: User provided argument names for this entry, if parameterized.\n    converter: Optional. Qobj to Qiskit converter.\n    name: Name of schedule.",
        "api_signature": "__init__(self, arguments, converter, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/calibration_entries.py"
    },
    {
        "api_name": "_build_schedule",
        "full_api_name": "PulseQobjDef._build_schedule",
        "api_description": "Build pulse schedule from cmd-def sequence.",
        "api_signature": "_build_schedule(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/calibration_entries.py"
    },
    {
        "api_name": "define",
        "full_api_name": "PulseQobjDef.define",
        "api_description": "",
        "api_signature": "define(self, definition, user_provided)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/calibration_entries.py"
    },
    {
        "api_name": "get_signature",
        "full_api_name": "PulseQobjDef.get_signature",
        "api_description": "",
        "api_signature": "get_signature(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/calibration_entries.py"
    },
    {
        "api_name": "get_schedule",
        "full_api_name": "PulseQobjDef.get_schedule",
        "api_description": "",
        "api_signature": "get_schedule(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/calibration_entries.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "PulseQobjDef.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/calibration_entries.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "PulseQobjDef.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/calibration_entries.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PulseError.__init__",
        "api_description": "Set the error message.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/exceptions.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "PulseError.__str__",
        "api_description": "Return the message.",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/exceptions.py"
    },
    {
        "api_name": "_requires_backend",
        "full_api_name": "_requires_backend",
        "api_description": "Decorator a function to raise if it is called without a builder with a\nset backend.",
        "api_signature": "_requires_backend(function)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "wrapper",
        "full_api_name": "wrapper",
        "api_description": "",
        "api_signature": "wrapper(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "_PulseBuilder.__init__",
        "api_description": "Initialize the builder context.\n\n.. note::\n    At some point we may consider incorporating the builder into\n    the :class:`~qiskit.pulse.Schedule` class. However, the risk of\n    this is tying the user interface to the intermediate\n    representation. For now we avoid this at the cost of some code\n    duplication.\n\nArgs:\n    backend (Backend): Input backend to use in\n        builder. If not set certain functionality will be unavailable.\n    block: Initital ``ScheduleBlock`` to build on.\n    name: Name of pulse program to be built.\n    default_alignment: Default scheduling alignment for builder.\n        One of ``left``, ``right``, ``sequential`` or an instance of\n        :class:`~qiskit.pulse.transforms.alignments.AlignmentKind` subclass.\n\nRaises:\n    PulseError: When invalid ``default_alignment`` or `block` is specified.",
        "api_signature": "__init__(self, backend, block, name, default_alignment)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "__enter__",
        "full_api_name": "_PulseBuilder.__enter__",
        "api_description": "Enter this builder context and yield either the supplied schedule\nor the schedule created for the user.\n\nReturns:\n    The schedule that the builder will build on.",
        "api_signature": "__enter__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "__exit__",
        "full_api_name": "_PulseBuilder.__exit__",
        "api_description": "Exit the builder context and compile the built pulse program.",
        "api_signature": "__exit__(self, exc_type, exc_val, exc_tb)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "backend",
        "full_api_name": "_PulseBuilder.backend",
        "api_description": "Returns the builder backend if set.\n\nReturns:\n    Optional[Backend]: The builder's backend.",
        "api_signature": "backend(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "push_context",
        "full_api_name": "_PulseBuilder.push_context",
        "api_description": "Push new context to the stack.",
        "api_signature": "push_context(self, alignment)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "pop_context",
        "full_api_name": "_PulseBuilder.pop_context",
        "api_description": "Pop the last context from the stack.",
        "api_signature": "pop_context(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "get_context",
        "full_api_name": "_PulseBuilder.get_context",
        "api_description": "Get current context.\n\nNotes:\n    New instruction can be added by `.append_subroutine` or `.append_instruction` method.\n    Use above methods rather than directly accessing to the current context.",
        "api_signature": "get_context(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "num_qubits",
        "full_api_name": "_PulseBuilder.num_qubits",
        "api_description": "Get the number of qubits in the backend.",
        "api_signature": "num_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "compile",
        "full_api_name": "_PulseBuilder.compile",
        "api_description": "Compile and output the built pulse program.",
        "api_signature": "compile(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "append_instruction",
        "full_api_name": "_PulseBuilder.append_instruction",
        "api_description": "Add an instruction to the builder's context schedule.\n\nArgs:\n    instruction: Instruction to append.",
        "api_signature": "append_instruction(self, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "append_reference",
        "full_api_name": "_PulseBuilder.append_reference",
        "api_description": "Add external program as a :class:`~qiskit.pulse.instructions.Reference` instruction.\n\nArgs:\n    name: Name of subroutine.\n    extra_keys: Assistance keys to uniquely specify the subroutine.",
        "api_signature": "append_reference(self, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "append_subroutine",
        "full_api_name": "_PulseBuilder.append_subroutine",
        "api_description": "Append a :class:`ScheduleBlock` to the builder's context schedule.\n\nThis operation doesn't create a reference. Subroutine is directly\nappended to current context schedule.\n\nArgs:\n    subroutine: ScheduleBlock to append to the current context block.\n\nRaises:\n    PulseError: When subroutine is not Schedule nor ScheduleBlock.",
        "api_signature": "append_subroutine(self, subroutine)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "call_subroutine",
        "full_api_name": "_PulseBuilder.call_subroutine",
        "api_description": "Call a schedule or circuit defined outside of the current scope.\n\nThe ``subroutine`` is appended to the context schedule as a call instruction.\nThis logic just generates a convenient program representation in the compiler.\nThus, this doesn't affect execution of inline subroutines.\nSee :class:`~pulse.instructions.Call` for more details.\n\nArgs:\n    subroutine: Target schedule or circuit to append to the current context.\n    name: Name of subroutine if defined.\n    value_dict: Parameter object and assigned value mapping. This is more precise way to\n        identify a parameter since mapping is managed with unique object id rather than\n        name. Especially there is any name collision in a parameter table.\n    kw_params: Parameter values to bind to the target subroutine\n        with string parameter names. If there are parameter name overlapping,\n        these parameters are updated with the same assigned value.\n\nRaises:\n    PulseError:\n        - When input subroutine is not valid data format.",
        "api_signature": "call_subroutine(self, subroutine, name, value_dict)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "_",
        "full_api_name": "_PulseBuilder._",
        "api_description": "",
        "api_signature": "_(self, target_block, name, value_dict)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "_",
        "full_api_name": "_PulseBuilder._",
        "api_description": "",
        "api_signature": "_(self, target_schedule, name, value_dict)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "_naive_typecast_schedule",
        "full_api_name": "_PulseBuilder._naive_typecast_schedule",
        "api_description": "",
        "api_signature": "_naive_typecast_schedule(schedule)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "get_dt",
        "full_api_name": "_PulseBuilder.get_dt",
        "api_description": "Retrieve dt differently based on the type of Backend",
        "api_signature": "get_dt(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "build",
        "full_api_name": "build",
        "api_description": "Create a context manager for launching the imperative pulse builder DSL.\n\nTo enter a building context and starting building a pulse program:\n\n.. code-block::\n\n    from qiskit import transpile, pulse\n    from qiskit.providers.fake_provider import FakeOpenPulse2Q\n\n    backend = FakeOpenPulse2Q()\n\n    d0 = pulse.DriveChannel(0)\n\n    with pulse.build() as pulse_prog:\n        pulse.play(pulse.Constant(100, 0.5), d0)\n\n\nWhile the output program ``pulse_prog`` cannot be executed as we are using\na mock backend. If a real backend is being used, executing the program is\ndone with:\n\n.. code-block:: python\n\n    backend.run(transpile(pulse_prog, backend))\n\nArgs:\n    backend (Backend): A Qiskit backend. If not supplied certain\n        builder functionality will be unavailable.\n    schedule: A pulse ``ScheduleBlock`` in which your pulse program will be built.\n    name: Name of pulse program to be built.\n    default_alignment: Default scheduling alignment for builder.\n        One of ``left``, ``right``, ``sequential`` or an alignment context.\n\nReturns:\n    A new builder context which has the active builder initialized.",
        "api_signature": "build(backend, schedule, name, default_alignment)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "_active_builder",
        "full_api_name": "_active_builder",
        "api_description": "Get the active builder in the active context.\n\nReturns:\n    The active active builder in this context.\n\nRaises:\n    exceptions.NoActiveBuilder: If a pulse builder function is called\n    outside of a builder context.",
        "api_signature": "_active_builder()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "active_backend",
        "full_api_name": "active_backend",
        "api_description": "Get the backend of the currently active builder context.\n\nReturns:\n    Backend: The active backend in the currently active\n        builder context.\n\nRaises:\n    exceptions.BackendNotSet: If the builder does not have a backend set.",
        "api_signature": "active_backend()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "append_schedule",
        "full_api_name": "append_schedule",
        "api_description": "Call a schedule by appending to the active builder's context block.\n\nArgs:\n    schedule: Schedule or ScheduleBlock to append.",
        "api_signature": "append_schedule(schedule)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "append_instruction",
        "full_api_name": "append_instruction",
        "api_description": "Append an instruction to the active builder's context schedule.\n\nExamples:\n\n.. code-block::\n\n    from qiskit import pulse\n\n    d0 = pulse.DriveChannel(0)\n\n    with pulse.build() as pulse_prog:\n        pulse.builder.append_instruction(pulse.Delay(10, d0))\n\n    print(pulse_prog.instructions)\n\n.. parsed-literal::\n\n    ((0, Delay(10, DriveChannel(0))),)",
        "api_signature": "append_instruction(instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "num_qubits",
        "full_api_name": "num_qubits",
        "api_description": "Return number of qubits in the currently active backend.\n\nExamples:\n\n.. code-block::\n\n    from qiskit import pulse\n    from qiskit.providers.fake_provider import FakeOpenPulse2Q\n\n    backend = FakeOpenPulse2Q()\n\n    with pulse.build(backend):\n        print(pulse.num_qubits())\n\n.. parsed-literal::\n\n   2\n\n.. note:: Requires the active builder context to have a backend set.",
        "api_signature": "num_qubits()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "seconds_to_samples",
        "full_api_name": "seconds_to_samples",
        "api_description": "Obtain the number of samples that will elapse in ``seconds`` on the\nactive backend.\n\nRounds down.\n\nArgs:\n    seconds: Time in seconds to convert to samples.\n\nReturns:\n    The number of samples for the time to elapse",
        "api_signature": "seconds_to_samples(seconds)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "samples_to_seconds",
        "full_api_name": "samples_to_seconds",
        "api_description": "Obtain the time in seconds that will elapse for the input number of\nsamples on the active backend.\n\nArgs:\n    samples: Number of samples to convert to time in seconds.\n\nReturns:\n    The time that elapses in ``samples``.",
        "api_signature": "samples_to_seconds(samples)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "qubit_channels",
        "full_api_name": "qubit_channels",
        "api_description": "Returns the set of channels associated with a qubit.\n\nExamples:\n\n.. code-block::\n\n    from qiskit import pulse\n    from qiskit.providers.fake_provider import FakeOpenPulse2Q\n\n    backend = FakeOpenPulse2Q()\n\n    with pulse.build(backend):\n        print(pulse.qubit_channels(0))\n\n.. parsed-literal::\n\n   {MeasureChannel(0), ControlChannel(0), DriveChannel(0), AcquireChannel(0), ControlChannel(1)}\n\n.. note:: Requires the active builder context to have a backend set.\n\n.. note:: A channel may still be associated with another qubit in this list\n    such as in the case where significant crosstalk exists.",
        "api_signature": "qubit_channels(qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "get_qubit_channels_v2",
        "full_api_name": "get_qubit_channels_v2",
        "api_description": "Return a list of channels which operate on the given ``qubit``.\nReturns:\n    List of ``Channel``\\s operated on my the given ``qubit``.",
        "api_signature": "get_qubit_channels_v2(backend, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "_qubits_to_channels",
        "full_api_name": "_qubits_to_channels",
        "api_description": "Returns the unique channels of the input qubits.",
        "api_signature": "_qubits_to_channels()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "align_left",
        "full_api_name": "align_left",
        "api_description": "Left alignment pulse scheduling context.\n\nPulse instructions within this context are scheduled as early as possible\nby shifting them left to the earliest available time.\n\nExamples:\n\n.. code-block::\n\n    from qiskit import pulse\n\n    d0 = pulse.DriveChannel(0)\n    d1 = pulse.DriveChannel(1)\n\n    with pulse.build() as pulse_prog:\n        with pulse.align_left():\n            # this pulse will start at t=0\n            pulse.play(pulse.Constant(100, 1.0), d0)\n            # this pulse will start at t=0\n            pulse.play(pulse.Constant(20, 1.0), d1)\n    pulse_prog = pulse.transforms.block_to_schedule(pulse_prog)\n\n    assert pulse_prog.ch_start_time(d0) == pulse_prog.ch_start_time(d1)\n\nYields:\n    None",
        "api_signature": "align_left()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "align_right",
        "full_api_name": "align_right",
        "api_description": "Right alignment pulse scheduling context.\n\nPulse instructions within this context are scheduled as late as possible\nby shifting them right to the latest available time.\n\nExamples:\n\n.. code-block::\n\n    from qiskit import pulse\n\n    d0 = pulse.DriveChannel(0)\n    d1 = pulse.DriveChannel(1)\n\n    with pulse.build() as pulse_prog:\n        with pulse.align_right():\n            # this pulse will start at t=0\n            pulse.play(pulse.Constant(100, 1.0), d0)\n            # this pulse will start at t=80\n            pulse.play(pulse.Constant(20, 1.0), d1)\n    pulse_prog = pulse.transforms.block_to_schedule(pulse_prog)\n\n    assert pulse_prog.ch_stop_time(d0) == pulse_prog.ch_stop_time(d1)\n\nYields:\n    None",
        "api_signature": "align_right()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "align_sequential",
        "full_api_name": "align_sequential",
        "api_description": "Sequential alignment pulse scheduling context.\n\nPulse instructions within this context are scheduled sequentially in time\nsuch that no two instructions will be played at the same time.\n\nExamples:\n\n.. code-block::\n\n    from qiskit import pulse\n\n    d0 = pulse.DriveChannel(0)\n    d1 = pulse.DriveChannel(1)\n\n    with pulse.build() as pulse_prog:\n        with pulse.align_sequential():\n            # this pulse will start at t=0\n            pulse.play(pulse.Constant(100, 1.0), d0)\n            # this pulse will also start at t=100\n            pulse.play(pulse.Constant(20, 1.0), d1)\n    pulse_prog = pulse.transforms.block_to_schedule(pulse_prog)\n\n    assert pulse_prog.ch_stop_time(d0) == pulse_prog.ch_start_time(d1)\n\nYields:\n    None",
        "api_signature": "align_sequential()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "align_equispaced",
        "full_api_name": "align_equispaced",
        "api_description": "Equispaced alignment pulse scheduling context.\n\nPulse instructions within this context are scheduled with the same interval spacing such that\nthe total length of the context block is ``duration``.\nIf the total free ``duration`` cannot be evenly divided by the number of instructions\nwithin the context, the modulo is split and then prepended and appended to\nthe returned schedule. Delay instructions are automatically inserted in between pulses.\n\nThis context is convenient to write a schedule for periodical dynamic decoupling or\nthe Hahn echo sequence.\n\nExamples:\n\n.. plot::\n   :include-source:\n\n    from qiskit import pulse\n\n    d0 = pulse.DriveChannel(0)\n    x90 = pulse.Gaussian(10, 0.1, 3)\n    x180 = pulse.Gaussian(10, 0.2, 3)\n\n    with pulse.build() as hahn_echo:\n        with pulse.align_equispaced(duration=100):\n            pulse.play(x90, d0)\n            pulse.play(x180, d0)\n            pulse.play(x90, d0)\n\n    hahn_echo.draw()\n\nArgs:\n    duration: Duration of this context. This should be larger than the schedule duration.\n\nYields:\n    None\n\nNotes:\n    The scheduling is performed for sub-schedules within the context rather than\n    channel-wise. If you want to apply the equispaced context for each channel,\n    you should use the context independently for channels.",
        "api_signature": "align_equispaced(duration)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "align_func",
        "full_api_name": "align_func",
        "api_description": "Callback defined alignment pulse scheduling context.\n\nPulse instructions within this context are scheduled at the location specified by\narbitrary callback function `position` that takes integer index and returns\nthe associated fractional location within [0, 1].\nDelay instruction is automatically inserted in between pulses.\n\nThis context may be convenient to write a schedule of arbitrary dynamical decoupling\nsequences such as Uhrig dynamical decoupling.\n\nExamples:\n\n.. plot::\n   :include-source:\n\n    import numpy as np\n    from qiskit import pulse\n\n    d0 = pulse.DriveChannel(0)\n    x90 = pulse.Gaussian(10, 0.1, 3)\n    x180 = pulse.Gaussian(10, 0.2, 3)\n\n    def udd10_pos(j):\n        return np.sin(np.pi*j/(2*10 + 2))**2\n\n    with pulse.build() as udd_sched:\n        pulse.play(x90, d0)\n        with pulse.align_func(duration=300, func=udd10_pos):\n            for _ in range(10):\n                pulse.play(x180, d0)\n        pulse.play(x90, d0)\n\n    udd_sched.draw()\n\nArgs:\n    duration: Duration of context. This should be larger than the schedule duration.\n    func: A function that takes an index of sub-schedule and returns the\n        fractional coordinate of of that sub-schedule.\n        The returned value should be defined within [0, 1].\n        The pulse index starts from 1.\n\nYields:\n    None\n\nNotes:\n    The scheduling is performed for sub-schedules within the context rather than\n    channel-wise. If you want to apply the numerical context for each channel,\n    you need to apply the context independently to channels.",
        "api_signature": "align_func(duration, func)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "general_transforms",
        "full_api_name": "general_transforms",
        "api_description": "Arbitrary alignment transformation defined by a subclass instance of\n:class:`~qiskit.pulse.transforms.alignments.AlignmentKind`.\n\nArgs:\n    alignment_context: Alignment context instance that defines schedule transformation.\n\nYields:\n    None\n\nRaises:\n    PulseError: When input ``alignment_context`` is not ``AlignmentKind`` subclasses.",
        "api_signature": "general_transforms(alignment_context)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "phase_offset",
        "full_api_name": "phase_offset",
        "api_description": "Shift the phase of input channels on entry into context and undo on exit.\n\nExamples:\n\n.. code-block::\n\n    import math\n\n    from qiskit import pulse\n\n    d0 = pulse.DriveChannel(0)\n\n    with pulse.build() as pulse_prog:\n        with pulse.phase_offset(math.pi, d0):\n            pulse.play(pulse.Constant(10, 1.0), d0)\n\n    assert len(pulse_prog.instructions) == 3\n\nArgs:\n    phase: Amount of phase offset in radians.\n    channels: Channels to offset phase of.\n\nYields:\n    None",
        "api_signature": "phase_offset(phase)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "frequency_offset",
        "full_api_name": "frequency_offset",
        "api_description": "Shift the frequency of inputs channels on entry into context and undo on exit.\n\nExamples:\n\n.. code-block:: python\n    :emphasize-lines: 7, 16\n\n    from qiskit import pulse\n\n    d0 = pulse.DriveChannel(0)\n\n    with pulse.build(backend) as pulse_prog:\n        # shift frequency by 1GHz\n        with pulse.frequency_offset(1e9, d0):\n            pulse.play(pulse.Constant(10, 1.0), d0)\n\n    assert len(pulse_prog.instructions) == 3\n\n    with pulse.build(backend) as pulse_prog:\n        # Shift frequency by 1GHz.\n        # Undo accumulated phase in the shifted frequency frame\n        # when exiting the context.\n        with pulse.frequency_offset(1e9, d0, compensate_phase=True):\n            pulse.play(pulse.Constant(10, 1.0), d0)\n\n    assert len(pulse_prog.instructions) == 4\n\nArgs:\n    frequency: Amount of frequency offset in Hz.\n    channels: Channels to offset frequency of.\n    compensate_phase: Compensate for accumulated phase accumulated with\n        respect to the channels' frame at its initial frequency.\n\nYields:\n    None",
        "api_signature": "frequency_offset(frequency)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "drive_channel",
        "full_api_name": "drive_channel",
        "api_description": "Return ``DriveChannel`` for ``qubit`` on the active builder backend.\n\nExamples:\n\n.. code-block::\n\n    from qiskit import pulse\n    from qiskit.providers.fake_provider import FakeOpenPulse2Q\n\n    backend = FakeOpenPulse2Q()\n\n    with pulse.build(backend):\n        assert pulse.drive_channel(0) == pulse.DriveChannel(0)\n\n.. note:: Requires the active builder context to have a backend set.",
        "api_signature": "drive_channel(qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "measure_channel",
        "full_api_name": "measure_channel",
        "api_description": "Return ``MeasureChannel`` for ``qubit`` on the active builder backend.\n\nExamples:\n\n.. code-block::\n\n    from qiskit import pulse\n    from qiskit.providers.fake_provider import FakeOpenPulse2Q\n\n    backend = FakeOpenPulse2Q()\n\n    with pulse.build(backend):\n        assert pulse.measure_channel(0) == pulse.MeasureChannel(0)\n\n.. note:: Requires the active builder context to have a backend set.",
        "api_signature": "measure_channel(qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "acquire_channel",
        "full_api_name": "acquire_channel",
        "api_description": "Return ``AcquireChannel`` for ``qubit`` on the active builder backend.\n\nExamples:\n\n.. code-block::\n\n    from qiskit import pulse\n    from qiskit.providers.fake_provider import FakeOpenPulse2Q\n\n    backend = FakeOpenPulse2Q()\n\n    with pulse.build(backend):\n        assert pulse.acquire_channel(0) == pulse.AcquireChannel(0)\n\n.. note:: Requires the active builder context to have a backend set.",
        "api_signature": "acquire_channel(qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "control_channels",
        "full_api_name": "control_channels",
        "api_description": "Return ``ControlChannel`` for ``qubit`` on the active builder backend.\n\nReturn the secondary drive channel for the given qubit -- typically\nutilized for controlling multi-qubit interactions.\n\nExamples:\n\n.. code-block::\n\n    from qiskit import pulse\n    from qiskit.providers.fake_provider import FakeOpenPulse2Q\n\n    backend = FakeOpenPulse2Q()\n    with pulse.build(backend):\n        assert pulse.control_channels(0, 1) == [pulse.ControlChannel(0)]\n\n.. note:: Requires the active builder context to have a backend set.\n\nArgs:\n  qubits: Tuple or list of ordered qubits of the form\n    `(control_qubit, target_qubit)`.\n\nReturns:\n    List of control channels associated with the supplied ordered list\n    of qubits.",
        "api_signature": "control_channels()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "delay",
        "full_api_name": "delay",
        "api_description": "Delay on a ``channel`` for a ``duration``.\n\nExamples:\n\n.. code-block::\n\n    from qiskit import pulse\n\n    d0 = pulse.DriveChannel(0)\n\n    with pulse.build() as pulse_prog:\n        pulse.delay(10, d0)\n\nArgs:\n    duration: Number of cycles to delay for on ``channel``.\n    channel: Channel to delay on.\n    name: Name of the instruction.",
        "api_signature": "delay(duration, channel, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "play",
        "full_api_name": "play",
        "api_description": "Play a ``pulse`` on a ``channel``.\n\nExamples:\n\n.. code-block::\n\n    from qiskit import pulse\n\n    d0 = pulse.DriveChannel(0)\n\n    with pulse.build() as pulse_prog:\n        pulse.play(pulse.Constant(10, 1.0), d0)\n\nArgs:\n    pulse: Pulse to play.\n    channel: Channel to play pulse on.\n    name: Name of the pulse.",
        "api_signature": "play(pulse, channel, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "acquire",
        "full_api_name": "acquire",
        "api_description": "Acquire for a ``duration`` on a ``channel`` and store the result\nin a ``register``.\n\nExamples:\n\n.. code-block::\n\n    from qiskit import pulse\n\n    acq0 = pulse.AcquireChannel(0)\n    mem0 = pulse.MemorySlot(0)\n\n    with pulse.build() as pulse_prog:\n        pulse.acquire(100, acq0, mem0)\n\n        # measurement metadata\n        kernel = pulse.configuration.Kernel('linear_discriminator')\n        pulse.acquire(100, acq0, mem0, kernel=kernel)\n\n.. note:: The type of data acquire will depend on the execution ``meas_level``.\n\nArgs:\n    duration: Duration to acquire data for\n    qubit_or_channel: Either the qubit to acquire data for or the specific\n        :class:`~qiskit.pulse.channels.AcquireChannel` to acquire on.\n    register: Location to store measured result.\n    metadata: Additional metadata for measurement. See\n        :class:`~qiskit.pulse.instructions.Acquire` for more information.\n\nRaises:\n    exceptions.PulseError: If the register type is not supported.",
        "api_signature": "acquire(duration, qubit_or_channel, register)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "set_frequency",
        "full_api_name": "set_frequency",
        "api_description": "Set the ``frequency`` of a pulse ``channel``.\n\nExamples:\n\n.. code-block::\n\n    from qiskit import pulse\n\n    d0 = pulse.DriveChannel(0)\n\n    with pulse.build() as pulse_prog:\n        pulse.set_frequency(1e9, d0)\n\nArgs:\n    frequency: Frequency in Hz to set channel to.\n    channel: Channel to set frequency of.\n    name: Name of the instruction.",
        "api_signature": "set_frequency(frequency, channel, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "shift_frequency",
        "full_api_name": "shift_frequency",
        "api_description": "Shift the ``frequency`` of a pulse ``channel``.\n\nExamples:\n\n.. code-block:: python\n    :emphasize-lines: 6\n\n    from qiskit import pulse\n\n    d0 = pulse.DriveChannel(0)\n\n    with pulse.build() as pulse_prog:\n        pulse.shift_frequency(1e9, d0)\n\nArgs:\n    frequency: Frequency in Hz to shift channel frequency by.\n    channel: Channel to shift frequency of.\n    name: Name of the instruction.",
        "api_signature": "shift_frequency(frequency, channel, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "set_phase",
        "full_api_name": "set_phase",
        "api_description": "Set the ``phase`` of a pulse ``channel``.\n\nExamples:\n\n.. code-block:: python\n    :emphasize-lines: 8\n\n    import math\n\n    from qiskit import pulse\n\n    d0 = pulse.DriveChannel(0)\n\n    with pulse.build() as pulse_prog:\n        pulse.set_phase(math.pi, d0)\n\nArgs:\n    phase: Phase in radians to set channel carrier signal to.\n    channel: Channel to set phase of.\n    name: Name of the instruction.",
        "api_signature": "set_phase(phase, channel, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "shift_phase",
        "full_api_name": "shift_phase",
        "api_description": "Shift the ``phase`` of a pulse ``channel``.\n\nExamples:\n\n.. code-block::\n\n    import math\n\n    from qiskit import pulse\n\n    d0 = pulse.DriveChannel(0)\n\n    with pulse.build() as pulse_prog:\n        pulse.shift_phase(math.pi, d0)\n\nArgs:\n    phase: Phase in radians to shift channel carrier signal by.\n    channel: Channel to shift phase of.\n    name: Name of the instruction.",
        "api_signature": "shift_phase(phase, channel, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "snapshot",
        "full_api_name": "snapshot",
        "api_description": "Simulator snapshot.\n\nExamples:\n\n.. code-block::\n\n    from qiskit import pulse\n\n    with pulse.build() as pulse_prog:\n        pulse.snapshot('first', 'statevector')\n\nArgs:\n    label: Label for snapshot.\n    snapshot_type: Type of snapshot.",
        "api_signature": "snapshot(label, snapshot_type)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "call",
        "full_api_name": "call",
        "api_description": "Call the subroutine within the currently active builder context with arbitrary\nparameters which will be assigned to the target program.\n\n.. note::\n\n    If the ``target`` program is a :class:`.ScheduleBlock`, then a :class:`.Reference`\n    instruction will be created and appended to the current context.\n    The ``target`` program will be immediately assigned to the current scope as a subroutine.\n    If the ``target`` program is :class:`.Schedule`, it will be wrapped by the\n    :class:`.Call` instruction and appended to the current context to avoid\n    a mixed representation of :class:`.ScheduleBlock` and :class:`.Schedule`.\n    If the ``target`` program is a :class:`.QuantumCircuit` it will be scheduled\n    and the new :class:`.Schedule` will be added as a :class:`.Call` instruction.\n\nExamples:\n\n    1. Calling a schedule block (recommended)\n\n    .. code-block::\n\n        from qiskit import circuit, pulse\n        from qiskit.providers.fake_provider import GenericBackendV2\n\n        backend = GenericBackendV2(num_qubits=5, calibrate_instructions=True)\n\n        with pulse.build() as x_sched:\n            pulse.play(pulse.Gaussian(160, 0.1, 40), pulse.DriveChannel(0))\n\n        with pulse.build() as pulse_prog:\n            pulse.call(x_sched)\n\n        print(pulse_prog)\n\n    .. parsed-literal::\n\n        ScheduleBlock(\n            ScheduleBlock(\n                Play(\n                    Gaussian(duration=160, amp=(0.1+0j), sigma=40),\n                    DriveChannel(0)\n                ),\n                name=\"block0\",\n                transform=AlignLeft()\n            ),\n            name=\"block1\",\n            transform=AlignLeft()\n        )\n\n    The actual program is stored in the reference table attached to the schedule.\n\n    .. code-block::\n\n        print(pulse_prog.references)\n\n    .. parsed-literal::\n\n        ReferenceManager:\n          - ('block0', '634b3b50bd684e26a673af1fbd2d6c81'): ScheduleBlock(Play(Gaussian(...\n\n    In addition, you can call a parameterized target program with parameter assignment.\n\n    .. code-block::\n\n        amp = circuit.Parameter(\"amp\")\n\n        with pulse.build() as subroutine:\n            pulse.play(pulse.Gaussian(160, amp, 40), pulse.DriveChannel(0))\n\n        with pulse.build() as pulse_prog:\n            pulse.call(subroutine, amp=0.1)\n            pulse.call(subroutine, amp=0.3)\n\n        print(pulse_prog)\n\n    .. parsed-literal::\n\n        ScheduleBlock(\n            ScheduleBlock(\n                Play(\n                    Gaussian(duration=160, amp=(0.1+0j), sigma=40),\n                    DriveChannel(0)\n                ),\n                name=\"block2\",\n                transform=AlignLeft()\n            ),\n            ScheduleBlock(\n                Play(\n                    Gaussian(duration=160, amp=(0.3+0j), sigma=40),\n                    DriveChannel(0)\n                ),\n                name=\"block2\",\n                transform=AlignLeft()\n            ),\n            name=\"block3\",\n            transform=AlignLeft()\n        )\n\n    If there is a name collision between parameters, you can distinguish them by specifying\n    each parameter object in a python dictionary. For example,\n\n    .. code-block::\n\n        amp1 = circuit.Parameter('amp')\n        amp2 = circuit.Parameter('amp')\n\n        with pulse.build() as subroutine:\n            pulse.play(pulse.Gaussian(160, amp1, 40), pulse.DriveChannel(0))\n            pulse.play(pulse.Gaussian(160, amp2, 40), pulse.DriveChannel(1))\n\n        with pulse.build() as pulse_prog:\n            pulse.call(subroutine, value_dict={amp1: 0.1, amp2: 0.3})\n\n        print(pulse_prog)\n\n    .. parsed-literal::\n\n        ScheduleBlock(\n            ScheduleBlock(\n                Play(Gaussian(duration=160, amp=(0.1+0j), sigma=40), DriveChannel(0)),\n                Play(Gaussian(duration=160, amp=(0.3+0j), sigma=40), DriveChannel(1)),\n                name=\"block4\",\n                transform=AlignLeft()\n            ),\n            name=\"block5\",\n            transform=AlignLeft()\n        )\n\n    2. Calling a schedule\n\n    .. code-block::\n\n        x_sched = backend.instruction_schedule_map.get(\"x\", (0,))\n\n        with pulse.build(backend) as pulse_prog:\n            pulse.call(x_sched)\n\n        print(pulse_prog)\n\n    .. parsed-literal::\n\n        ScheduleBlock(\n            Call(\n                Schedule(\n                    (\n                        0,\n                        Play(\n                            Drag(\n                                duration=160,\n                                amp=(0.18989731546729305+0j),\n                                sigma=40,\n                                beta=-1.201258305015517,\n                                name='drag_86a8'\n                            ),\n                            DriveChannel(0),\n                            name='drag_86a8'\n                        )\n                    ),\n                    name=\"x\"\n                ),\n                name='x'\n            ),\n            name=\"block6\",\n            transform=AlignLeft()\n        )\n\n    Currently, the backend calibrated gates are provided in the form of :class:`~.Schedule`.\n    The parameter assignment mechanism is available also for schedules.\n    However, the called schedule is not treated as a reference.\n\n\nArgs:\n    target: Target circuit or pulse schedule to call.\n    name: Optional. A unique name of subroutine if defined. When the name is explicitly\n        provided, one cannot call different schedule blocks with the same name.\n    value_dict: Optional. Parameters assigned to the ``target`` program.\n        If this dictionary is provided, the ``target`` program is copied and\n        then stored in the main built schedule and its parameters are assigned to the given values.\n        This dictionary is keyed on :class:`~.Parameter` objects,\n        allowing parameter name collision to be avoided.\n    kw_params: Alternative way to provide parameters.\n        Since this is keyed on the string parameter name,\n        the parameters having the same name are all updated together.\n        If you want to avoid name collision, use ``value_dict`` with :class:`~.Parameter`\n        objects instead.",
        "api_signature": "call(target, name, value_dict)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "reference",
        "full_api_name": "reference",
        "api_description": "Refer to undefined subroutine by string keys.\n\nA :class:`~qiskit.pulse.instructions.Reference` instruction is implicitly created\nand a schedule can be separately registered to the reference at a later stage.\n\n.. code-block:: python\n\n    from qiskit import pulse\n\n    with pulse.build() as main_prog:\n        pulse.reference(\"x_gate\", \"q0\")\n\n    with pulse.build() as subroutine:\n        pulse.play(pulse.Gaussian(160, 0.1, 40), pulse.DriveChannel(0))\n\n    main_prog.assign_references(subroutine_dict={(\"x_gate\", \"q0\"): subroutine})\n\nArgs:\n    name: Name of subroutine.\n    extra_keys: Helper keys to uniquely specify the subroutine.",
        "api_signature": "reference(name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "barrier",
        "full_api_name": "barrier",
        "api_description": "Barrier directive for a set of channels and qubits.\n\nThis directive prevents the compiler from moving instructions across\nthe barrier. Consider the case where we want to enforce that one pulse\nhappens after another on separate channels, this can be done with:\n\n.. code-block::\n\n    from qiskit import pulse\n    from qiskit.providers.fake_provider import FakeOpenPulse2Q\n\n    backend = FakeOpenPulse2Q()\n\n    d0 = pulse.DriveChannel(0)\n    d1 = pulse.DriveChannel(1)\n\n    with pulse.build(backend) as barrier_pulse_prog:\n        pulse.play(pulse.Constant(10, 1.0), d0)\n        pulse.barrier(d0, d1)\n        pulse.play(pulse.Constant(10, 1.0), d1)\n\nOf course this could have been accomplished with:\n\n.. code-block::\n\n    from qiskit.pulse import transforms\n\n    with pulse.build(backend) as aligned_pulse_prog:\n        with pulse.align_sequential():\n            pulse.play(pulse.Constant(10, 1.0), d0)\n            pulse.play(pulse.Constant(10, 1.0), d1)\n\n    barrier_pulse_prog = transforms.target_qobj_transform(barrier_pulse_prog)\n    aligned_pulse_prog = transforms.target_qobj_transform(aligned_pulse_prog)\n\n    assert barrier_pulse_prog == aligned_pulse_prog\n\nThe barrier allows the pulse compiler to take care of more advanced\nscheduling alignment operations across channels. For example\nin the case where we are calling an outside circuit or schedule and\nwant to align a pulse at the end of one call:\n\n.. code-block::\n\n    import math\n\n    d0 = pulse.DriveChannel(0)\n\n    with pulse.build(backend) as pulse_prog:\n        with pulse.align_right():\n            pulse.call(backend.defaults.instruction_schedule_map.get('x', (1,)))\n            # Barrier qubit 1 and d0.\n            pulse.barrier(1, d0)\n            # Due to barrier this will play before the gate on qubit 1.\n            pulse.play(pulse.Constant(10, 1.0), d0)\n            # This will end at the same time as the pulse above due to\n            # the barrier.\n            pulse.call(backend.defaults.instruction_schedule_map.get('x', (1,)))\n\n.. note:: Requires the active builder context to have a backend set if\n    qubits are barriered on.\n\nArgs:\n    channels_or_qubits: Channels or qubits to barrier.\n    name: Name for the barrier",
        "api_signature": "barrier()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "macro",
        "full_api_name": "macro",
        "api_description": "Wrap a Python function and activate the parent builder context at calling time.\n\nThis enables embedding Python functions as builder macros. This generates a new\n:class:`pulse.Schedule` that is embedded in the parent builder context with\nevery call of the decorated macro function. The decorated macro function will\nbehave as if the function code was embedded inline in the parent builder context\nafter parameter substitution.\n\n\nExamples:\n\n.. plot::\n   :include-source:\n\n    from qiskit import pulse\n\n    @pulse.macro\n    def measure(qubit: int):\n        pulse.play(pulse.GaussianSquare(16384, 256, 15872), pulse.measure_channel(qubit))\n        mem_slot = pulse.MemorySlot(qubit)\n        pulse.acquire(16384, pulse.acquire_channel(qubit), mem_slot)\n\n        return mem_slot\n\n    with pulse.build(backend=backend) as sched:\n        mem_slot = measure(0)\n        print(f\"Qubit measured into {mem_slot}\")\n\n    sched.draw()\n\n\nArgs:\n    func: The Python function to enable as a builder macro. There are no\n        requirements on the signature of the function, any calls to pulse\n        builder methods will be added to builder context the wrapped function\n        is called from.\n\nReturns:\n    Callable: The wrapped ``func``.",
        "api_signature": "macro(func)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "wrapper",
        "full_api_name": "wrapper",
        "api_description": "",
        "api_signature": "wrapper()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "measure",
        "full_api_name": "measure",
        "api_description": "Measure a qubit within the currently active builder context.\n\nAt the pulse level a measurement is composed of both a stimulus pulse and\nan acquisition instruction which tells the systems measurement unit to\nacquire data and process it. We provide this measurement macro to automate\nthe process for you, but if desired full control is still available with\n:func:`acquire` and :func:`play`.\n\nTo use the measurement it is as simple as specifying the qubit you wish to\nmeasure:\n\n.. code-block::\n\n    from qiskit import pulse\n    from qiskit.providers.fake_provider import FakeOpenPulse2Q\n\n    backend = FakeOpenPulse2Q()\n\n    qubit = 0\n\n    with pulse.build(backend) as pulse_prog:\n        # Do something to the qubit.\n        qubit_drive_chan = pulse.drive_channel(0)\n        pulse.play(pulse.Constant(100, 1.0), qubit_drive_chan)\n        # Measure the qubit.\n        reg = pulse.measure(qubit)\n\nFor now it is not possible to do much with the handle to ``reg`` but in the\nfuture we will support using this handle to a result register to build\nup ones program. It is also possible to supply this register:\n\n.. code-block::\n\n    with pulse.build(backend) as pulse_prog:\n        pulse.play(pulse.Constant(100, 1.0), qubit_drive_chan)\n        # Measure the qubit.\n        mem0 = pulse.MemorySlot(0)\n        reg = pulse.measure(qubit, mem0)\n\n    assert reg == mem0\n\n.. note:: Requires the active builder context to have a backend set.\n\nArgs:\n    qubits: Physical qubit to measure.\n    registers: Register to store result in. If not selected the current\n        behavior is to return the :class:`MemorySlot` with the same\n        index as ``qubit``. This register will be returned.\nReturns:\n    The ``register`` the qubit measurement result will be stored in.",
        "api_signature": "measure(qubits, registers)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "measure_all",
        "full_api_name": "measure_all",
        "api_description": "Measure all qubits within the currently active builder context.\n\nA simple macro function to measure all of the qubits in the device at the\nsame time. This is useful for handling device ``meas_map`` and single\nmeasurement constraints.\n\nExamples:\n\n.. code-block::\n\n    from qiskit import pulse\n    from qiskit.providers.fake_provider import FakeOpenPulse2Q\n\n    backend = FakeOpenPulse2Q()\n\n    with pulse.build(backend) as pulse_prog:\n        # Measure all qubits and return associated registers.\n        regs = pulse.measure_all()\n\n.. note::\n    Requires the active builder context to have a backend set.\n\nReturns:\n    The ``register``\\s the qubit measurement results will be stored in.",
        "api_signature": "measure_all()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "delay_qubits",
        "full_api_name": "delay_qubits",
        "api_description": "Insert delays on all the :class:`channels.Channel`\\s that correspond\nto the input ``qubits`` at the same time.\n\nExamples:\n\n.. code-block::\n\n    from qiskit import pulse\n    from qiskit.providers.fake_provider import FakeOpenPulse3Q\n\n    backend = FakeOpenPulse3Q()\n\n    with pulse.build(backend) as pulse_prog:\n        # Delay for 100 cycles on qubits 0, 1 and 2.\n        regs = pulse.delay_qubits(100, 0, 1, 2)\n\n.. note:: Requires the active builder context to have a backend set.\n\nArgs:\n    duration: Duration to delay for.\n    qubits: Physical qubits to delay on. Delays will be inserted based on\n        the channels returned by :func:`pulse.qubit_channels`.",
        "api_signature": "delay_qubits(duration)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/builder.py"
    },
    {
        "api_name": "unassigned",
        "full_api_name": "ReferenceManager.unassigned",
        "api_description": "Get the keys of unassigned references.\n\nReturns:\n    Tuple of reference keys.",
        "api_signature": "unassigned(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/reference_manager.py"
    },
    {
        "api_name": "__setitem__",
        "full_api_name": "ReferenceManager.__setitem__",
        "api_description": "",
        "api_signature": "__setitem__(self, key, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/reference_manager.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "ReferenceManager.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/reference_manager.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "ReferenceManager.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/reference_manager.py"
    },
    {
        "api_name": "measure",
        "full_api_name": "measure",
        "api_description": "Return a schedule which measures the requested qubits according to the given\ninstruction mapping and measure map, or by using the defaults provided by the backend.\n\n.. note::\n    This function internally dispatches schedule generation logic depending on input backend model.\n    For the :class:`.BackendV1`, it considers conventional :class:`.InstructionScheduleMap`\n    and utilizes the backend calibration defined for a group of qubits in the `meas_map`.\n    For the :class:`.BackendV2`, it assembles calibrations of single qubit measurement\n    defined in the backend target to build a composite measurement schedule for `qubits`.\n\nBy default, the measurement results for each qubit are trivially mapped to the qubit\nindex. This behavior is overridden by qubit_mem_slots. For instance, to measure\nqubit 0 into MemorySlot(1), qubit_mem_slots can be provided as {0: 1}.\n\nArgs:\n    qubits: List of qubits to be measured.\n    backend (Union[Backend, BaseBackend]): A backend instance, which contains\n        hardware-specific data required for scheduling.\n    inst_map: Mapping of circuit operations to pulse schedules. If None, defaults to the\n              ``instruction_schedule_map`` of ``backend``.\n    meas_map: List of sets of qubits that must be measured together. If None, defaults to\n              the ``meas_map`` of ``backend``.\n    qubit_mem_slots: Mapping of measured qubit index to classical bit index.\n    measure_name: Name of the measurement schedule.\n\nReturns:\n    A measurement schedule corresponding to the inputs provided.",
        "api_signature": "measure(qubits, backend, inst_map, meas_map, qubit_mem_slots, measure_name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/macros.py"
    },
    {
        "api_name": "_measure_v1",
        "full_api_name": "_measure_v1",
        "api_description": "Return a schedule which measures the requested qubits according to the given\ninstruction mapping and measure map, or by using the defaults provided by the backendV1.\n\nArgs:\n    qubits: List of qubits to be measured.\n    backend (Union[Backend, BaseBackend]): A backend instance, which contains\n        hardware-specific data required for scheduling.\n    inst_map: Mapping of circuit operations to pulse schedules. If None, defaults to the\n              ``instruction_schedule_map`` of ``backend``.\n    meas_map: List of sets of qubits that must be measured together. If None, defaults to\n              the ``meas_map`` of ``backend``.\n    qubit_mem_slots: Mapping of measured qubit index to classical bit index.\n    measure_name: Name of the measurement schedule.\nReturns:\n    A measurement schedule corresponding to the inputs provided.\nRaises:\n    PulseError: If both ``inst_map`` or ``meas_map``, and ``backend`` is None.",
        "api_signature": "_measure_v1(qubits, inst_map, meas_map, qubit_mem_slots, measure_name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/macros.py"
    },
    {
        "api_name": "_measure_v2",
        "full_api_name": "_measure_v2",
        "api_description": "Return a schedule which measures the requested qubits according to the given\ntarget and measure map, or by using the defaults provided by the backendV2.\n\nArgs:\n    qubits: List of qubits to be measured.\n    target: The :class:`~.Target` representing the target backend.\n    meas_map: List of sets of qubits that must be measured together.\n    qubit_mem_slots: Mapping of measured qubit index to classical bit index.\n    measure_name: Name of the measurement schedule.\n\nReturns:\n    A measurement schedule corresponding to the inputs provided.",
        "api_signature": "_measure_v2(qubits, target, meas_map, qubit_mem_slots, measure_name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/macros.py"
    },
    {
        "api_name": "measure_all",
        "full_api_name": "measure_all",
        "api_description": "Return a Schedule which measures all qubits of the given backend.\n\nArgs:\n    backend (Union[Backend, BaseBackend]): A backend instance, which contains\n        hardware-specific data required for scheduling.\n\nReturns:\n    A schedule corresponding to the inputs provided.",
        "api_signature": "measure_all(backend)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/macros.py"
    },
    {
        "api_name": "_schedule_remapping_memory_slot",
        "full_api_name": "_schedule_remapping_memory_slot",
        "api_description": "A helper function to overwrite MemorySlot index of :class:`.Acquire` instruction.\n\nArgs:\n    schedule: A measurement schedule.\n    qubit_mem_slots: Mapping of measured qubit index to classical bit index.\n\nReturns:\n    A measurement schedule with new memory slot index.",
        "api_signature": "_schedule_remapping_memory_slot(schedule, qubit_mem_slots)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/macros.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PulseExpression.__init__",
        "api_description": "Create new evaluator.\n\nArgs:\n    source: Expression of equation to evaluate.\n    partial_binding: Allow partial bind of parameters.\n\nRaises:\n    PulseError: When invalid string is specified.",
        "api_signature": "__init__(self, source, partial_binding)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parser.py"
    },
    {
        "api_name": "params",
        "full_api_name": "PulseExpression.params",
        "api_description": "Get parameters.\n\nReturns:\n    A list of parameters in sorted order.",
        "api_signature": "params(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parser.py"
    },
    {
        "api_name": "__call__",
        "full_api_name": "PulseExpression.__call__",
        "api_description": "Evaluate the expression with the given values of the expression's parameters.\n\nArgs:\n    *args: Variable length parameter list.\n    **kwargs: Arbitrary parameters.\n\nReturns:\n    Evaluated value.\n\nRaises:\n    PulseError: When parameters are not bound.",
        "api_signature": "__call__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parser.py"
    },
    {
        "api_name": "_match_ops",
        "full_api_name": "PulseExpression._match_ops",
        "api_description": "Helper method to apply operators.\n\nArgs:\n    opr: Operator of node.\n    opr_dict: Mapper from ast to operator.\n    *args: Arguments supplied to operator.\n\nReturns:\n    Evaluated value.\n\nRaises:\n    PulseError: When unsupported operation is specified.",
        "api_signature": "_match_ops(opr, opr_dict)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parser.py"
    },
    {
        "api_name": "visit_Expression",
        "full_api_name": "PulseExpression.visit_Expression",
        "api_description": "Evaluate children nodes of expression.\n\nArgs:\n    node: Expression to evaluate.\n\nReturns:\n    Evaluated value.",
        "api_signature": "visit_Expression(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parser.py"
    },
    {
        "api_name": "visit_Constant",
        "full_api_name": "PulseExpression.visit_Constant",
        "api_description": "Return constant value as it is.\n\nArgs:\n    node: Constant.\n\nReturns:\n    Input node.",
        "api_signature": "visit_Constant(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parser.py"
    },
    {
        "api_name": "visit_Name",
        "full_api_name": "PulseExpression.visit_Name",
        "api_description": "Evaluate name and return ast.Constant if it is bound.\n\nArgs:\n    node: Name to evaluate.\n\nReturns:\n    Evaluated value.\n\nRaises:\n    PulseError: When parameter value is not a number.",
        "api_signature": "visit_Name(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parser.py"
    },
    {
        "api_name": "visit_UnaryOp",
        "full_api_name": "PulseExpression.visit_UnaryOp",
        "api_description": "Evaluate unary operation and return ast.Constant if operand is bound.\n\nArgs:\n    node: Unary operation to evaluate.\n\nReturns:\n    Evaluated value.",
        "api_signature": "visit_UnaryOp(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parser.py"
    },
    {
        "api_name": "visit_BinOp",
        "full_api_name": "PulseExpression.visit_BinOp",
        "api_description": "Evaluate binary operation and return ast.Constant if operands are bound.\n\nArgs:\n    node: Binary operation to evaluate.\n\nReturns:\n    Evaluated value.",
        "api_signature": "visit_BinOp(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parser.py"
    },
    {
        "api_name": "visit_Call",
        "full_api_name": "PulseExpression.visit_Call",
        "api_description": "Evaluate function and return ast.Constant if all arguments are bound.\n\nArgs:\n    node: Function to evaluate.\n\nReturns:\n    Evaluated value.\n\nRaises:\n    PulseError: When unsupported or unsafe function is specified.",
        "api_signature": "visit_Call(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parser.py"
    },
    {
        "api_name": "generic_visit",
        "full_api_name": "PulseExpression.generic_visit",
        "api_description": "",
        "api_signature": "generic_visit(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parser.py"
    },
    {
        "api_name": "parse_string_expr",
        "full_api_name": "parse_string_expr",
        "api_description": "Safe parsing of string expression.\n\nArgs:\n    source: String expression to parse.\n    partial_binding: Allow partial bind of parameters.\n\nReturns:\n    PulseExpression: Returns a expression object.\n\nExample:\n\n    expr = 'P1 + P2 + P3'\n    parsed_expr = parse_string_expr(expr, partial_binding=True)\n\n    # create new PulseExpression\n    bound_two = parsed_expr(P1=1, P2=2)\n    # evaluate expression\n    value1 = bound_two(P3=3)\n    value2 = bound_two(P3=4)\n    value3 = bound_two(P3=5)",
        "api_signature": "parse_string_expr(source, partial_binding)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parser.py"
    },
    {
        "api_name": "_assert_nested_dict_equal",
        "full_api_name": "_assert_nested_dict_equal",
        "api_description": "",
        "api_signature": "_assert_nested_dict_equal(a, b)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/configuration.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Kernel.__init__",
        "api_description": "Create new kernel.\n\nArgs:\n    name: Name of kernel to be used\n    params: Any settings for kerneling.",
        "api_signature": "__init__(self, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/configuration.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "Kernel.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/configuration.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "Kernel.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/configuration.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Discriminator.__init__",
        "api_description": "Create new discriminator.\n\nArgs:\n    name: Name of discriminator to be used\n    params: Any settings for discrimination.",
        "api_signature": "__init__(self, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/configuration.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "Discriminator.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/configuration.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "Discriminator.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/configuration.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "LoRange.__init__",
        "api_description": "",
        "api_signature": "__init__(self, lower_bound, upper_bound)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/configuration.py"
    },
    {
        "api_name": "includes",
        "full_api_name": "LoRange.includes",
        "api_description": "Whether `lo_freq` is within the `LoRange`.\n\nArgs:\n    lo_freq: LO frequency to be validated\n\nReturns:\n    bool: True if lo_freq is included in this range, otherwise False",
        "api_signature": "includes(self, lo_freq)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/configuration.py"
    },
    {
        "api_name": "lower_bound",
        "full_api_name": "LoRange.lower_bound",
        "api_description": "Lower bound of the LO range",
        "api_signature": "lower_bound(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/configuration.py"
    },
    {
        "api_name": "upper_bound",
        "full_api_name": "LoRange.upper_bound",
        "api_description": "Upper bound of the LO range",
        "api_signature": "upper_bound(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/configuration.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "LoRange.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/configuration.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "LoRange.__eq__",
        "api_description": "Two LO ranges are the same if they are of the same type, and\nhave the same frequency range\n\nArgs:\n    other (LoRange): other LoRange\n\nReturns:\n    bool: are self and other equal.",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/configuration.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "LoConfig.__init__",
        "api_description": "Lo channel configuration data structure.\n\nArgs:\n    channel_los: Dictionary of mappings from configurable channel to lo\n    lo_ranges: Dictionary of mappings to be enforced from configurable channel to `LoRange`\n\nRaises:\n    PulseError: If channel is not configurable or set lo is out of range.",
        "api_signature": "__init__(self, channel_los, lo_ranges)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/configuration.py"
    },
    {
        "api_name": "add_lo",
        "full_api_name": "LoConfig.add_lo",
        "api_description": "Add a lo mapping for a channel.",
        "api_signature": "add_lo(self, channel, freq)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/configuration.py"
    },
    {
        "api_name": "add_lo_range",
        "full_api_name": "LoConfig.add_lo_range",
        "api_description": "Add lo range to configuration.\n\nArgs:\n    channel: Channel to add lo range for\n    lo_range: Lo range to add",
        "api_signature": "add_lo_range(self, channel, lo_range)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/configuration.py"
    },
    {
        "api_name": "check_lo",
        "full_api_name": "LoConfig.check_lo",
        "api_description": "Check that lo is valid for channel.\n\nArgs:\n    channel: Channel to validate lo for\n    freq: lo frequency\nRaises:\n    PulseError: If freq is outside of channels range\nReturns:\n    True if lo is valid for channel",
        "api_signature": "check_lo(self, channel, freq)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/configuration.py"
    },
    {
        "api_name": "channel_lo",
        "full_api_name": "LoConfig.channel_lo",
        "api_description": "Return channel lo.\n\nArgs:\n    channel: Channel to get lo for\nRaises:\n    PulseError: If channel is not configured\nReturns:\n    Lo of supplied channel if present",
        "api_signature": "channel_lo(self, channel)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/configuration.py"
    },
    {
        "api_name": "qubit_los",
        "full_api_name": "LoConfig.qubit_los",
        "api_description": "Returns dictionary mapping qubit channels (DriveChannel) to los.",
        "api_signature": "qubit_los(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/configuration.py"
    },
    {
        "api_name": "meas_los",
        "full_api_name": "LoConfig.meas_los",
        "api_description": "Returns dictionary mapping measure channels (MeasureChannel) to los.",
        "api_signature": "meas_los(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/configuration.py"
    },
    {
        "api_name": "visit",
        "full_api_name": "NodeVisitor.visit",
        "api_description": "Visit a node.",
        "api_signature": "visit(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parameter_manager.py"
    },
    {
        "api_name": "_get_visitor",
        "full_api_name": "NodeVisitor._get_visitor",
        "api_description": "A helper function to recursively investigate superclass visitor method.",
        "api_signature": "_get_visitor(self, node_class)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parameter_manager.py"
    },
    {
        "api_name": "visit_ScheduleBlock",
        "full_api_name": "NodeVisitor.visit_ScheduleBlock",
        "api_description": "Visit ``ScheduleBlock``. Recursively visit context blocks and overwrite.\n\n.. note:: ``ScheduleBlock`` can have parameters in blocks and its alignment.",
        "api_signature": "visit_ScheduleBlock(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parameter_manager.py"
    },
    {
        "api_name": "visit_Schedule",
        "full_api_name": "NodeVisitor.visit_Schedule",
        "api_description": "Visit ``Schedule``. Recursively visit schedule children and overwrite.",
        "api_signature": "visit_Schedule(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parameter_manager.py"
    },
    {
        "api_name": "generic_visit",
        "full_api_name": "NodeVisitor.generic_visit",
        "api_description": "Called if no explicit visitor function exists for a node.",
        "api_signature": "generic_visit(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parameter_manager.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ParameterSetter.__init__",
        "api_description": "",
        "api_signature": "__init__(self, param_map)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parameter_manager.py"
    },
    {
        "api_name": "visit_ScheduleBlock",
        "full_api_name": "ParameterSetter.visit_ScheduleBlock",
        "api_description": "Visit ``ScheduleBlock``. Recursively visit context blocks and overwrite.\n\n.. note:: ``ScheduleBlock`` can have parameters in blocks and its alignment.",
        "api_signature": "visit_ScheduleBlock(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parameter_manager.py"
    },
    {
        "api_name": "visit_Schedule",
        "full_api_name": "ParameterSetter.visit_Schedule",
        "api_description": "Visit ``Schedule``. Recursively visit schedule children and overwrite.",
        "api_signature": "visit_Schedule(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parameter_manager.py"
    },
    {
        "api_name": "visit_AlignmentKind",
        "full_api_name": "ParameterSetter.visit_AlignmentKind",
        "api_description": "Assign parameters to block's ``AlignmentKind`` specification.",
        "api_signature": "visit_AlignmentKind(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parameter_manager.py"
    },
    {
        "api_name": "visit_Instruction",
        "full_api_name": "ParameterSetter.visit_Instruction",
        "api_description": "Assign parameters to general pulse instruction.\n\n.. note:: All parametrized object should be stored in the operands.\n    Otherwise parameter cannot be detected.",
        "api_signature": "visit_Instruction(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parameter_manager.py"
    },
    {
        "api_name": "visit_Channel",
        "full_api_name": "ParameterSetter.visit_Channel",
        "api_description": "Assign parameters to ``Channel`` object.",
        "api_signature": "visit_Channel(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parameter_manager.py"
    },
    {
        "api_name": "visit_SymbolicPulse",
        "full_api_name": "ParameterSetter.visit_SymbolicPulse",
        "api_description": "Assign parameters to ``SymbolicPulse`` object.",
        "api_signature": "visit_SymbolicPulse(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parameter_manager.py"
    },
    {
        "api_name": "visit_Waveform",
        "full_api_name": "ParameterSetter.visit_Waveform",
        "api_description": "Assign parameters to ``Waveform`` object.\n\n.. node:: No parameter can be assigned to ``Waveform`` object.",
        "api_signature": "visit_Waveform(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parameter_manager.py"
    },
    {
        "api_name": "generic_visit",
        "full_api_name": "ParameterSetter.generic_visit",
        "api_description": "Assign parameters to object that doesn't belong to Qiskit Pulse module.",
        "api_signature": "generic_visit(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parameter_manager.py"
    },
    {
        "api_name": "_assign_parameter_expression",
        "full_api_name": "ParameterSetter._assign_parameter_expression",
        "api_description": "A helper function to assign parameter value to parameter expression.",
        "api_signature": "_assign_parameter_expression(self, param_expr)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parameter_manager.py"
    },
    {
        "api_name": "_update_parameter_manager",
        "full_api_name": "ParameterSetter._update_parameter_manager",
        "api_description": "A helper function to update parameter manager of pulse program.",
        "api_signature": "_update_parameter_manager(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parameter_manager.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ParameterGetter.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parameter_manager.py"
    },
    {
        "api_name": "visit_ScheduleBlock",
        "full_api_name": "ParameterGetter.visit_ScheduleBlock",
        "api_description": "Visit ``ScheduleBlock``. Recursively visit context blocks and search parameters.\n\n.. note:: ``ScheduleBlock`` can have parameters in blocks and its alignment.",
        "api_signature": "visit_ScheduleBlock(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parameter_manager.py"
    },
    {
        "api_name": "visit_Schedule",
        "full_api_name": "ParameterGetter.visit_Schedule",
        "api_description": "Visit ``Schedule``. Recursively visit schedule children and search parameters.",
        "api_signature": "visit_Schedule(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parameter_manager.py"
    },
    {
        "api_name": "visit_AlignmentKind",
        "full_api_name": "ParameterGetter.visit_AlignmentKind",
        "api_description": "Get parameters from block's ``AlignmentKind`` specification.",
        "api_signature": "visit_AlignmentKind(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parameter_manager.py"
    },
    {
        "api_name": "visit_Instruction",
        "full_api_name": "ParameterGetter.visit_Instruction",
        "api_description": "Get parameters from general pulse instruction.\n\n.. note:: All parametrized object should be stored in the operands.\n    Otherwise, parameter cannot be detected.",
        "api_signature": "visit_Instruction(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parameter_manager.py"
    },
    {
        "api_name": "visit_Channel",
        "full_api_name": "ParameterGetter.visit_Channel",
        "api_description": "Get parameters from ``Channel`` object.",
        "api_signature": "visit_Channel(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parameter_manager.py"
    },
    {
        "api_name": "visit_SymbolicPulse",
        "full_api_name": "ParameterGetter.visit_SymbolicPulse",
        "api_description": "Get parameters from ``SymbolicPulse`` object.",
        "api_signature": "visit_SymbolicPulse(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parameter_manager.py"
    },
    {
        "api_name": "visit_Waveform",
        "full_api_name": "ParameterGetter.visit_Waveform",
        "api_description": "Get parameters from ``Waveform`` object.\n\n.. node:: No parameter can be assigned to ``Waveform`` object.",
        "api_signature": "visit_Waveform(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parameter_manager.py"
    },
    {
        "api_name": "generic_visit",
        "full_api_name": "ParameterGetter.generic_visit",
        "api_description": "Get parameters from object that doesn't belong to Qiskit Pulse module.",
        "api_signature": "generic_visit(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parameter_manager.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ParameterManager.__init__",
        "api_description": "Create new parameter table for pulse programs.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parameter_manager.py"
    },
    {
        "api_name": "parameters",
        "full_api_name": "ParameterManager.parameters",
        "api_description": "Parameters which determine the schedule behavior.",
        "api_signature": "parameters(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parameter_manager.py"
    },
    {
        "api_name": "clear",
        "full_api_name": "ParameterManager.clear",
        "api_description": "Remove the parameters linked to this manager.",
        "api_signature": "clear(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parameter_manager.py"
    },
    {
        "api_name": "is_parameterized",
        "full_api_name": "ParameterManager.is_parameterized",
        "api_description": "Return True iff the instruction is parameterized.",
        "api_signature": "is_parameterized(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parameter_manager.py"
    },
    {
        "api_name": "get_parameters",
        "full_api_name": "ParameterManager.get_parameters",
        "api_description": "Get parameter object bound to this schedule by string name.\n\nBecause different ``Parameter`` objects can have the same name,\nthis method returns a list of ``Parameter`` s for the provided name.\n\nArgs:\n    parameter_name: Name of parameter.\n\nReturns:\n    Parameter objects that have corresponding name.",
        "api_signature": "get_parameters(self, parameter_name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parameter_manager.py"
    },
    {
        "api_name": "assign_parameters",
        "full_api_name": "ParameterManager.assign_parameters",
        "api_description": "Modify and return program data with parameters assigned according to the input.\n\nArgs:\n    pulse_program: Arbitrary pulse program associated with this manager instance.\n    value_dict: A mapping from Parameters to either numeric values or another\n        Parameter expression.\n\nReturns:\n    Updated program data.",
        "api_signature": "assign_parameters(self, pulse_program, value_dict)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parameter_manager.py"
    },
    {
        "api_name": "update_parameter_table",
        "full_api_name": "ParameterManager.update_parameter_table",
        "api_description": "A helper function to update parameter table with given data node.\n\nArgs:\n    new_node: A new data node to be added.",
        "api_signature": "update_parameter_table(self, new_node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parameter_manager.py"
    },
    {
        "api_name": "_unroll_param_dict",
        "full_api_name": "ParameterManager._unroll_param_dict",
        "api_description": "Unroll parameter dictionary to a map from parameter to value.\n\nArgs:\n    parameter_binds: A dictionary from parameter to value or a list of values.\n\nReturns:\n    A dictionary from parameter to value.",
        "api_signature": "_unroll_param_dict(self, parameter_binds)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/parameter_manager.py"
    },
    {
        "api_name": "__new__",
        "full_api_name": "Channel.__new__",
        "api_description": "",
        "api_signature": "__new__(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/channels.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Channel.__init__",
        "api_description": "Channel class.\n\nArgs:\n    index: Index of channel.",
        "api_signature": "__init__(self, index)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/channels.py"
    },
    {
        "api_name": "index",
        "full_api_name": "Channel.index",
        "api_description": "Return the index of this channel. The index is a label for a control signal line\ntypically mapped trivially to a qubit index. For instance, ``DriveChannel(0)`` labels\nthe signal line driving the qubit labeled with index 0.",
        "api_signature": "index(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/channels.py"
    },
    {
        "api_name": "_validate_index",
        "full_api_name": "Channel._validate_index",
        "api_description": "Raise a PulseError if the channel index is invalid, namely, if it's not a positive\ninteger.\n\nRaises:\n    PulseError: If ``index`` is not a nonnegative integer.",
        "api_signature": "_validate_index(self, index)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/channels.py"
    },
    {
        "api_name": "parameters",
        "full_api_name": "Channel.parameters",
        "api_description": "Parameters which determine the channel index.",
        "api_signature": "parameters(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/channels.py"
    },
    {
        "api_name": "is_parameterized",
        "full_api_name": "Channel.is_parameterized",
        "api_description": "Return True iff the channel is parameterized.",
        "api_signature": "is_parameterized(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/channels.py"
    },
    {
        "api_name": "name",
        "full_api_name": "Channel.name",
        "api_description": "Return the shorthand alias for this channel, which is based on its type and index.",
        "api_signature": "name(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/channels.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "Channel.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/channels.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "Channel.__eq__",
        "api_description": "Return True iff self and other are equal, specifically, iff they have the same type\nand the same index.\n\nArgs:\n    other: The channel to compare to this channel.\n\nReturns:\n    True iff equal.",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/channels.py"
    },
    {
        "api_name": "__hash__",
        "full_api_name": "Channel.__hash__",
        "api_description": "",
        "api_signature": "__hash__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/channels.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SnapshotChannel.__init__",
        "api_description": "Create new snapshot channel.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/channels.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Schedule.__init__",
        "api_description": "Create an empty schedule.\n\nArgs:\n    *schedules: Child Schedules of this parent Schedule. May either be passed as\n                the list of schedules, or a list of ``(start_time, schedule)`` pairs.\n    name: Name of this schedule. Defaults to an autogenerated string if not provided.\n    metadata: Arbitrary key value metadata to associate with the schedule. This gets\n        stored as free-form data in a dict in the\n        :attr:`~qiskit.pulse.Schedule.metadata` attribute. It will not be directly\n        used in the schedule.\nRaises:\n    TypeError: if metadata is not a dict.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "initialize_from",
        "full_api_name": "Schedule.initialize_from",
        "api_description": "Create new schedule object with metadata of another schedule object.\n\nArgs:\n    other_program: Qiskit program that provides metadata to new object.\n    name: Name of new schedule. Name of ``schedule`` is used by default.\n\nReturns:\n    New schedule object with name and metadata.\n\nRaises:\n    PulseError: When `other_program` does not provide necessary information.",
        "api_signature": "initialize_from(cls, other_program, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "name",
        "full_api_name": "Schedule.name",
        "api_description": "Name of this Schedule",
        "api_signature": "name(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "metadata",
        "full_api_name": "Schedule.metadata",
        "api_description": "The user provided metadata associated with the schedule.\n\nUser provided ``dict`` of metadata for the schedule.\nThe metadata contents do not affect the semantics of the program\nbut are used to influence the execution of the schedule. It is expected\nto be passed between all transforms of the schedule and that providers\nwill associate any schedule metadata with the results it returns from the\nexecution of that schedule.",
        "api_signature": "metadata(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "metadata",
        "full_api_name": "Schedule.metadata",
        "api_description": "Update the schedule metadata",
        "api_signature": "metadata(self, metadata)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "timeslots",
        "full_api_name": "Schedule.timeslots",
        "api_description": "Time keeping attribute.",
        "api_signature": "timeslots(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "duration",
        "full_api_name": "Schedule.duration",
        "api_description": "Duration of this schedule.",
        "api_signature": "duration(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "start_time",
        "full_api_name": "Schedule.start_time",
        "api_description": "Starting time of this schedule.",
        "api_signature": "start_time(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "stop_time",
        "full_api_name": "Schedule.stop_time",
        "api_description": "Stopping time of this schedule.",
        "api_signature": "stop_time(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "channels",
        "full_api_name": "Schedule.channels",
        "api_description": "Returns channels that this schedule uses.",
        "api_signature": "channels(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "children",
        "full_api_name": "Schedule.children",
        "api_description": "Return the child schedule components of this ``Schedule`` in the\norder they were added to the schedule.\n\nNotes:\n    Nested schedules are returned as-is. If you want to collect only instructions,\n    use :py:meth:`~Schedule.instructions` instead.\n\nReturns:\n    A tuple, where each element is a two-tuple containing the initial\n    scheduled time of each ``NamedValue`` and the component\n    itself.",
        "api_signature": "children(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "instructions",
        "full_api_name": "Schedule.instructions",
        "api_description": "Get the time-ordered instructions from self.",
        "api_signature": "instructions(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "key",
        "full_api_name": "Schedule.key",
        "api_description": "",
        "api_signature": "key(time_inst_pair)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "parameters",
        "full_api_name": "Schedule.parameters",
        "api_description": "Parameters which determine the schedule behavior.",
        "api_signature": "parameters(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "ch_duration",
        "full_api_name": "Schedule.ch_duration",
        "api_description": "Return the time of the end of the last instruction over the supplied channels.\n\nArgs:\n    *channels: Channels within ``self`` to include.",
        "api_signature": "ch_duration(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "ch_start_time",
        "full_api_name": "Schedule.ch_start_time",
        "api_description": "Return the time of the start of the first instruction over the supplied channels.\n\nArgs:\n    *channels: Channels within ``self`` to include.",
        "api_signature": "ch_start_time(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "ch_stop_time",
        "full_api_name": "Schedule.ch_stop_time",
        "api_description": "Return maximum start time over supplied channels.\n\nArgs:\n    *channels: Channels within ``self`` to include.",
        "api_signature": "ch_stop_time(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "_instructions",
        "full_api_name": "Schedule._instructions",
        "api_description": "Iterable for flattening Schedule tree.\n\nArgs:\n    time: Shifted time due to parent.\n\nYields:\n    Iterable[Tuple[int, Instruction]]: Tuple containing the time each\n        :class:`~qiskit.pulse.Instruction`\n        starts at and the flattened :class:`~qiskit.pulse.Instruction` s.",
        "api_signature": "_instructions(self, time)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "shift",
        "full_api_name": "Schedule.shift",
        "api_description": "Return a schedule shifted forward by ``time``.\n\nArgs:\n    time: Time to shift by.\n    name: Name of the new schedule. Defaults to the name of self.\n    inplace: Perform operation inplace on this schedule. Otherwise\n        return a new ``Schedule``.",
        "api_signature": "shift(self, time, name, inplace)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "_immutable_shift",
        "full_api_name": "Schedule._immutable_shift",
        "api_description": "Return a new schedule shifted forward by `time`.\n\nArgs:\n    time: Time to shift by\n    name: Name of the new schedule if call was mutable. Defaults to name of self",
        "api_signature": "_immutable_shift(self, time, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "_mutable_shift",
        "full_api_name": "Schedule._mutable_shift",
        "api_description": "Return this schedule shifted forward by `time`.\n\nArgs:\n    time: Time to shift by\n\nRaises:\n    PulseError: if ``time`` is not an integer.",
        "api_signature": "_mutable_shift(self, time)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "insert",
        "full_api_name": "Schedule.insert",
        "api_description": "Return a new schedule with ``schedule`` inserted into ``self`` at ``start_time``.\n\nArgs:\n    start_time: Time to insert the schedule.\n    schedule: Schedule to insert.\n    name: Name of the new schedule. Defaults to the name of self.\n    inplace: Perform operation inplace on this schedule. Otherwise\n        return a new ``Schedule``.",
        "api_signature": "insert(self, start_time, schedule, name, inplace)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "_mutable_insert",
        "full_api_name": "Schedule._mutable_insert",
        "api_description": "Mutably insert `schedule` into `self` at `start_time`.\n\nArgs:\n    start_time: Time to insert the second schedule.\n    schedule: Schedule to mutably insert.",
        "api_signature": "_mutable_insert(self, start_time, schedule)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "_immutable_insert",
        "full_api_name": "Schedule._immutable_insert",
        "api_description": "Return a new schedule with ``schedule`` inserted into ``self`` at ``start_time``.\nArgs:\n    start_time: Time to insert the schedule.\n    schedule: Schedule to insert.\n    name: Name of the new ``Schedule``. Defaults to name of ``self``.",
        "api_signature": "_immutable_insert(self, start_time, schedule, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "append",
        "full_api_name": "Schedule.append",
        "api_description": "Return a new schedule with ``schedule`` inserted at the maximum time over\nall channels shared between ``self`` and ``schedule``.\n\n.. math::\n\n    t = \\textrm{max}(\\texttt{x.stop_time} |\\texttt{x} \\in\n        \\texttt{self.channels} \\cap \\texttt{schedule.channels})\n\nArgs:\n    schedule: Schedule to be appended.\n    name: Name of the new ``Schedule``. Defaults to name of ``self``.\n    inplace: Perform operation inplace on this schedule. Otherwise\n        return a new ``Schedule``.",
        "api_signature": "append(self, schedule, name, inplace)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "filter",
        "full_api_name": "Schedule.filter",
        "api_description": "Return a new ``Schedule`` with only the instructions from this ``Schedule`` which pass\nthough the provided filters; i.e. an instruction will be retained iff every function in\n``filter_funcs`` returns ``True``, the instruction occurs on a channel type contained in\n``channels``, the instruction type is contained in ``instruction_types``, and the period\nover which the instruction operates is *fully* contained in one specified in\n``time_ranges`` or ``intervals``.\n\nIf no arguments are provided, ``self`` is returned.\n\nArgs:\n    filter_funcs: A list of Callables which take a (int, Union['Schedule', Instruction])\n        tuple and return a bool.\n    channels: For example, ``[DriveChannel(0), AcquireChannel(0)]``.\n    instruction_types: For example, ``[PulseInstruction, AcquireInstruction]``.\n    time_ranges: For example, ``[(0, 5), (6, 10)]``.\n    intervals: For example, ``[(0, 5), (6, 10)]``.\n    check_subroutine: Set `True` to individually filter instructions inside of a subroutine\n        defined by the :py:class:`~qiskit.pulse.instructions.Call` instruction.",
        "api_signature": "filter(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "exclude",
        "full_api_name": "Schedule.exclude",
        "api_description": "Return a ``Schedule`` with only the instructions from this Schedule *failing*\nat least one of the provided filters.\nThis method is the complement of :py:meth:`~Schedule.filter`, so that::\n\n    self.filter(args) | self.exclude(args) == self\n\nArgs:\n    filter_funcs: A list of Callables which take a (int, Union['Schedule', Instruction])\n        tuple and return a bool.\n    channels: For example, ``[DriveChannel(0), AcquireChannel(0)]``.\n    instruction_types: For example, ``[PulseInstruction, AcquireInstruction]``.\n    time_ranges: For example, ``[(0, 5), (6, 10)]``.\n    intervals: For example, ``[(0, 5), (6, 10)]``.\n    check_subroutine: Set `True` to individually filter instructions inside of a subroutine\n        defined by the :py:class:`~qiskit.pulse.instructions.Call` instruction.",
        "api_signature": "exclude(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "_add_timeslots",
        "full_api_name": "Schedule._add_timeslots",
        "api_description": "Update all time tracking within this schedule based on the given schedule.\n\nArgs:\n    time: The time to insert the schedule into self.\n    schedule: The schedule to insert into self.\n\nRaises:\n    PulseError: If timeslots overlap or an invalid start time is provided.",
        "api_signature": "_add_timeslots(self, time, schedule)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "_remove_timeslots",
        "full_api_name": "Schedule._remove_timeslots",
        "api_description": "Delete the timeslots if present for the respective schedule component.\n\nArgs:\n    time: The time to remove the timeslots for the ``schedule`` component.\n    schedule: The schedule to insert into self.\n\nRaises:\n    PulseError: If timeslots overlap or an invalid start time is provided.",
        "api_signature": "_remove_timeslots(self, time, schedule)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "_replace_timeslots",
        "full_api_name": "Schedule._replace_timeslots",
        "api_description": "Replace the timeslots of ``old`` if present with the timeslots of ``new``.\n\nArgs:\n    time: The time to remove the timeslots for the ``schedule`` component.\n    old: Instruction to replace.\n    new: Instruction to replace with.",
        "api_signature": "_replace_timeslots(self, time, old, new)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "_renew_timeslots",
        "full_api_name": "Schedule._renew_timeslots",
        "api_description": "Regenerate timeslots based on current instructions.",
        "api_signature": "_renew_timeslots(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "replace",
        "full_api_name": "Schedule.replace",
        "api_description": "Return a ``Schedule`` with the ``old`` instruction replaced with a ``new``\ninstruction.\n\nThe replacement matching is based on an instruction equality check.\n\n.. code-block::\n\n    from qiskit import pulse\n\n    d0 = pulse.DriveChannel(0)\n\n    sched = pulse.Schedule()\n\n    old = pulse.Play(pulse.Constant(100, 1.0), d0)\n    new = pulse.Play(pulse.Constant(100, 0.1), d0)\n\n    sched += old\n\n    sched = sched.replace(old, new)\n\n    assert sched == pulse.Schedule(new)\n\nOnly matches at the top-level of the schedule tree. If you wish to\nperform this replacement over all instructions in the schedule tree.\nFlatten the schedule prior to running::\n\n.. code-block::\n\n    sched = pulse.Schedule()\n\n    sched += pulse.Schedule(old)\n\n    sched = sched.flatten()\n\n    sched = sched.replace(old, new)\n\n    assert sched == pulse.Schedule(new)\n\nArgs:\n    old: Instruction to replace.\n    new: Instruction to replace with.\n    inplace: Replace instruction by mutably modifying this ``Schedule``.\n\nReturns:\n    The modified schedule with ``old`` replaced by ``new``.\n\nRaises:\n    PulseError: If the ``Schedule`` after replacements will has a timing overlap.",
        "api_signature": "replace(self, old, new, inplace)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "is_parameterized",
        "full_api_name": "Schedule.is_parameterized",
        "api_description": "Return True iff the instruction is parameterized.",
        "api_signature": "is_parameterized(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "assign_parameters",
        "full_api_name": "Schedule.assign_parameters",
        "api_description": "Assign the parameters in this schedule according to the input.\n\nArgs:\n    value_dict: A mapping from parameters or parameter names (parameter vector\n    or parameter vector name) to either numeric values (list of numeric values)\n    or another parameter expression (list of parameter expressions).\n    inplace: Set ``True`` to override this instance with new parameter.\n\nReturns:\n    Schedule with updated parameters.",
        "api_signature": "assign_parameters(self, value_dict, inplace)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "get_parameters",
        "full_api_name": "Schedule.get_parameters",
        "api_description": "Get parameter object bound to this schedule by string name.\n\nBecause different ``Parameter`` objects can have the same name,\nthis method returns a list of ``Parameter`` s for the provided name.\n\nArgs:\n    parameter_name: Name of parameter.\n\nReturns:\n    Parameter objects that have corresponding name.",
        "api_signature": "get_parameters(self, parameter_name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "__len__",
        "full_api_name": "Schedule.__len__",
        "api_description": "Return number of instructions in the schedule.",
        "api_signature": "__len__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "__add__",
        "full_api_name": "Schedule.__add__",
        "api_description": "Return a new schedule with ``other`` inserted within ``self`` at ``start_time``.",
        "api_signature": "__add__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "__or__",
        "full_api_name": "Schedule.__or__",
        "api_description": "Return a new schedule which is the union of `self` and `other`.",
        "api_signature": "__or__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "__lshift__",
        "full_api_name": "Schedule.__lshift__",
        "api_description": "Return a new schedule which is shifted forward by ``time``.",
        "api_signature": "__lshift__(self, time)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "Schedule.__eq__",
        "api_description": "Test if two Schedule are equal.\n\nEquality is checked by verifying there is an equal instruction at every time\nin ``other`` for every instruction in this ``Schedule``.\n\n.. warning::\n\n    This does not check for logical equivalency. Ie.,\n\n    ```python\n    >>> Delay(10, DriveChannel(0)) + Delay(10, DriveChannel(0))\n        == Delay(20, DriveChannel(0))\n    False\n    ```",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "Schedule.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "_require_schedule_conversion",
        "full_api_name": "_require_schedule_conversion",
        "api_description": "A method decorator to convert schedule block to pulse schedule.\n\nThis conversation is performed for backward compatibility only if all durations are assigned.",
        "api_signature": "_require_schedule_conversion(function)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "wrapper",
        "full_api_name": "wrapper",
        "api_description": "",
        "api_signature": "wrapper(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ScheduleBlock.__init__",
        "api_description": "Create an empty schedule block.\n\nArgs:\n    name: Name of this schedule. Defaults to an autogenerated string if not provided.\n    metadata: Arbitrary key value metadata to associate with the schedule. This gets\n        stored as free-form data in a dict in the\n        :attr:`~qiskit.pulse.ScheduleBlock.metadata` attribute. It will not be directly\n        used in the schedule.\n    alignment_context (AlignmentKind): ``AlignmentKind`` instance that manages\n        scheduling of instructions in this block.\n\nRaises:\n    TypeError: if metadata is not a dict.",
        "api_signature": "__init__(self, name, metadata, alignment_context)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "initialize_from",
        "full_api_name": "ScheduleBlock.initialize_from",
        "api_description": "Create new schedule object with metadata of another schedule object.\n\nArgs:\n    other_program: Qiskit program that provides metadata to new object.\n    name: Name of new schedule. Name of ``block`` is used by default.\n\nReturns:\n    New block object with name and metadata.\n\nRaises:\n    PulseError: When ``other_program`` does not provide necessary information.",
        "api_signature": "initialize_from(cls, other_program, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "name",
        "full_api_name": "ScheduleBlock.name",
        "api_description": "Return name of this schedule",
        "api_signature": "name(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "metadata",
        "full_api_name": "ScheduleBlock.metadata",
        "api_description": "The user provided metadata associated with the schedule.\n\nUser provided ``dict`` of metadata for the schedule.\nThe metadata contents do not affect the semantics of the program\nbut are used to influence the execution of the schedule. It is expected\nto be passed between all transforms of the schedule and that providers\nwill associate any schedule metadata with the results it returns from the\nexecution of that schedule.",
        "api_signature": "metadata(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "metadata",
        "full_api_name": "ScheduleBlock.metadata",
        "api_description": "Update the schedule metadata",
        "api_signature": "metadata(self, metadata)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "alignment_context",
        "full_api_name": "ScheduleBlock.alignment_context",
        "api_description": "Return alignment instance that allocates block component to generate schedule.",
        "api_signature": "alignment_context(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "is_schedulable",
        "full_api_name": "ScheduleBlock.is_schedulable",
        "api_description": "Return ``True`` if all durations are assigned.",
        "api_signature": "is_schedulable(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "duration",
        "full_api_name": "ScheduleBlock.duration",
        "api_description": "Duration of this schedule block.",
        "api_signature": "duration(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "channels",
        "full_api_name": "ScheduleBlock.channels",
        "api_description": "Returns channels that this schedule block uses.",
        "api_signature": "channels(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "instructions",
        "full_api_name": "ScheduleBlock.instructions",
        "api_description": "Get the time-ordered instructions from self.",
        "api_signature": "instructions(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "blocks",
        "full_api_name": "ScheduleBlock.blocks",
        "api_description": "Get the block elements added to self.\n\n.. note::\n\n    The sequence of elements is returned in order of addition. Because the first element is\n    schedule first, e.g. FIFO, the returned sequence is roughly time-ordered.\n    However, in the parallel alignment context, especially in\n    the as-late-as-possible scheduling, or :class:`.AlignRight` context,\n    the actual timing of when the instructions are issued is unknown until\n    the :class:`.ScheduleBlock` is scheduled and converted into a :class:`.Schedule`.",
        "api_signature": "blocks(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "parameters",
        "full_api_name": "ScheduleBlock.parameters",
        "api_description": "Return unassigned parameters with raw names.",
        "api_signature": "parameters(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "references",
        "full_api_name": "ScheduleBlock.references",
        "api_description": "Return a reference manager of the current scope.",
        "api_signature": "references(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "ch_duration",
        "full_api_name": "ScheduleBlock.ch_duration",
        "api_description": "Return the time of the end of the last instruction over the supplied channels.\n\nArgs:\n    *channels: Channels within ``self`` to include.",
        "api_signature": "ch_duration(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "append",
        "full_api_name": "ScheduleBlock.append",
        "api_description": "Return a new schedule block with ``block`` appended to the context block.\nThe execution time is automatically assigned when the block is converted into schedule.\n\nArgs:\n    block: ScheduleBlock to be appended.\n    name: Name of the new ``Schedule``. Defaults to name of ``self``.\n    inplace: Perform operation inplace on this schedule. Otherwise,\n        return a new ``Schedule``.\n\nReturns:\n    Schedule block with appended schedule.\n\nRaises:\n    PulseError: When invalid schedule type is specified.",
        "api_signature": "append(self, block, name, inplace)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "filter",
        "full_api_name": "ScheduleBlock.filter",
        "api_description": "Return a new ``ScheduleBlock`` with only the instructions from this ``ScheduleBlock``\nwhich pass though the provided filters; i.e. an instruction will be retained if\nevery function in ``filter_funcs`` returns ``True``, the instruction occurs on\na channel type contained in ``channels``, and the instruction type is contained\nin ``instruction_types``.\n\n.. warning::\n    Because ``ScheduleBlock`` is not aware of the execution time of\n    the context instructions, filtering out some instructions may\n    change the execution time of the remaining instructions.\n\nIf no arguments are provided, ``self`` is returned.\n\nArgs:\n    filter_funcs: A list of Callables which take a ``Instruction`` and return a bool.\n    channels: For example, ``[DriveChannel(0), AcquireChannel(0)]``.\n    instruction_types: For example, ``[PulseInstruction, AcquireInstruction]``.\n    check_subroutine: Set `True` to individually filter instructions inside a subroutine\n        defined by the :py:class:`~qiskit.pulse.instructions.Call` instruction.\n\nReturns:\n    ``ScheduleBlock`` consisting of instructions that matches with filtering condition.",
        "api_signature": "filter(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "exclude",
        "full_api_name": "ScheduleBlock.exclude",
        "api_description": "Return a new ``ScheduleBlock`` with only the instructions from this ``ScheduleBlock``\n*failing* at least one of the provided filters.\nThis method is the complement of :py:meth:`~ScheduleBlock.filter`, so that::\n\n    self.filter(args) + self.exclude(args) == self in terms of instructions included.\n\n.. warning::\n    Because ``ScheduleBlock`` is not aware of the execution time of\n    the context instructions, excluding some instructions may\n    change the execution time of the remaining instructions.\n\nArgs:\n    filter_funcs: A list of Callables which take a ``Instruction`` and return a bool.\n    channels: For example, ``[DriveChannel(0), AcquireChannel(0)]``.\n    instruction_types: For example, ``[PulseInstruction, AcquireInstruction]``.\n    check_subroutine: Set `True` to individually filter instructions inside of a subroutine\n        defined by the :py:class:`~qiskit.pulse.instructions.Call` instruction.\n\nReturns:\n    ``ScheduleBlock`` consisting of instructions that do not match with\n    at least one of filtering conditions.",
        "api_signature": "exclude(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "replace",
        "full_api_name": "ScheduleBlock.replace",
        "api_description": "Return a ``ScheduleBlock`` with the ``old`` component replaced with a ``new``\ncomponent.\n\nArgs:\n    old: Schedule block component to replace.\n    new: Schedule block component to replace with.\n    inplace: Replace instruction by mutably modifying this ``ScheduleBlock``.\n\nReturns:\n    The modified schedule block with ``old`` replaced by ``new``.",
        "api_signature": "replace(self, old, new, inplace)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "is_parameterized",
        "full_api_name": "ScheduleBlock.is_parameterized",
        "api_description": "Return True iff the instruction is parameterized.",
        "api_signature": "is_parameterized(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "is_referenced",
        "full_api_name": "ScheduleBlock.is_referenced",
        "api_description": "Return True iff the current schedule block contains reference to subroutine.",
        "api_signature": "is_referenced(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "assign_parameters",
        "full_api_name": "ScheduleBlock.assign_parameters",
        "api_description": "Assign the parameters in this schedule according to the input.\n\nArgs:\n    value_dict: A mapping from parameters or parameter names (parameter vector\n    or parameter vector name) to either numeric values (list of numeric values)\n    or another parameter expression (list of parameter expressions).\n    inplace: Set ``True`` to override this instance with new parameter.\n\nReturns:\n    Schedule with updated parameters.\n\nRaises:\n    PulseError: When the block is nested into another block.",
        "api_signature": "assign_parameters(self, value_dict, inplace)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "assign_references",
        "full_api_name": "ScheduleBlock.assign_references",
        "api_description": "Assign schedules to references.\n\nIt is only capable of assigning a schedule block to immediate references\nwhich are directly referred within the current scope.\nLet's see following example:\n\n.. code-block:: python\n\n    from qiskit import pulse\n\n    with pulse.build() as subroutine:\n        pulse.delay(10, pulse.DriveChannel(0))\n\n    with pulse.build() as sub_prog:\n        pulse.reference(\"A\")\n\n    with pulse.build() as main_prog:\n        pulse.reference(\"B\")\n\nIn above example, the ``main_prog`` can refer to the subroutine \"root::B\" and the\nreference of \"B\" to program \"A\", i.e., \"B::A\", is not defined in the root namespace.\nThis prevents breaking the reference \"root::B::A\" by the assignment of \"root::B\".\nFor example, if a user could indirectly assign \"root::B::A\" from the root program,\none can later assign another program to \"root::B\" that doesn't contain \"A\" within it.\nIn this situation, a reference \"root::B::A\" would still live in\nthe reference manager of the root.\nHowever, the subroutine \"root::B::A\" would no longer be used in the actual pulse program.\nTo assign subroutine \"A\" to ``nested_prog`` as a nested subprogram of ``main_prog``,\nyou must first assign \"A\" of the ``sub_prog``,\nand then assign the ``sub_prog`` to the ``main_prog``.\n\n.. code-block:: python\n\n    sub_prog.assign_references({(\"A\", ): nested_prog}, inplace=True)\n    main_prog.assign_references({(\"B\", ): sub_prog}, inplace=True)\n\nAlternatively, you can also write\n\n.. code-block:: python\n\n    main_prog.assign_references({(\"B\", ): sub_prog}, inplace=True)\n    main_prog.references[(\"B\", )].assign_references({\"A\": nested_prog}, inplace=True)\n\nHere :attr:`.references` returns a dict-like object, and you can\nmutably update the nested reference of the particular subroutine.\n\n.. note::\n\n    Assigned programs are deep-copied to prevent an unexpected update.\n\nArgs:\n    subroutine_dict: A mapping from reference key to schedule block of the subroutine.\n    inplace: Set ``True`` to override this instance with new subroutine.\n\nReturns:\n    Schedule block with assigned subroutine.\n\nRaises:\n    PulseError: When reference key is not defined in the current scope.",
        "api_signature": "assign_references(self, subroutine_dict, inplace)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "get_parameters",
        "full_api_name": "ScheduleBlock.get_parameters",
        "api_description": "Get parameter object bound to this schedule by string name.\n\nNote that we can define different parameter objects with the same name,\nbecause these different objects are identified by their unique uuid.\nFor example,\n\n.. code-block:: python\n\n    from qiskit import pulse, circuit\n\n    amp1 = circuit.Parameter(\"amp\")\n    amp2 = circuit.Parameter(\"amp\")\n\n    with pulse.build() as sub_prog:\n        pulse.play(pulse.Constant(100, amp1), pulse.DriveChannel(0))\n\n    with pulse.build() as main_prog:\n        pulse.call(sub_prog, name=\"sub\")\n        pulse.play(pulse.Constant(100, amp2), pulse.DriveChannel(0))\n\n    main_prog.get_parameters(\"amp\")\n\nThis returns a list of two parameters ``amp1`` and ``amp2``.\n\nArgs:\n    parameter_name: Name of parameter.\n\nReturns:\n    Parameter objects that have corresponding name.",
        "api_signature": "get_parameters(self, parameter_name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "__len__",
        "full_api_name": "ScheduleBlock.__len__",
        "api_description": "Return number of instructions in the schedule.",
        "api_signature": "__len__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "ScheduleBlock.__eq__",
        "api_description": "Test if two ScheduleBlocks are equal.\n\nEquality is checked by verifying there is an equal instruction at every time\nin ``other`` for every instruction in this ``ScheduleBlock``. This check is\nperformed by converting the instruction representation into directed acyclic graph,\nin which execution order of every instruction is evaluated correctly across all channels.\nAlso ``self`` and ``other`` should have the same alignment context.\n\n.. warning::\n\n    This does not check for logical equivalency. Ie.,\n\n    ```python\n    >>> Delay(10, DriveChannel(0)) + Delay(10, DriveChannel(0))\n        == Delay(20, DriveChannel(0))\n    False\n    ```",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "ScheduleBlock.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "__add__",
        "full_api_name": "ScheduleBlock.__add__",
        "api_description": "Return a new schedule with ``other`` inserted within ``self`` at ``start_time``.",
        "api_signature": "__add__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "_common_method",
        "full_api_name": "_common_method",
        "api_description": "A function decorator to attach the function to specified classes as a method.\n\n.. note:: For developer: A method attached through this decorator may hurt readability\n    of the codebase, because the method may not be detected by a code editor.\n    Thus, this decorator should be used to a limited extent, i.e. huge helper method.\n    By using this decorator wisely, we can reduce code maintenance overhead without\n    losing readability of the codebase.",
        "api_signature": "_common_method()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "decorator",
        "full_api_name": "decorator",
        "api_description": "",
        "api_signature": "decorator(method)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "wrapper",
        "full_api_name": "wrapper",
        "api_description": "",
        "api_signature": "wrapper()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "draw",
        "full_api_name": "draw",
        "api_description": "Plot the schedule.\n\nArgs:\n    style: Stylesheet options. This can be dictionary or preset stylesheet classes. See\n        :py:class:`~qiskit.visualization.pulse_v2.stylesheets.IQXStandard`,\n        :py:class:`~qiskit.visualization.pulse_v2.stylesheets.IQXSimple`, and\n        :py:class:`~qiskit.visualization.pulse_v2.stylesheets.IQXDebugging` for details of\n        preset stylesheets.\n    backend (Optional[BaseBackend]): Backend object to play the input pulse program.\n        If provided, the plotter may use to make the visualization hardware aware.\n    time_range: Set horizontal axis limit. Tuple ``(tmin, tmax)``.\n    time_unit: The unit of specified time range either ``dt`` or ``ns``.\n        The unit of `ns` is available only when ``backend`` object is provided.\n    disable_channels: A control property to show specific pulse channel.\n        Pulse channel instances provided as a list are not shown in the output image.\n    show_snapshot: Show snapshot instructions.\n    show_framechange: Show frame change instructions. The frame change represents\n        instructions that modulate phase or frequency of pulse channels.\n    show_waveform_info: Show additional information about waveforms such as their name.\n    plot_barrier: Show barrier lines.\n    plotter: Name of plotter API to generate an output image.\n        One of following APIs should be specified::\n\n            mpl2d: Matplotlib API for 2D image generation.\n                Matplotlib API to generate 2D image. Charts are placed along y axis with\n                vertical offset. This API takes matplotlib.axes.Axes as ``axis`` input.\n\n        ``axis`` and ``style`` kwargs may depend on the plotter.\n    axis: Arbitrary object passed to the plotter. If this object is provided,\n        the plotters use a given ``axis`` instead of internally initializing\n        a figure object. This object format depends on the plotter.\n        See plotter argument for details.\n    show_barrier: DEPRECATED. Show barrier lines.\n\nReturns:\n    Visualization output data.\n    The returned data type depends on the ``plotter``.\n    If matplotlib family is specified, this will be a ``matplotlib.pyplot.Figure`` data.",
        "api_signature": "draw(self, style, backend, time_range, time_unit, disable_channels, show_snapshot, show_framechange, show_waveform_info, plot_barrier, plotter, axis, show_barrier)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "_interval_index",
        "full_api_name": "_interval_index",
        "api_description": "Find the index of an interval.\n\nArgs:\n    intervals: A sorted list of non-overlapping Intervals.\n    interval: The interval for which the index into intervals will be found.\n\nReturns:\n    The index of the interval.\n\nRaises:\n    PulseError: If the interval does not exist.",
        "api_signature": "_interval_index(intervals, interval)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "_locate_interval_index",
        "full_api_name": "_locate_interval_index",
        "api_description": "Using binary search on start times, find an interval.\n\nArgs:\n    intervals: A sorted list of non-overlapping Intervals.\n    interval: The interval for which the index into intervals will be found.\n    index: A running tally of the index, for recursion. The user should not pass a value.\n\nReturns:\n    The index into intervals that new_interval would be inserted to maintain\n    a sorted list of intervals.",
        "api_signature": "_locate_interval_index(intervals, interval, index)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "_find_insertion_index",
        "full_api_name": "_find_insertion_index",
        "api_description": "Using binary search on start times, return the index into `intervals` where the new interval\nbelongs, or raise an error if the new interval overlaps with any existing ones.\nArgs:\n    intervals: A sorted list of non-overlapping Intervals.\n    new_interval: The interval for which the index into intervals will be found.\nReturns:\n    The index into intervals that new_interval should be inserted to maintain a sorted list\n    of intervals.\nRaises:\n    PulseError: If new_interval overlaps with the given intervals.",
        "api_signature": "_find_insertion_index(intervals, new_interval)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "_overlaps",
        "full_api_name": "_overlaps",
        "api_description": "Return True iff first and second overlap.\nNote: first.stop may equal second.start, since Interval stop times are exclusive.",
        "api_signature": "_overlaps(first, second)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "_check_nonnegative_timeslot",
        "full_api_name": "_check_nonnegative_timeslot",
        "api_description": "Test that a channel has no negative timeslots.\n\nRaises:\n    PulseError: If a channel timeslot is negative.",
        "api_signature": "_check_nonnegative_timeslot(timeslots)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "_get_timeslots",
        "full_api_name": "_get_timeslots",
        "api_description": "Generate timeslots from given schedule component.\n\nArgs:\n    schedule: Input schedule component.\n\nRaises:\n    PulseError: When invalid schedule type is specified.",
        "api_signature": "_get_timeslots(schedule)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "_get_references",
        "full_api_name": "_get_references",
        "api_description": "Recursively get reference instructions in the current scope.\n\nArgs:\n    block_elms: List of schedule block elements to investigate.\n\nReturns:\n    A set of unique reference instructions.",
        "api_signature": "_get_references(block_elms)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/schedule.py"
    },
    {
        "api_name": "filter_instructions",
        "full_api_name": "filter_instructions",
        "api_description": "A catch-TypeError function which will only get called if none of the other decorated\nfunctions, namely handle_schedule() and handle_scheduleblock(), handle the type passed.",
        "api_signature": "filter_instructions(sched, filters, negate, recurse_subroutines)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/filters.py"
    },
    {
        "api_name": "handle_schedule",
        "full_api_name": "handle_schedule",
        "api_description": "A filtering function that takes a schedule and returns a schedule consisting of\nfiltered instructions.\n\nArgs:\n    sched: A pulse schedule to be filtered.\n    filters: List of callback functions that take an instruction and return boolean.\n    negate: Set `True` to accept an instruction if a filter function returns `False`.\n        Otherwise the instruction is accepted when the filter function returns `False`.\n    recurse_subroutines: Set `True` to individually filter instructions inside of a subroutine\n        defined by the :py:class:`~qiskit.pulse.instructions.Call` instruction.\n\nReturns:\n    Filtered pulse schedule.",
        "api_signature": "handle_schedule(sched, filters, negate, recurse_subroutines)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/filters.py"
    },
    {
        "api_name": "handle_scheduleblock",
        "full_api_name": "handle_scheduleblock",
        "api_description": "A filtering function that takes a schedule_block and returns a schedule_block consisting of\nfiltered instructions.\n\nArgs:\n    sched_blk: A pulse schedule_block to be filtered.\n    filters: List of callback functions that take an instruction and return boolean.\n    negate: Set `True` to accept an instruction if a filter function returns `False`.\n        Otherwise the instruction is accepted when the filter function returns `False`.\n    recurse_subroutines: Set `True` to individually filter instructions inside of a subroutine\n        defined by the :py:class:`~qiskit.pulse.instructions.Call` instruction.\n\nReturns:\n    Filtered pulse schedule_block.",
        "api_signature": "handle_scheduleblock(sched_blk, filters, negate, recurse_subroutines)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/filters.py"
    },
    {
        "api_name": "apply_filters_to_insts_in_scheblk",
        "full_api_name": "apply_filters_to_insts_in_scheblk",
        "api_description": "",
        "api_signature": "apply_filters_to_insts_in_scheblk(blk)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/filters.py"
    },
    {
        "api_name": "composite_filter",
        "full_api_name": "composite_filter",
        "api_description": "A helper function to generate a list of filter functions based on\ntypical elements to be filtered.\n\nArgs:\n    channels: For example, ``[DriveChannel(0), AcquireChannel(0)]``.\n    instruction_types (Optional[Iterable[Type[qiskit.pulse.Instruction]]]): For example,\n        ``[PulseInstruction, AcquireInstruction]``.\n    time_ranges: For example, ``[(0, 5), (6, 10)]``.\n    intervals: For example, ``[(0, 5), (6, 10)]``.\n\nReturns:\n    List of filtering functions.",
        "api_signature": "composite_filter(channels, instruction_types, time_ranges, intervals)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/filters.py"
    },
    {
        "api_name": "with_channels",
        "full_api_name": "with_channels",
        "api_description": "Channel filter generator.\n\nArgs:\n    channels: List of channels to filter.\n\nReturns:\n    A callback function to filter channels.",
        "api_signature": "with_channels(channels)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/filters.py"
    },
    {
        "api_name": "channel_filter",
        "full_api_name": "channel_filter",
        "api_description": "A catch-TypeError function which will only get called if none of the other decorated\nfunctions, namely handle_numpyndarray() and handle_instruction(), handle the type passed.",
        "api_signature": "channel_filter(time_inst)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/filters.py"
    },
    {
        "api_name": "handle_numpyndarray",
        "full_api_name": "handle_numpyndarray",
        "api_description": "Filter channel.\n\nArgs:\n    time_inst (numpy.ndarray([int, Instruction])): Time\n\nReturns:\n    If instruction matches with condition.",
        "api_signature": "handle_numpyndarray(time_inst)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/filters.py"
    },
    {
        "api_name": "handle_instruction",
        "full_api_name": "handle_instruction",
        "api_description": "Filter channel.\n\nArgs:\n    inst: Instruction\n\nReturns:\n    If instruction matches with condition.",
        "api_signature": "handle_instruction(inst)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/filters.py"
    },
    {
        "api_name": "with_instruction_types",
        "full_api_name": "with_instruction_types",
        "api_description": "Instruction type filter generator.\n\nArgs:\n    types: List of instruction types to filter.\n\nReturns:\n    A callback function to filter instructions.",
        "api_signature": "with_instruction_types(types)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/filters.py"
    },
    {
        "api_name": "instruction_filter",
        "full_api_name": "instruction_filter",
        "api_description": "A catch-TypeError function which will only get called if none of the other decorated\nfunctions, namely handle_numpyndarray() and handle_instruction(), handle the type passed.",
        "api_signature": "instruction_filter(time_inst)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/filters.py"
    },
    {
        "api_name": "handle_numpyndarray",
        "full_api_name": "handle_numpyndarray",
        "api_description": "Filter instruction.\n\nArgs:\n    time_inst (numpy.ndarray([int, Instruction])): Time\n\nReturns:\n    If instruction matches with condition.",
        "api_signature": "handle_numpyndarray(time_inst)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/filters.py"
    },
    {
        "api_name": "handle_instruction",
        "full_api_name": "handle_instruction",
        "api_description": "Filter instruction.\n\nArgs:\n    inst: Instruction\n\nReturns:\n    If instruction matches with condition.",
        "api_signature": "handle_instruction(inst)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/filters.py"
    },
    {
        "api_name": "with_intervals",
        "full_api_name": "with_intervals",
        "api_description": "Interval filter generator.\n\nArgs:\n    ranges: List of intervals ``[t0, t1]`` to filter.\n\nReturns:\n    A callback function to filter intervals.",
        "api_signature": "with_intervals(ranges)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/filters.py"
    },
    {
        "api_name": "interval_filter",
        "full_api_name": "interval_filter",
        "api_description": "Filter interval.\nArgs:\n    time_inst (Tuple[int, Instruction]): Time\n\nReturns:\n    If instruction matches with condition.",
        "api_signature": "interval_filter(time_inst)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/filters.py"
    },
    {
        "api_name": "_if_scalar_cast_to_list",
        "full_api_name": "_if_scalar_cast_to_list",
        "api_description": "A helper function to create python list of input arguments.\n\nArgs:\n    to_list: Arbitrary object can be converted into a python list.\n\nReturns:\n    Python list of input object.",
        "api_signature": "_if_scalar_cast_to_list(to_list)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/filters.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Delay.__init__",
        "api_description": "Create a new delay instruction.\n\nNo other instruction may be scheduled within a ``Delay``.\n\nArgs:\n    duration: Length of time of the delay in terms of dt.\n    channel: The channel that will have the delay.\n    name: Name of the delay for display purposes.",
        "api_signature": "__init__(self, duration, channel, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/delay.py"
    },
    {
        "api_name": "channel",
        "full_api_name": "Delay.channel",
        "api_description": "Return the :py:class:`~qiskit.pulse.channels.Channel` that this instruction is\nscheduled on.",
        "api_signature": "channel(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/delay.py"
    },
    {
        "api_name": "channels",
        "full_api_name": "Delay.channels",
        "api_description": "Returns the channels that this schedule uses.",
        "api_signature": "channels(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/delay.py"
    },
    {
        "api_name": "duration",
        "full_api_name": "Delay.duration",
        "api_description": "Duration of this instruction.",
        "api_signature": "duration(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/delay.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Acquire.__init__",
        "api_description": "Create a new Acquire instruction.\n\nArgs:\n    duration: Length of time to acquire data in terms of dt.\n    channel: The channel that will acquire data.\n    mem_slot: The classical memory slot in which to store the classified readout result.\n    reg_slot: The fast-access register slot in which to store the classified readout\n              result for fast feedback.\n    kernel: A ``Kernel`` for integrating raw data.\n    discriminator: A ``Discriminator`` for discriminating kerneled IQ data into 0/1\n                   results.\n    name: Name of the instruction for display purposes.",
        "api_signature": "__init__(self, duration, channel, mem_slot, reg_slot, kernel, discriminator, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/acquire.py"
    },
    {
        "api_name": "_validate",
        "full_api_name": "Acquire._validate",
        "api_description": "Called after initialization to validate instruction data.\n\nRaises:\n    PulseError: If the input ``channel`` is not type :class:`AcquireChannel`.\n    PulseError: If the input ``mem_slot`` is not type :class:`MemorySlot`.\n    PulseError: If the input ``reg_slot`` is not type :class:`RegisterSlot`.\n    PulseError: When memory slot and register slot are both empty.",
        "api_signature": "_validate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/acquire.py"
    },
    {
        "api_name": "channel",
        "full_api_name": "Acquire.channel",
        "api_description": "Return the :py:class:`~qiskit.pulse.channels.Channel` that this instruction is\nscheduled on.",
        "api_signature": "channel(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/acquire.py"
    },
    {
        "api_name": "channels",
        "full_api_name": "Acquire.channels",
        "api_description": "Returns the channels that this schedule uses.",
        "api_signature": "channels(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/acquire.py"
    },
    {
        "api_name": "duration",
        "full_api_name": "Acquire.duration",
        "api_description": "Duration of this instruction.",
        "api_signature": "duration(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/acquire.py"
    },
    {
        "api_name": "kernel",
        "full_api_name": "Acquire.kernel",
        "api_description": "Return kernel settings.",
        "api_signature": "kernel(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/acquire.py"
    },
    {
        "api_name": "discriminator",
        "full_api_name": "Acquire.discriminator",
        "api_description": "Return discrimination settings.",
        "api_signature": "discriminator(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/acquire.py"
    },
    {
        "api_name": "acquire",
        "full_api_name": "Acquire.acquire",
        "api_description": "Acquire channel to acquire data. The ``AcquireChannel`` index maps trivially to\nqubit index.",
        "api_signature": "acquire(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/acquire.py"
    },
    {
        "api_name": "mem_slot",
        "full_api_name": "Acquire.mem_slot",
        "api_description": "The classical memory slot which will store the classified readout result.",
        "api_signature": "mem_slot(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/acquire.py"
    },
    {
        "api_name": "reg_slot",
        "full_api_name": "Acquire.reg_slot",
        "api_description": "The fast-access register slot which will store the classified readout result for\nfast-feedback computation.",
        "api_signature": "reg_slot(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/acquire.py"
    },
    {
        "api_name": "is_parameterized",
        "full_api_name": "Acquire.is_parameterized",
        "api_description": "Return True iff the instruction is parameterized.",
        "api_signature": "is_parameterized(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/acquire.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "Acquire.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/acquire.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SetFrequency.__init__",
        "api_description": "Creates a new set channel frequency instruction.\n\nArgs:\n    frequency: New frequency of the channel in Hz.\n    channel: The channel this instruction operates on.\n    name: Name of this set channel frequency instruction.",
        "api_signature": "__init__(self, frequency, channel, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/frequency.py"
    },
    {
        "api_name": "_validate",
        "full_api_name": "SetFrequency._validate",
        "api_description": "Called after initialization to validate instruction data.\n\nRaises:\n    PulseError: If the input ``channel`` is not type :class:`PulseChannel`.",
        "api_signature": "_validate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/frequency.py"
    },
    {
        "api_name": "frequency",
        "full_api_name": "SetFrequency.frequency",
        "api_description": "New frequency.",
        "api_signature": "frequency(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/frequency.py"
    },
    {
        "api_name": "channel",
        "full_api_name": "SetFrequency.channel",
        "api_description": "Return the :py:class:`~qiskit.pulse.channels.Channel` that this instruction is\nscheduled on.",
        "api_signature": "channel(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/frequency.py"
    },
    {
        "api_name": "channels",
        "full_api_name": "SetFrequency.channels",
        "api_description": "Returns the channels that this schedule uses.",
        "api_signature": "channels(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/frequency.py"
    },
    {
        "api_name": "duration",
        "full_api_name": "SetFrequency.duration",
        "api_description": "Duration of this instruction.",
        "api_signature": "duration(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/frequency.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ShiftFrequency.__init__",
        "api_description": "Creates a new shift frequency instruction.\n\nArgs:\n    frequency: Frequency shift of the channel in Hz.\n    channel: The channel this instruction operates on.\n    name: Name of this set channel frequency instruction.",
        "api_signature": "__init__(self, frequency, channel, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/frequency.py"
    },
    {
        "api_name": "_validate",
        "full_api_name": "ShiftFrequency._validate",
        "api_description": "Called after initialization to validate instruction data.\n\nRaises:\n    PulseError: If the input ``channel`` is not type :class:`PulseChannel`.",
        "api_signature": "_validate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/frequency.py"
    },
    {
        "api_name": "frequency",
        "full_api_name": "ShiftFrequency.frequency",
        "api_description": "Frequency shift from the set frequency.",
        "api_signature": "frequency(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/frequency.py"
    },
    {
        "api_name": "channel",
        "full_api_name": "ShiftFrequency.channel",
        "api_description": "Return the :py:class:`~qiskit.pulse.channels.Channel` that this instruction is\nscheduled on.",
        "api_signature": "channel(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/frequency.py"
    },
    {
        "api_name": "channels",
        "full_api_name": "ShiftFrequency.channels",
        "api_description": "Returns the channels that this schedule uses.",
        "api_signature": "channels(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/frequency.py"
    },
    {
        "api_name": "duration",
        "full_api_name": "ShiftFrequency.duration",
        "api_description": "Duration of this instruction.",
        "api_signature": "duration(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/frequency.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Reference.__init__",
        "api_description": "Create new reference.\n\nArgs:\n    name: Name of subroutine.\n    extra_keys: Optional. A set of string keys that may be necessary to\n        refer to a particular subroutine. For example, when we use\n        \"sx\" as a name to refer to the subroutine of an sx pulse,\n        this name might be used among schedules for different qubits.\n        In this example, you may specify \"q0\" in the extra keys\n        to distinguish the sx schedule for qubit 0 from others.\n        The user can use an arbitrary number of extra string keys to\n        uniquely determine the subroutine.",
        "api_signature": "__init__(self, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/reference.py"
    },
    {
        "api_name": "_validate",
        "full_api_name": "Reference._validate",
        "api_description": "Called after initialization to validate instruction data.\n\nRaises:\n    PulseError: When a key is not a string.\n    PulseError: When a key in ``ref_keys`` contains the scope delimiter.",
        "api_signature": "_validate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/reference.py"
    },
    {
        "api_name": "ref_keys",
        "full_api_name": "Reference.ref_keys",
        "api_description": "Returns unique key of the subroutine.",
        "api_signature": "ref_keys(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/reference.py"
    },
    {
        "api_name": "duration",
        "full_api_name": "Reference.duration",
        "api_description": "Duration of this instruction.",
        "api_signature": "duration(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/reference.py"
    },
    {
        "api_name": "channels",
        "full_api_name": "Reference.channels",
        "api_description": "Returns the channels that this schedule uses.",
        "api_signature": "channels(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/reference.py"
    },
    {
        "api_name": "parameters",
        "full_api_name": "Reference.parameters",
        "api_description": "Parameters which determine the instruction behavior.",
        "api_signature": "parameters(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/reference.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "Reference.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/reference.py"
    },
    {
        "api_name": "duration",
        "full_api_name": "Directive.duration",
        "api_description": "Duration of this instruction.",
        "api_signature": "duration(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/directives.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "RelativeBarrier.__init__",
        "api_description": "Create a relative barrier directive.\n\nThe barrier directive blocks instructions within the same schedule\nas the barrier on channels contained within this barrier from moving\nthrough the barrier in time.\n\nArgs:\n    channels: The channel that the barrier applies to.\n    name: Name of the directive for display purposes.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/directives.py"
    },
    {
        "api_name": "channels",
        "full_api_name": "RelativeBarrier.channels",
        "api_description": "Returns the channels that this schedule uses.",
        "api_signature": "channels(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/directives.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "RelativeBarrier.__eq__",
        "api_description": "Verify two barriers are equivalent.",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/directives.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "TimeBlockade.__init__",
        "api_description": "Create a time blockade directive.\n\nArgs:\n    duration: Length of time of the occupation in terms of dt.\n    channel: The channel that will be the occupied.\n    name: Name of the time blockade for display purposes.",
        "api_signature": "__init__(self, duration, channel, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/directives.py"
    },
    {
        "api_name": "_validate",
        "full_api_name": "TimeBlockade._validate",
        "api_description": "Called after initialization to validate instruction data.\n\nRaises:\n    PulseError: If the input ``duration`` is not integer value.",
        "api_signature": "_validate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/directives.py"
    },
    {
        "api_name": "channel",
        "full_api_name": "TimeBlockade.channel",
        "api_description": "Return the :py:class:`~qiskit.pulse.channels.Channel` that this instruction is\nscheduled on.",
        "api_signature": "channel(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/directives.py"
    },
    {
        "api_name": "channels",
        "full_api_name": "TimeBlockade.channels",
        "api_description": "Returns the channels that this schedule uses.",
        "api_signature": "channels(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/directives.py"
    },
    {
        "api_name": "duration",
        "full_api_name": "TimeBlockade.duration",
        "api_description": "Duration of this instruction.",
        "api_signature": "duration(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/directives.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Play.__init__",
        "api_description": "Create a new pulse instruction.\n\nArgs:\n    pulse: A pulse waveform description, such as\n           :py:class:`~qiskit.pulse.library.Waveform`.\n    channel: The channel to which the pulse is applied.\n    name: Name of the instruction for display purposes. Defaults to ``pulse.name``.",
        "api_signature": "__init__(self, pulse, channel, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/play.py"
    },
    {
        "api_name": "_validate",
        "full_api_name": "Play._validate",
        "api_description": "Called after initialization to validate instruction data.\n\nRaises:\n    PulseError: If pulse is not a Pulse type.\n    PulseError: If the input ``channel`` is not type :class:`PulseChannel`.",
        "api_signature": "_validate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/play.py"
    },
    {
        "api_name": "pulse",
        "full_api_name": "Play.pulse",
        "api_description": "A description of the samples that will be played.",
        "api_signature": "pulse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/play.py"
    },
    {
        "api_name": "channel",
        "full_api_name": "Play.channel",
        "api_description": "Return the :py:class:`~qiskit.pulse.channels.Channel` that this instruction is\nscheduled on.",
        "api_signature": "channel(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/play.py"
    },
    {
        "api_name": "channels",
        "full_api_name": "Play.channels",
        "api_description": "Returns the channels that this schedule uses.",
        "api_signature": "channels(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/play.py"
    },
    {
        "api_name": "duration",
        "full_api_name": "Play.duration",
        "api_description": "Duration of this instruction.",
        "api_signature": "duration(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/play.py"
    },
    {
        "api_name": "parameters",
        "full_api_name": "Play.parameters",
        "api_description": "Parameters which determine the instruction behavior.",
        "api_signature": "parameters(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/play.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ShiftPhase.__init__",
        "api_description": "Instantiate a shift phase instruction, increasing the output signal phase on ``channel``\nby ``phase`` [radians].\n\nArgs:\n    phase: The rotation angle in radians.\n    channel: The channel this instruction operates on.\n    name: Display name for this instruction.",
        "api_signature": "__init__(self, phase, channel, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/phase.py"
    },
    {
        "api_name": "_validate",
        "full_api_name": "ShiftPhase._validate",
        "api_description": "Called after initialization to validate instruction data.\n\nRaises:\n    PulseError: If the input ``channel`` is not type :class:`PulseChannel`.",
        "api_signature": "_validate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/phase.py"
    },
    {
        "api_name": "phase",
        "full_api_name": "ShiftPhase.phase",
        "api_description": "Return the rotation angle enacted by this instruction in radians.",
        "api_signature": "phase(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/phase.py"
    },
    {
        "api_name": "channel",
        "full_api_name": "ShiftPhase.channel",
        "api_description": "Return the :py:class:`~qiskit.pulse.channels.Channel` that this instruction is\nscheduled on.",
        "api_signature": "channel(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/phase.py"
    },
    {
        "api_name": "channels",
        "full_api_name": "ShiftPhase.channels",
        "api_description": "Returns the channels that this schedule uses.",
        "api_signature": "channels(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/phase.py"
    },
    {
        "api_name": "duration",
        "full_api_name": "ShiftPhase.duration",
        "api_description": "Duration of this instruction.",
        "api_signature": "duration(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/phase.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SetPhase.__init__",
        "api_description": "Instantiate a set phase instruction, setting the output signal phase on ``channel``\nto ``phase`` [radians].\n\nArgs:\n    phase: The rotation angle in radians.\n    channel: The channel this instruction operates on.\n    name: Display name for this instruction.",
        "api_signature": "__init__(self, phase, channel, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/phase.py"
    },
    {
        "api_name": "_validate",
        "full_api_name": "SetPhase._validate",
        "api_description": "Called after initialization to validate instruction data.\n\nRaises:\n    PulseError: If the input ``channel`` is not type :class:`PulseChannel`.",
        "api_signature": "_validate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/phase.py"
    },
    {
        "api_name": "phase",
        "full_api_name": "SetPhase.phase",
        "api_description": "Return the rotation angle enacted by this instruction in radians.",
        "api_signature": "phase(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/phase.py"
    },
    {
        "api_name": "channel",
        "full_api_name": "SetPhase.channel",
        "api_description": "Return the :py:class:`~qiskit.pulse.channels.Channel` that this instruction is\nscheduled on.",
        "api_signature": "channel(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/phase.py"
    },
    {
        "api_name": "channels",
        "full_api_name": "SetPhase.channels",
        "api_description": "Returns the channels that this schedule uses.",
        "api_signature": "channels(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/phase.py"
    },
    {
        "api_name": "duration",
        "full_api_name": "SetPhase.duration",
        "api_description": "Duration of this instruction.",
        "api_signature": "duration(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/phase.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Snapshot.__init__",
        "api_description": "Create new snapshot.\n\nArgs:\n    label: Snapshot label which is used to identify the snapshot in the output.\n    snapshot_type: Type of snapshot, e.g., \u201cstate\u201d (take a snapshot of the quantum state).\n                   The types of snapshots offered are defined by the simulator used.\n    name: Snapshot name which defaults to ``label``. This parameter is only for display\n          purposes and is not taken into account during comparison.",
        "api_signature": "__init__(self, label, snapshot_type, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/snapshot.py"
    },
    {
        "api_name": "_validate",
        "full_api_name": "Snapshot._validate",
        "api_description": "Called after initialization to validate instruction data.\n\nRaises:\n    PulseError: If snapshot label is invalid.",
        "api_signature": "_validate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/snapshot.py"
    },
    {
        "api_name": "label",
        "full_api_name": "Snapshot.label",
        "api_description": "Label of snapshot.",
        "api_signature": "label(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/snapshot.py"
    },
    {
        "api_name": "type",
        "full_api_name": "Snapshot.type",
        "api_description": "Type of snapshot.",
        "api_signature": "type(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/snapshot.py"
    },
    {
        "api_name": "channel",
        "full_api_name": "Snapshot.channel",
        "api_description": "Return the :py:class:`~qiskit.pulse.channels.Channel` that this instruction is\nscheduled on; trivially, a ``SnapshotChannel``.",
        "api_signature": "channel(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/snapshot.py"
    },
    {
        "api_name": "channels",
        "full_api_name": "Snapshot.channels",
        "api_description": "Returns the channels that this schedule uses.",
        "api_signature": "channels(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/snapshot.py"
    },
    {
        "api_name": "duration",
        "full_api_name": "Snapshot.duration",
        "api_description": "Duration of this instruction.",
        "api_signature": "duration(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/snapshot.py"
    },
    {
        "api_name": "is_parameterized",
        "full_api_name": "Snapshot.is_parameterized",
        "api_description": "Return True iff the instruction is parameterized.",
        "api_signature": "is_parameterized(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/snapshot.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Instruction.__init__",
        "api_description": "Instruction initializer.\n\nArgs:\n    operands: The argument list.\n    name: Optional display name for this instruction.",
        "api_signature": "__init__(self, operands, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/instruction.py"
    },
    {
        "api_name": "_validate",
        "full_api_name": "Instruction._validate",
        "api_description": "Called after initialization to validate instruction data.\n\nRaises:\n    PulseError: If the input ``channels`` are not all of type :class:`Channel`.",
        "api_signature": "_validate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/instruction.py"
    },
    {
        "api_name": "name",
        "full_api_name": "Instruction.name",
        "api_description": "Name of this instruction.",
        "api_signature": "name(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/instruction.py"
    },
    {
        "api_name": "id",
        "full_api_name": "Instruction.id",
        "api_description": "Unique identifier for this instruction.",
        "api_signature": "id(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/instruction.py"
    },
    {
        "api_name": "operands",
        "full_api_name": "Instruction.operands",
        "api_description": "Return instruction operands.",
        "api_signature": "operands(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/instruction.py"
    },
    {
        "api_name": "channels",
        "full_api_name": "Instruction.channels",
        "api_description": "Returns the channels that this schedule uses.",
        "api_signature": "channels(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/instruction.py"
    },
    {
        "api_name": "start_time",
        "full_api_name": "Instruction.start_time",
        "api_description": "Relative begin time of this instruction.",
        "api_signature": "start_time(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/instruction.py"
    },
    {
        "api_name": "stop_time",
        "full_api_name": "Instruction.stop_time",
        "api_description": "Relative end time of this instruction.",
        "api_signature": "stop_time(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/instruction.py"
    },
    {
        "api_name": "duration",
        "full_api_name": "Instruction.duration",
        "api_description": "Duration of this instruction.",
        "api_signature": "duration(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/instruction.py"
    },
    {
        "api_name": "_children",
        "full_api_name": "Instruction._children",
        "api_description": "Instruction has no child nodes.",
        "api_signature": "_children(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/instruction.py"
    },
    {
        "api_name": "instructions",
        "full_api_name": "Instruction.instructions",
        "api_description": "Iterable for getting instructions from Schedule tree.",
        "api_signature": "instructions(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/instruction.py"
    },
    {
        "api_name": "ch_duration",
        "full_api_name": "Instruction.ch_duration",
        "api_description": "Return duration of the supplied channels in this Instruction.\n\nArgs:\n    *channels: Supplied channels",
        "api_signature": "ch_duration(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/instruction.py"
    },
    {
        "api_name": "ch_start_time",
        "full_api_name": "Instruction.ch_start_time",
        "api_description": "Return minimum start time for supplied channels.\n\nArgs:\n    *channels: Supplied channels",
        "api_signature": "ch_start_time(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/instruction.py"
    },
    {
        "api_name": "ch_stop_time",
        "full_api_name": "Instruction.ch_stop_time",
        "api_description": "Return maximum start time for supplied channels.\n\nArgs:\n    *channels: Supplied channels",
        "api_signature": "ch_stop_time(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/instruction.py"
    },
    {
        "api_name": "_instructions",
        "full_api_name": "Instruction._instructions",
        "api_description": "Iterable for flattening Schedule tree.\n\nArgs:\n    time: Shifted time of this node due to parent\n\nYields:\n    Tuple[int, Union['Schedule, 'Instruction']]: Tuple of the form\n        (start_time, instruction).",
        "api_signature": "_instructions(self, time)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/instruction.py"
    },
    {
        "api_name": "shift",
        "full_api_name": "Instruction.shift",
        "api_description": "Return a new schedule shifted forward by `time`.\n\nArgs:\n    time: Time to shift by\n    name: Name of the new schedule. Defaults to name of self\n\nReturns:\n    Schedule: The shifted schedule.",
        "api_signature": "shift(self, time, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/instruction.py"
    },
    {
        "api_name": "insert",
        "full_api_name": "Instruction.insert",
        "api_description": "Return a new :class:`~qiskit.pulse.Schedule` with ``schedule`` inserted within\n``self`` at ``start_time``.\n\nArgs:\n    start_time: Time to insert the schedule schedule\n    schedule (Union['Schedule', 'Instruction']): Schedule or instruction to insert\n    name: Name of the new schedule. Defaults to name of self\n\nReturns:\n    Schedule: A new schedule with ``schedule`` inserted with this instruction at t=0.",
        "api_signature": "insert(self, start_time, schedule, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/instruction.py"
    },
    {
        "api_name": "append",
        "full_api_name": "Instruction.append",
        "api_description": "Return a new :class:`~qiskit.pulse.Schedule` with ``schedule`` inserted at the\nmaximum time over all channels shared between ``self`` and ``schedule``.\n\nArgs:\n    schedule (Union['Schedule', 'Instruction']): Schedule or instruction to be appended\n    name: Name of the new schedule. Defaults to name of self\n\nReturns:\n    Schedule: A new schedule with ``schedule`` a this instruction at t=0.",
        "api_signature": "append(self, schedule, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/instruction.py"
    },
    {
        "api_name": "parameters",
        "full_api_name": "Instruction.parameters",
        "api_description": "Parameters which determine the instruction behavior.",
        "api_signature": "parameters(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/instruction.py"
    },
    {
        "api_name": "_get_parameters_recursive",
        "full_api_name": "Instruction._get_parameters_recursive",
        "api_description": "",
        "api_signature": "_get_parameters_recursive(obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/instruction.py"
    },
    {
        "api_name": "is_parameterized",
        "full_api_name": "Instruction.is_parameterized",
        "api_description": "Return True iff the instruction is parameterized.",
        "api_signature": "is_parameterized(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/instruction.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "Instruction.__eq__",
        "api_description": "Check if this Instruction is equal to the `other` instruction.\n\nEquality is determined by the instruction sharing the same operands and channels.",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/instruction.py"
    },
    {
        "api_name": "__hash__",
        "full_api_name": "Instruction.__hash__",
        "api_description": "",
        "api_signature": "__hash__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/instruction.py"
    },
    {
        "api_name": "__add__",
        "full_api_name": "Instruction.__add__",
        "api_description": "Return a new schedule with `other` inserted within `self` at `start_time`.\n\nArgs:\n    other (Union['Schedule', 'Instruction']): Schedule or instruction to be appended\n\nReturns:\n    Schedule: A new schedule with ``schedule`` appended after this instruction at t=0.",
        "api_signature": "__add__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/instruction.py"
    },
    {
        "api_name": "__or__",
        "full_api_name": "Instruction.__or__",
        "api_description": "Return a new schedule which is the union of `self` and `other`.\n\nArgs:\n    other (Union['Schedule', 'Instruction']): Schedule or instruction to union with\n\nReturns:\n    Schedule: A new schedule with ``schedule`` inserted with this instruction at t=0",
        "api_signature": "__or__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/instruction.py"
    },
    {
        "api_name": "__lshift__",
        "full_api_name": "Instruction.__lshift__",
        "api_description": "Return a new schedule which is shifted forward by `time`.\n\nReturns:\n    Schedule: The shifted schedule",
        "api_signature": "__lshift__(self, time)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/instruction.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "Instruction.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/instructions/instruction.py"
    },
    {
        "api_name": "constant",
        "full_api_name": "constant",
        "api_description": "Continuous constant pulse.\n\nArgs:\n    times: Times to output pulse for.\n    amp: Complex pulse amplitude.",
        "api_signature": "constant(times, amp)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/continuous.py"
    },
    {
        "api_name": "zero",
        "full_api_name": "zero",
        "api_description": "Continuous zero pulse.\n\nArgs:\n    times: Times to output pulse for.",
        "api_signature": "zero(times)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/continuous.py"
    },
    {
        "api_name": "square",
        "full_api_name": "square",
        "api_description": "Continuous square wave.\n\nArgs:\n    times: Times to output wave for.\n    amp: Pulse amplitude. Wave range is [-amp, amp].\n    freq: Pulse frequency. units of 1/dt.\n    phase: Pulse phase.",
        "api_signature": "square(times, amp, freq, phase)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/continuous.py"
    },
    {
        "api_name": "sawtooth",
        "full_api_name": "sawtooth",
        "api_description": "Continuous sawtooth wave.\n\nArgs:\n    times: Times to output wave for.\n    amp: Pulse amplitude. Wave range is [-amp, amp].\n    freq: Pulse frequency. units of 1/dt.\n    phase: Pulse phase.",
        "api_signature": "sawtooth(times, amp, freq, phase)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/continuous.py"
    },
    {
        "api_name": "triangle",
        "full_api_name": "triangle",
        "api_description": "Continuous triangle wave.\n\nArgs:\n    times: Times to output wave for.\n    amp: Pulse amplitude. Wave range is [-amp, amp].\n    freq: Pulse frequency. units of 1/dt.\n    phase: Pulse phase.",
        "api_signature": "triangle(times, amp, freq, phase)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/continuous.py"
    },
    {
        "api_name": "cos",
        "full_api_name": "cos",
        "api_description": "Continuous cosine wave.\n\nArgs:\n    times: Times to output wave for.\n    amp: Pulse amplitude.\n    freq: Pulse frequency, units of 1/dt.\n    phase: Pulse phase.",
        "api_signature": "cos(times, amp, freq, phase)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/continuous.py"
    },
    {
        "api_name": "sin",
        "full_api_name": "sin",
        "api_description": "Continuous cosine wave.\n\nArgs:\n    times: Times to output wave for.\n    amp: Pulse amplitude.\n    freq: Pulse frequency, units of 1/dt.\n    phase: Pulse phase.",
        "api_signature": "sin(times, amp, freq, phase)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/continuous.py"
    },
    {
        "api_name": "_fix_gaussian_width",
        "full_api_name": "_fix_gaussian_width",
        "api_description": "Enforce that the supplied gaussian pulse is zeroed at a specific width.\n\nThis is achieved by subtracting $\\Omega_g(center \\pm zeroed_width/2)$ from all samples.\n\namp: Pulse amplitude at `center`.\ncenter: Center (mean) of pulse.\nsigma: Standard deviation of pulse.\nzeroed_width: Subtract baseline from gaussian pulses to make sure\n    $\\Omega_g(center \\pm zeroed_width/2)=0$ is satisfied. This is used to avoid\n    large discontinuities at the start of a gaussian pulse. If unsupplied,\n    defaults to $2*(center + 1)$ such that $\\Omega_g(-1)=0$ and $\\Omega_g(2*(center + 1))=0$.\nrescale_amp: If True the pulse will be rescaled so that $\\Omega_g(center)=amp$.\nret_scale_factor: Return amplitude scale factor.",
        "api_signature": "_fix_gaussian_width(gaussian_samples, amp, center, sigma, zeroed_width, rescale_amp, ret_scale_factor)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/continuous.py"
    },
    {
        "api_name": "gaussian",
        "full_api_name": "gaussian",
        "api_description": "Continuous unnormalized gaussian pulse.\n\nIntegrated area under curve is $\\Omega_g(amp, sigma) = amp \\times np.sqrt(2\\pi \\sigma^2)$\n\nArgs:\n    times: Times to output pulse for.\n    amp: Pulse amplitude at `center`. If `zeroed_width` is set pulse amplitude at center\n        will be $amp-\\Omega_g(center \\pm zeroed_width/2)$ unless `rescale_amp` is set,\n        in which case all samples will be rescaled such that the center\n        amplitude will be `amp`.\n    center: Center (mean) of pulse.\n    sigma: Width (standard deviation) of pulse.\n    zeroed_width: Subtract baseline from gaussian pulses to make sure\n        $\\Omega_g(center \\pm zeroed_width/2)=0$ is satisfied. This is used to avoid\n        large discontinuities at the start of a gaussian pulse.\n    rescale_amp: If `zeroed_width` is not `None` and `rescale_amp=True` the pulse will\n        be rescaled so that $\\Omega_g(center)=amp$.\n    ret_x: Return centered and standard deviation normalized pulse location.\n           $x=(times-center)/sigma.",
        "api_signature": "gaussian(times, amp, center, sigma, zeroed_width, rescale_amp, ret_x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/continuous.py"
    },
    {
        "api_name": "gaussian_deriv",
        "full_api_name": "gaussian_deriv",
        "api_description": "Continuous unnormalized gaussian derivative pulse.\n\nArgs:\n    times: Times to output pulse for.\n    amp: Pulse amplitude at `center`.\n    center: Center (mean) of pulse.\n    sigma: Width (standard deviation) of pulse.\n    ret_gaussian: Return gaussian with which derivative was taken with.\n    zeroed_width: Subtract baseline of pulse to make sure\n        $\\Omega_g(center \\pm zeroed_width/2)=0$ is satisfied. This is used to avoid\n        large discontinuities at the start of a pulse.\n    rescale_amp: If `zeroed_width` is not `None` and `rescale_amp=True` the pulse will\n        be rescaled so that $\\Omega_g(center)=amp$.",
        "api_signature": "gaussian_deriv(times, amp, center, sigma, ret_gaussian, zeroed_width, rescale_amp)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/continuous.py"
    },
    {
        "api_name": "_fix_sech_width",
        "full_api_name": "_fix_sech_width",
        "api_description": "Enforce that the supplied sech pulse is zeroed at a specific width.\n\nThis is achieved by subtracting $\\Omega_g(center \\pm zeroed_width/2)$ from all samples.\n\namp: Pulse amplitude at `center`.\ncenter: Center (mean) of pulse.\nsigma: Standard deviation of pulse.\nzeroed_width: Subtract baseline from sech pulses to make sure\n    $\\Omega_g(center \\pm zeroed_width/2)=0$ is satisfied. This is used to avoid\n    large discontinuities at the start of a sech pulse. If unsupplied,\n    defaults to $2*(center + 1)$ such that $\\Omega_g(-1)=0$ and $\\Omega_g(2*(center + 1))=0$.\nrescale_amp: If True the pulse will be rescaled so that $\\Omega_g(center)=amp$.\nret_scale_factor: Return amplitude scale factor.",
        "api_signature": "_fix_sech_width(sech_samples, amp, center, sigma, zeroed_width, rescale_amp, ret_scale_factor)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/continuous.py"
    },
    {
        "api_name": "sech_fn",
        "full_api_name": "sech_fn",
        "api_description": "Hyperbolic secant function",
        "api_signature": "sech_fn(x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/continuous.py"
    },
    {
        "api_name": "sech",
        "full_api_name": "sech",
        "api_description": "Continuous unnormalized sech pulse.\n\nArgs:\n    times: Times to output pulse for.\n    amp: Pulse amplitude at `center`.\n    center: Center (mean) of pulse.\n    sigma: Width (standard deviation) of pulse.\n    zeroed_width: Subtract baseline from pulse to make sure\n        $\\Omega_g(center \\pm zeroed_width/2)=0$ is satisfied. This is used to avoid\n        large discontinuities at the start and end of the pulse.\n    rescale_amp: If `zeroed_width` is not `None` and `rescale_amp=True` the pulse will\n        be rescaled so that $\\Omega_g(center)=amp$.\n    ret_x: Return centered and standard deviation normalized pulse location.\n        $x=(times-center)/sigma$.",
        "api_signature": "sech(times, amp, center, sigma, zeroed_width, rescale_amp, ret_x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/continuous.py"
    },
    {
        "api_name": "sech_deriv",
        "full_api_name": "sech_deriv",
        "api_description": "Continuous unnormalized sech derivative pulse.\n\nArgs:\n    times: Times to output pulse for.\n    amp: Pulse amplitude at `center`.\n    center: Center (mean) of pulse.\n    sigma: Width (standard deviation) of pulse.\n    ret_sech: Return sech with which derivative was taken with.",
        "api_signature": "sech_deriv(times, amp, center, sigma, ret_sech)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/continuous.py"
    },
    {
        "api_name": "gaussian_square",
        "full_api_name": "gaussian_square",
        "api_description": "Continuous gaussian square pulse.\n\nArgs:\n    times: Times to output pulse for.\n    amp: Pulse amplitude.\n    center: Center of the square pulse component.\n    square_width: Width of the square pulse component.\n    sigma: Standard deviation of Gaussian rise/fall portion of the pulse.\n    zeroed_width: Subtract baseline of gaussian square pulse\n        to enforce $\\OmegaSquare(center \\pm zeroed_width/2)=0$.\n\nRaises:\n    PulseError: if zeroed_width is not compatible with square_width.",
        "api_signature": "gaussian_square(times, amp, center, square_width, sigma, zeroed_width)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/continuous.py"
    },
    {
        "api_name": "drag",
        "full_api_name": "drag",
        "api_description": "Continuous Y-only correction DRAG pulse for standard nonlinear oscillator (SNO) [1].\n\n[1] Gambetta, J. M., Motzoi, F., Merkel, S. T. & Wilhelm, F. K.\n    Analytic control methods for high-fidelity unitary operations\n    in a weakly nonlinear oscillator. Phys. Rev. A 83, 012308 (2011).\n\nArgs:\n    times: Times to output pulse for.\n    amp: Pulse amplitude at `center`.\n    center: Center (mean) of pulse.\n    sigma: Width (standard deviation) of pulse.\n    beta: Y correction amplitude. For the SNO this is $\\beta=-\\frac{\\lambda_1^2}{4\\Delta_2}$.\n        Where $\\lambds_1$ is the relative coupling strength between the first excited and second\n        excited states and $\\Delta_2$ is the detuning between the respective excited states.\n    zeroed_width: Subtract baseline of drag pulse to make sure\n        $\\Omega_g(center \\pm zeroed_width/2)=0$ is satisfied. This is used to avoid\n        large discontinuities at the start of a drag pulse.\n    rescale_amp: If `zeroed_width` is not `None` and `rescale_amp=True` the pulse will\n        be rescaled so that $\\Omega_g(center)=amp$.",
        "api_signature": "drag(times, amp, center, sigma, beta, zeroed_width, rescale_amp)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/continuous.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Pulse.__init__",
        "api_description": "Abstract base class for pulses\nArgs:\n    duration: Duration of the pulse\n    name: Optional name for the pulse\n    limit_amplitude: If ``True``, then limit the amplitude of the waveform to 1.\n                     The default value of ``None`` causes the flag value to be\n                     derived from :py:attr:`~limit_amplitude` which is ``True``\n                     by default but may be set by the user to disable amplitude\n                     checks globally.",
        "api_signature": "__init__(self, duration, name, limit_amplitude)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/pulse.py"
    },
    {
        "api_name": "id",
        "full_api_name": "Pulse.id",
        "api_description": "Unique identifier for this pulse.",
        "api_signature": "id(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/pulse.py"
    },
    {
        "api_name": "parameters",
        "full_api_name": "Pulse.parameters",
        "api_description": "Return a dictionary containing the pulse's parameters.",
        "api_signature": "parameters(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/pulse.py"
    },
    {
        "api_name": "is_parameterized",
        "full_api_name": "Pulse.is_parameterized",
        "api_description": "Return True iff the instruction is parameterized.",
        "api_signature": "is_parameterized(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/pulse.py"
    },
    {
        "api_name": "draw",
        "full_api_name": "Pulse.draw",
        "api_description": "Plot the interpolated envelope of pulse.\n\nArgs:\n    style: Stylesheet options. This can be dictionary or preset stylesheet classes. See\n        :py:class:`~qiskit.visualization.pulse_v2.stylesheets.IQXStandard`,\n        :py:class:`~qiskit.visualization.pulse_v2.stylesheets.IQXSimple`, and\n        :py:class:`~qiskit.visualization.pulse_v2.stylesheets.IQXDebugging` for details of\n        preset stylesheets.\n    backend (Optional[BaseBackend]): Backend object to play the input pulse program.\n        If provided, the plotter may use to make the visualization hardware aware.\n    time_range: Set horizontal axis limit. Tuple ``(tmin, tmax)``.\n    time_unit: The unit of specified time range either ``dt`` or ``ns``.\n        The unit of ``ns`` is available only when ``backend`` object is provided.\n    show_waveform_info: Show waveform annotations, i.e. name, of waveforms.\n        Set ``True`` to show additional information about waveforms.\n    plotter: Name of plotter API to generate an output image.\n        One of following APIs should be specified::\n\n            mpl2d: Matplotlib API for 2D image generation.\n                Matplotlib API to generate 2D image. Charts are placed along y axis with\n                vertical offset. This API takes matplotlib.axes.Axes as `axis` input.\n\n        `axis` and `style` kwargs may depend on the plotter.\n    axis: Arbitrary object passed to the plotter. If this object is provided,\n        the plotters use a given ``axis`` instead of internally initializing\n        a figure object. This object format depends on the plotter.\n        See plotter argument for details.\n\nReturns:\n    Visualization output data.\n    The returned data type depends on the ``plotter``.\n    If matplotlib family is specified, this will be a ``matplotlib.pyplot.Figure`` data.",
        "api_signature": "draw(self, style, backend, time_range, time_unit, show_waveform_info, plotter, axis)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/pulse.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "Pulse.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/pulse.py"
    },
    {
        "api_name": "__hash__",
        "full_api_name": "Pulse.__hash__",
        "api_description": "",
        "api_signature": "__hash__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/pulse.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "Pulse.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/pulse.py"
    },
    {
        "api_name": "_lifted_gaussian",
        "full_api_name": "_lifted_gaussian",
        "api_description": "Helper function that returns a lifted Gaussian symbolic equation.\n\nFor :math:`\\sigma=` ``sigma`` the symbolic equation will be\n\n.. math::\n\n    f(x) = \\exp\\left(-\\frac12 \\left(\\frac{x - \\mu}{\\sigma}\\right)^2 \\right),\n\nwith the center :math:`\\mu=` ``duration/2``.\nThen, each output sample :math:`y` is modified according to:\n\n.. math::\n\n    y \\mapsto \\frac{y-y^*}{1.0-y^*},\n\nwhere :math:`y^*` is the value of the un-normalized Gaussian at the endpoints of the pulse.\nThis sets the endpoints to :math:`0` while preserving the amplitude at the center,\ni.e. :math:`y` is set to :math:`1.0`.\n\nArgs:\n    t: Symbol object representing time.\n    center: Symbol or expression representing the middle point of the samples.\n    t_zero: The value of t at which the pulse is lowered to 0.\n    sigma: Symbol or expression representing Gaussian sigma.\n\nReturns:\n    Symbolic equation.",
        "api_signature": "_lifted_gaussian(t, center, t_zero, sigma)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/symbolic_pulses.py"
    },
    {
        "api_name": "_is_amplitude_valid",
        "full_api_name": "_is_amplitude_valid",
        "api_description": "A helper function to validate maximum amplitude limit.\n\nResult is cached for better performance.\n\nArgs:\n    envelope_lam: The SymbolicPulse's lambdified envelope_lam expression.\n    time: The SymbolicPulse's time array, given as a tuple for hashability.\n    fargs: The arguments for the lambdified envelope_lam, as given by `_get_expression_args`,\n        except for the time array.\n\nReturns:\n    Return True if no sample point exceeds 1.0 in absolute value.",
        "api_signature": "_is_amplitude_valid(envelope_lam, time)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/symbolic_pulses.py"
    },
    {
        "api_name": "_get_expression_args",
        "full_api_name": "_get_expression_args",
        "api_description": "A helper function to get argument to evaluate expression.\n\nArgs:\n    expr: Symbolic expression to evaluate.\n    params: Dictionary of parameter, which is a superset of expression arguments.\n\nReturns:\n    Arguments passed to the lambdified expression.\n\nRaises:\n    PulseError: When a free symbol value is not defined in the pulse instance parameters.",
        "api_signature": "_get_expression_args(expr, params)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/symbolic_pulses.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "LambdifiedExpression.__init__",
        "api_description": "Create new descriptor.\n\nArgs:\n    attribute: Name of attribute of :class:`.SymbolicPulse` that returns\n        the target expression to evaluate.",
        "api_signature": "__init__(self, attribute)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/symbolic_pulses.py"
    },
    {
        "api_name": "__get__",
        "full_api_name": "LambdifiedExpression.__get__",
        "api_description": "",
        "api_signature": "__get__(self, instance, owner)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/symbolic_pulses.py"
    },
    {
        "api_name": "__set__",
        "full_api_name": "LambdifiedExpression.__set__",
        "api_description": "",
        "api_signature": "__set__(self, instance, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/symbolic_pulses.py"
    },
    {
        "api_name": "_wrapped_lamb",
        "full_api_name": "LambdifiedExpression._wrapped_lamb",
        "api_description": "",
        "api_signature": "_wrapped_lamb()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/symbolic_pulses.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SymbolicPulse.__init__",
        "api_description": "Create a parametric pulse.\n\nArgs:\n    pulse_type: Display name of this pulse shape.\n    duration: Duration of pulse.\n    parameters: Dictionary of pulse parameters that defines the pulse envelope.\n    name: Display name for this particular pulse envelope.\n    limit_amplitude: If ``True``, then limit the absolute value of the amplitude of the\n        waveform to 1. The default is ``True`` and the amplitude is constrained to 1.\n    envelope: Pulse envelope expression.\n    constraints: Pulse parameter constraint expression.\n    valid_amp_conditions: Extra conditions to skip a full-waveform check for the\n        amplitude limit. If this condition is not met, then the validation routine\n        will investigate the full-waveform and raise an error when the amplitude norm\n        of any data point exceeds 1.0. If not provided, the validation always\n        creates a full-waveform.\n\nRaises:\n    PulseError: When not all parameters are listed in the attribute :attr:`PARAM_DEF`.",
        "api_signature": "__init__(self, pulse_type, duration, parameters, name, limit_amplitude, envelope, constraints, valid_amp_conditions)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/symbolic_pulses.py"
    },
    {
        "api_name": "__getattr__",
        "full_api_name": "SymbolicPulse.__getattr__",
        "api_description": "",
        "api_signature": "__getattr__(self, item)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/symbolic_pulses.py"
    },
    {
        "api_name": "pulse_type",
        "full_api_name": "SymbolicPulse.pulse_type",
        "api_description": "Return display name of the pulse shape.",
        "api_signature": "pulse_type(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/symbolic_pulses.py"
    },
    {
        "api_name": "envelope",
        "full_api_name": "SymbolicPulse.envelope",
        "api_description": "Return symbolic expression for the pulse envelope.",
        "api_signature": "envelope(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/symbolic_pulses.py"
    },
    {
        "api_name": "constraints",
        "full_api_name": "SymbolicPulse.constraints",
        "api_description": "Return symbolic expression for the pulse parameter constraints.",
        "api_signature": "constraints(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/symbolic_pulses.py"
    },
    {
        "api_name": "valid_amp_conditions",
        "full_api_name": "SymbolicPulse.valid_amp_conditions",
        "api_description": "Return symbolic expression for the pulse amplitude constraints.",
        "api_signature": "valid_amp_conditions(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/symbolic_pulses.py"
    },
    {
        "api_name": "get_waveform",
        "full_api_name": "SymbolicPulse.get_waveform",
        "api_description": "Return a Waveform with samples filled according to the formula that the pulse\nrepresents and the parameter values it contains.\n\nSince the returned array is a discretized time series of the continuous function,\nthis method uses a midpoint sampler. For ``duration``, return:\n\n.. math::\n\n    \\{f(t+0.5) \\in \\mathbb{C} | t \\in \\mathbb{Z} \\wedge  0<=t<\\texttt{duration}\\}\n\nReturns:\n    A waveform representation of this pulse.\n\nRaises:\n    PulseError: When parameters are not assigned.\n    PulseError: When expression for pulse envelope is not assigned.",
        "api_signature": "get_waveform(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/symbolic_pulses.py"
    },
    {
        "api_name": "validate_parameters",
        "full_api_name": "SymbolicPulse.validate_parameters",
        "api_description": "Validate parameters.\n\nRaises:\n    PulseError: If the parameters passed are not valid.",
        "api_signature": "validate_parameters(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/symbolic_pulses.py"
    },
    {
        "api_name": "is_parameterized",
        "full_api_name": "SymbolicPulse.is_parameterized",
        "api_description": "Return True iff the instruction is parameterized.",
        "api_signature": "is_parameterized(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/symbolic_pulses.py"
    },
    {
        "api_name": "parameters",
        "full_api_name": "SymbolicPulse.parameters",
        "api_description": "",
        "api_signature": "parameters(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/symbolic_pulses.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "SymbolicPulse.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/symbolic_pulses.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "SymbolicPulse.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/symbolic_pulses.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ScalableSymbolicPulse.__init__",
        "api_description": "Create a scalable symbolic pulse.\n\nArgs:\n    pulse_type: Display name of this pulse shape.\n    duration: Duration of pulse.\n    amp: The magnitude of the complex amplitude of the pulse.\n    angle: The phase of the complex amplitude of the pulse.\n    parameters: Dictionary of pulse parameters that defines the pulse envelope.\n    name: Display name for this particular pulse envelope.\n    limit_amplitude: If ``True``, then limit the absolute value of the amplitude of the\n        waveform to 1. The default is ``True`` and the amplitude is constrained to 1.\n    envelope: Pulse envelope expression.\n    constraints: Pulse parameter constraint expression.\n    valid_amp_conditions: Extra conditions to skip a full-waveform check for the\n        amplitude limit. If this condition is not met, then the validation routine\n        will investigate the full-waveform and raise an error when the amplitude norm\n        of any data point exceeds 1.0. If not provided, the validation always\n        creates a full-waveform.\n\nRaises:\n    PulseError: If ``amp`` is complex.",
        "api_signature": "__init__(self, pulse_type, duration, amp, angle, parameters, name, limit_amplitude, envelope, constraints, valid_amp_conditions)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/symbolic_pulses.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "ScalableSymbolicPulse.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/symbolic_pulses.py"
    },
    {
        "api_name": "__instancecheck__",
        "full_api_name": "_PulseType.__instancecheck__",
        "api_description": "",
        "api_signature": "__instancecheck__(cls, instance)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/symbolic_pulses.py"
    },
    {
        "api_name": "__getattr__",
        "full_api_name": "_PulseType.__getattr__",
        "api_description": "",
        "api_signature": "__getattr__(cls, item)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/symbolic_pulses.py"
    },
    {
        "api_name": "__new__",
        "full_api_name": "Gaussian.__new__",
        "api_description": "Create new pulse instance.\n\nArgs:\n    duration: Pulse length in terms of the sampling period `dt`.\n    amp: The magnitude of the amplitude of the Gaussian envelope.\n    sigma: A measure of how wide or narrow the Gaussian peak is; described mathematically\n           in the class docstring.\n    angle: The angle of the complex amplitude of the Gaussian envelope. Default value 0.\n    name: Display name for this pulse envelope.\n    limit_amplitude: If ``True``, then limit the amplitude of the\n        waveform to 1. The default is ``True`` and the amplitude is constrained to 1.\n\nReturns:\n    ScalableSymbolicPulse instance.",
        "api_signature": "__new__(cls, duration, amp, sigma, angle, name, limit_amplitude)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/symbolic_pulses.py"
    },
    {
        "api_name": "__new__",
        "full_api_name": "GaussianSquare.__new__",
        "api_description": "Create new pulse instance.\n\nArgs:\n    duration: Pulse length in terms of the sampling period `dt`.\n    amp: The magnitude of the amplitude of the Gaussian and square pulse.\n    sigma: A measure of how wide or narrow the Gaussian risefall is; see the class\n           docstring for more details.\n    width: The duration of the embedded square pulse.\n    angle: The angle of the complex amplitude of the pulse. Default value 0.\n    risefall_sigma_ratio: The ratio of each risefall duration to sigma.\n    name: Display name for this pulse envelope.\n    limit_amplitude: If ``True``, then limit the amplitude of the\n        waveform to 1. The default is ``True`` and the amplitude is constrained to 1.\n\nReturns:\n    ScalableSymbolicPulse instance.\n\nRaises:\n    PulseError: When width and risefall_sigma_ratio are both empty or both non-empty.",
        "api_signature": "__new__(cls, duration, amp, sigma, width, angle, risefall_sigma_ratio, name, limit_amplitude)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/symbolic_pulses.py"
    },
    {
        "api_name": "GaussianSquareDrag",
        "full_api_name": "GaussianSquareDrag",
        "api_description": "A square pulse with a Drag shaped rise and fall\n\nThis pulse shape is similar to :class:`~.GaussianSquare` but uses\n:class:`~.Drag` for its rise and fall instead of :class:`~.Gaussian`. The\naddition of the DRAG component of the rise and fall is sometimes helpful in\nsuppressing the spectral content of the pulse at frequencies near to, but\nslightly offset from, the fundamental frequency of the drive. When there is\na spectator qubit close in frequency to the fundamental frequency,\nsuppressing the drive at the spectator's frequency can help avoid unwanted\nexcitation of the spectator.\n\nExactly one of the ``risefall_sigma_ratio`` and ``width`` parameters has to be specified.\n\nIf ``risefall_sigma_ratio`` is not ``None`` and ``width`` is ``None``:\n\n.. math::\n\n    \\begin{aligned}\n    \\text{risefall} &= \\text{risefall\\_sigma\\_ratio} \\times \\text{sigma}\\\\\n    \\text{width} &= \\text{duration} - 2 \\times \\text{risefall}\n    \\end{aligned}\n\nIf ``width`` is not None and ``risefall_sigma_ratio`` is None:\n\n.. math:: \\text{risefall} = \\frac{\\text{duration} - \\text{width}}{2}\n\nGaussian :math:`g(x, c, \u03c3)` and lifted gaussian :math:`g'(x, c, \u03c3)` curves\ncan be written as:\n\n.. math::\n\n    \\begin{aligned}\n    g(x, c, \u03c3) &= \\exp\\Bigl(-\\frac12 \\frac{(x - c)^2}{\u03c3^2}\\Bigr)\\\\\n    g'(x, c, \u03c3) &= \\frac{g(x, c, \u03c3)-g(-1, c, \u03c3)}{1-g(-1, c, \u03c3)}\n    \\end{aligned}\n\nFrom these, the lifted DRAG curve :math:`d'(x, c, \u03c3, \u03b2)` can be written as\n\n.. math::\n\n    d'(x, c, \u03c3, \u03b2) = g'(x, c, \u03c3) \\times \\Bigl(1 + 1j \\times \u03b2 \\times            \\Bigl(-\\frac{x - c}{\u03c3^2}\\Bigr)\\Bigr)\n\nThe lifted gaussian square drag pulse :math:`f'(x)` is defined as:\n\n.. math::\n\n    \\begin{aligned}\n    f'(x) &= \\begin{cases}            \\text{A} \\times d'(x, \\text{risefall}, \\text{sigma}, \\text{beta})                & x < \\text{risefall}\\\\\n        \\text{A}                & \\text{risefall} \\le x < \\text{risefall} + \\text{width}\\\\\n        \\text{A} \\times \\times d'(                    x - (\\text{risefall} + \\text{width}),                    \\text{risefall},                    \\text{sigma},                    \\text{beta}                )                & \\text{risefall} + \\text{width} \\le x        \\end{cases}\\\\\n    \\end{aligned}\n\nwhere :math:`\\text{A} = \\text{amp} \\times\n\\exp\\left(i\\times\\text{angle}\\right)`.\n\nArgs:\n    duration: Pulse length in terms of the sampling period `dt`.\n    amp: The amplitude of the DRAG rise and fall and of the square pulse.\n    sigma: A measure of how wide or narrow the DRAG risefall is; see the class\n           docstring for more details.\n    beta: The DRAG correction amplitude.\n    width: The duration of the embedded square pulse.\n    angle: The angle in radians of the complex phase factor uniformly\n        scaling the pulse. Default value 0.\n    risefall_sigma_ratio: The ratio of each risefall duration to sigma.\n    name: Display name for this pulse envelope.\n    limit_amplitude: If ``True``, then limit the amplitude of the\n        waveform to 1. The default is ``True`` and the amplitude is constrained to 1.\n\nReturns:\n    ScalableSymbolicPulse instance.\n\nRaises:\n    PulseError: When width and risefall_sigma_ratio are both empty or both non-empty.",
        "api_signature": "GaussianSquareDrag(duration, amp, sigma, beta, width, angle, risefall_sigma_ratio, name, limit_amplitude)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/symbolic_pulses.py"
    },
    {
        "api_name": "gaussian_square_echo",
        "full_api_name": "gaussian_square_echo",
        "api_description": "An echoed Gaussian square pulse with an active tone overlaid on it.\n\nThe Gaussian Square Echo pulse is composed of three pulses. First, a Gaussian Square pulse\n:math:`f_{echo}(x)` with amplitude ``amp`` and phase ``angle`` playing for half duration,\nfollowed by a second Gaussian Square pulse :math:`-f_{echo}(x)` with opposite amplitude\nand same phase playing for the rest of the duration. Third a Gaussian Square pulse\n:math:`f_{active}(x)` with amplitude ``active_amp`` and phase ``active_angle``\nplaying for the entire duration. The Gaussian Square Echo pulse :math:`g_e()`\ncan be written as:\n\n.. math::\n\n    \\begin{aligned}\n    g_e(x) &= \\begin{cases}            f_{\\text{active}} + f_{\\text{echo}}(x)                & x < \\frac{\\text{duration}}{2}\\\\\n        f_{\\text{active}} - f_{\\text{echo}}(x)                & \\frac{\\text{duration}}{2} < x        \\end{cases}\\\\\n    \\end{aligned}\n\nOne case where this pulse can be used is when implementing a direct CNOT gate with\na cross-resonance superconducting qubit architecture. When applying this pulse to\nthe target qubit, the active portion can be used to cancel IX terms from the\ncross-resonance drive while the echo portion can reduce the impact of a static ZZ coupling.\n\nExactly one of the ``risefall_sigma_ratio`` and ``width`` parameters has to be specified.\n\nIf ``risefall_sigma_ratio`` is not ``None`` and ``width`` is ``None``:\n\n.. math::\n\n    \\begin{aligned}\n    \\text{risefall} &= \\text{risefall\\_sigma\\_ratio} \\times \\text{sigma}\\\\\n    \\text{width} &= \\text{duration} - 2 \\times \\text{risefall}\n    \\end{aligned}\n\nIf ``width`` is not None and ``risefall_sigma_ratio`` is None:\n\n.. math:: \\text{risefall} = \\frac{\\text{duration} - \\text{width}}{2}\n\nReferences:\n    1. |citation1|_\n\n    .. _citation1: https://iopscience.iop.org/article/10.1088/2058-9565/abe519\n\n    .. |citation1| replace:: *Jurcevic, P., Javadi-Abhari, A., Bishop, L. S.,\n        Lauer, I., Bogorin, D. F., Brink, M., Capelluto, L., G{\"u}nl{\"u}k, O.,\n        Itoko, T., Kanazawa, N. & others\n        Demonstration of quantum volume 64 on a superconducting quantum\n        computing system. (Section V)*\nArgs:\n    duration: Pulse length in terms of the sampling period `dt`.\n    amp: The amplitude of the rise and fall and of the echoed pulse.\n    sigma: A measure of how wide or narrow the risefall is; see the class\n           docstring for more details.\n    width: The duration of the embedded square pulse.\n    angle: The angle in radians of the complex phase factor uniformly\n        scaling the echoed pulse. Default value 0.\n    active_amp: The amplitude of the active pulse.\n    active_angle: The angle in radian of the complex phase factor uniformly\n        scaling the active pulse. Default value 0.\n    risefall_sigma_ratio: The ratio of each risefall duration to sigma.\n    name: Display name for this pulse envelope.\n    limit_amplitude: If ``True``, then limit the amplitude of the\n        waveform to 1. The default is ``True`` and the amplitude is constrained to 1.\n\nReturns:\n    ScalableSymbolicPulse instance.\nRaises:\n    PulseError: When width and risefall_sigma_ratio are both empty or both non-empty.",
        "api_signature": "gaussian_square_echo(duration, amp, sigma, width, angle, active_amp, active_angle, risefall_sigma_ratio, name, limit_amplitude)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/symbolic_pulses.py"
    },
    {
        "api_name": "GaussianDeriv",
        "full_api_name": "GaussianDeriv",
        "api_description": "An unnormalized Gaussian derivative pulse.\n\nThe Gaussian function is centered around the halfway point of the pulse,\nand the envelope of the pulse is given by:\n\n.. math::\n\n    f(x) = -\\text{A}\\frac{x-\\mu}{\\text{sigma}^{2}}\\exp\n        \\left[-\\left(\\frac{x-\\mu}{2\\text{sigma}}\\right)^{2}\\right]  ,  0 <= x < duration\n\nwhere :math:`\\text{A} = \\text{amp} \\times\\exp\\left(i\\times\\text{angle}\\right)`,\nand :math:`\\mu=\\text{duration}/2`.\n\nArgs:\n    duration: Pulse length in terms of the sampling period `dt`.\n    amp: The magnitude of the amplitude of the pulse\n        (the value of the corresponding Gaussian at the midpoint `duration`/2).\n    sigma: A measure of how wide or narrow the corresponding Gaussian peak is in terms of `dt`;\n        described mathematically in the class docstring.\n    angle: The angle in radians of the complex phase factor uniformly\n        scaling the pulse. Default value 0.\n    name: Display name for this pulse envelope.\n    limit_amplitude: If ``True``, then limit the amplitude of the\n        waveform to 1. The default is ``True`` and the amplitude is constrained to 1.\n\nReturns:\n    ScalableSymbolicPulse instance.",
        "api_signature": "GaussianDeriv(duration, amp, sigma, angle, name, limit_amplitude)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/symbolic_pulses.py"
    },
    {
        "api_name": "__new__",
        "full_api_name": "Drag.__new__",
        "api_description": "Create new pulse instance.\n\nArgs:\n    duration: Pulse length in terms of the sampling period `dt`.\n    amp: The magnitude of the amplitude of the DRAG envelope.\n    sigma: A measure of how wide or narrow the Gaussian peak is; described mathematically\n           in the class docstring.\n    beta: The correction amplitude.\n    angle: The angle of the complex amplitude of the DRAG envelope. Default value 0.\n    name: Display name for this pulse envelope.\n    limit_amplitude: If ``True``, then limit the amplitude of the\n        waveform to 1. The default is ``True`` and the amplitude is constrained to 1.\n\nReturns:\n    ScalableSymbolicPulse instance.",
        "api_signature": "__new__(cls, duration, amp, sigma, beta, angle, name, limit_amplitude)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/symbolic_pulses.py"
    },
    {
        "api_name": "__new__",
        "full_api_name": "Constant.__new__",
        "api_description": "Create new pulse instance.\n\nArgs:\n    duration: Pulse length in terms of the sampling period `dt`.\n    amp: The magnitude of the amplitude of the square envelope.\n    angle: The angle of the complex amplitude of the square envelope. Default value 0.\n    name: Display name for this pulse envelope.\n    limit_amplitude: If ``True``, then limit the amplitude of the\n        waveform to 1. The default is ``True`` and the amplitude is constrained to 1.\n\nReturns:\n    ScalableSymbolicPulse instance.",
        "api_signature": "__new__(cls, duration, amp, angle, name, limit_amplitude)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/symbolic_pulses.py"
    },
    {
        "api_name": "Sin",
        "full_api_name": "Sin",
        "api_description": "A sinusoidal pulse.\n\nThe envelope of the pulse is given by:\n\n.. math::\n\n    f(x) = \\text{A}\\sin\\left(2\\pi\\text{freq}x+\\text{phase}\\right)  ,  0 <= x < duration\n\nwhere :math:`\\text{A} = \\text{amp} \\times\\exp\\left(i\\times\\text{angle}\\right)`.\n\nArgs:\n    duration: Pulse length in terms of the sampling period `dt`.\n    amp: The magnitude of the amplitude of the sinusoidal wave. Wave range is [-`amp`,`amp`].\n    phase: The phase of the sinusoidal wave (note that this is not equivalent to the angle of\n        the complex amplitude)\n    freq: The frequency of the sinusoidal wave, in terms of 1 over sampling period.\n        If not provided defaults to a single cycle (i.e :math:'\\frac{1}{\\text{duration}}').\n        The frequency is limited to the range :math:`\\left(0,0.5\\right]` (the Nyquist frequency).\n    angle: The angle in radians of the complex phase factor uniformly\n        scaling the pulse. Default value 0.\n    name: Display name for this pulse envelope.\n    limit_amplitude: If ``True``, then limit the amplitude of the\n        waveform to 1. The default is ``True`` and the amplitude is constrained to 1.\n\nReturns:\n    ScalableSymbolicPulse instance.",
        "api_signature": "Sin(duration, amp, phase, freq, angle, name, limit_amplitude)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/symbolic_pulses.py"
    },
    {
        "api_name": "Cos",
        "full_api_name": "Cos",
        "api_description": "A cosine pulse.\n\nThe envelope of the pulse is given by:\n\n.. math::\n\n    f(x) = \\text{A}\\cos\\left(2\\pi\\text{freq}x+\\text{phase}\\right)  ,  0 <= x < duration\n\nwhere :math:`\\text{A} = \\text{amp} \\times\\exp\\left(i\\times\\text{angle}\\right)`.\n\nArgs:\n    duration: Pulse length in terms of the sampling period `dt`.\n    amp: The magnitude of the amplitude of the cosine wave. Wave range is [-`amp`,`amp`].\n    phase: The phase of the cosine wave (note that this is not equivalent to the angle\n        of the complex amplitude).\n    freq: The frequency of the cosine wave, in terms of 1 over sampling period.\n        If not provided defaults to a single cycle (i.e :math:'\\frac{1}{\\text{duration}}').\n        The frequency is limited to the range :math:`\\left(0,0.5\\right]` (the Nyquist frequency).\n    angle: The angle in radians of the complex phase factor uniformly\n        scaling the pulse. Default value 0.\n    name: Display name for this pulse envelope.\n    limit_amplitude: If ``True``, then limit the amplitude of the\n        waveform to 1. The default is ``True`` and the amplitude is constrained to 1.\n\nReturns:\n    ScalableSymbolicPulse instance.",
        "api_signature": "Cos(duration, amp, phase, freq, angle, name, limit_amplitude)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/symbolic_pulses.py"
    },
    {
        "api_name": "Sawtooth",
        "full_api_name": "Sawtooth",
        "api_description": "A sawtooth pulse.\n\nThe envelope of the pulse is given by:\n\n.. math::\n\n    f(x) = 2\\text{A}\\left[g\\left(x\\right)-\n        \\lfloor g\\left(x\\right)+\\frac{1}{2}\\rfloor\\right]\n\nwhere :math:`\\text{A} = \\text{amp} \\times\\exp\\left(i\\times\\text{angle}\\right)`,\n:math:`g\\left(x\\right)=x\\times\\text{freq}+\\frac{\\text{phase}}{2\\pi}`,\nand :math:`\\lfloor ...\\rfloor` is the floor operation.\n\nArgs:\n    duration: Pulse length in terms of the sampling period `dt`.\n    amp: The magnitude of the amplitude of the sawtooth wave. Wave range is [-`amp`,`amp`].\n    phase: The phase of the sawtooth wave (note that this is not equivalent to the angle\n        of the complex amplitude)\n    freq: The frequency of the sawtooth wave, in terms of 1 over sampling period.\n        If not provided defaults to a single cycle (i.e :math:'\\frac{1}{\\text{duration}}').\n        The frequency is limited to the range :math:`\\left(0,0.5\\right]` (the Nyquist frequency).\n    angle: The angle in radians of the complex phase factor uniformly\n        scaling the pulse. Default value 0.\n    name: Display name for this pulse envelope.\n    limit_amplitude: If ``True``, then limit the amplitude of the\n        waveform to 1. The default is ``True`` and the amplitude is constrained to 1.\n\nReturns:\n    ScalableSymbolicPulse instance.",
        "api_signature": "Sawtooth(duration, amp, phase, freq, angle, name, limit_amplitude)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/symbolic_pulses.py"
    },
    {
        "api_name": "Triangle",
        "full_api_name": "Triangle",
        "api_description": "A triangle wave pulse.\n\nThe envelope of the pulse is given by:\n\n.. math::\n\n    f(x) = \\text{A}\\left[\\text{sawtooth}\\left(x\\right)\\right]  ,  0 <= x < duration\n\nwhere :math:`\\text{A} = \\text{amp} \\times\\exp\\left(i\\times\\text{angle}\\right)`,\nand :math:`\\text{sawtooth}\\left(x\\right)` is a sawtooth wave with the same frequency\nas the triangle wave, but a phase shifted by :math:`\\frac{\\pi}{2}`.\n\nArgs:\n    duration: Pulse length in terms of the sampling period `dt`.\n    amp: The magnitude of the amplitude of the triangle wave. Wave range is [-`amp`,`amp`].\n    phase: The phase of the triangle wave (note that this is not equivalent to the angle\n        of the complex amplitude)\n    freq: The frequency of the triangle wave, in terms of 1 over sampling period.\n        If not provided defaults to a single cycle (i.e :math:'\\frac{1}{\\text{duration}}').\n        The frequency is limited to the range :math:`\\left(0,0.5\\right]` (the Nyquist frequency).\n    angle: The angle in radians of the complex phase factor uniformly\n        scaling the pulse. Default value 0.\n    name: Display name for this pulse envelope.\n    limit_amplitude: If ``True``, then limit the amplitude of the\n        waveform to 1. The default is ``True`` and the amplitude is constrained to 1.\n\nReturns:\n    ScalableSymbolicPulse instance.",
        "api_signature": "Triangle(duration, amp, phase, freq, angle, name, limit_amplitude)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/symbolic_pulses.py"
    },
    {
        "api_name": "Square",
        "full_api_name": "Square",
        "api_description": "A square wave pulse.\n\nThe envelope of the pulse is given by:\n\n.. math::\n\n    f(x) = \\text{A}\\text{sign}\\left[\\sin\n        \\left(2\\pi x\\times\\text{freq}+\\text{phase}\\right)\\right]  ,  0 <= x < duration\n\nwhere :math:`\\text{A} = \\text{amp} \\times\\exp\\left(i\\times\\text{angle}\\right)`,\nand :math:`\\text{sign}`\nis the sign function with the convention :math:`\\text{sign}\\left(0\\right)=1`.\n\nArgs:\n    duration: Pulse length in terms of the sampling period `dt`.\n    amp: The magnitude of the amplitude of the square wave. Wave range is [-`amp`,`amp`].\n    phase: The phase of the square wave (note that this is not equivalent to the angle of\n        the complex amplitude).\n    freq: The frequency of the square wave, in terms of 1 over sampling period.\n        If not provided defaults to a single cycle (i.e :math:'\\frac{1}{\\text{duration}}').\n        The frequency is limited to the range :math:`\\left(0,0.5\\right]` (the Nyquist frequency).\n    angle: The angle in radians of the complex phase factor uniformly\n        scaling the pulse. Default value 0.\n    name: Display name for this pulse envelope.\n    limit_amplitude: If ``True``, then limit the amplitude of the\n        waveform to 1. The default is ``True`` and the amplitude is constrained to 1.\n\nReturns:\n    ScalableSymbolicPulse instance.",
        "api_signature": "Square(duration, amp, phase, freq, angle, name, limit_amplitude)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/symbolic_pulses.py"
    },
    {
        "api_name": "Sech",
        "full_api_name": "Sech",
        "api_description": "An unnormalized sech pulse.\n\nThe sech function is centered around the halfway point of the pulse,\nand the envelope of the pulse is given by:\n\n.. math::\n\n    f(x) = \\text{A}\\text{sech}\\left(\n        \\frac{x-\\mu}{\\text{sigma}}\\right)  ,  0 <= x < duration\n\nwhere :math:`\\text{A} = \\text{amp} \\times\\exp\\left(i\\times\\text{angle}\\right)`,\nand :math:`\\mu=\\text{duration}/2`.\n\nIf `zero_ends` is set to `True`, the output `y` is modified:\n.. math::\n\n    y\\left(x\\right) \\mapsto \\text{A}\\frac{y-y^{*}}{\\text{A}-y^{*}},\n\nwhere :math:`y^{*}` is the value of :math:`y` at the endpoints (at :math:`x=-1\nand :math:`x=\\text{duration}+1`). This shifts the endpoints value to zero, while also\nrescaling to preserve the amplitude at `:math:`\\text{duration}/2``.\n\nArgs:\n    duration: Pulse length in terms of the sampling period `dt`.\n    amp: The magnitude of the amplitude of the pulse (the value at the midpoint `duration`/2).\n    sigma: A measure of how wide or narrow the sech peak is in terms of `dt`;\n        described mathematically in the class docstring.\n    angle: The angle in radians of the complex phase factor uniformly\n        scaling the pulse. Default value 0.\n    name: Display name for this pulse envelope.\n    zero_ends: If True, zeros the ends at x = -1, x = `duration` + 1,\n        but rescales to preserve `amp`. Default value True.\n    limit_amplitude: If ``True``, then limit the amplitude of the\n        waveform to 1. The default is ``True`` and the amplitude is constrained to 1.\n\nReturns:\n    ScalableSymbolicPulse instance.",
        "api_signature": "Sech(duration, amp, sigma, angle, name, zero_ends, limit_amplitude)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/symbolic_pulses.py"
    },
    {
        "api_name": "SechDeriv",
        "full_api_name": "SechDeriv",
        "api_description": "An unnormalized sech derivative pulse.\n\nThe sech function is centered around the halfway point of the pulse, and the envelope of the\npulse is given by:\n\n.. math::\n\n    f(x) = \\text{A}\\frac{d}{dx}\\left[\\text{sech}\n        \\left(\\frac{x-\\mu}{\\text{sigma}}\\right)\\right]  ,  0 <= x < duration\n\nwhere :math:`\\text{A} = \\text{amp} \\times\\exp\\left(i\\times\\text{angle}\\right)`,\n:math:`\\mu=\\text{duration}/2`, and :math:`d/dx` is a derivative with respect to `x`.\n\nArgs:\n    duration: Pulse length in terms of the sampling period `dt`.\n    amp: The magnitude of the amplitude of the pulse (the value of the corresponding sech\n        function at the midpoint `duration`/2).\n    sigma: A measure of how wide or narrow the corresponding sech peak is, in terms of `dt`;\n        described mathematically in the class docstring.\n    angle: The angle in radians of the complex phase factor uniformly\n        scaling the pulse. Default value 0.\n    name: Display name for this pulse envelope.\n    limit_amplitude: If ``True``, then limit the amplitude of the\n        waveform to 1. The default is ``True`` and the amplitude is constrained to 1.\n\nReturns:\n    ScalableSymbolicPulse instance.",
        "api_signature": "SechDeriv(duration, amp, sigma, angle, name, limit_amplitude)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/symbolic_pulses.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Waveform.__init__",
        "api_description": "Create new sample pulse command.\n\nArgs:\n    samples: Complex array of the samples in the pulse envelope.\n    name: Unique name to identify the pulse.\n    epsilon: Pulse sample norm tolerance for clipping.\n        If any sample's norm exceeds unity by less than or equal to epsilon\n        it will be clipped to unit norm. If the sample\n        norm is greater than 1+epsilon an error will be raised.\n    limit_amplitude: Passed to parent Pulse",
        "api_signature": "__init__(self, samples, name, epsilon, limit_amplitude)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/waveform.py"
    },
    {
        "api_name": "samples",
        "full_api_name": "Waveform.samples",
        "api_description": "Return sample values.",
        "api_signature": "samples(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/waveform.py"
    },
    {
        "api_name": "_clip",
        "full_api_name": "Waveform._clip",
        "api_description": "If samples are within epsilon of unit norm, clip sample by reducing norm by (1-epsilon).\n\nIf difference is greater than epsilon error is raised.\n\nArgs:\n    samples: Complex array of the samples in the pulse envelope.\n    epsilon: Pulse sample norm tolerance for clipping.\n        If any sample's norm exceeds unity by less than or equal to epsilon\n        it will be clipped to unit norm. If the sample\n        norm is greater than 1+epsilon an error will be raised.\n\nReturns:\n    Clipped pulse samples.\n\nRaises:\n    PulseError: If there exists a pulse sample with a norm greater than 1+epsilon.",
        "api_signature": "_clip(self, samples, epsilon)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/waveform.py"
    },
    {
        "api_name": "is_parameterized",
        "full_api_name": "Waveform.is_parameterized",
        "api_description": "Return True iff the instruction is parameterized.",
        "api_signature": "is_parameterized(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/waveform.py"
    },
    {
        "api_name": "parameters",
        "full_api_name": "Waveform.parameters",
        "api_description": "Return a dictionary containing the pulse's parameters.",
        "api_signature": "parameters(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/waveform.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "Waveform.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/waveform.py"
    },
    {
        "api_name": "__hash__",
        "full_api_name": "Waveform.__hash__",
        "api_description": "",
        "api_signature": "__hash__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/waveform.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "Waveform.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/waveform.py"
    },
    {
        "api_name": "functional_pulse",
        "full_api_name": "functional_pulse",
        "api_description": "A decorator for generating Waveform from python callable.\n\nArgs:\n    func: A function describing pulse envelope.\n\nRaises:\n    PulseError: when invalid function is specified.",
        "api_signature": "functional_pulse(func)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/samplers/decorators.py"
    },
    {
        "api_name": "to_pulse",
        "full_api_name": "to_pulse",
        "api_description": "Return Waveform.",
        "api_signature": "to_pulse(duration)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/samplers/decorators.py"
    },
    {
        "api_name": "_update_annotations",
        "full_api_name": "_update_annotations",
        "api_description": "Update annotations of discretized continuous pulse function with duration.\n\nArgs:\n    discretized_pulse: Discretized decorated continuous pulse.",
        "api_signature": "_update_annotations(discretized_pulse)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/samplers/decorators.py"
    },
    {
        "api_name": "_update_docstring",
        "full_api_name": "_update_docstring",
        "api_description": "Update annotations of discretized continuous pulse function.\n\nArgs:\n    discretized_pulse: Discretized decorated continuous pulse.\n    sampler_inst: Applied sampler.",
        "api_signature": "_update_docstring(discretized_pulse, sampler_inst)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/samplers/decorators.py"
    },
    {
        "api_name": "sampler",
        "full_api_name": "sampler",
        "api_description": "Sampler decorator base method.\n\nSamplers are used for converting an continuous function to a discretized pulse.\n\nThey operate on a function with the signature:\n    `def f(times: np.ndarray, *args, **kwargs) -> np.ndarray`\nWhere `times` is a numpy array of floats with length n_times and the output array\nis a complex numpy array with length n_times. The output of the decorator is an\ninstance of `FunctionalPulse` with signature:\n    `def g(duration: int, *args, **kwargs) -> Waveform`\n\nNote if your continuous pulse function outputs a `complex` scalar rather than a\n`np.ndarray`, you should first vectorize it before applying a sampler.\n\n\nThis class implements the sampler boilerplate for the sampler.\n\nArgs:\n    sample_function: A sampler function to be decorated.",
        "api_signature": "sampler(sample_function)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/samplers/decorators.py"
    },
    {
        "api_name": "generate_sampler",
        "full_api_name": "generate_sampler",
        "api_description": "Return a decorated sampler function.",
        "api_signature": "generate_sampler(continuous_pulse)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/samplers/decorators.py"
    },
    {
        "api_name": "call_sampler",
        "full_api_name": "call_sampler",
        "api_description": "Replace the call to the continuous function with a call to the sampler applied\nto the analytic pulse function.",
        "api_signature": "call_sampler(duration)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/samplers/decorators.py"
    },
    {
        "api_name": "left",
        "full_api_name": "left",
        "api_description": "Left sampling strategy decorator.\n\nSee `pulse.samplers.sampler` for more information.\n\nFor `duration`, return:\n    $$\\{f(t) \\in \\mathbb{C} | t \\in \\mathbb{Z} \\wedge  0<=t<\\texttt{duration}\\}$$\n\nArgs:\n    continuous_pulse: To sample.",
        "api_signature": "left(continuous_pulse)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/samplers/decorators.py"
    },
    {
        "api_name": "right",
        "full_api_name": "right",
        "api_description": "Right sampling strategy decorator.\n\nSee `pulse.samplers.sampler` for more information.\n\nFor `duration`, return:\n    $$\\{f(t) \\in \\mathbb{C} | t \\in \\mathbb{Z} \\wedge  0<t<=\\texttt{duration}\\}$$\n\nArgs:\n    continuous_pulse: To sample.",
        "api_signature": "right(continuous_pulse)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/samplers/decorators.py"
    },
    {
        "api_name": "midpoint",
        "full_api_name": "midpoint",
        "api_description": "Midpoint sampling strategy decorator.\n\nSee `pulse.samplers.sampler` for more information.\n\nFor `duration`, return:\n    $$\\{f(t+0.5) \\in \\mathbb{C} | t \\in \\mathbb{Z} \\wedge  0<=t<\\texttt{duration}\\}$$\n\nArgs:\n    continuous_pulse: To sample.",
        "api_signature": "midpoint(continuous_pulse)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/samplers/decorators.py"
    },
    {
        "api_name": "left_sample",
        "full_api_name": "left_sample",
        "api_description": "Left sample a continuous function.\n\nArgs:\n    continuous_pulse: Continuous pulse function to sample.\n    duration: Duration to sample for.\n    *args: Continuous pulse function args.\n    **kwargs: Continuous pulse function kwargs.",
        "api_signature": "left_sample(continuous_pulse, duration)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/samplers/strategies.py"
    },
    {
        "api_name": "right_sample",
        "full_api_name": "right_sample",
        "api_description": "Sampling strategy for decorator.\n\nArgs:\n    continuous_pulse: Continuous pulse function to sample.\n    duration: Duration to sample for.\n    *args: Continuous pulse function args.\n    **kwargs: Continuous pulse function kwargs.",
        "api_signature": "right_sample(continuous_pulse, duration)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/samplers/strategies.py"
    },
    {
        "api_name": "midpoint_sample",
        "full_api_name": "midpoint_sample",
        "api_description": "Sampling strategy for decorator.\n\nArgs:\n    continuous_pulse: Continuous pulse function to sample.\n    duration: Duration to sample for.\n    *args: Continuous pulse function args.\n    **kwargs: Continuous pulse function kwargs.",
        "api_signature": "midpoint_sample(continuous_pulse, duration)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/library/samplers/strategies.py"
    },
    {
        "api_name": "target_qobj_transform",
        "full_api_name": "target_qobj_transform",
        "api_description": "A basic pulse program transformation for OpenPulse API execution.\n\nArgs:\n    sched: Input program to transform.\n    remove_directives: Set `True` to remove compiler directives.\n\nReturns:\n    Transformed program for execution.",
        "api_signature": "target_qobj_transform(sched, remove_directives)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/base_transforms.py"
    },
    {
        "api_name": "_format_schedule_component",
        "full_api_name": "_format_schedule_component",
        "api_description": "A helper function to convert instructions into list of instructions.",
        "api_signature": "_format_schedule_component(sched)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/base_transforms.py"
    },
    {
        "api_name": "block_to_schedule",
        "full_api_name": "block_to_schedule",
        "api_description": "Convert ``ScheduleBlock`` to ``Schedule``.\n\nArgs:\n    block: A ``ScheduleBlock`` to convert.\n\nReturns:\n    Scheduled pulse program.\n\nRaises:\n    UnassignedDurationError: When any instruction duration is not assigned.\n    PulseError: When the alignment context duration is shorter than the schedule duration.\n\n.. note:: This transform may insert barriers in between contexts.",
        "api_signature": "block_to_schedule(block)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/canonicalization.py"
    },
    {
        "api_name": "compress_pulses",
        "full_api_name": "compress_pulses",
        "api_description": "Optimization pass to replace identical pulses.\n\nArgs:\n    schedules: Schedules to compress.\n\nReturns:\n    Compressed schedules.",
        "api_signature": "compress_pulses(schedules)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/canonicalization.py"
    },
    {
        "api_name": "flatten",
        "full_api_name": "flatten",
        "api_description": "Flatten (inline) any called nodes into a Schedule tree with no nested children.\n\nArgs:\n    program: Pulse program to remove nested structure.\n\nReturns:\n    Flatten pulse program.\n\nRaises:\n    PulseError: When invalid data format is given.",
        "api_signature": "flatten(program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/canonicalization.py"
    },
    {
        "api_name": "inline_subroutines",
        "full_api_name": "inline_subroutines",
        "api_description": "Recursively remove call instructions and inline the respective subroutine instructions.\n\nAssigned parameter values, which are stored in the parameter table, are also applied.\nThe subroutine is copied before the parameter assignment to avoid mutation problem.\n\nArgs:\n    program: A program which may contain the subroutine, i.e. ``Call`` instruction.\n\nReturns:\n    A schedule without subroutine.\n\nRaises:\n    PulseError: When input program is not valid data format.",
        "api_signature": "inline_subroutines(program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/canonicalization.py"
    },
    {
        "api_name": "_inline_schedule",
        "full_api_name": "_inline_schedule",
        "api_description": "A helper function to inline subroutine of schedule.\n\n.. note:: If subroutine is ``ScheduleBlock`` it is converted into Schedule to get ``t0``.",
        "api_signature": "_inline_schedule(schedule)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/canonicalization.py"
    },
    {
        "api_name": "_inline_block",
        "full_api_name": "_inline_block",
        "api_description": "A helper function to inline subroutine of schedule block.\n\n.. note:: If subroutine is ``Schedule`` the function raises an error.",
        "api_signature": "_inline_block(block)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/canonicalization.py"
    },
    {
        "api_name": "remove_directives",
        "full_api_name": "remove_directives",
        "api_description": "Remove directives.\n\nArgs:\n    schedule: A schedule to remove compiler directives.\n\nReturns:\n    A schedule without directives.",
        "api_signature": "remove_directives(schedule)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/canonicalization.py"
    },
    {
        "api_name": "remove_trivial_barriers",
        "full_api_name": "remove_trivial_barriers",
        "api_description": "Remove trivial barriers with 0 or 1 channels.\n\nArgs:\n    schedule: A schedule to remove trivial barriers.\n\nReturns:\n    schedule: A schedule without trivial barriers",
        "api_signature": "remove_trivial_barriers(schedule)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/canonicalization.py"
    },
    {
        "api_name": "filter_func",
        "full_api_name": "filter_func",
        "api_description": "",
        "api_signature": "filter_func(inst)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/canonicalization.py"
    },
    {
        "api_name": "align_measures",
        "full_api_name": "align_measures",
        "api_description": "Return new schedules where measurements occur at the same physical time.\n\nThis transformation will align the first :class:`.Acquire` on\nevery channel to occur at the same time.\n\nMinimum measurement wait time (to allow for calibration pulses) is enforced\nand may be set with ``max_calibration_duration``.\n\nBy default only instructions containing a :class:`.AcquireChannel` or :class:`.MeasureChannel`\nwill be shifted. If you wish to keep the relative timing of all instructions in the schedule set\n``align_all=True``.\n\nThis method assumes that ``MeasureChannel(i)`` and ``AcquireChannel(i)``\ncorrespond to the same qubit and the acquire/play instructions\nshould be shifted together on these channels.\n\n.. code-block::\n\n    from qiskit import pulse\n    from qiskit.pulse import transforms\n\n    d0 = pulse.DriveChannel(0)\n    m0 = pulse.MeasureChannel(0)\n    a0 = pulse.AcquireChannel(0)\n    mem0 = pulse.MemorySlot(0)\n\n    sched = pulse.Schedule()\n    sched.append(pulse.Play(pulse.Constant(10, 0.5), d0), inplace=True)\n    sched.append(pulse.Play(pulse.Constant(10, 1.), m0).shift(sched.duration), inplace=True)\n    sched.append(pulse.Acquire(20, a0, mem0).shift(sched.duration), inplace=True)\n\n    sched_shifted = sched << 20\n\n    aligned_sched, aligned_sched_shifted = transforms.align_measures([sched, sched_shifted])\n\n    assert aligned_sched == aligned_sched_shifted\n\nIf it is desired to only shift acquisition and measurement stimulus instructions\nset the flag ``align_all=False``:\n\n.. code-block::\n\n    aligned_sched, aligned_sched_shifted = transforms.align_measures(\n        [sched, sched_shifted],\n        align_all=False,\n    )\n\n    assert aligned_sched != aligned_sched_shifted\n\n\nArgs:\n    schedules: Collection of schedules to be aligned together\n    inst_map: Mapping of circuit operations to pulse schedules\n    cal_gate: The name of the gate to inspect for the calibration time\n    max_calibration_duration: If provided, inst_map and cal_gate will be ignored\n    align_time: If provided, this will be used as final align time.\n    align_all: Shift all instructions in the schedule such that they maintain\n        their relative alignment with the shifted acquisition instruction.\n        If ``False`` only the acquisition and measurement pulse instructions\n        will be shifted.\nReturns:\n    The input list of schedules transformed to have their measurements aligned.\n\nRaises:\n    PulseError: If the provided alignment time is negative.",
        "api_signature": "align_measures(schedules, inst_map, cal_gate, max_calibration_duration, align_time, align_all)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/canonicalization.py"
    },
    {
        "api_name": "get_first_acquire_times",
        "full_api_name": "get_first_acquire_times",
        "api_description": "Return a list of first acquire times for each schedule.",
        "api_signature": "get_first_acquire_times(schedules)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/canonicalization.py"
    },
    {
        "api_name": "get_max_calibration_duration",
        "full_api_name": "get_max_calibration_duration",
        "api_description": "Return the time needed to allow for readout discrimination calibration pulses.",
        "api_signature": "get_max_calibration_duration(inst_map, cal_gate)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/canonicalization.py"
    },
    {
        "api_name": "add_implicit_acquires",
        "full_api_name": "add_implicit_acquires",
        "api_description": "Return a new schedule with implicit acquires from the measurement mapping replaced by\nexplicit ones.\n\n.. warning:: Since new acquires are being added, Memory Slots will be set to match the\n             qubit index. This may overwrite your specification.\n\nArgs:\n    schedule: Schedule to be aligned.\n    meas_map: List of lists of qubits that are measured together.\n\nReturns:\n    A ``Schedule`` with the additional acquisition instructions.",
        "api_signature": "add_implicit_acquires(schedule, meas_map)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/canonicalization.py"
    },
    {
        "api_name": "pad",
        "full_api_name": "pad",
        "api_description": "Pad the input Schedule with ``Delay``s on all unoccupied timeslots until\n``schedule.duration`` or ``until`` if not ``None``.\n\nArgs:\n    schedule: Schedule to pad.\n    channels: Channels to pad. Defaults to all channels in\n        ``schedule`` if not provided. If the supplied channel is not a member\n        of ``schedule`` it will be added.\n    until: Time to pad until. Defaults to ``schedule.duration`` if not provided.\n    inplace: Pad this schedule by mutating rather than returning a new schedule.\n    pad_with: Pulse ``Instruction`` subclass to be used for padding.\n        Default to :class:`~qiskit.pulse.instructions.Delay` instruction.\n\nReturns:\n    The padded schedule.\n\nRaises:\n    PulseError: When non pulse instruction is set to `pad_with`.",
        "api_signature": "pad(schedule, channels, until, inplace, pad_with)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/canonicalization.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "AlignmentKind.__init__",
        "api_description": "Create new context.",
        "api_signature": "__init__(self, context_params)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/alignments.py"
    },
    {
        "api_name": "align",
        "full_api_name": "AlignmentKind.align",
        "api_description": "Reallocate instructions according to the policy.\n\nOnly top-level sub-schedules are aligned. If sub-schedules are nested,\nnested schedules are not recursively aligned.\n\nArgs:\n    schedule: Schedule to align.\n\nReturns:\n    Schedule with reallocated instructions.",
        "api_signature": "align(self, schedule)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/alignments.py"
    },
    {
        "api_name": "is_sequential",
        "full_api_name": "AlignmentKind.is_sequential",
        "api_description": "Return ``True`` if this is sequential alignment context.\n\nThis information is used to evaluate DAG equivalency of two :class:`.ScheduleBlock`s.\nWhen the context has two pulses in different channels,\na sequential context subtype intends to return following scheduling outcome.\n\n.. parsed-literal::\n\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    D0: \u2524 pulse1 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    D1: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 pulse2 \u251c\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nOn the other hand, parallel context with ``is_sequential=False`` returns\n\n.. parsed-literal::\n\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    D0: \u2524 pulse1 \u251c\n        \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n    D1: \u2524 pulse2 \u251c\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nAll subclasses must implement this method according to scheduling strategy.",
        "api_signature": "is_sequential(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/alignments.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "AlignmentKind.__eq__",
        "api_description": "Check equality of two transforms.",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/alignments.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "AlignmentKind.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/alignments.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "AlignLeft.__init__",
        "api_description": "Create new left-justified context.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/alignments.py"
    },
    {
        "api_name": "is_sequential",
        "full_api_name": "AlignLeft.is_sequential",
        "api_description": "",
        "api_signature": "is_sequential(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/alignments.py"
    },
    {
        "api_name": "align",
        "full_api_name": "AlignLeft.align",
        "api_description": "Reallocate instructions according to the policy.\n\nOnly top-level sub-schedules are aligned. If sub-schedules are nested,\nnested schedules are not recursively aligned.\n\nArgs:\n    schedule: Schedule to align.\n\nReturns:\n    Schedule with reallocated instructions.",
        "api_signature": "align(self, schedule)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/alignments.py"
    },
    {
        "api_name": "_push_left_append",
        "full_api_name": "AlignLeft._push_left_append",
        "api_description": "Return ``this`` with ``other`` inserted at the maximum time over\nall channels shared between ```this`` and ``other``.\n\nArgs:\n    this: Input schedule to which ``other`` will be inserted.\n    other: Other schedule to insert.\n\nReturns:\n    Push left appended schedule.",
        "api_signature": "_push_left_append(this, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/alignments.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "AlignRight.__init__",
        "api_description": "Create new right-justified context.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/alignments.py"
    },
    {
        "api_name": "is_sequential",
        "full_api_name": "AlignRight.is_sequential",
        "api_description": "",
        "api_signature": "is_sequential(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/alignments.py"
    },
    {
        "api_name": "align",
        "full_api_name": "AlignRight.align",
        "api_description": "Reallocate instructions according to the policy.\n\nOnly top-level sub-schedules are aligned. If sub-schedules are nested,\nnested schedules are not recursively aligned.\n\nArgs:\n    schedule: Schedule to align.\n\nReturns:\n    Schedule with reallocated instructions.",
        "api_signature": "align(self, schedule)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/alignments.py"
    },
    {
        "api_name": "_push_right_prepend",
        "full_api_name": "AlignRight._push_right_prepend",
        "api_description": "Return ``this`` with ``other`` inserted at the latest possible time\nsuch that ``other`` ends before it overlaps with any of ``this``.\n\nIf required ``this`` is shifted  to start late enough so that there is room\nto insert ``other``.\n\nArgs:\n   this: Input schedule to which ``other`` will be inserted.\n   other: Other schedule to insert.\n\nReturns:\n   Push right prepended schedule.",
        "api_signature": "_push_right_prepend(this, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/alignments.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "AlignSequential.__init__",
        "api_description": "Create new sequential context.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/alignments.py"
    },
    {
        "api_name": "is_sequential",
        "full_api_name": "AlignSequential.is_sequential",
        "api_description": "",
        "api_signature": "is_sequential(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/alignments.py"
    },
    {
        "api_name": "align",
        "full_api_name": "AlignSequential.align",
        "api_description": "Reallocate instructions according to the policy.\n\nOnly top-level sub-schedules are aligned. If sub-schedules are nested,\nnested schedules are not recursively aligned.\n\nArgs:\n    schedule: Schedule to align.\n\nReturns:\n    Schedule with reallocated instructions.",
        "api_signature": "align(self, schedule)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/alignments.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "AlignEquispaced.__init__",
        "api_description": "Create new equispaced context.\n\nArgs:\n    duration: Duration of this context. This should be larger than the schedule duration.\n        If the specified duration is shorter than the schedule duration,\n        no alignment is performed and the input schedule is just returned.\n        This duration can be parametrized.",
        "api_signature": "__init__(self, duration)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/alignments.py"
    },
    {
        "api_name": "is_sequential",
        "full_api_name": "AlignEquispaced.is_sequential",
        "api_description": "",
        "api_signature": "is_sequential(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/alignments.py"
    },
    {
        "api_name": "duration",
        "full_api_name": "AlignEquispaced.duration",
        "api_description": "Return context duration.",
        "api_signature": "duration(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/alignments.py"
    },
    {
        "api_name": "align",
        "full_api_name": "AlignEquispaced.align",
        "api_description": "Reallocate instructions according to the policy.\n\nOnly top-level sub-schedules are aligned. If sub-schedules are nested,\nnested schedules are not recursively aligned.\n\nArgs:\n    schedule: Schedule to align.\n\nReturns:\n    Schedule with reallocated instructions.",
        "api_signature": "align(self, schedule)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/alignments.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "AlignFunc.__init__",
        "api_description": "Create new equispaced context.\n\nArgs:\n    duration: Duration of this context. This should be larger than the schedule duration.\n        If the specified duration is shorter than the schedule duration,\n        no alignment is performed and the input schedule is just returned.\n        This duration can be parametrized.\n    func: A function that takes an index of sub-schedule and returns the\n        fractional coordinate of of that sub-schedule. The returned value should be\n        defined within [0, 1]. The pulse index starts from 1.",
        "api_signature": "__init__(self, duration, func)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/alignments.py"
    },
    {
        "api_name": "is_sequential",
        "full_api_name": "AlignFunc.is_sequential",
        "api_description": "",
        "api_signature": "is_sequential(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/alignments.py"
    },
    {
        "api_name": "duration",
        "full_api_name": "AlignFunc.duration",
        "api_description": "Return context duration.",
        "api_signature": "duration(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/alignments.py"
    },
    {
        "api_name": "func",
        "full_api_name": "AlignFunc.func",
        "api_description": "Return context alignment function.",
        "api_signature": "func(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/alignments.py"
    },
    {
        "api_name": "align",
        "full_api_name": "AlignFunc.align",
        "api_description": "Reallocate instructions according to the policy.\n\nOnly top-level sub-schedules are aligned. If sub-schedules are nested,\nnested schedules are not recursively aligned.\n\nArgs:\n    schedule: Schedule to align.\n\nReturns:\n    Schedule with reallocated instructions.",
        "api_signature": "align(self, schedule)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/alignments.py"
    },
    {
        "api_name": "block_to_dag",
        "full_api_name": "block_to_dag",
        "api_description": "Convert schedule block instruction into DAG.\n\n``ScheduleBlock`` can be represented as a DAG as needed.\nFor example, equality of two programs are efficiently checked on DAG representation.\n\n.. code-block:: python\n\n    with pulse.build() as sched1:\n        with pulse.align_left():\n            pulse.play(my_gaussian0, pulse.DriveChannel(0))\n            pulse.shift_phase(1.57, pulse.DriveChannel(2))\n            pulse.play(my_gaussian1, pulse.DriveChannel(1))\n\n    with pulse.build() as sched2:\n        with pulse.align_left():\n            pulse.shift_phase(1.57, pulse.DriveChannel(2))\n            pulse.play(my_gaussian1, pulse.DriveChannel(1))\n            pulse.play(my_gaussian0, pulse.DriveChannel(0))\n\nHere the ``sched1 `` and ``sched2`` are different implementations of the same program,\nbut it is difficult to confirm on the list representation.\n\nAnother example is instruction optimization.\n\n.. code-block:: python\n\n    with pulse.build() as sched:\n        with pulse.align_left():\n            pulse.shift_phase(1.57, pulse.DriveChannel(1))\n            pulse.play(my_gaussian0, pulse.DriveChannel(0))\n            pulse.shift_phase(-1.57, pulse.DriveChannel(1))\n\nIn above program two ``shift_phase`` instructions can be cancelled out because\nthey are consecutive on the same drive channel.\nThis can be easily found on the DAG representation.\n\nArgs:\n    block (\"ScheduleBlock\"): A schedule block to be converted.\n\nReturns:\n    Instructions in DAG representation.\n\nRaises:\n    PulseError: When the context is invalid subclass.",
        "api_signature": "block_to_dag(block)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/dag.py"
    },
    {
        "api_name": "_sequential_allocation",
        "full_api_name": "_sequential_allocation",
        "api_description": "A helper function to create a DAG of a sequential alignment context.",
        "api_signature": "_sequential_allocation(block)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/dag.py"
    },
    {
        "api_name": "_parallel_allocation",
        "full_api_name": "_parallel_allocation",
        "api_description": "A helper function to create a DAG of a parallel alignment context.",
        "api_signature": "_parallel_allocation(block)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/pulse/transforms/dag.py"
    },
    {
        "api_name": "marginal_counts",
        "full_api_name": "marginal_counts",
        "api_description": "Marginalize counts from an experiment over some indices of interest.\n\nArgs:\n    result: result to be marginalized\n        (a Result object or a dict(str, int) of counts).\n    indices: The bit positions of interest\n        to marginalize over. If ``None`` (default), do not marginalize at all.\n    inplace: Default: False. Operates on the original Result\n        argument if True, leading to loss of original Job Result.\n        It has no effect if ``result`` is a dict.\n    format_marginal: Default: False. If True, takes the output of\n        marginalize and formats it with placeholders between cregs and\n        for non-indices.\n    marginalize_memory: If True, then also marginalize the memory field (if present).\n        If False, remove the memory field from the result.\n        If None, leave the memory field as is.\n\nReturns:\n    Result or dict(str, int): A Result object or a dictionary with\n        the observed counts, marginalized to only account for frequency\n        of observations of bits of interest.\n\nRaises:\n    QiskitError: in case of invalid indices to marginalize over.",
        "api_signature": "marginal_counts(result, indices, inplace, format_marginal, marginalize_memory)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/utils.py"
    },
    {
        "api_name": "_adjust_creg_sizes",
        "full_api_name": "_adjust_creg_sizes",
        "api_description": "Helper to reduce creg_sizes to match indices",
        "api_signature": "_adjust_creg_sizes(creg_sizes, indices)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/utils.py"
    },
    {
        "api_name": "marginal_memory",
        "full_api_name": "marginal_memory",
        "api_description": "Marginalize shot memory\n\nThis function is multithreaded and will launch a thread pool with threads equal to the number\nof CPUs by default. You can tune the number of threads with the ``RAYON_NUM_THREADS``\nenvironment variable. For example, setting ``RAYON_NUM_THREADS=4`` would limit the thread pool\nto 4 threads.\n\nArgs:\n    memory: The input memory list, this is either a list of hexadecimal strings to be marginalized\n        representing measure level 2 memory or a numpy array representing level 0 measurement\n        memory (single or avg) or level 1 measurement memory (single or avg).\n    indices: The bit positions of interest to marginalize over. If\n        ``None`` (default), do not marginalize at all.\n    int_return: If set to ``True`` the output will be a list of integers.\n        By default the return type is a bit string. This and ``hex_return``\n        are mutually exclusive and can not be specified at the same time. This option only has an\n        effect with memory level 2.\n    hex_return: If set to ``True`` the output will be a list of hexadecimal\n        strings. By default the return type is a bit string. This and\n        ``int_return`` are mutually exclusive and can not be specified\n        at the same time. This option only has an effect with memory level 2.\n    avg_data: If a 2 dimensional numpy array is passed in for ``memory`` this can be set to\n        ``True`` to indicate it's a avg level 0 data instead of level 1\n        single data.\n    parallel_threshold: The number of elements in ``memory`` to start running in multiple\n        threads. If ``len(memory)`` is >= this value, the function will run in multiple\n        threads. By default this is set to 1000.\n\nReturns:\n    marginal_memory: The list of marginalized memory\n\nRaises:\n    ValueError: if both ``int_return`` and ``hex_return`` are set to ``True``",
        "api_signature": "marginal_memory(memory, indices, int_return, hex_return, avg_data, parallel_threshold)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/utils.py"
    },
    {
        "api_name": "marginal_distribution",
        "full_api_name": "marginal_distribution",
        "api_description": "Marginalize counts from an experiment over some indices of interest.\n\nUnlike :func:`~.marginal_counts` this function respects the order of\nthe input ``indices``. If the input ``indices`` list is specified then the order\nthe bit indices are specified will be the output order of the bitstrings\nin the marginalized output.\n\nArgs:\n    counts: result to be marginalized\n    indices: The bit positions of interest\n        to marginalize over. If ``None`` (default), do not marginalize at all.\n    format_marginal: Default: False. If True, takes the output of\n        marginalize and formats it with placeholders between cregs and\n        for non-indices.\nReturns:\n    dict(str, int): A marginalized dictionary\nRaises:\n    QiskitError: If any value in ``indices`` is invalid or the ``counts`` dict\n    is invalid.",
        "api_signature": "marginal_distribution(counts, indices, format_marginal)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/utils.py"
    },
    {
        "api_name": "_marginalize",
        "full_api_name": "_marginalize",
        "api_description": "Get the marginal counts for the given set of indices",
        "api_signature": "_marginalize(counts, indices)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/utils.py"
    },
    {
        "api_name": "_format_marginal",
        "full_api_name": "_format_marginal",
        "api_description": "Take the output of marginalize and add placeholders for\nmultiple cregs and non-indices.",
        "api_signature": "_format_marginal(counts, marg_counts, indices)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/utils.py"
    },
    {
        "api_name": "_remove_space_underscore",
        "full_api_name": "_remove_space_underscore",
        "api_description": "Removes all spaces and underscores from bitstring",
        "api_signature": "_remove_space_underscore(bitstring)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/utils.py"
    },
    {
        "api_name": "sampled_expectation_value",
        "full_api_name": "sampled_expectation_value",
        "api_description": "Computes expectation value from a sampled distribution\n\nNote that passing a raw dict requires bit-string keys.\n\nParameters:\n    dist (Counts or QuasiDistribution or ProbDistribution or dict): Input sampled distribution\n    oper (str or Pauli or PauliOp or PauliSumOp or SparsePauliOp): The operator for\n                                                                   the observable\n\nReturns:\n    float: The expectation value\nRaises:\n    QiskitError: if the input distribution or operator is an invalid type",
        "api_signature": "sampled_expectation_value(dist, oper)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/sampled_expval.py"
    },
    {
        "api_name": "_hex_to_bin",
        "full_api_name": "_hex_to_bin",
        "api_description": "Convert hexadecimal readouts (memory) to binary readouts.",
        "api_signature": "_hex_to_bin(hexstring)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/postprocess.py"
    },
    {
        "api_name": "_bin_to_hex",
        "full_api_name": "_bin_to_hex",
        "api_description": "Convert bitstring readouts (memory) to hexadecimal readouts.",
        "api_signature": "_bin_to_hex(bitstring)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/postprocess.py"
    },
    {
        "api_name": "_pad_zeros",
        "full_api_name": "_pad_zeros",
        "api_description": "If the bitstring is truncated, pad extra zeros to make its\nlength equal to memory_slots",
        "api_signature": "_pad_zeros(bitstring, memory_slots)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/postprocess.py"
    },
    {
        "api_name": "_separate_bitstring",
        "full_api_name": "_separate_bitstring",
        "api_description": "Separate a bitstring according to the registers defined in the result header.",
        "api_signature": "_separate_bitstring(bitstring, creg_sizes)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/postprocess.py"
    },
    {
        "api_name": "format_counts_memory",
        "full_api_name": "format_counts_memory",
        "api_description": "Format a single bitstring (memory) from a single shot experiment.\n\n- The hexadecimals are expanded to bitstrings\n\n- Spaces are inserted at register divisions.\n\nArgs:\n    shot_memory (str): result of a single experiment.\n    header (dict): the experiment header dictionary containing\n        useful information for postprocessing. creg_sizes\n        are a nested list where the inner element is a list\n        of creg name, creg size pairs. memory_slots is an integers\n        specifying the number of total memory_slots in the experiment.\n\nReturns:\n    dict: a formatted memory",
        "api_signature": "format_counts_memory(shot_memory, header)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/postprocess.py"
    },
    {
        "api_name": "_list_to_complex_array",
        "full_api_name": "_list_to_complex_array",
        "api_description": "Convert nested list of shape (..., 2) to complex numpy array with shape (...)\n\nArgs:\n    complex_list (list): List to convert.\n\nReturns:\n    np.ndarray: Complex numpy array\n\nRaises:\n    QiskitError: If inner most array of input nested list is not of length 2.",
        "api_signature": "_list_to_complex_array(complex_list)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/postprocess.py"
    },
    {
        "api_name": "format_level_0_memory",
        "full_api_name": "format_level_0_memory",
        "api_description": "Format an experiment result memory object for measurement level 0.\n\nArgs:\n    memory (list): Memory from experiment with `meas_level==1`. `avg` or\n        `single` will be inferred from shape of result memory.\n\nReturns:\n    np.ndarray: Measurement level 0 complex numpy array\n\nRaises:\n    QiskitError: If the returned numpy array does not have 2 (avg) or 3 (single)\n        indices.",
        "api_signature": "format_level_0_memory(memory)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/postprocess.py"
    },
    {
        "api_name": "format_level_1_memory",
        "full_api_name": "format_level_1_memory",
        "api_description": "Format an experiment result memory object for measurement level 1.\n\nArgs:\n    memory (list): Memory from experiment with `meas_level==1`. `avg` or\n        `single` will be inferred from shape of result memory.\n\nReturns:\n    np.ndarray: Measurement level 1 complex numpy array\n\nRaises:\n    QiskitError: If the returned numpy array does not have 1 (avg) or 2 (single)\n        indices.",
        "api_signature": "format_level_1_memory(memory)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/postprocess.py"
    },
    {
        "api_name": "format_level_2_memory",
        "full_api_name": "format_level_2_memory",
        "api_description": "Format an experiment result memory object for measurement level 2.\n\nArgs:\n    memory (list): Memory from experiment with `meas_level==2` and `memory==True`.\n    header (dict): the experiment header dictionary containing\n        useful information for postprocessing.\n\nReturns:\n    list[str]: List of bitstrings",
        "api_signature": "format_level_2_memory(memory, header)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/postprocess.py"
    },
    {
        "api_name": "format_counts",
        "full_api_name": "format_counts",
        "api_description": "Format a single experiment result coming from backend to present\nto the Qiskit user.\n\nArgs:\n    counts (dict): counts histogram of multiple shots\n    header (dict): the experiment header dictionary containing\n        useful information for postprocessing.\n\nReturns:\n    dict: a formatted counts",
        "api_signature": "format_counts(counts, header)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/postprocess.py"
    },
    {
        "api_name": "format_statevector",
        "full_api_name": "format_statevector",
        "api_description": "Format statevector coming from the backend to present to the Qiskit user.\n\nArgs:\n    vec (list): a list of [re, im] complex numbers.\n    decimals (int): the number of decimals in the statevector.\n        If None, no rounding is done.\n\nReturns:\n    list[complex]: a list of python complex numbers.",
        "api_signature": "format_statevector(vec, decimals)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/postprocess.py"
    },
    {
        "api_name": "format_unitary",
        "full_api_name": "format_unitary",
        "api_description": "Format unitary coming from the backend to present to the Qiskit user.\n\nArgs:\n    mat (list[list]): a list of list of [re, im] complex numbers\n    decimals (int): the number of decimals in the statevector.\n        If None, no rounding is done.\n\nReturns:\n    list[list[complex]]: a matrix of complex numbers",
        "api_signature": "format_unitary(mat, decimals)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/postprocess.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ResultError.__init__",
        "api_description": "",
        "api_signature": "__init__(self, error)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/exceptions.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "ResultError.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/exceptions.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ExperimentResultData.__init__",
        "api_description": "Initialize an ExperimentalResult Data class\n\nArgs:\n    counts (dict): A dictionary where the keys are the result in\n        hexadecimal as string of the format \"0xff\" and the value\n        is the number of counts for that result\n    snapshots (dict): A dictionary where the key is the snapshot\n        slot and the value is a dictionary of the snapshots for\n        that slot.\n    memory (list): A list of results per shot if the run had\n        memory enabled\n    statevector (list or numpy.array): A list or numpy array of the\n        statevector result\n    unitary (list or numpy.array): A list or numpy array of the\n        unitary result\n    kwargs (any): additional data key-value pairs.",
        "api_signature": "__init__(self, counts, snapshots, memory, statevector, unitary)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/models.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "ExperimentResultData.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/models.py"
    },
    {
        "api_name": "to_dict",
        "full_api_name": "ExperimentResultData.to_dict",
        "api_description": "Return a dictionary format representation of the ExperimentResultData\n\nReturns:\n    dict: The dictionary form of the ExperimentResultData",
        "api_signature": "to_dict(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/models.py"
    },
    {
        "api_name": "from_dict",
        "full_api_name": "ExperimentResultData.from_dict",
        "api_description": "Create a new ExperimentResultData object from a dictionary.\n\nArgs:\n    data (dict): A dictionary representing the ExperimentResultData to\n                 create. It will be in the same format as output by\n                 :meth:`to_dict`\nReturns:\n    ExperimentResultData: The ``ExperimentResultData`` object from the\n                          input dictionary.",
        "api_signature": "from_dict(cls, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/models.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ExperimentResult.__init__",
        "api_description": "Initialize an ExperimentResult object.\n\nArgs:\n    shots(int or tuple): if an integer the number of shots or if a\n        tuple the starting and ending shot for this data\n    success (bool): True if the experiment was successful\n    data (ExperimentResultData): The data for the experiment's\n        result\n    meas_level (int): Measurement result level\n    status (str): The status of the experiment\n    seed (int): The seed used for simulation (if run on a simulator)\n    meas_return (str): The type of measurement returned\n    header (qiskit.qobj.QobjExperimentHeader): A free form dictionary\n        header for the experiment\n    kwargs: Arbitrary extra fields\n\nRaises:\n    QiskitError: If meas_return or meas_level are not valid values",
        "api_signature": "__init__(self, shots, success, data, meas_level, status, seed, meas_return, header)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/models.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "ExperimentResult.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/models.py"
    },
    {
        "api_name": "__getattr__",
        "full_api_name": "ExperimentResult.__getattr__",
        "api_description": "",
        "api_signature": "__getattr__(self, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/models.py"
    },
    {
        "api_name": "to_dict",
        "full_api_name": "ExperimentResult.to_dict",
        "api_description": "Return a dictionary format representation of the ExperimentResult\n\nReturns:\n    dict: The dictionary form of the ExperimentResult",
        "api_signature": "to_dict(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/models.py"
    },
    {
        "api_name": "from_dict",
        "full_api_name": "ExperimentResult.from_dict",
        "api_description": "Create a new ExperimentResult object from a dictionary.\n\nArgs:\n    data (dict): A dictionary representing the ExperimentResult to\n                 create. It will be in the same format as output by\n                 :meth:`to_dict`\n\nReturns:\n    ExperimentResult: The ``ExperimentResult`` object from the input\n                      dictionary.",
        "api_signature": "from_dict(cls, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/models.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Counts.__init__",
        "api_description": "Build a counts object\n\nArgs:\n    data (dict): The dictionary input for the counts. Where the keys\n        represent a measured classical value and the value is an\n        integer the number of shots with that result.\n        The keys can be one of several formats:\n\n             * A hexadecimal string of the form ``'0x4a'``\n             * A bit string prefixed with ``0b`` for example ``'0b1011'``\n             * A bit string formatted across register and memory slots.\n               For example, ``'00 10'``.\n             * A dit string, for example ``'02'``. Note for objects created\n               with dit strings the ``creg_sizes`` and ``memory_slots``\n               kwargs don't work and :meth:`hex_outcomes` and\n               :meth:`int_outcomes` also do not work.\n\n    time_taken (float): The duration of the experiment that generated\n        the counts in seconds.\n    creg_sizes (list): a nested list where the inner element is a list\n        of tuples containing both the classical register name and\n        classical register size. For example,\n        ``[('c_reg', 2), ('my_creg', 4)]``.\n    memory_slots (int): The number of total ``memory_slots`` in the\n        experiment.\nRaises:\n    TypeError: If the input key type is not an ``int`` or ``str``.\n    QiskitError: If a dit string key is input with ``creg_sizes`` and/or\n        ``memory_slots``.",
        "api_signature": "__init__(self, data, time_taken, creg_sizes, memory_slots)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/counts.py"
    },
    {
        "api_name": "most_frequent",
        "full_api_name": "Counts.most_frequent",
        "api_description": "Return the most frequent count\n\nReturns:\n    str: The bit string for the most frequent result\nRaises:\n    QiskitError: when there is >1 count with the same max counts, or\n        an empty object.",
        "api_signature": "most_frequent(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/counts.py"
    },
    {
        "api_name": "hex_outcomes",
        "full_api_name": "Counts.hex_outcomes",
        "api_description": "Return a counts dictionary with hexadecimal string keys\n\nReturns:\n    dict: A dictionary with the keys as hexadecimal strings instead of\n        bitstrings\nRaises:\n    QiskitError: If the Counts object contains counts for dit strings",
        "api_signature": "hex_outcomes(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/counts.py"
    },
    {
        "api_name": "int_outcomes",
        "full_api_name": "Counts.int_outcomes",
        "api_description": "Build a counts dictionary with integer keys instead of count strings\n\nReturns:\n    dict: A dictionary with the keys as integers instead of bitstrings\nRaises:\n    QiskitError: If the Counts object contains counts for dit strings",
        "api_signature": "int_outcomes(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/counts.py"
    },
    {
        "api_name": "_remove_space_underscore",
        "full_api_name": "Counts._remove_space_underscore",
        "api_description": "Removes all spaces and underscores from bitstring",
        "api_signature": "_remove_space_underscore(bitstring)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/counts.py"
    },
    {
        "api_name": "shots",
        "full_api_name": "Counts.shots",
        "api_description": "Return the number of shots",
        "api_signature": "shots(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/counts.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Result.__init__",
        "api_description": "",
        "api_signature": "__init__(self, backend_name, backend_version, qobj_id, job_id, success, results, date, status, header)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/result.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "Result.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/result.py"
    },
    {
        "api_name": "to_dict",
        "full_api_name": "Result.to_dict",
        "api_description": "Return a dictionary format representation of the Result\n\nReturns:\n    dict: The dictionary form of the Result",
        "api_signature": "to_dict(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/result.py"
    },
    {
        "api_name": "__getattr__",
        "full_api_name": "Result.__getattr__",
        "api_description": "",
        "api_signature": "__getattr__(self, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/result.py"
    },
    {
        "api_name": "from_dict",
        "full_api_name": "Result.from_dict",
        "api_description": "Create a new ExperimentResultData object from a dictionary.\n\nArgs:\n    data (dict): A dictionary representing the Result to create. It\n                 will be in the same format as output by\n                 :meth:`to_dict`.\nReturns:\n    Result: The ``Result`` object from the input dictionary.",
        "api_signature": "from_dict(cls, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/result.py"
    },
    {
        "api_name": "data",
        "full_api_name": "Result.data",
        "api_description": "Get the raw data for an experiment.\n\nNote this data will be a single classical and quantum register and in a\nformat required by the results schema. We recommend that most users use\nthe get_xxx method, and the data will be post-processed for the data type.\n\nArgs:\n    experiment (str or QuantumCircuit or Schedule or int or None): the index of the\n        experiment. Several types are accepted for convenience::\n        * str: the name of the experiment.\n        * QuantumCircuit: the name of the circuit instance will be used.\n        * Schedule: the name of the schedule instance will be used.\n        * int: the position of the experiment.\n        * None: if there is only one experiment, returns it.\n\nReturns:\n    dict: A dictionary of results data for an experiment. The data\n    depends on the backend it ran on and the settings of `meas_level`,\n    `meas_return` and `memory`.\n\n    OpenQASM backends return a dictionary of dictionary with the key\n    'counts' and  with the counts, with the second dictionary keys\n    containing a string in hex format (``0x123``) and values equal to\n    the number of times this outcome was measured.\n\n    Statevector backends return a dictionary with key 'statevector' and\n    values being a list[list[complex components]] list of 2^num_qubits\n    complex amplitudes. Where each complex number is represented as a 2\n    entry list for each component. For example, a list of\n    [0.5+1j, 0-1j] would be represented as [[0.5, 1], [0, -1]].\n\n    Unitary backends return a dictionary with key 'unitary' and values\n    being a list[list[list[complex components]]] list of\n    2^num_qubits x 2^num_qubits complex amplitudes in a two entry list for\n    each component. For example if the amplitude is\n    [[0.5+0j, 0-1j], ...] the value returned will be\n    [[[0.5, 0], [0, -1]], ...].\n\n    The simulator backends also have an optional key 'snapshots' which\n    returns a dict of snapshots specified by the simulator backend.\n    The value is of the form dict[slot: dict[str: array]]\n    where the keys are the requested snapshot slots, and the values are\n    a dictionary of the snapshots.\n\nRaises:\n    QiskitError: if data for the experiment could not be retrieved.",
        "api_signature": "data(self, experiment)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/result.py"
    },
    {
        "api_name": "get_memory",
        "full_api_name": "Result.get_memory",
        "api_description": "Get the sequence of memory states (readouts) for each shot\nThe data from the experiment is a list of format\n['00000', '01000', '10100', '10100', '11101', '11100', '00101', ..., '01010']\n\nArgs:\n    experiment (str or QuantumCircuit or Schedule or int or None): the index of the\n        experiment, as specified by ``data()``.\n\nReturns:\n    List[str] or np.ndarray: Either the list of each outcome, formatted according to\n    registers in circuit or a complex numpy np.ndarray with shape:\n\n        ============  =============  =====\n        `meas_level`  `meas_return`  shape\n        ============  =============  =====\n        0             `single`       np.ndarray[shots, memory_slots, memory_slot_size]\n        0             `avg`          np.ndarray[memory_slots, memory_slot_size]\n        1             `single`       np.ndarray[shots, memory_slots]\n        1             `avg`          np.ndarray[memory_slots]\n        2             `memory=True`  list\n        ============  =============  =====\n\nRaises:\n    QiskitError: if there is no memory data for the circuit.",
        "api_signature": "get_memory(self, experiment)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/result.py"
    },
    {
        "api_name": "get_counts",
        "full_api_name": "Result.get_counts",
        "api_description": "Get the histogram data of an experiment.\n\nArgs:\n    experiment (str or QuantumCircuit or Schedule or int or None): the index of the\n        experiment, as specified by ``data([experiment])``.\n\nReturns:\n    dict[str, int] or list[dict[str, int]]: a dictionary or a list of\n    dictionaries. A dictionary has the counts for each qubit with\n    the keys containing a string in binary format and separated\n    according to the registers in circuit (e.g. ``0100 1110``).\n    The string is little-endian (cr[0] on the right hand side).\n\nRaises:\n    QiskitError: if there are no counts for the experiment.",
        "api_signature": "get_counts(self, experiment)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/result.py"
    },
    {
        "api_name": "get_statevector",
        "full_api_name": "Result.get_statevector",
        "api_description": "Get the final statevector of an experiment.\n\nArgs:\n    experiment (str or QuantumCircuit or Schedule or int or None): the index of the\n        experiment, as specified by ``data()``.\n    decimals (int): the number of decimals in the statevector.\n        If None, does not round.\n\nReturns:\n    list[complex]: list of 2^num_qubits complex amplitudes.\n\nRaises:\n    QiskitError: if there is no statevector for the experiment.",
        "api_signature": "get_statevector(self, experiment, decimals)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/result.py"
    },
    {
        "api_name": "get_unitary",
        "full_api_name": "Result.get_unitary",
        "api_description": "Get the final unitary of an experiment.\n\nArgs:\n    experiment (str or QuantumCircuit or Schedule or int or None): the index of the\n        experiment, as specified by ``data()``.\n    decimals (int): the number of decimals in the unitary.\n        If None, does not round.\n\nReturns:\n    list[list[complex]]: list of 2^num_qubits x 2^num_qubits complex\n        amplitudes.\n\nRaises:\n    QiskitError: if there is no unitary for the experiment.",
        "api_signature": "get_unitary(self, experiment, decimals)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/result.py"
    },
    {
        "api_name": "_get_experiment",
        "full_api_name": "Result._get_experiment",
        "api_description": "Return a single experiment result from a given key.\n\nArgs:\n    key (str or QuantumCircuit or Schedule or int or None): the index of the\n        experiment, as specified by ``data()``.\n\nReturns:\n    ExperimentResult: the results for an experiment.\n\nRaises:\n    QiskitError: if there is no data for the experiment, or an unhandled\n        error occurred while fetching the data.",
        "api_signature": "_get_experiment(self, key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/result.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QuasiDistribution.__init__",
        "api_description": "Builds a quasiprobability distribution object.\n\n.. note::\n\n    The quasiprobability values might include floating-point errors.\n    ``QuasiDistribution.__repr__`` rounds using :meth:`numpy.round`\n    and the parameter ``ndigits`` can be manipulated with the\n    class attribute ``__ndigits__``. The default is ``15``.\n\nParameters:\n    data (dict): Input quasiprobability data. Where the keys\n        represent a measured classical value and the value is a\n        float for the quasiprobability of that result.\n        The keys can be one of several formats:\n\n            * A hexadecimal string of the form ``\"0x4a\"``\n            * A bit string e.g. ``'0b1011'`` or ``\"01011\"``\n            * An integer\n\n    shots (int): Number of shots the distribution was derived from.\n    stddev_upper_bound (float): An upper bound for the standard deviation\n\nRaises:\n    TypeError: If the input keys are not a string or int\n    ValueError: If the string format of the keys is incorrect",
        "api_signature": "__init__(self, data, shots, stddev_upper_bound)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/distributions/quasi.py"
    },
    {
        "api_name": "nearest_probability_distribution",
        "full_api_name": "QuasiDistribution.nearest_probability_distribution",
        "api_description": "Takes a quasiprobability distribution and maps\nit to the closest probability distribution as defined by\nthe L2-norm.\n\nParameters:\n    return_distance (bool): Return the L2 distance between distributions.\n\nReturns:\n    ProbDistribution: Nearest probability distribution.\n    float: Euclidean (L2) distance of distributions.\n\nNotes:\n    Method from Smolin et al., Phys. Rev. Lett. 108, 070502 (2012).",
        "api_signature": "nearest_probability_distribution(self, return_distance)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/distributions/quasi.py"
    },
    {
        "api_name": "binary_probabilities",
        "full_api_name": "QuasiDistribution.binary_probabilities",
        "api_description": "Build a quasi-probabilities dictionary with binary string keys\n\nParameters:\n    num_bits (int): number of bits in the binary bitstrings (leading\n        zeros will be padded). If None, a default value will be used.\n        If keys are given as integers or strings with binary or hex prefix,\n        the default value will be derived from the largest key present.\n        If keys are given as bitstrings without prefix,\n        the default value will be derived from the largest key length.\n\nReturns:\n    dict: A dictionary where the keys are binary strings in the format\n        ``\"0110\"``",
        "api_signature": "binary_probabilities(self, num_bits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/distributions/quasi.py"
    },
    {
        "api_name": "hex_probabilities",
        "full_api_name": "QuasiDistribution.hex_probabilities",
        "api_description": "Build a quasi-probabilities dictionary with hexadecimal string keys\n\nReturns:\n    dict: A dictionary where the keys are hexadecimal strings in the\n        format ``\"0x1a\"``",
        "api_signature": "hex_probabilities(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/distributions/quasi.py"
    },
    {
        "api_name": "stddev_upper_bound",
        "full_api_name": "QuasiDistribution.stddev_upper_bound",
        "api_description": "Return an upper bound on standard deviation of expval estimator.",
        "api_signature": "stddev_upper_bound(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/distributions/quasi.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "QuasiDistribution.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/distributions/quasi.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ProbDistribution.__init__",
        "api_description": "Builds a probability distribution object.\n\nArgs:\n    data (dict): Input probability data. Where the keys\n        represent a measured classical value and the value is a\n        float for the probability of that result.\n        The keys can be one of several formats:\n\n            * A hexadecimal string of the form ``\"0x4a\"``\n            * A bit string e.g. ``'0b1011'`` or ``\"01011\"``\n            * An integer\n\n    shots (int): Number of shots the distribution was derived from.\n\nRaises:\n    TypeError: If the input keys are not a string or int\n    ValueError: If the string format of the keys is incorrect",
        "api_signature": "__init__(self, data, shots)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/distributions/probability.py"
    },
    {
        "api_name": "binary_probabilities",
        "full_api_name": "ProbDistribution.binary_probabilities",
        "api_description": "Build a probabilities dictionary with binary string keys\n\nParameters:\n    num_bits (int): number of bits in the binary bitstrings (leading\n        zeros will be padded). If None, a default value will be used.\n        If keys are given as integers or strings with binary or hex prefix,\n        the default value will be derived from the largest key present.\n        If keys are given as bitstrings without prefix,\n        the default value will be derived from the largest key length.\n\nReturns:\n    dict: A dictionary where the keys are binary strings in the format\n        ``\"0110\"``",
        "api_signature": "binary_probabilities(self, num_bits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/distributions/probability.py"
    },
    {
        "api_name": "hex_probabilities",
        "full_api_name": "ProbDistribution.hex_probabilities",
        "api_description": "Build a probabilities dictionary with hexadecimal string keys\n\nReturns:\n    dict: A dictionary where the keys are hexadecimal strings in the\n        format ``\"0x1a\"``",
        "api_signature": "hex_probabilities(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/distributions/probability.py"
    },
    {
        "api_name": "z_diagonal",
        "full_api_name": "z_diagonal",
        "api_description": "Return the diagonal for the operator :math:`Z^\\otimes n`",
        "api_signature": "z_diagonal(dim, dtype)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/mitigation/utils.py"
    },
    {
        "api_name": "expval_with_stddev",
        "full_api_name": "expval_with_stddev",
        "api_description": "Compute expectation value and standard deviation.\nArgs:\n    coeffs: array of diagonal operator coefficients.\n    probs: array of measurement probabilities.\n    shots: total number of shots to obtain probabilities.\nReturns:\n    tuple: (expval, stddev) expectation value and standard deviation.",
        "api_signature": "expval_with_stddev(coeffs, probs, shots)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/mitigation/utils.py"
    },
    {
        "api_name": "stddev",
        "full_api_name": "stddev",
        "api_description": "Calculate stddev dict",
        "api_signature": "stddev(probs, shots)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/mitigation/utils.py"
    },
    {
        "api_name": "str2diag",
        "full_api_name": "str2diag",
        "api_description": "Transform diagonal from a string to a numpy array",
        "api_signature": "str2diag(string)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/mitigation/utils.py"
    },
    {
        "api_name": "counts_to_vector",
        "full_api_name": "counts_to_vector",
        "api_description": "Transforms Counts to a probability vector",
        "api_signature": "counts_to_vector(counts, num_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/mitigation/utils.py"
    },
    {
        "api_name": "remap_qubits",
        "full_api_name": "remap_qubits",
        "api_description": "Remapping the qubits",
        "api_signature": "remap_qubits(vec, num_qubits, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/mitigation/utils.py"
    },
    {
        "api_name": "marganalize_counts",
        "full_api_name": "marganalize_counts",
        "api_description": "Marginalization of the Counts. Verify that number of clbits equals to the number of qubits.",
        "api_signature": "marganalize_counts(counts, qubit_index, qubits, clbits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/mitigation/utils.py"
    },
    {
        "api_name": "counts_probability_vector",
        "full_api_name": "counts_probability_vector",
        "api_description": "Compute a probability vector for all count outcomes.\n\nArgs:\n    counts: counts object\n    qubit_index: For each qubit, its index in the mitigator qubits list\n    qubits: qubits the count bitstrings correspond to.\n    clbits: Optional, marginalize counts to just these bits.\n\nRaises:\n    QiskitError: if qubits and clbits kwargs are not valid.\n\nReturns:\n    np.ndarray: a probability vector for all count outcomes.\n    int: Number of shots in the counts",
        "api_signature": "counts_probability_vector(counts, qubit_index, qubits, clbits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/mitigation/utils.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CorrelatedReadoutMitigator.__init__",
        "api_description": "Initialize a CorrelatedReadoutMitigator\n\nArgs:\n    assignment_matrix: readout error assignment matrix.\n    qubits: Optional, the measured physical qubits for mitigation.\n\nRaises:\n    QiskitError: matrix size does not agree with number of qubits",
        "api_signature": "__init__(self, assignment_matrix, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/mitigation/correlated_readout_mitigator.py"
    },
    {
        "api_name": "settings",
        "full_api_name": "CorrelatedReadoutMitigator.settings",
        "api_description": "Return settings.",
        "api_signature": "settings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/mitigation/correlated_readout_mitigator.py"
    },
    {
        "api_name": "expectation_value",
        "full_api_name": "CorrelatedReadoutMitigator.expectation_value",
        "api_description": "Compute the mitigated expectation value of a diagonal observable.\n\nThis computes the mitigated estimator of\n:math:`\\langle O \\rangle = \\mbox{Tr}[\\rho. O]` of a diagonal observable\n:math:`O = \\sum_{x\\in\\{0, 1\\}^n} O(x)|x\\rangle\\!\\langle x|`.\n\nArgs:\n    data: Counts object\n    diagonal: Optional, the vector of diagonal values for summing the\n              expectation value. If ``None`` the default value is\n              :math:`[1, -1]^\\otimes n`.\n    qubits: Optional, the measured physical qubits the count\n            bitstrings correspond to. If None qubits are assumed to be\n            :math:`[0, ..., n-1]`.\n    clbits: Optional, if not None marginalize counts to the specified bits.\n    shots: the number of shots.\n\nReturns:\n    (float, float): the expectation value and an upper bound of the standard deviation.\n\nAdditional Information:\n    The diagonal observable :math:`O` is input using the ``diagonal`` kwarg as\n    a list or Numpy array :math:`[O(0), ..., O(2^n -1)]`. If no diagonal is specified\n    the diagonal of the Pauli operator\n    :math`O = \\mbox{diag}(Z^{\\otimes n}) = [1, -1]^{\\otimes n}` is used.\n    The ``clbits`` kwarg is used to marginalize the input counts dictionary\n    over the specified bit-values, and the ``qubits`` kwarg is used to specify\n    which physical qubits these bit-values correspond to as\n    ``circuit.measure(qubits, clbits)``.",
        "api_signature": "expectation_value(self, data, diagonal, qubits, clbits, shots)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/mitigation/correlated_readout_mitigator.py"
    },
    {
        "api_name": "quasi_probabilities",
        "full_api_name": "CorrelatedReadoutMitigator.quasi_probabilities",
        "api_description": "Compute mitigated quasi probabilities value.\n\nArgs:\n    data: counts object\n    qubits: qubits the count bitstrings correspond to.\n    clbits: Optional, marginalize counts to just these bits.\n    shots: Optional, the total number of shots, if None shots will\n        be calculated as the sum of all counts.\n\nReturns:\n    QuasiDistribution: A dictionary containing pairs of [output, mean] where \"output\"\n        is the key in the dictionaries,\n        which is the length-N bitstring of a measured standard basis state,\n        and \"mean\" is the mean of non-zero quasi-probability estimates.",
        "api_signature": "quasi_probabilities(self, data, qubits, clbits, shots)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/mitigation/correlated_readout_mitigator.py"
    },
    {
        "api_name": "mitigation_matrix",
        "full_api_name": "CorrelatedReadoutMitigator.mitigation_matrix",
        "api_description": "Return the readout mitigation matrix for the specified qubits.\n\nThe mitigation matrix :math:`A^{-1}` is defined as the inverse of the\n:meth:`assignment_matrix` :math:`A`.\n\nArgs:\n    qubits: Optional, qubits being measured.\n\nReturns:\n    np.ndarray: the measurement error mitigation matrix :math:`A^{-1}`.",
        "api_signature": "mitigation_matrix(self, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/mitigation/correlated_readout_mitigator.py"
    },
    {
        "api_name": "assignment_matrix",
        "full_api_name": "CorrelatedReadoutMitigator.assignment_matrix",
        "api_description": "Return the readout assignment matrix for specified qubits.\n\nThe assignment matrix is the stochastic matrix :math:`A` which assigns\na noisy readout probability distribution to an ideal input\nreadout distribution: :math:`P(i|j) = \\langle i | A | j \\rangle`.\n\nArgs:\n    qubits: Optional, qubits being measured.\n\nReturns:\n    np.ndarray: the assignment matrix A.",
        "api_signature": "assignment_matrix(self, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/mitigation/correlated_readout_mitigator.py"
    },
    {
        "api_name": "_keep_indexes",
        "full_api_name": "CorrelatedReadoutMitigator._keep_indexes",
        "api_description": "",
        "api_signature": "_keep_indexes(qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/mitigation/correlated_readout_mitigator.py"
    },
    {
        "api_name": "_compute_gamma",
        "full_api_name": "CorrelatedReadoutMitigator._compute_gamma",
        "api_description": "Compute gamma for N-qubit mitigation",
        "api_signature": "_compute_gamma(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/mitigation/correlated_readout_mitigator.py"
    },
    {
        "api_name": "stddev_upper_bound",
        "full_api_name": "CorrelatedReadoutMitigator.stddev_upper_bound",
        "api_description": "Return an upper bound on standard deviation of expval estimator.\n\nArgs:\n    shots: Number of shots used for expectation value measurement.\n\nReturns:\n    float: the standard deviation upper bound.",
        "api_signature": "stddev_upper_bound(self, shots)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/mitigation/correlated_readout_mitigator.py"
    },
    {
        "api_name": "qubits",
        "full_api_name": "CorrelatedReadoutMitigator.qubits",
        "api_description": "The device qubits for this mitigator",
        "api_signature": "qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/mitigation/correlated_readout_mitigator.py"
    },
    {
        "api_name": "quasi_probabilities",
        "full_api_name": "BaseReadoutMitigator.quasi_probabilities",
        "api_description": "Convert counts to a dictionary of quasi-probabilities\n\nArgs:\n    data: Counts to be mitigated.\n    qubits: the physical qubits measured to obtain the counts clbits.\n        If None these are assumed to be qubits [0, ..., N-1]\n        for N-bit counts.\n    clbits: Optional, marginalize counts to just these bits.\n    shots: Optional, the total number of shots, if None shots will\n        be calculated as the sum of all counts.\n\nReturns:\n    QuasiDistribution: A dictionary containing pairs of [output, mean] where \"output\"\n        is the key in the dictionaries,\n        which is the length-N bitstring of a measured standard basis state,\n        and \"mean\" is the mean of non-zero quasi-probability estimates.",
        "api_signature": "quasi_probabilities(self, data, qubits, clbits, shots)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/mitigation/base_readout_mitigator.py"
    },
    {
        "api_name": "expectation_value",
        "full_api_name": "BaseReadoutMitigator.expectation_value",
        "api_description": "Calculate the expectation value of a diagonal Hermitian operator.\n\nArgs:\n    data: Counts object to be mitigated.\n    diagonal: the diagonal operator. This may either be specified\n              as a string containing I,Z,0,1 characters, or as a\n              real valued 1D array_like object supplying the full diagonal,\n              or as a dictionary, or as Callable.\n    qubits: the physical qubits measured to obtain the counts clbits.\n            If None these are assumed to be qubits [0, ..., N-1]\n            for N-bit counts.\n    clbits: Optional, marginalize counts to just these bits.\n    shots: Optional, the total number of shots, if None shots will\n        be calculated as the sum of all counts.\n\nReturns:\n    The mean and an upper bound of the standard deviation of operator\n    expectation value calculated from the current counts.",
        "api_signature": "expectation_value(self, data, diagonal, qubits, clbits, shots)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/mitigation/base_readout_mitigator.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "LocalReadoutMitigator.__init__",
        "api_description": "Initialize a LocalReadoutMitigator\n\nArgs:\n    assignment_matrices: Optional, list of single-qubit readout error assignment matrices.\n    qubits: Optional, the measured physical qubits for mitigation.\n    backend: Optional, backend name.\n\nRaises:\n    QiskitError: matrices sizes do not agree with number of qubits",
        "api_signature": "__init__(self, assignment_matrices, qubits, backend)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/mitigation/local_readout_mitigator.py"
    },
    {
        "api_name": "settings",
        "full_api_name": "LocalReadoutMitigator.settings",
        "api_description": "Return settings.",
        "api_signature": "settings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/mitigation/local_readout_mitigator.py"
    },
    {
        "api_name": "expectation_value",
        "full_api_name": "LocalReadoutMitigator.expectation_value",
        "api_description": "Compute the mitigated expectation value of a diagonal observable.\n\nThis computes the mitigated estimator of\n:math:`\\langle O \\rangle = \\mbox{Tr}[\\rho. O]` of a diagonal observable\n:math:`O = \\sum_{x\\in\\{0, 1\\}^n} O(x)|x\\rangle\\!\\langle x|`.\n\nArgs:\n    data: Counts object\n    diagonal: Optional, the vector of diagonal values for summing the\n              expectation value. If ``None`` the default value is\n              :math:`[1, -1]^\\otimes n`.\n    qubits: Optional, the measured physical qubits the count\n            bitstrings correspond to. If None qubits are assumed to be\n            :math:`[0, ..., n-1]`.\n    clbits: Optional, if not None marginalize counts to the specified bits.\n    shots: the number of shots.\n\nReturns:\n    (float, float): the expectation value and an upper bound of the standard deviation.\n\nAdditional Information:\n    The diagonal observable :math:`O` is input using the ``diagonal`` kwarg as\n    a list or Numpy array :math:`[O(0), ..., O(2^n -1)]`. If no diagonal is specified\n    the diagonal of the Pauli operator\n    :math`O = \\mbox{diag}(Z^{\\otimes n}) = [1, -1]^{\\otimes n}` is used.\n    The ``clbits`` kwarg is used to marginalize the input counts dictionary\n    over the specified bit-values, and the ``qubits`` kwarg is used to specify\n    which physical qubits these bit-values correspond to as\n    ``circuit.measure(qubits, clbits)``.",
        "api_signature": "expectation_value(self, data, diagonal, qubits, clbits, shots)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/mitigation/local_readout_mitigator.py"
    },
    {
        "api_name": "quasi_probabilities",
        "full_api_name": "LocalReadoutMitigator.quasi_probabilities",
        "api_description": "Compute mitigated quasi probabilities value.\n\nArgs:\n    data: counts object\n    qubits: qubits the count bitstrings correspond to.\n    clbits: Optional, marginalize counts to just these bits.\n    shots: Optional, the total number of shots, if None shots will\n        be calculated as the sum of all counts.\n\nReturns:\n    QuasiDistribution: A dictionary containing pairs of [output, mean] where \"output\"\n        is the key in the dictionaries,\n        which is the length-N bitstring of a measured standard basis state,\n        and \"mean\" is the mean of non-zero quasi-probability estimates.\n\nRaises:\n    QiskitError: if qubit and clbit kwargs are not valid.",
        "api_signature": "quasi_probabilities(self, data, qubits, clbits, shots)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/mitigation/local_readout_mitigator.py"
    },
    {
        "api_name": "mitigation_matrix",
        "full_api_name": "LocalReadoutMitigator.mitigation_matrix",
        "api_description": "Return the measurement mitigation matrix for the specified qubits.\n\nThe mitigation matrix :math:`A^{-1}` is defined as the inverse of the\n:meth:`assignment_matrix` :math:`A`.\n\nArgs:\n    qubits: Optional, qubits being measured for operator expval.\n            if a single int is given, it is assumed to be the index\n            of the qubit in self._qubits\n\nReturns:\n    np.ndarray: the measurement error mitigation matrix :math:`A^{-1}`.",
        "api_signature": "mitigation_matrix(self, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/mitigation/local_readout_mitigator.py"
    },
    {
        "api_name": "assignment_matrix",
        "full_api_name": "LocalReadoutMitigator.assignment_matrix",
        "api_description": "Return the measurement assignment matrix for specified qubits.\n\nThe assignment matrix is the stochastic matrix :math:`A` which assigns\na noisy measurement probability distribution to an ideal input\nmeasurement distribution: :math:`P(i|j) = \\langle i | A | j \\rangle`.\n\nArgs:\n    qubits: Optional, qubits being measured for operator expval.\n\nReturns:\n    np.ndarray: the assignment matrix A.",
        "api_signature": "assignment_matrix(self, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/mitigation/local_readout_mitigator.py"
    },
    {
        "api_name": "_compute_gamma",
        "full_api_name": "LocalReadoutMitigator._compute_gamma",
        "api_description": "Compute gamma for N-qubit mitigation",
        "api_signature": "_compute_gamma(self, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/mitigation/local_readout_mitigator.py"
    },
    {
        "api_name": "stddev_upper_bound",
        "full_api_name": "LocalReadoutMitigator.stddev_upper_bound",
        "api_description": "Return an upper bound on standard deviation of expval estimator.\n\nArgs:\n    shots: Number of shots used for expectation value measurement.\n    qubits: qubits being measured for operator expval.\n\nReturns:\n    float: the standard deviation upper bound.",
        "api_signature": "stddev_upper_bound(self, shots, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/mitigation/local_readout_mitigator.py"
    },
    {
        "api_name": "_from_backend",
        "full_api_name": "LocalReadoutMitigator._from_backend",
        "api_description": "Calculates amats from backend properties readout_error",
        "api_signature": "_from_backend(self, backend, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/mitigation/local_readout_mitigator.py"
    },
    {
        "api_name": "qubits",
        "full_api_name": "LocalReadoutMitigator.qubits",
        "api_description": "The device qubits for this mitigator",
        "api_signature": "qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/result/mitigation/local_readout_mitigator.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BasicPrinter.__init__",
        "api_description": "Args:\n    stream (io.TextIOBase): the stream that the output will be written to.\n    indent (str): the string to use as a single indentation level.\n    chain_else_if (bool): If ``True``, then constructs of the form::\n\n            if (x == 0) {\n                // ...\n            } else {\n                if (x == 1) {\n                    // ...\n                } else {\n                    // ...\n                }\n            }\n\n        will be collapsed into the equivalent but flatter::\n\n            if (x == 0) {\n                // ...\n            } else if (x == 1) {\n                // ...\n            } else {\n                // ...\n            }\n\n        This collapsed form may have less support on backends, so it is turned off by\n        default.  While the output of this printer is always unambiguous, using ``else``\n        without immediately opening an explicit scope with ``{ }`` in nested contexts can\n        cause issues, in the general case, which is why it is sometimes less supported.",
        "api_signature": "__init__(self, stream)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "visit",
        "full_api_name": "BasicPrinter.visit",
        "api_description": "Visit this node of the AST, printing it out to the stream in this class instance.\n\nNormally, you will want to call this function on a complete :obj:`~qiskit.qasm3.ast.Program`\nnode, to print out a complete program to the stream.  The visit can start from any node,\nhowever, if you want to build up a file bit-by-bit manually.\n\nArgs:\n    node (ASTNode): the node to convert to OpenQASM 3 and write out to the stream.\n\nRaises:\n    RuntimeError: if an AST node is encountered that the visitor is unable to parse.  This\n        typically means that the given AST was malformed.",
        "api_signature": "visit(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_start_line",
        "full_api_name": "BasicPrinter._start_line",
        "api_description": "",
        "api_signature": "_start_line(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_end_statement",
        "full_api_name": "BasicPrinter._end_statement",
        "api_description": "",
        "api_signature": "_end_statement(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_end_line",
        "full_api_name": "BasicPrinter._end_line",
        "api_description": "",
        "api_signature": "_end_line(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_write_statement",
        "full_api_name": "BasicPrinter._write_statement",
        "api_description": "",
        "api_signature": "_write_statement(self, line)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_sequence",
        "full_api_name": "BasicPrinter._visit_sequence",
        "api_description": "",
        "api_signature": "_visit_sequence(self, nodes)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_Program",
        "full_api_name": "BasicPrinter._visit_Program",
        "api_description": "",
        "api_signature": "_visit_Program(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_Header",
        "full_api_name": "BasicPrinter._visit_Header",
        "api_description": "",
        "api_signature": "_visit_Header(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_Version",
        "full_api_name": "BasicPrinter._visit_Version",
        "api_description": "",
        "api_signature": "_visit_Version(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_Include",
        "full_api_name": "BasicPrinter._visit_Include",
        "api_description": "",
        "api_signature": "_visit_Include(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_Pragma",
        "full_api_name": "BasicPrinter._visit_Pragma",
        "api_description": "",
        "api_signature": "_visit_Pragma(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_CalibrationGrammarDeclaration",
        "full_api_name": "BasicPrinter._visit_CalibrationGrammarDeclaration",
        "api_description": "",
        "api_signature": "_visit_CalibrationGrammarDeclaration(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_FloatType",
        "full_api_name": "BasicPrinter._visit_FloatType",
        "api_description": "",
        "api_signature": "_visit_FloatType(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_BoolType",
        "full_api_name": "BasicPrinter._visit_BoolType",
        "api_description": "",
        "api_signature": "_visit_BoolType(self, _node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_IntType",
        "full_api_name": "BasicPrinter._visit_IntType",
        "api_description": "",
        "api_signature": "_visit_IntType(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_UintType",
        "full_api_name": "BasicPrinter._visit_UintType",
        "api_description": "",
        "api_signature": "_visit_UintType(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_BitType",
        "full_api_name": "BasicPrinter._visit_BitType",
        "api_description": "",
        "api_signature": "_visit_BitType(self, _node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_BitArrayType",
        "full_api_name": "BasicPrinter._visit_BitArrayType",
        "api_description": "",
        "api_signature": "_visit_BitArrayType(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_StringifyAndPray",
        "full_api_name": "BasicPrinter._visit_StringifyAndPray",
        "api_description": "",
        "api_signature": "_visit_StringifyAndPray(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_Identifier",
        "full_api_name": "BasicPrinter._visit_Identifier",
        "api_description": "",
        "api_signature": "_visit_Identifier(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_SubscriptedIdentifier",
        "full_api_name": "BasicPrinter._visit_SubscriptedIdentifier",
        "api_description": "",
        "api_signature": "_visit_SubscriptedIdentifier(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_Constant",
        "full_api_name": "BasicPrinter._visit_Constant",
        "api_description": "",
        "api_signature": "_visit_Constant(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_Range",
        "full_api_name": "BasicPrinter._visit_Range",
        "api_description": "",
        "api_signature": "_visit_Range(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_IndexSet",
        "full_api_name": "BasicPrinter._visit_IndexSet",
        "api_description": "",
        "api_signature": "_visit_IndexSet(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_QuantumMeasurement",
        "full_api_name": "BasicPrinter._visit_QuantumMeasurement",
        "api_description": "",
        "api_signature": "_visit_QuantumMeasurement(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_QuantumMeasurementAssignment",
        "full_api_name": "BasicPrinter._visit_QuantumMeasurementAssignment",
        "api_description": "",
        "api_signature": "_visit_QuantumMeasurementAssignment(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_QuantumReset",
        "full_api_name": "BasicPrinter._visit_QuantumReset",
        "api_description": "",
        "api_signature": "_visit_QuantumReset(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_QuantumDelay",
        "full_api_name": "BasicPrinter._visit_QuantumDelay",
        "api_description": "",
        "api_signature": "_visit_QuantumDelay(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_IntegerLiteral",
        "full_api_name": "BasicPrinter._visit_IntegerLiteral",
        "api_description": "",
        "api_signature": "_visit_IntegerLiteral(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_BooleanLiteral",
        "full_api_name": "BasicPrinter._visit_BooleanLiteral",
        "api_description": "",
        "api_signature": "_visit_BooleanLiteral(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_BitstringLiteral",
        "full_api_name": "BasicPrinter._visit_BitstringLiteral",
        "api_description": "",
        "api_signature": "_visit_BitstringLiteral(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_DurationLiteral",
        "full_api_name": "BasicPrinter._visit_DurationLiteral",
        "api_description": "",
        "api_signature": "_visit_DurationLiteral(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_Designator",
        "full_api_name": "BasicPrinter._visit_Designator",
        "api_description": "",
        "api_signature": "_visit_Designator(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_Unary",
        "full_api_name": "BasicPrinter._visit_Unary",
        "api_description": "",
        "api_signature": "_visit_Unary(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_Binary",
        "full_api_name": "BasicPrinter._visit_Binary",
        "api_description": "",
        "api_signature": "_visit_Binary(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_Cast",
        "full_api_name": "BasicPrinter._visit_Cast",
        "api_description": "",
        "api_signature": "_visit_Cast(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_Index",
        "full_api_name": "BasicPrinter._visit_Index",
        "api_description": "",
        "api_signature": "_visit_Index(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_ClassicalDeclaration",
        "full_api_name": "BasicPrinter._visit_ClassicalDeclaration",
        "api_description": "",
        "api_signature": "_visit_ClassicalDeclaration(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_AssignmentStatement",
        "full_api_name": "BasicPrinter._visit_AssignmentStatement",
        "api_description": "",
        "api_signature": "_visit_AssignmentStatement(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_IODeclaration",
        "full_api_name": "BasicPrinter._visit_IODeclaration",
        "api_description": "",
        "api_signature": "_visit_IODeclaration(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_QuantumDeclaration",
        "full_api_name": "BasicPrinter._visit_QuantumDeclaration",
        "api_description": "",
        "api_signature": "_visit_QuantumDeclaration(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_AliasStatement",
        "full_api_name": "BasicPrinter._visit_AliasStatement",
        "api_description": "",
        "api_signature": "_visit_AliasStatement(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_QuantumGateModifier",
        "full_api_name": "BasicPrinter._visit_QuantumGateModifier",
        "api_description": "",
        "api_signature": "_visit_QuantumGateModifier(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_QuantumGateCall",
        "full_api_name": "BasicPrinter._visit_QuantumGateCall",
        "api_description": "",
        "api_signature": "_visit_QuantumGateCall(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_QuantumBarrier",
        "full_api_name": "BasicPrinter._visit_QuantumBarrier",
        "api_description": "",
        "api_signature": "_visit_QuantumBarrier(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_ProgramBlock",
        "full_api_name": "BasicPrinter._visit_ProgramBlock",
        "api_description": "",
        "api_signature": "_visit_ProgramBlock(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_ReturnStatement",
        "full_api_name": "BasicPrinter._visit_ReturnStatement",
        "api_description": "",
        "api_signature": "_visit_ReturnStatement(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_QuantumGateDefinition",
        "full_api_name": "BasicPrinter._visit_QuantumGateDefinition",
        "api_description": "",
        "api_signature": "_visit_QuantumGateDefinition(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_CalibrationDefinition",
        "full_api_name": "BasicPrinter._visit_CalibrationDefinition",
        "api_description": "",
        "api_signature": "_visit_CalibrationDefinition(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_BreakStatement",
        "full_api_name": "BasicPrinter._visit_BreakStatement",
        "api_description": "",
        "api_signature": "_visit_BreakStatement(self, _node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_ContinueStatement",
        "full_api_name": "BasicPrinter._visit_ContinueStatement",
        "api_description": "",
        "api_signature": "_visit_ContinueStatement(self, _node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_BranchingStatement",
        "full_api_name": "BasicPrinter._visit_BranchingStatement",
        "api_description": "",
        "api_signature": "_visit_BranchingStatement(self, node, chained)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_ForLoopStatement",
        "full_api_name": "BasicPrinter._visit_ForLoopStatement",
        "api_description": "",
        "api_signature": "_visit_ForLoopStatement(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_WhileLoopStatement",
        "full_api_name": "BasicPrinter._visit_WhileLoopStatement",
        "api_description": "",
        "api_signature": "_visit_WhileLoopStatement(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_SwitchStatement",
        "full_api_name": "BasicPrinter._visit_SwitchStatement",
        "api_description": "",
        "api_signature": "_visit_SwitchStatement(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_SwitchStatementPreview",
        "full_api_name": "BasicPrinter._visit_SwitchStatementPreview",
        "api_description": "",
        "api_signature": "_visit_SwitchStatementPreview(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "_visit_DefaultCase",
        "full_api_name": "BasicPrinter._visit_DefaultCase",
        "api_description": "",
        "api_signature": "_visit_DefaultCase(self, _node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/printer.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Pragma.__init__",
        "api_description": "",
        "api_signature": "__init__(self, content)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CalibrationGrammarDeclaration.__init__",
        "api_description": "",
        "api_signature": "__init__(self, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Program.__init__",
        "api_description": "",
        "api_signature": "__init__(self, header, statements)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Header.__init__",
        "api_description": "",
        "api_signature": "__init__(self, version, includes)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Include.__init__",
        "api_description": "",
        "api_signature": "__init__(self, filename)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Version.__init__",
        "api_description": "",
        "api_signature": "__init__(self, version_number)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "IntType.__init__",
        "api_description": "",
        "api_signature": "__init__(self, size)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "UintType.__init__",
        "api_description": "",
        "api_signature": "__init__(self, size)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BitArrayType.__init__",
        "api_description": "",
        "api_signature": "__init__(self, size)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "StringifyAndPray.__init__",
        "api_description": "",
        "api_signature": "__init__(self, obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Range.__init__",
        "api_description": "",
        "api_signature": "__init__(self, start, end, step)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Identifier.__init__",
        "api_description": "",
        "api_signature": "__init__(self, string)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SubscriptedIdentifier.__init__",
        "api_description": "",
        "api_signature": "__init__(self, string, subscript)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "IntegerLiteral.__init__",
        "api_description": "",
        "api_signature": "__init__(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BooleanLiteral.__init__",
        "api_description": "",
        "api_signature": "__init__(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BitstringLiteral.__init__",
        "api_description": "",
        "api_signature": "__init__(self, value, width)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "DurationLiteral.__init__",
        "api_description": "",
        "api_signature": "__init__(self, value, unit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "__init__",
        "api_description": "",
        "api_signature": "__init__(self, op, operand)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "__init__",
        "api_description": "",
        "api_signature": "__init__(self, op, left, right)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Cast.__init__",
        "api_description": "",
        "api_signature": "__init__(self, type, operand)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Index.__init__",
        "api_description": "",
        "api_signature": "__init__(self, target, index)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "IndexSet.__init__",
        "api_description": "",
        "api_signature": "__init__(self, values)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QuantumMeasurement.__init__",
        "api_description": "",
        "api_signature": "__init__(self, identifierList)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QuantumMeasurementAssignment.__init__",
        "api_description": "",
        "api_signature": "__init__(self, identifier, quantumMeasurement)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Designator.__init__",
        "api_description": "",
        "api_signature": "__init__(self, expression)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ClassicalDeclaration.__init__",
        "api_description": "",
        "api_signature": "__init__(self, type_, identifier, initializer)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "AssignmentStatement.__init__",
        "api_description": "",
        "api_signature": "__init__(self, lvalue, rvalue)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QuantumDeclaration.__init__",
        "api_description": "",
        "api_signature": "__init__(self, identifier, designator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "AliasStatement.__init__",
        "api_description": "",
        "api_signature": "__init__(self, identifier, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QuantumGateModifier.__init__",
        "api_description": "",
        "api_signature": "__init__(self, modifier, argument)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QuantumGateCall.__init__",
        "api_description": "",
        "api_signature": "__init__(self, quantumGateName, indexIdentifierList, parameters, modifiers)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QuantumBarrier.__init__",
        "api_description": "",
        "api_signature": "__init__(self, indexIdentifierList)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QuantumReset.__init__",
        "api_description": "",
        "api_signature": "__init__(self, identifier)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QuantumDelay.__init__",
        "api_description": "",
        "api_signature": "__init__(self, duration, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ProgramBlock.__init__",
        "api_description": "",
        "api_signature": "__init__(self, statements)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ReturnStatement.__init__",
        "api_description": "",
        "api_signature": "__init__(self, expression)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QuantumGateDefinition.__init__",
        "api_description": "",
        "api_signature": "__init__(self, name, params, qubits, body)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SubroutineDefinition.__init__",
        "api_description": "",
        "api_signature": "__init__(self, identifier, subroutineBlock, arguments)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CalibrationDefinition.__init__",
        "api_description": "",
        "api_signature": "__init__(self, name, identifierList, calibrationArgumentList)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BranchingStatement.__init__",
        "api_description": "",
        "api_signature": "__init__(self, condition, true_body, false_body)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ForLoopStatement.__init__",
        "api_description": "",
        "api_signature": "__init__(self, indexset, parameter, body)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "WhileLoopStatement.__init__",
        "api_description": "",
        "api_signature": "__init__(self, condition, body)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "IODeclaration.__init__",
        "api_description": "",
        "api_signature": "__init__(self, modifier, type_, identifier)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SwitchStatementPreview.__init__",
        "api_description": "",
        "api_signature": "__init__(self, target, cases)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SwitchStatement.__init__",
        "api_description": "",
        "api_signature": "__init__(self, target, cases, default)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/ast.py"
    },
    {
        "api_name": "dumps",
        "full_api_name": "dumps",
        "api_description": "Serialize a :class:`~qiskit.circuit.QuantumCircuit` object in an OpenQASM 3 string.\n\nArgs:\n    circuit (QuantumCircuit): Circuit to serialize.\n    **kwargs: Arguments for the :obj:`.Exporter` constructor.\n\nReturns:\n    str: The OpenQASM 3 serialization",
        "api_signature": "dumps(circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/__init__.py"
    },
    {
        "api_name": "dump",
        "full_api_name": "dump",
        "api_description": "Serialize a :class:`~qiskit.circuit.QuantumCircuit` object as an OpenQASM 3 stream to\nfile-like object.\n\nArgs:\n    circuit (QuantumCircuit): Circuit to serialize.\n    stream (TextIOBase): stream-like object to dump the OpenQASM 3 serialization\n    **kwargs: Arguments for the :obj:`.Exporter` constructor.",
        "api_signature": "dump(circuit, stream)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/__init__.py"
    },
    {
        "api_name": "load",
        "full_api_name": "load",
        "api_description": "Load an OpenQASM 3 program from the file ``filename``.\n\nArgs:\n    filename: the filename to load the program from.\n\nReturns:\n    QuantumCircuit: a circuit representation of the OpenQASM 3 program.\n\nRaises:\n    QASM3ImporterError: if the OpenQASM 3 file is invalid, or cannot be represented by a\n        :class:`.QuantumCircuit`.",
        "api_signature": "load(filename)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/__init__.py"
    },
    {
        "api_name": "loads",
        "full_api_name": "loads",
        "api_description": "Load an OpenQASM 3 program from the given string.\n\nArgs:\n    program: the OpenQASM 3 program.\n\nReturns:\n    QuantumCircuit: a circuit representation of the OpenQASM 3 program.\n\nRaises:\n    QASM3ImporterError: if the OpenQASM 3 file is invalid, or cannot be represented by a\n        :class:`.QuantumCircuit`.",
        "api_signature": "loads(program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/__init__.py"
    },
    {
        "api_name": "loads_experimental",
        "full_api_name": "loads_experimental",
        "api_description": "<overridden by functools.wraps>",
        "api_signature": "loads_experimental()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/__init__.py"
    },
    {
        "api_name": "load_experimental",
        "full_api_name": "load_experimental",
        "api_description": "<overridden by functools.wraps>",
        "api_signature": "load_experimental()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/__init__.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Exporter.__init__",
        "api_description": "Args:\n    includes: the filenames that should be emitted as includes.  These files will be parsed\n        for gates, and any objects dumped from this exporter will use those definitions\n        where possible.\n    basis_gates: the basic defined gate set of the backend.\n    disable_constants: if ``True``, always emit floating-point constants for numeric\n        parameter values.  If ``False`` (the default), then values close to multiples of\n        OpenQASM 3 constants (``pi``, ``euler``, and ``tau``) will be emitted in terms of those\n        constants instead, potentially improving accuracy in the output.\n    alias_classical_registers: If ``True``, then bits may be contained in more than one\n        register.  If so, the registers will be emitted using \"alias\" definitions, which\n        might not be well supported by consumers of OpenQASM 3.\n\n        .. seealso::\n            Parameter ``allow_aliasing``\n                A value for ``allow_aliasing`` overrides any value given here, and\n                supersedes this parameter.\n    allow_aliasing: If ``True``, then bits may be contained in more than one register.  If\n        so, the registers will be emitted using \"alias\" definitions, which might not be\n        well supported by consumers of OpenQASM 3.  Defaults to ``False`` or the value of\n        ``alias_classical_registers``.\n\n        .. versionadded:: 0.25.0\n    indent: the indentation string to use for each level within an indented block.  Can be\n        set to the empty string to disable indentation.\n    experimental: any experimental features to enable during the export.  See\n        :class:`ExperimentalFeatures` for more details.",
        "api_signature": "__init__(self, includes, basis_gates, disable_constants, alias_classical_registers, allow_aliasing, indent, experimental)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "dumps",
        "full_api_name": "Exporter.dumps",
        "api_description": "Convert the circuit to OpenQASM 3, returning the result as a string.",
        "api_signature": "dumps(self, circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "dump",
        "full_api_name": "Exporter.dump",
        "api_description": "Convert the circuit to OpenQASM 3, dumping the result to a file or text stream.",
        "api_signature": "dump(self, circuit, stream)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SymbolTable.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "push_scope",
        "full_api_name": "SymbolTable.push_scope",
        "api_description": "Enter a new variable scope.",
        "api_signature": "push_scope(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "pop_scope",
        "full_api_name": "SymbolTable.pop_scope",
        "api_description": "Exit the current scope, returning to a previous scope.",
        "api_signature": "pop_scope(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "new_context",
        "full_api_name": "SymbolTable.new_context",
        "api_description": "Create a new context, such as for a gate definition.\n\nContexts share the same set of globally defined gates, but have no access to other variables\ndefined in any scope.",
        "api_signature": "new_context(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "symbol_defined",
        "full_api_name": "SymbolTable.symbol_defined",
        "api_description": "Whether this identifier has a defined meaning already.",
        "api_signature": "symbol_defined(self, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "can_shadow_symbol",
        "full_api_name": "SymbolTable.can_shadow_symbol",
        "api_description": "Whether a new definition of this symbol can be made within the OpenQASM 3 shadowing\nrules.",
        "api_signature": "can_shadow_symbol(self, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "escaped_declarable_name",
        "full_api_name": "SymbolTable.escaped_declarable_name",
        "api_description": "Get an identifier based on ``name`` that can be safely shadowed within this scope.\n\nIf ``unique`` is ``True``, then the name is required to be unique across all live scopes,\nnot just able to be redefined.",
        "api_signature": "escaped_declarable_name(self, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "register_variable",
        "full_api_name": "SymbolTable.register_variable",
        "api_description": "Register a variable in the symbol table for the given scope, returning the name that\nshould be used to refer to the variable.  The same name will be returned by subsequent calls\nto :meth:`get_variable` within the same scope.\n\nArgs:\n    name: the name to base the identifier on.\n    variable: the Qiskit object this refers to.  This can be ``None`` in the case of\n        reserving a dummy variable name that does not actually have a Qiskit object backing\n        it.\n    allow_rename: whether to allow the name to be mutated to escape it and/or make it safe\n        to define (avoiding keywords, subject to shadowing rules, etc).\n    force_global: force this declaration to be in the global scope.\n    allow_hardware_qubit: whether to allow hardware qubits to pass through as identifiers.\n        Hardware qubits are a dollar sign followed by a non-negative integer, and cannot be\n        declared, so are not suitable identifiers for most objects.",
        "api_signature": "register_variable(self, name, variable)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "set_object_ident",
        "full_api_name": "SymbolTable.set_object_ident",
        "api_description": "Set the identifier used to refer to a given object for this scope.\n\nThis overwrites any previously set identifier, such as during the original registration.\n\nThis is generally only useful for tracking \"sub\" objects, like bits out of a register, which\nwill have an `SubscriptedIdentifier` as their identifier.",
        "api_signature": "set_object_ident(self, ident, variable)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "get_variable",
        "full_api_name": "SymbolTable.get_variable",
        "api_description": "Lookup a non-gate variable in the symbol table.",
        "api_signature": "get_variable(self, variable)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "register_gate_without_definition",
        "full_api_name": "SymbolTable.register_gate_without_definition",
        "api_description": "Register a gate that does not require an OQ3 definition.\n\nIf the ``gate`` is given, it will be used to validate that a call to it is compatible (such\nas a known gate from an included file).  If it is not given, it is treated as a user-defined\n\"basis gate\" that assumes that all calling signatures are valid and that all gates of this\nname are exactly compatible, which is somewhat dangerous.",
        "api_signature": "register_gate_without_definition(self, name, gate)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "register_gate",
        "full_api_name": "SymbolTable.register_gate",
        "api_description": "Register the given gate in the symbol table, using the given components to build up the\nfull AST definition.",
        "api_signature": "register_gate(self, name, source, params, qubits, body)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "get_gate",
        "full_api_name": "SymbolTable.get_gate",
        "api_description": "Lookup the identifier for a given `Gate`, if it exists.",
        "api_signature": "get_gate(self, gate)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "_gate_canonical_form",
        "full_api_name": "_gate_canonical_form",
        "api_description": "Get the canonical form of a gate.\n\nThis is the gate object that should be used to provide the OpenQASM 3 definition of a gate (but\nnot the call site; that's the input object).  This lets us return a re-parametrised gate in\nterms of general parameters, in cases where we can be sure that that is valid.  This is\ncurrently only Qiskit standard gates.  This lets multiple call-site gates match the same symbol,\nin the case of parametric gates.\n\nThe definition source provides the number of qubits, the parameter signature and the body of the\n`gate` statement.  It does not provide the name of the symbol being defined.",
        "api_signature": "_gate_canonical_form(gate)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QASM3Builder.__init__",
        "api_description": "",
        "api_signature": "__init__(self, quantumcircuit, includeslist, basis_gates, disable_constants, allow_aliasing, experimental)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "new_scope",
        "full_api_name": "QASM3Builder.new_scope",
        "api_description": "Context manager that pushes a new scope (like a ``for`` or ``while`` loop body) onto the\ncurrent context stack.",
        "api_signature": "new_scope(self, circuit, qubits, clbits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "new_context",
        "full_api_name": "QASM3Builder.new_context",
        "api_description": "Push a new context (like for a ``gate`` or ``def`` body) onto the stack.",
        "api_signature": "new_context(self, body)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "_lookup_variable",
        "full_api_name": "QASM3Builder._lookup_variable",
        "api_description": "Lookup a Qiskit object within the current context, and return the name that should be\nused to represent it in OpenQASM 3 programmes.",
        "api_signature": "_lookup_variable(self, variable)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "build_program",
        "full_api_name": "QASM3Builder.build_program",
        "api_description": "Builds a Program",
        "api_signature": "build_program(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "build_includes",
        "full_api_name": "QASM3Builder.build_includes",
        "api_description": "Builds a list of included files.",
        "api_signature": "build_includes(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "define_gate",
        "full_api_name": "QASM3Builder.define_gate",
        "api_description": "Define a gate in the symbol table, including building the gate-definition statement for\nit.\n\nThis recurses through gate-definition statements.",
        "api_signature": "define_gate(self, gate)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "assert_global_scope",
        "full_api_name": "QASM3Builder.assert_global_scope",
        "api_description": "Raise an error if we are not in the global scope, as a defensive measure.",
        "api_signature": "assert_global_scope(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "hoist_global_parameter_declarations",
        "full_api_name": "QASM3Builder.hoist_global_parameter_declarations",
        "api_description": "Extend ``self._global_io_declarations`` and ``self._global_classical_declarations`` with\nany implicit declarations used to support the early IBM efforts to use :class:`.Parameter`\nas an input variable.",
        "api_signature": "hoist_global_parameter_declarations(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "hoist_classical_register_declarations",
        "full_api_name": "QASM3Builder.hoist_classical_register_declarations",
        "api_description": "Extend the global classical declarations with AST nodes declaring all the global-scope\ncircuit :class:`.Clbit` and :class:`.ClassicalRegister` instances.  Qiskit's data model\ndoesn't involve the declaration of *new* bits or registers in inner scopes; only the\n:class:`.expr.Var` mechanism allows that.\n\nThe behavior of this function depends on the setting ``allow_aliasing``. If this\nis ``True``, then the output will be in the same form as the output of\n:meth:`.build_classical_declarations`, with the registers being aliases.  If ``False``, it\nwill instead return a :obj:`.ast.ClassicalDeclaration` for each classical register, and one\nfor the loose :obj:`.Clbit` instances, and will raise :obj:`QASM3ExporterError` if any\nregisters overlap.",
        "api_signature": "hoist_classical_register_declarations(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "hoist_classical_io_var_declarations",
        "full_api_name": "QASM3Builder.hoist_classical_io_var_declarations",
        "api_description": "Hoist the declarations of classical IO :class:`.expr.Var` nodes into the global state.\n\nLocal :class:`.expr.Var` declarations are handled by the regular local-block scope builder,\nand the :class:`.QuantumCircuit` data model ensures that the only time an IO variable can\noccur is in an outermost block.",
        "api_signature": "hoist_classical_io_var_declarations(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "build_quantum_declarations",
        "full_api_name": "QASM3Builder.build_quantum_declarations",
        "api_description": "Return a list of AST nodes declaring all the qubits in the current scope, and all the\nalias declarations for these qubits.",
        "api_signature": "build_quantum_declarations(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "build_aliases",
        "full_api_name": "QASM3Builder.build_aliases",
        "api_description": "Return a list of alias declarations for the given registers.  The registers can be either\nclassical or quantum.",
        "api_signature": "build_aliases(self, registers)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "build_current_scope",
        "full_api_name": "QASM3Builder.build_current_scope",
        "api_description": "Build the instructions that occur in the current scope.\n\nIn addition to everything literally in the circuit's ``data`` field, this also includes\ndeclarations for any local :class:`.expr.Var` nodes.",
        "api_signature": "build_current_scope(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "build_if_statement",
        "full_api_name": "QASM3Builder.build_if_statement",
        "api_description": "Build an :obj:`.IfElseOp` into a :obj:`.ast.BranchingStatement`.",
        "api_signature": "build_if_statement(self, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "build_switch_statement",
        "full_api_name": "QASM3Builder.build_switch_statement",
        "api_description": "Build a :obj:`.SwitchCaseOp` into a :class:`.ast.SwitchStatement`.",
        "api_signature": "build_switch_statement(self, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "case",
        "full_api_name": "QASM3Builder.case",
        "api_description": "",
        "api_signature": "case(values, case_block)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "build_while_loop",
        "full_api_name": "QASM3Builder.build_while_loop",
        "api_description": "Build a :obj:`.WhileLoopOp` into a :obj:`.ast.WhileLoopStatement`.",
        "api_signature": "build_while_loop(self, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "build_for_loop",
        "full_api_name": "QASM3Builder.build_for_loop",
        "api_description": "Build a :obj:`.ForLoopOp` into a :obj:`.ast.ForLoopStatement`.",
        "api_signature": "build_for_loop(self, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "build_expression",
        "full_api_name": "QASM3Builder.build_expression",
        "api_description": "Build an expression.",
        "api_signature": "build_expression(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "build_delay",
        "full_api_name": "QASM3Builder.build_delay",
        "api_description": "Build a built-in delay statement.",
        "api_signature": "build_delay(self, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "build_integer",
        "full_api_name": "QASM3Builder.build_integer",
        "api_description": "Build an integer literal, raising a :obj:`.QASM3ExporterError` if the input is not\nactually an\ninteger.",
        "api_signature": "build_integer(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "_rebind_scoped_parameters",
        "full_api_name": "QASM3Builder._rebind_scoped_parameters",
        "api_description": "If the input is a :class:`.ParameterExpression`, rebind any internal\n:class:`.Parameter`\\ s so that their names match their names in the scope.  Other inputs\nare returned unchanged.",
        "api_signature": "_rebind_scoped_parameters(self, expression)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "build_gate_call",
        "full_api_name": "QASM3Builder.build_gate_call",
        "api_description": "Builds a gate-call AST node.\n\nThis will also push the gate into the symbol table (if required), including recursively\ndefining the gate blocks.",
        "api_signature": "build_gate_call(self, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "_infer_variable_declaration",
        "full_api_name": "_infer_variable_declaration",
        "api_description": "Attempt to infer what type a parameter should be declared as to work with a circuit.\n\nThis is very simplistic; it assumes all parameters are real numbers that need to be input to the\nprogram, unless one is used as a loop variable, in which case it shouldn't be declared at all,\nbecause the ``for`` loop declares it implicitly (per the Qiskit/qe-compiler reading of the\nOpenQASM spec at openqasm/openqasm@8ee55ec).\n\n.. note::\n\n    This is a hack around not having a proper type system implemented in Terra, and really this\n    whole function should be removed in favour of proper symbol-table building and lookups.\n    This function is purely to try and hack the parameters for ``for`` loops into the exporter\n    for now.\n\nArgs:\n    circuit: The global-scope circuit, which is the base of the exported program.\n    parameter: The parameter to infer the type of.\n    parameter_name: The name of the parameter to use in the declaration.\n\nReturns:\n    A suitable :obj:`.ast.ClassicalDeclaration` node, or, if the parameter should *not* be\n    declared, then ``None``.",
        "api_signature": "_infer_variable_declaration(circuit, parameter, parameter_name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "is_loop_variable",
        "full_api_name": "is_loop_variable",
        "api_description": "Recurse into the instructions a parameter is used in, checking at every level if it is\nused as the loop variable of a ``for`` loop.",
        "api_signature": "is_loop_variable(circuit, parameter)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "_lift_condition",
        "full_api_name": "_lift_condition",
        "api_description": "",
        "api_signature": "_lift_condition(condition)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "_build_ast_type",
        "full_api_name": "_build_ast_type",
        "api_description": "",
        "api_signature": "_build_ast_type(type_)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "_ExprBuilder.__init__",
        "api_description": "",
        "api_signature": "__init__(self, lookup)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "visit_var",
        "full_api_name": "_ExprBuilder.visit_var",
        "api_description": "",
        "api_signature": "visit_var()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "visit_value",
        "full_api_name": "_ExprBuilder.visit_value",
        "api_description": "",
        "api_signature": "visit_value()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "visit_cast",
        "full_api_name": "_ExprBuilder.visit_cast",
        "api_description": "",
        "api_signature": "visit_cast()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "visit_unary",
        "full_api_name": "_ExprBuilder.visit_unary",
        "api_description": "",
        "api_signature": "visit_unary()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "visit_binary",
        "full_api_name": "_ExprBuilder.visit_binary",
        "api_description": "",
        "api_signature": "visit_binary()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "visit_index",
        "full_api_name": "_ExprBuilder.visit_index",
        "api_description": "",
        "api_signature": "visit_index()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm3/exporter.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Layout.__init__",
        "api_description": "construct a Layout from a bijective dictionary, mapping\nvirtual qubits to physical qubits",
        "api_signature": "__init__(self, input_dict)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/layout.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "Layout.__repr__",
        "api_description": "Representation of a Layout",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/layout.py"
    },
    {
        "api_name": "from_dict",
        "full_api_name": "Layout.from_dict",
        "api_description": "Populates a Layout from a dictionary.\n\nThe dictionary must be a bijective mapping between\nvirtual qubits (tuple) and physical qubits (int).\n\nArgs:\n    input_dict (dict):\n        e.g.::\n\n        {(QuantumRegister(3, 'qr'), 0): 0,\n         (QuantumRegister(3, 'qr'), 1): 1,\n         (QuantumRegister(3, 'qr'), 2): 2}\n\n        Can be written more concisely as follows:\n\n        * virtual to physical::\n\n            {qr[0]: 0,\n             qr[1]: 1,\n             qr[2]: 2}\n\n        * physical to virtual::\n\n            {0: qr[0],\n             1: qr[1],\n             2: qr[2]}",
        "api_signature": "from_dict(self, input_dict)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/layout.py"
    },
    {
        "api_name": "order_based_on_type",
        "full_api_name": "Layout.order_based_on_type",
        "api_description": "decides which one is physical/virtual based on the type. Returns (virtual, physical)",
        "api_signature": "order_based_on_type(value1, value2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/layout.py"
    },
    {
        "api_name": "__getitem__",
        "full_api_name": "Layout.__getitem__",
        "api_description": "",
        "api_signature": "__getitem__(self, item)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/layout.py"
    },
    {
        "api_name": "__contains__",
        "full_api_name": "Layout.__contains__",
        "api_description": "",
        "api_signature": "__contains__(self, item)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/layout.py"
    },
    {
        "api_name": "__setitem__",
        "full_api_name": "Layout.__setitem__",
        "api_description": "",
        "api_signature": "__setitem__(self, key, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/layout.py"
    },
    {
        "api_name": "_set_type_checked_item",
        "full_api_name": "Layout._set_type_checked_item",
        "api_description": "",
        "api_signature": "_set_type_checked_item(self, virtual, physical)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/layout.py"
    },
    {
        "api_name": "__delitem__",
        "full_api_name": "Layout.__delitem__",
        "api_description": "",
        "api_signature": "__delitem__(self, key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/layout.py"
    },
    {
        "api_name": "__len__",
        "full_api_name": "Layout.__len__",
        "api_description": "",
        "api_signature": "__len__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/layout.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "Layout.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/layout.py"
    },
    {
        "api_name": "copy",
        "full_api_name": "Layout.copy",
        "api_description": "Returns a copy of a Layout instance.",
        "api_signature": "copy(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/layout.py"
    },
    {
        "api_name": "add",
        "full_api_name": "Layout.add",
        "api_description": "Adds a map element between `bit` and `physical_bit`. If `physical_bit` is not\ndefined, `bit` will be mapped to a new physical bit.\n\nArgs:\n    virtual_bit (tuple): A (qu)bit. For example, (QuantumRegister(3, 'qr'), 2).\n    physical_bit (int): A physical bit. For example, 3.",
        "api_signature": "add(self, virtual_bit, physical_bit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/layout.py"
    },
    {
        "api_name": "add_register",
        "full_api_name": "Layout.add_register",
        "api_description": "Adds at the end physical_qubits that map each bit in reg.\n\nArgs:\n    reg (Register): A (qu)bit Register. For example, QuantumRegister(3, 'qr').",
        "api_signature": "add_register(self, reg)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/layout.py"
    },
    {
        "api_name": "get_registers",
        "full_api_name": "Layout.get_registers",
        "api_description": "Returns the registers in the layout [QuantumRegister(2, 'qr0'), QuantumRegister(3, 'qr1')]\nReturns:\n    Set: A set of Registers in the layout",
        "api_signature": "get_registers(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/layout.py"
    },
    {
        "api_name": "get_virtual_bits",
        "full_api_name": "Layout.get_virtual_bits",
        "api_description": "Returns the dictionary where the keys are virtual (qu)bits and the\nvalues are physical (qu)bits.",
        "api_signature": "get_virtual_bits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/layout.py"
    },
    {
        "api_name": "get_physical_bits",
        "full_api_name": "Layout.get_physical_bits",
        "api_description": "Returns the dictionary where the keys are physical (qu)bits and the\nvalues are virtual (qu)bits.",
        "api_signature": "get_physical_bits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/layout.py"
    },
    {
        "api_name": "swap",
        "full_api_name": "Layout.swap",
        "api_description": "Swaps the map between left and right.\n\nArgs:\n    left (tuple or int): Item to swap with right.\n    right (tuple or int): Item to swap with left.\nRaises:\n    LayoutError: If left and right have not the same type.",
        "api_signature": "swap(self, left, right)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/layout.py"
    },
    {
        "api_name": "combine_into_edge_map",
        "full_api_name": "Layout.combine_into_edge_map",
        "api_description": "Combines self and another_layout into an \"edge map\".\n\nFor example::\n\n      self       another_layout  resulting edge map\n   qr_1 -> 0        0 <- q_2         qr_1 -> q_2\n   qr_2 -> 2        2 <- q_1         qr_2 -> q_1\n   qr_3 -> 3        3 <- q_0         qr_3 -> q_0\n\nThe edge map is used to compose dags via, for example, compose.\n\nArgs:\n    another_layout (Layout): The other layout to combine.\nReturns:\n    dict: A \"edge map\".\nRaises:\n    LayoutError: another_layout can be bigger than self, but not smaller.\n        Otherwise, raises.",
        "api_signature": "combine_into_edge_map(self, another_layout)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/layout.py"
    },
    {
        "api_name": "reorder_bits",
        "full_api_name": "Layout.reorder_bits",
        "api_description": "Given an ordered list of bits, reorder them according to this layout.\n\nThe list of bits must exactly match the virtual bits in this layout.\n\nArgs:\n    bits (list[Bit]): the bits to reorder.\n\nReturns:\n    List: ordered bits.",
        "api_signature": "reorder_bits(self, bits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/layout.py"
    },
    {
        "api_name": "generate_trivial_layout",
        "full_api_name": "Layout.generate_trivial_layout",
        "api_description": "Creates a trivial (\"one-to-one\") Layout with the registers and qubits in `regs`.\n\nArgs:\n    *regs (Registers, Qubits): registers and qubits to include in the layout.\nReturns:\n    Layout: A layout with all the `regs` in the given order.",
        "api_signature": "generate_trivial_layout()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/layout.py"
    },
    {
        "api_name": "from_intlist",
        "full_api_name": "Layout.from_intlist",
        "api_description": "Converts a list of integers to a Layout\nmapping virtual qubits (index of the list) to\nphysical qubits (the list values).\n\nArgs:\n    int_list (list): A list of integers.\n    *qregs (QuantumRegisters): The quantum registers to apply\n        the layout to.\nReturns:\n    Layout: The corresponding Layout object.\nRaises:\n    LayoutError: Invalid input layout.",
        "api_signature": "from_intlist(int_list)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/layout.py"
    },
    {
        "api_name": "from_qubit_list",
        "full_api_name": "Layout.from_qubit_list",
        "api_description": "Populates a Layout from a list containing virtual\nqubits, Qubit or None.\n\nArgs:\n    qubit_list (list):\n        e.g.: [qr[0], None, qr[2], qr[3]]\n    *qregs (QuantumRegisters): The quantum registers to apply\n        the layout to.\nReturns:\n    Layout: the corresponding Layout object\nRaises:\n    LayoutError: If the elements are not Qubit or None",
        "api_signature": "from_qubit_list(qubit_list)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/layout.py"
    },
    {
        "api_name": "compose",
        "full_api_name": "Layout.compose",
        "api_description": "Compose this layout with another layout.\n\nIf this layout represents a mapping from the P-qubits to the positions of the Q-qubits,\nand the other layout represents a mapping from the Q-qubits to the positions of\nthe R-qubits, then the composed layout represents a mapping from the P-qubits to the\npositions of the R-qubits.\n\nArgs:\n    other: The existing :class:`.Layout` to compose this :class:`.Layout` with.\n    qubits: A list of :class:`.Qubit` objects over which ``other`` is defined,\n        used to establish the correspondence between the positions of the ``other``\n        qubits and the actual qubits.\n\nReturns:\n    A new layout object the represents this layout composed with the ``other`` layout.",
        "api_signature": "compose(self, other, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/layout.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "Layout.inverse",
        "api_description": "Finds the inverse of this layout.\n\nThis is possible when the layout is a bijective mapping, however the input\nand the output qubits may be different (in particular, this layout may be\nthe mapping from the extended-with-ancillas virtual qubits to physical qubits).\nThus, if this layout represents a mapping from the P-qubits to the positions\nof the Q-qubits, the inverse layout represents a mapping from the Q-qubits\nto the positions of the P-qubits.\n\nArgs:\n    source_qubits: A list of :class:`.Qubit` objects representing the domain\n        of the layout.\n    target_qubits: A list of :class:`.Qubit` objects representing the image\n        of the layout.\n\nReturns:\n    A new layout object the represents the inverse of this layout.",
        "api_signature": "inverse(self, source_qubits, target_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/layout.py"
    },
    {
        "api_name": "to_permutation",
        "full_api_name": "Layout.to_permutation",
        "api_description": "Creates a permutation corresponding to this layout.\n\nThis is possible when the layout is a bijective mapping with the same\nsource and target qubits (for instance, a \"final_layout\" corresponds\nto a permutation of the physical circuit qubits). If this layout is\na mapping from qubits to their new positions, the resulting permutation\ndescribes which qubits occupy the positions 0, 1, 2, etc. after\napplying the permutation.\n\nFor example, suppose that the list of qubits is ``[qr_0, qr_1, qr_2]``,\nand the layout maps ``qr_0`` to ``2``, ``qr_1`` to ``0``, and\n``qr_2`` to ``1``. In terms of positions in ``qubits``, this maps ``0``\nto ``2``, ``1`` to ``0`` and ``2`` to ``1``, with the corresponding\npermutation being ``[1, 2, 0]``.",
        "api_signature": "to_permutation(self, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/layout.py"
    },
    {
        "api_name": "initial_virtual_layout",
        "full_api_name": "TranspileLayout.initial_virtual_layout",
        "api_description": "Return a :class:`.Layout` object for the initial layout.\n\nThis returns a mapping of virtual :class:`~.circuit.Qubit` objects in the input\ncircuit to the positions of the physical qubits selected during layout.\nThis is analogous to the :attr:`.initial_layout` attribute.\n\nArgs:\n    filter_ancillas: If set to ``True`` only qubits in the input circuit\n        will be in the returned layout. Any ancilla qubits added to the\n        output circuit will be filtered from the returned object.\nReturns:\n    A layout object mapping the input circuit's :class:`~.circuit.Qubit`\n    objects to the positions of the selected physical qubits.",
        "api_signature": "initial_virtual_layout(self, filter_ancillas)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/layout.py"
    },
    {
        "api_name": "initial_index_layout",
        "full_api_name": "TranspileLayout.initial_index_layout",
        "api_description": "Generate an initial layout as an array of integers.\n\nArgs:\n    filter_ancillas: If set to ``True`` any ancilla qubits added\n        to the transpiler will not be included in the output.\n\nReturn:\n    A layout array that maps a position in the array to its new position in the output\n    circuit.",
        "api_signature": "initial_index_layout(self, filter_ancillas)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/layout.py"
    },
    {
        "api_name": "routing_permutation",
        "full_api_name": "TranspileLayout.routing_permutation",
        "api_description": "Generate a final layout as an array of integers.\n\nIf there is no :attr:`.final_layout` attribute present then that indicates\nthere was no output permutation caused by routing or other transpiler\ntransforms. In this case the function will return a list of ``[0, 1, 2, .., n]``.\n\nReturns:\n    A layout array that maps a position in the array to its new position in the output\n    circuit.",
        "api_signature": "routing_permutation(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/layout.py"
    },
    {
        "api_name": "final_index_layout",
        "full_api_name": "TranspileLayout.final_index_layout",
        "api_description": "Generate the final layout as an array of integers.\n\nThis method will generate an array of final positions for each qubit in the input circuit.\nFor example, if you had an input circuit like::\n\n    qc = QuantumCircuit(3)\n    qc.h(0)\n    qc.cx(0, 1)\n    qc.cx(0, 2)\n\nand the output from the transpiler was::\n\n    tqc = QuantumCircuit(3)\n    tqc.h(2)\n    tqc.cx(2, 1)\n    tqc.swap(0, 1)\n    tqc.cx(2, 1)\n\nthen the :meth:`.final_index_layout` method returns::\n\n    [2, 0, 1]\n\nThis can be seen as follows. Qubit 0 in the original circuit is mapped to qubit 2\nin the output circuit during the layout stage, which is mapped to qubit 2 during the\nrouting stage. Qubit 1 in the original circuit is mapped to qubit 1 in the output\ncircuit during the layout stage, which is mapped to qubit 0 during the routing\nstage. Qubit 2 in the original circuit is mapped to qubit 0 in the output circuit\nduring the layout stage, which is mapped to qubit 1 during the routing stage.\nThe output list length will be as wide as the input circuit's number of qubits,\nas the output list from this method is for tracking the permutation of qubits in the\noriginal circuit caused by the transpiler.\n\nArgs:\n    filter_ancillas: If set to ``False`` any ancillas allocated in the output circuit will be\n        included in the layout.\n\nReturns:\n    A list of final positions for each input circuit qubit.",
        "api_signature": "final_index_layout(self, filter_ancillas)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/layout.py"
    },
    {
        "api_name": "final_virtual_layout",
        "full_api_name": "TranspileLayout.final_virtual_layout",
        "api_description": "Generate the final layout as a :class:`.Layout` object.\n\nThis method will generate an array of final positions for each qubit in the input circuit.\nFor example, if you had an input circuit like::\n\n    qc = QuantumCircuit(3)\n    qc.h(0)\n    qc.cx(0, 1)\n    qc.cx(0, 2)\n\nand the output from the transpiler was::\n\n    tqc = QuantumCircuit(3)\n    tqc.h(2)\n    tqc.cx(2, 1)\n    tqc.swap(0, 1)\n    tqc.cx(2, 1)\n\nthen the return from this function would be a layout object::\n\n    Layout({\n        qc.qubits[0]: 2,\n        qc.qubits[1]: 0,\n        qc.qubits[2]: 1,\n    })\n\nThis can be seen as follows. Qubit 0 in the original circuit is mapped to qubit 2\nin the output circuit during the layout stage, which is mapped to qubit 2 during the\nrouting stage. Qubit 1 in the original circuit is mapped to qubit 1 in the output\ncircuit during the layout stage, which is mapped to qubit 0 during the routing\nstage. Qubit 2 in the original circuit is mapped to qubit 0 in the output circuit\nduring the layout stage, which is mapped to qubit 1 during the routing stage.\nThe output list length will be as wide as the input circuit's number of qubits,\nas the output list from this method is for tracking the permutation of qubits in the\noriginal circuit caused by the transpiler.\n\nArgs:\n    filter_ancillas: If set to ``False`` any ancillas allocated in the output circuit will be\n        included in the layout.\n\nReturns:\n    A layout object mapping to the final positions for each qubit.",
        "api_signature": "final_virtual_layout(self, filter_ancillas)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/layout.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CouplingMap.__init__",
        "api_description": "Create coupling graph. By default, the generated coupling has no nodes.\n\nArgs:\n    couplinglist (list or None): An initial coupling graph, specified as\n        an adjacency list containing couplings, e.g. [[0,1], [0,2], [1,2]].\n        It is required that nodes are contiguously indexed starting at 0.\n        Missed nodes will be added as isolated nodes in the coupling map.\n    description (str): A string to describe the coupling map.",
        "api_signature": "__init__(self, couplinglist, description)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/coupling.py"
    },
    {
        "api_name": "size",
        "full_api_name": "CouplingMap.size",
        "api_description": "Return the number of physical qubits in this graph.",
        "api_signature": "size(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/coupling.py"
    },
    {
        "api_name": "get_edges",
        "full_api_name": "CouplingMap.get_edges",
        "api_description": "Gets the list of edges in the coupling graph.\n\nReturns:\n    Tuple(int,int): Each edge is a pair of physical qubits.",
        "api_signature": "get_edges(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/coupling.py"
    },
    {
        "api_name": "__iter__",
        "full_api_name": "CouplingMap.__iter__",
        "api_description": "",
        "api_signature": "__iter__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/coupling.py"
    },
    {
        "api_name": "add_physical_qubit",
        "full_api_name": "CouplingMap.add_physical_qubit",
        "api_description": "Add a physical qubit to the coupling graph as a node.\n\nphysical_qubit (int): An integer representing a physical qubit.\n\nRaises:\n    CouplingError: if trying to add duplicate qubit",
        "api_signature": "add_physical_qubit(self, physical_qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/coupling.py"
    },
    {
        "api_name": "add_edge",
        "full_api_name": "CouplingMap.add_edge",
        "api_description": "Add directed edge to coupling graph.\n\nsrc (int): source physical qubit\ndst (int): destination physical qubit",
        "api_signature": "add_edge(self, src, dst)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/coupling.py"
    },
    {
        "api_name": "physical_qubits",
        "full_api_name": "CouplingMap.physical_qubits",
        "api_description": "Returns a sorted list of physical_qubits",
        "api_signature": "physical_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/coupling.py"
    },
    {
        "api_name": "is_connected",
        "full_api_name": "CouplingMap.is_connected",
        "api_description": "Test if the graph is connected.\n\nReturn True if connected, False otherwise",
        "api_signature": "is_connected(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/coupling.py"
    },
    {
        "api_name": "neighbors",
        "full_api_name": "CouplingMap.neighbors",
        "api_description": "Return the nearest neighbors of a physical qubit.\n\nDirectionality matters, i.e. a neighbor must be reachable\nby going one hop in the direction of an edge.",
        "api_signature": "neighbors(self, physical_qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/coupling.py"
    },
    {
        "api_name": "distance_matrix",
        "full_api_name": "CouplingMap.distance_matrix",
        "api_description": "Return the distance matrix for the coupling map.\n\nFor any qubits where there isn't a path available between them the value\nin this position of the distance matrix will be ``math.inf``.",
        "api_signature": "distance_matrix(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/coupling.py"
    },
    {
        "api_name": "compute_distance_matrix",
        "full_api_name": "CouplingMap.compute_distance_matrix",
        "api_description": "Compute the full distance matrix on pairs of nodes.\n\nThe distance map self._dist_matrix is computed from the graph using\nall_pairs_shortest_path_length. This is normally handled internally\nby the :attr:`~qiskit.transpiler.CouplingMap.distance_matrix`\nattribute or the :meth:`~qiskit.transpiler.CouplingMap.distance` method\nbut can be called if you're accessing the distance matrix outside of\nthose or want to pre-generate it.",
        "api_signature": "compute_distance_matrix(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/coupling.py"
    },
    {
        "api_name": "distance",
        "full_api_name": "CouplingMap.distance",
        "api_description": "Returns the undirected distance between physical_qubit1 and physical_qubit2.\n\nArgs:\n    physical_qubit1 (int): A physical qubit\n    physical_qubit2 (int): Another physical qubit\n\nReturns:\n    int: The undirected distance\n\nRaises:\n    CouplingError: if the qubits do not exist in the CouplingMap",
        "api_signature": "distance(self, physical_qubit1, physical_qubit2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/coupling.py"
    },
    {
        "api_name": "shortest_undirected_path",
        "full_api_name": "CouplingMap.shortest_undirected_path",
        "api_description": "Returns the shortest undirected path between physical_qubit1 and physical_qubit2.\n\nArgs:\n    physical_qubit1 (int): A physical qubit\n    physical_qubit2 (int): Another physical qubit\nReturns:\n    List: The shortest undirected path\nRaises:\n    CouplingError: When there is no path between physical_qubit1, physical_qubit2.",
        "api_signature": "shortest_undirected_path(self, physical_qubit1, physical_qubit2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/coupling.py"
    },
    {
        "api_name": "is_symmetric",
        "full_api_name": "CouplingMap.is_symmetric",
        "api_description": "Test if the graph is symmetric.\n\nReturn True if symmetric, False otherwise",
        "api_signature": "is_symmetric(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/coupling.py"
    },
    {
        "api_name": "make_symmetric",
        "full_api_name": "CouplingMap.make_symmetric",
        "api_description": "Convert uni-directional edges into bi-directional.",
        "api_signature": "make_symmetric(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/coupling.py"
    },
    {
        "api_name": "_check_symmetry",
        "full_api_name": "CouplingMap._check_symmetry",
        "api_description": "Calculates symmetry\n\nReturns:\n    Bool: True if symmetric, False otherwise",
        "api_signature": "_check_symmetry(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/coupling.py"
    },
    {
        "api_name": "reduce",
        "full_api_name": "CouplingMap.reduce",
        "api_description": "Returns a reduced coupling map that\ncorresponds to the subgraph of qubits\nselected in the mapping.\n\nArgs:\n    mapping (list): A mapping of reduced qubits to device\n        qubits.\n    check_if_connected (bool): if True, checks that the reduced\n        coupling map is connected.\n\nReturns:\n    CouplingMap: A reduced coupling_map for the selected qubits.\n\nRaises:\n    CouplingError: Reduced coupling map must be connected.",
        "api_signature": "reduce(self, mapping, check_if_connected)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/coupling.py"
    },
    {
        "api_name": "from_full",
        "full_api_name": "CouplingMap.from_full",
        "api_description": "Return a fully connected coupling map on n qubits.",
        "api_signature": "from_full(cls, num_qubits, bidirectional)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/coupling.py"
    },
    {
        "api_name": "from_line",
        "full_api_name": "CouplingMap.from_line",
        "api_description": "Return a coupling map of n qubits connected in a line.",
        "api_signature": "from_line(cls, num_qubits, bidirectional)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/coupling.py"
    },
    {
        "api_name": "from_ring",
        "full_api_name": "CouplingMap.from_ring",
        "api_description": "Return a coupling map of n qubits connected to each of their neighbors in a ring.",
        "api_signature": "from_ring(cls, num_qubits, bidirectional)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/coupling.py"
    },
    {
        "api_name": "from_grid",
        "full_api_name": "CouplingMap.from_grid",
        "api_description": "Return a coupling map of qubits connected on a grid of num_rows x num_columns.",
        "api_signature": "from_grid(cls, num_rows, num_columns, bidirectional)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/coupling.py"
    },
    {
        "api_name": "from_heavy_hex",
        "full_api_name": "CouplingMap.from_heavy_hex",
        "api_description": "Return a heavy hexagon graph coupling map.\n\nA heavy hexagon graph is described in:\n\nhttps://journals.aps.org/prx/abstract/10.1103/PhysRevX.10.011022\n\nArgs:\n    distance (int): The code distance for the generated heavy hex\n        graph. The value for distance can be any odd positive integer.\n        The distance relates to the number of qubits by:\n        :math:`n = \\frac{5d^2 - 2d - 1}{2}` where :math:`n` is the\n        number of qubits and :math:`d` is the ``distance`` parameter.\n    bidirectional (bool): Whether the edges in the output coupling\n        graph are bidirectional or not. By default this is set to\n        ``True``\nReturns:\n    CouplingMap: A heavy hex coupling graph",
        "api_signature": "from_heavy_hex(cls, distance, bidirectional)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/coupling.py"
    },
    {
        "api_name": "from_heavy_square",
        "full_api_name": "CouplingMap.from_heavy_square",
        "api_description": "Return a heavy square graph coupling map.\n\nA heavy square graph is described in:\n\nhttps://journals.aps.org/prx/abstract/10.1103/PhysRevX.10.011022\n\nArgs:\n    distance (int): The code distance for the generated heavy square\n        graph. The value for distance can be any odd positive integer.\n        The distance relates to the number of qubits by:\n        :math:`n = 3d^2 - 2d` where :math:`n` is the\n        number of qubits and :math:`d` is the ``distance`` parameter.\n    bidirectional (bool): Whether the edges in the output coupling\n        graph are bidirectional or not. By default this is set to\n        ``True``\nReturns:\n    CouplingMap: A heavy square coupling graph",
        "api_signature": "from_heavy_square(cls, distance, bidirectional)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/coupling.py"
    },
    {
        "api_name": "from_hexagonal_lattice",
        "full_api_name": "CouplingMap.from_hexagonal_lattice",
        "api_description": "Return a hexagonal lattice graph coupling map.\n\nArgs:\n    rows (int): The number of rows to generate the graph with.\n    cols (int): The number of columns to generate the graph with.\n    bidirectional (bool): Whether the edges in the output coupling\n        graph are bidirectional or not. By default this is set to\n        ``True``\nReturns:\n    CouplingMap: A hexagonal lattice coupling graph",
        "api_signature": "from_hexagonal_lattice(cls, rows, cols, bidirectional)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/coupling.py"
    },
    {
        "api_name": "largest_connected_component",
        "full_api_name": "CouplingMap.largest_connected_component",
        "api_description": "Return a set of qubits in the largest connected component.",
        "api_signature": "largest_connected_component(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/coupling.py"
    },
    {
        "api_name": "connected_components",
        "full_api_name": "CouplingMap.connected_components",
        "api_description": "Separate a :Class:`~.CouplingMap` into subgraph :class:`~.CouplingMap`\nfor each connected component.\n\nThe connected components of a :class:`~.CouplingMap` are the subgraphs\nthat are not part of any larger subgraph. For example, if you had a\ncoupling map that looked like::\n\n    0 --> 1   4 --> 5 ---> 6 --> 7\n    |     |\n    |     |\n    V     V\n    2 --> 3\n\nthen the connected components of that graph are the subgraphs::\n\n    0 --> 1\n    |     |\n    |     |\n    V     V\n    2 --> 3\n\nand::\n\n    4 --> 5 ---> 6 --> 7\n\nFor a connected :class:`~.CouplingMap` object there is only a single connected\ncomponent, the entire :class:`~.CouplingMap`.\n\nThis method will return a list of :class:`~.CouplingMap` objects, one for each connected\ncomponent in this :class:`~.CouplingMap`. The data payload of each node in the\n:attr:`~.CouplingMap.graph` attribute will contain the qubit number in the original\ngraph. This will enables mapping the qubit index in a component subgraph to\nthe original qubit in the combined :class:`~.CouplingMap`. For example::\n\n    from qiskit.transpiler import CouplingMap\n\n    cmap = CouplingMap([[0, 1], [1, 2], [2, 0], [3, 4], [4, 5], [5, 3]])\n    component_cmaps = cmap.connected_components()\n    print(component_cmaps[1].graph[0])\n\nwill print ``3`` as index ``0`` in the second component is qubit 3 in the original cmap.\n\nReturns:\n    list: A list of :class:`~.CouplingMap` objects for each connected\n        components. The order of this list is deterministic but\n        implementation specific and shouldn't be relied upon as\n        part of the API.",
        "api_signature": "connected_components(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/coupling.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "CouplingMap.__str__",
        "api_description": "Return a string representation of the coupling graph.",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/coupling.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "CouplingMap.__eq__",
        "api_description": "Check if the graph in ``other`` has the same node labels and edges as the graph in\n``self``.\n\nThis function assumes that the graphs in :class:`.CouplingMap` instances are connected.\n\nArgs:\n    other (CouplingMap): The other coupling map.\n\nReturns:\n    bool: Whether or not other is isomorphic to self.",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/coupling.py"
    },
    {
        "api_name": "draw",
        "full_api_name": "CouplingMap.draw",
        "api_description": "Draws the coupling map.\n\nThis function calls the :func:`~rustworkx.visualization.graphviz_draw` function from the\n``rustworkx`` package to draw the :class:`CouplingMap` object.\n\nReturns:\n    PIL.Image: Drawn coupling map.",
        "api_signature": "draw(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/coupling.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PassManagerConfig.__init__",
        "api_description": "Initialize a PassManagerConfig object\n\nArgs:\n    initial_layout (Layout): Initial position of virtual qubits on\n        physical qubits.\n    basis_gates (list): List of basis gate names to unroll to.\n    inst_map (InstructionScheduleMap): Mapping object that maps gate to schedule.\n    coupling_map (CouplingMap): Directed graph represented a coupling\n        map.\n    layout_method (str): the pass to use for choosing initial qubit\n        placement. This will be the plugin name if an external layout stage\n        plugin is being used.\n    routing_method (str): the pass to use for routing qubits on the\n        architecture. This will be a plugin name if an external routing stage\n        plugin is being used.\n    translation_method (str): the pass to use for translating gates to\n        basis_gates. This will be a plugin name if an external translation stage\n        plugin is being used.\n    scheduling_method (str): the pass to use for scheduling instructions. This will\n        be a plugin name if an external scheduling stage plugin is being used.\n    instruction_durations (InstructionDurations): Dictionary of duration\n        (in dt) for each instruction.\n    backend_properties (BackendProperties): Properties returned by a\n        backend, including information on gate errors, readout errors,\n        qubit coherence times, etc.\n    approximation_degree (float): heuristic dial used for circuit approximation\n        (1.0=no approximation, 0.0=maximal approximation)\n    seed_transpiler (int): Sets random seed for the stochastic parts of\n        the transpiler.\n    timing_constraints (TimingConstraints): Hardware time alignment restrictions.\n    unitary_synthesis_method (str): The string method to use for the\n        :class:`~qiskit.transpiler.passes.UnitarySynthesis` pass. Will\n        search installed plugins for a valid method. You can see a list of\n        installed plugins with :func:`.unitary_synthesis_plugin_names`.\n    target (Target): The backend target\n    hls_config (HLSConfig): An optional configuration class to use for\n        :class:`~qiskit.transpiler.passes.HighLevelSynthesis` pass.\n        Specifies how to synthesize various high-level objects.\n    init_method (str): The plugin name for the init stage plugin to use\n    optimization_method (str): The plugin name for the optimization stage plugin\n        to use.",
        "api_signature": "__init__(self, initial_layout, basis_gates, inst_map, coupling_map, layout_method, routing_method, translation_method, scheduling_method, instruction_durations, backend_properties, approximation_degree, seed_transpiler, timing_constraints, unitary_synthesis_method, unitary_synthesis_plugin_config, target, hls_config, init_method, optimization_method)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passmanager_config.py"
    },
    {
        "api_name": "from_backend",
        "full_api_name": "PassManagerConfig.from_backend",
        "api_description": "Construct a configuration based on a backend and user input.\n\nThis method automatically gererates a PassManagerConfig object based on the backend's\nfeatures. User options can be used to overwrite the configuration.\n\nArgs:\n    backend (BackendV1): The backend that provides the configuration.\n    pass_manager_options: User-defined option-value pairs.\n\nReturns:\n    PassManagerConfig: The configuration generated based on the arguments.\n\nRaises:\n    AttributeError: If the backend does not support a `configuration()` method.",
        "api_signature": "from_backend(cls, backend, _skip_target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passmanager_config.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "PassManagerConfig.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passmanager_config.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CouplingError.__init__",
        "api_description": "Set the error message.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/exceptions.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "CouplingError.__str__",
        "api_description": "Return the message.",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/exceptions.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "LayoutError.__init__",
        "api_description": "Set the error message.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/exceptions.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "LayoutError.__str__",
        "api_description": "Return the message.",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/exceptions.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "InstructionDurations.__init__",
        "api_description": "",
        "api_signature": "__init__(self, instruction_durations, dt)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/instruction_durations.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "InstructionDurations.__str__",
        "api_description": "Return a string representation of all stored durations.",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/instruction_durations.py"
    },
    {
        "api_name": "from_backend",
        "full_api_name": "InstructionDurations.from_backend",
        "api_description": "Construct an :class:`InstructionDurations` object from the backend.\n\nArgs:\n    backend: backend from which durations (gate lengths) and dt are extracted.\n\nReturns:\n    InstructionDurations: The InstructionDurations constructed from backend.\n\nRaises:\n    TranspilerError: If dt and dtm is different in the backend.",
        "api_signature": "from_backend(cls, backend)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/instruction_durations.py"
    },
    {
        "api_name": "update",
        "full_api_name": "InstructionDurations.update",
        "api_description": "Update self with inst_durations (inst_durations overwrite self).\n\nArgs:\n    inst_durations: Instruction durations to be merged into self (overwriting self).\n    dt: Sampling duration in seconds of the target backend.\n\nReturns:\n    InstructionDurations: The updated InstructionDurations.\n\nRaises:\n    TranspilerError: If the format of instruction_durations is invalid.",
        "api_signature": "update(self, inst_durations, dt)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/instruction_durations.py"
    },
    {
        "api_name": "get",
        "full_api_name": "InstructionDurations.get",
        "api_description": "Get the duration of the instruction with the name, qubits, and parameters.\n\nSome instructions may have a parameter dependent duration.\n\nArgs:\n    inst: An instruction or its name to be queried.\n    qubits: Qubit indices that the instruction acts on.\n    unit: The unit of duration to be returned. It must be 's' or 'dt'.\n    parameters: The value of the parameters of the desired instruction.\n\nReturns:\n    float|int: The duration of the instruction on the qubits.\n\nRaises:\n    TranspilerError: No duration is defined for the instruction.",
        "api_signature": "get(self, inst, qubits, unit, parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/instruction_durations.py"
    },
    {
        "api_name": "_get",
        "full_api_name": "InstructionDurations._get",
        "api_description": "Get the duration of the instruction with the name, qubits, and parameters.",
        "api_signature": "_get(self, name, qubits, to_unit, parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/instruction_durations.py"
    },
    {
        "api_name": "_convert_unit",
        "full_api_name": "InstructionDurations._convert_unit",
        "api_description": "",
        "api_signature": "_convert_unit(self, duration, from_unit, to_unit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/instruction_durations.py"
    },
    {
        "api_name": "units_used",
        "full_api_name": "InstructionDurations.units_used",
        "api_description": "Get the set of all units used in this instruction durations.\n\nReturns:\n    Set of units used in this instruction durations.",
        "api_signature": "units_used(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/instruction_durations.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PassManager.__init__",
        "api_description": "Initialize an empty pass manager object.\n\nArgs:\n    passes: A pass set to be added to the pass manager schedule.\n    max_iteration: The maximum number of iterations the schedule will be looped if the\n        condition is not met.",
        "api_signature": "__init__(self, passes, max_iteration)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py"
    },
    {
        "api_name": "_passmanager_frontend",
        "full_api_name": "PassManager._passmanager_frontend",
        "api_description": "",
        "api_signature": "_passmanager_frontend(self, input_program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py"
    },
    {
        "api_name": "_passmanager_backend",
        "full_api_name": "PassManager._passmanager_backend",
        "api_description": "",
        "api_signature": "_passmanager_backend(self, passmanager_ir, in_program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py"
    },
    {
        "api_name": "_finalize_layouts",
        "full_api_name": "PassManager._finalize_layouts",
        "api_description": "",
        "api_signature": "_finalize_layouts(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py"
    },
    {
        "api_name": "append",
        "full_api_name": "PassManager.append",
        "api_description": "Append a Pass Set to the schedule of passes.\n\nArgs:\n    passes: A set of transpiler passes to be added to schedule.\n\nRaises:\n    TranspilerError: if a pass in passes is not a proper pass.",
        "api_signature": "append(self, passes)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py"
    },
    {
        "api_name": "replace",
        "full_api_name": "PassManager.replace",
        "api_description": "Replace a particular pass in the scheduler.\n\nArgs:\n    index: Pass index to replace, based on the position in passes().\n    passes: A pass set to be added to the pass manager schedule.",
        "api_signature": "replace(self, index, passes)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py"
    },
    {
        "api_name": "run",
        "full_api_name": "PassManager.run",
        "api_description": "Run all the passes on the specified ``circuits``.\n\nArgs:\n    circuits: Circuit(s) to transform via all the registered passes.\n    output_name: The output circuit name. If ``None``, it will be set to the same as the\n        input circuit name.\n    callback: A callback function that will be called after each pass execution. The\n        function will be called with 5 keyword arguments::\n\n            pass_ (Pass): the pass being run\n            dag (DAGCircuit): the dag output of the pass\n            time (float): the time to execute the pass\n            property_set (PropertySet): the property set\n            count (int): the index for the pass execution\n\n        .. note::\n\n            Beware that the keyword arguments here are different to those used by the\n            generic :class:`.BasePassManager`.  This pass manager will translate those\n            arguments into the form described above.\n\n        The exact arguments pass expose the internals of the pass\n        manager and are subject to change as the pass manager internals\n        change. If you intend to reuse a callback function over\n        multiple releases be sure to check that the arguments being\n        passed are the same.\n\n        To use the callback feature you define a function that will\n        take in kwargs dict and access the variables. For example::\n\n            def callback_func(**kwargs):\n                pass_ = kwargs['pass_']\n                dag = kwargs['dag']\n                time = kwargs['time']\n                property_set = kwargs['property_set']\n                count = kwargs['count']\n                ...\n    num_processes: The maximum number of parallel processes to launch if parallel\n        execution is enabled. This argument overrides ``num_processes`` in the user\n        configuration file, and the ``QISKIT_NUM_PROCS`` environment variable. If set\n        to ``None`` the system default or local user configuration will be used.\n\nReturns:\n    The transformed circuit(s).",
        "api_signature": "run(self, circuits, output_name, callback, num_processes)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py"
    },
    {
        "api_name": "draw",
        "full_api_name": "PassManager.draw",
        "api_description": "Draw the pass manager.\n\nThis function needs `pydot <https://github.com/erocarrera/pydot>`__, which in turn needs\n`Graphviz <https://www.graphviz.org/>`__ to be installed.\n\nArgs:\n    filename (str): file path to save image to.\n    style (dict): keys are the pass classes and the values are the colors to make them. An\n        example can be seen in the DEFAULT_STYLE. An ordered dict can be used to ensure\n        a priority coloring when pass falls into multiple categories. Any values not\n        included in the provided dict will be filled in from the default dict.\n    raw (bool): If ``True``, save the raw Dot output instead of the image.\n\nReturns:\n    Optional[PassManager]: an in-memory representation of the pass manager, or ``None``\n    if no image was generated or `Pillow <https://pypi.org/project/Pillow/>`__\n    is not installed.\n\nRaises:\n    ImportError: when nxpd or pydot not installed.",
        "api_signature": "draw(self, filename, style, raw)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "StagedPassManager.__init__",
        "api_description": "Initialize a new StagedPassManager object\n\nArgs:\n    stages (Iterable[str]): An optional list of stages to use for this\n        instance. If this is not specified the default stages list\n        ``['init', 'layout', 'routing', 'translation', 'optimization', 'scheduling']`` is\n        used. After instantiation, the final list will be immutable and stored as tuple.\n        If a stage is provided multiple times (i.e. at diferent relative positions), the\n        associated passes, including pre and post, will run once per declaration.\n    kwargs: The initial :class:`~.PassManager` values for any stages\n        defined in ``stages``. If a argument is not defined the\n        stages will default to ``None`` indicating an empty/undefined\n        stage.\n\nRaises:\n    AttributeError: If a stage in the input keyword arguments is not defined.\n    ValueError: If an invalid stage name is specified.",
        "api_signature": "__init__(self, stages)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py"
    },
    {
        "api_name": "_validate_stages",
        "full_api_name": "StagedPassManager._validate_stages",
        "api_description": "",
        "api_signature": "_validate_stages(self, stages)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py"
    },
    {
        "api_name": "_validate_init_kwargs",
        "full_api_name": "StagedPassManager._validate_init_kwargs",
        "api_description": "",
        "api_signature": "_validate_init_kwargs(self, kwargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py"
    },
    {
        "api_name": "stages",
        "full_api_name": "StagedPassManager.stages",
        "api_description": "Pass manager stages",
        "api_signature": "stages(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py"
    },
    {
        "api_name": "expanded_stages",
        "full_api_name": "StagedPassManager.expanded_stages",
        "api_description": "Expanded Pass manager stages including ``pre_`` and ``post_`` phases.",
        "api_signature": "expanded_stages(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py"
    },
    {
        "api_name": "_generate_expanded_stages",
        "full_api_name": "StagedPassManager._generate_expanded_stages",
        "api_description": "",
        "api_signature": "_generate_expanded_stages(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py"
    },
    {
        "api_name": "_update_passmanager",
        "full_api_name": "StagedPassManager._update_passmanager",
        "api_description": "",
        "api_signature": "_update_passmanager(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py"
    },
    {
        "api_name": "__setattr__",
        "full_api_name": "StagedPassManager.__setattr__",
        "api_description": "",
        "api_signature": "__setattr__(self, attr, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py"
    },
    {
        "api_name": "append",
        "full_api_name": "StagedPassManager.append",
        "api_description": "",
        "api_signature": "append(self, passes)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py"
    },
    {
        "api_name": "replace",
        "full_api_name": "StagedPassManager.replace",
        "api_description": "",
        "api_signature": "replace(self, index, passes)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py"
    },
    {
        "api_name": "remove",
        "full_api_name": "StagedPassManager.remove",
        "api_description": "",
        "api_signature": "remove(self, index)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py"
    },
    {
        "api_name": "__getitem__",
        "full_api_name": "StagedPassManager.__getitem__",
        "api_description": "",
        "api_signature": "__getitem__(self, index)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py"
    },
    {
        "api_name": "__len__",
        "full_api_name": "StagedPassManager.__len__",
        "api_description": "",
        "api_signature": "__len__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py"
    },
    {
        "api_name": "__setitem__",
        "full_api_name": "StagedPassManager.__setitem__",
        "api_description": "",
        "api_signature": "__setitem__(self, index, item)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py"
    },
    {
        "api_name": "__add__",
        "full_api_name": "StagedPassManager.__add__",
        "api_description": "",
        "api_signature": "__add__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py"
    },
    {
        "api_name": "run",
        "full_api_name": "StagedPassManager.run",
        "api_description": "",
        "api_signature": "run(self, circuits, output_name, callback, num_processes)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py"
    },
    {
        "api_name": "to_flow_controller",
        "full_api_name": "StagedPassManager.to_flow_controller",
        "api_description": "",
        "api_signature": "to_flow_controller(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py"
    },
    {
        "api_name": "draw",
        "full_api_name": "StagedPassManager.draw",
        "api_description": "Draw the staged pass manager.",
        "api_signature": "draw(self, filename, style, raw)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py"
    },
    {
        "api_name": "_replace_error",
        "full_api_name": "_replace_error",
        "api_description": "",
        "api_signature": "_replace_error(meth)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py"
    },
    {
        "api_name": "wrapper",
        "full_api_name": "wrapper",
        "api_description": "",
        "api_signature": "wrapper()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py"
    },
    {
        "api_name": "_legacy_style_callback",
        "full_api_name": "_legacy_style_callback",
        "api_description": "",
        "api_signature": "_legacy_style_callback(callback)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py"
    },
    {
        "api_name": "_wrapped_callable",
        "full_api_name": "_wrapped_callable",
        "api_description": "",
        "api_signature": "_wrapped_callable(task, passmanager_ir, property_set, running_time, count)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "TimingConstraints.__init__",
        "api_description": "Initialize a TimingConstraints object\n\nArgs:\n    granularity: An integer value representing minimum pulse gate\n        resolution in units of ``dt``. A user-defined pulse gate should have\n        duration of a multiple of this granularity value.\n    min_length: An integer value representing minimum pulse gate\n        length in units of ``dt``. A user-defined pulse gate should be longer\n        than this length.\n    pulse_alignment: An integer value representing a time resolution of gate\n        instruction starting time. Gate instruction should start at time which\n        is a multiple of the alignment value.\n    acquire_alignment: An integer value representing a time resolution of measure\n        instruction starting time. Measure instruction should start at time which\n        is a multiple of the alignment value.\n\nNotes:\n    This information will be provided by the backend configuration.\n\nRaises:\n    TranspilerError: When any invalid constraint value is passed.",
        "api_signature": "__init__(self, granularity, min_length, pulse_alignment, acquire_alignment)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/timing_constraints.py"
    },
    {
        "api_name": "__call__",
        "full_api_name": "MetaPass.__call__",
        "api_description": "",
        "api_signature": "__call__(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/basepasses.py"
    },
    {
        "api_name": "_freeze_init_parameters",
        "full_api_name": "MetaPass._freeze_init_parameters",
        "api_description": "",
        "api_signature": "_freeze_init_parameters(class_, args, kwargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/basepasses.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BasePass.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/basepasses.py"
    },
    {
        "api_name": "__hash__",
        "full_api_name": "BasePass.__hash__",
        "api_description": "",
        "api_signature": "__hash__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/basepasses.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "BasePass.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/basepasses.py"
    },
    {
        "api_name": "run",
        "full_api_name": "BasePass.run",
        "api_description": "Run a pass on the DAGCircuit. This is implemented by the pass developer.\n\nArgs:\n    dag: the dag on which the pass is run.\n\nRaises:\n    NotImplementedError: when this is left unimplemented for a pass.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/basepasses.py"
    },
    {
        "api_name": "is_transformation_pass",
        "full_api_name": "BasePass.is_transformation_pass",
        "api_description": "Check if the pass is a transformation pass.\n\nIf the pass is a TransformationPass, that means that the pass can manipulate the DAG,\nbut cannot modify the property set (but it can be read).",
        "api_signature": "is_transformation_pass(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/basepasses.py"
    },
    {
        "api_name": "is_analysis_pass",
        "full_api_name": "BasePass.is_analysis_pass",
        "api_description": "Check if the pass is an analysis pass.\n\nIf the pass is an AnalysisPass, that means that the pass can analyze the DAG and write\nthe results of that analysis in the property set. Modifications on the DAG are not allowed\nby this kind of pass.",
        "api_signature": "is_analysis_pass(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/basepasses.py"
    },
    {
        "api_name": "__call__",
        "full_api_name": "BasePass.__call__",
        "api_description": "Runs the pass on circuit.\n\nArgs:\n    circuit: The dag on which the pass is run.\n    property_set: Input/output property set. An analysis pass\n        might change the property set in-place.\n\nReturns:\n    If on transformation pass, the resulting QuantumCircuit.\n    If analysis pass, the input circuit.",
        "api_signature": "__call__(self, circuit, property_set)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/basepasses.py"
    },
    {
        "api_name": "execute",
        "full_api_name": "TransformationPass.execute",
        "api_description": "",
        "api_signature": "execute(self, passmanager_ir, state, callback)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/basepasses.py"
    },
    {
        "api_name": "update_status",
        "full_api_name": "TransformationPass.update_status",
        "api_description": "",
        "api_signature": "update_status(self, state, run_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/basepasses.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "InstructionProperties.__init__",
        "api_description": "Create a new ``InstructionProperties`` object\n\nArgs:\n    duration: The duration, in seconds, of the instruction on the\n        specified set of qubits\n    error: The average error rate for the instruction on the specified\n        set of qubits.\n    calibration: The pulse representation of the instruction.",
        "api_signature": "__init__(self, duration, error, calibration)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "calibration",
        "full_api_name": "InstructionProperties.calibration",
        "api_description": "The pulse representation of the instruction.\n\n.. note::\n\n    This attribute always returns a Qiskit pulse program, but it is internally\n    wrapped by the :class:`.CalibrationEntry` to manage unbound parameters\n    and to uniformly handle different data representation,\n    for example, un-parsed Pulse Qobj JSON that a backend provider may provide.\n\n    This value can be overridden through the property setter in following manner.\n    When you set either :class:`.Schedule` or :class:`.ScheduleBlock` this is\n    always treated as a user-defined (custom) calibration and\n    the transpiler may automatically attach the calibration data to the output circuit.\n    This calibration data may appear in the wire format as an inline calibration,\n    which may further update the backend standard instruction set architecture.\n\n    If you are a backend provider who provides a default calibration data\n    that is not needed to be attached to the transpiled quantum circuit,\n    you can directly set :class:`.CalibrationEntry` instance to this attribute,\n    in which you should set :code:`user_provided=False` when you define\n    calibration data for the entry. End users can still intentionally utilize\n    the calibration data, for example, to run pulse-level simulation of the circuit.\n    However, such entry doesn't appear in the wire format, and backend must\n    use own definition to compile the circuit down to the execution format.",
        "api_signature": "calibration(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "calibration",
        "full_api_name": "InstructionProperties.calibration",
        "api_description": "",
        "api_signature": "calibration(self, calibration)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "InstructionProperties.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Target.__init__",
        "api_description": "Create a new ``Target`` object\n\nArgs:\n    description (str): An optional string to describe the Target.\n    num_qubits (int): An optional int to specify the number of qubits\n        the backend target has. If not set it will be implicitly set\n        based on the qargs when :meth:`~qiskit.Target.add_instruction`\n        is called. Note this must be set if the backend target is for a\n        noiseless simulator that doesn't have constraints on the\n        instructions so the transpiler knows how many qubits are\n        available.\n    dt (float): The system time resolution of input signals in seconds\n    granularity (int): An integer value representing minimum pulse gate\n        resolution in units of ``dt``. A user-defined pulse gate should\n        have duration of a multiple of this granularity value.\n    min_length (int): An integer value representing minimum pulse gate\n        length in units of ``dt``. A user-defined pulse gate should be\n        longer than this length.\n    pulse_alignment (int): An integer value representing a time\n        resolution of gate instruction starting time. Gate instruction\n        should start at time which is a multiple of the alignment\n        value.\n    acquire_alignment (int): An integer value representing a time\n        resolution of measure instruction starting time. Measure\n        instruction should start at time which is a multiple of the\n        alignment value.\n    qubit_properties (list): A list of :class:`~.QubitProperties`\n        objects defining the characteristics of each qubit on the\n        target device. If specified the length of this list must match\n        the number of qubits in the target, where the index in the list\n        matches the qubit number the properties are defined for. If some\n        qubits don't have properties available you can set that entry to\n        ``None``\n    concurrent_measurements(list): A list of sets of qubits that must be\n        measured together. This must be provided\n        as a nested list like ``[[0, 1], [2, 3, 4]]``.\nRaises:\n    ValueError: If both ``num_qubits`` and ``qubit_properties`` are both\n        defined and the value of ``num_qubits`` differs from the length of\n        ``qubit_properties``.",
        "api_signature": "__init__(self, description, num_qubits, dt, granularity, min_length, pulse_alignment, acquire_alignment, qubit_properties, concurrent_measurements)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "add_instruction",
        "full_api_name": "Target.add_instruction",
        "api_description": "Add a new instruction to the :class:`~qiskit.transpiler.Target`\n\nAs ``Target`` objects are strictly additive this is the primary method\nfor modifying a ``Target``. Typically, you will use this to fully populate\na ``Target`` before using it in :class:`~qiskit.providers.BackendV2`. For\nexample::\n\n    from qiskit.circuit.library import CXGate\n    from qiskit.transpiler import Target, InstructionProperties\n\n    target = Target()\n    cx_properties = {\n        (0, 1): None,\n        (1, 0): None,\n        (0, 2): None,\n        (2, 0): None,\n        (0, 3): None,\n        (2, 3): None,\n        (3, 0): None,\n        (3, 2): None\n    }\n    target.add_instruction(CXGate(), cx_properties)\n\nWill add a :class:`~qiskit.circuit.library.CXGate` to the target with no\nproperties (duration, error, etc) with the coupling edge list:\n``(0, 1), (1, 0), (0, 2), (2, 0), (0, 3), (2, 3), (3, 0), (3, 2)``. If\nthere are properties available for the instruction you can replace the\n``None`` value in the properties dictionary with an\n:class:`~qiskit.transpiler.InstructionProperties` object. This pattern\nis repeated for each :class:`~qiskit.circuit.Instruction` the target\nsupports.\n\nArgs:\n    instruction (Union[qiskit.circuit.Instruction, Type[qiskit.circuit.Instruction]]):\n        The operation object to add to the map. If it's parameterized any value\n        of the parameter can be set. Optionally for variable width\n        instructions (such as control flow operations such as :class:`~.ForLoop` or\n        :class:`~MCXGate`) you can specify the class. If the class is specified than the\n        ``name`` argument must be specified. When a class is used the gate is treated as global\n        and not having any properties set.\n    properties (dict): A dictionary of qarg entries to an\n        :class:`~qiskit.transpiler.InstructionProperties` object for that\n        instruction implementation on the backend. Properties are optional\n        for any instruction implementation, if there are no\n        :class:`~qiskit.transpiler.InstructionProperties` available for the\n        backend the value can be None. If there are no constraints on the\n        instruction (as in a noiseless/ideal simulation) this can be set to\n        ``{None, None}`` which will indicate it runs on all qubits (or all\n        available permutations of qubits for multi-qubit gates). The first\n        ``None`` indicates it applies to all qubits and the second ``None``\n        indicates there are no\n        :class:`~qiskit.transpiler.InstructionProperties` for the\n        instruction. By default, if properties is not set it is equivalent to\n        passing ``{None: None}``.\n    name (str): An optional name to use for identifying the instruction. If not\n        specified the :attr:`~qiskit.circuit.Instruction.name` attribute\n        of ``gate`` will be used. All gates in the ``Target`` need unique\n        names. Backends can differentiate between different\n        parameterization of a single gate by providing a unique name for\n        each (e.g. `\"rx30\"`, `\"rx60\", ``\"rx90\"`` similar to the example in the\n        documentation for the :class:`~qiskit.transpiler.Target` class).\nRaises:\n    AttributeError: If gate is already in map\n    TranspilerError: If an operation class is passed in for ``instruction`` and no name\n        is specified or ``properties`` is set.",
        "api_signature": "add_instruction(self, instruction, properties, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "update_instruction_properties",
        "full_api_name": "Target.update_instruction_properties",
        "api_description": "Update the property object for an instruction qarg pair already in the Target\n\nArgs:\n    instruction (str): The instruction name to update\n    qargs (tuple): The qargs to update the properties of\n    properties (InstructionProperties): The properties to set for this instruction\nRaises:\n    KeyError: If ``instruction`` or ``qarg`` are not in the target",
        "api_signature": "update_instruction_properties(self, instruction, qargs, properties)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "update_from_instruction_schedule_map",
        "full_api_name": "Target.update_from_instruction_schedule_map",
        "api_description": "Update the target from an instruction schedule map.\n\nIf the input instruction schedule map contains new instructions not in\nthe target they will be added. However, if it contains additional qargs\nfor an existing instruction in the target it will error.\n\nArgs:\n    inst_map (InstructionScheduleMap): The instruction\n    inst_name_map (dict): An optional dictionary that maps any\n        instruction name in ``inst_map`` to an instruction object.\n        If not provided, instruction is pulled from the standard Qiskit gates,\n        and finally custom gate instance is created with schedule name.\n    error_dict (dict): A dictionary of errors of the form::\n\n        {gate_name: {qarg: error}}\n\n    for example::\n\n        {'rx': {(0, ): 1.4e-4, (1, ): 1.2e-4}}\n\n    For each entry in the ``inst_map`` if ``error_dict`` is defined\n    a when updating the ``Target`` the error value will be pulled from\n    this dictionary. If one is not found in ``error_dict`` then\n    ``None`` will be used.",
        "api_signature": "update_from_instruction_schedule_map(self, inst_map, inst_name_map, error_dict)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "qargs",
        "full_api_name": "Target.qargs",
        "api_description": "The set of qargs in the target.",
        "api_signature": "qargs(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "qargs_for_operation_name",
        "full_api_name": "Target.qargs_for_operation_name",
        "api_description": "Get the qargs for a given operation name\n\nArgs:\n   operation (str): The operation name to get qargs for\nReturns:\n    set: The set of qargs the gate instance applies to.",
        "api_signature": "qargs_for_operation_name(self, operation)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "durations",
        "full_api_name": "Target.durations",
        "api_description": "Get an InstructionDurations object from the target\n\nReturns:\n    InstructionDurations: The instruction duration represented in the\n        target",
        "api_signature": "durations(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "timing_constraints",
        "full_api_name": "Target.timing_constraints",
        "api_description": "Get an :class:`~qiskit.transpiler.TimingConstraints` object from the target\n\nReturns:\n    TimingConstraints: The timing constraints represented in the ``Target``",
        "api_signature": "timing_constraints(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "instruction_schedule_map",
        "full_api_name": "Target.instruction_schedule_map",
        "api_description": "Return an :class:`~qiskit.pulse.InstructionScheduleMap` for the\ninstructions in the target with a pulse schedule defined.\n\nReturns:\n    InstructionScheduleMap: The instruction schedule map for the\n    instructions in this target with a pulse schedule defined.",
        "api_signature": "instruction_schedule_map(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "operation_from_name",
        "full_api_name": "Target.operation_from_name",
        "api_description": "Get the operation class object for a given name\n\nArgs:\n    instruction (str): The instruction name to get the\n        :class:`~qiskit.circuit.Instruction` instance for\nReturns:\n    qiskit.circuit.Instruction: The Instruction instance corresponding to the\n    name. This also can also be the class for globally defined variable with\n    operations.",
        "api_signature": "operation_from_name(self, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "operations_for_qargs",
        "full_api_name": "Target.operations_for_qargs",
        "api_description": "Get the operation class object for a specified qargs tuple\n\nArgs:\n    qargs (tuple): A qargs tuple of the qubits to get the gates that apply\n        to it. For example, ``(0,)`` will return the set of all\n        instructions that apply to qubit 0. If set to ``None`` this will\n        return any globally defined operations in the target.\nReturns:\n    list: The list of :class:`~qiskit.circuit.Instruction` instances\n    that apply to the specified qarg. This may also be a class if\n    a variable width operation is globally defined.\n\nRaises:\n    KeyError: If qargs is not in target",
        "api_signature": "operations_for_qargs(self, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "operation_names_for_qargs",
        "full_api_name": "Target.operation_names_for_qargs",
        "api_description": "Get the operation names for a specified qargs tuple\n\nArgs:\n    qargs (tuple): A ``qargs`` tuple of the qubits to get the gates that apply\n        to it. For example, ``(0,)`` will return the set of all\n        instructions that apply to qubit 0. If set to ``None`` this will\n        return the names for any globally defined operations in the target.\nReturns:\n    set: The set of operation names that apply to the specified ``qargs``.\n\nRaises:\n    KeyError: If ``qargs`` is not in target",
        "api_signature": "operation_names_for_qargs(self, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "instruction_supported",
        "full_api_name": "Target.instruction_supported",
        "api_description": "Return whether the instruction (operation + qubits) is supported by the target\n\nArgs:\n    operation_name (str): The name of the operation for the instruction. Either\n        this or ``operation_class`` must be specified, if both are specified\n        ``operation_class`` will take priority and this argument will be ignored.\n    qargs (tuple): The tuple of qubit indices for the instruction. If this is\n        not specified then this method will return ``True`` if the specified\n        operation is supported on any qubits. The typical application will\n        always have this set (otherwise it's the same as just checking if the\n        target contains the operation). Normally you would not set this argument\n        if you wanted to check more generally that the target supports an operation\n        with the ``parameters`` on any qubits.\n    operation_class (Type[qiskit.circuit.Instruction]): The operation class to check whether\n        the target supports a particular operation by class rather\n        than by name. This lookup is more expensive as it needs to\n        iterate over all operations in the target instead of just a\n        single lookup. If this is specified it will supersede the\n        ``operation_name`` argument. The typical use case for this\n        operation is to check whether a specific variant of an operation\n        is supported on the backend. For example, if you wanted to\n        check whether a :class:`~.RXGate` was supported on a specific\n        qubit with a fixed angle. That fixed angle variant will\n        typically have a name different from the object's\n        :attr:`~.Instruction.name` attribute (``\"rx\"``) in the target.\n        This can be used to check if any instances of the class are\n        available in such a case.\n    parameters (list): A list of parameters to check if the target\n        supports them on the specified qubits. If the instruction\n        supports the parameter values specified in the list on the\n        operation and qargs specified this will return ``True`` but\n        if the parameters are not supported on the specified\n        instruction it will return ``False``. If this argument is not\n        specified this method will return ``True`` if the instruction\n        is supported independent of the instruction parameters. If\n        specified with any :class:`~.Parameter` objects in the list,\n        that entry will be treated as supporting any value, however parameter names\n        will not be checked (for example if an operation in the target\n        is listed as parameterized with ``\"theta\"`` and ``\"phi\"`` is\n        passed into this function that will return ``True``). For\n        example, if called with::\n\n            parameters = [Parameter(\"theta\")]\n            target.instruction_supported(\"rx\", (0,), parameters=parameters)\n\n        will return ``True`` if an :class:`~.RXGate` is supported on qubit 0\n        that will accept any parameter. If you need to check for a fixed numeric\n        value parameter this argument is typically paired with the ``operation_class``\n        argument. For example::\n\n            target.instruction_supported(\"rx\", (0,), RXGate, parameters=[pi / 4])\n\n        will return ``True`` if an RXGate(pi/4) exists on qubit 0.\n\nReturns:\n    bool: Returns ``True`` if the instruction is supported and ``False`` if it isn't.",
        "api_signature": "instruction_supported(self, operation_name, qargs, operation_class, parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "check_obj_params",
        "full_api_name": "Target.check_obj_params",
        "api_description": "",
        "api_signature": "check_obj_params(parameters, obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "has_calibration",
        "full_api_name": "Target.has_calibration",
        "api_description": "Return whether the instruction (operation + qubits) defines a calibration.\n\nArgs:\n    operation_name: The name of the operation for the instruction.\n    qargs: The tuple of qubit indices for the instruction.\n\nReturns:\n    Returns ``True`` if the calibration is supported and ``False`` if it isn't.",
        "api_signature": "has_calibration(self, operation_name, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "get_calibration",
        "full_api_name": "Target.get_calibration",
        "api_description": "Get calibrated pulse schedule for the instruction.\n\nIf calibration is templated with parameters, one can also provide those values\nto build a schedule with assigned parameters.\n\nArgs:\n    operation_name: The name of the operation for the instruction.\n    qargs: The tuple of qubit indices for the instruction.\n    args: Parameter values to build schedule if any.\n    kwargs: Parameter values with name to build schedule if any.\n\nReturns:\n    Calibrated pulse schedule of corresponding instruction.",
        "api_signature": "get_calibration(self, operation_name, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "operation_names",
        "full_api_name": "Target.operation_names",
        "api_description": "Get the operation names in the target.",
        "api_signature": "operation_names(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "operations",
        "full_api_name": "Target.operations",
        "api_description": "Get the operation class objects in the target.",
        "api_signature": "operations(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "instructions",
        "full_api_name": "Target.instructions",
        "api_description": "Get the list of tuples ``(:class:`~qiskit.circuit.Instruction`, (qargs))``\nfor the target\n\nFor globally defined variable width operations the tuple will be of the form\n``(class, None)`` where class is the actual operation class that\nis globally defined.",
        "api_signature": "instructions(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "instruction_properties",
        "full_api_name": "Target.instruction_properties",
        "api_description": "Get the instruction properties for a specific instruction tuple\n\nThis method is to be used in conjunction with the\n:attr:`~qiskit.transpiler.Target.instructions` attribute of a\n:class:`~qiskit.transpiler.Target` object. You can use this method to quickly\nget the instruction properties for an element of\n:attr:`~qiskit.transpiler.Target.instructions` by using the index in that list.\nHowever, if you're not working with :attr:`~qiskit.transpiler.Target.instructions`\ndirectly it is likely more efficient to access the target directly via the name\nand qubits to get the instruction properties. For example, if\n:attr:`~qiskit.transpiler.Target.instructions` returned::\n\n    [(XGate(), (0,)), (XGate(), (1,))]\n\nyou could get the properties of the ``XGate`` on qubit 1 with::\n\n    props = target.instruction_properties(1)\n\nbut just accessing it directly via the name would be more efficient::\n\n    props = target['x'][(1,)]\n\n(assuming the ``XGate``'s canonical name in the target is ``'x'``)\nThis is especially true for larger targets as this will scale worse with the number\nof instruction tuples in a target.\n\nArgs:\n    index (int): The index of the instruction tuple from the\n        :attr:`~qiskit.transpiler.Target.instructions` attribute. For, example\n        if you want the properties from the third element in\n        :attr:`~qiskit.transpiler.Target.instructions` you would set this to be ``2``.\nReturns:\n    InstructionProperties: The instruction properties for the specified instruction tuple",
        "api_signature": "instruction_properties(self, index)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "_build_coupling_graph",
        "full_api_name": "Target._build_coupling_graph",
        "api_description": "",
        "api_signature": "_build_coupling_graph(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "build_coupling_map",
        "full_api_name": "Target.build_coupling_map",
        "api_description": "Get a :class:`~qiskit.transpiler.CouplingMap` from this target.\n\nIf there is a mix of two qubit operations that have a connectivity\nconstraint and those that are globally defined this will also return\n``None`` because the globally connectivity means there is no constraint\non the target. If you wish to see the constraints of the two qubit\noperations that have constraints you should use the ``two_q_gate``\nargument to limit the output to the gates which have a constraint.\n\nArgs:\n    two_q_gate (str): An optional gate name for a two qubit gate in\n        the ``Target`` to generate the coupling map for. If specified the\n        output coupling map will only have edges between qubits where\n        this gate is present.\n    filter_idle_qubits (bool): If set to ``True`` the output :class:`~.CouplingMap`\n        will remove any qubits that don't have any operations defined in the\n        target. Note that using this argument will result in an output\n        :class:`~.CouplingMap` object which has holes in its indices\n        which might differ from the assumptions of the class. The typical use\n        case of this argument is to be paired with\n        :meth:`.CouplingMap.connected_components` which will handle the holes\n        as expected.\nReturns:\n    CouplingMap: The :class:`~qiskit.transpiler.CouplingMap` object\n        for this target. If there are no connectivity constraints in\n        the target this will return ``None``.\n\nRaises:\n    ValueError: If a non-two qubit gate is passed in for ``two_q_gate``.\n    IndexError: If an Instruction not in the ``Target`` is passed in for\n        ``two_q_gate``.",
        "api_signature": "build_coupling_map(self, two_q_gate, filter_idle_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "_filter_coupling_graph",
        "full_api_name": "Target._filter_coupling_graph",
        "api_description": "",
        "api_signature": "_filter_coupling_graph(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "physical_qubits",
        "full_api_name": "Target.physical_qubits",
        "api_description": "Returns a sorted list of physical_qubits",
        "api_signature": "physical_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "get_non_global_operation_names",
        "full_api_name": "Target.get_non_global_operation_names",
        "api_description": "Return the non-global operation names for the target\n\nThe non-global operations are those in the target which don't apply\non all qubits (for single qubit operations) or all multi-qubit qargs\n(for multi-qubit operations).\n\nArgs:\n    strict_direction (bool): If set to ``True`` the multi-qubit\n        operations considered as non-global respect the strict\n        direction (or order of qubits in the qargs is significant). For\n        example, if ``cx`` is defined on ``(0, 1)`` and ``ecr`` is\n        defined over ``(1, 0)`` by default neither would be considered\n        non-global, but if ``strict_direction`` is set ``True`` both\n        ``cx`` and ``ecr`` would be returned.\n\nReturns:\n    List[str]: A list of operation names for operations that aren't global in this target",
        "api_signature": "get_non_global_operation_names(self, strict_direction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "__iter__",
        "full_api_name": "Target.__iter__",
        "api_description": "",
        "api_signature": "__iter__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "__getitem__",
        "full_api_name": "Target.__getitem__",
        "api_description": "",
        "api_signature": "__getitem__(self, key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "__len__",
        "full_api_name": "Target.__len__",
        "api_description": "",
        "api_signature": "__len__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "__contains__",
        "full_api_name": "Target.__contains__",
        "api_description": "",
        "api_signature": "__contains__(self, item)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "keys",
        "full_api_name": "Target.keys",
        "api_description": "",
        "api_signature": "keys(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "values",
        "full_api_name": "Target.values",
        "api_description": "",
        "api_signature": "values(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "items",
        "full_api_name": "Target.items",
        "api_description": "",
        "api_signature": "items(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "Target.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "from_configuration",
        "full_api_name": "Target.from_configuration",
        "api_description": "Create a target object from the individual global configuration\n\nPrior to the creation of the :class:`~.Target` class, the constraints\nof a backend were represented by a collection of different objects\nwhich combined represent a subset of the information contained in\nthe :class:`~.Target`. This function provides a simple interface\nto convert those separate objects to a :class:`~.Target`.\n\nThis constructor will use the input from ``basis_gates``, ``num_qubits``,\nand ``coupling_map`` to build a base model of the backend and the\n``instruction_durations``, ``backend_properties``, and ``inst_map`` inputs\nare then queried (in that order) based on that model to look up the properties\nof each instruction and qubit. If there is an inconsistency between the inputs\nany extra or conflicting information present in ``instruction_durations``,\n``backend_properties``, or ``inst_map`` will be ignored.\n\nArgs:\n    basis_gates: The list of basis gate names for the backend. For the\n        target to be created these names must either be in the output\n        from :func:`~.get_standard_gate_name_mapping` or present in the\n        specified ``custom_name_mapping`` argument.\n    num_qubits: The number of qubits supported on the backend.\n    coupling_map: The coupling map representing connectivity constraints\n        on the backend. If specified all gates from ``basis_gates`` will\n        be supported on all qubits (or pairs of qubits).\n    inst_map: The instruction schedule map representing the pulse\n       :class:`~.Schedule` definitions for each instruction. If this\n       is specified ``coupling_map`` must be specified. The\n       ``coupling_map`` is used as the source of truth for connectivity\n       and if ``inst_map`` is used the schedule is looked up based\n       on the instructions from the pair of ``basis_gates`` and\n       ``coupling_map``. If you want to define a custom gate for\n       a particular qubit or qubit pair, you can manually build :class:`.Target`.\n    backend_properties: The :class:`~.BackendProperties` object which is\n        used for instruction properties and qubit properties.\n        If specified and instruction properties are intended to be used\n        then the ``coupling_map`` argument must be specified. This is\n        only used to lookup error rates and durations (unless\n        ``instruction_durations`` is specified which would take\n        precedence) for instructions specified via ``coupling_map`` and\n        ``basis_gates``.\n    instruction_durations: Optional instruction durations for instructions. If specified\n        it will take priority for setting the ``duration`` field in the\n        :class:`~InstructionProperties` objects for the instructions in the target.\n    concurrent_measurements(list): A list of sets of qubits that must be\n        measured together. This must be provided\n        as a nested list like ``[[0, 1], [2, 3, 4]]``.\n    dt: The system time resolution of input signals in seconds\n    timing_constraints: Optional timing constraints to include in the\n        :class:`~.Target`\n    custom_name_mapping: An optional dictionary that maps custom gate/operation names in\n        ``basis_gates`` to an :class:`~.Operation` object representing that\n        gate/operation. By default, most standard gates names are mapped to the\n        standard gate object from :mod:`qiskit.circuit.library` this only needs\n        to be specified if the input ``basis_gates`` defines gates in names outside\n        that set.\n\nReturns:\n    Target: the target built from the input configuration\n\nRaises:\n    TranspilerError: If the input basis gates contain > 2 qubits and ``coupling_map`` is\n    specified.\n    KeyError: If no mapping is available for a specified ``basis_gate``.",
        "api_signature": "from_configuration(cls, basis_gates, num_qubits, coupling_map, inst_map, backend_properties, instruction_durations, concurrent_measurements, dt, timing_constraints, custom_name_mapping)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "target_to_backend_properties",
        "full_api_name": "target_to_backend_properties",
        "api_description": "Convert a :class:`~.Target` object into a legacy :class:`~.BackendProperties`",
        "api_signature": "target_to_backend_properties(target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/target.py"
    },
    {
        "api_name": "_has_control_flow",
        "full_api_name": "_has_control_flow",
        "api_description": "",
        "api_signature": "_has_control_flow(property_set)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/common.py"
    },
    {
        "api_name": "_without_control_flow",
        "full_api_name": "_without_control_flow",
        "api_description": "",
        "api_signature": "_without_control_flow(property_set)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/common.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "_InvalidControlFlowForBackend.__init__",
        "api_description": "",
        "api_signature": "__init__(self, basis_gates, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/common.py"
    },
    {
        "api_name": "message",
        "full_api_name": "_InvalidControlFlowForBackend.message",
        "api_description": "Create an error message for the given property set.",
        "api_signature": "message(self, property_set)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/common.py"
    },
    {
        "api_name": "condition",
        "full_api_name": "_InvalidControlFlowForBackend.condition",
        "api_description": "Checkable condition for the given property set.",
        "api_signature": "condition(self, property_set)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/common.py"
    },
    {
        "api_name": "generate_control_flow_options_check",
        "full_api_name": "generate_control_flow_options_check",
        "api_description": "Generate a pass manager that, when run on a DAG that contains control flow, fails with an\nerror message explaining the invalid options, and what could be used instead.\n\nReturns:\n    PassManager: a pass manager that populates the ``contains_x`` properties for each of the\n    control-flow operations, and raises an error if any of the given options do not support\n    control flow, but a circuit with control flow is given.",
        "api_signature": "generate_control_flow_options_check(layout_method, routing_method, translation_method, optimization_method, scheduling_method, basis_gates, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/common.py"
    },
    {
        "api_name": "generate_error_on_control_flow",
        "full_api_name": "generate_error_on_control_flow",
        "api_description": "Get a pass manager that always raises an error if control flow is present in a given\ncircuit.",
        "api_signature": "generate_error_on_control_flow(message)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/common.py"
    },
    {
        "api_name": "if_has_control_flow_else",
        "full_api_name": "if_has_control_flow_else",
        "api_description": "Generate a pass manager that will run the passes in ``if_present`` if the given circuit\nhas control-flow operations in it, and those in ``if_absent`` if it doesn't.",
        "api_signature": "if_has_control_flow_else(if_present, if_absent)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/common.py"
    },
    {
        "api_name": "generate_unroll_3q",
        "full_api_name": "generate_unroll_3q",
        "api_description": "Generate an unroll >3q :class:`~qiskit.transpiler.PassManager`\n\nArgs:\n    target (Target): the :class:`~.Target` object representing the backend\n    basis_gates (list): A list of str gate names that represent the basis\n        gates on the backend target\n    approximation_degree (Optional[float]): The heuristic approximation degree to\n        use. Can be between 0 and 1.\n    unitary_synthesis_method (str): The unitary synthesis method to use. You can see\n        a list of installed plugins with :func:`.unitary_synthesis_plugin_names`.\n    unitary_synthesis_plugin_config (dict): The optional dictionary plugin\n        configuration, this is plugin specific refer to the specified plugin's\n        documentation for how to use.\n    hls_config (HLSConfig): An optional configuration class to use for\n            :class:`~qiskit.transpiler.passes.HighLevelSynthesis` pass.\n            Specifies how to synthesize various high-level objects.\n\nReturns:\n    PassManager: The unroll 3q or more pass manager",
        "api_signature": "generate_unroll_3q(target, basis_gates, approximation_degree, unitary_synthesis_method, unitary_synthesis_plugin_config, hls_config)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/common.py"
    },
    {
        "api_name": "generate_embed_passmanager",
        "full_api_name": "generate_embed_passmanager",
        "api_description": "Generate a layout embedding :class:`~qiskit.transpiler.PassManager`\n\nThis is used to generate a :class:`~qiskit.transpiler.PassManager` object\nthat can be used to expand and apply an initial layout to a circuit\n\nArgs:\n    coupling_map (Union[CouplingMap, Target): The coupling map for the backend to embed\n        the circuit to.\nReturns:\n    PassManager: The embedding passmanager that assumes the layout property\n        set has been set in earlier stages",
        "api_signature": "generate_embed_passmanager(coupling_map)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/common.py"
    },
    {
        "api_name": "_layout_not_perfect",
        "full_api_name": "_layout_not_perfect",
        "api_description": "Return ``True`` if the first attempt at layout has been checked and found to be imperfect.\nIn this case, perfection means \"does not require any swap routing\".",
        "api_signature": "_layout_not_perfect(property_set)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/common.py"
    },
    {
        "api_name": "_apply_post_layout_condition",
        "full_api_name": "_apply_post_layout_condition",
        "api_description": "",
        "api_signature": "_apply_post_layout_condition(property_set)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/common.py"
    },
    {
        "api_name": "generate_routing_passmanager",
        "full_api_name": "generate_routing_passmanager",
        "api_description": "Generate a routing :class:`~qiskit.transpiler.PassManager`\n\nArgs:\n    routing_pass (TransformationPass): The pass which will perform the\n        routing\n    target (Target): the :class:`~.Target` object representing the backend\n    coupling_map (CouplingMap): The coupling map of the backend to route\n        for\n    vf2_call_limit (int): The internal call limit for the vf2 post layout\n        pass. If this is ``None`` or ``0`` the vf2 post layout will not be\n        run.\n    backend_properties (BackendProperties): Properties of a backend to\n        synthesize for (e.g. gate fidelities).\n    seed_transpiler (int): Sets random seed for the stochastic parts of\n        the transpiler.\n    check_trivial (bool): If set to true this will condition running the\n        :class:`~.VF2PostLayout` pass after routing on whether a trivial\n        layout was tried and was found to not be perfect. This is only\n        needed if the constructed pass manager runs :class:`~.TrivialLayout`\n        as a first layout attempt and uses it if it's a perfect layout\n        (as is the case with preset pass manager level 1).\n    use_barrier_before_measurement (bool): If true (the default) the\n        :class:`~.BarrierBeforeFinalMeasurements` transpiler pass will be run prior to the\n        specified pass in the ``routing_pass`` argument.\n    vf2_max_trials (int): The maximum number of trials to run VF2 when\n        evaluating the vf2 post layout\n        pass. If this is ``None`` or ``0`` the vf2 post layout will not be run.\nReturns:\n    PassManager: The routing pass manager",
        "api_signature": "generate_routing_passmanager(routing_pass, target, coupling_map, vf2_call_limit, backend_properties, seed_transpiler, check_trivial, use_barrier_before_measurement, vf2_max_trials)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/common.py"
    },
    {
        "api_name": "_run_post_layout_condition",
        "full_api_name": "_run_post_layout_condition",
        "api_description": "",
        "api_signature": "_run_post_layout_condition(property_set)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/common.py"
    },
    {
        "api_name": "_swap_condition",
        "full_api_name": "_swap_condition",
        "api_description": "",
        "api_signature": "_swap_condition(property_set)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/common.py"
    },
    {
        "api_name": "filter_fn",
        "full_api_name": "filter_fn",
        "api_description": "",
        "api_signature": "filter_fn(node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/common.py"
    },
    {
        "api_name": "generate_pre_op_passmanager",
        "full_api_name": "generate_pre_op_passmanager",
        "api_description": "Generate a pre-optimization loop :class:`~qiskit.transpiler.PassManager`\n\nThis pass manager will check to ensure that directionality from the coupling\nmap is respected\n\nArgs:\n    target (Target): the :class:`~.Target` object representing the backend\n    coupling_map (CouplingMap): The coupling map to use\n    remove_reset_in_zero (bool): If ``True`` include the remove reset in\n        zero pass in the generated PassManager\nReturns:\n    PassManager: The pass manager",
        "api_signature": "generate_pre_op_passmanager(target, coupling_map, remove_reset_in_zero)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/common.py"
    },
    {
        "api_name": "_direction_condition",
        "full_api_name": "_direction_condition",
        "api_description": "",
        "api_signature": "_direction_condition(property_set)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/common.py"
    },
    {
        "api_name": "generate_translation_passmanager",
        "full_api_name": "generate_translation_passmanager",
        "api_description": "Generate a basis translation :class:`~qiskit.transpiler.PassManager`\n\nArgs:\n    target (Target): the :class:`~.Target` object representing the backend\n    basis_gates (list): A list of str gate names that represent the basis\n        gates on the backend target\n    method (str): The basis translation method to use\n    approximation_degree (Optional[float]): The heuristic approximation degree to\n        use. Can be between 0 and 1.\n    coupling_map (CouplingMap): the coupling map of the backend\n        in case synthesis is done on a physical circuit. The\n        directionality of the coupling_map will be taken into\n        account if pulse_optimize is True/None and natural_direction\n        is True/None.\n    unitary_synthesis_plugin_config (dict): The optional dictionary plugin\n        configuration, this is plugin specific refer to the specified plugin's\n        documentation for how to use.\n    backend_props (BackendProperties): Properties of a backend to\n        synthesize for (e.g. gate fidelities).\n    unitary_synthesis_method (str): The unitary synthesis method to use. You can\n        see a list of installed plugins with :func:`.unitary_synthesis_plugin_names`.\n    hls_config (HLSConfig): An optional configuration class to use for\n        :class:`~qiskit.transpiler.passes.HighLevelSynthesis` pass.\n        Specifies how to synthesize various high-level objects.\n\nReturns:\n    PassManager: The basis translation pass manager\n\nRaises:\n    TranspilerError: If the ``method`` kwarg is not a valid value",
        "api_signature": "generate_translation_passmanager(target, basis_gates, method, approximation_degree, coupling_map, backend_props, unitary_synthesis_method, unitary_synthesis_plugin_config, hls_config)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/common.py"
    },
    {
        "api_name": "generate_scheduling",
        "full_api_name": "generate_scheduling",
        "api_description": "Generate a post optimization scheduling :class:`~qiskit.transpiler.PassManager`\n\nArgs:\n    instruction_durations (dict): The dictionary of instruction durations\n    scheduling_method (str): The scheduling method to use, can either be\n        ``'asap'``/``'as_soon_as_possible'`` or\n        ``'alap'``/``'as_late_as_possible'``\n    timing_constraints (TimingConstraints): Hardware time alignment restrictions.\n    inst_map (InstructionScheduleMap): Mapping object that maps gate to schedule.\n    target (Target): The :class:`~.Target` object representing the backend\n\nReturns:\n    PassManager: The scheduling pass manager\n\nRaises:\n    TranspilerError: If the ``scheduling_method`` kwarg is not a valid value",
        "api_signature": "generate_scheduling(instruction_durations, scheduling_method, timing_constraints, inst_map, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/common.py"
    },
    {
        "api_name": "_contains_delay",
        "full_api_name": "_contains_delay",
        "api_description": "",
        "api_signature": "_contains_delay(property_set)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/common.py"
    },
    {
        "api_name": "_require_alignment",
        "full_api_name": "_require_alignment",
        "api_description": "",
        "api_signature": "_require_alignment(property_set)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/common.py"
    },
    {
        "api_name": "get_vf2_limits",
        "full_api_name": "get_vf2_limits",
        "api_description": "Get the VF2 limits for VF2-based layout passes.\n\nReturns:\n    VF2Limits: An namedtuple with optional elements\n    ``call_limit`` and ``max_trials``.",
        "api_signature": "get_vf2_limits(optimization_level, layout_method, initial_layout)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/common.py"
    },
    {
        "api_name": "level_0_pass_manager",
        "full_api_name": "level_0_pass_manager",
        "api_description": "Level 0 pass manager: no explicit optimization other than mapping to backend.\n\nThis pass manager applies the user-given initial layout. If none is given, a trivial\nlayout consisting of mapping the i-th virtual qubit to the i-th physical qubit is used.\nAny unused physical qubit is allocated as ancilla space.\n\nThe pass manager then unrolls the circuit to the desired basis, and transforms the\ncircuit to match the coupling map.\n\nArgs:\n    pass_manager_config: configuration of the pass manager.\n\nReturns:\n    a level 0 pass manager.\n\nRaises:\n    TranspilerError: if the passmanager config is invalid.",
        "api_signature": "level_0_pass_manager(pass_manager_config)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/level0.py"
    },
    {
        "api_name": "pass_manager",
        "full_api_name": "PassManagerStagePlugin.pass_manager",
        "api_description": "This method is designed to return a :class:`~.PassManager` for the stage this implements\n\nArgs:\n    pass_manager_config: A configuration object that defines all the target device\n        specifications and any user specified options to :func:`~.transpile` or\n        :func:`~.generate_preset_pass_manager`\n    optimization_level: The optimization level of the transpilation, if set this\n        should be used to set values for any tunable parameters to trade off runtime\n        for potential optimization. Valid values should be ``0``, ``1``, ``2``, or ``3``\n        and the higher the number the more optimization is expected.",
        "api_signature": "pass_manager(self, pass_manager_config, optimization_level)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/plugin.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PassManagerStagePluginManager.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/plugin.py"
    },
    {
        "api_name": "get_passmanager_stage",
        "full_api_name": "PassManagerStagePluginManager.get_passmanager_stage",
        "api_description": "Get a stage",
        "api_signature": "get_passmanager_stage(self, stage_name, plugin_name, pm_config, optimization_level)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/plugin.py"
    },
    {
        "api_name": "_build_pm",
        "full_api_name": "PassManagerStagePluginManager._build_pm",
        "api_description": "",
        "api_signature": "_build_pm(self, stage_obj, stage_name, plugin_name, pm_config, optimization_level)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/plugin.py"
    },
    {
        "api_name": "list_stage_plugins",
        "full_api_name": "list_stage_plugins",
        "api_description": "Get a list of installed plugins for a stage.\n\nArgs:\n    stage_name: The stage name to get the plugin names for\n\nReturns:\n    plugins: The list of installed plugin names for the specified stages\n\nRaises:\n   TranspilerError: If an invalid stage name is specified.",
        "api_signature": "list_stage_plugins(stage_name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/plugin.py"
    },
    {
        "api_name": "passmanager_stage_plugins",
        "full_api_name": "passmanager_stage_plugins",
        "api_description": "Return a dict with, for each stage name, the class type of the plugin.\n\nThis function is useful for getting more information about a plugin:\n\n.. code-block:: python\n\n    from qiskit.transpiler.preset_passmanagers.plugin import passmanager_stage_plugins\n    routing_plugins = passmanager_stage_plugins('routing')\n    basic_plugin = routing_plugins['basic']\n    help(basic_plugin)\n\n.. code-block:: text\n\n    Help on BasicSwapPassManager in module ...preset_passmanagers.builtin_plugins object:\n\n    class BasicSwapPassManager(...preset_passmanagers.plugin.PassManagerStagePlugin)\n     |  Plugin class for routing stage with :class:`~.BasicSwap`\n     |\n     |  Method resolution order:\n     |      BasicSwapPassManager\n     |      ...preset_passmanagers.plugin.PassManagerStagePlugin\n     |      abc.ABC\n     |      builtins.object\n     ...\n\nArgs:\n    stage: The stage name to get\n\nReturns:\n    dict: the key is the name of the plugin and the value is the class type for each.\n\nRaises:\n   TranspilerError: If an invalid stage name is specified.",
        "api_signature": "passmanager_stage_plugins(stage)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/plugin.py"
    },
    {
        "api_name": "pass_manager",
        "full_api_name": "DefaultInitPassManager.pass_manager",
        "api_description": "",
        "api_signature": "pass_manager(self, pass_manager_config, optimization_level)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/builtin_plugins.py"
    },
    {
        "api_name": "pass_manager",
        "full_api_name": "BasisTranslatorPassManager.pass_manager",
        "api_description": "",
        "api_signature": "pass_manager(self, pass_manager_config, optimization_level)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/builtin_plugins.py"
    },
    {
        "api_name": "pass_manager",
        "full_api_name": "UnitarySynthesisPassManager.pass_manager",
        "api_description": "",
        "api_signature": "pass_manager(self, pass_manager_config, optimization_level)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/builtin_plugins.py"
    },
    {
        "api_name": "pass_manager",
        "full_api_name": "BasicSwapPassManager.pass_manager",
        "api_description": "Build routing stage PassManager.",
        "api_signature": "pass_manager(self, pass_manager_config, optimization_level)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/builtin_plugins.py"
    },
    {
        "api_name": "pass_manager",
        "full_api_name": "StochasticSwapPassManager.pass_manager",
        "api_description": "Build routing stage PassManager.",
        "api_signature": "pass_manager(self, pass_manager_config, optimization_level)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/builtin_plugins.py"
    },
    {
        "api_name": "pass_manager",
        "full_api_name": "LookaheadSwapPassManager.pass_manager",
        "api_description": "Build routing stage PassManager.",
        "api_signature": "pass_manager(self, pass_manager_config, optimization_level)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/builtin_plugins.py"
    },
    {
        "api_name": "pass_manager",
        "full_api_name": "SabreSwapPassManager.pass_manager",
        "api_description": "Build routing stage PassManager.",
        "api_signature": "pass_manager(self, pass_manager_config, optimization_level)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/builtin_plugins.py"
    },
    {
        "api_name": "pass_manager",
        "full_api_name": "NoneRoutingPassManager.pass_manager",
        "api_description": "Build routing stage PassManager.",
        "api_signature": "pass_manager(self, pass_manager_config, optimization_level)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/builtin_plugins.py"
    },
    {
        "api_name": "pass_manager",
        "full_api_name": "OptimizationPassManager.pass_manager",
        "api_description": "Build pass manager for optimization stage.",
        "api_signature": "pass_manager(self, pass_manager_config, optimization_level)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/builtin_plugins.py"
    },
    {
        "api_name": "_opt_control",
        "full_api_name": "OptimizationPassManager._opt_control",
        "api_description": "",
        "api_signature": "_opt_control(property_set)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/builtin_plugins.py"
    },
    {
        "api_name": "_opt_control",
        "full_api_name": "OptimizationPassManager._opt_control",
        "api_description": "",
        "api_signature": "_opt_control(property_set)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/builtin_plugins.py"
    },
    {
        "api_name": "_unroll_condition",
        "full_api_name": "OptimizationPassManager._unroll_condition",
        "api_description": "",
        "api_signature": "_unroll_condition(property_set)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/builtin_plugins.py"
    },
    {
        "api_name": "pass_manager",
        "full_api_name": "AlapSchedulingPassManager.pass_manager",
        "api_description": "Build scheduling stage PassManager",
        "api_signature": "pass_manager(self, pass_manager_config, optimization_level)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/builtin_plugins.py"
    },
    {
        "api_name": "pass_manager",
        "full_api_name": "AsapSchedulingPassManager.pass_manager",
        "api_description": "Build scheduling stage PassManager",
        "api_signature": "pass_manager(self, pass_manager_config, optimization_level)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/builtin_plugins.py"
    },
    {
        "api_name": "pass_manager",
        "full_api_name": "DefaultSchedulingPassManager.pass_manager",
        "api_description": "Build scheduling stage PassManager",
        "api_signature": "pass_manager(self, pass_manager_config, optimization_level)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/builtin_plugins.py"
    },
    {
        "api_name": "pass_manager",
        "full_api_name": "DefaultLayoutPassManager.pass_manager",
        "api_description": "",
        "api_signature": "pass_manager(self, pass_manager_config, optimization_level)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/builtin_plugins.py"
    },
    {
        "api_name": "_choose_layout_condition",
        "full_api_name": "DefaultLayoutPassManager._choose_layout_condition",
        "api_description": "",
        "api_signature": "_choose_layout_condition(property_set)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/builtin_plugins.py"
    },
    {
        "api_name": "_layout_not_perfect",
        "full_api_name": "DefaultLayoutPassManager._layout_not_perfect",
        "api_description": "Return ``True`` if the first attempt at layout has been checked and found to be\nimperfect.  In this case, perfection means \"does not require any swap routing\".",
        "api_signature": "_layout_not_perfect(property_set)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/builtin_plugins.py"
    },
    {
        "api_name": "_vf2_match_not_found",
        "full_api_name": "DefaultLayoutPassManager._vf2_match_not_found",
        "api_description": "",
        "api_signature": "_vf2_match_not_found(property_set)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/builtin_plugins.py"
    },
    {
        "api_name": "_swap_mapped",
        "full_api_name": "DefaultLayoutPassManager._swap_mapped",
        "api_description": "",
        "api_signature": "_swap_mapped(property_set)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/builtin_plugins.py"
    },
    {
        "api_name": "pass_manager",
        "full_api_name": "TrivialLayoutPassManager.pass_manager",
        "api_description": "",
        "api_signature": "pass_manager(self, pass_manager_config, optimization_level)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/builtin_plugins.py"
    },
    {
        "api_name": "_choose_layout_condition",
        "full_api_name": "TrivialLayoutPassManager._choose_layout_condition",
        "api_description": "",
        "api_signature": "_choose_layout_condition(property_set)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/builtin_plugins.py"
    },
    {
        "api_name": "pass_manager",
        "full_api_name": "DenseLayoutPassManager.pass_manager",
        "api_description": "",
        "api_signature": "pass_manager(self, pass_manager_config, optimization_level)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/builtin_plugins.py"
    },
    {
        "api_name": "_choose_layout_condition",
        "full_api_name": "DenseLayoutPassManager._choose_layout_condition",
        "api_description": "",
        "api_signature": "_choose_layout_condition(property_set)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/builtin_plugins.py"
    },
    {
        "api_name": "pass_manager",
        "full_api_name": "SabreLayoutPassManager.pass_manager",
        "api_description": "",
        "api_signature": "pass_manager(self, pass_manager_config, optimization_level)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/builtin_plugins.py"
    },
    {
        "api_name": "_choose_layout_condition",
        "full_api_name": "SabreLayoutPassManager._choose_layout_condition",
        "api_description": "",
        "api_signature": "_choose_layout_condition(property_set)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/builtin_plugins.py"
    },
    {
        "api_name": "_swap_mapped",
        "full_api_name": "SabreLayoutPassManager._swap_mapped",
        "api_description": "",
        "api_signature": "_swap_mapped(property_set)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/builtin_plugins.py"
    },
    {
        "api_name": "_get_trial_count",
        "full_api_name": "_get_trial_count",
        "api_description": "",
        "api_signature": "_get_trial_count(default_trials)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/builtin_plugins.py"
    },
    {
        "api_name": "level_3_pass_manager",
        "full_api_name": "level_3_pass_manager",
        "api_description": "Level 3 pass manager: heavy optimization by noise adaptive qubit mapping and\ngate cancellation using commutativity rules and unitary synthesis.\n\nThis pass manager applies the user-given initial layout. If none is given, a search\nfor a perfect layout (i.e. one that satisfies all 2-qubit interactions) is conducted.\nIf no such layout is found, and device calibration information is available, the\ncircuit is mapped to the qubits with best readouts and to CX gates with highest fidelity.\n\nThe pass manager then transforms the circuit to match the coupling constraints.\nIt is then unrolled to the basis, and any flipped cx directions are fixed.\nFinally, optimizations in the form of commutative gate cancellation, resynthesis\nof two-qubit unitary blocks, and redundant reset removal are performed.\n\nArgs:\n    pass_manager_config: configuration of the pass manager.\n\nReturns:\n    a level 3 pass manager.\n\nRaises:\n    TranspilerError: if the passmanager config is invalid.",
        "api_signature": "level_3_pass_manager(pass_manager_config)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/level3.py"
    },
    {
        "api_name": "level_1_pass_manager",
        "full_api_name": "level_1_pass_manager",
        "api_description": "Level 1 pass manager: light optimization by simple adjacent gate collapsing.\n\nThis pass manager applies the user-given initial layout. If none is given,\nand a trivial layout (i-th virtual -> i-th physical) makes the circuit fit\nthe coupling map, that is used.\nOtherwise, the circuit is mapped to the most densely connected coupling subgraph,\nand swaps are inserted to map. Any unused physical qubit is allocated as ancilla space.\nThe pass manager then unrolls the circuit to the desired basis, and transforms the\ncircuit to match the coupling map. Finally, optimizations in the form of adjacent\ngate collapse and redundant reset removal are performed.\n\nArgs:\n    pass_manager_config: configuration of the pass manager.\n\nReturns:\n    a level 1 pass manager.\n\nRaises:\n    TranspilerError: if the passmanager config is invalid.",
        "api_signature": "level_1_pass_manager(pass_manager_config)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/level1.py"
    },
    {
        "api_name": "generate_preset_pass_manager",
        "full_api_name": "generate_preset_pass_manager",
        "api_description": "Generate a preset :class:`~.PassManager`\n\nThis function is used to quickly generate a preset pass manager. Preset pass\nmanagers are the default pass managers used by the :func:`~.transpile`\nfunction. This function provides a convenient and simple method to construct\na standalone :class:`~.PassManager` object that mirrors what the :func:`~.transpile`\nfunction internally builds and uses.\n\nThe target constraints for the pass manager construction can be specified through a :class:`.Target`\ninstance, a :class:`.BackendV1` or :class:`.BackendV2` instance, or via loose constraints\n(``basis_gates``, ``inst_map``, ``coupling_map``, ``backend_properties``, ``instruction_durations``,\n``dt`` or ``timing_constraints``).\nThe order of priorities for target constraints works as follows: if a ``target``\ninput is provided, it will take priority over any ``backend`` input or loose constraints.\nIf a ``backend`` is provided together with any loose constraint\nfrom the list above, the loose constraint will take priority over the corresponding backend\nconstraint. This behavior is independent of whether the ``backend`` instance is of type\n:class:`.BackendV1` or :class:`.BackendV2`, as summarized in the table below. The first column\nin the table summarizes the potential user-provided constraints, and each cell shows whether\nthe priority is assigned to that specific constraint input or another input\n(`target`/`backend(V1)`/`backend(V2)`).\n\n============================ ========= ======================== =======================\nUser Provided                target    backend(V1)              backend(V2)\n============================ ========= ======================== =======================\n**basis_gates**              target    basis_gates              basis_gates\n**coupling_map**             target    coupling_map             coupling_map\n**instruction_durations**    target    instruction_durations    instruction_durations\n**inst_map**                 target    inst_map                 inst_map\n**dt**                       target    dt                       dt\n**timing_constraints**       target    timing_constraints       timing_constraints\n**backend_properties**       target    backend_properties       backend_properties\n============================ ========= ======================== =======================\n\nArgs:\n    optimization_level (int): The optimization level to generate a\n        :class:`~.PassManager` for. This can be 0, 1, 2, or 3. Higher\n        levels generate more optimized circuits, at the expense of\n        longer transpilation time:\n\n            * 0: no optimization\n            * 1: light optimization\n            * 2: heavy optimization\n            * 3: even heavier optimization\n\n    backend (Backend): An optional backend object which can be used as the\n        source of the default values for the ``basis_gates``, ``inst_map``,\n        ``coupling_map``, ``backend_properties``, ``instruction_durations``,\n        ``timing_constraints``, and ``target``. If any of those other arguments\n        are specified in addition to ``backend`` they will take precedence\n        over the value contained in the backend.\n    target (Target): The :class:`~.Target` representing a backend compilation\n        target. The following attributes will be inferred from this\n        argument if they are not set: ``coupling_map``, ``basis_gates``,\n        ``instruction_durations``, ``inst_map``, ``timing_constraints``\n        and ``backend_properties``.\n    basis_gates (list): List of basis gate names to unroll to\n        (e.g: ``['u1', 'u2', 'u3', 'cx']``).\n    inst_map (InstructionScheduleMap): Mapping object that maps gates to schedules.\n        If any user defined calibration is found in the map and this is used in a\n        circuit, transpiler attaches the custom gate definition to the circuit.\n        This enables one to flexibly override the low-level instruction\n        implementation.\n    coupling_map (CouplingMap or list): Directed graph represented a coupling\n        map. Multiple formats are supported:\n\n        #. ``CouplingMap`` instance\n        #. List, must be given as an adjacency matrix, where each entry\n           specifies all directed two-qubit interactions supported by backend,\n           e.g: ``[[0, 1], [0, 3], [1, 2], [1, 5], [2, 5], [4, 1], [5, 3]]``\n\n    instruction_durations (InstructionDurations or list): Dictionary of duration\n        (in dt) for each instruction. If specified, these durations overwrite the\n        gate lengths in ``backend.properties``. Applicable only if ``scheduling_method``\n        is specified.\n        The format of ``instruction_durations`` must be as follows:\n        They must be given as an :class:`.InstructionDurations` instance or a list of tuples\n\n        ```\n        [(instruction_name, qubits, duration, unit), ...].\n        | [('cx', [0, 1], 12.3, 'ns'), ('u3', [0], 4.56, 'ns')]\n        | [('cx', [0, 1], 1000), ('u3', [0], 300)]\n        ```\n\n        If ``unit`` is omitted, the default is ``'dt'``, which is a sample time depending on backend.\n        If the time unit is ``'dt'``, the duration must be an integer.\n    dt (float): Backend sample time (resolution) in seconds.\n        If provided, this value will overwrite the ``dt`` value in ``instruction_durations``.\n        If ``None`` (default) and a backend is provided, ``backend.dt`` is used.\n    timing_constraints (TimingConstraints): Hardware time alignment restrictions.\n         A quantum computer backend may report a set of restrictions, namely:\n\n            - granularity: An integer value representing minimum pulse gate\n              resolution in units of ``dt``. A user-defined pulse gate should have\n              duration of a multiple of this granularity value.\n            - min_length: An integer value representing minimum pulse gate\n              length in units of ``dt``. A user-defined pulse gate should be longer\n              than this length.\n            - pulse_alignment: An integer value representing a time resolution of gate\n              instruction starting time. Gate instruction should start at time which\n              is a multiple of the alignment value.\n            - acquire_alignment: An integer value representing a time resolution of measure\n              instruction starting time. Measure instruction should start at time which\n              is a multiple of the alignment value.\n\n            This information will be provided by the backend configuration.\n            If the backend doesn't have any restriction on the instruction time allocation,\n            then ``timing_constraints`` is None and no adjustment will be performed.\n\n    initial_layout (Layout | List[int]): Initial position of virtual qubits on\n        physical qubits.\n    layout_method (str): The :class:`~.Pass` to use for choosing initial qubit\n        placement. Valid choices are ``'trivial'``, ``'dense'``,\n        and ``'sabre'``, representing :class:`~.TrivialLayout`, :class:`~.DenseLayout` and\n        :class:`~.SabreLayout` respectively. This can also\n        be the external plugin name to use for the ``layout`` stage of the output\n        :class:`~.StagedPassManager`. You can see a list of installed plugins by using\n        :func:`~.list_stage_plugins` with ``\"layout\"`` for the ``stage_name`` argument.\n    routing_method (str): The pass to use for routing qubits on the\n        architecture. Valid choices are ``'basic'``, ``'lookahead'``, ``'stochastic'``,\n        ``'sabre'``, and ``'none'`` representing :class:`~.BasicSwap`,\n        :class:`~.LookaheadSwap`, :class:`~.StochasticSwap`, :class:`~.SabreSwap`, and\n        erroring if routing is required respectively. This can also be the external plugin\n        name to use for the ``routing`` stage of the output :class:`~.StagedPassManager`.\n        You can see a list of installed plugins by using :func:`~.list_stage_plugins` with\n        ``\"routing\"`` for the ``stage_name`` argument.\n    translation_method (str): The method to use for translating gates to\n        basis gates. Valid choices ``'translator'``, ``'synthesis'`` representing\n        :class:`~.BasisTranslator`, and :class:`~.UnitarySynthesis` respectively. This can\n        also be the external plugin name to use for the ``translation`` stage of the output\n        :class:`~.StagedPassManager`. You can see a list of installed plugins by using\n        :func:`~.list_stage_plugins` with ``\"translation\"`` for the ``stage_name`` argument.\n    scheduling_method (str): The pass to use for scheduling instructions. Valid choices\n        are ``'alap'`` and ``'asap'``. This can also be the external plugin name to use\n        for the ``scheduling`` stage of the output :class:`~.StagedPassManager`. You can\n        see a list of installed plugins by using :func:`~.list_stage_plugins` with\n        ``\"scheduling\"`` for the ``stage_name`` argument.\n    backend_properties (BackendProperties): Properties returned by a\n        backend, including information on gate errors, readout errors,\n        qubit coherence times, etc.\n    approximation_degree (float): Heuristic dial used for circuit approximation\n        (1.0=no approximation, 0.0=maximal approximation).\n    seed_transpiler (int): Sets random seed for the stochastic parts of\n        the transpiler.\n    unitary_synthesis_method (str): The name of the unitary synthesis\n        method to use. By default ``'default'`` is used. You can see a list of\n        installed plugins with :func:`.unitary_synthesis_plugin_names`.\n    unitary_synthesis_plugin_config (dict): An optional configuration dictionary\n        that will be passed directly to the unitary synthesis plugin. By\n        default this setting will have no effect as the default unitary\n        synthesis method does not take custom configuration. This should\n        only be necessary when a unitary synthesis plugin is specified with\n        the ``unitary_synthesis_method`` argument. As this is custom for each\n        unitary synthesis plugin refer to the plugin documentation for how\n        to use this option.\n    hls_config (HLSConfig): An optional configuration class :class:`~.HLSConfig`\n        that will be passed directly to :class:`~.HighLevelSynthesis` transformation pass.\n        This configuration class allows to specify for various high-level objects\n        the lists of synthesis algorithms and their parameters.\n    init_method (str): The plugin name to use for the ``init`` stage of\n        the output :class:`~.StagedPassManager`. By default an external\n        plugin is not used. You can see a list of installed plugins by\n        using :func:`~.list_stage_plugins` with ``\"init\"`` for the stage\n        name argument.\n    optimization_method (str): The plugin name to use for the\n        ``optimization`` stage of the output\n        :class:`~.StagedPassManager`. By default an external\n        plugin is not used. You can see a list of installed plugins by\n        using :func:`~.list_stage_plugins` with ``\"optimization\"`` for the\n        ``stage_name`` argument.\n\nReturns:\n    StagedPassManager: The preset pass manager for the given options\n\nRaises:\n    ValueError: if an invalid value for ``optimization_level`` is passed in.",
        "api_signature": "generate_preset_pass_manager(optimization_level, backend, target, basis_gates, inst_map, coupling_map, instruction_durations, backend_properties, timing_constraints, initial_layout, layout_method, routing_method, translation_method, scheduling_method, approximation_degree, seed_transpiler, unitary_synthesis_method, unitary_synthesis_plugin_config, hls_config, init_method, optimization_method, dt)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/generate_preset_pass_manager.py"
    },
    {
        "api_name": "_parse_basis_gates",
        "full_api_name": "_parse_basis_gates",
        "api_description": "",
        "api_signature": "_parse_basis_gates(basis_gates, backend, inst_map, skip_target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/generate_preset_pass_manager.py"
    },
    {
        "api_name": "_parse_inst_map",
        "full_api_name": "_parse_inst_map",
        "api_description": "",
        "api_signature": "_parse_inst_map(inst_map, backend)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/generate_preset_pass_manager.py"
    },
    {
        "api_name": "_parse_backend_properties",
        "full_api_name": "_parse_backend_properties",
        "api_description": "",
        "api_signature": "_parse_backend_properties(backend_properties, backend)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/generate_preset_pass_manager.py"
    },
    {
        "api_name": "_parse_dt",
        "full_api_name": "_parse_dt",
        "api_description": "",
        "api_signature": "_parse_dt(dt, backend)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/generate_preset_pass_manager.py"
    },
    {
        "api_name": "_parse_coupling_map",
        "full_api_name": "_parse_coupling_map",
        "api_description": "",
        "api_signature": "_parse_coupling_map(coupling_map, backend)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/generate_preset_pass_manager.py"
    },
    {
        "api_name": "_parse_instruction_durations",
        "full_api_name": "_parse_instruction_durations",
        "api_description": "Create a list of ``InstructionDuration``s. If ``inst_durations`` is provided,\nthe backend will be ignored, otherwise, the durations will be populated from the\nbackend.",
        "api_signature": "_parse_instruction_durations(backend, inst_durations, dt)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/generate_preset_pass_manager.py"
    },
    {
        "api_name": "_parse_timing_constraints",
        "full_api_name": "_parse_timing_constraints",
        "api_description": "",
        "api_signature": "_parse_timing_constraints(backend, timing_constraints)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/generate_preset_pass_manager.py"
    },
    {
        "api_name": "_parse_initial_layout",
        "full_api_name": "_parse_initial_layout",
        "api_description": "",
        "api_signature": "_parse_initial_layout(initial_layout)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/generate_preset_pass_manager.py"
    },
    {
        "api_name": "_parse_approximation_degree",
        "full_api_name": "_parse_approximation_degree",
        "api_description": "",
        "api_signature": "_parse_approximation_degree(approximation_degree)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/generate_preset_pass_manager.py"
    },
    {
        "api_name": "level_2_pass_manager",
        "full_api_name": "level_2_pass_manager",
        "api_description": "Level 2 pass manager: medium optimization by initial layout selection and\ngate cancellation using commutativity rules.\n\nThis pass manager applies the user-given initial layout. If none is given, a search\nfor a perfect layout (i.e. one that satisfies all 2-qubit interactions) is conducted.\nIf no such layout is found, qubits are laid out on the most densely connected subset\nwhich also exhibits the best gate fidelities.\n\nThe pass manager then transforms the circuit to match the coupling constraints.\nIt is then unrolled to the basis, and any flipped cx directions are fixed.\nFinally, optimizations in the form of commutative gate cancellation and redundant\nreset removal are performed.\n\nArgs:\n    pass_manager_config: configuration of the pass manager.\n\nReturns:\n    a level 2 pass manager.\n\nRaises:\n    TranspilerError: if the passmanager config is invalid.",
        "api_signature": "level_2_pass_manager(pass_manager_config)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/preset_passmanagers/level2.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "FilterOpNodes.__init__",
        "api_description": "",
        "api_signature": "__init__(self, predicate)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/filter_op_nodes.py"
    },
    {
        "api_name": "run",
        "full_api_name": "FilterOpNodes.run",
        "api_description": "Run the RemoveBarriers pass on `dag`.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/filter_op_nodes.py"
    },
    {
        "api_name": "map_blocks",
        "full_api_name": "map_blocks",
        "api_description": "Use the ``dag_mapping`` function to replace the blocks of a :class:`.ControlFlowOp` with new\nones.  Each block will be automatically converted to a :class:`.DAGCircuit` and then returned\nto a :class:`.QuantumCircuit`.",
        "api_signature": "map_blocks(dag_mapping, op)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/control_flow.py"
    },
    {
        "api_name": "trivial_recurse",
        "full_api_name": "trivial_recurse",
        "api_description": "Decorator that causes :class:`.BasePass.run` to iterate over all control-flow nodes,\nreplacing their operations with a new :class:`.ControlFlowOp` whose blocks have all had\n:class`.BasePass.run` called on them.\n\nThis is only suitable for simple run calls that store no state between calls, do not need\ncircuit-specific information feeding into them (such as via a :class:`.PropertySet`), and will\nsafely do nothing to control-flow operations that are in the DAG.\n\nIf slightly finer control is needed on when the control-flow operations are modified, one can\nuse :func:`map_blocks` as::\n\n    if isinstance(node.op, ControlFlowOp):\n        node.op = map_blocks(self.run, node.op)\n\nfrom with :meth:`.BasePass.run`.",
        "api_signature": "trivial_recurse(method)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/control_flow.py"
    },
    {
        "api_name": "out",
        "full_api_name": "out",
        "api_description": "",
        "api_signature": "out(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/control_flow.py"
    },
    {
        "api_name": "bound_wrapped_method",
        "full_api_name": "bound_wrapped_method",
        "api_description": "",
        "api_signature": "bound_wrapped_method(dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/control_flow.py"
    },
    {
        "api_name": "run",
        "full_api_name": "RemoveBarriers.run",
        "api_description": "Run the RemoveBarriers pass on `dag`.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/remove_barriers.py"
    },
    {
        "api_name": "_calc_final_ops",
        "full_api_name": "RemoveFinalMeasurements._calc_final_ops",
        "api_description": "",
        "api_signature": "_calc_final_ops(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/remove_final_measurements.py"
    },
    {
        "api_name": "run",
        "full_api_name": "RemoveFinalMeasurements.run",
        "api_description": "Run the RemoveFinalMeasurements pass on `dag`.\n\nArgs:\n    dag (DAGCircuit): the DAG to be optimized.\n\nReturns:\n    DAGCircuit: the optimized DAG.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/remove_final_measurements.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BarrierBeforeFinalMeasurements.__init__",
        "api_description": "",
        "api_signature": "__init__(self, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/barrier_before_final_measurements.py"
    },
    {
        "api_name": "run",
        "full_api_name": "BarrierBeforeFinalMeasurements.run",
        "api_description": "Run the BarrierBeforeFinalMeasurements pass on `dag`.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/barrier_before_final_measurements.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Error.__init__",
        "api_description": "Error pass.\n\nArgs:\n    msg (str | Callable[[PropertySet], str]): Error message, if not provided a generic error\n        will be used.  This can be either a raw string, or a callback function that accepts\n        the current ``property_set`` and returns the desired message.\n    action (str): the action to perform. Default: 'raise'. The options are:\n      * ``'raise'``: Raises a ``TranspilerError`` exception with msg\n      * ``'warn'``: Raises a non-fatal warning with msg\n      * ``'log'``: logs in ``logging.getLogger(__name__)``\n\nRaises:\n    TranspilerError: if action is not valid.",
        "api_signature": "__init__(self, msg, action)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/error.py"
    },
    {
        "api_name": "run",
        "full_api_name": "Error.run",
        "api_description": "Run the Error pass on `dag`.",
        "api_signature": "run(self, _)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/error.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "GatesInBasis.__init__",
        "api_description": "Initialize the GatesInBasis pass.\n\nArgs:\n    basis_gates (list): The list of strings representing the set of basis gates.\n    target (Target): The target representing the backend. If specified\n        this will be used instead of the ``basis_gates`` parameter",
        "api_signature": "__init__(self, basis_gates, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/gates_basis.py"
    },
    {
        "api_name": "run",
        "full_api_name": "GatesInBasis.run",
        "api_description": "Run the GatesInBasis pass on `dag`.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/gates_basis.py"
    },
    {
        "api_name": "_visit_target",
        "full_api_name": "GatesInBasis._visit_target",
        "api_description": "",
        "api_signature": "_visit_target(dag, wire_map)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/gates_basis.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ContainsInstruction.__init__",
        "api_description": "ContainsInstruction initializer.\n\nArgs:\n    instruction_name (str | Iterable[str]): The instruction or instructions to check are in\n        the DAG. The output in the property set is set to ``contains_`` prefixed on each\n        value for this parameter.\n    recurse (bool): if ``True`` (default), then recurse into control-flow operations.",
        "api_signature": "__init__(self, instruction_name, recurse)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/contains_instruction.py"
    },
    {
        "api_name": "run",
        "full_api_name": "ContainsInstruction.run",
        "api_description": "Run the ContainsInstruction pass on dag.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/contains_instruction.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CheckMap.__init__",
        "api_description": "CheckMap initializer.\n\nArgs:\n    coupling_map (Union[CouplingMap, Target]): Directed graph representing a coupling map.\n    property_set_field (str): An optional string to specify the property set field to\n        store the result of the check. If not default the result is stored in\n        ``\"is_swap_mapped\"``.",
        "api_signature": "__init__(self, coupling_map, property_set_field)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/check_map.py"
    },
    {
        "api_name": "run",
        "full_api_name": "CheckMap.run",
        "api_description": "Run the CheckMap pass on `dag`.\n\nIf `dag` is mapped to `coupling_map`, the property\n`is_swap_mapped` is set to True (or to False otherwise).\n\nArgs:\n    dag (DAGCircuit): DAG to map.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/check_map.py"
    },
    {
        "api_name": "_recurse",
        "full_api_name": "CheckMap._recurse",
        "api_description": "",
        "api_signature": "_recurse(self, dag, wire_map)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/check_map.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "UnrollForLoops.__init__",
        "api_description": "Things like ``for x in {0, 3, 4} {rx(x) qr[1];}`` will turn into\n``rx(0) qr[1]; rx(3) qr[1]; rx(4) qr[1];``.\n\n.. note::\n    The ``UnrollForLoops`` unrolls only one level of block depth. No inner loop will\n    be considered by ``max_target_depth``.\n\nArgs:\n    max_target_depth (int): Optional. Checks if the unrolled block is over a particular\n        subcircuit depth. To disable the check, use ``-1`` (Default).",
        "api_signature": "__init__(self, max_target_depth)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/unroll_forloops.py"
    },
    {
        "api_name": "run",
        "full_api_name": "UnrollForLoops.run",
        "api_description": "Run the UnrollForLoops pass on ``dag``.\n\nArgs:\n    dag (DAGCircuit): the directed acyclic graph to run on.\n\nReturns:\n    DAGCircuit: Transformed DAG.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/unroll_forloops.py"
    },
    {
        "api_name": "_body_contains_continue_or_break",
        "full_api_name": "_body_contains_continue_or_break",
        "api_description": "Checks if a circuit contains ``continue``s or ``break``s. Conditional bodies are inspected.",
        "api_signature": "_body_contains_continue_or_break(circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/unroll_forloops.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "FixedPoint.__init__",
        "api_description": "FixedPoint initializer.\n\nArgs:\n    property_to_check (str): The property to check if a fixed point was reached.",
        "api_signature": "__init__(self, property_to_check)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/fixed_point.py"
    },
    {
        "api_name": "run",
        "full_api_name": "FixedPoint.run",
        "api_description": "Run the FixedPoint pass on `dag`.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/fixed_point.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "MinimumPoint.__init__",
        "api_description": "Initialize an instance of this pass\n\nArgs:\n    property_set_list (list): A list of property set keys that will\n        be used to evaluate the local minimum. The values of these\n        property set keys will be used as a tuple for comparison\n    prefix (str): The prefix to use for the property set key that is used\n        for tracking previous evaluations\n    backtrack_depth (int): The maximum number of entries to store. If\n        this number is reached and the next iteration doesn't have\n        a decrease in the number of values the minimum of the previous\n        n will be set as the output dag and ``minimum_point`` will be set to\n        ``True`` in the property set",
        "api_signature": "__init__(self, property_set_list, prefix, backtrack_depth)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/minimum_point.py"
    },
    {
        "api_name": "run",
        "full_api_name": "MinimumPoint.run",
        "api_description": "Run the MinimumPoint pass on `dag`.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/minimum_point.py"
    },
    {
        "api_name": "_run_inner",
        "full_api_name": "ConvertConditionsToIfOps._run_inner",
        "api_description": "Run the pass on one :class:`.DAGCircuit`, mutating it.  Returns ``True`` if the circuit\nwas modified and ``False`` if not.",
        "api_signature": "_run_inner(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/convert_conditions_to_if_ops.py"
    },
    {
        "api_name": "run",
        "full_api_name": "ConvertConditionsToIfOps.run",
        "api_description": "",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/convert_conditions_to_if_ops.py"
    },
    {
        "api_name": "run",
        "full_api_name": "MergeAdjacentBarriers.run",
        "api_description": "Run the MergeAdjacentBarriers pass on `dag`.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/merge_adjacent_barriers.py"
    },
    {
        "api_name": "_collect_potential_merges",
        "full_api_name": "MergeAdjacentBarriers._collect_potential_merges",
        "api_description": "Return the potential merges.\n\nReturns a dict of DAGOpNode: (Barrier, [DAGOpNode]) objects, where the barrier needs to be\ninserted where the corresponding index DAGOpNode appears in the main DAG, in replacement of\nthe listed DAGOpNodes.",
        "api_signature": "_collect_potential_merges(dag, barriers)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/merge_adjacent_barriers.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CheckGateDirection.__init__",
        "api_description": "CheckGateDirection initializer.\n\nArgs:\n    coupling_map (CouplingMap): Directed graph representing a coupling map.\n    target (Target): The backend target to use for this pass. If this is specified\n        it will be used instead of the coupling map",
        "api_signature": "__init__(self, coupling_map, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/check_gate_direction.py"
    },
    {
        "api_name": "_coupling_map_visit",
        "full_api_name": "CheckGateDirection._coupling_map_visit",
        "api_description": "",
        "api_signature": "_coupling_map_visit(self, dag, wire_map, edges)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/check_gate_direction.py"
    },
    {
        "api_name": "_target_visit",
        "full_api_name": "CheckGateDirection._target_visit",
        "api_description": "",
        "api_signature": "_target_visit(self, dag, wire_map)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/check_gate_direction.py"
    },
    {
        "api_name": "run",
        "full_api_name": "CheckGateDirection.run",
        "api_description": "Run the CheckGateDirection pass on `dag`.\n\nIf `dag` is mapped and the direction is correct the property\n`is_direction_mapped` is set to True (or to False otherwise).\n\nArgs:\n    dag (DAGCircuit): DAG to check.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/check_gate_direction.py"
    },
    {
        "api_name": "_swap_node_qargs",
        "full_api_name": "_swap_node_qargs",
        "api_description": "",
        "api_signature": "_swap_node_qargs(node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/gate_direction.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "GateDirection.__init__",
        "api_description": "GateDirection pass.\n\nArgs:\n    coupling_map (CouplingMap): Directed graph represented a coupling map.\n    target (Target): The backend target to use for this pass. If this is specified\n        it will be used instead of the coupling map",
        "api_signature": "__init__(self, coupling_map, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/gate_direction.py"
    },
    {
        "api_name": "_rzx_dag",
        "full_api_name": "GateDirection._rzx_dag",
        "api_description": "",
        "api_signature": "_rzx_dag(parameter)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/gate_direction.py"
    },
    {
        "api_name": "_rxx_dag",
        "full_api_name": "GateDirection._rxx_dag",
        "api_description": "",
        "api_signature": "_rxx_dag(parameter)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/gate_direction.py"
    },
    {
        "api_name": "_ryy_dag",
        "full_api_name": "GateDirection._ryy_dag",
        "api_description": "",
        "api_signature": "_ryy_dag(parameter)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/gate_direction.py"
    },
    {
        "api_name": "_rzz_dag",
        "full_api_name": "GateDirection._rzz_dag",
        "api_description": "",
        "api_signature": "_rzz_dag(parameter)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/gate_direction.py"
    },
    {
        "api_name": "_run_coupling_map",
        "full_api_name": "GateDirection._run_coupling_map",
        "api_description": "",
        "api_signature": "_run_coupling_map(self, dag, wire_map, edges)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/gate_direction.py"
    },
    {
        "api_name": "_run_target",
        "full_api_name": "GateDirection._run_target",
        "api_description": "",
        "api_signature": "_run_target(self, dag, wire_map)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/gate_direction.py"
    },
    {
        "api_name": "run",
        "full_api_name": "GateDirection.run",
        "api_description": "Run the GateDirection pass on `dag`.\n\nFlips the cx nodes to match the directed coupling map. Modifies the\ninput dag.\n\nArgs:\n    dag (DAGCircuit): DAG to map.\n\nReturns:\n    DAGCircuit: The rearranged dag for the coupling map\n\nRaises:\n    TranspilerError: If the circuit cannot be mapped just by flipping the\n        cx nodes.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/gate_direction.py"
    },
    {
        "api_name": "run",
        "full_api_name": "DAGFixedPoint.run",
        "api_description": "Run the DAGFixedPoint pass on `dag`.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/utils/dag_fixed_point.py"
    },
    {
        "api_name": "run",
        "full_api_name": "Width.run",
        "api_description": "Run the Width pass on `dag`.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/analysis/width.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ResourceEstimation.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/analysis/resource_estimation.py"
    },
    {
        "api_name": "run",
        "full_api_name": "ResourceEstimation.run",
        "api_description": "Run the ResourceEstimation pass on `dag`.",
        "api_signature": "run(self, _)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/analysis/resource_estimation.py"
    },
    {
        "api_name": "run",
        "full_api_name": "DAGLongestPath.run",
        "api_description": "Run the DAGLongestPath pass on `dag`.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/analysis/dag_longest_path.py"
    },
    {
        "api_name": "run",
        "full_api_name": "NumQubits.run",
        "api_description": "Run the NumQubits pass on `dag`.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/analysis/num_qubits.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CountOps.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/analysis/count_ops.py"
    },
    {
        "api_name": "run",
        "full_api_name": "CountOps.run",
        "api_description": "Run the CountOps pass on `dag`.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/analysis/count_ops.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Size.__init__",
        "api_description": "Args:\n    recurse: whether to allow recursion into control flow.  If this is ``False`` (default),\n        the pass will throw an error when control flow is present, to avoid returning a\n        number with little meaning.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/analysis/size.py"
    },
    {
        "api_name": "run",
        "full_api_name": "Size.run",
        "api_description": "Run the Size pass on `dag`.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/analysis/size.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Depth.__init__",
        "api_description": "Args:\n    recurse: whether to allow recursion into control flow.  If this is ``False`` (default),\n        the pass will throw an error when control flow is present, to avoid returning a\n        number with little meaning.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/analysis/depth.py"
    },
    {
        "api_name": "run",
        "full_api_name": "Depth.run",
        "api_description": "Run the Depth pass on `dag`.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/analysis/depth.py"
    },
    {
        "api_name": "run",
        "full_api_name": "CountOpsLongestPath.run",
        "api_description": "Run the CountOpsLongestPath pass on `dag`.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/analysis/count_ops_longest_path.py"
    },
    {
        "api_name": "run",
        "full_api_name": "NumTensorFactors.run",
        "api_description": "Run the NumTensorFactors pass on `dag`.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/analysis/num_tensor_factors.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "FullAncillaAllocation.__init__",
        "api_description": "FullAncillaAllocation initializer.\n\nArgs:\n    coupling_map (Union[CouplingMap, Target]): directed graph representing a coupling map.",
        "api_signature": "__init__(self, coupling_map)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/full_ancilla_allocation.py"
    },
    {
        "api_name": "run",
        "full_api_name": "FullAncillaAllocation.run",
        "api_description": "Run the FullAncillaAllocation pass on `dag`.\n\nExtend the layout with new (physical qubit, virtual qubit) pairs.\nThe dag signals which virtual qubits are already in the circuit.\nThis pass will allocate new virtual qubits such that no collision occurs\n(i.e. Layout bijectivity is preserved)\n\nThe coupling_map and layout together determine which physical qubits are free.\n\nArgs:\n    dag (DAGCircuit): circuit to analyze\n\nReturns:\n    DAGCircuit: returns the same dag circuit, unmodified\n\nRaises:\n    TranspilerError: If there is not layout in the property set or not set at init time.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/full_ancilla_allocation.py"
    },
    {
        "api_name": "validate_layout",
        "full_api_name": "FullAncillaAllocation.validate_layout",
        "api_description": "Checks if all the qregs in ``layout_qregs`` already exist in ``dag_qregs``. Otherwise, raise.",
        "api_signature": "validate_layout(layout_qubits, dag_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/full_ancilla_allocation.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "VF2Layout.__init__",
        "api_description": "Initialize a ``VF2Layout`` pass instance\n\nArgs:\n    coupling_map (CouplingMap): Directed graph representing a coupling map.\n    strict_direction (bool): If True, considers the direction of the coupling map.\n                             Default is False.\n    seed (int): Sets the seed of the PRNG. -1 Means no node shuffling.\n    call_limit (int): The number of state visits to attempt in each execution of\n        VF2.\n    time_limit (float): The total time limit in seconds to run ``VF2Layout``\n    properties (BackendProperties): The backend properties for the backend. If\n        :meth:`~qiskit.providers.models.BackendProperties.readout_error` is available\n        it is used to score the layout.\n    max_trials (int): The maximum number of trials to run VF2 to find\n        a layout. If this is not specified the number of trials will be limited\n        based on the number of edges in the interaction graph or the coupling graph\n        (whichever is larger) if no other limits are set. If set to a value <= 0 no\n        limit on the number of trials will be set.\n    target (Target): A target representing the backend device to run ``VF2Layout`` on.\n        If specified it will supersede a set value for ``properties`` and\n        ``coupling_map`` if the :class:`.Target` contains connectivity constraints. If the value\n        of ``target`` models an ideal backend without any constraints then the value of\n        ``coupling_map``\n        will be used.\n\nRaises:\n    TypeError: At runtime, if neither ``coupling_map`` or ``target`` are provided.",
        "api_signature": "__init__(self, coupling_map, strict_direction, seed, call_limit, time_limit, properties, max_trials, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/vf2_layout.py"
    },
    {
        "api_name": "run",
        "full_api_name": "VF2Layout.run",
        "api_description": "run the layout method",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/vf2_layout.py"
    },
    {
        "api_name": "mapping_to_layout",
        "full_api_name": "VF2Layout.mapping_to_layout",
        "api_description": "",
        "api_signature": "mapping_to_layout(layout_mapping)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/vf2_layout.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "TrivialLayout.__init__",
        "api_description": "TrivialLayout initializer.\n\nArgs:\n    coupling_map (Union[CouplingMap, Target]): directed graph representing a coupling map.\n\nRaises:\n    TranspilerError: if invalid options",
        "api_signature": "__init__(self, coupling_map)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/trivial_layout.py"
    },
    {
        "api_name": "run",
        "full_api_name": "TrivialLayout.run",
        "api_description": "Run the TrivialLayout pass on `dag`.\n\nArgs:\n    dag (DAGCircuit): DAG to find layout for.\n\nRaises:\n    TranspilerError: if dag wider than the target backend",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/trivial_layout.py"
    },
    {
        "api_name": "run_pass_over_connected_components",
        "full_api_name": "run_pass_over_connected_components",
        "api_description": "Run a transpiler pass inner function over mapped components.",
        "api_signature": "run_pass_over_connected_components(dag, components_source, run_func)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/disjoint_utils.py"
    },
    {
        "api_name": "map_components",
        "full_api_name": "map_components",
        "api_description": "Returns a map where the key is the index of each connected component in cmap_components and\nthe value is a list of indices from dag_components which should be placed onto it.",
        "api_signature": "map_components(dag_components, cmap_components)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/disjoint_utils.py"
    },
    {
        "api_name": "split_barriers",
        "full_api_name": "split_barriers",
        "api_description": "Mutate an input dag to split barriers into single qubit barriers.",
        "api_signature": "split_barriers(dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/disjoint_utils.py"
    },
    {
        "api_name": "combine_barriers",
        "full_api_name": "combine_barriers",
        "api_description": "Mutate input dag to combine barriers with UUID labels into a single barrier.",
        "api_signature": "combine_barriers(dag, retain_uuid)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/disjoint_utils.py"
    },
    {
        "api_name": "require_layout_isolated_to_component",
        "full_api_name": "require_layout_isolated_to_component",
        "api_description": "Check that the layout of the dag does not require connectivity across connected components\nin the CouplingMap\n\nArgs:\n    dag: DAGCircuit to check.\n    components_source: Target to check against.\n\nRaises:\n    TranspilerError: Chosen layout is not valid for the target disjoint connectivity.",
        "api_signature": "require_layout_isolated_to_component(dag, components_source)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/disjoint_utils.py"
    },
    {
        "api_name": "separate_dag",
        "full_api_name": "separate_dag",
        "api_description": "Separate a dag circuit into it's connected components.",
        "api_signature": "separate_dag(dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/disjoint_utils.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CustomSolver.__init__",
        "api_description": "",
        "api_signature": "__init__(self, call_limit, time_limit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/_csp_custom_solver.py"
    },
    {
        "api_name": "limit_reached",
        "full_api_name": "CustomSolver.limit_reached",
        "api_description": "Checks if a limit is reached.",
        "api_signature": "limit_reached(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/_csp_custom_solver.py"
    },
    {
        "api_name": "getSolution",
        "full_api_name": "CustomSolver.getSolution",
        "api_description": "Wrap RecursiveBacktrackingSolver.getSolution to add the limits.",
        "api_signature": "getSolution(self, domains, constraints, vconstraints)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/_csp_custom_solver.py"
    },
    {
        "api_name": "recursiveBacktracking",
        "full_api_name": "CustomSolver.recursiveBacktracking",
        "api_description": "Like ``constraint.RecursiveBacktrackingSolver.recursiveBacktracking`` but\nlimited in the amount of calls by ``self.call_limit``",
        "api_signature": "recursiveBacktracking(self, solutions, domains, vconstraints, assignments, single)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/_csp_custom_solver.py"
    },
    {
        "api_name": "run",
        "full_api_name": "EnlargeWithAncilla.run",
        "api_description": "Run the EnlargeWithAncilla pass on `dag`.\n\nArgs:\n    dag (DAGCircuit): DAG to extend.\n\nReturns:\n    DAGCircuit: An extended DAG.\n\nRaises:\n    TranspilerError: If there is no layout in the property set or not set at init time.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/enlarge_with_ancilla.py"
    },
    {
        "api_name": "run",
        "full_api_name": "ApplyLayout.run",
        "api_description": "Run the ApplyLayout pass on ``dag``.\n\nArgs:\n    dag (DAGCircuit): DAG to map.\n\nReturns:\n    DAGCircuit: A mapped DAG (with physical qubits).\n\nRaises:\n    TranspilerError: if no layout is found in ``property_set`` or no full physical qubits.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/apply_layout.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SabreLayout.__init__",
        "api_description": "SabreLayout initializer.\n\nArgs:\n    coupling_map (Union[CouplingMap, Target]): directed graph representing a coupling map.\n    routing_pass (BasePass): the routing pass to use while iterating.\n        If specified this pass operates as an :class:`~.AnalysisPass` and\n        will only populate the ``layout`` field in the property set and\n        the input dag is returned unmodified. This argument is mutually\n        exclusive with the ``swap_trials`` and the ``layout_trials``\n        arguments and if this is specified at the same time as either\n        argument an error will be raised.\n    seed (int): seed for setting a random first trial layout.\n    max_iterations (int): number of forward-backward iterations.\n    swap_trials (int): The number of trials to run of\n        :class:`~.SabreSwap` for each iteration. This is equivalent to\n        the ``trials`` argument on :class:`~.SabreSwap`. If this is not\n        specified (and ``routing_pass`` isn't set) by default the number\n        of physical CPUs on your local system will be used. For\n        reproducibility between environments it is best to set this\n        to an explicit number because the output will potentially depend\n        on the number of trials run. This option is mutually exclusive\n        with the ``routing_pass`` argument and an error will be raised\n        if both are used.\n    layout_trials (int): The number of random seed trials to run\n        layout with. When > 1 the trial that results in the output with\n        the fewest swap gates will be selected. If this is not specified\n        (and ``routing_pass`` is not set) then the number of local\n        physical CPUs will be used as the default value. This option is\n        mutually exclusive with the ``routing_pass`` argument and an error\n        will be raised if both are used.\n    skip_routing (bool): If this is set ``True`` and ``routing_pass`` is not used\n        then routing will not be applied to the output circuit.  Only the layout\n        will be set in the property set. This is a tradeoff to run custom\n        routing with multiple layout trials, as using this option will cause\n        SabreLayout to run the routing stage internally but not use that result.\n\nRaises:\n    TranspilerError: If both ``routing_pass`` and ``swap_trials`` or\n    both ``routing_pass`` and ``layout_trials`` are specified",
        "api_signature": "__init__(self, coupling_map, routing_pass, seed, max_iterations, swap_trials, layout_trials, skip_routing)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/sabre_layout.py"
    },
    {
        "api_name": "run",
        "full_api_name": "SabreLayout.run",
        "api_description": "Run the SabreLayout pass on `dag`.\n\nArgs:\n    dag (DAGCircuit): DAG to find layout for.\n\nReturns:\n   DAGCircuit: The output dag if swap mapping was run\n    (otherwise the input dag is returned unmodified).\n\nRaises:\n    TranspilerError: if dag wider than self.coupling_map",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/sabre_layout.py"
    },
    {
        "api_name": "_inner_run",
        "full_api_name": "SabreLayout._inner_run",
        "api_description": "",
        "api_signature": "_inner_run(self, dag, coupling_map, starting_layouts)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/sabre_layout.py"
    },
    {
        "api_name": "_ancilla_allocation_no_pass_manager",
        "full_api_name": "SabreLayout._ancilla_allocation_no_pass_manager",
        "api_description": "Run the ancilla-allocation and -enlargement passes on the DAG chained onto our\n``property_set``, skipping the DAG-to-circuit conversion cost of using a ``PassManager``.",
        "api_signature": "_ancilla_allocation_no_pass_manager(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/sabre_layout.py"
    },
    {
        "api_name": "_layout_and_route_passmanager",
        "full_api_name": "SabreLayout._layout_and_route_passmanager",
        "api_description": "Return a passmanager for a full layout and routing.\n\nWe use a factory to remove potential statefulness of passes.",
        "api_signature": "_layout_and_route_passmanager(self, initial_layout)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/sabre_layout.py"
    },
    {
        "api_name": "_compose_layouts",
        "full_api_name": "SabreLayout._compose_layouts",
        "api_description": "Return the real final_layout resulting from the composition\nof an initial_layout with the final_layout reported by a pass.\n\nThe routing passes internally start with a trivial layout, as the\nlayout gets applied to the circuit prior to running them. So the\n``\"final_layout\"`` they report must be amended to account for the actual\ninitial_layout that was selected.",
        "api_signature": "_compose_layouts(self, initial_layout, pass_final_layout, qregs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/sabre_layout.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Layout2qDistance.__init__",
        "api_description": "Layout2qDistance initializer.\n\nArgs:\n    coupling_map (Union[CouplingMap, Target]): Directed graph represented a coupling map.\n    property_name (str): The property name to save the score. Default: layout_score",
        "api_signature": "__init__(self, coupling_map, property_name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/layout_2q_distance.py"
    },
    {
        "api_name": "run",
        "full_api_name": "Layout2qDistance.run",
        "api_description": "Run the Layout2qDistance pass on `dag`.\nArgs:\n    dag (DAGCircuit): DAG to evaluate.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/layout_2q_distance.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CSPLayout.__init__",
        "api_description": "If possible, chooses a Layout as a CSP, using backtracking.\n\nIf not possible, does not set the layout property. In all the cases,\nthe property `CSPLayout_stop_reason` will be added with one of the\nfollowing values:\n\n* solution found: If a perfect layout was found.\n* nonexistent solution: If no perfect layout was found and every combination was checked.\n* call limit reached: If no perfect layout was found and the call limit was reached.\n* time limit reached: If no perfect layout was found and the time limit was reached.\n\nArgs:\n    coupling_map (Union[CouplingMap, Target]): Directed graph representing a coupling map.\n    strict_direction (bool): If True, considers the direction of the coupling map.\n                             Default is False.\n    seed (int): Sets the seed of the PRNG.\n    call_limit (int): Amount of times that\n        ``constraint.RecursiveBacktrackingSolver.recursiveBacktracking`` will be called.\n        None means no call limit. Default: 1000.\n    time_limit (int): Amount of seconds that the pass will try to find a solution.\n        None means no time limit. Default: 10 seconds.",
        "api_signature": "__init__(self, coupling_map, strict_direction, seed, call_limit, time_limit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/csp_layout.py"
    },
    {
        "api_name": "run",
        "full_api_name": "CSPLayout.run",
        "api_description": "run the layout method",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/csp_layout.py"
    },
    {
        "api_name": "constraint",
        "full_api_name": "CSPLayout.constraint",
        "api_description": "",
        "api_signature": "constraint(control, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/csp_layout.py"
    },
    {
        "api_name": "constraint",
        "full_api_name": "CSPLayout.constraint",
        "api_description": "",
        "api_signature": "constraint(control, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/csp_layout.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "DenseLayout.__init__",
        "api_description": "DenseLayout initializer.\n\nArgs:\n    coupling_map (Coupling): directed graph representing a coupling map.\n    backend_prop (BackendProperties): backend properties object\n    target (Target): A target representing the target backend.",
        "api_signature": "__init__(self, coupling_map, backend_prop, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/dense_layout.py"
    },
    {
        "api_name": "run",
        "full_api_name": "DenseLayout.run",
        "api_description": "Run the DenseLayout pass on `dag`.\n\nPick a convenient layout depending on the best matching\nqubit connectivity, and set the property `layout`.\n\nArgs:\n    dag (DAGCircuit): DAG to find layout for.\n\nRaises:\n    TranspilerError: if dag wider than self.coupling_map",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/dense_layout.py"
    },
    {
        "api_name": "_inner_run",
        "full_api_name": "DenseLayout._inner_run",
        "api_description": "",
        "api_signature": "_inner_run(self, dag, coupling_map)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/dense_layout.py"
    },
    {
        "api_name": "_best_subset",
        "full_api_name": "DenseLayout._best_subset",
        "api_description": "Computes the qubit mapping with the best connectivity.\n\nArgs:\n    num_qubits (int): Number of subset qubits to consider.\n\nReturns:\n    ndarray: Array of qubits to use for best connectivity mapping.",
        "api_signature": "_best_subset(self, num_qubits, num_meas, num_cx, coupling_map)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/dense_layout.py"
    },
    {
        "api_name": "_build_error_matrix",
        "full_api_name": "_build_error_matrix",
        "api_description": "",
        "api_signature": "_build_error_matrix(num_qubits, qubit_map, target, coupling_map, backend_prop)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/dense_layout.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SabrePreLayout.__init__",
        "api_description": "SabrePreLayout initializer.\n\nThe pass works by augmenting the coupling map with more and more \"extra\" edges\nuntil VF2 succeeds to find a perfect graph isomorphism. More precisely, the\naugmented coupling map contains edges between nodes that are within a given\ndistance ``d`` in the original coupling map, and the value of ``d`` is increased\nuntil an isomorphism is found.\n\nIntuitively, a better layout involves fewer extra edges. The pass also optionally\nminimizes the number of extra edges involved in the layout until a local minimum\nis found. This involves removing extra edges and running VF2 to see if an\nisomorphism still exists.\n\nArgs:\n    coupling_map (Union[CouplingMap, Target]): directed graph representing the\n        original coupling map or a target modelling the backend (including its\n        connectivity).\n    max_distance (int): the maximum distance to consider for augmented coupling maps.\n    error_rate (float): the error rate to assign to the \"extra\" edges. A non-zero\n        error rate prioritizes VF2 to choose original edges over extra edges.\n    max_trials_vf2 (int): specifies the maximum number of VF2 trials. A larger number\n        allows VF2 to explore more layouts, eventually choosing the one with the smallest\n        error rate.\n    call_limit_vf2 (int): limits each call to VF2 by bounding the number of VF2 state visits.\n    improve_layout (bool): whether to improve the layout by minimizing the number of\n        extra edges involved. This might be time-consuming as this requires additional\n        VF2 calls.\n\nRaises:\n    TranspilerError: At runtime, if neither ``coupling_map`` or ``target`` are provided.",
        "api_signature": "__init__(self, coupling_map, max_distance, error_rate, max_trials_vf2, call_limit_vf2, improve_layout)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/sabre_pre_layout.py"
    },
    {
        "api_name": "run",
        "full_api_name": "SabrePreLayout.run",
        "api_description": "Run the SabrePreLayout pass on `dag`.\n\nThe discovered starting layout is written to the property set\nvalue ``sabre_starting_layouts``.\n\nArgs:\n    dag (DAGCircuit): DAG to create starting layout for.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/sabre_pre_layout.py"
    },
    {
        "api_name": "_add_extra_edges",
        "full_api_name": "SabrePreLayout._add_extra_edges",
        "api_description": "Augments the coupling map with extra edges that connect nodes ``distance``\napart in the original graph. The extra edges are assigned errors allowing VF2\nto prioritize real edges over extra edges.",
        "api_signature": "_add_extra_edges(self, distance)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/sabre_pre_layout.py"
    },
    {
        "api_name": "_get_extra_edges_used",
        "full_api_name": "SabrePreLayout._get_extra_edges_used",
        "api_description": "Returns the set of extra edges involved in the layout.",
        "api_signature": "_get_extra_edges_used(self, dag, layout)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/sabre_pre_layout.py"
    },
    {
        "api_name": "_find_layout",
        "full_api_name": "SabrePreLayout._find_layout",
        "api_description": "Checks if there is a layout for a given set of edges.",
        "api_signature": "_find_layout(self, dag, edges)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/sabre_pre_layout.py"
    },
    {
        "api_name": "_minimize_extra_edges",
        "full_api_name": "SabrePreLayout._minimize_extra_edges",
        "api_description": "Minimizes the set of extra edges involved in the layout. This iteratively\nremoves extra edges from the coupling map and uses VF2 to check if a layout\nstill exists. This is reasonably efficiently as it only looks for a local\nminimum.",
        "api_signature": "_minimize_extra_edges(self, dag, starting_layout)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/sabre_pre_layout.py"
    },
    {
        "api_name": "build_interaction_graph",
        "full_api_name": "build_interaction_graph",
        "api_description": "Build an interaction graph from a dag.",
        "api_signature": "build_interaction_graph(dag, strict_direction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/vf2_utils.py"
    },
    {
        "api_name": "_visit",
        "full_api_name": "_visit",
        "api_description": "",
        "api_signature": "_visit(dag, weight, wire_map)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/vf2_utils.py"
    },
    {
        "api_name": "build_edge_list",
        "full_api_name": "build_edge_list",
        "api_description": "Generate an edge list for scoring.",
        "api_signature": "build_edge_list(im_graph)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/vf2_utils.py"
    },
    {
        "api_name": "build_bit_list",
        "full_api_name": "build_bit_list",
        "api_description": "Generate a bit list for scoring.",
        "api_signature": "build_bit_list(im_graph, bit_map)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/vf2_utils.py"
    },
    {
        "api_name": "score_layout",
        "full_api_name": "score_layout",
        "api_description": "Score a layout given an average error map.",
        "api_signature": "score_layout(avg_error_map, layout_mapping, bit_map, _reverse_bit_map, im_graph, strict_direction, run_in_parallel, edge_list, bit_list)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/vf2_utils.py"
    },
    {
        "api_name": "build_average_error_map",
        "full_api_name": "build_average_error_map",
        "api_description": "Build an average error map used for scoring layouts pre-basis translation.",
        "api_signature": "build_average_error_map(target, properties, coupling_map)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/vf2_utils.py"
    },
    {
        "api_name": "shuffle_coupling_graph",
        "full_api_name": "shuffle_coupling_graph",
        "api_description": "Create a shuffled coupling graph from a coupling map.",
        "api_signature": "shuffle_coupling_graph(coupling_map, seed, strict_direction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/vf2_utils.py"
    },
    {
        "api_name": "map_free_qubits",
        "full_api_name": "map_free_qubits",
        "api_description": "Add any free nodes to a layout.",
        "api_signature": "map_free_qubits(free_nodes, partial_layout, num_physical_qubits, reverse_bit_map, avg_error_map)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/vf2_utils.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SetLayout.__init__",
        "api_description": "SetLayout initializer.\n\nArgs:\n    layout (Layout or List[int]): the layout to set. It can be:\n\n        * a :class:`Layout` instance: sets that layout.\n        * a list of integers: takes the index in the list as the physical position in which the\n          virtual qubit is going to be mapped.",
        "api_signature": "__init__(self, layout)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/set_layout.py"
    },
    {
        "api_name": "run",
        "full_api_name": "SetLayout.run",
        "api_description": "Run the SetLayout pass on ``dag``.\n\nArgs:\n    dag (DAGCircuit): DAG to map.\n\nReturns:\n    DAGCircuit: the original DAG.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/set_layout.py"
    },
    {
        "api_name": "_target_match",
        "full_api_name": "_target_match",
        "api_description": "",
        "api_signature": "_target_match(node_a, node_b)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/vf2_post_layout.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "VF2PostLayout.__init__",
        "api_description": "Initialize a ``VF2PostLayout`` pass instance\n\nArgs:\n    target (Target): A target representing the backend device to run ``VF2PostLayout`` on.\n        If specified it will supersede a set value for ``properties`` and\n        ``coupling_map``.\n    coupling_map (CouplingMap): Directed graph representing a coupling map.\n    properties (BackendProperties): The backend properties for the backend. If\n        :meth:`~qiskit.providers.models.BackendProperties.readout_error` is available\n        it is used to score the layout.\n    seed (int): Sets the seed of the PRNG. -1 Means no node shuffling.\n    call_limit (int): The number of state visits to attempt in each execution of\n        VF2.\n    time_limit (float): The total time limit in seconds to run ``VF2PostLayout``\n    strict_direction (bool): Whether the pass is configured to follow\n        the strict direction in the coupling graph. If this is set to\n        false, the pass will treat any edge in the coupling graph as\n        a weak edge and the interaction graph will be undirected. For\n        the purposes of evaluating layouts the avg error rate for\n        each qubit and 2q link will be used. This enables the pass to be\n        run prior to basis translation and work with any 1q and 2q operations.\n        However, if ``strict_direction=True`` the pass expects the input\n        :class:`~.DAGCircuit` object to :meth:`~.VF2PostLayout.run` to be in\n        the target set of instructions.\n    max_trials (int): The maximum number of trials to run VF2 to find\n        a layout. A value of ``0`` (the default) means 'unlimited'.\n\nRaises:\n    TypeError: At runtime, if neither ``coupling_map`` or ``target`` are provided.",
        "api_signature": "__init__(self, target, coupling_map, properties, seed, call_limit, time_limit, strict_direction, max_trials)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/vf2_post_layout.py"
    },
    {
        "api_name": "run",
        "full_api_name": "VF2PostLayout.run",
        "api_description": "run the layout method",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/vf2_post_layout.py"
    },
    {
        "api_name": "_score_layout",
        "full_api_name": "VF2PostLayout._score_layout",
        "api_description": "",
        "api_signature": "_score_layout(self, layout, bit_map, reverse_bit_map, im_graph)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/layout/vf2_post_layout.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "UnrollCustomDefinitions.__init__",
        "api_description": "Unrolls instructions with custom definitions.\n\nArgs:\n    equivalence_library (EquivalenceLibrary): The equivalence library\n        which will be used by the BasisTranslator pass. (Instructions in\n        this library will not be unrolled by this pass.)\n    basis_gates (Optional[list[str]]): Target basis names to unroll to, e.g. ``['u3', 'cx']``.\n        Ignored if ``target`` is also specified.\n    target (Optional[Target]): The :class:`~.Target` object corresponding to the compilation\n        target. When specified, any argument specified for ``basis_gates`` is ignored.\n     min_qubits (int): The minimum number of qubits for operations in the input\n         dag to translate.",
        "api_signature": "__init__(self, equivalence_library, basis_gates, target, min_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/basis/unroll_custom_definitions.py"
    },
    {
        "api_name": "run",
        "full_api_name": "UnrollCustomDefinitions.run",
        "api_description": "Run the UnrollCustomDefinitions pass on `dag`.\n\nArgs:\n    dag (DAGCircuit): input dag\n\nRaises:\n    QiskitError: if unable to unroll given the basis due to undefined\n    decomposition rules (such as a bad basis) or excessive recursion.\n\nReturns:\n    DAGCircuit: output unrolled dag",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/basis/unroll_custom_definitions.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BasisTranslator.__init__",
        "api_description": "Initialize a BasisTranslator instance.\n\nArgs:\n    equivalence_library (EquivalenceLibrary): The equivalence library\n        which will be used by the BasisTranslator pass. (Instructions in\n        this library will not be unrolled by this pass.)\n    target_basis (list[str]): Target basis names to unroll to, e.g. ``['u3', 'cx']``.\n    target (Target): The backend compilation target\n    min_qubits (int): The minimum number of qubits for operations in the input\n        dag to translate.",
        "api_signature": "__init__(self, equivalence_library, target_basis, target, min_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/basis/basis_translator.py"
    },
    {
        "api_name": "run",
        "full_api_name": "BasisTranslator.run",
        "api_description": "Translate an input DAGCircuit to the target basis.\n\nArgs:\n    dag (DAGCircuit): input dag\n\nRaises:\n    TranspilerError: if the target basis cannot be reached\n\nReturns:\n    DAGCircuit: translated circuit.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/basis/basis_translator.py"
    },
    {
        "api_name": "apply_translation",
        "full_api_name": "BasisTranslator.apply_translation",
        "api_description": "",
        "api_signature": "apply_translation(dag, wire_map)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/basis/basis_translator.py"
    },
    {
        "api_name": "_replace_node",
        "full_api_name": "BasisTranslator._replace_node",
        "api_description": "",
        "api_signature": "_replace_node(self, dag, node, instr_map)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/basis/basis_translator.py"
    },
    {
        "api_name": "_extract_basis",
        "full_api_name": "BasisTranslator._extract_basis",
        "api_description": "",
        "api_signature": "_extract_basis(self, circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/basis/basis_translator.py"
    },
    {
        "api_name": "_",
        "full_api_name": "BasisTranslator._",
        "api_description": "",
        "api_signature": "_(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/basis/basis_translator.py"
    },
    {
        "api_name": "_",
        "full_api_name": "BasisTranslator._",
        "api_description": "",
        "api_signature": "_(self, circ)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/basis/basis_translator.py"
    },
    {
        "api_name": "_extract_basis_target",
        "full_api_name": "BasisTranslator._extract_basis_target",
        "api_description": "",
        "api_signature": "_extract_basis_target(self, dag, qarg_indices, source_basis, qargs_local_source_basis)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/basis/basis_translator.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BasisSearchVisitor.__init__",
        "api_description": "",
        "api_signature": "__init__(self, graph, source_basis, target_basis)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/basis/basis_translator.py"
    },
    {
        "api_name": "discover_vertex",
        "full_api_name": "BasisSearchVisitor.discover_vertex",
        "api_description": "",
        "api_signature": "discover_vertex(self, v, score)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/basis/basis_translator.py"
    },
    {
        "api_name": "examine_edge",
        "full_api_name": "BasisSearchVisitor.examine_edge",
        "api_description": "",
        "api_signature": "examine_edge(self, edge)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/basis/basis_translator.py"
    },
    {
        "api_name": "edge_relaxed",
        "full_api_name": "BasisSearchVisitor.edge_relaxed",
        "api_description": "",
        "api_signature": "edge_relaxed(self, edge)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/basis/basis_translator.py"
    },
    {
        "api_name": "edge_cost",
        "full_api_name": "BasisSearchVisitor.edge_cost",
        "api_description": "Returns the cost of an edge.\n\nThis function computes the cost of this edge rule by summing\nthe costs of all gates in the rule equivalence circuit. In the\nend, we need to subtract the cost of the source since `dijkstra`\nwill later add it.",
        "api_signature": "edge_cost(self, edge_data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/basis/basis_translator.py"
    },
    {
        "api_name": "basis_transforms",
        "full_api_name": "BasisSearchVisitor.basis_transforms",
        "api_description": "Returns the gate basis transforms.",
        "api_signature": "basis_transforms(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/basis/basis_translator.py"
    },
    {
        "api_name": "_basis_search",
        "full_api_name": "_basis_search",
        "api_description": "Search for a set of transformations from source_basis to target_basis.\n\nArgs:\n    equiv_lib (EquivalenceLibrary): Source of valid translations\n    source_basis (Set[Tuple[gate_name: str, gate_num_qubits: int]]): Starting basis.\n    target_basis (Set[gate_name: str]): Target basis.\n\nReturns:\n    Optional[List[Tuple[gate, equiv_params, equiv_circuit]]]: List of (gate,\n        equiv_params, equiv_circuit) tuples tuples which, if applied in order\n        will map from source_basis to target_basis. Returns None if no path\n        was found.",
        "api_signature": "_basis_search(equiv_lib, source_basis, target_basis)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/basis/basis_translator.py"
    },
    {
        "api_name": "_compose_transforms",
        "full_api_name": "_compose_transforms",
        "api_description": "Compose a set of basis transforms into a set of replacements.\n\nArgs:\n    basis_transforms (List[Tuple[gate_name, params, equiv]]): List of\n        transforms to compose.\n    source_basis (Set[Tuple[gate_name: str, gate_num_qubits: int]]): Names\n        of gates which need to be translated.\n    source_dag (DAGCircuit): DAG with example gates from source_basis.\n        (Used to determine num_params for gate in source_basis.)\n\nReturns:\n    Dict[gate_name, Tuple(params, dag)]: Dictionary mapping between each gate\n        in source_basis and a DAGCircuit instance to replace it. Gates in\n        source_basis but not affected by basis_transforms will be included\n        as a key mapping to itself.",
        "api_signature": "_compose_transforms(basis_transforms, source_basis, source_dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/basis/basis_translator.py"
    },
    {
        "api_name": "_get_example_gates",
        "full_api_name": "_get_example_gates",
        "api_description": "",
        "api_signature": "_get_example_gates(source_dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/basis/basis_translator.py"
    },
    {
        "api_name": "recurse",
        "full_api_name": "recurse",
        "api_description": "",
        "api_signature": "recurse(dag, example_gates)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/basis/basis_translator.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Decompose.__init__",
        "api_description": "Decompose initializer.\n\nArgs:\n    gates_to_decompose: optional subset of gates to be decomposed,\n        identified by gate label, name or type. Defaults to all gates.",
        "api_signature": "__init__(self, gates_to_decompose)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/basis/decompose.py"
    },
    {
        "api_name": "run",
        "full_api_name": "Decompose.run",
        "api_description": "Run the Decompose pass on `dag`.\n\nArgs:\n    dag: input dag.\n\nReturns:\n    output dag where ``gate`` was expanded.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/basis/decompose.py"
    },
    {
        "api_name": "_should_decompose",
        "full_api_name": "Decompose._should_decompose",
        "api_description": "Call a decomposition pass on this circuit,\nto decompose one level (shallow decompose).",
        "api_signature": "_should_decompose(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/basis/decompose.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Unroll3qOrMore.__init__",
        "api_description": "Initialize the Unroll3qOrMore pass\n\nArgs:\n    target (Target): The target object representing the compilation\n        target. If specified any multi-qubit instructions in the\n        circuit when the pass is run that are supported by the target\n        device will be left in place. If both this and ``basis_gates``\n        are specified only the target will be checked.\n    basis_gates (list): A list of basis gate names that the target\n        device supports. If specified any gate names in the circuit\n        which are present in this list will not be unrolled. If both\n        this and ``target`` are specified only the target will be used\n        for checking which gates are supported.",
        "api_signature": "__init__(self, target, basis_gates)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/basis/unroll_3q_or_more.py"
    },
    {
        "api_name": "run",
        "full_api_name": "Unroll3qOrMore.run",
        "api_description": "Run the Unroll3qOrMore pass on `dag`.\n\nArgs:\n    dag(DAGCircuit): input dag\nReturns:\n    DAGCircuit: output dag with maximum node degrees of 2\nRaises:\n    QiskitError: if a 3q+ gate is not decomposable",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/basis/unroll_3q_or_more.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "TranslateParameterizedGates.__init__",
        "api_description": "Args:\n    supported_gates: A list of suppported basis gates specified as string. If ``None``,\n        a ``target`` must be provided.\n    equivalence_library: The equivalence library to translate the gates. Defaults\n        to the equivalence library of all Qiskit standard gates.\n    target: A :class:`.Target` containing the supported operations. If ``None``,\n        ``supported_gates`` must be set. Note that this argument takes precedence over\n        ``supported_gates``, if both are set.\n\nRaises:\n    ValueError: If neither of ``supported_gates`` and ``target`` are passed.",
        "api_signature": "__init__(self, supported_gates, equivalence_library, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/basis/translate_parameterized.py"
    },
    {
        "api_name": "run",
        "full_api_name": "TranslateParameterizedGates.run",
        "api_description": "Run the transpiler pass.\n\nArgs:\n    dag: The DAG circuit in which the parameterized gates should be unrolled.\n\nReturns:\n    A DAG where the parameterized gates have been unrolled.\n\nRaises:\n    QiskitError: If the circuit cannot be unrolled.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/basis/translate_parameterized.py"
    },
    {
        "api_name": "_is_parameterized",
        "full_api_name": "_is_parameterized",
        "api_description": "",
        "api_signature": "_is_parameterized(op)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/basis/translate_parameterized.py"
    },
    {
        "api_name": "_is_supported",
        "full_api_name": "_is_supported",
        "api_description": "Check whether the node is supported.\n\nIf the target is provided, check using the target, otherwise the supported_gates are used.",
        "api_signature": "_is_supported(node, supported_gates, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/basis/translate_parameterized.py"
    },
    {
        "api_name": "_instruction_to_dag",
        "full_api_name": "_instruction_to_dag",
        "api_description": "",
        "api_signature": "_instruction_to_dag(op)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/basis/translate_parameterized.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CollectAndCollapse.__init__",
        "api_description": "Args:\n    collect_function (callable): a function that takes a DAG and returns a list\n        of \"collected\" blocks of nodes\n    collapse_function (callable): a function that takes a DAG and a list of\n        \"collected\" blocks, and consolidates each block.\n    do_commutative_analysis (bool): if True, exploits commutativity relations\n        between nodes.",
        "api_signature": "__init__(self, collect_function, collapse_function, do_commutative_analysis)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/collect_and_collapse.py"
    },
    {
        "api_name": "run",
        "full_api_name": "CollectAndCollapse.run",
        "api_description": "Run the CollectLinearFunctions pass on `dag`.\nArgs:\n    dag (DAGCircuit): the DAG to be optimized.\nReturns:\n    DAGCircuit: the optimized DAG.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/collect_and_collapse.py"
    },
    {
        "api_name": "collect_using_filter_function",
        "full_api_name": "collect_using_filter_function",
        "api_description": "Corresponds to an important block collection strategy that greedily collects\nmaximal blocks of nodes matching a given ``filter_function``.",
        "api_signature": "collect_using_filter_function(dag, filter_function, split_blocks, min_block_size, split_layers, collect_from_back)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/collect_and_collapse.py"
    },
    {
        "api_name": "collapse_to_operation",
        "full_api_name": "collapse_to_operation",
        "api_description": "Corresponds to an important block collapsing strategy that collapses every block\nto a specific object as specified by ``collapse_function``.",
        "api_signature": "collapse_to_operation(dag, blocks, collapse_function)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/collect_and_collapse.py"
    },
    {
        "api_name": "run",
        "full_api_name": "Collect1qRuns.run",
        "api_description": "Run the Collect1qBlocks pass on `dag`.\n\nThe blocks contain \"op\" nodes in topological order such that all gates\nin a block act on the same qubits and are adjacent in the circuit.\n\nAfter the execution, ``property_set['run_list']`` is set to a list of\ntuples of \"op\" node.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/collect_1q_runs.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "OptimizeAnnotated.__init__",
        "api_description": "OptimizeAnnotated initializer.\n\nArgs:\n    target: Optional, the backend target to use for this pass.\n    equivalence_library: The equivalence library used\n        (instructions in this library will not be optimized by this pass).\n    basis_gates: Optional, target basis names to unroll to, e.g. `['u3', 'cx']`\n        (instructions in this list will not be optimized by this pass).\n        Ignored if ``target`` is also specified.\n    recurse: By default, when either ``target`` or ``basis_gates`` is specified,\n        the pass recursively descends into gate definitions (and the recursion is\n        not applied when neither is specified since such objects do not need to\n        be synthesized). Setting this value to ``False`` precludes the recursion in\n        every case.\n    do_conjugate_reduction: controls whether conjugate reduction should be performed.",
        "api_signature": "__init__(self, target, equivalence_library, basis_gates, recurse, do_conjugate_reduction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/optimize_annotated.py"
    },
    {
        "api_name": "run",
        "full_api_name": "OptimizeAnnotated.run",
        "api_description": "Run the OptimizeAnnotated pass on `dag`.\n\nArgs:\n    dag: input dag.\n\nReturns:\n    Output dag with higher-level operations optimized.\n\nRaises:\n    TranspilerError: when something goes wrong.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/optimize_annotated.py"
    },
    {
        "api_name": "_run_inner",
        "full_api_name": "OptimizeAnnotated._run_inner",
        "api_description": "Optimizes annotated operations.\nReturns True if did something.",
        "api_signature": "_run_inner(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/optimize_annotated.py"
    },
    {
        "api_name": "_canonicalize",
        "full_api_name": "OptimizeAnnotated._canonicalize",
        "api_description": "Combines recursive annotated operations and canonicalizes modifiers.\nReturns True if did something.",
        "api_signature": "_canonicalize(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/optimize_annotated.py"
    },
    {
        "api_name": "_conjugate_decomposition",
        "full_api_name": "OptimizeAnnotated._conjugate_decomposition",
        "api_description": "Decomposes a circuit ``A`` into 3 sub-circuits ``P``, ``Q``, ``R`` such that\n``A = P -- Q -- R`` and ``R = P^{-1}``.\n\nThis is accomplished by iteratively finding inverse nodes at the front and at the back of the\ncircuit.",
        "api_signature": "_conjugate_decomposition(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/optimize_annotated.py"
    },
    {
        "api_name": "_conjugate_reduce_op",
        "full_api_name": "OptimizeAnnotated._conjugate_reduce_op",
        "api_description": "We are given an annotated-operation ``op = M [ B ]`` (where ``B`` is the base operation and\n``M`` is the list of modifiers) and the \"conjugate decomposition\" of the definition of ``B``,\ni.e. ``B = P * Q * R``, with ``R = P^{-1}`` (with ``P``, ``Q`` and ``R`` represented as\n``DAGCircuit`` objects).\n\nLet ``IQ`` denote a new custom instruction with definitions ``Q``.\n\nWe return the operation ``op_new`` which a new custom instruction with definition\n``P * A * R``, where ``A`` is a new annotated-operation with modifiers ``M`` and\nbase gate ``IQ``.",
        "api_signature": "_conjugate_reduce_op(self, op, base_decomposition)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/optimize_annotated.py"
    },
    {
        "api_name": "_conjugate_reduction",
        "full_api_name": "OptimizeAnnotated._conjugate_reduction",
        "api_description": "Looks for annotated operations whose base operation has a nontrivial conjugate decomposition.\nIn such cases, the modifiers of the annotated operation can be moved to the \"middle\" part of\nthe decomposition.\n\nReturns the modified DAG and whether it did something.",
        "api_signature": "_conjugate_reduction(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/optimize_annotated.py"
    },
    {
        "api_name": "_skip_definition",
        "full_api_name": "OptimizeAnnotated._skip_definition",
        "api_description": "Returns True if we should not recurse into a gate's definition.",
        "api_signature": "_skip_definition(self, op)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/optimize_annotated.py"
    },
    {
        "api_name": "_recursively_process_definitions",
        "full_api_name": "OptimizeAnnotated._recursively_process_definitions",
        "api_description": "Recursively applies optimizations to op's definition (or to op.base_op's\ndefinition if op is an annotated operation).\nReturns True if did something.",
        "api_signature": "_recursively_process_definitions(self, op)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/optimize_annotated.py"
    },
    {
        "api_name": "_recurse",
        "full_api_name": "OptimizeAnnotated._recurse",
        "api_description": "Recursively handles gate definitions.\nReturns True if did something.",
        "api_signature": "_recurse(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/optimize_annotated.py"
    },
    {
        "api_name": "run",
        "full_api_name": "RemoveResetInZeroState.run",
        "api_description": "Run the RemoveResetInZeroState pass on `dag`.\n\nArgs:\n    dag (DAGCircuit): the DAG to be optimized.\n\nReturns:\n    DAGCircuit: the optimized DAG.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/remove_reset_in_zero_state.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CollectMultiQBlocks.__init__",
        "api_description": "",
        "api_signature": "__init__(self, max_block_size)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/collect_multiqubit_blocks.py"
    },
    {
        "api_name": "find_set",
        "full_api_name": "CollectMultiQBlocks.find_set",
        "api_description": "DSU function for finding root of set of items\nIf my parent is myself, I am the root. Otherwise we recursively\nfind the root for my parent. After that, we assign my parent to be\nmy root, saving recursion in the future.",
        "api_signature": "find_set(self, index)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/collect_multiqubit_blocks.py"
    },
    {
        "api_name": "union_set",
        "full_api_name": "CollectMultiQBlocks.union_set",
        "api_description": "DSU function for unioning two sets together\nFind the roots of each set. Then assign one to have the other\nas its parent, thus liking the sets.\nMerges smaller set into larger set in order to have better runtime",
        "api_signature": "union_set(self, set1, set2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/collect_multiqubit_blocks.py"
    },
    {
        "api_name": "run",
        "full_api_name": "CollectMultiQBlocks.run",
        "api_description": "Run the CollectMultiQBlocks pass on `dag`.\n\nThe blocks contain \"op\" nodes in topological sort order\nsuch that all gates in a block act on the same set of\nqubits and are adjacent in the circuit.\n\nThe blocks are built by examining predecessors and successors of\n\"cx\" gates in the circuit. u1, u2, u3, cx, id gates will be included.\n\nAfter the execution, ``property_set['block_list']`` is set to\na list of tuples of ``DAGNode`` objects",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/collect_multiqubit_blocks.py"
    },
    {
        "api_name": "collect_key",
        "full_api_name": "CollectMultiQBlocks.collect_key",
        "api_description": "special key function for topological ordering.\nHeuristic for this is to push all gates involving measurement\nor barriers, etc. as far back as possible (because they force\nblocks to end). After that, we process gates in order of lowest\nnumber of qubits acted on to largest number of qubits acted on\nbecause these have less chance of increasing the size of blocks\nThe key also processes all the non operation notes first so that\ninput nodes do not mess with the top sort of op nodes",
        "api_signature": "collect_key(x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/collect_multiqubit_blocks.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CommutativeInverseCancellation.__init__",
        "api_description": "Args:\n    matrix_based: If ``True``, uses matrix representations to check whether two\n        operations are inverse of each other. This makes the checks more powerful,\n        and, in addition, allows canceling pairs of operations that are inverse up to a\n        phase, while updating the global phase of the circuit accordingly.\n        Generally this leads to more reductions at the expense of increased runtime.\n    max_qubits: Limits the number of qubits in matrix-based commutativity and\n        inverse checks.",
        "api_signature": "__init__(self, matrix_based, max_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/commutative_inverse_cancellation.py"
    },
    {
        "api_name": "_skip_node",
        "full_api_name": "CommutativeInverseCancellation._skip_node",
        "api_description": "Returns True if we should skip this node for the analysis.",
        "api_signature": "_skip_node(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/commutative_inverse_cancellation.py"
    },
    {
        "api_name": "_check_inverse",
        "full_api_name": "CommutativeInverseCancellation._check_inverse",
        "api_description": "Checks whether op1 and op2 are inverse up to a phase, that is whether\n``op2 = e^{i * d} op1^{-1})`` for some phase difference ``d``.\nIf this is the case, we can replace ``op2 * op1`` by `e^{i * d} I``.\nThe input to this function is a pair of DAG nodes.\nThe output is a tuple representing whether the two nodes\nare inverse up to a phase and that phase difference.",
        "api_signature": "_check_inverse(self, node1, node2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/commutative_inverse_cancellation.py"
    },
    {
        "api_name": "run",
        "full_api_name": "CommutativeInverseCancellation.run",
        "api_description": "Run the CommutativeInverseCancellation pass on `dag`.\n\nArgs:\n    dag: the directed acyclic graph to run on.\n\nReturns:\n    DAGCircuit: Transformed DAG.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/commutative_inverse_cancellation.py"
    },
    {
        "api_name": "run",
        "full_api_name": "OptimizeSwapBeforeMeasure.run",
        "api_description": "Run the OptimizeSwapBeforeMeasure pass on `dag`.\n\nArgs:\n    dag (DAGCircuit): the DAG to be optimized.\n\nReturns:\n    DAGCircuit: the optimized DAG.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/optimize_swap_before_measure.py"
    },
    {
        "api_name": "run",
        "full_api_name": "OptimizeCliffords.run",
        "api_description": "Run the OptimizeCliffords pass on `dag`.\n\nArgs:\n    dag (DAGCircuit): the DAG to be optimized.\n\nReturns:\n    DAGCircuit: the optimized DAG.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/optimize_cliffords.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Optimize1qGatesDecomposition.__init__",
        "api_description": "Optimize1qGatesDecomposition initializer.\n\nArgs:\n    basis (list[str]): Basis gates to consider, e.g. `['u3', 'cx']`. For the effects\n        of this pass, the basis is the set intersection between the `basis` parameter\n        and the Euler basis. Ignored if ``target`` is also specified.\n    target (Optional[Target]): The :class:`~.Target` object corresponding to the compilation\n        target. When specified, any argument specified for ``basis_gates`` is ignored.",
        "api_signature": "__init__(self, basis, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/optimize_1q_decomposition.py"
    },
    {
        "api_name": "_build_error_map",
        "full_api_name": "Optimize1qGatesDecomposition._build_error_map",
        "api_description": "",
        "api_signature": "_build_error_map(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/optimize_1q_decomposition.py"
    },
    {
        "api_name": "_get_decomposer",
        "full_api_name": "Optimize1qGatesDecomposition._get_decomposer",
        "api_description": "",
        "api_signature": "_get_decomposer(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/optimize_1q_decomposition.py"
    },
    {
        "api_name": "_resynthesize_run",
        "full_api_name": "Optimize1qGatesDecomposition._resynthesize_run",
        "api_description": "Re-synthesizes one 2x2 `matrix`, typically extracted via `dag.collect_1q_runs`.\n\nReturns the newly synthesized circuit in the indicated basis, or None\nif no synthesis routine applied.\n\nWhen multiple synthesis options are available, it prefers the one with the lowest\nerror when the circuit is applied to `qubit`.",
        "api_signature": "_resynthesize_run(self, matrix, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/optimize_1q_decomposition.py"
    },
    {
        "api_name": "_gate_sequence_to_dag",
        "full_api_name": "Optimize1qGatesDecomposition._gate_sequence_to_dag",
        "api_description": "",
        "api_signature": "_gate_sequence_to_dag(self, best_synth_circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/optimize_1q_decomposition.py"
    },
    {
        "api_name": "_substitution_checks",
        "full_api_name": "Optimize1qGatesDecomposition._substitution_checks",
        "api_description": "Returns `True` when it is recommended to replace `old_run` with `new_circ` over `basis`.",
        "api_signature": "_substitution_checks(self, dag, old_run, new_circ, basis, qubit, old_error, new_error)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/optimize_1q_decomposition.py"
    },
    {
        "api_name": "run",
        "full_api_name": "Optimize1qGatesDecomposition.run",
        "api_description": "Run the Optimize1qGatesDecomposition pass on `dag`.\n\nArgs:\n    dag (DAGCircuit): the DAG to be optimized.\n\nReturns:\n    DAGCircuit: the optimized DAG.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/optimize_1q_decomposition.py"
    },
    {
        "api_name": "_error",
        "full_api_name": "Optimize1qGatesDecomposition._error",
        "api_description": "Calculate a rough error for a `circuit` that runs on a specific\n`qubit` of `target` (`circuit` can either be an OneQubitGateSequence\nfrom Rust or a list of DAGOPNodes).\n\nUse basis errors from target if available, otherwise use length\nof circuit as a weak proxy for error.",
        "api_signature": "_error(self, circuit, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/optimize_1q_decomposition.py"
    },
    {
        "api_name": "_possible_decomposers",
        "full_api_name": "_possible_decomposers",
        "api_description": "",
        "api_signature": "_possible_decomposers(basis_set)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/optimize_1q_decomposition.py"
    },
    {
        "api_name": "run",
        "full_api_name": "ResetAfterMeasureSimplification.run",
        "api_description": "Run the pass on a dag.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/reset_after_measure_simplification.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "TemplateOptimization.__init__",
        "api_description": "Args:\n    template_list (list[QuantumCircuit()]): list of the different template circuit to apply.\n    heuristics_backward_param (list[int]): [length, survivor] Those are the parameters for\n        applying heuristics on the backward part of the algorithm. This part of the\n        algorithm creates a tree of matching scenario. This tree grows exponentially. The\n        heuristics evaluate which scenarios have the longest match and keep only those.\n        The length is the interval in the tree for cutting it and survivor is the number\n        of scenarios that are kept. We advise to use l=3 and s=1 to have serious time\n        advantage. We remind that the heuristics implies losing a part of the maximal\n        matches. Check reference for more details.\n    heuristics_qubits_param (list[int]): [length] The heuristics for the qubit choice make\n        guesses from the dag dependency of the circuit in order to limit the number of\n        qubit configurations to explore. The length is the number of successors or not\n        predecessors that will be explored in the dag dependency of the circuit, each\n        qubits of the nodes are added to the set of authorized qubits. We advise to use\n        length=1. Check reference for more details.\n    user_cost_dict (Dict[str, int]): quantum cost dictionary passed to TemplateSubstitution\n        to configure its behavior. This will override any default values if None\n        is not given. The key is the name of the gate and the value its quantum cost.",
        "api_signature": "__init__(self, template_list, heuristics_qubits_param, heuristics_backward_param, user_cost_dict)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_optimization.py"
    },
    {
        "api_name": "run",
        "full_api_name": "TemplateOptimization.run",
        "api_description": "Args:\n    dag(DAGCircuit): DAG circuit.\nReturns:\n    DAGCircuit: optimized DAG circuit.\nRaises:\n    TranspilerError: If the template has not the right form or\n     if the output circuit acts differently as the input circuit.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_optimization.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CollectCliffords.__init__",
        "api_description": "CollectCliffords initializer.\n\nArgs:\n    do_commutative_analysis (bool): if True, exploits commutativity relations\n        between nodes.\n    split_blocks (bool): if True, splits collected blocks into sub-blocks\n        over disjoint qubit subsets.\n    min_block_size (int): specifies the minimum number of gates in the block\n        for the block to be collected.\n    split_layers (bool): if True, splits collected blocks into sub-blocks\n        over disjoint qubit subsets.\n    collect_from_back (bool): specifies if blocks should be collected started\n        from the end of the circuit.",
        "api_signature": "__init__(self, do_commutative_analysis, split_blocks, min_block_size, split_layers, collect_from_back)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/collect_cliffords.py"
    },
    {
        "api_name": "_is_clifford_gate",
        "full_api_name": "_is_clifford_gate",
        "api_description": "Specifies whether a node holds a clifford gate.",
        "api_signature": "_is_clifford_gate(node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/collect_cliffords.py"
    },
    {
        "api_name": "_collapse_to_clifford",
        "full_api_name": "_collapse_to_clifford",
        "api_description": "Specifies how to construct a ``Clifford`` from a quantum circuit (that must\nconsist of Clifford gates only).",
        "api_signature": "_collapse_to_clifford(circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/collect_cliffords.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "EchoRZXWeylDecomposition.__init__",
        "api_description": "EchoRZXWeylDecomposition pass.\n\nArgs:\n    instruction_schedule_map (InstructionScheduleMap): the mapping from circuit\n        :class:`~.circuit.Instruction` names and arguments to :class:`.Schedule`\\ s.\n    target (Target): The :class:`~.Target` representing the target backend, if both\n        ``instruction_schedule_map`` and ``target`` are specified then this argument will take\n        precedence and ``instruction_schedule_map`` will be ignored.",
        "api_signature": "__init__(self, instruction_schedule_map, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/echo_rzx_weyl_decomposition.py"
    },
    {
        "api_name": "_is_native",
        "full_api_name": "EchoRZXWeylDecomposition._is_native",
        "api_description": "Return the direction of the qubit pair that is native.",
        "api_signature": "_is_native(self, qubit_pair)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/echo_rzx_weyl_decomposition.py"
    },
    {
        "api_name": "_echo_rzx_dag",
        "full_api_name": "EchoRZXWeylDecomposition._echo_rzx_dag",
        "api_description": "Return the following circuit\n\n.. parsed-literal::\n\n         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\n    q_0: \u25240              \u251c\u2524 X \u251c\u25240               \u251c\u2524 X \u251c\n         \u2502  Rzx(theta/2) \u2502\u2514\u2500\u2500\u2500\u2518\u2502  Rzx(-theta/2) \u2502\u2514\u2500\u2500\u2500\u2518\n    q_1: \u25241              \u251c\u2500\u2500\u2500\u2500\u2500\u25241               \u251c\u2500\u2500\u2500\u2500\u2500\n         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
        "api_signature": "_echo_rzx_dag(theta)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/echo_rzx_weyl_decomposition.py"
    },
    {
        "api_name": "_reverse_echo_rzx_dag",
        "full_api_name": "EchoRZXWeylDecomposition._reverse_echo_rzx_dag",
        "api_description": "Return the following circuit\n\n.. parsed-literal::\n\n         \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\n    q_0: \u2524 H \u251c\u25241              \u251c\u2500\u2500\u2500\u2500\u2500\u25241               \u251c\u2524 H \u251c\u2500\u2500\u2500\u2500\u2500\n         \u251c\u2500\u2500\u2500\u2524\u2502  Rzx(theta/2) \u2502\u250c\u2500\u2500\u2500\u2510\u2502  Rzx(-theta/2) \u2502\u251c\u2500\u2500\u2500\u2524\u250c\u2500\u2500\u2500\u2510\n    q_1: \u2524 H \u251c\u25240              \u251c\u2524 X \u251c\u25240               \u251c\u2524 X \u251c\u2524 H \u251c\n         \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518",
        "api_signature": "_reverse_echo_rzx_dag(theta)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/echo_rzx_weyl_decomposition.py"
    },
    {
        "api_name": "run",
        "full_api_name": "EchoRZXWeylDecomposition.run",
        "api_description": "Run the EchoRZXWeylDecomposition pass on `dag`.\n\nRewrites two-qubit gates in an arbitrary circuit in terms of echoed cross-resonance\ngates by computing the Weyl decomposition of the corresponding unitary. Modifies the\ninput dag.\n\nArgs:\n    dag (DAGCircuit): DAG to rewrite.\n\nReturns:\n    DAGCircuit: The modified dag.\n\nRaises:\n    TranspilerError: If the circuit cannot be rewritten.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/echo_rzx_weyl_decomposition.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Split2QUnitaries.__init__",
        "api_description": "Split2QUnitaries initializer.\n\nArgs:\n    fidelity (float): Allowed tolerance for splitting two-qubit unitaries and gate decompositions",
        "api_signature": "__init__(self, fidelity)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/split_2q_unitaries.py"
    },
    {
        "api_name": "run",
        "full_api_name": "Split2QUnitaries.run",
        "api_description": "Run the Split2QUnitaries pass on `dag`.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/split_2q_unitaries.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "InverseCancellation.__init__",
        "api_description": "Initialize InverseCancellation pass.\n\nArgs:\n    gates_to_cancel: List describing the gates to cancel. Each element of the\n        list is either a single gate or a pair of gates. If a single gate, then\n        it should be self-inverse. If a pair of gates, then the gates in the\n        pair should be inverses of each other.\n\nRaises:\n    TranspilerError: Input is not a self-inverse gate or a pair of inverse gates.",
        "api_signature": "__init__(self, gates_to_cancel)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/inverse_cancellation.py"
    },
    {
        "api_name": "run",
        "full_api_name": "InverseCancellation.run",
        "api_description": "Run the InverseCancellation pass on `dag`.\n\nArgs:\n    dag: the directed acyclic graph to run on.\n\nReturns:\n    DAGCircuit: Transformed DAG.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/inverse_cancellation.py"
    },
    {
        "api_name": "_run_on_self_inverse",
        "full_api_name": "InverseCancellation._run_on_self_inverse",
        "api_description": "Run self-inverse gates on `dag`.\n\nArgs:\n    dag: the directed acyclic graph to run on.\n    self_inverse_gates: list of gates who cancel themeselves in pairs\n\nReturns:\n    DAGCircuit: Transformed DAG.",
        "api_signature": "_run_on_self_inverse(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/inverse_cancellation.py"
    },
    {
        "api_name": "_run_on_inverse_pairs",
        "full_api_name": "InverseCancellation._run_on_inverse_pairs",
        "api_description": "Run inverse gate pairs on `dag`.\n\nArgs:\n    dag: the directed acyclic graph to run on.\n    inverse_gate_pairs: list of gates with inverse angles that cancel each other.\n\nReturns:\n    DAGCircuit: Transformed DAG.",
        "api_signature": "_run_on_inverse_pairs(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/inverse_cancellation.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CommutationAnalysis.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/commutation_analysis.py"
    },
    {
        "api_name": "run",
        "full_api_name": "CommutationAnalysis.run",
        "api_description": "Run the CommutationAnalysis pass on `dag`.\n\nRun the pass on the DAG, and write the discovered commutation relations\ninto the ``property_set``.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/commutation_analysis.py"
    },
    {
        "api_name": "run",
        "full_api_name": "RemoveFinalReset.run",
        "api_description": "Run the RemoveFinalReset pass on `dag`.\n\nArgs:\n    dag (DAGCircuit): the DAG to be optimized.\n\nReturns:\n    DAGCircuit: the optimized DAG.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/remove_final_reset.py"
    },
    {
        "api_name": "run",
        "full_api_name": "RemoveDiagonalGatesBeforeMeasure.run",
        "api_description": "Run the RemoveDiagonalGatesBeforeMeasure pass on `dag`.\n\nArgs:\n    dag (DAGCircuit): the DAG to be optimized.\n\nReturns:\n    DAGCircuit: the optimized DAG.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/remove_diagonal_gates_before_measure.py"
    },
    {
        "api_name": "run",
        "full_api_name": "ElidePermutations.run",
        "api_description": "Run the ElidePermutations pass on ``dag``.\n\nArgs:\n    dag (DAGCircuit): the DAG to be optimized.\n\nReturns:\n    DAGCircuit: the optimized DAG.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/elide_permutations.py"
    },
    {
        "api_name": "_apply_mapping",
        "full_api_name": "ElidePermutations._apply_mapping",
        "api_description": "",
        "api_signature": "_apply_mapping(qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/elide_permutations.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ConsolidateBlocks.__init__",
        "api_description": "ConsolidateBlocks initializer.\n\nIf ``kak_basis_gate`` is not ``None`` it will be used as the basis gate for KAK decomposition.\nOtherwise, if ``basis_gates`` is not ``None`` a basis gate will be chosen from this list.\nOtherwise, the basis gate will be :class:`.CXGate`.\n\nArgs:\n    kak_basis_gate (Gate): Basis gate for KAK decomposition.\n    force_consolidate (bool): Force block consolidation.\n    basis_gates (List(str)): Basis gates from which to choose a KAK gate.\n    approximation_degree (float): a float between :math:`[0.0, 1.0]`. Lower approximates more.\n    target (Target): The target object for the compilation target backend.",
        "api_signature": "__init__(self, kak_basis_gate, force_consolidate, basis_gates, approximation_degree, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/consolidate_blocks.py"
    },
    {
        "api_name": "run",
        "full_api_name": "ConsolidateBlocks.run",
        "api_description": "Run the ConsolidateBlocks pass on `dag`.\n\nIterate over each block and replace it with an equivalent Unitary\non the same wires.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/consolidate_blocks.py"
    },
    {
        "api_name": "_handle_control_flow_ops",
        "full_api_name": "ConsolidateBlocks._handle_control_flow_ops",
        "api_description": "This is similar to transpiler/passes/utils/control_flow.py except that the\ncollect blocks is redone for the control flow blocks.",
        "api_signature": "_handle_control_flow_ops(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/consolidate_blocks.py"
    },
    {
        "api_name": "_check_not_in_basis",
        "full_api_name": "ConsolidateBlocks._check_not_in_basis",
        "api_description": "",
        "api_signature": "_check_not_in_basis(self, dag, gate_name, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/consolidate_blocks.py"
    },
    {
        "api_name": "_block_qargs_to_indices",
        "full_api_name": "ConsolidateBlocks._block_qargs_to_indices",
        "api_description": "Map each qubit in block_qargs to its wire position among the block's wires.\nArgs:\n    block_qargs (list): list of qubits that a block acts on\n    global_index_map (dict): mapping from each qubit in the\n        circuit to its wire position within that circuit\nReturns:\n    dict: mapping from qarg to position in block",
        "api_signature": "_block_qargs_to_indices(self, dag, block_qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/consolidate_blocks.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "HoareOptimizer.__init__",
        "api_description": "Args:\n    size (int): size of gate cache, in number of gates\nRaises:\n    MissingOptionalLibraryError: if unable to import z3 solver",
        "api_signature": "__init__(self, size)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/hoare_opt.py"
    },
    {
        "api_name": "_gen_variable",
        "full_api_name": "HoareOptimizer._gen_variable",
        "api_description": "After each gate generate a new unique variable name for each of the\n    qubits, using scheme: 'q[id]_[gatenum]', e.g. q1_0 -> q1_1 -> q1_2,\n                                                  q2_0 -> q2_1\nArgs:\n    qubit (Qubit): qubit to generate new variable for\nReturns:\n    BoolRef: z3 variable of qubit state",
        "api_signature": "_gen_variable(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/hoare_opt.py"
    },
    {
        "api_name": "_initialize",
        "full_api_name": "HoareOptimizer._initialize",
        "api_description": "create boolean variables for each qubit and apply qb == 0 condition\nArgs:\n    dag (DAGCircuit): input DAG to get qubits from",
        "api_signature": "_initialize(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/hoare_opt.py"
    },
    {
        "api_name": "_add_postconditions",
        "full_api_name": "HoareOptimizer._add_postconditions",
        "api_description": "create boolean variables for each qubit the gate is applied to\n    and apply the relevant post conditions.\n    a gate rotating out of the z-basis will not have any valid\n    post-conditions, in which case the qubit state is unknown\nArgs:\n    gate (Gate): gate to inspect\n    ctrl_ones (BoolRef): z3 condition asserting all control qubits to 1\n    trgtqb (list((QuantumRegister, int))): list of target qubits\n    trgtvar (list(BoolRef)): z3 variables corresponding to latest state\n                             of target qubits",
        "api_signature": "_add_postconditions(self, gate, ctrl_ones, trgtqb, trgtvar)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/hoare_opt.py"
    },
    {
        "api_name": "_test_gate",
        "full_api_name": "HoareOptimizer._test_gate",
        "api_description": "use z3 sat solver to determine triviality of gate\nArgs:\n    gate (Gate): gate to inspect\n    ctrl_ones (BoolRef): z3 condition asserting all control qubits to 1\n    trgtvar (list(BoolRef)): z3 variables corresponding to latest state\n                             of target qubits\nReturns:\n    bool: if gate is trivial",
        "api_signature": "_test_gate(self, gate, ctrl_ones, trgtvar)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/hoare_opt.py"
    },
    {
        "api_name": "_remove_control",
        "full_api_name": "HoareOptimizer._remove_control",
        "api_description": "use z3 sat solver to determine if all control qubits are in 1 state,\n     and if so replace the Controlled - U by U.\nArgs:\n    gate (Gate): gate to inspect\n    ctrlvar (list(BoolRef)): z3 variables corresponding to latest state\n                             of control qubits\n    trgtvar (list(BoolRef)): z3 variables corresponding to latest state\n                             of target qubits\nReturns:\n    Tuple(bool, DAGCircuit, List)::\n      * bool:if controlled gate can be replaced.\n      * DAGCircuit: with U applied to the target qubits.\n      * List: with indices of target qubits.",
        "api_signature": "_remove_control(self, gate, ctrlvar, trgtvar)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/hoare_opt.py"
    },
    {
        "api_name": "_check_removal",
        "full_api_name": "HoareOptimizer._check_removal",
        "api_description": "",
        "api_signature": "_check_removal(self, ctrlvar)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/hoare_opt.py"
    },
    {
        "api_name": "_traverse_dag",
        "full_api_name": "HoareOptimizer._traverse_dag",
        "api_description": "traverse DAG in topological order\n    for each gate check: if any control is 0, or\n                         if triviality conditions are satisfied\n    if yes remove gate from dag\n    apply postconditions of gate\nArgs:\n    dag (DAGCircuit): input DAG to optimize in place",
        "api_signature": "_traverse_dag(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/hoare_opt.py"
    },
    {
        "api_name": "_remove_successive_identity",
        "full_api_name": "HoareOptimizer._remove_successive_identity",
        "api_description": "remove gates that have the same set of target qubits, follow each\n    other immediately on these target qubits, and combine to the\n    identity (consider sequences of length 2 for now)\nArgs:\n    dag (DAGCircuit): the directed acyclic graph to run on.\n    qubit (Qubit): qubit cache to inspect\n    from_idx (int): only gates whose indexes in the cache are larger\n                    than this value can be removed",
        "api_signature": "_remove_successive_identity(self, dag, qubit, from_idx)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/hoare_opt.py"
    },
    {
        "api_name": "_is_identity",
        "full_api_name": "HoareOptimizer._is_identity",
        "api_description": "determine whether the sequence of gates combines to the identity\n    (consider sequences of length 2 for now)\nArgs:\n    sequence (list(DAGOpNode)): gate sequence to inspect\nReturns:\n    bool: if gate sequence combines to identity",
        "api_signature": "_is_identity(self, sequence)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/hoare_opt.py"
    },
    {
        "api_name": "_seq_as_one",
        "full_api_name": "HoareOptimizer._seq_as_one",
        "api_description": "use z3 solver to determine if the gates in the sequence are either\n    all executed or none of them are executed, based on control qubits\n    (consider sequences of length 2 for now)\nArgs:\n    sequence (list(DAGOpNode)): gate sequence to inspect\nReturns:\n    bool: if gate sequence is only executed completely or not at all",
        "api_signature": "_seq_as_one(self, sequence)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/hoare_opt.py"
    },
    {
        "api_name": "_multigate_opt",
        "full_api_name": "HoareOptimizer._multigate_opt",
        "api_description": "Args:\n    dag (DAGCircuit): the directed acyclic graph to run on.\n    qubit (Qubit): qubit whose gate cache is to be optimized\n    max_idx (int): a value indicates a recursive call, optimize\n                   and remove gates up to this point in the cache\n    dnt_rec (list(int)): don't recurse on these qubit caches (again)",
        "api_signature": "_multigate_opt(self, dag, qubit, max_idx, dnt_rec)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/hoare_opt.py"
    },
    {
        "api_name": "_seperate_ctrl_trgt",
        "full_api_name": "HoareOptimizer._seperate_ctrl_trgt",
        "api_description": "Get the target qubits and control qubits if available,\nas well as their respective z3 variables.",
        "api_signature": "_seperate_ctrl_trgt(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/hoare_opt.py"
    },
    {
        "api_name": "_reset",
        "full_api_name": "HoareOptimizer._reset",
        "api_description": "Reset HoareOptimize internal state,\nso it can be run multiple times.",
        "api_signature": "_reset(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/hoare_opt.py"
    },
    {
        "api_name": "run",
        "full_api_name": "HoareOptimizer.run",
        "api_description": "Args:\n    dag (DAGCircuit): the directed acyclic graph to run on.\nReturns:\n    DAGCircuit: Transformed DAG.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/hoare_opt.py"
    },
    {
        "api_name": "run",
        "full_api_name": "Collect2qBlocks.run",
        "api_description": "Run the Collect2qBlocks pass on `dag`.\n\nThe blocks contain \"op\" nodes in topological order such that all gates\nin a block act on the same qubits and are adjacent in the circuit.\n\nAfter the execution, ``property_set['block_list']`` is set to a list of\ntuples of \"op\" node.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/collect_2q_blocks.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CollectLinearFunctions.__init__",
        "api_description": "CollectLinearFunctions initializer.\n\nArgs:\n    do_commutative_analysis (bool): if True, exploits commutativity relations\n        between nodes.\n    split_blocks (bool): if True, splits collected blocks into sub-blocks\n        over disjoint qubit subsets.\n    min_block_size (int): specifies the minimum number of gates in the block\n        for the block to be collected.\n    split_layers (bool): if True, splits collected blocks into sub-blocks\n        over disjoint qubit subsets.\n    collect_from_back (bool): specifies if blocks should be collected started\n        from the end of the circuit.",
        "api_signature": "__init__(self, do_commutative_analysis, split_blocks, min_block_size, split_layers, collect_from_back)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/collect_linear_functions.py"
    },
    {
        "api_name": "_is_linear_gate",
        "full_api_name": "_is_linear_gate",
        "api_description": "Specifies whether a node holds a linear gate.",
        "api_signature": "_is_linear_gate(node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/collect_linear_functions.py"
    },
    {
        "api_name": "_collapse_to_linear_function",
        "full_api_name": "_collapse_to_linear_function",
        "api_description": "Specifies how to construct a ``LinearFunction`` from a quantum circuit (that must\nconsist of linear gates only).",
        "api_signature": "_collapse_to_linear_function(circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/collect_linear_functions.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "NormalizeRXAngle.__init__",
        "api_description": "NormalizeRXAngle initializer.\n\nArgs:\n    target (Target): The :class:`~.Target` representing the target backend.\n        If the target contains SX and X calibrations, this pass will replace the\n        corresponding RX gates with SX and X gates.\n    resolution_in_radian (float): Resolution for RX rotation angle quantization.\n        If set to zero, this pass won't modify the rotation angles in the given DAG.\n        (=Provides arbitrary-angle RX)",
        "api_signature": "__init__(self, target, resolution_in_radian)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/normalize_rx_angle.py"
    },
    {
        "api_name": "quantize_angles",
        "full_api_name": "NormalizeRXAngle.quantize_angles",
        "api_description": "Quantize the RX rotation angles by assigning the same value for the angles\nthat differ within a resolution provided by the user.\n\nArgs:\n    qubit (qiskit.circuit.Qubit): This will be the dict key to access the list of\n        quantized rotation angles.\n    original_angle (float): Original rotation angle, before quantization.\n\nReturns:\n    float: Quantized angle.",
        "api_signature": "quantize_angles(self, qubit, original_angle)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/normalize_rx_angle.py"
    },
    {
        "api_name": "run",
        "full_api_name": "NormalizeRXAngle.run",
        "api_description": "Run the NormalizeRXAngle pass on ``dag``.\n\nArgs:\n    dag (DAGCircuit): The DAG to be optimized.\n\nReturns:\n    DAGCircuit: A DAG with RX gate calibration.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/normalize_rx_angle.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CommutativeCancellation.__init__",
        "api_description": "CommutativeCancellation initializer.\n\nArgs:\n    basis_gates (list[str]): Basis gates to consider, e.g.\n        ``['u3', 'cx']``. For the effects of this pass, the basis is\n        the set intersection between the ``basis_gates`` parameter\n        and the gates in the dag.\n    target (Target): The :class:`~.Target` representing the target backend, if both\n        ``basis_gates`` and ``target`` are specified then this argument will take\n        precedence and ``basis_gates`` will be ignored.",
        "api_signature": "__init__(self, basis_gates, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/commutative_cancellation.py"
    },
    {
        "api_name": "run",
        "full_api_name": "CommutativeCancellation.run",
        "api_description": "Run the CommutativeCancellation pass on `dag`.\n\nArgs:\n    dag (DAGCircuit): the DAG to be optimized.\n\nReturns:\n    DAGCircuit: the optimized DAG.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/commutative_cancellation.py"
    },
    {
        "api_name": "_handle_control_flow_ops",
        "full_api_name": "CommutativeCancellation._handle_control_flow_ops",
        "api_description": "This is similar to transpiler/passes/utils/control_flow.py except that the\ncommutation analysis is redone for the control flow blocks.",
        "api_signature": "_handle_control_flow_ops(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/commutative_cancellation.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CXCancellation.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/cx_cancellation.py"
    },
    {
        "api_name": "run",
        "full_api_name": "CXCancellation.run",
        "api_description": "Run the CXCancellation pass on `dag`.\n\nArgs:\n    dag (DAGCircuit): the directed acyclic graph to run on.\n\nReturns:\n    DAGCircuit: Transformed DAG.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/cx_cancellation.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Optimize1qGatesSimpleCommutation.__init__",
        "api_description": "Args:\n    basis (List[str]): See also `Optimize1qGatesDecomposition`.\n    run_to_completion (bool): If `True`, this pass retries until it is unable to do any more\n        work.  If `False`, it finds and performs one optimization, and for full optimization\n        the user is obligated to re-call the pass until the output stabilizes.\n    target (Target): The :class:`~.Target` representing the target backend, if both\n        ``basis`` and this are specified then this argument will take\n        precedence and ``basis`` will be ignored.",
        "api_signature": "__init__(self, basis, run_to_completion, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/optimize_1q_commutation.py"
    },
    {
        "api_name": "_find_adjoining_run",
        "full_api_name": "Optimize1qGatesSimpleCommutation._find_adjoining_run",
        "api_description": "Finds the run which abuts `run` from the front (or the rear if `front == False`), separated\nby a blocking node.\n\nReturns a pair of the abutting multiqubit gate and the run which it separates from this\none. The next run can be the empty list `[]` if it is absent.",
        "api_signature": "_find_adjoining_run(dag, runs, run, front)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/optimize_1q_commutation.py"
    },
    {
        "api_name": "_commute_through",
        "full_api_name": "Optimize1qGatesSimpleCommutation._commute_through",
        "api_description": "Pulls `DAGOpNode`s from the front of `run` (or the back, if `front == False`) until it\nencounters a gate which does not commute with `blocker`.\n\nReturns a pair of lists whose concatenation is `run`.",
        "api_signature": "_commute_through(blocker, run, front)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/optimize_1q_commutation.py"
    },
    {
        "api_name": "_resynthesize",
        "full_api_name": "Optimize1qGatesSimpleCommutation._resynthesize",
        "api_description": "Synthesizes an efficient circuit from a sequence `run` of `DAGOpNode`s.\n\nNOTE: Returns None when resynthesis is not possible.",
        "api_signature": "_resynthesize(self, run, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/optimize_1q_commutation.py"
    },
    {
        "api_name": "_replace_subdag",
        "full_api_name": "Optimize1qGatesSimpleCommutation._replace_subdag",
        "api_description": "Replaces a nonempty sequence `old_run` of `DAGNode`s, assumed to be a complete chain in\n`dag`, with the circuit `new_circ`.",
        "api_signature": "_replace_subdag(dag, old_run, new_dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/optimize_1q_commutation.py"
    },
    {
        "api_name": "_step",
        "full_api_name": "Optimize1qGatesSimpleCommutation._step",
        "api_description": "Performs one full pass of optimization work.\n\nReturns True if `dag` changed, False if no work on `dag` was possible.",
        "api_signature": "_step(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/optimize_1q_commutation.py"
    },
    {
        "api_name": "run",
        "full_api_name": "Optimize1qGatesSimpleCommutation.run",
        "api_description": "Args:\n    dag (DAGCircuit): the DAG to be optimized.\n\nReturns:\n    DAGCircuit: the optimized DAG.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/optimize_1q_commutation.py"
    },
    {
        "api_name": "mov_list",
        "full_api_name": "mov_list",
        "api_description": "Replace `destination` in-place with `source`.",
        "api_signature": "mov_list(destination, source)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/optimize_1q_commutation.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Optimize1qGates.__init__",
        "api_description": "Optimize1qGates initializer.\n\nArgs:\n    basis (list[str]): Basis gates to consider, e.g. `['u3', 'cx']`. For the effects\n        of this pass, the basis is the set intersection between the `basis` parameter and\n        the set `{'u1','u2','u3', 'u', 'p'}`.\n    eps (float): EPS to check against\n    target (Target): The :class:`~.Target` representing the target backend, if both\n        ``basis`` and ``target`` are specified then this argument will take\n        precedence and ``basis`` will be ignored.",
        "api_signature": "__init__(self, basis, eps, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/optimize_1q_gates.py"
    },
    {
        "api_name": "run",
        "full_api_name": "Optimize1qGates.run",
        "api_description": "Run the Optimize1qGates pass on `dag`.\n\nArgs:\n    dag (DAGCircuit): the DAG to be optimized.\n\nReturns:\n    DAGCircuit: the optimized DAG.\n\nRaises:\n    TranspilerError: if ``YZY`` and ``ZYZ`` angles do not give same rotation matrix.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/optimize_1q_gates.py"
    },
    {
        "api_name": "compose_u3",
        "full_api_name": "Optimize1qGates.compose_u3",
        "api_description": "Return a triple theta, phi, lambda for the product.\n\nu3(theta, phi, lambda)\n   = u3(theta1, phi1, lambda1).u3(theta2, phi2, lambda2)\n   = Rz(phi1).Ry(theta1).Rz(lambda1+phi2).Ry(theta2).Rz(lambda2)\n   = Rz(phi1).Rz(phi').Ry(theta').Rz(lambda').Rz(lambda2)\n   = u3(theta', phi1 + phi', lambda2 + lambda')\n\nReturn theta, phi, lambda.",
        "api_signature": "compose_u3(theta1, phi1, lambda1, theta2, phi2, lambda2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/optimize_1q_gates.py"
    },
    {
        "api_name": "yzy_to_zyz",
        "full_api_name": "Optimize1qGates.yzy_to_zyz",
        "api_description": "Express a Y.Z.Y single qubit gate as a Z.Y.Z gate.\n\nSolve the equation\n\n.. math::\n\nRy(theta1).Rz(xi).Ry(theta2) = Rz(phi).Ry(theta).Rz(lambda)\n\nfor theta, phi, and lambda.\n\nReturn a solution theta, phi, and lambda.",
        "api_signature": "yzy_to_zyz(xi, theta1, theta2, eps)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/optimize_1q_gates.py"
    },
    {
        "api_name": "_split_runs_on_parameters",
        "full_api_name": "_split_runs_on_parameters",
        "api_description": "Finds runs containing parameterized gates and splits them into sequential\nruns excluding the parameterized gates.",
        "api_signature": "_split_runs_on_parameters(runs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/optimize_1q_gates.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ForwardMatch.__init__",
        "api_description": "Create a ForwardMatch class with necessary arguments.\nArgs:\n    circuit_dag_dep (DAGDependency): circuit in the dag dependency form.\n    template_dag_dep (DAGDependency): template in the dag dependency form.\n    node_id_c (int): index of the first gate matched in the circuit.\n    node_id_t (int): index of the first gate matched in the template.\n    qubits (list): list of considered qubits in the circuit.\n    clbits (list): list of considered clbits in the circuit.",
        "api_signature": "__init__(self, circuit_dag_dep, template_dag_dep, node_id_c, node_id_t, qubits, clbits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/forward_match.py"
    },
    {
        "api_name": "_init_successors_to_visit",
        "full_api_name": "ForwardMatch._init_successors_to_visit",
        "api_description": "Initialize the attribute list 'SuccessorsToVisit'",
        "api_signature": "_init_successors_to_visit(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/forward_match.py"
    },
    {
        "api_name": "_init_matched_with_circuit",
        "full_api_name": "ForwardMatch._init_matched_with_circuit",
        "api_description": "Initialize the attribute 'MatchedWith' in the template DAG dependency.",
        "api_signature": "_init_matched_with_circuit(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/forward_match.py"
    },
    {
        "api_name": "_init_matched_with_template",
        "full_api_name": "ForwardMatch._init_matched_with_template",
        "api_description": "Initialize the attribute 'MatchedWith' in the circuit DAG dependency.",
        "api_signature": "_init_matched_with_template(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/forward_match.py"
    },
    {
        "api_name": "_init_is_blocked_circuit",
        "full_api_name": "ForwardMatch._init_is_blocked_circuit",
        "api_description": "Initialize the attribute 'IsBlocked' in the circuit DAG dependency.",
        "api_signature": "_init_is_blocked_circuit(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/forward_match.py"
    },
    {
        "api_name": "_init_is_blocked_template",
        "full_api_name": "ForwardMatch._init_is_blocked_template",
        "api_description": "Initialize the attribute 'IsBlocked' in the template DAG dependency.",
        "api_signature": "_init_is_blocked_template(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/forward_match.py"
    },
    {
        "api_name": "_init_list_match",
        "full_api_name": "ForwardMatch._init_list_match",
        "api_description": "Initialize the list of matched nodes between the circuit and the template\nwith the first match found.",
        "api_signature": "_init_list_match(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/forward_match.py"
    },
    {
        "api_name": "_find_forward_candidates",
        "full_api_name": "ForwardMatch._find_forward_candidates",
        "api_description": "Find the candidate nodes to be matched in the template for a given node.\nArgs:\n    node_id_t (int): considered node id.",
        "api_signature": "_find_forward_candidates(self, node_id_t)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/forward_match.py"
    },
    {
        "api_name": "_init_matched_nodes",
        "full_api_name": "ForwardMatch._init_matched_nodes",
        "api_description": "Initialize the list of current matched nodes.",
        "api_signature": "_init_matched_nodes(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/forward_match.py"
    },
    {
        "api_name": "_get_node_forward",
        "full_api_name": "ForwardMatch._get_node_forward",
        "api_description": "Return a node from the matched_node_list for a given list id.\nArgs:\n    list_id (int): considered list id of the desired node.\n\nReturns:\n    DAGDepNode: DAGDepNode object corresponding to i-th node of the matched_node_list.",
        "api_signature": "_get_node_forward(self, list_id)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/forward_match.py"
    },
    {
        "api_name": "_remove_node_forward",
        "full_api_name": "ForwardMatch._remove_node_forward",
        "api_description": "Remove a node of the current matched list for a given list id.\nArgs:\n    list_id (int): considered list id of the desired node.",
        "api_signature": "_remove_node_forward(self, list_id)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/forward_match.py"
    },
    {
        "api_name": "_update_successor",
        "full_api_name": "ForwardMatch._update_successor",
        "api_description": "Return a node with an updated attribute 'SuccessorToVisit'.\nArgs:\n    node (DAGDepNode): current node.\n    successor_id (int): successor id to remove.\n\nReturns:\n    DAGOpNode or DAGOutNode: Node with updated attribute 'SuccessorToVisit'.",
        "api_signature": "_update_successor(self, node, successor_id)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/forward_match.py"
    },
    {
        "api_name": "_get_successors_to_visit",
        "full_api_name": "ForwardMatch._get_successors_to_visit",
        "api_description": "Return the successor for a given node and id.\nArgs:\n    node (DAGOpNode or DAGOutNode): current node.\n    list_id (int): id in the list for the successor to get.\n\nReturns:\n    int: id of the successor to get.",
        "api_signature": "_get_successors_to_visit(self, node, list_id)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/forward_match.py"
    },
    {
        "api_name": "_update_qarg_indices",
        "full_api_name": "ForwardMatch._update_qarg_indices",
        "api_description": "Change qubits indices of the current circuit node in order to\nbe comparable with the indices of the template qubits list.\nArgs:\n    qarg (list): list of qubits indices from the circuit for a given node.",
        "api_signature": "_update_qarg_indices(self, qarg)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/forward_match.py"
    },
    {
        "api_name": "_update_carg_indices",
        "full_api_name": "ForwardMatch._update_carg_indices",
        "api_description": "Change clbits indices of the current circuit node in order to\nbe comparable with the indices of the template qubits list.\nArgs:\n    carg (list): list of clbits indices from the circuit for a given node.",
        "api_signature": "_update_carg_indices(self, carg)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/forward_match.py"
    },
    {
        "api_name": "_is_same_op",
        "full_api_name": "ForwardMatch._is_same_op",
        "api_description": "Check if two instructions are the same.\nArgs:\n    node_circuit (DAGDepNode): node in the circuit.\n    node_template (DAGDepNode): node in the template.\nReturns:\n    bool: True if the same, False otherwise.",
        "api_signature": "_is_same_op(self, node_circuit, node_template)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/forward_match.py"
    },
    {
        "api_name": "_is_same_q_conf",
        "full_api_name": "ForwardMatch._is_same_q_conf",
        "api_description": "Check if the qubits configurations are compatible.\nArgs:\n    node_circuit (DAGDepNode): node in the circuit.\n    node_template (DAGDepNode): node in the template.\nReturns:\n    bool: True if possible, False otherwise.",
        "api_signature": "_is_same_q_conf(self, node_circuit, node_template)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/forward_match.py"
    },
    {
        "api_name": "_is_same_c_conf",
        "full_api_name": "ForwardMatch._is_same_c_conf",
        "api_description": "Check if the clbits configurations are compatible.\nArgs:\n    node_circuit (DAGDepNode): node in the circuit.\n    node_template (DAGDepNode): node in the template.\nReturns:\n    bool: True if possible, False otherwise.",
        "api_signature": "_is_same_c_conf(self, node_circuit, node_template)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/forward_match.py"
    },
    {
        "api_name": "run_forward_match",
        "full_api_name": "ForwardMatch.run_forward_match",
        "api_description": "Apply the forward match algorithm and returns the list of matches given an initial match\nand a circuit qubits configuration.",
        "api_signature": "run_forward_match(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/forward_match.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SubstitutionConfig.__init__",
        "api_description": "",
        "api_signature": "__init__(self, circuit_config, template_config, pred_block, qubit_config, template_dag_dep, clbit_config)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/template_substitution.py"
    },
    {
        "api_name": "has_parameters",
        "full_api_name": "SubstitutionConfig.has_parameters",
        "api_description": "Ensure that the template does not have parameters.",
        "api_signature": "has_parameters(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/template_substitution.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "TemplateSubstitution.__init__",
        "api_description": "Initialize TemplateSubstitution with necessary arguments.\nArgs:\n    max_matches (list): list of maximal matches obtained from the running\n     the template matching algorithm.\n    circuit_dag_dep (DAGDependency): circuit in the dag dependency form.\n    template_dag_dep (DAGDependency): template in the dag dependency form.\n    user_cost_dict (Optional[dict]): user provided cost dictionary that will override\n        the default cost dictionary.",
        "api_signature": "__init__(self, max_matches, circuit_dag_dep, template_dag_dep, user_cost_dict)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/template_substitution.py"
    },
    {
        "api_name": "_pred_block",
        "full_api_name": "TemplateSubstitution._pred_block",
        "api_description": "It returns the predecessors of a given part of the circuit.\nArgs:\n    circuit_sublist (list): list of the gates matched in the circuit.\n    index (int): Index of the group of matches.\nReturns:\n    list: List of predecessors of the current match circuit configuration.",
        "api_signature": "_pred_block(self, circuit_sublist, index)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/template_substitution.py"
    },
    {
        "api_name": "_quantum_cost",
        "full_api_name": "TemplateSubstitution._quantum_cost",
        "api_description": "Compare the two parts of the template and returns True if the quantum cost is reduced.\nArgs:\n    left (list): list of matched nodes in the template.\n    right (list): list of nodes to be replaced.\nReturns:\n    bool: True if the quantum cost is reduced",
        "api_signature": "_quantum_cost(self, left, right)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/template_substitution.py"
    },
    {
        "api_name": "_rules",
        "full_api_name": "TemplateSubstitution._rules",
        "api_description": "Set of rules to decide whether the match is to be substitute or not.\nArgs:\n    circuit_sublist (list): list of the gates matched in the circuit.\n    template_sublist (list): list of matched nodes in the template.\n    template_complement (list): list of gates not matched in the template.\nReturns:\n    bool: True if the match respects the given rule for replacement, False otherwise.",
        "api_signature": "_rules(self, circuit_sublist, template_sublist, template_complement)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/template_substitution.py"
    },
    {
        "api_name": "_template_inverse",
        "full_api_name": "TemplateSubstitution._template_inverse",
        "api_description": "The template circuit realizes the identity operator, then given the list of\nmatches in the template, it returns the inverse part of the template that\nwill be replaced.\nArgs:\n    template_list (list): list of all gates in the template.\n    template_sublist (list): list of the gates matched in the circuit.\n    template_complement  (list): list of gates not matched in the template.\nReturns:\n    list: the template inverse part that will substitute the circuit match.",
        "api_signature": "_template_inverse(self, template_list, template_sublist, template_complement)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/template_substitution.py"
    },
    {
        "api_name": "_substitution_sort",
        "full_api_name": "TemplateSubstitution._substitution_sort",
        "api_description": "Sort the substitution list.",
        "api_signature": "_substitution_sort(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/template_substitution.py"
    },
    {
        "api_name": "_permutation",
        "full_api_name": "TemplateSubstitution._permutation",
        "api_description": "Permute two groups of matches if first one has predecessors in the second one.\nReturns:\n    bool: True if the matches groups are in the right order, False otherwise.",
        "api_signature": "_permutation(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/template_substitution.py"
    },
    {
        "api_name": "_remove_impossible",
        "full_api_name": "TemplateSubstitution._remove_impossible",
        "api_description": "Remove matched groups if they both have predecessors in the other one, they are not\ncompatible.",
        "api_signature": "_remove_impossible(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/template_substitution.py"
    },
    {
        "api_name": "_substitution",
        "full_api_name": "TemplateSubstitution._substitution",
        "api_description": "From the list of maximal matches, it chooses which one will be used and gives the necessary\ndetails for each substitution(template inverse, predecessors of the match).",
        "api_signature": "_substitution(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/template_substitution.py"
    },
    {
        "api_name": "run_dag_opt",
        "full_api_name": "TemplateSubstitution.run_dag_opt",
        "api_description": "It runs the substitution algorithm and creates the optimized DAGCircuit().",
        "api_signature": "run_dag_opt(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/template_substitution.py"
    },
    {
        "api_name": "_attempt_bind",
        "full_api_name": "TemplateSubstitution._attempt_bind",
        "api_description": "Copies the template and attempts to bind any parameters,\ni.e. attempts to solve for a valid parameter assignment.\ntemplate_sublist and circuit_sublist match up to the\nassignment of the parameters. For example the template\n\n.. parsed-literal::\n\n         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    q_0: \u2524 P(-1.0*\u03b2) \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u25240       \u251c\n         \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u250c\u2500\u2534\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2534\u2500\u2510\u2502  CZ(\u03b2) \u2502\n    q_1: \u2524 P(-1.0*\u03b2) \u251c\u2524 X \u251c\u2524 P(\u03b2) \u251c\u2524 X \u251c\u25241       \u251c\n         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nshould only maximally match once in the circuit\n\n.. parsed-literal::\n\n         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    q_0: \u2524 P(-2) \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n         \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u250c\u2500\u2534\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2534\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    q_1: \u2524 P(-2) \u251c\u2524 X \u251c\u2524 P(2) \u251c\u2524 X \u251c\u2524 P(3) \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\n         \u2514\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2534\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2534\u2500\u2510\n    q_2: \u2500\u2524 P(3) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2524 P(3) \u251c\u2524 X \u251c\n          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518                          \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\n\nHowever, up until attempt bind is called, the soft matching\nwill have found two matches due to the parameters.\nThe first match can be satisfied with \u03b2=2. However, the\nsecond match would imply both \u03b2=3 and \u03b2=-3 which is impossible.\nAttempt bind detects inconsistencies by solving a system of equations\ngiven by the parameter expressions in the sub-template and the\nvalue of the parameters in the gates of the sub-circuit. If a\nsolution is found then the match is valid and the parameters\nare assigned. If not, None is returned.\n\nIn order to resolve the conflict of the same parameter names in the\ncircuit and template, each variable in the template sublist is\nre-assigned to a new dummy parameter with a completely separate name\nif it clashes with one that exists in an input circuit.\n\nArgs:\n    template_sublist (list): part of the matched template.\n    circuit_sublist (list): part of the matched circuit.\n\nReturns:\n    DAGDependency: A deep copy of the template with\n        the parameters bound. If no binding satisfies the\n        parameter constraints, returns None.",
        "api_signature": "_attempt_bind(self, template_sublist, circuit_sublist)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/template_substitution.py"
    },
    {
        "api_name": "dummy_parameter",
        "full_api_name": "TemplateSubstitution.dummy_parameter",
        "api_description": "",
        "api_signature": "dummy_parameter()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/template_substitution.py"
    },
    {
        "api_name": "_incr_num_parameters",
        "full_api_name": "TemplateSubstitution._incr_num_parameters",
        "api_description": "Checks if template substitution would increase the number of\nparameters in the circuit.",
        "api_signature": "_incr_num_parameters(self, template)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/template_substitution.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Match.__init__",
        "api_description": "Create a Match with necessary arguments.\nArgs:\n    match (list): list of a match.\n    qubit (list): list of qubits configuration.\n    clbit (list): list of clbits configuration.",
        "api_signature": "__init__(self, match, qubit, clbit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/maximal_matches.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "MaximalMatches.__init__",
        "api_description": "Initialize MaximalMatches with the necessary arguments.\nArgs:\n    template_matches (list): list of matches obtained from running the algorithm.",
        "api_signature": "__init__(self, template_matches)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/maximal_matches.py"
    },
    {
        "api_name": "run_maximal_matches",
        "full_api_name": "MaximalMatches.run_maximal_matches",
        "api_description": "Method that extracts and stores maximal matches in decreasing length order.",
        "api_signature": "run_maximal_matches(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/maximal_matches.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "TemplateMatching.__init__",
        "api_description": "Create a TemplateMatching object with necessary arguments.\nArgs:\n    circuit_dag_dep (QuantumCircuit): circuit.\n    template_dag_dep (QuantumCircuit): template.\n    heuristics_backward_param (list[int]): [length, survivor]\n    heuristics_qubits_param (list[int]): [length]",
        "api_signature": "__init__(self, circuit_dag_dep, template_dag_dep, heuristics_qubits_param, heuristics_backward_param)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/template_matching.py"
    },
    {
        "api_name": "_list_first_match_new",
        "full_api_name": "TemplateMatching._list_first_match_new",
        "api_description": "Returns the list of qubit for circuit given the first match, the unknown qubit are\nreplaced by -1.\nArgs:\n    node_circuit (DAGDepNode): First match node in the circuit.\n    node_template (DAGDepNode): First match node in the template.\n    n_qubits_t (int): number of qubit in the template.\n    n_clbits_t (int): number of classical bit in the template.\nReturns:\n    list: list of qubits to consider in circuit (with specific order).",
        "api_signature": "_list_first_match_new(self, node_circuit, node_template, n_qubits_t, n_clbits_t)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/template_matching.py"
    },
    {
        "api_name": "_sublist",
        "full_api_name": "TemplateMatching._sublist",
        "api_description": "Function that returns all possible combinations of a given length, considering an\nexcluded list of elements.\nArgs:\n    lst (list): list of qubits indices from the circuit.\n    exclude (list): list of qubits from the first matched circuit gate.\n    length (int): length of the list to be returned (number of template qubit -\n    number of qubit from the first matched template gate).\nYield:\n    iterator: Iterator of the possible lists.",
        "api_signature": "_sublist(self, lst, exclude, length)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/template_matching.py"
    },
    {
        "api_name": "_list_qubit_clbit_circuit",
        "full_api_name": "TemplateMatching._list_qubit_clbit_circuit",
        "api_description": "Function that returns the list of the circuit qubits and clbits give a permutation\nand an initial match.\nArgs:\n    list_first_match (list): list of qubits indices for the initial match.\n    permutation (list): possible permutation for the circuit qubit.\nReturns:\n    list: list of circuit qubit for the given permutation and initial match.",
        "api_signature": "_list_qubit_clbit_circuit(self, list_first_match, permutation)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/template_matching.py"
    },
    {
        "api_name": "_add_match",
        "full_api_name": "TemplateMatching._add_match",
        "api_description": "Method to add a match in list only if it is not already in it.\nIf the match is already in the list, the qubit configuration\nis append to the existing match.\nArgs:\n    backward_match_list (list): match from the backward part of the\n    algorithm.",
        "api_signature": "_add_match(self, backward_match_list)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/template_matching.py"
    },
    {
        "api_name": "_explore_circuit",
        "full_api_name": "TemplateMatching._explore_circuit",
        "api_description": "Explore the successors of the node_id_c (up to the given length).\nArgs:\n    node_id_c (int): first match id in the circuit.\n    node_id_t (int): first match id in the template.\n    n_qubits_t (int): number of qubits in the template.\n    length (int): length for exploration of the successors.\nReturns:\n    list: qubits configuration for the 'length' successors of node_id_c.",
        "api_signature": "_explore_circuit(self, node_id_c, node_id_t, n_qubits_t, length)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/template_matching.py"
    },
    {
        "api_name": "run_template_matching",
        "full_api_name": "TemplateMatching.run_template_matching",
        "api_description": "Run the complete algorithm for finding all maximal matches for the given template and\ncircuit. First it fixes the configuration of the circuit due to the first match.\nThen it explores all compatible qubit configurations of the circuit. For each\nqubit configurations, we apply first the Forward part of the algorithm  and then\nthe Backward part of the algorithm. The longest matches for the given configuration\nare stored. Finally, the list of stored matches is sorted.",
        "api_signature": "run_template_matching(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/template_matching.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Match.__init__",
        "api_description": "Create a Match class with necessary arguments.\nArgs:\n    match (list): list of matched gates.\n    qubit (list): list of qubits configuration.\n    clbit (list): list of clbits configuration.",
        "api_signature": "__init__(self, match, qubit, clbit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/backward_match.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "MatchingScenarios.__init__",
        "api_description": "Create a MatchingScenarios class with necessary arguments.\nArgs:\n    circuit_matched (list): list of matchedwith attributes in the circuit.\n    circuit_blocked (list): list of isblocked attributes in the circuit.\n    template_matched (list): list of matchedwith attributes in the template.\n    template_blocked (list): list of isblocked attributes in the template.\n    matches (list): list of matches.\n    counter (int): counter of the number of circuit gates already considered.",
        "api_signature": "__init__(self, circuit_matched, circuit_blocked, template_matched, template_blocked, matches, counter)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/backward_match.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "MatchingScenariosList.__init__",
        "api_description": "Create an empty MatchingScenariosList.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/backward_match.py"
    },
    {
        "api_name": "append_scenario",
        "full_api_name": "MatchingScenariosList.append_scenario",
        "api_description": "Append a scenario to the list.\nArgs:\n    matching (MatchingScenarios): a scenario of match.",
        "api_signature": "append_scenario(self, matching)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/backward_match.py"
    },
    {
        "api_name": "pop_scenario",
        "full_api_name": "MatchingScenariosList.pop_scenario",
        "api_description": "Pop the first scenario of the list.\nReturns:\n    MatchingScenarios: a scenario of match.",
        "api_signature": "pop_scenario(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/backward_match.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BackwardMatch.__init__",
        "api_description": "Create a ForwardMatch class with necessary arguments.\nArgs:\n    circuit_dag_dep (DAGDependency): circuit in the dag dependency form.\n    template_dag_dep (DAGDependency): template in the dag dependency form.\n    forward_matches (list): list of match obtained in the forward direction.\n    node_id_c (int): index of the first gate matched in the circuit.\n    node_id_t (int): index of the first gate matched in the template.\n    qubits (list): list of considered qubits in the circuit.\n    clbits (list): list of considered clbits in the circuit.\n    heuristics_backward_param (list): list that contains the two parameters for\n    applying the heuristics (length and survivor).",
        "api_signature": "__init__(self, circuit_dag_dep, template_dag_dep, forward_matches, node_id_c, node_id_t, qubits, clbits, heuristics_backward_param)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/backward_match.py"
    },
    {
        "api_name": "_gate_indices",
        "full_api_name": "BackwardMatch._gate_indices",
        "api_description": "Function which returns the list of gates that are not match and not\nblocked for the first scenario.\nReturns:\n    list: list of gate id.",
        "api_signature": "_gate_indices(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/backward_match.py"
    },
    {
        "api_name": "_find_backward_candidates",
        "full_api_name": "BackwardMatch._find_backward_candidates",
        "api_description": "Function which returns the list possible backward candidates in the template dag.\nArgs:\n    template_blocked (list): list of attributes isblocked in the template circuit.\n    matches (list): list of matches.\nReturns:\n    list: list of backward candidates (id).",
        "api_signature": "_find_backward_candidates(self, template_blocked, matches)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/backward_match.py"
    },
    {
        "api_name": "_update_qarg_indices",
        "full_api_name": "BackwardMatch._update_qarg_indices",
        "api_description": "Change qubits indices of the current circuit node in order to\nbe comparable the indices of the template qubits list.\nArgs:\n    qarg (list): list of qubits indices from the circuit for a given gate.\nReturns:\n    list: circuit indices update for qubits.",
        "api_signature": "_update_qarg_indices(self, qarg)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/backward_match.py"
    },
    {
        "api_name": "_update_carg_indices",
        "full_api_name": "BackwardMatch._update_carg_indices",
        "api_description": "Change clbits indices of the current circuit node in order to\nbe comparable the indices of the template qubits list.\nArgs:\n    carg (list): list of clbits indices from the circuit for a given gate.\nReturns:\n    list: circuit indices update for clbits.",
        "api_signature": "_update_carg_indices(self, carg)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/backward_match.py"
    },
    {
        "api_name": "_is_same_op",
        "full_api_name": "BackwardMatch._is_same_op",
        "api_description": "Check if two instructions are the same.\nArgs:\n    node_circuit (DAGDepNode): node in the circuit.\n    node_template (DAGDepNode): node in the template.\nReturns:\n    bool: True if the same, False otherwise.",
        "api_signature": "_is_same_op(self, node_circuit, node_template)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/backward_match.py"
    },
    {
        "api_name": "_is_same_q_conf",
        "full_api_name": "BackwardMatch._is_same_q_conf",
        "api_description": "Check if the qubits configurations are compatible.\nArgs:\n    node_circuit (DAGDepNode): node in the circuit.\n    node_template (DAGDepNode): node in the template.\n    qarg_circuit (list): qubits configuration for the Instruction in the circuit.\nReturns:\n    bool: True if possible, False otherwise.",
        "api_signature": "_is_same_q_conf(self, node_circuit, node_template, qarg_circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/backward_match.py"
    },
    {
        "api_name": "_is_same_c_conf",
        "full_api_name": "BackwardMatch._is_same_c_conf",
        "api_description": "Check if the clbits configurations are compatible.\nArgs:\n    node_circuit (DAGDepNode): node in the circuit.\n    node_template (DAGDepNode): node in the template.\n    carg_circuit (list): clbits configuration for the Instruction in the circuit.\nReturns:\n    bool: True if possible, False otherwise.",
        "api_signature": "_is_same_c_conf(self, node_circuit, node_template, carg_circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/backward_match.py"
    },
    {
        "api_name": "_init_matched_blocked_list",
        "full_api_name": "BackwardMatch._init_matched_blocked_list",
        "api_description": "Initialize the list of blocked and matchedwith attributes.\nReturns:\n    Tuple[list, list, list, list]:\n    First list contains the attributes matchedwith in the circuit,\n    second list contains the attributes isblocked in the circuit,\n    third list contains the attributes matchedwith in the template,\n    fourth list contains the attributes isblocked in the template.",
        "api_signature": "_init_matched_blocked_list(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/backward_match.py"
    },
    {
        "api_name": "_backward_heuristics",
        "full_api_name": "BackwardMatch._backward_heuristics",
        "api_description": "Heuristics to cut the tree in the backward match algorithm\nArgs:\n    gate_indices (list): list of candidates in the circuit.\n    length (int): depth for cutting the tree, cutting operation is repeated every length.\n    survivor (int): number of survivor branches.",
        "api_signature": "_backward_heuristics(self, gate_indices, length, survivor)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/backward_match.py"
    },
    {
        "api_name": "_backward_metrics",
        "full_api_name": "BackwardMatch._backward_metrics",
        "api_description": "Heuristics to cut the tree in the backward match algorithm.\nArgs:\n    scenario (MatchingScenarios): scenario for the given match.\nReturns:\n    int: length of the match for the given scenario.",
        "api_signature": "_backward_metrics(self, scenario)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/backward_match.py"
    },
    {
        "api_name": "run_backward_match",
        "full_api_name": "BackwardMatch.run_backward_match",
        "api_description": "Apply the forward match algorithm and returns the list of matches given an initial match\nand a circuit qubits configuration.",
        "api_signature": "run_backward_match(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/optimization/template_matching/backward_match.py"
    },
    {
        "api_name": "supported",
        "full_api_name": "CalibrationBuilder.supported",
        "api_description": "Determine if a given node supports the calibration.\n\nArgs:\n    node_op: Target instruction object.\n    qubits: Integer qubit indices to check.\n\nReturns:\n    Return ``True`` is calibration can be provided.",
        "api_signature": "supported(self, node_op, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/calibration/base_builder.py"
    },
    {
        "api_name": "get_calibration",
        "full_api_name": "CalibrationBuilder.get_calibration",
        "api_description": "Gets the calibrated schedule for the given instruction and qubits.\n\nArgs:\n    node_op: Target instruction object.\n    qubits: Integer qubit indices to check.\n\nReturns:\n    Return Schedule of target gate instruction.",
        "api_signature": "get_calibration(self, node_op, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/calibration/base_builder.py"
    },
    {
        "api_name": "run",
        "full_api_name": "CalibrationBuilder.run",
        "api_description": "Run the calibration adder pass on `dag`.\n\nArgs:\n    dag: DAG to schedule.\n\nReturns:\n    A DAG with calibrations added to it.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/calibration/base_builder.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "RXCalibrationBuilder.__init__",
        "api_description": "Bootstrap single-pulse RX gate calibrations from the\n(hardware-calibrated) SX gate calibration.\n\nArgs:\n    target (Target): Should contain a SX calibration that will be\n    used for bootstrapping RX calibrations.",
        "api_signature": "__init__(self, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/calibration/rx_builder.py"
    },
    {
        "api_name": "supported",
        "full_api_name": "RXCalibrationBuilder.supported",
        "api_description": "Check if the calibration for SX gate exists and it's a single DRAG pulse.",
        "api_signature": "supported(self, node_op, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/calibration/rx_builder.py"
    },
    {
        "api_name": "get_calibration",
        "full_api_name": "RXCalibrationBuilder.get_calibration",
        "api_description": "Generate RX calibration for the rotation angle specified in node_op.",
        "api_signature": "get_calibration(self, node_op, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/calibration/rx_builder.py"
    },
    {
        "api_name": "_create_rx_sched",
        "full_api_name": "_create_rx_sched",
        "api_description": "Generates (and caches) pulse calibrations for RX gates.\nAssumes that the rotation angle is in [0, pi].",
        "api_signature": "_create_rx_sched(rx_angle, duration, amp, sigma, beta, channel)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/calibration/rx_builder.py"
    },
    {
        "api_name": "rzx_templates",
        "full_api_name": "rzx_templates",
        "api_description": "Convenience function to get the cost_dict and templates for template matching.\n\nArgs:\n    template_list: List of instruction names.\n\nReturns:\n    Decomposition templates and cost values.",
        "api_signature": "rzx_templates(template_list)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/calibration/rzx_templates.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PulseGates.__init__",
        "api_description": "Create new pass.\n\nArgs:\n    inst_map: Instruction schedule map that user may override.\n    target: The :class:`~.Target` representing the target backend, if both\n        ``inst_map`` and ``target`` are specified then it updates instructions\n        in the ``target`` with ``inst_map``.",
        "api_signature": "__init__(self, inst_map, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/calibration/pulse_gate.py"
    },
    {
        "api_name": "supported",
        "full_api_name": "PulseGates.supported",
        "api_description": "Determine if a given node supports the calibration.\n\nArgs:\n    node_op: Target instruction object.\n    qubits: Integer qubit indices to check.\n\nReturns:\n    Return ``True`` is calibration can be provided.",
        "api_signature": "supported(self, node_op, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/calibration/pulse_gate.py"
    },
    {
        "api_name": "get_calibration",
        "full_api_name": "PulseGates.get_calibration",
        "api_description": "Gets the calibrated schedule for the given instruction and qubits.\n\nArgs:\n    node_op: Target instruction object.\n    qubits: Integer qubit indices to check.\n\nReturns:\n    Return Schedule of target gate instruction.\n\nRaises:\n    TranspilerError: When node is parameterized and calibration is raw schedule object.",
        "api_signature": "get_calibration(self, node_op, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/calibration/pulse_gate.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "RZXCalibrationBuilder.__init__",
        "api_description": "Initializes a RZXGate calibration builder.\n\nArgs:\n    instruction_schedule_map: The :obj:`InstructionScheduleMap` object representing the\n        default pulse calibrations for the target backend\n    verbose: Set True to raise a user warning when RZX schedule cannot be built.\n    target: The :class:`~.Target` representing the target backend, if both\n         ``instruction_schedule_map`` and this are specified then this argument will take\n         precedence and ``instruction_schedule_map`` will be ignored.\n\nRaises:\n    QiskitError: Instruction schedule map is not provided.",
        "api_signature": "__init__(self, instruction_schedule_map, verbose, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/calibration/rzx_builder.py"
    },
    {
        "api_name": "supported",
        "full_api_name": "RZXCalibrationBuilder.supported",
        "api_description": "Determine if a given node supports the calibration.\n\nArgs:\n    node_op: Target instruction object.\n    qubits: Integer qubit indices to check.\n\nReturns:\n    Return ``True`` is calibration can be provided.",
        "api_signature": "supported(self, node_op, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/calibration/rzx_builder.py"
    },
    {
        "api_name": "rescale_cr_inst",
        "full_api_name": "RZXCalibrationBuilder.rescale_cr_inst",
        "api_description": "A builder macro to play stretched pulse.\n\nArgs:\n    instruction: The instruction from which to create a new shortened or lengthened pulse.\n    theta: desired angle, pi/2 is assumed to be the angle that the pulse in the given\n        play instruction implements.\n    sample_mult: All pulses must be a multiple of sample_mult.\n\nReturns:\n    Duration of stretched pulse.\n\nRaises:\n    QiskitError: if rotation angle is not assigned.",
        "api_signature": "rescale_cr_inst(instruction, theta, sample_mult)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/calibration/rzx_builder.py"
    },
    {
        "api_name": "get_calibration",
        "full_api_name": "RZXCalibrationBuilder.get_calibration",
        "api_description": "Builds the calibration schedule for the RZXGate(theta) with echos.\n\nArgs:\n    node_op: Instruction of the RZXGate(theta). I.e. params[0] is theta.\n    qubits: List of qubits for which to get the schedules. The first qubit is\n        the control and the second is the target.\n\nReturns:\n    schedule: The calibration schedule for the RZXGate(theta).\n\nRaises:\n    QiskitError: if rotation angle is not assigned.\n    QiskitError: If the control and target qubits cannot be identified.\n    CalibrationNotAvailable: RZX schedule cannot be built for input node.",
        "api_signature": "get_calibration(self, node_op, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/calibration/rzx_builder.py"
    },
    {
        "api_name": "get_calibration",
        "full_api_name": "RZXCalibrationBuilderNoEcho.get_calibration",
        "api_description": "Builds the calibration schedule for the RZXGate(theta) without echos.\n\nArgs:\n    node_op: Instruction of the RZXGate(theta). I.e. params[0] is theta.\n    qubits: List of qubits for which to get the schedules. The first qubit is\n        the control and the second is the target.\n\nReturns:\n    schedule: The calibration schedule for the RZXGate(theta).\n\nRaises:\n    QiskitError: if rotation angle is not assigned.\n    QiskitError: If the control and target qubits cannot be identified,\n        or the backend does not natively support the specified direction of the cx.\n    CalibrationNotAvailable: RZX schedule cannot be built for input node.",
        "api_signature": "get_calibration(self, node_op, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/calibration/rzx_builder.py"
    },
    {
        "api_name": "_filter_cr_tone",
        "full_api_name": "_filter_cr_tone",
        "api_description": "A helper function to filter pulses on control channels.",
        "api_signature": "_filter_cr_tone(time_inst_tup)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/calibration/rzx_builder.py"
    },
    {
        "api_name": "_filter_comp_tone",
        "full_api_name": "_filter_comp_tone",
        "api_description": "A helper function to filter pulses on drive channels.",
        "api_signature": "_filter_comp_tone(time_inst_tup)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/calibration/rzx_builder.py"
    },
    {
        "api_name": "_check_calibration_type",
        "full_api_name": "_check_calibration_type",
        "api_description": "A helper function to check type of CR calibration.\n\nArgs:\n    inst_sched_map: instruction schedule map of the backends\n    qubits: ordered tuple of qubits for cross resonance (q_control, q_target)\n\nReturns:\n    Filtered instructions and most-likely type of calibration.\n\nRaises:\n    QiskitError: Unknown calibration type is detected.",
        "api_signature": "_check_calibration_type(inst_sched_map, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/calibration/rzx_builder.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "LookaheadSwap.__init__",
        "api_description": "LookaheadSwap initializer.\n\nArgs:\n    coupling_map (Union[CouplingMap, Target]): CouplingMap of the target backend.\n    search_depth (int): lookahead tree depth when ranking best SWAP options.\n    search_width (int): lookahead tree width when ranking best SWAP options.\n    fake_run (bool): if true, it will only pretend to do routing, i.e., no\n        swap is effectively added.",
        "api_signature": "__init__(self, coupling_map, search_depth, search_width, fake_run)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/lookahead_swap.py"
    },
    {
        "api_name": "run",
        "full_api_name": "LookaheadSwap.run",
        "api_description": "Run the LookaheadSwap pass on `dag`.\n\nArgs:\n    dag (DAGCircuit): the directed acyclic graph to be mapped\nReturns:\n    DAGCircuit: A dag mapped to be compatible with the coupling_map in\n        the property_set.\nRaises:\n    TranspilerError: if the coupling map or the layout are not\n    compatible with the DAG, or if the coupling_map=None",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/lookahead_swap.py"
    },
    {
        "api_name": "_search_forward_n_swaps",
        "full_api_name": "_search_forward_n_swaps",
        "api_description": "Search for SWAPs which allow for application of largest number of gates.\n\nArgs:\n    state (_SystemState): The ``namedtuple`` collection containing the state of the physical\n        system.  This includes the current layout, the coupling map, the canonical register and\n        the possible swaps available.\n    gates (list): Gates to be mapped.\n    depth (int): Number of SWAP layers to search before choosing a result.\n    width (int): Number of SWAPs to consider at each layer.\nReturns:\n    Optional(_Step): Describes the solution step found.  If ``None``, no swaps leading to an\n    improvement were found.",
        "api_signature": "_search_forward_n_swaps(state, gates, depth, width)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/lookahead_swap.py"
    },
    {
        "api_name": "_map_free_gates",
        "full_api_name": "_map_free_gates",
        "api_description": "Map all gates that can be executed with the current layout.\n\nArgs:\n    state (_SystemState): The physical characteristics of the system, including its current\n        layout and the coupling map.\n    gates (list): Gates to be mapped.\n\nReturns:\n    tuple:\n        mapped_gates (list): ops for gates that can be executed, mapped onto layout.\n        remaining_gates (list): gates that cannot be executed on the layout.",
        "api_signature": "_map_free_gates(state, gates)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/lookahead_swap.py"
    },
    {
        "api_name": "_calc_layout_distance",
        "full_api_name": "_calc_layout_distance",
        "api_description": "Return the sum of the distances of two-qubit pairs in each CNOT in gates\naccording to the layout and the coupling.",
        "api_signature": "_calc_layout_distance(gates, state, max_gates)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/lookahead_swap.py"
    },
    {
        "api_name": "_score_state_with_swap",
        "full_api_name": "_score_state_with_swap",
        "api_description": "Calculate the relative score for a given SWAP.\n\nReturns:\n    float: the score of the given swap.\n    Tuple[int, int]: the input swap that should be performed.\n    _SystemState: an updated system state with the new layout contained.",
        "api_signature": "_score_state_with_swap(swap, state, gates)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/lookahead_swap.py"
    },
    {
        "api_name": "_score_step",
        "full_api_name": "_score_step",
        "api_description": "Count the mapped two-qubit gates, less the number of added SWAPs.",
        "api_signature": "_score_step(step)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/lookahead_swap.py"
    },
    {
        "api_name": "_transform_gate_for_system",
        "full_api_name": "_transform_gate_for_system",
        "api_description": "Return op implementing a virtual gate on given layout.",
        "api_signature": "_transform_gate_for_system(gate, state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/lookahead_swap.py"
    },
    {
        "api_name": "_swap_ops_from_edge",
        "full_api_name": "_swap_ops_from_edge",
        "api_description": "Generate list of ops to implement a SWAP gate along a coupling edge.",
        "api_signature": "_swap_ops_from_edge(edge, state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/lookahead_swap.py"
    },
    {
        "api_name": "_first_op_node",
        "full_api_name": "_first_op_node",
        "api_description": "Get the first op node from a DAG.",
        "api_signature": "_first_op_node(dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/lookahead_swap.py"
    },
    {
        "api_name": "get_swap_map_dag",
        "full_api_name": "get_swap_map_dag",
        "api_description": "Get the circuit of swaps to go from from_layout to to_layout, and the physical qubits\n(integers) that the swap circuit should be applied on.",
        "api_signature": "get_swap_map_dag(dag, coupling_map, from_layout, to_layout, seed, trials)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/utils.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "StarBlock.__init__",
        "api_description": "",
        "api_signature": "__init__(self, nodes, center, num2q)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/star_prerouting.py"
    },
    {
        "api_name": "get_nodes",
        "full_api_name": "StarBlock.get_nodes",
        "api_description": "Returns the list of nodes used in the block.",
        "api_signature": "get_nodes(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/star_prerouting.py"
    },
    {
        "api_name": "append_node",
        "full_api_name": "StarBlock.append_node",
        "api_description": "If node can be added to block while keeping the block star-shaped, and\nreturn True. Otherwise, does not add node to block and returns False.",
        "api_signature": "append_node(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/star_prerouting.py"
    },
    {
        "api_name": "size",
        "full_api_name": "StarBlock.size",
        "api_description": "Returns the number of two-qubit quantum gates in this block.",
        "api_signature": "size(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/star_prerouting.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "StarPreRouting.__init__",
        "api_description": "StarPreRouting",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/star_prerouting.py"
    },
    {
        "api_name": "_setup_in_degrees",
        "full_api_name": "StarPreRouting._setup_in_degrees",
        "api_description": "For an efficient implementation, for every node we keep the number of its\nunprocessed immediate predecessors (called ``_in_degree``). This ``_in_degree``\nis set up at the start and updated throughout the algorithm.\nA node is leaf (or input) node iff its ``_in_degree`` is 0.\nWhen a node is (marked as) collected, the ``_in_degree`` of each of its immediate\nsuccessor is updated by subtracting 1.\nAdditionally, ``_pending_nodes`` explicitly keeps the list of nodes whose\n``_in_degree`` is 0.",
        "api_signature": "_setup_in_degrees(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/star_prerouting.py"
    },
    {
        "api_name": "_op_nodes",
        "full_api_name": "StarPreRouting._op_nodes",
        "api_description": "Returns DAG nodes.",
        "api_signature": "_op_nodes(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/star_prerouting.py"
    },
    {
        "api_name": "_direct_preds",
        "full_api_name": "StarPreRouting._direct_preds",
        "api_description": "Returns direct predecessors of a node. This function takes into account the\ndirection of collecting blocks, that is node's predecessors when collecting\nbackwards are the direct successors of a node in the DAG.",
        "api_signature": "_direct_preds(self, dag, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/star_prerouting.py"
    },
    {
        "api_name": "_direct_succs",
        "full_api_name": "StarPreRouting._direct_succs",
        "api_description": "Returns direct successors of a node. This function takes into account the\ndirection of collecting blocks, that is node's successors when collecting\nbackwards are the direct predecessors of a node in the DAG.",
        "api_signature": "_direct_succs(self, dag, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/star_prerouting.py"
    },
    {
        "api_name": "_have_uncollected_nodes",
        "full_api_name": "StarPreRouting._have_uncollected_nodes",
        "api_description": "Returns whether there are uncollected (pending) nodes",
        "api_signature": "_have_uncollected_nodes(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/star_prerouting.py"
    },
    {
        "api_name": "collect_matching_block",
        "full_api_name": "StarPreRouting.collect_matching_block",
        "api_description": "Iteratively collects the largest block of input nodes (that is, nodes with\n``_in_degree`` equal to 0) that match a given filtering function.\nExamples of this include collecting blocks of swap gates,\nblocks of linear gates (CXs and SWAPs), blocks of Clifford gates, blocks of single-qubit gates,\nblocks of two-qubit gates, etc.  Here 'iteratively' means that once a node is collected,\nthe ``_in_degree`` of each of its immediate successor is decreased by 1, allowing more nodes\nto become input and to be eligible for collecting into the current block.\nReturns the block of collected nodes.",
        "api_signature": "collect_matching_block(self, dag, filter_fn)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/star_prerouting.py"
    },
    {
        "api_name": "collect_all_matching_blocks",
        "full_api_name": "StarPreRouting.collect_all_matching_blocks",
        "api_description": "Collects all blocks that match a given filtering function filter_fn.\nThis iteratively finds the largest block that does not match filter_fn,\nthen the largest block that matches filter_fn, and so on, until no more uncollected\nnodes remain. Intuitively, finding larger blocks of non-matching nodes helps to\nfind larger blocks of matching nodes later on. The option ``min_block_size``\nspecifies the minimum number of gates in the block for the block to be collected.\n\nBy default, blocks are collected in the direction from the inputs towards the outputs\nof the circuit. The option ``collect_from_back`` allows to change this direction,\nthat is collect blocks from the outputs towards the inputs of the circuit.\n\nReturns the list of matching blocks only.",
        "api_signature": "collect_all_matching_blocks(self, dag, min_block_size)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/star_prerouting.py"
    },
    {
        "api_name": "filter_fn",
        "full_api_name": "StarPreRouting.filter_fn",
        "api_description": "Specifies which nodes can be collected into star blocks.",
        "api_signature": "filter_fn(node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/star_prerouting.py"
    },
    {
        "api_name": "not_filter_fn",
        "full_api_name": "StarPreRouting.not_filter_fn",
        "api_description": "Returns the opposite of filter_fn.",
        "api_signature": "not_filter_fn(node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/star_prerouting.py"
    },
    {
        "api_name": "run",
        "full_api_name": "StarPreRouting.run",
        "api_description": "",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/star_prerouting.py"
    },
    {
        "api_name": "determine_star_blocks_processing",
        "full_api_name": "StarPreRouting.determine_star_blocks_processing",
        "api_description": "Returns star blocks in dag and the processing order of nodes within these star blocks\nArgs:\n    dag (DAGCircuit or DAGDependency): a dag on which star blocks should be determined.\n    min_block_size (int): minimum number of two-qubit gates in a star block.\n\nReturns:\n    List[StarBlock]: a list of star blocks in the given dag\n    Union[List[DAGOpNode], List[DAGDepNode]]: a list of operations specifying processing order",
        "api_signature": "determine_star_blocks_processing(self, dag, min_block_size)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/star_prerouting.py"
    },
    {
        "api_name": "star_preroute",
        "full_api_name": "StarPreRouting.star_preroute",
        "api_description": "Returns star blocks in dag and the processing order of nodes within these star blocks\nArgs:\n    dag (DAGCircuit or DAGDependency): a dag on which star prerouting should be performed.\n    blocks (List[StarBlock]): a list of star blocks in the given dag.\n    processing_order (Union[List[DAGOpNode], List[DAGDepNode]]): a list of operations specifying\n    processing order\n\nReturns:\n    new_dag: a dag specifying the pre-routed circuit\n    qubit_mapping: the final qubit mapping after pre-routing",
        "api_signature": "star_preroute(self, dag, blocks, processing_order)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/star_prerouting.py"
    },
    {
        "api_name": "tie_breaker_key",
        "full_api_name": "StarPreRouting.tie_breaker_key",
        "api_description": "",
        "api_signature": "tie_breaker_key(node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/star_prerouting.py"
    },
    {
        "api_name": "_extract_nodes",
        "full_api_name": "_extract_nodes",
        "api_description": "Extract and format node information for Rust representation used in SabreDAG.\n\nEach node is represented as a tuple containing:\n- Node ID (int): The unique identifier of the node in the DAG.\n- Qubit indices (list of int): Indices of qubits involved in the node's operation.\n- Classical bit indices (set of int): Indices of classical bits involved in the node's operation.\n- Directive flag (bool): Indicates whether the operation is a directive (True) or not (False).\n\nArgs:\n    nodes (list[DAGOpNode]): List of DAGOpNode objects to extract information from.\n    dag (DAGCircuit): DAGCircuit object containing the circuit structure.\n\nReturns:\n    list of tuples: Each tuple contains information about a node in the format described above.",
        "api_signature": "_extract_nodes(nodes, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/star_prerouting.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SabreSwap.__init__",
        "api_description": "SabreSwap initializer.\n\nArgs:\n    coupling_map (Union[CouplingMap, Target]): CouplingMap of the target backend.\n    heuristic (str): The type of heuristic to use when deciding best\n        swap strategy ('basic' or 'lookahead' or 'decay').\n    seed (int): random seed used to tie-break among candidate swaps.\n    fake_run (bool): if true, it only pretend to do routing, i.e., no\n        swap is effectively added.\n    trials (int): The number of seed trials to run sabre with. These will\n        be run in parallel (unless the PassManager is already running in\n        parallel). If not specified this defaults to the number of physical\n        CPUs on the local system. For reproducible results it is recommended\n        that you set this explicitly, as the output will be deterministic for\n        a fixed number of trials.\n\nRaises:\n    TranspilerError: If the specified heuristic is not valid.\n\nAdditional Information:\n\n    The search space of possible SWAPs on physical qubits is explored\n    by assigning a score to the layout that would result from each SWAP.\n    The goodness of a layout is evaluated based on how viable it makes\n    the remaining virtual gates that must be applied. A few heuristic\n    cost functions are supported\n\n    - 'basic':\n\n    The sum of distances for corresponding physical qubits of\n    interacting virtual qubits in the front_layer.\n\n    .. math::\n\n        H_{basic} = \\sum_{gate \\in F} D[\\pi(gate.q_1)][\\pi(gate.q2)]\n\n    - 'lookahead':\n\n    This is the sum of two costs: first is the same as the basic cost.\n    Second is the basic cost but now evaluated for the\n    extended set as well (i.e. :math:`|E|` number of upcoming successors to gates in\n    front_layer F). This is weighted by some amount EXTENDED_SET_WEIGHT (W) to\n    signify that upcoming gates are less important that the front_layer.\n\n    .. math::\n\n        H_{decay}=\\frac{1}{\\left|{F}\\right|}\\sum_{gate \\in F} D[\\pi(gate.q_1)][\\pi(gate.q2)]\n            + W*\\frac{1}{\\left|{E}\\right|} \\sum_{gate \\in E} D[\\pi(gate.q_1)][\\pi(gate.q2)]\n\n    - 'decay':\n\n    This is the same as 'lookahead', but the whole cost is multiplied by a\n    decay factor. This increases the cost if the SWAP that generated the\n    trial layout was recently used (i.e. it penalizes increase in depth).\n\n    .. math::\n\n        H_{decay} = max(decay(SWAP.q_1), decay(SWAP.q_2)) {\n            \\frac{1}{\\left|{F}\\right|} \\sum_{gate \\in F} D[\\pi(gate.q_1)][\\pi(gate.q2)]\\\\\n            + W *\\frac{1}{\\left|{E}\\right|} \\sum_{gate \\in E} D[\\pi(gate.q_1)][\\pi(gate.q2)]\n            }",
        "api_signature": "__init__(self, coupling_map, heuristic, seed, fake_run, trials)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/sabre_swap.py"
    },
    {
        "api_name": "run",
        "full_api_name": "SabreSwap.run",
        "api_description": "Run the SabreSwap pass on `dag`.\n\nArgs:\n    dag (DAGCircuit): the directed acyclic graph to be mapped.\nReturns:\n    DAGCircuit: A dag mapped to be compatible with the coupling_map.\nRaises:\n    TranspilerError: if the coupling map or the layout are not\n    compatible with the DAG, or if the coupling_map=None",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/sabre_swap.py"
    },
    {
        "api_name": "_build_sabre_dag",
        "full_api_name": "_build_sabre_dag",
        "api_description": "",
        "api_signature": "_build_sabre_dag(dag, num_physical_qubits, qubit_indices)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/sabre_swap.py"
    },
    {
        "api_name": "recurse",
        "full_api_name": "recurse",
        "api_description": "",
        "api_signature": "recurse(block, block_qubit_indices)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/sabre_swap.py"
    },
    {
        "api_name": "process_dag",
        "full_api_name": "process_dag",
        "api_description": "",
        "api_signature": "process_dag(block_dag, wire_map)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/sabre_swap.py"
    },
    {
        "api_name": "_apply_sabre_result",
        "full_api_name": "_apply_sabre_result",
        "api_description": "Apply the ``SabreResult`` to ``out_dag``, mutating it in place.  This function in effect\nperforms the :class:`.ApplyLayout` transpiler pass with ``initial_layout`` and the Sabre routing\nsimultaneously, though it assumes that ``out_dag`` has already been prepared as containing the\nright physical qubits.\n\nMutates ``out_dag`` in place and returns it.  Mutates ``initial_layout`` in place as scratch\nspace.\n\nArgs:\n    out_dag (DAGCircuit): the physical DAG that the output should be written to.\n    in_dag (DAGCircuit): the source of the nodes that are being routed.\n    sabre_result (tuple[SwapMap, Sequence[int], NodeBlockResults]): the result object from the\n        Rust run of the Sabre routing algorithm.\n    initial_layout (NLayout): a Rust-space mapping of virtual indices (i.e. those of the qubits\n        in ``in_dag``) to physical ones.\n    physical_qubits (list[Qubit]): an indexable sequence of :class:`.circuit.Qubit` objects\n        representing the physical qubits of the circuit.  Note that disjoint-coupling\n        handling can mean that these are not strictly a \"canonical physical register\" in order.\n    circuit_to_dag_dict (Mapping[int, DAGCircuit]): a mapping of the Python object identity\n        (as returned by :func:`id`) of a control-flow block :class:`.QuantumCircuit` to a\n        :class:`.DAGCircuit` that represents the same thing.",
        "api_signature": "_apply_sabre_result(out_dag, in_dag, sabre_result, initial_layout, physical_qubits, circuit_to_dag_dict)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/sabre_swap.py"
    },
    {
        "api_name": "empty_dag",
        "full_api_name": "empty_dag",
        "api_description": "",
        "api_signature": "empty_dag(block)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/sabre_swap.py"
    },
    {
        "api_name": "apply_swaps",
        "full_api_name": "apply_swaps",
        "api_description": "",
        "api_signature": "apply_swaps(dest_dag, swaps, layout)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/sabre_swap.py"
    },
    {
        "api_name": "recurse",
        "full_api_name": "recurse",
        "api_description": "The main recursive worker.  Mutates ``dest_dag`` and ``layout`` and returns them.\n\n``root_virtual_map`` is a mapping of the (virtual) qubit in ``source_dag`` to the index of\nthe virtual qubit in the root source DAG that it is bound to.",
        "api_signature": "recurse(dest_dag, source_dag, result, root_logical_map, layout)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/sabre_swap.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "LayoutTransformation.__init__",
        "api_description": "LayoutTransformation initializer.\n\nArgs:\n    coupling_map:\n        Directed graph representing a coupling map.\n\n    from_layout (Union[Layout, str]):\n        The starting layout of qubits onto physical qubits.\n        If the type is str, look up `property_set` when this pass runs.\n\n    to_layout (Union[Layout, str]):\n        The final layout of qubits on physical qubits.\n        If the type is str, look up ``property_set`` when this pass runs.\n\n    seed (Union[int, np.random.default_rng]):\n        Seed to use for random trials.\n\n    trials (int):\n        How many randomized trials to perform, taking the best circuit as output.",
        "api_signature": "__init__(self, coupling_map, from_layout, to_layout, seed, trials)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/layout_transformation.py"
    },
    {
        "api_name": "run",
        "full_api_name": "LayoutTransformation.run",
        "api_description": "Apply the specified partial permutation to the circuit.\n\nArgs:\n    dag (DAGCircuit): DAG to transform the layout of.\n\nReturns:\n    DAGCircuit: The DAG with transformed layout.\n\nRaises:\n    TranspilerError: if the coupling map or the layout are not compatible with the DAG.\n        Or if either of string from/to_layout is not found in `property_set`.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/layout_transformation.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BasicSwap.__init__",
        "api_description": "BasicSwap initializer.\n\nArgs:\n    coupling_map (Union[CouplingMap, Target]): Directed graph represented a coupling map.\n    fake_run (bool): if true, it will only pretend to do routing, i.e., no\n        swap is effectively added.",
        "api_signature": "__init__(self, coupling_map, fake_run)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/basic_swap.py"
    },
    {
        "api_name": "run",
        "full_api_name": "BasicSwap.run",
        "api_description": "Run the BasicSwap pass on `dag`.\n\nArgs:\n    dag (DAGCircuit): DAG to map.\n\nReturns:\n    DAGCircuit: A mapped DAG.\n\nRaises:\n    TranspilerError: if the coupling map or the layout are not\n    compatible with the DAG, or if the ``coupling_map=None``.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/basic_swap.py"
    },
    {
        "api_name": "_fake_run",
        "full_api_name": "BasicSwap._fake_run",
        "api_description": "Do a fake run the BasicSwap pass on `dag`.\n\nArgs:\n    dag (DAGCircuit): DAG to improve initial layout.\n\nReturns:\n    DAGCircuit: The same DAG.\n\nRaises:\n    TranspilerError: if the coupling map or the layout are not\n    compatible with the DAG.",
        "api_signature": "_fake_run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/basic_swap.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "StochasticSwap.__init__",
        "api_description": "StochasticSwap initializer.\n\nThe coupling map is a connected graph\n\nIf these are not satisfied, the behavior is undefined.\n\nArgs:\n    coupling_map (Union[CouplingMap, Target]): Directed graph representing a coupling\n        map.\n    trials (int): maximum number of iterations to attempt\n    seed (int): seed for random number generator\n    fake_run (bool): if true, it will only pretend to do routing, i.e., no\n        swap is effectively added.\n    initial_layout (Layout): starting layout at beginning of pass.",
        "api_signature": "__init__(self, coupling_map, trials, seed, fake_run, initial_layout)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/stochastic_swap.py"
    },
    {
        "api_name": "run",
        "full_api_name": "StochasticSwap.run",
        "api_description": "Run the StochasticSwap pass on `dag`.\n\nArgs:\n    dag (DAGCircuit): DAG to map.\n\nReturns:\n    DAGCircuit: A mapped DAG.\n\nRaises:\n    TranspilerError: if the coupling map or the layout are not\n    compatible with the DAG, or if the coupling_map=None",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/stochastic_swap.py"
    },
    {
        "api_name": "_layer_permutation",
        "full_api_name": "StochasticSwap._layer_permutation",
        "api_description": "Find a swap circuit that implements a permutation for this layer.\n\nThe goal is to swap qubits such that qubits in the same two-qubit gates\nare adjacent.\n\nBased on S. Bravyi's algorithm.\n\nArgs:\n    layer_partition (list): The layer_partition is a list of (qu)bit\n        lists and each qubit is a tuple (qreg, index).\n    layout (Layout): The layout is a Layout object mapping virtual\n        qubits in the input circuit to physical qubits in the coupling\n        graph. It reflects the current positions of the data.\n    qubit_subset (list): The qubit_subset is the set of qubits in\n        the coupling graph that we have chosen to map into, as tuples\n        (Register, index).\n    coupling (CouplingMap): Directed graph representing a coupling map.\n        This coupling map should be one that was provided to the\n        stochastic mapper.\n    trials (int): Number of attempts the randomized algorithm makes.\n\nReturns:\n    Tuple: success_flag, best_circuit, best_depth, best_layout\n\nIf success_flag is True, then best_circuit contains a DAGCircuit with\nthe swap circuit, best_depth contains the depth of the swap circuit,\nand best_layout contains the new positions of the data qubits after the\nswap circuit has been applied.\n\nRaises:\n    TranspilerError: if anything went wrong.",
        "api_signature": "_layer_permutation(self, dag, layer_partition, layout, qubit_subset, coupling, trials)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/stochastic_swap.py"
    },
    {
        "api_name": "_layer_update",
        "full_api_name": "StochasticSwap._layer_update",
        "api_description": "Add swaps followed by the now mapped layer from the original circuit.\n\nArgs:\n    dag (DAGCircuit): The DAGCircuit object that the _mapper method is building\n    layer (DAGCircuit): A DAGCircuit layer from the original circuit\n    best_layout (Layout): layout returned from _layer_permutation\n    best_depth (int): depth returned from _layer_permutation\n    best_circuit (DAGCircuit): swap circuit returned from _layer_permutation",
        "api_signature": "_layer_update(self, dag, layer, best_layout, best_depth, best_circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/stochastic_swap.py"
    },
    {
        "api_name": "_mapper",
        "full_api_name": "StochasticSwap._mapper",
        "api_description": "Map a DAGCircuit onto a CouplingMap using swap gates.\n\nArgs:\n    circuit_graph (DAGCircuit): input DAG circuit\n    coupling_graph (CouplingMap): coupling graph to map onto\n    trials (int): number of trials.\n\nReturns:\n    DAGCircuit: object containing a circuit equivalent to\n        circuit_graph that respects couplings in coupling_graph\n\nRaises:\n    TranspilerError: if there was any error during the mapping\n        or with the parameters.",
        "api_signature": "_mapper(self, circuit_graph, coupling_graph, trials)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/stochastic_swap.py"
    },
    {
        "api_name": "_controlflow_layer_update",
        "full_api_name": "StochasticSwap._controlflow_layer_update",
        "api_description": "Updates the new dagcircuit with a routed control flow operation.\n\nArgs:\n   dagcircuit_output (DAGCircuit): dagcircuit that is being built with routed operations.\n   layer_dag (DAGCircuit): layer to route containing a single controlflow operation.\n   current_layout (Layout): current layout coming into this layer.\n   root_dag (DAGCircuit): root dag of pass\n\nReturns:\n   Layout: updated layout after this layer has been routed.\n\nRaises:\n    TranspilerError: if layer_dag does not contain a recognized ControlFlowOp.",
        "api_signature": "_controlflow_layer_update(self, dagcircuit_output, layer_dag, current_layout, root_dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/stochastic_swap.py"
    },
    {
        "api_name": "_new_seed",
        "full_api_name": "StochasticSwap._new_seed",
        "api_description": "Get a seed for a new RNG instance.",
        "api_signature": "_new_seed(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/stochastic_swap.py"
    },
    {
        "api_name": "_recursive_pass",
        "full_api_name": "StochasticSwap._recursive_pass",
        "api_description": "Get a new instance of this class to handle a recursive call for a control-flow block.\n\nEach pass starts with its own new seed, determined deterministically from our own.",
        "api_signature": "_recursive_pass(self, initial_layout)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/stochastic_swap.py"
    },
    {
        "api_name": "_controlflow_exhaustive_acyclic",
        "full_api_name": "_controlflow_exhaustive_acyclic",
        "api_description": "Return True if the entire control-flow operation represents a block that is guaranteed to be\nentered, and does not cycle back to the initial layout.",
        "api_signature": "_controlflow_exhaustive_acyclic(operation)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/stochastic_swap.py"
    },
    {
        "api_name": "_dag_from_block",
        "full_api_name": "_dag_from_block",
        "api_description": "Get a :class:`DAGCircuit` that represents the :class:`.QuantumCircuit` ``block`` embedded\nwithin the ``root_dag`` for full-width routing purposes.  This means that all the qubits are in\nthe output DAG, but only the necessary clbits and classical registers are.",
        "api_signature": "_dag_from_block(block, node, root_dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/stochastic_swap.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Commuting2qGateRouter.__init__",
        "api_description": "Args:\n    swap_strategy: An instance of a :class:`.SwapStrategy` that holds the swap layers\n        that are used, and the order in which to apply them, to map the instruction to\n        the hardware. If this field is not given, it should be contained in the\n        property set of the pass. This allows other passes to determine the most\n        appropriate swap strategy at run-time.\n    edge_coloring: An optional edge coloring of the coupling map (I.e. no two edges that\n        share a node have the same color). If the edge coloring is given then the commuting\n        gates that can be simultaneously applied given the current qubit permutation are\n        grouped according to the edge coloring and applied according to this edge\n        coloring. Here, a color is an int which is used as the index to define and\n        access the groups of commuting gates that can be applied simultaneously.\n        If the edge coloring is not given then the sets will be built-up using a\n        greedy algorithm. The edge coloring is useful to position gates such as\n        ``RZZGate``\\s next to swap gates to exploit CX cancellations.",
        "api_signature": "__init__(self, swap_strategy, edge_coloring)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/commuting_2q_gate_routing/commuting_2q_gate_router.py"
    },
    {
        "api_name": "run",
        "full_api_name": "Commuting2qGateRouter.run",
        "api_description": "Run the pass by decomposing the nodes it applies on.\n\nArgs:\n    dag: The dag to which we will add swaps.\n\nReturns:\n    A dag where swaps have been added for the intended gate type.\n\nRaises:\n    TranspilerError: If the swap strategy was not given at init time and there is\n        no swap strategy in the property set.\n    TranspilerError: If the quantum circuit contains more than one qubit register.\n    TranspilerError: If there are qubits that are not contained in the quantum register.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/commuting_2q_gate_routing/commuting_2q_gate_router.py"
    },
    {
        "api_name": "_compose_non_swap_nodes",
        "full_api_name": "Commuting2qGateRouter._compose_non_swap_nodes",
        "api_description": "Add all the non-swap strategy nodes that we have accumulated up to now.\n\nThis method also resets the node accumulator to an empty dag.\n\nArgs:\n    layout: The current layout that keeps track of the swaps.\n    new_dag: The new dag that we are building up.\n    accumulator: A DAG to keep track of nodes that do not decompose\n        using swap strategies.\n\nReturns:\n    A new accumulator with the same registers as ``new_dag``.",
        "api_signature": "_compose_non_swap_nodes(self, accumulator, layout, new_dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/commuting_2q_gate_routing/commuting_2q_gate_router.py"
    },
    {
        "api_name": "_position_in_cmap",
        "full_api_name": "Commuting2qGateRouter._position_in_cmap",
        "api_description": "A helper function to track the movement of virtual qubits through the swaps.\n\nArgs:\n    j: The index of decision variable j (i.e. virtual qubit).\n    k: The index of decision variable k (i.e. virtual qubit).\n    layout: The current layout that takes into account previous swap gates.\n\nReturns:\n    The position in the coupling map of the virtual qubits j and k as a tuple.",
        "api_signature": "_position_in_cmap(self, dag, j, k, layout)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/commuting_2q_gate_routing/commuting_2q_gate_router.py"
    },
    {
        "api_name": "_build_sub_layers",
        "full_api_name": "Commuting2qGateRouter._build_sub_layers",
        "api_description": "A helper method to build-up sets of gates to simultaneously apply.\n\nThis is done with an edge coloring if the ``edge_coloring`` init argument was given or with\na greedy algorithm if not. With an edge coloring all gates on edges with the same color\nwill be applied simultaneously. These sublayers are applied in the order of their color,\nwhich is an int, in increasing color order.\n\nArgs:\n    current_layer: All gates in the current layer can be applied given the qubit ordering\n        of the current layout. However, not all gates in the current layer can be applied\n        simultaneously. This function creates sub-layers by building up sub-layers\n        of gates. All gates in a sub-layer can simultaneously be applied given the coupling\n        map and current qubit configuration.\n\nReturns:\n     A list of gate dicts that can be applied. The gates a position 0 are applied first.\n     A gate dict has the qubit tuple as key and the gate to apply as value.",
        "api_signature": "_build_sub_layers(self, current_layer)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/commuting_2q_gate_routing/commuting_2q_gate_router.py"
    },
    {
        "api_name": "_edge_coloring_build_sub_layers",
        "full_api_name": "Commuting2qGateRouter._edge_coloring_build_sub_layers",
        "api_description": "The edge coloring method of building sub-layers of commuting gates.",
        "api_signature": "_edge_coloring_build_sub_layers(self, current_layer)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/commuting_2q_gate_routing/commuting_2q_gate_router.py"
    },
    {
        "api_name": "_greedy_build_sub_layers",
        "full_api_name": "Commuting2qGateRouter._greedy_build_sub_layers",
        "api_description": "The greedy method of building sub-layers of commuting gates.",
        "api_signature": "_greedy_build_sub_layers(current_layer)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/commuting_2q_gate_routing/commuting_2q_gate_router.py"
    },
    {
        "api_name": "swap_decompose",
        "full_api_name": "Commuting2qGateRouter.swap_decompose",
        "api_description": "Take an instance of :class:`.Commuting2qBlock` and map it to the coupling map.\n\nThe mapping is done with the swap strategy.\n\nArgs:\n    dag: The dag which contains the :class:`.Commuting2qBlock` we route.\n    node: A node whose operation is a :class:`.Commuting2qBlock`.\n    current_layout: The layout before the swaps are applied. This function will\n        modify the layout so that subsequent gates can be properly composed on the dag.\n    swap_strategy: The swap strategy used to decompose the node.\n\nReturns:\n    A dag that is compatible with the coupling map where swap gates have been added\n    to map the gates in the :class:`.Commuting2qBlock` to the hardware.",
        "api_signature": "swap_decompose(self, dag, node, current_layout, swap_strategy)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/commuting_2q_gate_routing/commuting_2q_gate_router.py"
    },
    {
        "api_name": "_make_op_layers",
        "full_api_name": "Commuting2qGateRouter._make_op_layers",
        "api_description": "Creates layers of two-qubit gates based on the distance in the swap strategy.",
        "api_signature": "_make_op_layers(self, dag, op, layout, swap_strategy)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/commuting_2q_gate_routing/commuting_2q_gate_router.py"
    },
    {
        "api_name": "_check_edges",
        "full_api_name": "Commuting2qGateRouter._check_edges",
        "api_description": "Check if the swap strategy can create the required connectivity.\n\nArgs:\n    node: The dag node for which to check if the swap strategy provides enough connectivity.\n    swap_strategy: The swap strategy that is being used.\n\nRaises:\n    TranspilerError: If there is an edge that the swap strategy cannot accommodate\n        and if the pass has been configured to raise on such issues.",
        "api_signature": "_check_edges(self, dag, node, swap_strategy)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/commuting_2q_gate_routing/commuting_2q_gate_router.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Commuting2qBlock.__init__",
        "api_description": "Args:\n    node_block: A block of nodes that commute.\n\nRaises:\n    QiskitError: If the nodes in the node block do not apply to two-qubits.",
        "api_signature": "__init__(self, node_block)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/commuting_2q_gate_routing/commuting_2q_block.py"
    },
    {
        "api_name": "__iter__",
        "full_api_name": "Commuting2qBlock.__iter__",
        "api_description": "Iterate through the nodes in the block.",
        "api_signature": "__iter__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/commuting_2q_gate_routing/commuting_2q_block.py"
    },
    {
        "api_name": "run",
        "full_api_name": "FindCommutingPauliEvolutions.run",
        "api_description": "Check for :class:`.PauliEvolutionGate`s where the summands all commute.\n\nArgs:\n    The DAG circuit in which to look for the commuting evolutions.\n\nReturns:\n    The dag in which :class:`.PauliEvolutionGate`s made of commuting two-qubit Paulis\n    have been replaced with :class:`.Commuting2qBlocks`` gate instructions. These gates\n    contain nodes of two-qubit :class:`.PauliEvolutionGate`s.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/commuting_2q_gate_routing/pauli_2q_evolution_commutation.py"
    },
    {
        "api_name": "single_qubit_terms_only",
        "full_api_name": "FindCommutingPauliEvolutions.single_qubit_terms_only",
        "api_description": "Determine if the Paulis are made of single qubit terms only.\n\nArgs:\n    operator: The operator to check if it consists only of single qubit terms.\n\nReturns:\n    True if the operator consists of only single qubit terms (like ``IIX + IZI``),\n    and False otherwise.",
        "api_signature": "single_qubit_terms_only(operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/commuting_2q_gate_routing/pauli_2q_evolution_commutation.py"
    },
    {
        "api_name": "summands_commute",
        "full_api_name": "FindCommutingPauliEvolutions.summands_commute",
        "api_description": "Check if all summands in the evolved operator commute.\n\nArgs:\n    operator: The operator to check if all its summands commute.\n\nReturns:\n    True if all summands commute, False otherwise.",
        "api_signature": "summands_commute(operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/commuting_2q_gate_routing/pauli_2q_evolution_commutation.py"
    },
    {
        "api_name": "_pauli_to_edge",
        "full_api_name": "FindCommutingPauliEvolutions._pauli_to_edge",
        "api_description": "Convert a pauli to an edge.\n\nArgs:\n    pauli: A pauli that is converted to a string to find out where non-identity\n        Paulis are.\n\nReturns:\n    A tuple representing where the Paulis are. For example, the Pauli \"IZIZ\" will\n    return (0, 2) since virtual qubits 0 and 2 interact.\n\nRaises:\n    QiskitError: If the pauli does not exactly have two non-identity terms.",
        "api_signature": "_pauli_to_edge(pauli)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/commuting_2q_gate_routing/pauli_2q_evolution_commutation.py"
    },
    {
        "api_name": "_decompose_to_2q",
        "full_api_name": "FindCommutingPauliEvolutions._decompose_to_2q",
        "api_description": "Decompose the SparsePauliOp into two-qubit.\n\nArgs:\n    dag: The dag needed to get access to qubits.\n    op: The operator with all the Pauli terms we need to apply.\n\nReturns:\n    A dag made of two-qubit :class:`.PauliEvolutionGate`.",
        "api_signature": "_decompose_to_2q(self, dag, op)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/commuting_2q_gate_routing/pauli_2q_evolution_commutation.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SwapStrategy.__init__",
        "api_description": "Args:\n    coupling_map: The coupling map the strategy is implemented for.\n    swap_layers: The swap layers of the strategy, specified as tuple of swap layers.\n        Each swap layer is a tuple of edges to which swaps are applied simultaneously.\n        Each swap is specified as an edge which is a tuple of two integers.\n\nRaises:\n    QiskitError: If the coupling map is not specified.\n    QiskitError: if the swap strategy is not valid. A swap strategy is valid if all\n        swap gates, specified as tuples, are contained in the edge set of the coupling map.\n        A swap strategy is also invalid if a layer has multiple swaps on the same qubit.",
        "api_signature": "__init__(self, coupling_map, swap_layers)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/commuting_2q_gate_routing/swap_strategy.py"
    },
    {
        "api_name": "from_line",
        "full_api_name": "SwapStrategy.from_line",
        "api_description": "Creates a swap strategy for a line graph with the specified number of SWAP layers.\n\nThis SWAP strategy will use the full line if instructed to do so (i.e. num_variables\nis None or equal to num_vertices). If instructed otherwise then the first num_variables\nnodes of the line will be used in the swap strategy.\n\nArgs:\n    line: A line given as a list of nodes, e.g. ``[0, 2, 3, 4]``.\n    num_swap_layers: Number of swap layers the swap manager should be initialized with.\n\nReturns:\n    A swap strategy that reaches full connectivity on a linear coupling map.\n\nRaises:\n    ValueError: If the ``num_swap_layers`` is negative.\n    ValueError: If the ``line`` has less than 2 elements and no swap strategy can be applied.",
        "api_signature": "from_line(cls, line, num_swap_layers)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/commuting_2q_gate_routing/swap_strategy.py"
    },
    {
        "api_name": "__len__",
        "full_api_name": "SwapStrategy.__len__",
        "api_description": "Return the length of the strategy as the number of layers.\n\nReturns:\n    The number of layers of the swap strategy.",
        "api_signature": "__len__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/commuting_2q_gate_routing/swap_strategy.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "SwapStrategy.__repr__",
        "api_description": "Representation of the swap strategy.\n\nReturns:\n    The representation of the swap strategy.",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/commuting_2q_gate_routing/swap_strategy.py"
    },
    {
        "api_name": "swap_layer",
        "full_api_name": "SwapStrategy.swap_layer",
        "api_description": "Return the layer of swaps at the given index.\n\nArgs:\n    idx: The index of the returned swap layer.\n\nReturns:\n    A copy of the swap layer at ``idx`` to avoid any unintentional modification to\n    the swap strategy.",
        "api_signature": "swap_layer(self, idx)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/commuting_2q_gate_routing/swap_strategy.py"
    },
    {
        "api_name": "distance_matrix",
        "full_api_name": "SwapStrategy.distance_matrix",
        "api_description": "A matrix describing when qubits become adjacent in the swap strategy.\n\nReturns:\n    The distance matrix for the SWAP strategy as an array that cannot be written to. Here,\n    the entry (i, j) corresponds to the number of SWAP layers that need to be applied to\n    obtain a connection between physical qubits i and j.",
        "api_signature": "distance_matrix(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/commuting_2q_gate_routing/swap_strategy.py"
    },
    {
        "api_name": "new_connections",
        "full_api_name": "SwapStrategy.new_connections",
        "api_description": "Returns the new connections obtained after applying the SWAP layer specified by idx, i.e.\na list of qubit pairs that are adjacent to one another after idx steps of the SWAP strategy.\n\nArgs:\n    idx: The index of the SWAP layer. 1 refers to the first SWAP layer whereas an ``idx``\n        of 0 will return the connections present in the original coupling map.\n\nReturns:\n    A list of edges representing the new qubit connections.",
        "api_signature": "new_connections(self, idx)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/commuting_2q_gate_routing/swap_strategy.py"
    },
    {
        "api_name": "_build_edges",
        "full_api_name": "SwapStrategy._build_edges",
        "api_description": "Build the possible edges that the swap strategy accommodates.",
        "api_signature": "_build_edges(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/commuting_2q_gate_routing/swap_strategy.py"
    },
    {
        "api_name": "possible_edges",
        "full_api_name": "SwapStrategy.possible_edges",
        "api_description": "Return the qubit connections that can be generated.\n\nReturns:\n    The qubit connections that can be accommodated by the swap strategy.",
        "api_signature": "possible_edges(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/commuting_2q_gate_routing/swap_strategy.py"
    },
    {
        "api_name": "missing_couplings",
        "full_api_name": "SwapStrategy.missing_couplings",
        "api_description": "Return the set of couplings that cannot be reached.\n\nReturns:\n    The couplings that cannot be reached as a set of Tuples of int. Here,\n    each int corresponds to a qubit in the coupling map.",
        "api_signature": "missing_couplings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/commuting_2q_gate_routing/swap_strategy.py"
    },
    {
        "api_name": "swapped_coupling_map",
        "full_api_name": "SwapStrategy.swapped_coupling_map",
        "api_description": "Returns the coupling map after applying ``idx`` swap layers of strategy.\n\nArgs:\n    idx: The number of swap layers to apply. For idx = 0, the original coupling\n        map is returned.\n\nReturns:\n    The swapped coupling map.",
        "api_signature": "swapped_coupling_map(self, idx)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/commuting_2q_gate_routing/swap_strategy.py"
    },
    {
        "api_name": "apply_swap_layer",
        "full_api_name": "SwapStrategy.apply_swap_layer",
        "api_description": "Permute the elements of ``list_to_swap`` based on layer indexed by ``idx``.\n\nArgs:\n    list_to_swap: The list of elements to swap.\n    idx: The index of the swap layer to apply.\n    inplace: A boolean which if set to True will modify the list inplace. By default\n        this value is False.\n\nReturns:\n    The list with swapped elements",
        "api_signature": "apply_swap_layer(self, list_to_swap, idx, inplace)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/commuting_2q_gate_routing/swap_strategy.py"
    },
    {
        "api_name": "inverse_composed_permutation",
        "full_api_name": "SwapStrategy.inverse_composed_permutation",
        "api_description": "Returns the inversed composed permutation of all swap layers applied up to layer\n``idx``. Permutations are represented by list of integers where the ith element\ncorresponds to the mapping of i under the permutation.\n\nArgs:\n    idx: The number of swap layers to apply.\n\nReturns:\n    The inversed permutation as a list of integer values.",
        "api_signature": "inverse_composed_permutation(self, idx)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/commuting_2q_gate_routing/swap_strategy.py"
    },
    {
        "api_name": "swap_permutation",
        "full_api_name": "swap_permutation",
        "api_description": "Given a circuit of swaps, apply them to the permutation (in-place).\n\nArgs:\n  swaps: param mapping: A mapping of Keys to Values, where the Keys are being swapped.\n  mapping: The permutation to have swaps applied to.\n  allow_missing_keys: Whether to allow swaps of missing keys in mapping.",
        "api_signature": "swap_permutation(swaps, mapping, allow_missing_keys)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/algorithms/util.py"
    },
    {
        "api_name": "permutation_circuit",
        "full_api_name": "permutation_circuit",
        "api_description": "Produce a circuit description of a list of swaps.\n    With a given permutation and permuter you can compute the swaps using the permuter function\n    then feed it into this circuit function to obtain a circuit description.\nArgs:\n  swaps: An iterable of swaps to perform.\nReturns:\n  A MappingCircuit with the circuit and a mapping of node to qubit in the circuit.",
        "api_signature": "permutation_circuit(swaps)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/algorithms/util.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ApproximateTokenSwapper.__init__",
        "api_description": "Construct an ApproximateTokenSwapping object.\n\nArgs:\n    graph: Undirected graph represented a coupling map.\n    seed: Seed to use for random trials.",
        "api_signature": "__init__(self, graph, seed)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/algorithms/token_swapper.py"
    },
    {
        "api_name": "distance",
        "full_api_name": "ApproximateTokenSwapper.distance",
        "api_description": "Compute the distance between two nodes in `graph`.",
        "api_signature": "distance(self, vertex0, vertex1)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/algorithms/token_swapper.py"
    },
    {
        "api_name": "permutation_circuit",
        "full_api_name": "ApproximateTokenSwapper.permutation_circuit",
        "api_description": "Perform an approximately optimal Token Swapping algorithm to implement the permutation.\n\nArgs:\n  permutation: The partial mapping to implement in swaps.\n  trials: The number of trials to try to perform the mapping. Minimize over the trials.\n\nReturns:\n  The circuit to implement the permutation",
        "api_signature": "permutation_circuit(self, permutation, trials)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/algorithms/token_swapper.py"
    },
    {
        "api_name": "map",
        "full_api_name": "ApproximateTokenSwapper.map",
        "api_description": "Perform an approximately optimal Token Swapping algorithm to implement the permutation.\n\nSupports partial mappings (i.e. not-permutations) for graphs with missing tokens.\n\nBased on the paper: Approximation and Hardness for Token Swapping by Miltzow et al. (2016)\nArXiV: https://arxiv.org/abs/1602.05150\nand generalization based on our own work.\n\nArgs:\n  mapping: The partial mapping to implement in swaps.\n  trials: The number of trials to try to perform the mapping. Minimize over the trials.\n  parallel_threshold: The number of nodes in the graph beyond which the algorithm\n        will use parallel processing\n\nReturns:\n  The swaps to implement the mapping",
        "api_signature": "map(self, mapping, trials, parallel_threshold)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/routing/algorithms/token_swapper.py"
    },
    {
        "api_name": "run",
        "full_api_name": "LinearFunctionsToPermutations.run",
        "api_description": "Run the LinearFunctionsToPermutations pass on `dag`.\nArgs:\n    dag: input dag.\nReturns:\n    Output dag with LinearFunctions synthesized.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/linear_functions_synthesis.py"
    },
    {
        "api_name": "_choose_kak_gate",
        "full_api_name": "_choose_kak_gate",
        "api_description": "Choose the first available 2q gate to use in the KAK decomposition.",
        "api_signature": "_choose_kak_gate(basis_gates)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/unitary_synthesis.py"
    },
    {
        "api_name": "_choose_euler_basis",
        "full_api_name": "_choose_euler_basis",
        "api_description": "Choose the first available 1q basis to use in the Euler decomposition.",
        "api_signature": "_choose_euler_basis(basis_gates)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/unitary_synthesis.py"
    },
    {
        "api_name": "_find_matching_euler_bases",
        "full_api_name": "_find_matching_euler_bases",
        "api_description": "Find matching available 1q basis to use in the Euler decomposition.",
        "api_signature": "_find_matching_euler_bases(target, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/unitary_synthesis.py"
    },
    {
        "api_name": "_choose_bases",
        "full_api_name": "_choose_bases",
        "api_description": "Find the matching basis string keys from the list of basis gates from the backend.",
        "api_signature": "_choose_bases(basis_gates, basis_dict)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/unitary_synthesis.py"
    },
    {
        "api_name": "_decomposer_2q_from_basis_gates",
        "full_api_name": "_decomposer_2q_from_basis_gates",
        "api_description": "",
        "api_signature": "_decomposer_2q_from_basis_gates(basis_gates, pulse_optimize, approximation_degree)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/unitary_synthesis.py"
    },
    {
        "api_name": "_error",
        "full_api_name": "_error",
        "api_description": "Calculate a rough error for a `circuit` that runs on specific\n`qubits` of `target`.\n\nUse basis errors from target if available, otherwise use length\nof circuit as a weak proxy for error.",
        "api_signature": "_error(circuit, target, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/unitary_synthesis.py"
    },
    {
        "api_name": "score_instruction",
        "full_api_name": "score_instruction",
        "api_description": "",
        "api_signature": "score_instruction(inst, inst_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/unitary_synthesis.py"
    },
    {
        "api_name": "_preferred_direction",
        "full_api_name": "_preferred_direction",
        "api_description": "`decomposer2q` decomposes an SU(4) over `qubits`. A user sets `natural_direction`\nto indicate whether they prefer synthesis in a hardware-native direction.\nIf yes, we return the `preferred_direction` here. If no hardware direction is\npreferred, we raise an error (unless natural_direction is None).\nWe infer this from `coupling_map`, `gate_lengths`, `gate_errors`.\n\nReturns [0, 1] if qubits are correct in the hardware-native direction.\nReturns [1, 0] if qubits must be flipped to match hardware-native direction.",
        "api_signature": "_preferred_direction(decomposer2q, qubits, natural_direction, coupling_map, gate_lengths, gate_errors)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/unitary_synthesis.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "UnitarySynthesis.__init__",
        "api_description": "Synthesize unitaries over some basis gates.\n\nThis pass can approximate 2-qubit unitaries given some\ngate fidelities (either via ``backend_props`` or ``target``).\nMore approximation can be forced by setting a heuristic dial\n``approximation_degree``.\n\nArgs:\n    basis_gates (list[str]): List of gate names to target. If this is\n        not specified the ``target`` argument must be used. If both this\n        and the ``target`` are specified the value of ``target`` will\n        be used and this will be ignored.\n    approximation_degree (float): heuristic dial used for circuit approximation\n        (1.0=no approximation, 0.0=maximal approximation). Approximation can\n        make the synthesized circuit cheaper at the cost of straying from\n        the original unitary. If None, approximation is done based on gate fidelities.\n    coupling_map (CouplingMap): the coupling map of the backend\n        in case synthesis is done on a physical circuit. The\n        directionality of the coupling_map will be taken into\n        account if ``pulse_optimize`` is ``True``/``None`` and ``natural_direction``\n        is ``True``/``None``.\n    backend_props (BackendProperties): Properties of a backend to\n        synthesize for (e.g. gate fidelities).\n    pulse_optimize (bool): Whether to optimize pulses during\n        synthesis. A value of ``None`` will attempt it but fall\n        back if it does not succeed. A value of ``True`` will raise\n        an error if pulse-optimized synthesis does not succeed.\n    natural_direction (bool): Whether to apply synthesis considering\n        directionality of 2-qubit gates. Only applies when\n        ``pulse_optimize`` is ``True`` or ``None``. The natural direction is\n        determined by first checking to see whether the\n        coupling map is unidirectional.  If there is no\n        coupling map or the coupling map is bidirectional,\n        the gate direction with the shorter\n        duration from the backend properties will be used. If\n        set to True, and a natural direction can not be\n        determined, raises :class:`.TranspilerError`. If set to None, no\n        exception will be raised if a natural direction can\n        not be determined.\n    synth_gates (list[str]): List of gates to synthesize. If None and\n        ``pulse_optimize`` is False or None, default to\n        ``['unitary']``. If ``None`` and ``pulse_optimize == True``,\n        default to ``['unitary', 'swap']``\n    method (str): The unitary synthesis method plugin to use.\n    min_qubits: The minimum number of qubits in the unitary to synthesize. If this is set\n        and the unitary is less than the specified number of qubits it will not be\n        synthesized.\n    plugin_config: Optional extra configuration arguments (as a ``dict``)\n        which are passed directly to the specified unitary synthesis\n        plugin. By default, this will have no effect as the default\n        plugin has no extra arguments. Refer to the documentation of\n        your unitary synthesis plugin on how to use this.\n    target: The optional :class:`~.Target` for the target device the pass\n        is compiling for. If specified this will supersede the values\n        set for ``basis_gates``, ``coupling_map``, and ``backend_props``.\n\nRaises:\n    TranspilerError: if ``method`` was specified but is not found in the\n        installed plugins list. The list of installed plugins can be queried with\n        :func:`~qiskit.transpiler.passes.synthesis.plugin.unitary_synthesis_plugin_names`",
        "api_signature": "__init__(self, basis_gates, approximation_degree, coupling_map, backend_props, pulse_optimize, natural_direction, synth_gates, method, min_qubits, plugin_config, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/unitary_synthesis.py"
    },
    {
        "api_name": "run",
        "full_api_name": "UnitarySynthesis.run",
        "api_description": "Run the UnitarySynthesis pass on ``dag``.\n\nArgs:\n    dag: input dag.\n\nReturns:\n    Output dag with UnitaryGates synthesized to target basis.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/unitary_synthesis.py"
    },
    {
        "api_name": "_run_main_loop",
        "full_api_name": "UnitarySynthesis._run_main_loop",
        "api_description": "Inner loop for the optimizer, after all DAG-independent set-up has been completed.",
        "api_signature": "_run_main_loop(self, dag, qubit_indices, plugin_method, plugin_kwargs, default_method, default_kwargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/unitary_synthesis.py"
    },
    {
        "api_name": "_build_gate_lengths",
        "full_api_name": "_build_gate_lengths",
        "api_description": "Builds a ``gate_lengths`` dictionary from either ``props`` (BackendV1)\nor ``target`` (BackendV2).\n\nThe dictionary has the form:\n{gate_name: {(qubits,): duration}}",
        "api_signature": "_build_gate_lengths(props, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/unitary_synthesis.py"
    },
    {
        "api_name": "_build_gate_errors",
        "full_api_name": "_build_gate_errors",
        "api_description": "Builds a ``gate_error`` dictionary from either ``props`` (BackendV1)\nor ``target`` (BackendV2).\n\nThe dictionary has the form:\n{gate_name: {(qubits,): error_rate}}",
        "api_signature": "_build_gate_errors(props, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/unitary_synthesis.py"
    },
    {
        "api_name": "_build_gate_lengths_by_qubit",
        "full_api_name": "_build_gate_lengths_by_qubit",
        "api_description": "Builds a `gate_lengths` dictionary from either `props` (BackendV1)\nor `target (BackendV2)`.\n\nThe dictionary has the form:\n{(qubits): [Gate, duration]}",
        "api_signature": "_build_gate_lengths_by_qubit(props, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/unitary_synthesis.py"
    },
    {
        "api_name": "_build_gate_errors_by_qubit",
        "full_api_name": "_build_gate_errors_by_qubit",
        "api_description": "Builds a `gate_error` dictionary from either `props` (BackendV1)\nor `target (BackendV2)`.\n\nThe dictionary has the form:\n{(qubits): [Gate, error]}",
        "api_signature": "_build_gate_errors_by_qubit(props, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/unitary_synthesis.py"
    },
    {
        "api_name": "supports_basis_gates",
        "full_api_name": "DefaultUnitarySynthesis.supports_basis_gates",
        "api_description": "",
        "api_signature": "supports_basis_gates(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/unitary_synthesis.py"
    },
    {
        "api_name": "supports_coupling_map",
        "full_api_name": "DefaultUnitarySynthesis.supports_coupling_map",
        "api_description": "",
        "api_signature": "supports_coupling_map(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/unitary_synthesis.py"
    },
    {
        "api_name": "supports_natural_direction",
        "full_api_name": "DefaultUnitarySynthesis.supports_natural_direction",
        "api_description": "",
        "api_signature": "supports_natural_direction(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/unitary_synthesis.py"
    },
    {
        "api_name": "supports_pulse_optimize",
        "full_api_name": "DefaultUnitarySynthesis.supports_pulse_optimize",
        "api_description": "",
        "api_signature": "supports_pulse_optimize(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/unitary_synthesis.py"
    },
    {
        "api_name": "supports_gate_lengths",
        "full_api_name": "DefaultUnitarySynthesis.supports_gate_lengths",
        "api_description": "",
        "api_signature": "supports_gate_lengths(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/unitary_synthesis.py"
    },
    {
        "api_name": "supports_gate_errors",
        "full_api_name": "DefaultUnitarySynthesis.supports_gate_errors",
        "api_description": "",
        "api_signature": "supports_gate_errors(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/unitary_synthesis.py"
    },
    {
        "api_name": "supports_gate_lengths_by_qubit",
        "full_api_name": "DefaultUnitarySynthesis.supports_gate_lengths_by_qubit",
        "api_description": "",
        "api_signature": "supports_gate_lengths_by_qubit(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/unitary_synthesis.py"
    },
    {
        "api_name": "supports_gate_errors_by_qubit",
        "full_api_name": "DefaultUnitarySynthesis.supports_gate_errors_by_qubit",
        "api_description": "",
        "api_signature": "supports_gate_errors_by_qubit(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/unitary_synthesis.py"
    },
    {
        "api_name": "max_qubits",
        "full_api_name": "DefaultUnitarySynthesis.max_qubits",
        "api_description": "",
        "api_signature": "max_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/unitary_synthesis.py"
    },
    {
        "api_name": "min_qubits",
        "full_api_name": "DefaultUnitarySynthesis.min_qubits",
        "api_description": "",
        "api_signature": "min_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/unitary_synthesis.py"
    },
    {
        "api_name": "supported_bases",
        "full_api_name": "DefaultUnitarySynthesis.supported_bases",
        "api_description": "",
        "api_signature": "supported_bases(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/unitary_synthesis.py"
    },
    {
        "api_name": "supports_target",
        "full_api_name": "DefaultUnitarySynthesis.supports_target",
        "api_description": "",
        "api_signature": "supports_target(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/unitary_synthesis.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "DefaultUnitarySynthesis.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/unitary_synthesis.py"
    },
    {
        "api_name": "_decomposer_2q_from_target",
        "full_api_name": "DefaultUnitarySynthesis._decomposer_2q_from_target",
        "api_description": "",
        "api_signature": "_decomposer_2q_from_target(self, target, qubits, approximation_degree)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/unitary_synthesis.py"
    },
    {
        "api_name": "_replace_parameterized_gate",
        "full_api_name": "DefaultUnitarySynthesis._replace_parameterized_gate",
        "api_description": "",
        "api_signature": "_replace_parameterized_gate(op)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/unitary_synthesis.py"
    },
    {
        "api_name": "is_supercontrolled",
        "full_api_name": "DefaultUnitarySynthesis.is_supercontrolled",
        "api_description": "",
        "api_signature": "is_supercontrolled(gate)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/unitary_synthesis.py"
    },
    {
        "api_name": "is_controlled",
        "full_api_name": "DefaultUnitarySynthesis.is_controlled",
        "api_description": "",
        "api_signature": "is_controlled(gate)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/unitary_synthesis.py"
    },
    {
        "api_name": "run",
        "full_api_name": "DefaultUnitarySynthesis.run",
        "api_description": "",
        "api_signature": "run(self, unitary)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/unitary_synthesis.py"
    },
    {
        "api_name": "_synth_su4_no_dag",
        "full_api_name": "DefaultUnitarySynthesis._synth_su4_no_dag",
        "api_description": "",
        "api_signature": "_synth_su4_no_dag(self, unitary, decomposer2q, preferred_direction, approximation_degree)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/unitary_synthesis.py"
    },
    {
        "api_name": "_synth_su4",
        "full_api_name": "DefaultUnitarySynthesis._synth_su4",
        "api_description": "",
        "api_signature": "_synth_su4(self, su4_mat, decomposer2q, preferred_direction, approximation_degree)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/unitary_synthesis.py"
    },
    {
        "api_name": "_reversed_synth_su4",
        "full_api_name": "DefaultUnitarySynthesis._reversed_synth_su4",
        "api_description": "",
        "api_signature": "_reversed_synth_su4(self, su4_mat, decomposer2q, approximation_degree)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/unitary_synthesis.py"
    },
    {
        "api_name": "max_qubits",
        "full_api_name": "UnitarySynthesisPlugin.max_qubits",
        "api_description": "Return the maximum number of qubits the unitary synthesis plugin supports.\n\nIf the size of the unitary to be synthesized exceeds this value the\n``default`` plugin will be used. If there is no upper bound return\n``None`` and all unitaries (``>= min_qubits`` if it's defined) will be\npassed to this plugin when it's enabled.",
        "api_signature": "max_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/plugin.py"
    },
    {
        "api_name": "min_qubits",
        "full_api_name": "UnitarySynthesisPlugin.min_qubits",
        "api_description": "Return the minimum number of qubits the unitary synthesis plugin supports.\n\nIf the size of the unitary to be synthesized is below this value the\n``default`` plugin will be used. If there is no lower bound return\n``None`` and all unitaries (``<= max_qubits`` if it's defined) will be\npassed to this plugin when it's enabled.",
        "api_signature": "min_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/plugin.py"
    },
    {
        "api_name": "supports_basis_gates",
        "full_api_name": "UnitarySynthesisPlugin.supports_basis_gates",
        "api_description": "Return whether the plugin supports taking ``basis_gates``\n\nIf this returns ``True`` the plugin's ``run()`` method will be\npassed a ``basis_gates`` kwarg with a list of gate names the target\nbackend supports. For example, ``['sx', 'x', 'cx', 'id', 'rz']``.",
        "api_signature": "supports_basis_gates(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/plugin.py"
    },
    {
        "api_name": "supports_coupling_map",
        "full_api_name": "UnitarySynthesisPlugin.supports_coupling_map",
        "api_description": "Return whether the plugin supports taking ``coupling_map``\n\nIf this returns ``True`` the plugin's ``run()`` method will receive\none kwarg ``coupling_map``. The ``coupling_map`` kwarg will be set to a\ntuple with the first element being a\n:class:`~qiskit.transpiler.CouplingMap` object representing the qubit\nconnectivity of the target backend, the second element will be a list\nof integers that represent the qubit indices in the coupling map that\nunitary is on. Note that if the target backend doesn't have a coupling\nmap set, the ``coupling_map`` kwarg's value will be ``(None, qubit_indices)``.",
        "api_signature": "supports_coupling_map(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/plugin.py"
    },
    {
        "api_name": "supports_natural_direction",
        "full_api_name": "UnitarySynthesisPlugin.supports_natural_direction",
        "api_description": "Return whether the plugin supports a toggle for considering\ndirectionality of 2-qubit gates as ``natural_direction``.\n\nRefer to the documentation for :class:`~qiskit.transpiler.passes.UnitarySynthesis`\nfor the possible values and meaning of these values.",
        "api_signature": "supports_natural_direction(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/plugin.py"
    },
    {
        "api_name": "supports_pulse_optimize",
        "full_api_name": "UnitarySynthesisPlugin.supports_pulse_optimize",
        "api_description": "Return whether the plugin supports a toggle to optimize pulses\nduring synthesis as ``pulse_optimize``.\n\nRefer to the documentation for :class:`~qiskit.transpiler.passes.UnitarySynthesis`\nfor the possible values and meaning of these values.",
        "api_signature": "supports_pulse_optimize(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/plugin.py"
    },
    {
        "api_name": "supports_gate_lengths_by_qubit",
        "full_api_name": "UnitarySynthesisPlugin.supports_gate_lengths_by_qubit",
        "api_description": "Return whether the plugin supports taking ``gate_lengths_by_qubit``\n\nThis differs from ``supports_gate_lengths``/``gate_lengths`` by using a different\nview of the same data. Instead of being keyed by gate name this is keyed by qubit\nand uses :class:`~.Gate` instances to represent gates (instead of gate names)\n\n``gate_lengths_by_qubit`` will be a dictionary in the form of\n``{(qubits,): [Gate, length]}``. For example::\n\n    {\n    (0,): [SXGate(): 0.0006149355812506126, RZGate(): 0.0],\n    (0, 1): [CXGate(): 0.012012477900732316]\n    }\n\nwhere the ``length`` value is in units of seconds.\n\nDo note that this dictionary might not be complete or could be empty\nas it depends on the target backend reporting gate lengths on every\ngate for each qubit.\n\nThis defaults to False",
        "api_signature": "supports_gate_lengths_by_qubit(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/plugin.py"
    },
    {
        "api_name": "supports_gate_errors_by_qubit",
        "full_api_name": "UnitarySynthesisPlugin.supports_gate_errors_by_qubit",
        "api_description": "Return whether the plugin supports taking ``gate_errors_by_qubit``\n\nThis differs from ``supports_gate_errors``/``gate_errors`` by using a different\nview of the same data. Instead of being keyed by gate name this is keyed by qubit\nand uses :class:`~.Gate` instances to represent gates (instead of gate names).\n\n``gate_errors_by_qubit`` will be a dictionary in the form of\n``{(qubits,): [Gate, error]}``. For example::\n\n    {\n    (0,): [SXGate(): 0.0006149355812506126, RZGate(): 0.0],\n    (0, 1): [CXGate(): 0.012012477900732316]\n    }\n\nDo note that this dictionary might not be complete or could be empty\nas it depends on the target backend reporting gate errors on every\ngate for each qubit. The gate error rates reported in ``gate_errors``\nare provided by the target device ``Backend`` object and the exact\nmeaning might be different depending on the backend.\n\nThis defaults to False",
        "api_signature": "supports_gate_errors_by_qubit(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/plugin.py"
    },
    {
        "api_name": "supports_gate_lengths",
        "full_api_name": "UnitarySynthesisPlugin.supports_gate_lengths",
        "api_description": "Return whether the plugin supports taking ``gate_lengths``\n\n``gate_lengths`` will be a dictionary in the form of\n``{gate_name: {(qubit_1, qubit_2): length}}``. For example::\n\n    {\n    'sx': {(0,): 0.0006149355812506126, (1,): 0.0006149355812506126},\n    'cx': {(0, 1): 0.012012477900732316, (1, 0): 5.191111111111111e-07}\n    }\n\nwhere the ``length`` value is in units of seconds.\n\nDo note that this dictionary might not be complete or could be empty\nas it depends on the target backend reporting gate lengths on every\ngate for each qubit.",
        "api_signature": "supports_gate_lengths(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/plugin.py"
    },
    {
        "api_name": "supports_gate_errors",
        "full_api_name": "UnitarySynthesisPlugin.supports_gate_errors",
        "api_description": "Return whether the plugin supports taking ``gate_errors``\n\n``gate_errors`` will be a dictionary in the form of\n``{gate_name: {(qubit_1, qubit_2): error}}``. For example::\n\n    {\n    'sx': {(0,): 0.0006149355812506126, (1,): 0.0006149355812506126},\n    'cx': {(0, 1): 0.012012477900732316, (1, 0): 5.191111111111111e-07}\n    }\n\nDo note that this dictionary might not be complete or could be empty\nas it depends on the target backend reporting gate errors on every\ngate for each qubit. The gate error rates reported in ``gate_errors``\nare provided by the target device ``Backend`` object and the exact\nmeaning might be different depending on the backend.",
        "api_signature": "supports_gate_errors(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/plugin.py"
    },
    {
        "api_name": "supported_bases",
        "full_api_name": "UnitarySynthesisPlugin.supported_bases",
        "api_description": "Returns a dictionary of supported bases for synthesis\n\nThis is expected to return a dictionary where the key is a string\nbasis and the value is a list of gate names that the basis works in.\nIf the synthesis method doesn't support multiple bases this should\nreturn ``None``. For example::\n\n    {\n        \"XZX\": [\"rz\", \"rx\"],\n        \"XYX\": [\"rx\", \"ry\"],\n    }\n\nIf a dictionary is returned by this method the run kwargs will be\npassed a parameter ``matched_basis`` which contains a list of the\nbasis strings (i.e. keys in the dictionary) which match the target basis\ngate set for the transpilation. If no entry in the dictionary matches\nthe target basis gate set then the ``matched_basis`` kwarg will be set\nto an empty list, and a plugin can choose how to deal with the target\nbasis gate set not matching the plugin's capabilities.",
        "api_signature": "supported_bases(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/plugin.py"
    },
    {
        "api_name": "supports_target",
        "full_api_name": "UnitarySynthesisPlugin.supports_target",
        "api_description": "Whether the plugin supports taking ``target`` as an option\n\n``target`` will be a :class:`~.Target` object representing the target\ndevice for the output of the synthesis pass.\n\nBy default this will be ``False`` since the plugin interface predates\nthe :class:`~.Target` class. If a plugin returns ``True`` for this\nattribute, it is expected that the plugin will use the\n:class:`~.Target` instead of the values passed if any of\n``supports_gate_lengths``, ``supports_gate_errors``,\n``supports_coupling_map``, and ``supports_basis_gates`` are set\n(although ideally all those parameters should contain duplicate\ninformation).",
        "api_signature": "supports_target(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/plugin.py"
    },
    {
        "api_name": "run",
        "full_api_name": "UnitarySynthesisPlugin.run",
        "api_description": "Run synthesis for the given unitary matrix\n\nArgs:\n    unitary (numpy.ndarray): The unitary matrix to synthesize to a\n        :class:`~qiskit.dagcircuit.DAGCircuit` object\n    options: The optional kwargs that are passed based on the output\n        the ``support_*`` methods on the class. Refer to the\n        documentation for these methods on\n        :class:`~qiskit.transpiler.passes.synthesis.plugin.UnitarySynthesisPlugin`\n        to see what the keys and values are.\n\nReturns:\n    DAGCircuit: The dag circuit representation of the unitary. Alternatively, you can return\n    a tuple of the form ``(dag, wires)`` where ``dag`` is the dag circuit representation of\n    the circuit representation of the unitary and ``wires`` is the mapping wires to use for\n    :meth:`qiskit.dagcircuit.DAGCircuit.substitute_node_with_dag`. If you return a tuple\n    and ``wires`` is ``None`` this will behave just as if only a\n    :class:`~qiskit.dagcircuit.DAGCircuit` was returned. Additionally if this returns\n    ``None`` no substitution will be made.",
        "api_signature": "run(self, unitary)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/plugin.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "UnitarySynthesisPluginManager.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/plugin.py"
    },
    {
        "api_name": "unitary_synthesis_plugin_names",
        "full_api_name": "unitary_synthesis_plugin_names",
        "api_description": "Return a list of installed unitary synthesis plugin names\n\nReturns:\n    list: A list of the installed unitary synthesis plugin names. The plugin names are valid\n    values for the :func:`~qiskit.compiler.transpile` kwarg ``unitary_synthesis_method``.",
        "api_signature": "unitary_synthesis_plugin_names()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/plugin.py"
    },
    {
        "api_name": "run",
        "full_api_name": "HighLevelSynthesisPlugin.run",
        "api_description": "Run synthesis for the given Operation.\n\nArgs:\n    high_level_object (Operation): The Operation to synthesize to a\n        :class:`~qiskit.dagcircuit.DAGCircuit` object.\n    coupling_map (CouplingMap): The coupling map of the backend\n        in case synthesis is done on a physical circuit.\n    target (Target): A target representing the target backend.\n    qubits (list): List of qubits over which the operation is defined\n        in case synthesis is done on a physical circuit.\n    options: Additional method-specific optional kwargs.\n\nReturns:\n    QuantumCircuit: The quantum circuit representation of the Operation\n        when successful, and ``None`` otherwise.",
        "api_signature": "run(self, high_level_object, coupling_map, target, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/plugin.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "HighLevelSynthesisPluginManager.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/plugin.py"
    },
    {
        "api_name": "method_names",
        "full_api_name": "HighLevelSynthesisPluginManager.method_names",
        "api_description": "Returns plugin methods for op_name.",
        "api_signature": "method_names(self, op_name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/plugin.py"
    },
    {
        "api_name": "method",
        "full_api_name": "HighLevelSynthesisPluginManager.method",
        "api_description": "Returns the plugin for ``op_name`` and ``method_name``.",
        "api_signature": "method(self, op_name, method_name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/plugin.py"
    },
    {
        "api_name": "high_level_synthesis_plugin_names",
        "full_api_name": "high_level_synthesis_plugin_names",
        "api_description": "Return a list of plugin names installed for a given high level object name\n\nArgs:\n    op_name: The operation name to find the installed plugins for. For example,\n        if you provide ``\"clifford\"`` as the input it will find all the installed\n        clifford synthesis plugins that can synthesize :class:`.Clifford` objects.\n        The name refers to the :attr:`.Operation.name` attribute of the relevant objects.\n\nReturns:\n    A list of installed plugin names for the specified high level operation",
        "api_signature": "high_level_synthesis_plugin_names(op_name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/plugin.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SolovayKitaev.__init__",
        "api_description": "Args:\n    recursion_degree: The recursion depth for the Solovay-Kitaev algorithm.\n        A larger recursion depth increases the accuracy and length of the\n        decomposition.\n    basic_approximations: The basic approximations for the finding the best discrete\n        decomposition at the root of the recursion. If a string, it specifies the ``.npy``\n        file to load the approximations from. If a dictionary, it contains\n        ``{label: SO(3)-matrix}`` pairs. If None, a default based on the H, T and Tdg gates\n        up to combinations of depth 10 is generated.",
        "api_signature": "__init__(self, recursion_degree, basic_approximations)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/solovay_kitaev_synthesis.py"
    },
    {
        "api_name": "run",
        "full_api_name": "SolovayKitaev.run",
        "api_description": "Run the ``SolovayKitaev`` pass on `dag`.\n\nArgs:\n    dag: The input dag.\n\nReturns:\n    Output dag with 1q gates synthesized in the discrete target basis.\n\nRaises:\n    TranspilerError: if a gates does not have to_matrix",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/solovay_kitaev_synthesis.py"
    },
    {
        "api_name": "max_qubits",
        "full_api_name": "SolovayKitaevSynthesis.max_qubits",
        "api_description": "Maximum number of supported qubits is ``1``.",
        "api_signature": "max_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/solovay_kitaev_synthesis.py"
    },
    {
        "api_name": "min_qubits",
        "full_api_name": "SolovayKitaevSynthesis.min_qubits",
        "api_description": "Minimum number of supported qubits is ``1``.",
        "api_signature": "min_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/solovay_kitaev_synthesis.py"
    },
    {
        "api_name": "supports_natural_direction",
        "full_api_name": "SolovayKitaevSynthesis.supports_natural_direction",
        "api_description": "The plugin does not support natural direction, it does not assume\nbidirectional two qubit gates.",
        "api_signature": "supports_natural_direction(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/solovay_kitaev_synthesis.py"
    },
    {
        "api_name": "supports_pulse_optimize",
        "full_api_name": "SolovayKitaevSynthesis.supports_pulse_optimize",
        "api_description": "The plugin does not support optimization of pulses.",
        "api_signature": "supports_pulse_optimize(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/solovay_kitaev_synthesis.py"
    },
    {
        "api_name": "supports_gate_lengths",
        "full_api_name": "SolovayKitaevSynthesis.supports_gate_lengths",
        "api_description": "The plugin does not support gate lengths.",
        "api_signature": "supports_gate_lengths(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/solovay_kitaev_synthesis.py"
    },
    {
        "api_name": "supports_gate_errors",
        "full_api_name": "SolovayKitaevSynthesis.supports_gate_errors",
        "api_description": "The plugin does not support gate errors.",
        "api_signature": "supports_gate_errors(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/solovay_kitaev_synthesis.py"
    },
    {
        "api_name": "supported_bases",
        "full_api_name": "SolovayKitaevSynthesis.supported_bases",
        "api_description": "The plugin does not support bases for synthesis.",
        "api_signature": "supported_bases(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/solovay_kitaev_synthesis.py"
    },
    {
        "api_name": "supports_basis_gates",
        "full_api_name": "SolovayKitaevSynthesis.supports_basis_gates",
        "api_description": "The plugin does not support basis gates. By default it synthesis to the\n``[\"h\", \"t\", \"tdg\"]`` gate basis.",
        "api_signature": "supports_basis_gates(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/solovay_kitaev_synthesis.py"
    },
    {
        "api_name": "supports_coupling_map",
        "full_api_name": "SolovayKitaevSynthesis.supports_coupling_map",
        "api_description": "The plugin does not support coupling maps.",
        "api_signature": "supports_coupling_map(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/solovay_kitaev_synthesis.py"
    },
    {
        "api_name": "run",
        "full_api_name": "SolovayKitaevSynthesis.run",
        "api_description": "",
        "api_signature": "run(self, unitary)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/solovay_kitaev_synthesis.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "HLSConfig.__init__",
        "api_description": "Creates a high-level-synthesis config.\n\nArgs:\n    use_default_on_unspecified: if True, every higher-level-object without an\n        explicitly specified list of methods will be synthesized using the \"default\"\n        algorithm if it exists.\n    plugin_selection: if set to ``\"sequential\"`` (default), for every higher-level-object\n        the synthesis pass will consider the specified methods sequentially, stopping\n        at the first method that is able to synthesize the object. If set to ``\"all\"``,\n        all the specified methods will be considered, and the best synthesized circuit,\n        according to ``plugin_evaluation_fn`` will be chosen.\n    plugin_evaluation_fn: a callable that evaluates the quality of the synthesized\n        quantum circuit; a smaller value means a better circuit. If ``None``, the\n        quality of the circuit its size (i.e. the number of gates that it contains).\n    kwargs: a dictionary mapping higher-level-objects to lists of synthesis methods.",
        "api_signature": "__init__(self, use_default_on_unspecified, plugin_selection, plugin_evaluation_fn)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/high_level_synthesis.py"
    },
    {
        "api_name": "set_methods",
        "full_api_name": "HLSConfig.set_methods",
        "api_description": "Sets the list of synthesis methods for a given higher-level-object. This overwrites\nthe lists of methods if also set previously.",
        "api_signature": "set_methods(self, hls_name, hls_methods)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/high_level_synthesis.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "HighLevelSynthesis.__init__",
        "api_description": "HighLevelSynthesis initializer.\n\nArgs:\n    hls_config: Optional, the high-level-synthesis config that specifies synthesis methods\n        and parameters for various high-level-objects in the circuit. If it is not specified,\n        the default synthesis methods and parameters will be used.\n    coupling_map: Optional, directed graph represented as a coupling map.\n    target: Optional, the backend target to use for this pass. If it is specified,\n        it will be used instead of the coupling map.\n    use_qubit_indices: a flag indicating whether this synthesis pass is running before or after\n        the layout is set, that is, whether the qubit indices of higher-level-objects correspond\n        to qubit indices on the target backend.\n    equivalence_library: The equivalence library used (instructions in this library will not\n        be unrolled by this pass).\n    basis_gates: Optional, target basis names to unroll to, e.g. `['u3', 'cx']`.\n        Ignored if ``target`` is also specified.\n    min_qubits: The minimum number of qubits for operations in the input\n        dag to translate.",
        "api_signature": "__init__(self, hls_config, coupling_map, target, use_qubit_indices, equivalence_library, basis_gates, min_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/high_level_synthesis.py"
    },
    {
        "api_name": "run",
        "full_api_name": "HighLevelSynthesis.run",
        "api_description": "Run the HighLevelSynthesis pass on `dag`.\n\nArgs:\n    dag: input dag.\n\nReturns:\n    Output dag with higher-level operations synthesized.\n\nRaises:\n    TranspilerError: when the transpiler is unable to synthesize the given DAG\n    (for instance, when the specified synthesis method is not available).",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/high_level_synthesis.py"
    },
    {
        "api_name": "_definitely_skip_node",
        "full_api_name": "HighLevelSynthesis._definitely_skip_node",
        "api_description": "Fast-path determination of whether a node can certainly be skipped (i.e. nothing will\nattempt to synthesise it) without accessing its Python-space `Operation`.\n\nThis is tightly coupled to `_recursively_handle_op`; it exists as a temporary measure to\navoid Python-space `Operation` creation from a `DAGOpNode` if we wouldn't do anything to the\nnode (which is _most_ nodes).",
        "api_signature": "_definitely_skip_node(self, node, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/high_level_synthesis.py"
    },
    {
        "api_name": "_instruction_supported",
        "full_api_name": "HighLevelSynthesis._instruction_supported",
        "api_description": "",
        "api_signature": "_instruction_supported(self, name, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/high_level_synthesis.py"
    },
    {
        "api_name": "_recursively_handle_op",
        "full_api_name": "HighLevelSynthesis._recursively_handle_op",
        "api_description": "Recursively synthesizes a single operation.\n\nNote: the reason that this function accepts an operation and not a dag node\nis that it's also used for synthesizing the base operation for an annotated\ngate (i.e. no dag node is available).\n\nThere are several possible results:\n\n- The given operation is unchanged: e.g., it is supported by the target or is\n  in the equivalence library\n- The result is a quantum circuit: e.g., synthesizing Clifford using plugin\n- The result is a DAGCircuit: e.g., when unrolling custom gates\n- The result is an Operation: e.g., adding control to CXGate results in CCXGate\n- The given operation could not be synthesized, raising a transpiler error\n\nThe function returns the result of the synthesis (either a quantum circuit or\nan Operation), and, as an optimization, a boolean indicating whether\nsynthesis did anything.\n\nThe function is recursive, for example synthesizing an annotated operation\ninvolves synthesizing its \"base operation\" which might also be\nan annotated operation.",
        "api_signature": "_recursively_handle_op(self, op, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/high_level_synthesis.py"
    },
    {
        "api_name": "_methods_to_try",
        "full_api_name": "HighLevelSynthesis._methods_to_try",
        "api_description": "Get a sequence of methods to try for a given op name.",
        "api_signature": "_methods_to_try(self, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/high_level_synthesis.py"
    },
    {
        "api_name": "_synthesize_op_using_plugins",
        "full_api_name": "HighLevelSynthesis._synthesize_op_using_plugins",
        "api_description": "Attempts to synthesize op using plugin mechanism.\nReturns either the synthesized circuit or None (which occurs when no\nsynthesis methods are available or specified).",
        "api_signature": "_synthesize_op_using_plugins(self, op, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/high_level_synthesis.py"
    },
    {
        "api_name": "_synthesize_annotated_op",
        "full_api_name": "HighLevelSynthesis._synthesize_annotated_op",
        "api_description": "Recursively synthesizes annotated operations.\nReturns either the synthesized operation or None (which occurs when the operation\nis not an annotated operation).",
        "api_signature": "_synthesize_annotated_op(self, op)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/high_level_synthesis.py"
    },
    {
        "api_name": "run",
        "full_api_name": "DefaultSynthesisClifford.run",
        "api_description": "Run synthesis for the given Clifford.",
        "api_signature": "run(self, high_level_object, coupling_map, target, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/high_level_synthesis.py"
    },
    {
        "api_name": "run",
        "full_api_name": "AGSynthesisClifford.run",
        "api_description": "Run synthesis for the given Clifford.",
        "api_signature": "run(self, high_level_object, coupling_map, target, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/high_level_synthesis.py"
    },
    {
        "api_name": "run",
        "full_api_name": "BMSynthesisClifford.run",
        "api_description": "Run synthesis for the given Clifford.",
        "api_signature": "run(self, high_level_object, coupling_map, target, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/high_level_synthesis.py"
    },
    {
        "api_name": "run",
        "full_api_name": "GreedySynthesisClifford.run",
        "api_description": "Run synthesis for the given Clifford.",
        "api_signature": "run(self, high_level_object, coupling_map, target, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/high_level_synthesis.py"
    },
    {
        "api_name": "run",
        "full_api_name": "LayerSynthesisClifford.run",
        "api_description": "Run synthesis for the given Clifford.",
        "api_signature": "run(self, high_level_object, coupling_map, target, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/high_level_synthesis.py"
    },
    {
        "api_name": "run",
        "full_api_name": "LayerLnnSynthesisClifford.run",
        "api_description": "Run synthesis for the given Clifford.",
        "api_signature": "run(self, high_level_object, coupling_map, target, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/high_level_synthesis.py"
    },
    {
        "api_name": "run",
        "full_api_name": "DefaultSynthesisLinearFunction.run",
        "api_description": "Run synthesis for the given LinearFunction.",
        "api_signature": "run(self, high_level_object, coupling_map, target, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/high_level_synthesis.py"
    },
    {
        "api_name": "run",
        "full_api_name": "KMSSynthesisLinearFunction.run",
        "api_description": "Run synthesis for the given LinearFunction.",
        "api_signature": "run(self, high_level_object, coupling_map, target, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/high_level_synthesis.py"
    },
    {
        "api_name": "run",
        "full_api_name": "PMHSynthesisLinearFunction.run",
        "api_description": "Run synthesis for the given LinearFunction.",
        "api_signature": "run(self, high_level_object, coupling_map, target, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/high_level_synthesis.py"
    },
    {
        "api_name": "run",
        "full_api_name": "KMSSynthesisPermutation.run",
        "api_description": "Run synthesis for the given Permutation.",
        "api_signature": "run(self, high_level_object, coupling_map, target, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/high_level_synthesis.py"
    },
    {
        "api_name": "run",
        "full_api_name": "BasicSynthesisPermutation.run",
        "api_description": "Run synthesis for the given Permutation.",
        "api_signature": "run(self, high_level_object, coupling_map, target, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/high_level_synthesis.py"
    },
    {
        "api_name": "run",
        "full_api_name": "ACGSynthesisPermutation.run",
        "api_description": "Run synthesis for the given Permutation.",
        "api_signature": "run(self, high_level_object, coupling_map, target, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/high_level_synthesis.py"
    },
    {
        "api_name": "run",
        "full_api_name": "QFTSynthesisFull.run",
        "api_description": "Run synthesis for the given QFTGate.",
        "api_signature": "run(self, high_level_object, coupling_map, target, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/high_level_synthesis.py"
    },
    {
        "api_name": "run",
        "full_api_name": "QFTSynthesisLine.run",
        "api_description": "Run synthesis for the given QFTGate.",
        "api_signature": "run(self, high_level_object, coupling_map, target, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/high_level_synthesis.py"
    },
    {
        "api_name": "run",
        "full_api_name": "TokenSwapperSynthesisPermutation.run",
        "api_description": "Run synthesis for the given Permutation.",
        "api_signature": "run(self, high_level_object, coupling_map, target, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/high_level_synthesis.py"
    },
    {
        "api_name": "max_qubits",
        "full_api_name": "AQCSynthesisPlugin.max_qubits",
        "api_description": "Maximum number of supported qubits is ``14``.",
        "api_signature": "max_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/aqc_plugin.py"
    },
    {
        "api_name": "min_qubits",
        "full_api_name": "AQCSynthesisPlugin.min_qubits",
        "api_description": "Minimum number of supported qubits is ``3``.",
        "api_signature": "min_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/aqc_plugin.py"
    },
    {
        "api_name": "supports_natural_direction",
        "full_api_name": "AQCSynthesisPlugin.supports_natural_direction",
        "api_description": "The plugin does not support natural direction,\nit assumes bidirectional two qubit gates.",
        "api_signature": "supports_natural_direction(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/aqc_plugin.py"
    },
    {
        "api_name": "supports_pulse_optimize",
        "full_api_name": "AQCSynthesisPlugin.supports_pulse_optimize",
        "api_description": "The plugin does not support optimization of pulses.",
        "api_signature": "supports_pulse_optimize(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/aqc_plugin.py"
    },
    {
        "api_name": "supports_gate_lengths",
        "full_api_name": "AQCSynthesisPlugin.supports_gate_lengths",
        "api_description": "The plugin does not support gate lengths.",
        "api_signature": "supports_gate_lengths(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/aqc_plugin.py"
    },
    {
        "api_name": "supports_gate_errors",
        "full_api_name": "AQCSynthesisPlugin.supports_gate_errors",
        "api_description": "The plugin does not support gate errors.",
        "api_signature": "supports_gate_errors(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/aqc_plugin.py"
    },
    {
        "api_name": "supported_bases",
        "full_api_name": "AQCSynthesisPlugin.supported_bases",
        "api_description": "The plugin does not support bases for synthesis.",
        "api_signature": "supported_bases(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/aqc_plugin.py"
    },
    {
        "api_name": "supports_basis_gates",
        "full_api_name": "AQCSynthesisPlugin.supports_basis_gates",
        "api_description": "The plugin does not support basis gates and by default it synthesizes a circuit using\n``[\"rx\", \"ry\", \"rz\", \"cx\"]`` gate basis.",
        "api_signature": "supports_basis_gates(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/aqc_plugin.py"
    },
    {
        "api_name": "supports_coupling_map",
        "full_api_name": "AQCSynthesisPlugin.supports_coupling_map",
        "api_description": "The plugin does not support coupling maps.",
        "api_signature": "supports_coupling_map(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/aqc_plugin.py"
    },
    {
        "api_name": "run",
        "full_api_name": "AQCSynthesisPlugin.run",
        "api_description": "",
        "api_signature": "run(self, unitary)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/synthesis/aqc_plugin.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ASAPSchedule.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/asap.py"
    },
    {
        "api_name": "run",
        "full_api_name": "ASAPSchedule.run",
        "api_description": "Run the ASAPSchedule pass on `dag`.\n\nArgs:\n    dag (DAGCircuit): DAG to schedule.\n\nReturns:\n    DAGCircuit: A scheduled DAG.\n\nRaises:\n    TranspilerError: if the circuit is not mapped on physical qubits.\n    TranspilerError: if conditional bit is added to non-supported instruction.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/asap.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ALAPSchedule.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/alap.py"
    },
    {
        "api_name": "run",
        "full_api_name": "ALAPSchedule.run",
        "api_description": "Run the ALAPSchedule pass on `dag`.\n\nArgs:\n    dag (DAGCircuit): DAG to schedule.\n\nReturns:\n    DAGCircuit: A scheduled DAG.\n\nRaises:\n    TranspilerError: if the circuit is not mapped on physical qubits.\n    TranspilerError: if conditional bit is added to non-supported instruction.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/alap.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "DynamicalDecoupling.__init__",
        "api_description": "Dynamical decoupling initializer.\n\nArgs:\n    durations (InstructionDurations): Durations of instructions to be\n        used in scheduling.\n    dd_sequence (list[Gate]): sequence of gates to apply in idle spots.\n    qubits (list[int]): physical qubits on which to apply DD.\n        If None, all qubits will undergo DD (when possible).\n    spacing (list[float]): a list of spacings between the DD gates.\n        The available slack will be divided according to this.\n        The list length must be one more than the length of dd_sequence,\n        and the elements must sum to 1. If None, a balanced spacing\n        will be used [d/2, d, d, ..., d, d, d/2].\n    skip_reset_qubits (bool): if True, does not insert DD on idle\n        periods that immediately follow initialized/reset qubits (as\n        qubits in the ground state are less susceptible to decoherence).\n    target (Target): The :class:`~.Target` representing the target backend, if both\n          ``durations`` and this are specified then this argument will take\n          precedence and ``durations`` will be ignored.",
        "api_signature": "__init__(self, durations, dd_sequence, qubits, spacing, skip_reset_qubits, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/dynamical_decoupling.py"
    },
    {
        "api_name": "run",
        "full_api_name": "DynamicalDecoupling.run",
        "api_description": "Run the DynamicalDecoupling pass on dag.\n\nArgs:\n    dag (DAGCircuit): a scheduled DAG.\n\nReturns:\n    DAGCircuit: equivalent circuit with delays interrupted by DD,\n        where possible.\n\nRaises:\n    TranspilerError: if the circuit is not mapped on physical qubits.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/dynamical_decoupling.py"
    },
    {
        "api_name": "_update_inst_durations",
        "full_api_name": "DynamicalDecoupling._update_inst_durations",
        "api_description": "Update instruction durations with circuit information. If the dag contains gate\ncalibrations and no instruction durations were provided through the target or as a\nstandalone input, the circuit calibration durations will be used.\nThe priority order for instruction durations is: target > standalone > circuit.",
        "api_signature": "_update_inst_durations(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/dynamical_decoupling.py"
    },
    {
        "api_name": "__gate_supported",
        "full_api_name": "DynamicalDecoupling.__gate_supported",
        "api_description": "A gate is supported on the qubit (qarg) or not.",
        "api_signature": "__gate_supported(self, gate, qarg)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/dynamical_decoupling.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BaseSchedulerTransform.__init__",
        "api_description": "Scheduler initializer.\n\nArgs:\n    durations: Durations of instructions to be used in scheduling\n    clbit_write_latency: A control flow constraints. Because standard superconducting\n        quantum processor implement dispersive QND readout, the actual data transfer\n        to the clbit happens after the round-trip stimulus signal is buffered\n        and discriminated into quantum state.\n        The interval ``[t0, t0 + clbit_write_latency]`` is regarded as idle time\n        for clbits associated with the measure instruction.\n        This defaults to 0 dt which is identical to Qiskit Pulse scheduler.\n    conditional_latency: A control flow constraints. This value represents\n        a latency of reading a classical register for the conditional operation.\n        The gate operation occurs after this latency. This appears as a delay\n        in front of the DAGOpNode of the gate.\n        This defaults to 0 dt.\n    target: The :class:`~.Target` representing the target backend, if both\n        ``durations`` and this are specified then this argument will take\n        precedence and ``durations`` will be ignored.",
        "api_signature": "__init__(self, durations, clbit_write_latency, conditional_latency, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/base_scheduler.py"
    },
    {
        "api_name": "_get_node_duration",
        "full_api_name": "BaseSchedulerTransform._get_node_duration",
        "api_description": "A helper method to get duration from node or calibration.",
        "api_signature": "_get_node_duration(node, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/base_scheduler.py"
    },
    {
        "api_name": "_delay_supported",
        "full_api_name": "BaseSchedulerTransform._delay_supported",
        "api_description": "Delay operation is supported on the qubit (qarg) or not.",
        "api_signature": "_delay_supported(self, qarg)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/base_scheduler.py"
    },
    {
        "api_name": "run",
        "full_api_name": "BaseSchedulerTransform.run",
        "api_description": "",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/base_scheduler.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "TimeUnitConversion.__init__",
        "api_description": "TimeUnitAnalysis initializer.\n\nArgs:\n    inst_durations (InstructionDurations): A dictionary of durations of instructions.\n    target: The :class:`~.Target` representing the target backend, if both\n          ``inst_durations`` and ``target`` are specified then this argument will take\n          precedence and ``inst_durations`` will be ignored.",
        "api_signature": "__init__(self, inst_durations, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/time_unit_conversion.py"
    },
    {
        "api_name": "run",
        "full_api_name": "TimeUnitConversion.run",
        "api_description": "Run the TimeUnitAnalysis pass on `dag`.\n\nArgs:\n    dag (DAGCircuit): DAG to be checked.\n\nReturns:\n    DAGCircuit: DAG with consistent timing and op nodes annotated with duration.\n\nRaises:\n    TranspilerError: if the units are not unifiable",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/time_unit_conversion.py"
    },
    {
        "api_name": "_update_inst_durations",
        "full_api_name": "TimeUnitConversion._update_inst_durations",
        "api_description": "Update instruction durations with circuit information. If the dag contains gate\ncalibrations and no instruction durations were provided through the target or as a\nstandalone input, the circuit calibration durations will be used.\nThe priority order for instruction durations is: target > standalone > circuit.",
        "api_signature": "_update_inst_durations(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/time_unit_conversion.py"
    },
    {
        "api_name": "_units_used_in_delays",
        "full_api_name": "TimeUnitConversion._units_used_in_delays",
        "api_description": "",
        "api_signature": "_units_used_in_delays(dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/time_unit_conversion.py"
    },
    {
        "api_name": "_unified",
        "full_api_name": "TimeUnitConversion._unified",
        "api_description": "",
        "api_signature": "_unified(unit_set)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/time_unit_conversion.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "AlignMeasures.__init__",
        "api_description": "Create new pass.\n\nArgs:\n    alignment: Integer number representing the minimum time resolution to\n        trigger measure instruction in units of ``dt``. This value depends on\n        the control electronics of your quantum processor.",
        "api_signature": "__init__(self, alignment)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/alignments/align_measures.py"
    },
    {
        "api_name": "run",
        "full_api_name": "AlignMeasures.run",
        "api_description": "Run the measurement alignment pass on `dag`.\n\nArgs:\n    dag (DAGCircuit): DAG to be checked.\n\nReturns:\n    DAGCircuit: DAG with consistent timing and op nodes annotated with duration.\n\nRaises:\n    TranspilerError: If circuit is not scheduled.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/alignments/align_measures.py"
    },
    {
        "api_name": "pad_with_delays",
        "full_api_name": "AlignMeasures.pad_with_delays",
        "api_description": "Pad idle time-slots in ``qubits`` with delays in ``unit`` until ``until``.",
        "api_signature": "pad_with_delays(qubits, until, unit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/alignments/align_measures.py"
    },
    {
        "api_name": "_check_alignment_required",
        "full_api_name": "_check_alignment_required",
        "api_description": "Check DAG nodes and return a boolean representing if instruction scheduling is necessary.\n\nArgs:\n    dag: DAG circuit to check.\n    alignment: Instruction alignment condition.\n    instructions: Target instructions.\n\nReturns:\n    If instruction scheduling is necessary.",
        "api_signature": "_check_alignment_required(dag, alignment, instructions)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/alignments/align_measures.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ValidatePulseGates.__init__",
        "api_description": "Create new pass.\n\nArgs:\n    granularity: Integer number representing the minimum time resolution to\n        define the pulse gate length in units of ``dt``. This value depends on\n        the control electronics of your quantum processor.\n    min_length: Integer number representing the minimum data point length to\n        define the pulse gate in units of ``dt``. This value depends on\n        the control electronics of your quantum processor.\n    target: The :class:`~.Target` representing the target backend, if\n        ``target`` is specified then this argument will take\n        precedence and ``granularity`` and ``min_length`` will be ignored.",
        "api_signature": "__init__(self, granularity, min_length, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/alignments/pulse_gate_validation.py"
    },
    {
        "api_name": "run",
        "full_api_name": "ValidatePulseGates.run",
        "api_description": "Run the pulse gate validation attached to ``dag``.\n\nArgs:\n    dag: DAG to be validated.\n\nReturns:\n    DAGCircuit: DAG with consistent timing and op nodes annotated with duration.\n\nRaises:\n    TranspilerError: When pulse gate violate pulse controller constraints.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/alignments/pulse_gate_validation.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "InstructionDurationCheck.__init__",
        "api_description": "Create new duration validation pass.\n\nThe alignment values depend on the control electronics of your quantum processor.\n\nArgs:\n    acquire_alignment: Integer number representing the minimum time resolution to\n        trigger acquisition instruction in units of ``dt``.\n    pulse_alignment: Integer number representing the minimum time resolution to\n        trigger gate instruction in units of ``dt``.\n    target: The :class:`~.Target` representing the target backend, if\n        ``target`` is specified then this argument will take\n        precedence and ``acquire_alignment`` and ``pulse_alignment`` will be ignored.",
        "api_signature": "__init__(self, acquire_alignment, pulse_alignment, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/alignments/check_durations.py"
    },
    {
        "api_name": "run",
        "full_api_name": "InstructionDurationCheck.run",
        "api_description": "Run duration validation passes.\n\nArgs:\n    dag: DAG circuit to check instruction durations.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/alignments/check_durations.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ConstrainedReschedule.__init__",
        "api_description": "Create new rescheduler pass.\n\nThe alignment values depend on the control electronics of your quantum processor.\n\nArgs:\n    acquire_alignment: Integer number representing the minimum time resolution to\n        trigger acquisition instruction in units of ``dt``.\n    pulse_alignment: Integer number representing the minimum time resolution to\n        trigger gate instruction in units of ``dt``.\n    target: The :class:`~.Target` representing the target backend, if\n        ``target`` is specified then this argument will take\n        precedence and ``acquire_alignment`` and ``pulse_alignment`` will be ignored.",
        "api_signature": "__init__(self, acquire_alignment, pulse_alignment, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/alignments/reschedule.py"
    },
    {
        "api_name": "_get_next_gate",
        "full_api_name": "ConstrainedReschedule._get_next_gate",
        "api_description": "Get next non-delay nodes.\n\nArgs:\n    dag: DAG circuit to be rescheduled with constraints.\n    node: Current node.\n\nReturns:\n    A list of non-delay successors.",
        "api_signature": "_get_next_gate(cls, dag, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/alignments/reschedule.py"
    },
    {
        "api_name": "_push_node_back",
        "full_api_name": "ConstrainedReschedule._push_node_back",
        "api_description": "Update the start time of the current node to satisfy alignment constraints.\nImmediate successors are pushed back to avoid overlap and will be processed later.\n\n.. note::\n\n    This logic assumes the all bits in the qregs and cregs synchronously start and end,\n    i.e. occupy the same time slot, but qregs and cregs can take\n    different time slot due to classical I/O latencies.\n\nArgs:\n    dag: DAG circuit to be rescheduled with constraints.\n    node: Current node.",
        "api_signature": "_push_node_back(self, dag, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/alignments/reschedule.py"
    },
    {
        "api_name": "run",
        "full_api_name": "ConstrainedReschedule.run",
        "api_description": "Run rescheduler.\n\nThis pass should perform rescheduling to satisfy:\n\n    - All DAGOpNode nodes (except for compiler directives) are placed at start time\n      satisfying hardware alignment constraints.\n    - The end time of a node does not overlap with the start time of successor nodes.\n\nAssumptions:\n\n    - Topological order and absolute time order of DAGOpNode are consistent.\n    - All bits in either qargs or cargs associated with node synchronously start.\n    - Start time of qargs and cargs may different due to I/O latency.\n\nBased on the configurations above, the rescheduler pass takes the following strategy:\n\n1. The nodes are processed in the topological order, from the beginning of\n    the circuit (i.e. from left to right). For every node (including compiler\n    directives), the function ``_push_node_back`` performs steps 2 and 3.\n2. If the start time of the node violates the alignment constraint,\n    the start time is increased to satisfy the constraint.\n3. Each immediate successor whose start_time overlaps the node's end_time is\n    pushed backwards (towards the end of the wire). Note that at this point\n    the shifted successor does not need to satisfy the constraints, but this\n    will be taken care of when that successor node itself is processed.\n4. After every node is processed, all misalignment constraints will be resolved,\n    and there will be no overlap between the nodes.\n\nArgs:\n    dag: DAG circuit to be rescheduled with constraints.\n\nRaises:\n    TranspilerError: If circuit is not scheduled.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/alignments/reschedule.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PadDynamicalDecoupling.__init__",
        "api_description": "Dynamical decoupling initializer.\n\nArgs:\n    durations: Durations of instructions to be used in scheduling.\n    dd_sequence: Sequence of gates to apply in idle spots.\n    qubits: Physical qubits on which to apply DD.\n        If None, all qubits will undergo DD (when possible).\n    spacing: A list of spacings between the DD gates.\n        The available slack will be divided according to this.\n        The list length must be one more than the length of dd_sequence,\n        and the elements must sum to 1. If None, a balanced spacing\n        will be used [d/2, d, d, ..., d, d, d/2].\n    skip_reset_qubits: If True, does not insert DD on idle periods that\n        immediately follow initialized/reset qubits\n        (as qubits in the ground state are less susceptible to decoherence).\n    pulse_alignment: The hardware constraints for gate timing allocation.\n        This is usually provided from ``backend.configuration().timing_constraints``.\n        If provided, the delay length, i.e. ``spacing``, is implicitly adjusted to\n        satisfy this constraint.\n    extra_slack_distribution: The option to control the behavior of DD sequence generation.\n        The duration of the DD sequence should be identical to an idle time in the\n        scheduled quantum circuit, however, the delay in between gates comprising the sequence\n        should be integer number in units of dt, and it might be further truncated\n        when ``pulse_alignment`` is specified. This sometimes results in the duration of\n        the created sequence being shorter than the idle time\n        that you want to fill with the sequence, i.e. `extra slack`.\n        This option takes following values.\n\n            - \"middle\": Put the extra slack to the interval at the middle of the sequence.\n            - \"edges\": Divide the extra slack as evenly as possible into\n              intervals at beginning and end of the sequence.\n    target: The :class:`~.Target` representing the target backend.\n        Target takes precedence over other arguments when they can be inferred from target.\n        Therefore specifying target as well as other arguments like ``durations`` or\n        ``pulse_alignment`` will cause those other arguments to be ignored.\n\nRaises:\n    TranspilerError: When invalid DD sequence is specified.\n    TranspilerError: When pulse gate with the duration which is\n        non-multiple of the alignment constraint value is found.\n    TypeError: If ``dd_sequence`` is not specified",
        "api_signature": "__init__(self, durations, dd_sequence, qubits, spacing, skip_reset_qubits, pulse_alignment, extra_slack_distribution, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/padding/dynamical_decoupling.py"
    },
    {
        "api_name": "_update_inst_durations",
        "full_api_name": "PadDynamicalDecoupling._update_inst_durations",
        "api_description": "Update instruction durations with circuit information. If the dag contains gate\ncalibrations and no instruction durations were provided through the target or as a\nstandalone input, the circuit calibration durations will be used.\nThe priority order for instruction durations is: target > standalone > circuit.",
        "api_signature": "_update_inst_durations(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/padding/dynamical_decoupling.py"
    },
    {
        "api_name": "_pre_runhook",
        "full_api_name": "PadDynamicalDecoupling._pre_runhook",
        "api_description": "",
        "api_signature": "_pre_runhook(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/padding/dynamical_decoupling.py"
    },
    {
        "api_name": "__gate_supported",
        "full_api_name": "PadDynamicalDecoupling.__gate_supported",
        "api_description": "A gate is supported on the qubit (qarg) or not.",
        "api_signature": "__gate_supported(self, gate, qarg)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/padding/dynamical_decoupling.py"
    },
    {
        "api_name": "__is_dd_qubit",
        "full_api_name": "PadDynamicalDecoupling.__is_dd_qubit",
        "api_description": "DD can be inserted in the qubit or not.",
        "api_signature": "__is_dd_qubit(self, qubit_index)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/padding/dynamical_decoupling.py"
    },
    {
        "api_name": "_pad",
        "full_api_name": "PadDynamicalDecoupling._pad",
        "api_description": "",
        "api_signature": "_pad(self, dag, qubit, t_start, t_end, next_node, prev_node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/padding/dynamical_decoupling.py"
    },
    {
        "api_name": "_constrained_length",
        "full_api_name": "PadDynamicalDecoupling._constrained_length",
        "api_description": "",
        "api_signature": "_constrained_length(values)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/padding/dynamical_decoupling.py"
    },
    {
        "api_name": "_resolve_params",
        "full_api_name": "PadDynamicalDecoupling._resolve_params",
        "api_description": "Return gate params with any bound parameters replaced with floats",
        "api_signature": "_resolve_params(gate)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/padding/dynamical_decoupling.py"
    },
    {
        "api_name": "_format_node",
        "full_api_name": "_format_node",
        "api_description": "Util to format the DAGNode, DAGInNode, and DAGOutNode.",
        "api_signature": "_format_node(node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/padding/dynamical_decoupling.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BasePadding.__init__",
        "api_description": "BasePadding initializer.\n\nArgs:\n    target: The :class:`~.Target` representing the target backend.\n        If it supplied and it does not support delay instruction on a qubit,\n        padding passes do not pad any idle time of the qubit.",
        "api_signature": "__init__(self, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/padding/base_padding.py"
    },
    {
        "api_name": "run",
        "full_api_name": "BasePadding.run",
        "api_description": "Run the padding pass on ``dag``.\n\nArgs:\n    dag: DAG to be checked.\n\nReturns:\n    DAGCircuit: DAG with idle time filled with instructions.\n\nRaises:\n    TranspilerError: When a particular node is not scheduled, likely some transform pass\n        is inserted before this node is called.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/padding/base_padding.py"
    },
    {
        "api_name": "__delay_supported",
        "full_api_name": "BasePadding.__delay_supported",
        "api_description": "Delay operation is supported on the qubit (qarg) or not.",
        "api_signature": "__delay_supported(self, qarg)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/padding/base_padding.py"
    },
    {
        "api_name": "_pre_runhook",
        "full_api_name": "BasePadding._pre_runhook",
        "api_description": "Extra routine inserted before running the padding pass.\n\nArgs:\n    dag: DAG circuit on which the sequence is applied.\n\nRaises:\n    TranspilerError: If the whole circuit or instruction is not scheduled.",
        "api_signature": "_pre_runhook(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/padding/base_padding.py"
    },
    {
        "api_name": "_apply_scheduled_op",
        "full_api_name": "BasePadding._apply_scheduled_op",
        "api_description": "Add new operation to DAG with scheduled information.\n\nThis is identical to apply_operation_back + updating the node_start_time property.\n\nArgs:\n    dag: DAG circuit on which the sequence is applied.\n    t_start: Start time of new node.\n    oper: New operation that is added to the DAG circuit.\n    qubits: The list of qubits that the operation acts on.\n    clbits: The list of clbits that the operation acts on.",
        "api_signature": "_apply_scheduled_op(self, dag, t_start, oper, qubits, clbits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/padding/base_padding.py"
    },
    {
        "api_name": "_pad",
        "full_api_name": "BasePadding._pad",
        "api_description": "Interleave instruction sequence in between two nodes.\n\n.. note::\n    If a DAGOpNode is added here, it should update node_start_time property\n    in the property set so that the added node is also scheduled.\n    This is achieved by adding operation via :meth:`_apply_scheduled_op`.\n\n.. note::\n\n    This method doesn't check if the total duration of new DAGOpNode added here\n    is identical to the interval (``t_end - t_start``).\n    A developer of the pass must guarantee this is satisfied.\n    If the duration is greater than the interval, your circuit may be\n    compiled down to the target code with extra duration on the backend compiler,\n    which is then played normally without error. However, the outcome of your circuit\n    might be unexpected due to erroneous scheduling.\n\nArgs:\n    dag: DAG circuit that sequence is applied.\n    qubit: The wire that the sequence is applied on.\n    t_start: Absolute start time of this interval.\n    t_end: Absolute end time of this interval.\n    next_node: Node that follows the sequence.\n    prev_node: Node ahead of the sequence.",
        "api_signature": "_pad(self, dag, qubit, t_start, t_end, next_node, prev_node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/padding/base_padding.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PadDelay.__init__",
        "api_description": "Create new padding delay pass.\n\nArgs:\n    fill_very_end: Set ``True`` to fill the end of circuit with delay.\n    target: The :class:`~.Target` representing the target backend.\n        If it is supplied and does not support delay instruction on a qubit,\n        padding passes do not pad any idle time of the qubit.",
        "api_signature": "__init__(self, fill_very_end, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/padding/pad_delay.py"
    },
    {
        "api_name": "_pad",
        "full_api_name": "PadDelay._pad",
        "api_description": "",
        "api_signature": "_pad(self, dag, qubit, t_start, t_end, next_node, prev_node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/padding/pad_delay.py"
    },
    {
        "api_name": "run",
        "full_api_name": "ASAPScheduleAnalysis.run",
        "api_description": "Run the ASAPSchedule pass on `dag`.\n\nArgs:\n    dag (DAGCircuit): DAG to schedule.\n\nReturns:\n    DAGCircuit: A scheduled DAG.\n\nRaises:\n    TranspilerError: if the circuit is not mapped on physical qubits.\n    TranspilerError: if conditional bit is added to non-supported instruction.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/scheduling/asap.py"
    },
    {
        "api_name": "run",
        "full_api_name": "ALAPScheduleAnalysis.run",
        "api_description": "Run the ALAPSchedule pass on `dag`.\n\nArgs:\n    dag (DAGCircuit): DAG to schedule.\n\nReturns:\n    DAGCircuit: A scheduled DAG.\n\nRaises:\n    TranspilerError: if the circuit is not mapped on physical qubits.\n    TranspilerError: if conditional bit is added to non-supported instruction.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/scheduling/alap.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BaseScheduler.__init__",
        "api_description": "Scheduler initializer.\n\nArgs:\n    durations: Durations of instructions to be used in scheduling\n    target: The :class:`~.Target` representing the target backend, if both\n          ``durations`` and this are specified then this argument will take\n          precedence and ``durations`` will be ignored.",
        "api_signature": "__init__(self, durations, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/scheduling/base_scheduler.py"
    },
    {
        "api_name": "_get_node_duration",
        "full_api_name": "BaseScheduler._get_node_duration",
        "api_description": "A helper method to get duration from node or calibration.",
        "api_signature": "_get_node_duration(node, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/scheduling/base_scheduler.py"
    },
    {
        "api_name": "run",
        "full_api_name": "BaseScheduler.run",
        "api_description": "",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/scheduling/base_scheduler.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SetIOLatency.__init__",
        "api_description": "Create pass with latency information.\n\nArgs:\n    clbit_write_latency: A control flow constraints. Because standard superconducting\n        quantum processor implement dispersive QND readout, the actual data transfer\n        to the clbit happens after the round-trip stimulus signal is buffered\n        and discriminated into quantum state.\n        The interval ``[t0, t0 + clbit_write_latency]`` is regarded as idle time\n        for clbits associated with the measure instruction.\n        This defaults to 0 dt which is identical to Qiskit Pulse scheduler.\n    conditional_latency: A control flow constraints. This value represents\n        a latency of reading a classical register for the conditional operation.\n        The gate operation occurs after this latency. This appears as a delay\n        in front of the DAGOpNode of the gate.\n        This defaults to 0 dt.",
        "api_signature": "__init__(self, clbit_write_latency, conditional_latency)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/scheduling/set_io_latency.py"
    },
    {
        "api_name": "run",
        "full_api_name": "SetIOLatency.run",
        "api_description": "Add IO latency information.\n\nArgs:\n    dag: Input DAG circuit.",
        "api_signature": "run(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/scheduling/set_io_latency.py"
    },
    {
        "api_name": "execute",
        "full_api_name": "Task.execute",
        "api_description": "Execute optimization task for input Qiskit IR.\n\nArgs:\n    passmanager_ir: Qiskit IR to optimize.\n    state: State associated with workflow execution by the pass manager itself.\n    callback: A callback function which is caller per execution of optimization task.\n\nReturns:\n    Optimized Qiskit IR and state of the workflow.",
        "api_signature": "execute(self, passmanager_ir, state, callback)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/passmanager/base_tasks.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "GenericPass.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/passmanager/base_tasks.py"
    },
    {
        "api_name": "name",
        "full_api_name": "GenericPass.name",
        "api_description": "Name of the pass.",
        "api_signature": "name(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/passmanager/base_tasks.py"
    },
    {
        "api_name": "execute",
        "full_api_name": "GenericPass.execute",
        "api_description": "",
        "api_signature": "execute(self, passmanager_ir, state, callback)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/passmanager/base_tasks.py"
    },
    {
        "api_name": "update_status",
        "full_api_name": "GenericPass.update_status",
        "api_description": "Update workflow status.\n\nArgs:\n    state: Pass manager state to update.\n    run_state: Completion status of current task.\n\nReturns:\n    Updated pass manager state.",
        "api_signature": "update_status(self, state, run_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/passmanager/base_tasks.py"
    },
    {
        "api_name": "run",
        "full_api_name": "GenericPass.run",
        "api_description": "Run optimization task.\n\nArgs:\n    passmanager_ir: Qiskit IR to optimize.\n\nReturns:\n    Optimized Qiskit IR.",
        "api_signature": "run(self, passmanager_ir)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/passmanager/base_tasks.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BaseController.__init__",
        "api_description": "Create new flow controller.\n\nArgs:\n    options: Option for this flow controller.",
        "api_signature": "__init__(self, options)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/passmanager/base_tasks.py"
    },
    {
        "api_name": "iter_tasks",
        "full_api_name": "BaseController.iter_tasks",
        "api_description": "A custom logic to choose a next task to run.\n\nController subclass can consume the state to build a proper task pipeline.  The updated\nstate after a task execution will be fed back in as the \"return\" value of any ``yield``\nstatements.  This indicates the order of task execution is only determined at running time.\nThis method is not allowed to mutate the given state object.\n\nArgs:\n    state: The state of the passmanager workflow at the beginning of this flow controller's\n        execution.\n\nReceives:\n    state: the state of pass manager after the execution of the last task that was yielded.\n        The generator does not need to inspect this if it is irrelevant to its logic, nor\n        update it.\n\nYields:\n    Task: Next task to run.",
        "api_signature": "iter_tasks(self, state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/passmanager/base_tasks.py"
    },
    {
        "api_name": "execute",
        "full_api_name": "BaseController.execute",
        "api_description": "",
        "api_signature": "execute(self, passmanager_ir, state, callback)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/passmanager/base_tasks.py"
    },
    {
        "api_name": "__missing__",
        "full_api_name": "PropertySet.__missing__",
        "api_description": "",
        "api_signature": "__missing__(self, key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/passmanager/compilation_status.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BasePassManager.__init__",
        "api_description": "Initialize an empty pass manager object.\n\nArgs:\n    tasks: A pass set to be added to the pass manager schedule.\n    max_iteration: The maximum number of iterations the schedule will be looped if the\n        condition is not met.",
        "api_signature": "__init__(self, tasks, max_iteration)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/passmanager/passmanager.py"
    },
    {
        "api_name": "append",
        "full_api_name": "BasePassManager.append",
        "api_description": "Append tasks to the schedule of passes.\n\nArgs:\n    tasks: A set of pass manager tasks to be added to schedule.\n\nRaises:\n    TypeError: When any element of tasks is not a subclass of passmanager Task.",
        "api_signature": "append(self, tasks)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/passmanager/passmanager.py"
    },
    {
        "api_name": "replace",
        "full_api_name": "BasePassManager.replace",
        "api_description": "Replace a particular pass in the scheduler.\n\nArgs:\n    index: Task index to replace, based on the position in :meth:`tasks`\n    tasks: A set of pass manager tasks to be added to schedule.\n\nRaises:\n    TypeError: When any element of tasks is not a subclass of passmanager Task.\n    PassManagerError: If the index is not found.",
        "api_signature": "replace(self, index, tasks)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/passmanager/passmanager.py"
    },
    {
        "api_name": "remove",
        "full_api_name": "BasePassManager.remove",
        "api_description": "Removes a particular pass in the scheduler.\n\nArgs:\n    index: Pass index to remove, based on the position in :meth:`passes`.\n\nRaises:\n    PassManagerError: If the index is not found.",
        "api_signature": "remove(self, index)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/passmanager/passmanager.py"
    },
    {
        "api_name": "__setitem__",
        "full_api_name": "BasePassManager.__setitem__",
        "api_description": "",
        "api_signature": "__setitem__(self, index, item)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/passmanager/passmanager.py"
    },
    {
        "api_name": "__len__",
        "full_api_name": "BasePassManager.__len__",
        "api_description": "",
        "api_signature": "__len__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/passmanager/passmanager.py"
    },
    {
        "api_name": "__getitem__",
        "full_api_name": "BasePassManager.__getitem__",
        "api_description": "",
        "api_signature": "__getitem__(self, index)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/passmanager/passmanager.py"
    },
    {
        "api_name": "__add__",
        "full_api_name": "BasePassManager.__add__",
        "api_description": "",
        "api_signature": "__add__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/passmanager/passmanager.py"
    },
    {
        "api_name": "_passmanager_frontend",
        "full_api_name": "BasePassManager._passmanager_frontend",
        "api_description": "Convert input program into pass manager IR.\n\nArgs:\n    in_program: Input program.\n\nReturns:\n    Pass manager IR.",
        "api_signature": "_passmanager_frontend(self, input_program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/passmanager/passmanager.py"
    },
    {
        "api_name": "_passmanager_backend",
        "full_api_name": "BasePassManager._passmanager_backend",
        "api_description": "Convert pass manager IR into output program.\n\nArgs:\n    passmanager_ir: Pass manager IR after optimization.\n    in_program: The input program, this can be used if you need\n        any metadata about the original input for the output.\n        It should not be mutated.\n\nReturns:\n    Output program.",
        "api_signature": "_passmanager_backend(self, passmanager_ir, in_program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/passmanager/passmanager.py"
    },
    {
        "api_name": "run",
        "full_api_name": "BasePassManager.run",
        "api_description": "Run all the passes on the specified ``in_programs``.\n\nArgs:\n    in_programs: Input programs to transform via all the registered passes.\n        A single input object cannot be a Python builtin list object.\n        A list object is considered as multiple input objects to optimize.\n    callback: A callback function that will be called after each pass execution. The\n        function will be called with 4 keyword arguments::\n\n            task (GenericPass): the pass being run\n            passmanager_ir (Any): depending on pass manager subclass\n            property_set (PropertySet): the property set\n            running_time (float): the time to execute the pass\n            count (int): the index for the pass execution\n\n        The exact arguments pass expose the internals of the pass\n        manager and are subject to change as the pass manager internals\n        change. If you intend to reuse a callback function over\n        multiple releases be sure to check that the arguments being\n        passed are the same.\n\n        To use the callback feature you define a function that will\n        take in kwargs dict and access the variables. For example::\n\n            def callback_func(**kwargs):\n                task = kwargs['task']\n                passmanager_ir = kwargs['passmanager_ir']\n                property_set = kwargs['property_set']\n                running_time = kwargs['running_time']\n                count = kwargs['count']\n                ...\n    num_processes: The maximum number of parallel processes to launch if parallel\n        execution is enabled. This argument overrides ``num_processes`` in the user\n        configuration file, and the ``QISKIT_NUM_PROCS`` environment variable. If set\n        to ``None`` the system default or local user configuration will be used.\n\n    kwargs: Arbitrary arguments passed to the compiler frontend and backend.\n\nReturns:\n    The transformed program(s).",
        "api_signature": "run(self, in_programs, callback, num_processes)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/passmanager/passmanager.py"
    },
    {
        "api_name": "to_flow_controller",
        "full_api_name": "BasePassManager.to_flow_controller",
        "api_description": "Linearize this manager into a single :class:`.FlowControllerLinear`,\nso that it can be nested inside another pass manager.\n\nReturns:\n    A linearized pass manager.",
        "api_signature": "to_flow_controller(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/passmanager/passmanager.py"
    },
    {
        "api_name": "_flatten_tasks",
        "full_api_name": "BasePassManager._flatten_tasks",
        "api_description": "A helper method to recursively flatten a nested task chain.",
        "api_signature": "_flatten_tasks(self, elements)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/passmanager/passmanager.py"
    },
    {
        "api_name": "_run_workflow",
        "full_api_name": "_run_workflow",
        "api_description": "Run single program optimization with a pass manager.\n\nArgs:\n    program: Arbitrary program to optimize.\n    pass_manager: Pass manager with scheduled passes.\n    **kwargs: Keyword arguments for IR conversion.\n\nReturns:\n    Optimized program.",
        "api_signature": "_run_workflow(program, pass_manager)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/passmanager/passmanager.py"
    },
    {
        "api_name": "_run_workflow_in_new_process",
        "full_api_name": "_run_workflow_in_new_process",
        "api_description": "Run single program optimization in new process.\n\nArgs:\n    program: Arbitrary program to optimize.\n    pass_manager_bin: Binary of the pass manager with scheduled passes.\n\nReturns:\n      Optimized program.",
        "api_signature": "_run_workflow_in_new_process(program, pass_manager_bin)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/passmanager/passmanager.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "FlowControllerLinear.__init__",
        "api_description": "",
        "api_signature": "__init__(self, tasks)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/passmanager/flow_controllers.py"
    },
    {
        "api_name": "passes",
        "full_api_name": "FlowControllerLinear.passes",
        "api_description": "Alias of tasks for backward compatibility.",
        "api_signature": "passes(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/passmanager/flow_controllers.py"
    },
    {
        "api_name": "iter_tasks",
        "full_api_name": "FlowControllerLinear.iter_tasks",
        "api_description": "",
        "api_signature": "iter_tasks(self, state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/passmanager/flow_controllers.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "DoWhileController.__init__",
        "api_description": "",
        "api_signature": "__init__(self, tasks, do_while)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/passmanager/flow_controllers.py"
    },
    {
        "api_name": "passes",
        "full_api_name": "DoWhileController.passes",
        "api_description": "Alias of tasks for backward compatibility.",
        "api_signature": "passes(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/passmanager/flow_controllers.py"
    },
    {
        "api_name": "iter_tasks",
        "full_api_name": "DoWhileController.iter_tasks",
        "api_description": "",
        "api_signature": "iter_tasks(self, state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/passmanager/flow_controllers.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ConditionalController.__init__",
        "api_description": "",
        "api_signature": "__init__(self, tasks, condition)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/passmanager/flow_controllers.py"
    },
    {
        "api_name": "passes",
        "full_api_name": "ConditionalController.passes",
        "api_description": "Alias of tasks for backward compatibility.",
        "api_signature": "passes(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/passmanager/flow_controllers.py"
    },
    {
        "api_name": "iter_tasks",
        "full_api_name": "ConditionalController.iter_tasks",
        "api_description": "",
        "api_signature": "iter_tasks(self, state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/passmanager/flow_controllers.py"
    },
    {
        "api_name": "disassemble",
        "full_api_name": "disassemble",
        "api_description": "Disassemble a qobj and return the circuits or pulse schedules, run_config, and user header.\n\n.. note::\n\n    ``disassemble(assemble(qc))`` is not guaranteed to produce an exactly equal circuit to the\n    input, due to limitations in the :obj:`.QasmQobj` format that need to be maintained for\n    backend system compatibility.  This is most likely to be the case when using newer features\n    of :obj:`.QuantumCircuit`.  In most cases, the output should be equivalent, if not quite\n    equal.\n\nArgs:\n    qobj (Qobj): The input qobj object to disassemble\n\nReturns:\n    Union[CircuitModule, PulseModule]: The disassembled program which consists of:\n\n        * programs: A list of quantum circuits or pulse schedules\n        * run_config: The dict of the run config\n        * user_qobj_header: The dict of any user headers in the qobj\n\nExamples:\n\n    .. code-block:: python\n\n        from qiskit.circuit import QuantumRegister, ClassicalRegister, QuantumCircuit\n        from qiskit.compiler.assembler import assemble\n        from qiskit.assembler.disassemble import disassemble\n        # Create a circuit to assemble into a qobj\n        q = QuantumRegister(2)\n        c = ClassicalRegister(2)\n        qc = QuantumCircuit(q, c)\n        qc.h(q[0])\n        qc.cx(q[0], q[1])\n        qc.measure(q, c)\n        # Assemble the circuit into a Qobj\n        qobj = assemble(qc, shots=2000, memory=True)\n        # Disassemble the qobj back into a circuit\n        circuits, run_config_out, headers = disassemble(qobj)",
        "api_signature": "disassemble(qobj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/assembler/disassemble.py"
    },
    {
        "api_name": "_disassemble_circuit",
        "full_api_name": "_disassemble_circuit",
        "api_description": "",
        "api_signature": "_disassemble_circuit(qobj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/assembler/disassemble.py"
    },
    {
        "api_name": "_qobj_to_circuit_cals",
        "full_api_name": "_qobj_to_circuit_cals",
        "api_description": "Return circuit calibrations dictionary from qobj/exp config calibrations.",
        "api_signature": "_qobj_to_circuit_cals(qobj, pulse_lib)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/assembler/disassemble.py"
    },
    {
        "api_name": "_experiments_to_circuits",
        "full_api_name": "_experiments_to_circuits",
        "api_description": "Return a list of QuantumCircuit object(s) from a qobj.\n\nArgs:\n    qobj (Qobj): The Qobj object to convert to QuantumCircuits\n\nReturns:\n    list: A list of QuantumCircuit objects from the qobj",
        "api_signature": "_experiments_to_circuits(qobj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/assembler/disassemble.py"
    },
    {
        "api_name": "_disassemble_pulse_schedule",
        "full_api_name": "_disassemble_pulse_schedule",
        "api_description": "",
        "api_signature": "_disassemble_pulse_schedule(qobj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/assembler/disassemble.py"
    },
    {
        "api_name": "_experiments_to_schedules",
        "full_api_name": "_experiments_to_schedules",
        "api_description": "Return a list of :class:`qiskit.pulse.Schedule` object(s) from a qobj.\n\nArgs:\n    qobj (Qobj): The Qobj object to convert to pulse schedules.\n\nReturns:\n    A list of :class:`qiskit.pulse.Schedule` objects from the qobj\n\nRaises:\n    pulse.PulseError: If a parameterized instruction is supplied.",
        "api_signature": "_experiments_to_schedules(qobj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/assembler/disassemble.py"
    },
    {
        "api_name": "assemble_schedules",
        "full_api_name": "assemble_schedules",
        "api_description": "Assembles a list of schedules into a qobj that can be run on the backend.\n\nArgs:\n    schedules: Schedules to assemble.\n    qobj_id: Identifier for the generated qobj.\n    qobj_header: Header to pass to the results.\n    run_config: Configuration of the runtime environment.\n\nReturns:\n    The Qobj to be run on the backends.\n\nRaises:\n    QiskitError: when frequency settings are not supplied.\n\nExamples:\n\n    .. code-block:: python\n\n        from qiskit import pulse\n        from qiskit.assembler import assemble_schedules\n        from qiskit.assembler.run_config import RunConfig\n        # Construct a Qobj header for the output Qobj\n        header = {\"backend_name\": \"FakeOpenPulse2Q\", \"backend_version\": \"0.0.0\"}\n        # Build a configuration object for the output Qobj\n        config = RunConfig(shots=1024,\n                           memory=False,\n                           meas_level=1,\n                           meas_return='avg',\n                           memory_slot_size=100,\n                           parametric_pulses=[],\n                           init_qubits=True,\n                           qubit_lo_freq=[4900000000.0, 5000000000.0],\n                           meas_lo_freq=[6500000000.0, 6600000000.0],\n                           schedule_los=[])\n        # Build a Pulse schedule to assemble into a Qobj\n        schedule = pulse.Schedule()\n        schedule += pulse.Play(pulse.Waveform([0.1] * 16, name=\"test0\"),\n                               pulse.DriveChannel(0),\n                               name=\"test1\")\n        schedule += pulse.Play(pulse.Waveform([0.1] * 16, name=\"test1\"),\n                               pulse.DriveChannel(0),\n                               name=\"test2\")\n        schedule += pulse.Play(pulse.Waveform([0.5] * 16, name=\"test0\"),\n                               pulse.DriveChannel(0),\n                               name=\"test1\")\n        # Assemble a Qobj from the schedule.\n        pulseQobj = assemble_schedules(schedules=[schedule],\n                                       qobj_id=\"custom-id\",\n                                       qobj_header=header,\n                                       run_config=config)",
        "api_signature": "assemble_schedules(schedules, qobj_id, qobj_header, run_config)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/assembler/assemble_schedules.py"
    },
    {
        "api_name": "_assemble_experiments",
        "full_api_name": "_assemble_experiments",
        "api_description": "Assembles a list of schedules into PulseQobjExperiments, and returns related metadata that\nwill be assembled into the Qobj configuration.\n\nArgs:\n    schedules: Schedules to assemble.\n    lo_converter: The configured frequency converter and validator.\n    run_config: Configuration of the runtime environment.\n\nReturns:\n    The list of assembled experiments, and the dictionary of related experiment config.\n\nRaises:\n    QiskitError: when frequency settings are not compatible with the experiments.",
        "api_signature": "_assemble_experiments(schedules, lo_converter, run_config)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/assembler/assemble_schedules.py"
    },
    {
        "api_name": "_assemble_instructions",
        "full_api_name": "_assemble_instructions",
        "api_description": "Assembles the instructions in a schedule into a list of PulseQobjInstructions and returns\nrelated metadata that will be assembled into the Qobj configuration. Lookup table for\npulses defined in all experiments are registered in ``user_pulselib``. This object should be\nmutable python dictionary so that items are properly updated after each instruction assemble.\nThe dictionary is not returned to avoid redundancy.\n\nArgs:\n    sched: Schedule to assemble.\n    instruction_converter: A converter instance which can convert PulseInstructions to\n                           PulseQobjInstructions.\n    run_config: Configuration of the runtime environment.\n    user_pulselib: User pulse library from previous schedule.\n\nReturns:\n    A list of converted instructions, the user pulse library dictionary (from pulse name to\n    pulse samples), and the maximum number of readout memory slots used by this Schedule.",
        "api_signature": "_assemble_instructions(sched, instruction_converter, run_config, user_pulselib)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/assembler/assemble_schedules.py"
    },
    {
        "api_name": "_validate_meas_map",
        "full_api_name": "_validate_meas_map",
        "api_description": "Validate all qubits tied in ``meas_map`` are to be acquired.\n\nArgs:\n    instruction_map: A dictionary grouping Acquire instructions according to their start time\n                     and duration.\n    meas_map: List of groups of qubits that must be acquired together.\n\nRaises:\n    QiskitError: If the instructions do not satisfy the measurement map.",
        "api_signature": "_validate_meas_map(instruction_map, meas_map)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/assembler/assemble_schedules.py"
    },
    {
        "api_name": "_assemble_config",
        "full_api_name": "_assemble_config",
        "api_description": "Assembles the QobjConfiguration from experimental config and runtime config.\n\nArgs:\n    lo_converter: The configured frequency converter and validator.\n    experiment_config: Schedules to assemble.\n    run_config: Configuration of the runtime environment.\n\nReturns:\n    The assembled PulseQobjConfig.",
        "api_signature": "_assemble_config(lo_converter, experiment_config, run_config)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/assembler/assemble_schedules.py"
    },
    {
        "api_name": "_assemble_circuit",
        "full_api_name": "_assemble_circuit",
        "api_description": "Assemble one circuit.\n\nArgs:\n    circuit: circuit to assemble\n    run_config: configuration of the runtime environment\n\nReturns:\n    One experiment for the QasmQobj, and pulse library for pulse gates (which could be None)\n\nRaises:\n    QiskitError: when the circuit has unit other than 'dt'.",
        "api_signature": "_assemble_circuit(circuit, run_config)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/assembler/assemble_circuits.py"
    },
    {
        "api_name": "_assemble_pulse_gates",
        "full_api_name": "_assemble_pulse_gates",
        "api_description": "Assemble and return the circuit calibrations and associated pulse library, if there are any.\nThe calibrations themselves may reference the pulse library which is returned as a dict.\n\nArgs:\n    circuit: circuit which may have pulse calibrations\n    run_config: configuration of the runtime environment\n\nReturns:\n    The calibrations and pulse library, if there are any",
        "api_signature": "_assemble_pulse_gates(circuit, run_config)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/assembler/assemble_circuits.py"
    },
    {
        "api_name": "_extract_common_calibrations",
        "full_api_name": "_extract_common_calibrations",
        "api_description": "Given a list of ``QasmQobjExperiment``s, each of which may have calibrations in their\n``config``, collect common calibrations into a global ``QasmExperimentCalibrations``\nand delete them from their local experiments.\n\nArgs:\n    experiments: The list of OpenQASM experiments that are being assembled into one qobj\n\nReturns:\n    The input experiments with modified calibrations, and common calibrations, if there\n    are any",
        "api_signature": "_extract_common_calibrations(experiments)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/assembler/assemble_circuits.py"
    },
    {
        "api_name": "index_calibrations",
        "full_api_name": "index_calibrations",
        "api_description": "Map each calibration to all experiments that contain it.",
        "api_signature": "index_calibrations()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/assembler/assemble_circuits.py"
    },
    {
        "api_name": "collect_common_calibrations",
        "full_api_name": "collect_common_calibrations",
        "api_description": "If a gate calibration appears in all experiments, collect it.",
        "api_signature": "collect_common_calibrations()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/assembler/assemble_circuits.py"
    },
    {
        "api_name": "remove_common_gate_calibrations",
        "full_api_name": "remove_common_gate_calibrations",
        "api_description": "For calibrations that appear in all experiments, remove them from the individual\nexperiment's ``config.calibrations``.",
        "api_signature": "remove_common_gate_calibrations(exps)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/assembler/assemble_circuits.py"
    },
    {
        "api_name": "_configure_experiment_los",
        "full_api_name": "_configure_experiment_los",
        "api_description": "",
        "api_signature": "_configure_experiment_los(experiments, lo_converter, run_config)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/assembler/assemble_circuits.py"
    },
    {
        "api_name": "_assemble_circuits",
        "full_api_name": "_assemble_circuits",
        "api_description": "",
        "api_signature": "_assemble_circuits(circuits, run_config, qobj_id, qobj_header)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/assembler/assemble_circuits.py"
    },
    {
        "api_name": "assemble_circuits",
        "full_api_name": "assemble_circuits",
        "api_description": "Assembles a list of circuits into a qobj that can be run on the backend.\n\nArgs:\n    circuits: circuit(s) to assemble\n    run_config: configuration of the runtime environment\n    qobj_id: identifier for the generated qobj\n    qobj_header: header to pass to the results\n\nReturns:\n    The qobj to be run on the backends\n\nExamples:\n\n    .. code-block:: python\n\n        from qiskit.circuit import QuantumRegister, ClassicalRegister, QuantumCircuit\n        from qiskit.assembler import assemble_circuits\n        from qiskit.assembler.run_config import RunConfig\n        # Build a circuit to convert into a Qobj\n        q = QuantumRegister(2)\n        c = ClassicalRegister(2)\n        qc = QuantumCircuit(q, c)\n        qc.h(q[0])\n        qc.cx(q[0], q[1])\n        qc.measure(q, c)\n        # Assemble a Qobj from the input circuit\n        qobj = assemble_circuits(circuits=[qc],\n                                 qobj_id=\"custom-id\",\n                                 qobj_header=[],\n                                 run_config=RunConfig(shots=2000, memory=True, init_qubits=True))",
        "api_signature": "assemble_circuits(circuits, run_config, qobj_id, qobj_header)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/assembler/assemble_circuits.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "RunConfig.__init__",
        "api_description": "Initialize a RunConfig object\n\nArgs:\n    shots (int): the number of shots\n    seed_simulator (int): the seed to use in the simulator\n    memory (bool): whether to request memory from backend\n        (per-shot readouts)\n    parameter_binds (list[dict]): List of parameter bindings\n    **kwargs: optional fields",
        "api_signature": "__init__(self, shots, seed_simulator, memory, parameter_binds)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/assembler/run_config.py"
    },
    {
        "api_name": "from_dict",
        "full_api_name": "RunConfig.from_dict",
        "api_description": "Create a new RunConfig object from a dictionary.\n\nArgs:\n    data (dict): A dictionary representing the RunConfig to create.\n                 It will be in the same format as output by\n                 :meth:`to_dict`.\n\nReturns:\n    RunConfig: The RunConfig from the input dictionary.",
        "api_signature": "from_dict(cls, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/assembler/run_config.py"
    },
    {
        "api_name": "to_dict",
        "full_api_name": "RunConfig.to_dict",
        "api_description": "Return a dictionary format representation of the RunConfig\n\nReturns:\n    dict: The dictionary form of the RunConfig.",
        "api_signature": "to_dict(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/assembler/run_config.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Estimator.__init__",
        "api_description": "Args:\n    options: Default options.\n\nRaises:\n    QiskitError: if some classical bits are not used for measurements.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/estimator.py"
    },
    {
        "api_name": "_call",
        "full_api_name": "Estimator._call",
        "api_description": "",
        "api_signature": "_call(self, circuits, observables, parameter_values)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/estimator.py"
    },
    {
        "api_name": "_run",
        "full_api_name": "Estimator._run",
        "api_description": "",
        "api_signature": "_run(self, circuits, observables, parameter_values)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/estimator.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "StatevectorEstimator.__init__",
        "api_description": "Args:\n    default_precision: The default precision for the estimator if not specified during run.\n    seed: The seed or Generator object for random number generation.\n        If None, a random seeded default RNG will be used.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/statevector_estimator.py"
    },
    {
        "api_name": "default_precision",
        "full_api_name": "StatevectorEstimator.default_precision",
        "api_description": "Return the default precision",
        "api_signature": "default_precision(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/statevector_estimator.py"
    },
    {
        "api_name": "seed",
        "full_api_name": "StatevectorEstimator.seed",
        "api_description": "Return the seed or Generator object for random number generation.",
        "api_signature": "seed(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/statevector_estimator.py"
    },
    {
        "api_name": "run",
        "full_api_name": "StatevectorEstimator.run",
        "api_description": "",
        "api_signature": "run(self, pubs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/statevector_estimator.py"
    },
    {
        "api_name": "_run",
        "full_api_name": "StatevectorEstimator._run",
        "api_description": "",
        "api_signature": "_run(self, pubs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/statevector_estimator.py"
    },
    {
        "api_name": "_run_pub",
        "full_api_name": "StatevectorEstimator._run_pub",
        "api_description": "",
        "api_signature": "_run_pub(self, pub)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/statevector_estimator.py"
    },
    {
        "api_name": "init_circuit",
        "full_api_name": "init_circuit",
        "api_description": "Initialize state by converting the input to a quantum circuit.\n\nArgs:\n    state: The state as quantum circuit or statevector.\n\nReturns:\n    The state as quantum circuit.",
        "api_signature": "init_circuit(state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/utils.py"
    },
    {
        "api_name": "init_observable",
        "full_api_name": "init_observable",
        "api_description": "Initialize observable by converting the input to a :class:`~qiskit.quantum_info.SparsePauliOp`.\n\nArgs:\n    observable: The observable.\n\nReturns:\n    The observable as :class:`~qiskit.quantum_info.SparsePauliOp`.\n\nRaises:\n    QiskitError: when observable type cannot be converted to SparsePauliOp.",
        "api_signature": "init_observable(observable)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/utils.py"
    },
    {
        "api_name": "final_measurement_mapping",
        "full_api_name": "final_measurement_mapping",
        "api_description": "Return the final measurement mapping for the circuit.\n\nDict keys label measured qubits, whereas the values indicate the\nclassical bit onto which that qubits measurement result is stored.\n\nParameters:\n    circuit: Input quantum circuit.\n\nReturns:\n    Mapping of qubits to classical bits for final measurements.",
        "api_signature": "final_measurement_mapping(circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/utils.py"
    },
    {
        "api_name": "_bits_key",
        "full_api_name": "_bits_key",
        "api_description": "",
        "api_signature": "_bits_key(bits, circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/utils.py"
    },
    {
        "api_name": "_format_params",
        "full_api_name": "_format_params",
        "api_description": "",
        "api_signature": "_format_params(param)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/utils.py"
    },
    {
        "api_name": "_circuit_key",
        "full_api_name": "_circuit_key",
        "api_description": "Private key function for QuantumCircuit.\n\nThis is the workaround until :meth:`QuantumCircuit.__hash__` will be introduced.\nIf key collision is found, please add elements to avoid it.\n\nArgs:\n    circuit: Input quantum circuit.\n    functional: If True, the returned key only includes functional data (i.e. execution related).\n\nReturns:\n    Composite key for circuit.",
        "api_signature": "_circuit_key(circuit, functional)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/utils.py"
    },
    {
        "api_name": "_observable_key",
        "full_api_name": "_observable_key",
        "api_description": "Private key function for SparsePauliOp.\nArgs:\n    observable: Input operator.\n\nReturns:\n    Key for observables.",
        "api_signature": "_observable_key(observable)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/utils.py"
    },
    {
        "api_name": "bound_circuit_to_instruction",
        "full_api_name": "bound_circuit_to_instruction",
        "api_description": "Build an :class:`~qiskit.circuit.Instruction` object from\na :class:`~qiskit.circuit.QuantumCircuit`\n\nThis is a specialized version of :func:`~qiskit.converters.circuit_to_instruction`\nto avoid deep copy. This requires a quantum circuit whose parameters are all bound.\nBecause this does not take a copy of the input circuit, this assumes that the input\ncircuit won't be modified.\n\nIf https://github.com/Qiskit/qiskit-terra/issues/7983 is resolved,\nwe can remove this function.\n\nArgs:\n    circuit(QuantumCircuit): Input quantum circuit\n\nReturns:\n    An :class:`~qiskit.circuit.Instruction` object",
        "api_signature": "bound_circuit_to_instruction(circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/utils.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BackendSamplerV2.__init__",
        "api_description": "Args:\n    backend: The backend to run the primitive on.\n    options: The options to control the default shots (``default_shots``) and\n        the random seed for the simulator (``seed_simulator``).",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_sampler_v2.py"
    },
    {
        "api_name": "backend",
        "full_api_name": "BackendSamplerV2.backend",
        "api_description": "Returns the backend which this sampler object based on.",
        "api_signature": "backend(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_sampler_v2.py"
    },
    {
        "api_name": "options",
        "full_api_name": "BackendSamplerV2.options",
        "api_description": "Return the options",
        "api_signature": "options(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_sampler_v2.py"
    },
    {
        "api_name": "run",
        "full_api_name": "BackendSamplerV2.run",
        "api_description": "",
        "api_signature": "run(self, pubs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_sampler_v2.py"
    },
    {
        "api_name": "_validate_pubs",
        "full_api_name": "BackendSamplerV2._validate_pubs",
        "api_description": "",
        "api_signature": "_validate_pubs(self, pubs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_sampler_v2.py"
    },
    {
        "api_name": "_run",
        "full_api_name": "BackendSamplerV2._run",
        "api_description": "",
        "api_signature": "_run(self, pubs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_sampler_v2.py"
    },
    {
        "api_name": "_run_pubs",
        "full_api_name": "BackendSamplerV2._run_pubs",
        "api_description": "Compute results for pubs that all require the same value of ``shots``.",
        "api_signature": "_run_pubs(self, pubs, shots)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_sampler_v2.py"
    },
    {
        "api_name": "_postprocess_pub",
        "full_api_name": "BackendSamplerV2._postprocess_pub",
        "api_description": "Converts the memory data into an array of bit arrays with the shape of the pub.",
        "api_signature": "_postprocess_pub(self, result_memory, shots, shape, meas_info, max_num_bytes, circuit_metadata)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_sampler_v2.py"
    },
    {
        "api_name": "_analyze_circuit",
        "full_api_name": "_analyze_circuit",
        "api_description": "Analyzes the information for each creg in a circuit.",
        "api_signature": "_analyze_circuit(circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_sampler_v2.py"
    },
    {
        "api_name": "_prepare_memory",
        "full_api_name": "_prepare_memory",
        "api_description": "Joins splitted results if exceeding max_experiments",
        "api_signature": "_prepare_memory(results)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_sampler_v2.py"
    },
    {
        "api_name": "_memory_array",
        "full_api_name": "_memory_array",
        "api_description": "Converts the memory data into an array in an unpacked way.",
        "api_signature": "_memory_array(results, num_bytes)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_sampler_v2.py"
    },
    {
        "api_name": "_samples_to_packed_array",
        "full_api_name": "_samples_to_packed_array",
        "api_description": "Converts an unpacked array of the memory data into a packed array.",
        "api_signature": "_samples_to_packed_array(samples, num_bits, start)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_sampler_v2.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "StatevectorSampler.__init__",
        "api_description": "Args:\n    default_shots: The default shots for the sampler if not specified during run.\n    seed: The seed or Generator object for random number generation.\n        If None, a random seeded default RNG will be used.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/statevector_sampler.py"
    },
    {
        "api_name": "default_shots",
        "full_api_name": "StatevectorSampler.default_shots",
        "api_description": "Return the default shots",
        "api_signature": "default_shots(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/statevector_sampler.py"
    },
    {
        "api_name": "seed",
        "full_api_name": "StatevectorSampler.seed",
        "api_description": "Return the seed or Generator object for random number generation.",
        "api_signature": "seed(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/statevector_sampler.py"
    },
    {
        "api_name": "run",
        "full_api_name": "StatevectorSampler.run",
        "api_description": "",
        "api_signature": "run(self, pubs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/statevector_sampler.py"
    },
    {
        "api_name": "_run",
        "full_api_name": "StatevectorSampler._run",
        "api_description": "",
        "api_signature": "_run(self, pubs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/statevector_sampler.py"
    },
    {
        "api_name": "_run_pub",
        "full_api_name": "StatevectorSampler._run_pub",
        "api_description": "",
        "api_signature": "_run_pub(self, pub)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/statevector_sampler.py"
    },
    {
        "api_name": "_preprocess_circuit",
        "full_api_name": "_preprocess_circuit",
        "api_description": "",
        "api_signature": "_preprocess_circuit(circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/statevector_sampler.py"
    },
    {
        "api_name": "_samples_to_packed_array",
        "full_api_name": "_samples_to_packed_array",
        "api_description": "",
        "api_signature": "_samples_to_packed_array(samples, num_bits, indices)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/statevector_sampler.py"
    },
    {
        "api_name": "_final_measurement_mapping",
        "full_api_name": "_final_measurement_mapping",
        "api_description": "Return the final measurement mapping for the circuit.\n\nParameters:\n    circuit: Input quantum circuit.\n\nReturns:\n    Mapping of classical bits to qubits for final measurements.",
        "api_signature": "_final_measurement_mapping(circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/statevector_sampler.py"
    },
    {
        "api_name": "_has_control_flow",
        "full_api_name": "_has_control_flow",
        "api_description": "",
        "api_signature": "_has_control_flow(circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/statevector_sampler.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BackendEstimatorV2.__init__",
        "api_description": "Args:\n    backend: The backend to run the primitive on.\n    options: The options to control the default precision (``default_precision``),\n        the operator grouping (``abelian_grouping``), and\n        the random seed for the simulator (``seed_simulator``).",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_estimator_v2.py"
    },
    {
        "api_name": "options",
        "full_api_name": "BackendEstimatorV2.options",
        "api_description": "Return the options",
        "api_signature": "options(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_estimator_v2.py"
    },
    {
        "api_name": "backend",
        "full_api_name": "BackendEstimatorV2.backend",
        "api_description": "Returns the backend which this sampler object based on.",
        "api_signature": "backend(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_estimator_v2.py"
    },
    {
        "api_name": "run",
        "full_api_name": "BackendEstimatorV2.run",
        "api_description": "",
        "api_signature": "run(self, pubs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_estimator_v2.py"
    },
    {
        "api_name": "_validate_pubs",
        "full_api_name": "BackendEstimatorV2._validate_pubs",
        "api_description": "",
        "api_signature": "_validate_pubs(self, pubs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_estimator_v2.py"
    },
    {
        "api_name": "_run",
        "full_api_name": "BackendEstimatorV2._run",
        "api_description": "",
        "api_signature": "_run(self, pubs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_estimator_v2.py"
    },
    {
        "api_name": "_run_pubs",
        "full_api_name": "BackendEstimatorV2._run_pubs",
        "api_description": "Compute results for pubs that all require the same value of ``shots``.",
        "api_signature": "_run_pubs(self, pubs, shots)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_estimator_v2.py"
    },
    {
        "api_name": "_preprocess_pub",
        "full_api_name": "BackendEstimatorV2._preprocess_pub",
        "api_description": "Converts a pub into a list of bound circuits necessary to estimate all its observables.\n\nThe circuits contain metadata explaining which bindings array index they are with respect to,\nand which measurement basis they are measuring.\n\nArgs:\n    pub: The pub to preprocess.\n\nReturns:\n    The values ``(circuits, bc_param_ind, bc_obs)`` where ``circuits`` are the circuits to\n    execute on the backend, ``bc_param_ind`` are indices of the pub's bindings array and\n    ``bc_obs`` is the observables array, both broadcast to the shape of the pub.",
        "api_signature": "_preprocess_pub(self, pub)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_estimator_v2.py"
    },
    {
        "api_name": "_postprocess_pub",
        "full_api_name": "BackendEstimatorV2._postprocess_pub",
        "api_description": "Computes expectation values (evs) and standard errors (stds).\n\nThe values are stored in arrays broadcast to the shape of the pub.\n\nArgs:\n    pub: The pub to postprocess.\n    expval_map: The map\n    data: The result data of the preprocessing.\n    shots: The number of shots.\n\nReturns:\n    The pub result.",
        "api_signature": "_postprocess_pub(self, pub, expval_map, data, shots)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_estimator_v2.py"
    },
    {
        "api_name": "_bind_and_add_measurements",
        "full_api_name": "BackendEstimatorV2._bind_and_add_measurements",
        "api_description": "Bind the given circuit against each parameter value set, and add necessary measurements\nto each.\n\nArgs:\n    circuit: The (possibly parametric) circuit of interest.\n    parameter_values: An array of parameter value sets that can be applied to the circuit.\n    param_obs_map: A mapping from locations in ``parameter_values`` to a sets of\n        Pauli terms whose expectation values are required in those locations.\n\nReturns:\n    A flat list of circuits sufficient to measure all Pauli terms in the ``param_obs_map``\n    values at the corresponding ``parameter_values`` location, where requisite\n    book-keeping is stored as circuit metadata.",
        "api_signature": "_bind_and_add_measurements(self, circuit, parameter_values, param_obs_map)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_estimator_v2.py"
    },
    {
        "api_name": "_calc_expval_map",
        "full_api_name": "BackendEstimatorV2._calc_expval_map",
        "api_description": "Computes the map of expectation values.\n\nArgs:\n    counts: The counts data.\n    metadata: The metadata.\n\nReturns:\n    The map of expectation values takes a pair of an index of the bindings array and\n    a pauli string as a key and returns the expectation value of the pauli string\n    with the the pub's circuit bound against the parameter value set in the index of\n    the bindings array.",
        "api_signature": "_calc_expval_map(self, counts, metadata)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_estimator_v2.py"
    },
    {
        "api_name": "_create_measurement_circuits",
        "full_api_name": "BackendEstimatorV2._create_measurement_circuits",
        "api_description": "Generate a list of circuits sufficient to estimate each of the given Paulis.\n\nPaulis are divided into qubitwise-commuting subsets to reduce the total circuit count.\nMetadata is attached to circuits in order to remember what each one measures, and\nwhere it belongs in the output.\n\nArgs:\n    circuit: The circuit of interest.\n    observable: Which Pauli terms we would like to observe.\n    param_index: Where to put the data we estimate (only passed to metadata).\n\nReturns:\n    A list of circuits sufficient to estimate each of the given Paulis.",
        "api_signature": "_create_measurement_circuits(self, circuit, observable, param_index)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_estimator_v2.py"
    },
    {
        "api_name": "_measurement_circuit",
        "full_api_name": "_measurement_circuit",
        "api_description": "",
        "api_signature": "_measurement_circuit(num_qubits, pauli)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_estimator_v2.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PrimitiveJob.__init__",
        "api_description": "Args:\n    function: A callable function to execute the job.",
        "api_signature": "__init__(self, function)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/primitive_job.py"
    },
    {
        "api_name": "_submit",
        "full_api_name": "PrimitiveJob._submit",
        "api_description": "",
        "api_signature": "_submit(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/primitive_job.py"
    },
    {
        "api_name": "result",
        "full_api_name": "PrimitiveJob.result",
        "api_description": "",
        "api_signature": "result(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/primitive_job.py"
    },
    {
        "api_name": "status",
        "full_api_name": "PrimitiveJob.status",
        "api_description": "",
        "api_signature": "status(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/primitive_job.py"
    },
    {
        "api_name": "_check_submitted",
        "full_api_name": "PrimitiveJob._check_submitted",
        "api_description": "",
        "api_signature": "_check_submitted(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/primitive_job.py"
    },
    {
        "api_name": "cancel",
        "full_api_name": "PrimitiveJob.cancel",
        "api_description": "",
        "api_signature": "cancel(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/primitive_job.py"
    },
    {
        "api_name": "done",
        "full_api_name": "PrimitiveJob.done",
        "api_description": "",
        "api_signature": "done(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/primitive_job.py"
    },
    {
        "api_name": "running",
        "full_api_name": "PrimitiveJob.running",
        "api_description": "",
        "api_signature": "running(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/primitive_job.py"
    },
    {
        "api_name": "cancelled",
        "full_api_name": "PrimitiveJob.cancelled",
        "api_description": "",
        "api_signature": "cancelled(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/primitive_job.py"
    },
    {
        "api_name": "in_final_state",
        "full_api_name": "PrimitiveJob.in_final_state",
        "api_description": "",
        "api_signature": "in_final_state(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/primitive_job.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Sampler.__init__",
        "api_description": "Args:\n    options: Default options.\n\nRaises:\n    QiskitError: if some classical bits are not used for measurements.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/sampler.py"
    },
    {
        "api_name": "_call",
        "full_api_name": "Sampler._call",
        "api_description": "",
        "api_signature": "_call(self, circuits, parameter_values)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/sampler.py"
    },
    {
        "api_name": "_run",
        "full_api_name": "Sampler._run",
        "api_description": "",
        "api_signature": "_run(self, circuits, parameter_values)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/sampler.py"
    },
    {
        "api_name": "_preprocess_circuit",
        "full_api_name": "Sampler._preprocess_circuit",
        "api_description": "",
        "api_signature": "_preprocess_circuit(circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/sampler.py"
    },
    {
        "api_name": "_run_circuits",
        "full_api_name": "_run_circuits",
        "api_description": "Remove metadata of circuits and run the circuits on a backend.\nArgs:\n    circuits: The circuits\n    backend: The backend\n    monitor: Enable job minotor if True\n    **run_options: run_options\nReturns:\n    The result and the metadata of the circuits",
        "api_signature": "_run_circuits(circuits, backend)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_estimator.py"
    },
    {
        "api_name": "_prepare_counts",
        "full_api_name": "_prepare_counts",
        "api_description": "",
        "api_signature": "_prepare_counts(results)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_estimator.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BackendEstimator.__init__",
        "api_description": "Initialize a new BackendEstimator (V1) instance\n\nArgs:\n    backend: (required) the backend to run the primitive on\n    options: Default options.\n    abelian_grouping: Whether the observable should be grouped into\n        commuting\n    bound_pass_manager: An optional pass manager to run after\n        parameter binding.\n    skip_transpilation: If this is set to True the internal compilation\n        of the input circuits is skipped and the circuit objects\n        will be directly executed when this object is called.",
        "api_signature": "__init__(self, backend, options, abelian_grouping, bound_pass_manager, skip_transpilation)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_estimator.py"
    },
    {
        "api_name": "transpile_options",
        "full_api_name": "BackendEstimator.transpile_options",
        "api_description": "Return the transpiler options for transpiling the circuits.",
        "api_signature": "transpile_options(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_estimator.py"
    },
    {
        "api_name": "set_transpile_options",
        "full_api_name": "BackendEstimator.set_transpile_options",
        "api_description": "Set the transpiler options for transpiler.\nArgs:\n    **fields: The fields to update the options",
        "api_signature": "set_transpile_options(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_estimator.py"
    },
    {
        "api_name": "preprocessed_circuits",
        "full_api_name": "BackendEstimator.preprocessed_circuits",
        "api_description": "Transpiled quantum circuits produced by preprocessing\nReturns:\n    List of the transpiled quantum circuit",
        "api_signature": "preprocessed_circuits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_estimator.py"
    },
    {
        "api_name": "transpiled_circuits",
        "full_api_name": "BackendEstimator.transpiled_circuits",
        "api_description": "Transpiled quantum circuits.\nReturns:\n    List of the transpiled quantum circuit\nRaises:\n    QiskitError: if the instance has been closed.",
        "api_signature": "transpiled_circuits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_estimator.py"
    },
    {
        "api_name": "backend",
        "full_api_name": "BackendEstimator.backend",
        "api_description": "Returns:\n    The backend which this estimator object based on",
        "api_signature": "backend(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_estimator.py"
    },
    {
        "api_name": "_transpile",
        "full_api_name": "BackendEstimator._transpile",
        "api_description": "Split Transpile",
        "api_signature": "_transpile(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_estimator.py"
    },
    {
        "api_name": "_call",
        "full_api_name": "BackendEstimator._call",
        "api_description": "",
        "api_signature": "_call(self, circuits, observables, parameter_values)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_estimator.py"
    },
    {
        "api_name": "_run",
        "full_api_name": "BackendEstimator._run",
        "api_description": "",
        "api_signature": "_run(self, circuits, observables, parameter_values)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_estimator.py"
    },
    {
        "api_name": "_measurement_circuit",
        "full_api_name": "BackendEstimator._measurement_circuit",
        "api_description": "",
        "api_signature": "_measurement_circuit(num_qubits, pauli)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_estimator.py"
    },
    {
        "api_name": "_preprocessing",
        "full_api_name": "BackendEstimator._preprocessing",
        "api_description": "Preprocessing for evaluation of expectation value using pauli rotation gates.",
        "api_signature": "_preprocessing(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_estimator.py"
    },
    {
        "api_name": "_postprocessing",
        "full_api_name": "BackendEstimator._postprocessing",
        "api_description": "Postprocessing for evaluation of expectation value using pauli rotation gates.",
        "api_signature": "_postprocessing(self, result, accum, metadata)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_estimator.py"
    },
    {
        "api_name": "_bound_pass_manager_run",
        "full_api_name": "BackendEstimator._bound_pass_manager_run",
        "api_description": "",
        "api_signature": "_bound_pass_manager_run(self, circuits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_estimator.py"
    },
    {
        "api_name": "_paulis2inds",
        "full_api_name": "_paulis2inds",
        "api_description": "Convert PauliList to diagonal integers.\nThese are integer representations of the binary string with a\n1 where there are Paulis, and 0 where there are identities.",
        "api_signature": "_paulis2inds(paulis)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_estimator.py"
    },
    {
        "api_name": "_parity",
        "full_api_name": "_parity",
        "api_description": "Return the parity of an integer",
        "api_signature": "_parity(integer)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_estimator.py"
    },
    {
        "api_name": "_pauli_expval_with_variance",
        "full_api_name": "_pauli_expval_with_variance",
        "api_description": "Return array of expval and variance pairs for input Paulis.\nNote: All non-identity Pauli's are treated as Z-paulis, assuming\nthat basis rotations have been applied to convert them to the\ndiagonal basis.",
        "api_signature": "_pauli_expval_with_variance(counts, paulis)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_estimator.py"
    },
    {
        "api_name": "_passmanager_for_measurement_circuits",
        "full_api_name": "_passmanager_for_measurement_circuits",
        "api_description": "",
        "api_signature": "_passmanager_for_measurement_circuits(layout, backend)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_estimator.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BackendSampler.__init__",
        "api_description": "Initialize a new BackendSampler (V1) instance\n\nArgs:\n    backend: (required) the backend to run the sampler primitive on\n    options: Default options.\n    bound_pass_manager: An optional pass manager to run after\n        parameter binding.\n    skip_transpilation: If this is set to True the internal compilation\n        of the input circuits is skipped and the circuit objects\n        will be directly executed when this objected is called.\nRaises:\n    ValueError: If backend is not provided",
        "api_signature": "__init__(self, backend, options, bound_pass_manager, skip_transpilation)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_sampler.py"
    },
    {
        "api_name": "preprocessed_circuits",
        "full_api_name": "BackendSampler.preprocessed_circuits",
        "api_description": "Preprocessed quantum circuits produced by preprocessing\nReturns:\n    List of the transpiled quantum circuit\nRaises:\n    QiskitError: if the instance has been closed.",
        "api_signature": "preprocessed_circuits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_sampler.py"
    },
    {
        "api_name": "transpiled_circuits",
        "full_api_name": "BackendSampler.transpiled_circuits",
        "api_description": "Transpiled quantum circuits.\nReturns:\n    List of the transpiled quantum circuit\nRaises:\n    QiskitError: if the instance has been closed.",
        "api_signature": "transpiled_circuits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_sampler.py"
    },
    {
        "api_name": "backend",
        "full_api_name": "BackendSampler.backend",
        "api_description": "Returns:\n    The backend which this sampler object based on",
        "api_signature": "backend(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_sampler.py"
    },
    {
        "api_name": "transpile_options",
        "full_api_name": "BackendSampler.transpile_options",
        "api_description": "Return the transpiler options for transpiling the circuits.",
        "api_signature": "transpile_options(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_sampler.py"
    },
    {
        "api_name": "set_transpile_options",
        "full_api_name": "BackendSampler.set_transpile_options",
        "api_description": "Set the transpiler options for transpiler.\nArgs:\n    **fields: The fields to update the options.\nReturns:\n    self.\nRaises:\n    QiskitError: if the instance has been closed.",
        "api_signature": "set_transpile_options(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_sampler.py"
    },
    {
        "api_name": "_call",
        "full_api_name": "BackendSampler._call",
        "api_description": "",
        "api_signature": "_call(self, circuits, parameter_values)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_sampler.py"
    },
    {
        "api_name": "_postprocessing",
        "full_api_name": "BackendSampler._postprocessing",
        "api_description": "",
        "api_signature": "_postprocessing(self, result, circuits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_sampler.py"
    },
    {
        "api_name": "_transpile",
        "full_api_name": "BackendSampler._transpile",
        "api_description": "",
        "api_signature": "_transpile(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_sampler.py"
    },
    {
        "api_name": "_bound_pass_manager_run",
        "full_api_name": "BackendSampler._bound_pass_manager_run",
        "api_description": "",
        "api_signature": "_bound_pass_manager_run(self, circuits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_sampler.py"
    },
    {
        "api_name": "_run",
        "full_api_name": "BackendSampler._run",
        "api_description": "",
        "api_signature": "_run(self, circuits, parameter_values)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/backend_sampler.py"
    },
    {
        "api_name": "_validate_estimator_args",
        "full_api_name": "_validate_estimator_args",
        "api_description": "Validate run arguments for a reference Estimator.\n\nArgs:\n    circuits: one or more circuit objects.\n    observables: one or more observable objects.\n    parameter_values: concrete parameters to be bound.\n\nReturns:\n    The formatted arguments ``(circuits, observables, parameter_values)``.\n\nRaises:\n    TypeError: If input arguments are invalid types.\n    ValueError: if input arguments are invalid values.",
        "api_signature": "_validate_estimator_args(circuits, observables, parameter_values)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/base/validation.py"
    },
    {
        "api_name": "_validate_sampler_args",
        "full_api_name": "_validate_sampler_args",
        "api_description": "Validate run arguments for a reference Sampler.\n\nArgs:\n    circuits: one or more circuit objects.\n    parameter_values: concrete parameters to be bound.\n\nReturns:\n    The formatted arguments ``(circuits, parameter_values)``.\n\nRaises:\n    TypeError: If input arguments are invalid types.\n    ValueError: if input arguments are invalid values.",
        "api_signature": "_validate_sampler_args(circuits, parameter_values)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/base/validation.py"
    },
    {
        "api_name": "_validate_circuits",
        "full_api_name": "_validate_circuits",
        "api_description": "",
        "api_signature": "_validate_circuits(circuits, requires_measure)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/base/validation.py"
    },
    {
        "api_name": "_validate_parameter_values",
        "full_api_name": "_validate_parameter_values",
        "api_description": "",
        "api_signature": "_validate_parameter_values(parameter_values, default)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/base/validation.py"
    },
    {
        "api_name": "_validate_observables",
        "full_api_name": "_validate_observables",
        "api_description": "",
        "api_signature": "_validate_observables(observables)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/base/validation.py"
    },
    {
        "api_name": "_cross_validate_circuits_parameter_values",
        "full_api_name": "_cross_validate_circuits_parameter_values",
        "api_description": "",
        "api_signature": "_cross_validate_circuits_parameter_values(circuits, parameter_values)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/base/validation.py"
    },
    {
        "api_name": "_cross_validate_circuits_observables",
        "full_api_name": "_cross_validate_circuits_observables",
        "api_description": "",
        "api_signature": "_cross_validate_circuits_observables(circuits, observables)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/base/validation.py"
    },
    {
        "api_name": "_isint",
        "full_api_name": "_isint",
        "api_description": "Check if object is int.",
        "api_signature": "_isint(obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/base/validation.py"
    },
    {
        "api_name": "_isreal",
        "full_api_name": "_isreal",
        "api_description": "Check if object is a real number: int or float except ``\u00b1Inf`` and ``NaN``.",
        "api_signature": "_isreal(obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/base/validation.py"
    },
    {
        "api_name": "_has_measure",
        "full_api_name": "_has_measure",
        "api_description": "",
        "api_signature": "_has_measure(circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/base/validation.py"
    },
    {
        "api_name": "__post_init__",
        "full_api_name": "_BasePrimitiveResult.__post_init__",
        "api_description": "Verify that all fields in any inheriting result dataclass are consistent, after\ninstantiation, with the number of experiments being represented.\n\nThis magic method is specific of `dataclasses.dataclass`, therefore all inheriting\nclasses must have this decorator.\n\nRaises:\n    TypeError: If one of the data fields is not a Sequence or ``numpy.ndarray``.\n    ValueError: Inconsistent number of experiments across data fields.",
        "api_signature": "__post_init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/base/base_result.py"
    },
    {
        "api_name": "_field_names",
        "full_api_name": "_BasePrimitiveResult._field_names",
        "api_description": "Tuple of field names in any inheriting result dataclass.",
        "api_signature": "_field_names(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/base/base_result.py"
    },
    {
        "api_name": "_field_values",
        "full_api_name": "_BasePrimitiveResult._field_values",
        "api_description": "Tuple of field values in any inheriting result dataclass.",
        "api_signature": "_field_values(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/base/base_result.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BaseSamplerV1.__init__",
        "api_description": "Args:\n    options: Default options.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/base/base_sampler.py"
    },
    {
        "api_name": "run",
        "full_api_name": "BaseSamplerV1.run",
        "api_description": "Run the job of the sampling of bitstrings.\n\nArgs:\n    circuits: One of more circuit objects.\n    parameter_values: Parameters to be bound to the circuit.\n    run_options: Backend runtime options used for circuit execution.\n\nReturns:\n    The job object of the result of the sampler. The i-th result corresponds to\n    ``circuits[i]`` evaluated with parameters bound as ``parameter_values[i]``.\n\nRaises:\n    ValueError: Invalid arguments are given.",
        "api_signature": "run(self, circuits, parameter_values)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/base/base_sampler.py"
    },
    {
        "api_name": "_run",
        "full_api_name": "BaseSamplerV1._run",
        "api_description": "",
        "api_signature": "_run(self, circuits, parameter_values)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/base/base_sampler.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BaseSampler.__init__",
        "api_description": "Args:\n    options: Default options.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/base/base_sampler.py"
    },
    {
        "api_name": "run",
        "full_api_name": "BaseSamplerV2.run",
        "api_description": "Run and collect samples from each pub.\n\nArgs:\n    pubs: An iterable of pub-like objects. For example, a list of circuits\n          or tuples ``(circuit, parameter_values)``.\n    shots: The total number of shots to sample for each sampler pub that does\n           not specify its own shots. If ``None``, the primitive's default\n           shots value will be used, which can vary by implementation.\n\nReturns:\n    The job object of Sampler's result.",
        "api_signature": "run(self, pubs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/base/base_sampler.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BaseEstimatorV1.__init__",
        "api_description": "Creating an instance of an Estimator V1, or using one in a ``with`` context opens a session that\nholds resources until the instance is ``close()`` ed or the context is exited.\n\nArgs:\n    options: Default options.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/base/base_estimator.py"
    },
    {
        "api_name": "run",
        "full_api_name": "BaseEstimatorV1.run",
        "api_description": "Run the job of the estimation of expectation value(s).\n\n``circuits``, ``observables``, and ``parameter_values`` should have the same\nlength. The i-th element of the result is the expectation of observable\n\n.. code-block:: python\n\n    obs = observables[i]\n\nfor the state prepared by\n\n.. code-block:: python\n\n    circ = circuits[i]\n\nwith bound parameters\n\n.. code-block:: python\n\n    values = parameter_values[i].\n\nArgs:\n    circuits: one or more circuit objects.\n    observables: one or more observable objects. Several formats are allowed;\n        importantly, ``str`` should follow the string representation format for\n        :class:`~qiskit.quantum_info.Pauli` objects.\n    parameter_values: concrete parameters to be bound.\n    run_options: runtime options used for circuit execution.\n\nReturns:\n    The job object of EstimatorResult.\n\nRaises:\n    TypeError: Invalid argument type given.\n    ValueError: Invalid argument values given.",
        "api_signature": "run(self, circuits, observables, parameter_values)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/base/base_estimator.py"
    },
    {
        "api_name": "_run",
        "full_api_name": "BaseEstimatorV1._run",
        "api_description": "",
        "api_signature": "_run(self, circuits, observables, parameter_values)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/base/base_estimator.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BaseEstimator.__init__",
        "api_description": "Creating an instance of an Estimator, or using one in a ``with`` context opens a session that\nholds resources until the instance is ``close()`` ed or the context is exited.\n\nArgs:\n    options: Default options.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/base/base_estimator.py"
    },
    {
        "api_name": "_make_data_bin",
        "full_api_name": "BaseEstimatorV2._make_data_bin",
        "api_description": "",
        "api_signature": "_make_data_bin(_)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/base/base_estimator.py"
    },
    {
        "api_name": "run",
        "full_api_name": "BaseEstimatorV2.run",
        "api_description": "Estimate expectation values for each provided pub (Primitive Unified Bloc).\n\nArgs:\n    pubs: An iterable of pub-like objects, such as tuples ``(circuit, observables)``\n          or ``(circuit, observables, parameter_values)``.\n    precision: The target precision for expectation value estimates of each\n               run Estimator Pub that does not specify its own precision. If None\n               the estimator's default precision value will be used.\n\nReturns:\n    A job object that contains results.",
        "api_signature": "run(self, pubs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/base/base_estimator.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BasePrimitiveJob.__init__",
        "api_description": "Initializes the primitive job.\n\nArgs:\n    job_id: A unique id in the context of the primitive used to run the job.\n    kwargs: Any key value metadata to associate with this job.",
        "api_signature": "__init__(self, job_id)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/base/base_primitive_job.py"
    },
    {
        "api_name": "job_id",
        "full_api_name": "BasePrimitiveJob.job_id",
        "api_description": "Return a unique id identifying the job.",
        "api_signature": "job_id(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/base/base_primitive_job.py"
    },
    {
        "api_name": "result",
        "full_api_name": "BasePrimitiveJob.result",
        "api_description": "Return the results of the job.",
        "api_signature": "result(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/base/base_primitive_job.py"
    },
    {
        "api_name": "status",
        "full_api_name": "BasePrimitiveJob.status",
        "api_description": "Return the status of the job.",
        "api_signature": "status(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/base/base_primitive_job.py"
    },
    {
        "api_name": "done",
        "full_api_name": "BasePrimitiveJob.done",
        "api_description": "Return whether the job has successfully run.",
        "api_signature": "done(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/base/base_primitive_job.py"
    },
    {
        "api_name": "running",
        "full_api_name": "BasePrimitiveJob.running",
        "api_description": "Return whether the job is actively running.",
        "api_signature": "running(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/base/base_primitive_job.py"
    },
    {
        "api_name": "cancelled",
        "full_api_name": "BasePrimitiveJob.cancelled",
        "api_description": "Return whether the job has been cancelled.",
        "api_signature": "cancelled(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/base/base_primitive_job.py"
    },
    {
        "api_name": "in_final_state",
        "full_api_name": "BasePrimitiveJob.in_final_state",
        "api_description": "Return whether the job is in a final job state such as ``DONE`` or ``ERROR``.",
        "api_signature": "in_final_state(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/base/base_primitive_job.py"
    },
    {
        "api_name": "cancel",
        "full_api_name": "BasePrimitiveJob.cancel",
        "api_description": "Attempt to cancel the job.",
        "api_signature": "cancel(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/base/base_primitive_job.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BasePrimitive.__init__",
        "api_description": "",
        "api_signature": "__init__(self, options)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/base/base_primitive.py"
    },
    {
        "api_name": "options",
        "full_api_name": "BasePrimitive.options",
        "api_description": "Return options values for the estimator.\n\nReturns:\n    options",
        "api_signature": "options(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/base/base_primitive.py"
    },
    {
        "api_name": "set_options",
        "full_api_name": "BasePrimitive.set_options",
        "api_description": "Set options values for the estimator.\n\nArgs:\n    **fields: The fields to update the options",
        "api_signature": "set_options(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/base/base_primitive.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PubResult.__init__",
        "api_description": "Initialize a pub result.\n\nArgs:\n    data: Result data.\n    metadata: Metadata specific to this pub. Keys are expected to be strings.",
        "api_signature": "__init__(self, data, metadata)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/pub_result.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "PubResult.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/pub_result.py"
    },
    {
        "api_name": "data",
        "full_api_name": "PubResult.data",
        "api_description": "Result data for the pub.",
        "api_signature": "data(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/pub_result.py"
    },
    {
        "api_name": "metadata",
        "full_api_name": "PubResult.metadata",
        "api_description": "Metadata for the pub.",
        "api_signature": "metadata(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/pub_result.py"
    },
    {
        "api_name": "_min_num_bytes",
        "full_api_name": "_min_num_bytes",
        "api_description": "Return the minimum number of bytes needed to store ``num_bits``.",
        "api_signature": "_min_num_bytes(num_bits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/bit_array.py"
    },
    {
        "api_name": "_unpack",
        "full_api_name": "_unpack",
        "api_description": "",
        "api_signature": "_unpack(bit_array)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/bit_array.py"
    },
    {
        "api_name": "_pack",
        "full_api_name": "_pack",
        "api_description": "",
        "api_signature": "_pack(arr)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/bit_array.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BitArray.__init__",
        "api_description": "Args:\n    array: The ``uint8`` data array.\n    num_bits: How many bit are in each outcome.\n\nRaises:\n    TypeError: If the input is not a NumPy array with type ``numpy.uint8``.\n    ValueError: If the input array has fewer than two axes, or the size of the last axis\n        is not the smallest number of bytes that can contain ``num_bits``.",
        "api_signature": "__init__(self, array, num_bits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/bit_array.py"
    },
    {
        "api_name": "_prepare_broadcastable",
        "full_api_name": "BitArray._prepare_broadcastable",
        "api_description": "Validation and broadcasting of two bit arrays before element-wise binary operation.",
        "api_signature": "_prepare_broadcastable(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/bit_array.py"
    },
    {
        "api_name": "__and__",
        "full_api_name": "BitArray.__and__",
        "api_description": "",
        "api_signature": "__and__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/bit_array.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "BitArray.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/bit_array.py"
    },
    {
        "api_name": "__invert__",
        "full_api_name": "BitArray.__invert__",
        "api_description": "",
        "api_signature": "__invert__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/bit_array.py"
    },
    {
        "api_name": "__or__",
        "full_api_name": "BitArray.__or__",
        "api_description": "",
        "api_signature": "__or__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/bit_array.py"
    },
    {
        "api_name": "__xor__",
        "full_api_name": "BitArray.__xor__",
        "api_description": "",
        "api_signature": "__xor__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/bit_array.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "BitArray.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/bit_array.py"
    },
    {
        "api_name": "__getitem__",
        "full_api_name": "BitArray.__getitem__",
        "api_description": "",
        "api_signature": "__getitem__(self, indices)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/bit_array.py"
    },
    {
        "api_name": "array",
        "full_api_name": "BitArray.array",
        "api_description": "The raw NumPy array of data.",
        "api_signature": "array(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/bit_array.py"
    },
    {
        "api_name": "num_bits",
        "full_api_name": "BitArray.num_bits",
        "api_description": "The number of bits in the register that this array stores data for.\n\nFor example, a ``ClassicalRegister(5, \"meas\")`` would result in ``num_bits=5``.",
        "api_signature": "num_bits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/bit_array.py"
    },
    {
        "api_name": "num_shots",
        "full_api_name": "BitArray.num_shots",
        "api_description": "The number of shots sampled from the register in each configuration.\n\nMore precisely, the length of the second last axis of :attr:`~.array`.",
        "api_signature": "num_shots(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/bit_array.py"
    },
    {
        "api_name": "_bytes_to_bitstring",
        "full_api_name": "BitArray._bytes_to_bitstring",
        "api_description": "",
        "api_signature": "_bytes_to_bitstring(data, num_bits, mask)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/bit_array.py"
    },
    {
        "api_name": "_bytes_to_int",
        "full_api_name": "BitArray._bytes_to_int",
        "api_description": "",
        "api_signature": "_bytes_to_int(data, mask)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/bit_array.py"
    },
    {
        "api_name": "_get_counts",
        "full_api_name": "BitArray._get_counts",
        "api_description": "",
        "api_signature": "_get_counts(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/bit_array.py"
    },
    {
        "api_name": "bitcount",
        "full_api_name": "BitArray.bitcount",
        "api_description": "Compute the number of ones appearing in the binary representation of each shot.\n\nReturns:\n    A ``numpy.uint64``-array with shape ``(*shape, num_shots)``.",
        "api_signature": "bitcount(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/bit_array.py"
    },
    {
        "api_name": "from_bool_array",
        "full_api_name": "BitArray.from_bool_array",
        "api_description": "Construct a new bit array from an array of bools.\n\nArgs:\n    array: The array to convert, with \"bitstrings\" along the last axis.\n    order: One of ``\"big\"`` or ``\"little\"``, indicating whether ``array[..., 0]``\n        correspond to the most significant bits or the least significant bits of each\n        bitstring, respectively.\n\nReturns:\n    A new bit array.",
        "api_signature": "from_bool_array(array, order)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/bit_array.py"
    },
    {
        "api_name": "from_counts",
        "full_api_name": "BitArray.from_counts",
        "api_description": "Construct a new bit array from one or more ``Counts``-like objects.\n\nThe ``counts`` can have keys that are (uniformly) integers, hexstrings, or bitstrings.\nTheir values represent numbers of occurrences of that value.\n\nArgs:\n    counts: One or more counts-like mappings with the same number of shots.\n    num_bits: The desired number of bits per shot. If unset, the biggest value found sets\n        this value, with a minimum of one bit.\n\nReturns:\n    A new bit array with shape ``()`` for single input counts, or ``(N,)`` for an iterable\n    of :math:`N` counts.\n\nRaises:\n    ValueError: If different mappings have different numbers of shots.\n    ValueError: If no counts dictionaries are supplied.",
        "api_signature": "from_counts(counts, num_bits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/bit_array.py"
    },
    {
        "api_name": "from_samples",
        "full_api_name": "BitArray.from_samples",
        "api_description": "Construct a new bit array from an iterable of bitstrings, hexstrings, or integers.\n\nAll samples are assumed to be integers if the first one is. Strings are all assumed to be\nbitstrings whenever the first string doesn't start with ``\"0x\"``.\n\nConsider pairing this method with :meth:`~reshape` if your samples represent nested data.\n\nArgs:\n    samples: A list of bitstrings, a list of integers, or a list of hexstrings.\n    num_bits: The desired number of bits per sample. If unset, the biggest sample provided\n        is used to determine this value, with a minimum of one bit.\n\nReturns:\n    A new bit array.\n\nRaises:\n    ValueError: If no strings are given.",
        "api_signature": "from_samples(samples, num_bits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/bit_array.py"
    },
    {
        "api_name": "get_counts",
        "full_api_name": "BitArray.get_counts",
        "api_description": "Return a counts dictionary with bitstring keys.\n\nArgs:\n    loc: Which entry of this array to return a dictionary for. If ``None``, counts from\n        all positions in this array are unioned together.\n\nReturns:\n    A dictionary mapping bitstrings to the number of occurrences of that bitstring.",
        "api_signature": "get_counts(self, loc)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/bit_array.py"
    },
    {
        "api_name": "get_int_counts",
        "full_api_name": "BitArray.get_int_counts",
        "api_description": "Return a counts dictionary, where bitstrings are stored as ``int``\\s.\n\nArgs:\n    loc: Which entry of this array to return a dictionary for. If ``None``, counts from\n        all positions in this array are unioned together.\n\nReturns:\n    A dictionary mapping ``ints`` to the number of occurrences of that ``int``.",
        "api_signature": "get_int_counts(self, loc)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/bit_array.py"
    },
    {
        "api_name": "get_bitstrings",
        "full_api_name": "BitArray.get_bitstrings",
        "api_description": "Return a list of bitstrings.\n\nArgs:\n    loc: Which entry of this array to return a dictionary for. If ``None``, counts from\n        all positions in this array are unioned together.\n\nReturns:\n    A list of bitstrings.",
        "api_signature": "get_bitstrings(self, loc)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/bit_array.py"
    },
    {
        "api_name": "reshape",
        "full_api_name": "BitArray.reshape",
        "api_description": "Return a new reshaped bit array.\n\nThe :attr:`~num_shots` axis is either included or excluded from the reshaping procedure\ndepending on which picture the new shape is compatible with. For example, for a bit array\nwith shape ``(20, 5)`` and ``64`` shots, a reshape to ``(100,)`` would leave the\nnumber of shots intact, whereas a reshape to ``(200, 32)`` would change the number of\nshots to ``32``.\n\nArgs:\n    *shape: The new desired shape.\n\nReturns:\n    A new bit array.\n\nRaises:\n    ValueError: If the size corresponding to your new shape is not equal to either\n        :attr:`~size`, or the product of :attr:`~size` and :attr:`~num_shots`.",
        "api_signature": "reshape(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/bit_array.py"
    },
    {
        "api_name": "transpose",
        "full_api_name": "BitArray.transpose",
        "api_description": "Return a bit array with axes transposed.\n\nArgs:\n    axes: None, tuple of ints or n ints. See `ndarray.transpose\n        <https://numpy.org/doc/stable/reference/generated/\n        numpy.ndarray.transpose.html#numpy.ndarray.transpose>`_\n        for the details.\n\nReturns:\n    BitArray: A bit array with axes permuted.\n\nRaises:\n    ValueError: If ``axes`` don't match this bit array.\n    ValueError: If ``axes`` includes any indices that are out of bounds.",
        "api_signature": "transpose(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/bit_array.py"
    },
    {
        "api_name": "slice_bits",
        "full_api_name": "BitArray.slice_bits",
        "api_description": "Return a bit array sliced along the bit axis of some indices of interest.\n\n.. note::\n\n    The convention used by this method is that the index ``0`` corresponds to\n    the least-significant bit in the :attr:`~array`, or equivalently\n    the right-most bitstring entry as returned by\n    :meth:`~get_counts` or :meth:`~get_bitstrings`, etc.\n\n    If this bit array was produced by a sampler, then an index ``i`` corresponds to the\n    :class:`~.ClassicalRegister` location ``creg[i]``.\n\nArgs:\n    indices: The bit positions of interest to slice along.\n\nReturns:\n    A bit array sliced along the bit axis.\n\nRaises:\n    IndexError: If there are any invalid indices of the bit axis.",
        "api_signature": "slice_bits(self, indices)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/bit_array.py"
    },
    {
        "api_name": "slice_shots",
        "full_api_name": "BitArray.slice_shots",
        "api_description": "Return a bit array sliced along the shots axis of some indices of interest.\n\nArgs:\n    indices: The shots positions of interest to slice along.\n\nReturns:\n    A bit array sliced along the shots axis.\n\nRaises:\n    IndexError: If there are any invalid indices of the shots axis.",
        "api_signature": "slice_shots(self, indices)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/bit_array.py"
    },
    {
        "api_name": "postselect",
        "full_api_name": "BitArray.postselect",
        "api_description": "Post-select this bit array based on sliced equality with a given bitstring.\n\n.. note::\n    If this bit array contains any shape axes, it is first flattened into a long list of shots\n    before applying post-selection. This is done because :class:`~BitArray` cannot handle\n    ragged numbers of shots across axes.\n\nArgs:\n    indices: A list of the indices of the cbits on which to postselect.\n        If this bit array was produced by a sampler, then an index ``i`` corresponds to the\n        :class:`~.ClassicalRegister` location ``creg[i]`` (as in :meth:`~slice_bits`).\n        Negative indices are allowed.\n\n    selection: A list of binary values (will be cast to ``bool``) of length matching\n        ``indices``, with ``indices[i]`` corresponding to ``selection[i]``. Shots will be\n        discarded unless all cbits specified by ``indices`` have the values given by\n        ``selection``.\n\nReturns:\n    A new bit array with ``shape=(), num_bits=data.num_bits, num_shots<=data.num_shots``.\n\nRaises:\n    IndexError: If ``max(indices)`` is greater than or equal to :attr:`num_bits`.\n    IndexError: If ``min(indices)`` is less than negative :attr:`num_bits`.\n    ValueError: If the lengths of ``selection`` and ``indices`` do not match.",
        "api_signature": "postselect(self, indices, selection)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/bit_array.py"
    },
    {
        "api_name": "expectation_values",
        "full_api_name": "BitArray.expectation_values",
        "api_description": "Compute the expectation values of the provided observables, broadcasted against\nthis bit array.\n\n.. note::\n\n    This method returns the real part of the expectation value even if\n    the operator has complex coefficients due to the specification of\n    :func:`~.sampled_expectation_value`.\n\nArgs:\n    observables: The observable(s) to take the expectation value of.\n    Must have a shape broadcastable with with this bit array and\n    the same number of qubits as the number of bits of this bit array.\n    The observables must be diagonal (I, Z, 0 or 1) too.\n\nReturns:\n    An array of expectation values whose shape is the broadcast shape of ``observables``\n    and this bit array.\n\nRaises:\n    ValueError: If the provided observables does not have a shape broadcastable with\n        this bit array.\n    ValueError: If the provided observables does not have the same number of qubits as\n        the number of bits of this bit array.\n    ValueError: If the provided observables are not diagonal.",
        "api_signature": "expectation_values(self, observables)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/bit_array.py"
    },
    {
        "api_name": "concatenate",
        "full_api_name": "BitArray.concatenate",
        "api_description": "Join a sequence of bit arrays along an existing axis.\n\nArgs:\n    bit_arrays: The bit arrays must have (1) the same number of bits,\n        (2) the same number of shots, and\n        (3) the same shape, except in the dimension corresponding to axis\n        (the first, by default).\n    axis: The axis along which the arrays will be joined. Default is 0.\n\nReturns:\n    The concatenated bit array.\n\nRaises:\n    ValueError: If the sequence of bit arrays is empty.\n    ValueError: If any bit arrays has a different number of bits.\n    ValueError: If any bit arrays has a different number of shots.\n    ValueError: If any bit arrays has a different number of dimensions.",
        "api_signature": "concatenate(bit_arrays, axis)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/bit_array.py"
    },
    {
        "api_name": "concatenate_shots",
        "full_api_name": "BitArray.concatenate_shots",
        "api_description": "Join a sequence of bit arrays along the shots axis.\n\nArgs:\n    bit_arrays: The bit arrays must have (1) the same number of bits,\n        and (2) the same shape.\n\nReturns:\n    The stacked bit array.\n\nRaises:\n    ValueError: If the sequence of bit arrays is empty.\n    ValueError: If any bit arrays has a different number of bits.\n    ValueError: If any bit arrays has a different shape.",
        "api_signature": "concatenate_shots(bit_arrays)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/bit_array.py"
    },
    {
        "api_name": "concatenate_bits",
        "full_api_name": "BitArray.concatenate_bits",
        "api_description": "Join a sequence of bit arrays along the bits axis.\n\n.. note::\n    This method is equivalent to per-shot bitstring concatenation.\n\nArgs:\n    bit_arrays: Bit arrays that have (1) the same number of shots,\n        and (2) the same shape.\n\nReturns:\n    The stacked bit array.\n\nRaises:\n    ValueError: If the sequence of bit arrays is empty.\n    ValueError: If any bit arrays has a different number of shots.\n    ValueError: If any bit arrays has a different shape.",
        "api_signature": "concatenate_bits(bit_arrays)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/bit_array.py"
    },
    {
        "api_name": "shape",
        "full_api_name": "Shaped.shape",
        "api_description": "The array shape of this object.",
        "api_signature": "shape(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/shape.py"
    },
    {
        "api_name": "ndim",
        "full_api_name": "Shaped.ndim",
        "api_description": "The number of array dimensions of this object.",
        "api_signature": "ndim(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/shape.py"
    },
    {
        "api_name": "size",
        "full_api_name": "Shaped.size",
        "api_description": "The total dimension of this object, i.e. the product of the entries of :attr:`~shape`.",
        "api_signature": "size(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/shape.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "ShapedMixin.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/shape.py"
    },
    {
        "api_name": "shape",
        "full_api_name": "ShapedMixin.shape",
        "api_description": "",
        "api_signature": "shape(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/shape.py"
    },
    {
        "api_name": "ndim",
        "full_api_name": "ShapedMixin.ndim",
        "api_description": "",
        "api_signature": "ndim(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/shape.py"
    },
    {
        "api_name": "size",
        "full_api_name": "ShapedMixin.size",
        "api_description": "",
        "api_signature": "size(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/shape.py"
    },
    {
        "api_name": "array_coerce",
        "full_api_name": "array_coerce",
        "api_description": "Coerce the input into an object with a shape attribute.\n\nCopies are avoided.\n\nArgs:\n    arr: The object to coerce.\n\nReturns:\n    Something that is :class:`~Shaped`, and always ``numpy.ndarray`` if the input is not\n    already :class:`~Shaped`.",
        "api_signature": "array_coerce(arr)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/shape.py"
    },
    {
        "api_name": "_flatten_to_ints",
        "full_api_name": "_flatten_to_ints",
        "api_description": "Yield one integer at a time.\n\nArgs:\n    arg: Integers or iterables of integers, possibly nested, to be yielded.\n\nYields:\n    The provided integers in depth-first recursive order.\n\nRaises:\n    ValueError: If an input is not an iterable or an integer.",
        "api_signature": "_flatten_to_ints(arg)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/shape.py"
    },
    {
        "api_name": "shape_tuple",
        "full_api_name": "shape_tuple",
        "api_description": "Flatten the input into a single tuple of integers, preserving order.\n\nArgs:\n    shapes: Integers or iterables of integers, possibly nested.\n\nReturns:\n    A tuple of integers.\n\nRaises:\n    ValueError: If some member of ``shapes`` is not an integer or iterable.",
        "api_signature": "shape_tuple()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/shape.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SamplerPub.__init__",
        "api_description": "Initialize a sampler pub.\n\nArgs:\n    circuit: A quantum circuit.\n    parameter_values: A bindings array.\n    shots: A specific number of shots to run with. This value takes\n        precedence over any value owed by or supplied to a sampler.\n    validate: If ``True``, the input data is validated during initialization.",
        "api_signature": "__init__(self, circuit, parameter_values, shots, validate)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/sampler_pub.py"
    },
    {
        "api_name": "circuit",
        "full_api_name": "SamplerPub.circuit",
        "api_description": "A quantum circuit.",
        "api_signature": "circuit(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/sampler_pub.py"
    },
    {
        "api_name": "parameter_values",
        "full_api_name": "SamplerPub.parameter_values",
        "api_description": "A bindings array.",
        "api_signature": "parameter_values(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/sampler_pub.py"
    },
    {
        "api_name": "shots",
        "full_api_name": "SamplerPub.shots",
        "api_description": "An specific number of shots to run with (optional).\n\nThis value takes precedence over any value owed by or supplied to a sampler.",
        "api_signature": "shots(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/sampler_pub.py"
    },
    {
        "api_name": "coerce",
        "full_api_name": "SamplerPub.coerce",
        "api_description": "Coerce a :class:`~.SamplerPubLike` object into a :class:`~.SamplerPub` instance.\n\nArgs:\n    pub: An object to coerce.\n    shots: An optional default number of shots to use if not\n           already specified by the pub-like object.\n\nReturns:\n    A coerced sampler pub.",
        "api_signature": "coerce(cls, pub, shots)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/sampler_pub.py"
    },
    {
        "api_name": "validate",
        "full_api_name": "SamplerPub.validate",
        "api_description": "Validate the pub.",
        "api_signature": "validate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/sampler_pub.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "EstimatorPub.__init__",
        "api_description": "Initialize an estimator pub.\n\nArgs:\n    circuit: A quantum circuit.\n    observables: An observables array.\n    parameter_values: A bindings array, if the circuit is parametric.\n    precision: An optional target precision for expectation value estimates.\n    validate: Whether to validate arguments during initialization.\n\nRaises:\n    ValueError: If the ``observables`` and ``parameter_values`` are not broadcastable, that\n        is, if their shapes, when right-aligned, do not agree or equal 1.",
        "api_signature": "__init__(self, circuit, observables, parameter_values, precision, validate)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/estimator_pub.py"
    },
    {
        "api_name": "circuit",
        "full_api_name": "EstimatorPub.circuit",
        "api_description": "A quantum circuit.",
        "api_signature": "circuit(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/estimator_pub.py"
    },
    {
        "api_name": "observables",
        "full_api_name": "EstimatorPub.observables",
        "api_description": "An observables array.",
        "api_signature": "observables(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/estimator_pub.py"
    },
    {
        "api_name": "parameter_values",
        "full_api_name": "EstimatorPub.parameter_values",
        "api_description": "A bindings array.",
        "api_signature": "parameter_values(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/estimator_pub.py"
    },
    {
        "api_name": "precision",
        "full_api_name": "EstimatorPub.precision",
        "api_description": "The target precision for expectation value estimates (optional).",
        "api_signature": "precision(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/estimator_pub.py"
    },
    {
        "api_name": "coerce",
        "full_api_name": "EstimatorPub.coerce",
        "api_description": "Coerce :class:`~.EstimatorPubLike` into :class:`~.EstimatorPub`.\n\nArgs:\n    pub: A compatible object for coercion.\n    precision: an optional default precision to use if not\n               already specified by the pub-like object.\n\nReturns:\n    An estimator pub.",
        "api_signature": "coerce(cls, pub, precision)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/estimator_pub.py"
    },
    {
        "api_name": "validate",
        "full_api_name": "EstimatorPub.validate",
        "api_description": "Validate the pub.",
        "api_signature": "validate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/estimator_pub.py"
    },
    {
        "api_name": "_value_repr",
        "full_api_name": "_value_repr",
        "api_description": "Helper function for :meth:`DataBin.__repr__`.",
        "api_signature": "_value_repr(value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/data_bin.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "DataBin.__init__",
        "api_description": "Args:\n    data: Name/value data to place in the data bin.\n    shape: The leading shape common to all entries in the data bin. This defaults to\n        the trivial leading shape of ``()`` that is compatible with all objects.\n\nRaises:\n    ValueError: If a name overlaps with a method name on this class.\n    ValueError: If some value is inconsistent with the provided shape.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/data_bin.py"
    },
    {
        "api_name": "__len__",
        "full_api_name": "DataBin.__len__",
        "api_description": "",
        "api_signature": "__len__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/data_bin.py"
    },
    {
        "api_name": "__setattr__",
        "full_api_name": "DataBin.__setattr__",
        "api_description": "",
        "api_signature": "__setattr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/data_bin.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "DataBin.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/data_bin.py"
    },
    {
        "api_name": "__getitem__",
        "full_api_name": "DataBin.__getitem__",
        "api_description": "",
        "api_signature": "__getitem__(self, key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/data_bin.py"
    },
    {
        "api_name": "__contains__",
        "full_api_name": "DataBin.__contains__",
        "api_description": "",
        "api_signature": "__contains__(self, key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/data_bin.py"
    },
    {
        "api_name": "__iter__",
        "full_api_name": "DataBin.__iter__",
        "api_description": "",
        "api_signature": "__iter__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/data_bin.py"
    },
    {
        "api_name": "keys",
        "full_api_name": "DataBin.keys",
        "api_description": "Return a view of field names.",
        "api_signature": "keys(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/data_bin.py"
    },
    {
        "api_name": "values",
        "full_api_name": "DataBin.values",
        "api_description": "Return a view of values.",
        "api_signature": "values(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/data_bin.py"
    },
    {
        "api_name": "items",
        "full_api_name": "DataBin.items",
        "api_description": "Return a view of field names and values",
        "api_signature": "items(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/data_bin.py"
    },
    {
        "api_name": "_FIELDS",
        "full_api_name": "DataBin._FIELDS",
        "api_description": "",
        "api_signature": "_FIELDS(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/data_bin.py"
    },
    {
        "api_name": "_FIELD_TYPES",
        "full_api_name": "DataBin._FIELD_TYPES",
        "api_description": "",
        "api_signature": "_FIELD_TYPES(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/data_bin.py"
    },
    {
        "api_name": "_SHAPE",
        "full_api_name": "DataBin._SHAPE",
        "api_description": "",
        "api_signature": "_SHAPE(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/data_bin.py"
    },
    {
        "api_name": "make_data_bin",
        "full_api_name": "make_data_bin",
        "api_description": "Return the :class:`~DataBin` type.\n\n.. note::\n    This class used to return a subclass of :class:`~DataBin`. However, that caused confusion\n    and didn't have a useful purpose. Several internal projects made use of this internal\n    function prior to qiskit 1.1. This function will be removed once these internal projects\n    have made the appropriate changes.\n\nArgs:\n    fields: Tuples ``(name, type)`` specifying the attributes of the returned class.\n    shape: The intended shape of every attribute of this class.\n\nReturns:\n    The :class:`DataBin` type.",
        "api_signature": "make_data_bin(fields, shape)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/data_bin.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BindingsArray.__init__",
        "api_description": "Initialize a :class:`~.BindingsArray`.\n\nThe ``shape`` argument does not need to be provided whenever it can unambiguously\nbe inferred from the provided arrays. Ambiguity arises whenever the key of an entry of\n``data`` contains only one parameter and the corresponding array's shape ends in a one.\nIn this case, it can't be decided whether that one is an index over parameters, or whether\nit should be incorporated in :attr:`~shape`.\n\nSince :class:`~.Parameter` objects are only allowed to represent float values, this\nclass casts all given values to float. If an incompatible dtype is given, such as complex\nnumbers, a ``TypeError`` will be raised.\n\nArgs:\n    data: A mapping from one or more parameters to arrays of values to bind\n        them to, where the last axis is over parameters.\n    shape: The leading shape of every array in these bindings.\n\nRaises:\n    ValueError: If all inputs are ``None``.\n    ValueError: If the shape cannot be automatically inferred from the arrays, or if there\n        is some inconsistency in the shape of the given arrays.\n    TypeError: If some of the vaules can't be cast to a float type.",
        "api_signature": "__init__(self, data, shape)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/bindings_array.py"
    },
    {
        "api_name": "__getitem__",
        "full_api_name": "BindingsArray.__getitem__",
        "api_description": "",
        "api_signature": "__getitem__(self, args)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/bindings_array.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "BindingsArray.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/bindings_array.py"
    },
    {
        "api_name": "data",
        "full_api_name": "BindingsArray.data",
        "api_description": "The keyword values of this array.",
        "api_signature": "data(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/bindings_array.py"
    },
    {
        "api_name": "num_parameters",
        "full_api_name": "BindingsArray.num_parameters",
        "api_description": "The total number of parameters.",
        "api_signature": "num_parameters(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/bindings_array.py"
    },
    {
        "api_name": "as_array",
        "full_api_name": "BindingsArray.as_array",
        "api_description": "Return the contents of this bindings array as a single NumPy array.\n\nThe parameters are indexed along the last dimension of the returned array.\n\nParameters:\n    parameters: Optional parameters that determine the order of the output.\n\nReturns:\n    This bindings array as a single NumPy array.\n\nRaises:\n    ValueError: If ``parameters`` are provided, but do not match those found in ``data``.",
        "api_signature": "as_array(self, parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/bindings_array.py"
    },
    {
        "api_name": "bind",
        "full_api_name": "BindingsArray.bind",
        "api_description": "Return a new circuit bound to the values at the provided index.\n\nArgs:\n    circuit: The circuit to bind.\n    loc: A tuple of indices, on for each dimension of this array.\n\nReturns:\n    The bound circuit.\n\nRaises:\n    ValueError: If the index doesn't have the right number of values.",
        "api_signature": "bind(self, circuit, loc)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/bindings_array.py"
    },
    {
        "api_name": "bind_all",
        "full_api_name": "BindingsArray.bind_all",
        "api_description": "Return an object array of bound circuits with the same shape.\n\nArgs:\n    circuit: The circuit to bind.\n\nReturns:\n    An object array of the same shape containing all bound circuits.",
        "api_signature": "bind_all(self, circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/bindings_array.py"
    },
    {
        "api_name": "ravel",
        "full_api_name": "BindingsArray.ravel",
        "api_description": "Return a new :class:`~BindingsArray` with one dimension.\n\nThe returned bindings array has a :attr:`shape` given by ``(size, )``, where the size is the\n:attr:`~size` of this bindings array.\n\nReturns:\n    A new bindings array.",
        "api_signature": "ravel(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/bindings_array.py"
    },
    {
        "api_name": "reshape",
        "full_api_name": "BindingsArray.reshape",
        "api_description": "Return a new :class:`~BindingsArray` with a different shape.\n\nThis results in a new view of the same arrays.\n\nArgs:\n    shape: The shape of the returned bindings array.\n\nReturns:\n    A new bindings array.\n\nRaises:\n    ValueError: If the provided shape has a different product than the current size.",
        "api_signature": "reshape(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/bindings_array.py"
    },
    {
        "api_name": "coerce",
        "full_api_name": "BindingsArray.coerce",
        "api_description": "Coerce an input that is :class:`~BindingsArrayLike` into a new :class:`~BindingsArray`.\n\nArgs:\n    bindings_array: An object to be bindings array.\n\nReturns:\n    A new bindings array.",
        "api_signature": "coerce(cls, bindings_array)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/bindings_array.py"
    },
    {
        "api_name": "validate",
        "full_api_name": "BindingsArray.validate",
        "api_description": "Validate the consistency in bindings_array.",
        "api_signature": "validate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/bindings_array.py"
    },
    {
        "api_name": "_standardize_shape",
        "full_api_name": "_standardize_shape",
        "api_description": "Return ``val`` or ``val[..., None]``.\n\nArgs:\n    val: The array whose shape to standardize.\n    shape: The shape to standardize to.\n\nReturns:\n    An array with one more dimension than ``len(shape)``, and whose leading dimensions match\n    ``shape``.\n\nRaises:\n    ValueError: If the leading shape of ``val`` does not match the ``shape``.",
        "api_signature": "_standardize_shape(val, shape)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/bindings_array.py"
    },
    {
        "api_name": "_infer_shape",
        "full_api_name": "_infer_shape",
        "api_description": "Return a shape tuple that consistently defines the leading dimensions of all arrays.\n\nArgs:\n    data: A mapping from tuples to arrays, where the length of each tuple should match the\n        last dimension of the corresponding array.\n\nReturns:\n    A shape tuple that matches the leading dimension of every array.\n\nRaises:\n    ValueError: If this cannot be done unambiguously.",
        "api_signature": "_infer_shape(data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/bindings_array.py"
    },
    {
        "api_name": "examine_array",
        "full_api_name": "examine_array",
        "api_description": "",
        "api_signature": "examine_array()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/bindings_array.py"
    },
    {
        "api_name": "_format_key",
        "full_api_name": "_format_key",
        "api_description": "",
        "api_signature": "_format_key(key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/bindings_array.py"
    },
    {
        "api_name": "_param_name",
        "full_api_name": "_param_name",
        "api_description": "",
        "api_signature": "_param_name(param)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/bindings_array.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ObservablesArray.__init__",
        "api_description": "Initialize an observables array.\n\nArgs:\n    observables: An array-like of basis observable compatible objects.\n    copy: Specify the ``copy`` kwarg of the :func:`.object_array` function\n        when initializing observables.\n    validate: If true, coerce entries into the internal format and validate them. If false,\n        the input should already be an array-like.\n\nRaises:\n    ValueError: If ``validate=True`` and the input observables is not valid.",
        "api_signature": "__init__(self, observables, copy, validate)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/observables_array.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "ObservablesArray.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/observables_array.py"
    },
    {
        "api_name": "tolist",
        "full_api_name": "ObservablesArray.tolist",
        "api_description": "Convert to a nested list",
        "api_signature": "tolist(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/observables_array.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "ObservablesArray.__array__",
        "api_description": "Convert to an Numpy.ndarray",
        "api_signature": "__array__(self, dtype, copy)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/observables_array.py"
    },
    {
        "api_name": "__getitem__",
        "full_api_name": "ObservablesArray.__getitem__",
        "api_description": "",
        "api_signature": "__getitem__(self, args)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/observables_array.py"
    },
    {
        "api_name": "__getitem__",
        "full_api_name": "ObservablesArray.__getitem__",
        "api_description": "",
        "api_signature": "__getitem__(self, args)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/observables_array.py"
    },
    {
        "api_name": "__getitem__",
        "full_api_name": "ObservablesArray.__getitem__",
        "api_description": "",
        "api_signature": "__getitem__(self, args)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/observables_array.py"
    },
    {
        "api_name": "reshape",
        "full_api_name": "ObservablesArray.reshape",
        "api_description": "Return a new array with a different shape.\n\nThis results in a new view of the same arrays.\n\nArgs:\n    shape: The shape of the returned array.\n\nReturns:\n    A new array.",
        "api_signature": "reshape(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/observables_array.py"
    },
    {
        "api_name": "ravel",
        "full_api_name": "ObservablesArray.ravel",
        "api_description": "Return a new array with one dimension.\n\nThe returned array has a :attr:`shape` given by ``(size, )``, where\nthe size is the :attr:`~size` of this array.\n\nReturns:\n    A new flattened array.",
        "api_signature": "ravel(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/observables_array.py"
    },
    {
        "api_name": "coerce_observable",
        "full_api_name": "ObservablesArray.coerce_observable",
        "api_description": "Format an observable-like object into the internal format.\n\nArgs:\n    observable: The observable-like to format.\n\nReturns:\n    The coerced observable.\n\nRaises:\n    TypeError: If the input cannot be formatted because its type is not valid.\n    ValueError: If the input observable is invalid.",
        "api_signature": "coerce_observable(cls, observable)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/observables_array.py"
    },
    {
        "api_name": "coerce",
        "full_api_name": "ObservablesArray.coerce",
        "api_description": "Coerce ObservablesArrayLike into ObservableArray.\n\nArgs:\n    observables: an object to be observables array.\n\nReturns:\n    A coerced observables array.",
        "api_signature": "coerce(cls, observables)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/observables_array.py"
    },
    {
        "api_name": "validate",
        "full_api_name": "ObservablesArray.validate",
        "api_description": "Validate the consistency in observables array.",
        "api_signature": "validate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/observables_array.py"
    },
    {
        "api_name": "_validate_basis",
        "full_api_name": "ObservablesArray._validate_basis",
        "api_description": "Validate a basis string.\n\nArgs:\n    basis: a basis string to validate.\n\nRaises:\n    ValueError: If basis string contains invalid characters",
        "api_signature": "_validate_basis(cls, basis)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/observables_array.py"
    },
    {
        "api_name": "_regex_match",
        "full_api_name": "_regex_match",
        "api_description": "Return pattern for matching if a string contains only the allowed characters.",
        "api_signature": "_regex_match(allowed_chars)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/observables_array.py"
    },
    {
        "api_name": "_regex_invalid",
        "full_api_name": "_regex_invalid",
        "api_description": "Return pattern for selecting invalid strings",
        "api_signature": "_regex_invalid(allowed_chars)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/observables_array.py"
    },
    {
        "api_name": "join_data",
        "full_api_name": "SamplerPubResult.join_data",
        "api_description": "Join data from many registers into one data container.\n\nData is joined along the bits axis. For example, for :class:`~.BitArray` data, this corresponds\nto bitstring concatenation.\n\nArgs:\n    names: Which registers to join. Their order is maintained, for example, given\n        ``[\"alpha\", \"beta\"]``, the data from register ``alpha`` is placed to the left of the\n        data from register ``beta``. When ``None`` is given, this value is set to the\n        ordered list of register names, which will have been preserved from the input circuit\n        order.\n\nReturns:\n    Joint data.\n\nRaises:\n    ValueError: If specified names are empty.\n    ValueError: If specified name does not exist.\n    TypeError: If specified data comes from incompatible types.",
        "api_signature": "join_data(self, names)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/sampler_pub_result.py"
    },
    {
        "api_name": "object_array",
        "full_api_name": "object_array",
        "api_description": "Convert an array-like of objects into an object array.\n\n.. note::\n\n    If the objects in the array like input define ``__array__`` methods\n    this avoids calling them and will instead set the returned array values\n    to the Python objects themselves.\n\nArgs:\n    arr: An array-like input.\n    order: Optional, the order of the returned array (C, F, A, K). If None\n           the default NumPy ordering of C is used.\n    copy: If True make a copy of the input if it is already an array.\n    list_types: Optional, a sequence of types to treat as lists of array\n        element objects when inferring the array shape from the input.\n\nReturns:\n    A NumPy ND-array with ``dtype=object``.\n\nRaises:\n    ValueError: If the input cannot be coerced into an object array.",
        "api_signature": "object_array(arr, order, copy, list_types)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/object_array.py"
    },
    {
        "api_name": "_flatten",
        "full_api_name": "_flatten",
        "api_description": "",
        "api_signature": "_flatten(nested, k)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/object_array.py"
    },
    {
        "api_name": "_infer_shape",
        "full_api_name": "_infer_shape",
        "api_description": "Infer the shape of an array-like object without casting",
        "api_signature": "_infer_shape(obj, list_types)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/object_array.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PrimitiveResult.__init__",
        "api_description": "Args:\n    pub_results: Pub results.\n    metadata: Metadata that is common to all pub results; metadata specific to particular\n        pubs should be placed in their metadata fields. Keys are expected to be strings.",
        "api_signature": "__init__(self, pub_results, metadata)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/primitive_result.py"
    },
    {
        "api_name": "metadata",
        "full_api_name": "PrimitiveResult.metadata",
        "api_description": "The metadata of this primitive result.",
        "api_signature": "metadata(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/primitive_result.py"
    },
    {
        "api_name": "__getitem__",
        "full_api_name": "PrimitiveResult.__getitem__",
        "api_description": "",
        "api_signature": "__getitem__(self, index)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/primitive_result.py"
    },
    {
        "api_name": "__len__",
        "full_api_name": "PrimitiveResult.__len__",
        "api_description": "",
        "api_signature": "__len__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/primitive_result.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "PrimitiveResult.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/primitive_result.py"
    },
    {
        "api_name": "__iter__",
        "full_api_name": "PrimitiveResult.__iter__",
        "api_description": "",
        "api_signature": "__iter__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/primitives/containers/primitive_result.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ParameterExpression.__init__",
        "api_description": "Create a new :class:`ParameterExpression`.\n\nNot intended to be called directly, but to be instantiated via operations\non other :class:`Parameter` or :class:`ParameterExpression` objects.\n\nArgs:\n    symbol_map (Dict[Parameter, [ParameterExpression, float, or int]]):\n        Mapping of :class:`Parameter` instances to the :class:`sympy.Symbol`\n        serving as their placeholder in expr.\n    expr (sympy.Expr): Expression of :class:`sympy.Symbol` s.",
        "api_signature": "__init__(self, symbol_map, expr)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "parameters",
        "full_api_name": "ParameterExpression.parameters",
        "api_description": "Returns a set of the unbound Parameters in the expression.",
        "api_signature": "parameters(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "_names",
        "full_api_name": "ParameterExpression._names",
        "api_description": "Returns a mapping of parameter names to Parameters in the expression.",
        "api_signature": "_names(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "conjugate",
        "full_api_name": "ParameterExpression.conjugate",
        "api_description": "Return the conjugate.",
        "api_signature": "conjugate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "assign",
        "full_api_name": "ParameterExpression.assign",
        "api_description": "Assign one parameter to a value, which can either be numeric or another parameter\nexpression.\n\nArgs:\n    parameter (Parameter): A parameter in this expression whose value will be updated.\n    value: The new value to bind to.\n\nReturns:\n    A new expression parameterized by any parameters which were not bound by assignment.",
        "api_signature": "assign(self, parameter, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "bind",
        "full_api_name": "ParameterExpression.bind",
        "api_description": "Binds the provided set of parameters to their corresponding values.\n\nArgs:\n    parameter_values: Mapping of Parameter instances to the numeric value to which\n                      they will be bound.\n    allow_unknown_parameters: If ``False``, raises an error if ``parameter_values``\n        contains Parameters in the keys outside those present in the expression.\n        If ``True``, any such parameters are simply ignored.\n\nRaises:\n    CircuitError:\n        - If parameter_values contains Parameters outside those in self.\n        - If a non-numeric value is passed in parameter_values.\n    ZeroDivisionError:\n        - If binding the provided values requires division by zero.\n\nReturns:\n    A new expression parameterized by any parameters which were not bound by\n    parameter_values.",
        "api_signature": "bind(self, parameter_values, allow_unknown_parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "subs",
        "full_api_name": "ParameterExpression.subs",
        "api_description": "Returns a new Expression with replacement Parameters.\n\nArgs:\n    parameter_map: Mapping from Parameters in self to the ParameterExpression\n                   instances with which they should be replaced.\n    allow_unknown_parameters: If ``False``, raises an error if ``parameter_map``\n        contains Parameters in the keys outside those present in the expression.\n        If ``True``, any such parameters are simply ignored.\n\nRaises:\n    CircuitError:\n        - If parameter_map contains Parameters outside those in self.\n        - If the replacement Parameters in parameter_map would result in\n          a name conflict in the generated expression.\n\nReturns:\n    A new expression with the specified parameters replaced.",
        "api_signature": "subs(self, parameter_map, allow_unknown_parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "_raise_if_passed_unknown_parameters",
        "full_api_name": "ParameterExpression._raise_if_passed_unknown_parameters",
        "api_description": "",
        "api_signature": "_raise_if_passed_unknown_parameters(self, parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "_raise_if_passed_nan",
        "full_api_name": "ParameterExpression._raise_if_passed_nan",
        "api_description": "",
        "api_signature": "_raise_if_passed_nan(self, parameter_values)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "_raise_if_parameter_names_conflict",
        "full_api_name": "ParameterExpression._raise_if_parameter_names_conflict",
        "api_description": "",
        "api_signature": "_raise_if_parameter_names_conflict(self, inbound_parameters, outbound_parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "_apply_operation",
        "full_api_name": "ParameterExpression._apply_operation",
        "api_description": "Base method implementing math operations between Parameters and\neither a constant or a second ParameterExpression.\n\nArgs:\n    operation: One of operator.{add,sub,mul,truediv}.\n    other: The second argument to be used with self in operation.\n    reflected: Optional - The default ordering is \"self operator other\".\n               If reflected is True, this is switched to \"other operator self\".\n               For use in e.g. __radd__, ...\n\nRaises:\n    CircuitError:\n        - If parameter_map contains Parameters outside those in self.\n        - If the replacement Parameters in parameter_map would result in\n          a name conflict in the generated expression.\n\nReturns:\n    A new expression describing the result of the operation.",
        "api_signature": "_apply_operation(self, operation, other, reflected)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "gradient",
        "full_api_name": "ParameterExpression.gradient",
        "api_description": "Get the derivative of a parameter expression w.r.t. a specified parameter expression.\n\nArgs:\n    param (Parameter): Parameter w.r.t. which we want to take the derivative\n\nReturns:\n    ParameterExpression representing the gradient of param_expr w.r.t. param\n    or complex or float number",
        "api_signature": "gradient(self, param)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "__add__",
        "full_api_name": "ParameterExpression.__add__",
        "api_description": "",
        "api_signature": "__add__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "__radd__",
        "full_api_name": "ParameterExpression.__radd__",
        "api_description": "",
        "api_signature": "__radd__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "__sub__",
        "full_api_name": "ParameterExpression.__sub__",
        "api_description": "",
        "api_signature": "__sub__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "__rsub__",
        "full_api_name": "ParameterExpression.__rsub__",
        "api_description": "",
        "api_signature": "__rsub__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "__mul__",
        "full_api_name": "ParameterExpression.__mul__",
        "api_description": "",
        "api_signature": "__mul__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "__pos__",
        "full_api_name": "ParameterExpression.__pos__",
        "api_description": "",
        "api_signature": "__pos__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "__neg__",
        "full_api_name": "ParameterExpression.__neg__",
        "api_description": "",
        "api_signature": "__neg__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "__rmul__",
        "full_api_name": "ParameterExpression.__rmul__",
        "api_description": "",
        "api_signature": "__rmul__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "__truediv__",
        "full_api_name": "ParameterExpression.__truediv__",
        "api_description": "",
        "api_signature": "__truediv__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "__rtruediv__",
        "full_api_name": "ParameterExpression.__rtruediv__",
        "api_description": "",
        "api_signature": "__rtruediv__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "__pow__",
        "full_api_name": "ParameterExpression.__pow__",
        "api_description": "",
        "api_signature": "__pow__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "__rpow__",
        "full_api_name": "ParameterExpression.__rpow__",
        "api_description": "",
        "api_signature": "__rpow__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "_call",
        "full_api_name": "ParameterExpression._call",
        "api_description": "",
        "api_signature": "_call(self, ufunc)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "sin",
        "full_api_name": "ParameterExpression.sin",
        "api_description": "Sine of a ParameterExpression",
        "api_signature": "sin(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "cos",
        "full_api_name": "ParameterExpression.cos",
        "api_description": "Cosine of a ParameterExpression",
        "api_signature": "cos(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "tan",
        "full_api_name": "ParameterExpression.tan",
        "api_description": "Tangent of a ParameterExpression",
        "api_signature": "tan(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "arcsin",
        "full_api_name": "ParameterExpression.arcsin",
        "api_description": "Arcsin of a ParameterExpression",
        "api_signature": "arcsin(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "arccos",
        "full_api_name": "ParameterExpression.arccos",
        "api_description": "Arccos of a ParameterExpression",
        "api_signature": "arccos(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "arctan",
        "full_api_name": "ParameterExpression.arctan",
        "api_description": "Arctan of a ParameterExpression",
        "api_signature": "arctan(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "exp",
        "full_api_name": "ParameterExpression.exp",
        "api_description": "Exponential of a ParameterExpression",
        "api_signature": "exp(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "log",
        "full_api_name": "ParameterExpression.log",
        "api_description": "Logarithm of a ParameterExpression",
        "api_signature": "log(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "sign",
        "full_api_name": "ParameterExpression.sign",
        "api_description": "Sign of a ParameterExpression",
        "api_signature": "sign(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "ParameterExpression.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "ParameterExpression.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "__complex__",
        "full_api_name": "ParameterExpression.__complex__",
        "api_description": "",
        "api_signature": "__complex__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "__float__",
        "full_api_name": "ParameterExpression.__float__",
        "api_description": "",
        "api_signature": "__float__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "__int__",
        "full_api_name": "ParameterExpression.__int__",
        "api_description": "",
        "api_signature": "__int__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "__hash__",
        "full_api_name": "ParameterExpression.__hash__",
        "api_description": "",
        "api_signature": "__hash__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "__copy__",
        "full_api_name": "ParameterExpression.__copy__",
        "api_description": "",
        "api_signature": "__copy__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "__deepcopy__",
        "full_api_name": "ParameterExpression.__deepcopy__",
        "api_description": "",
        "api_signature": "__deepcopy__(self, memo)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "__abs__",
        "full_api_name": "ParameterExpression.__abs__",
        "api_description": "Absolute of a ParameterExpression",
        "api_signature": "__abs__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "abs",
        "full_api_name": "ParameterExpression.abs",
        "api_description": "Absolute of a ParameterExpression",
        "api_signature": "abs(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "ParameterExpression.__eq__",
        "api_description": "Check if this parameter expression is equal to another parameter expression\n   or a fixed value (only if this is a bound expression).\nArgs:\n    other (ParameterExpression or a number):\n        Parameter expression or numeric constant used for comparison\nReturns:\n    bool: result of the comparison",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "is_real",
        "full_api_name": "ParameterExpression.is_real",
        "api_description": "Return whether the expression is real",
        "api_signature": "is_real(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "numeric",
        "full_api_name": "ParameterExpression.numeric",
        "api_description": "Return a Python number representing this object, using the most restrictive of\n:class:`int`, :class:`float` and :class:`complex` that is valid for this object.\n\nIn general, an :class:`int` is only returned if the expression only involved symbolic\nintegers.  If floating-point values were used during the evaluation, the return value will\nbe a :class:`float` regardless of whether the represented value is an integer.  This is\nbecause floating-point values \"infect\" symbolic computations by their inexact nature, and\nsymbolic libraries will use inexact floating-point semantics not exact real-number semantics\nwhen they are involved.  If you want to assert that all floating-point calculations *were*\ncarried out at infinite precision (i.e. :class:`float` could represent every intermediate\nvalue exactly), you can use :meth:`float.is_integer` to check if the return float represents\nan integer and cast it using :class:`int` if so.  This would be an unusual pattern;\ntypically one requires this by only ever using explicitly :class:`~numbers.Rational` objects\nwhile working with symbolic expressions.\n\nThis is more reliable and performant than using :meth:`is_real` followed by calling\n:class:`float` or :class:`complex`, as in some cases :meth:`is_real` needs to force a\nfloating-point evaluation to determine an accurate result to work around bugs in the\nupstream symbolic libraries.\n\nReturns:\n    A Python number representing the object.\n\nRaises:\n    TypeError: if there are unbound parameters.",
        "api_signature": "numeric(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "sympify",
        "full_api_name": "ParameterExpression.sympify",
        "api_description": "Return symbolic expression as a raw Sympy or Symengine object.\n\nSymengine is used preferentially; if both are available, the result will always be a\n``symengine`` object.  Symengine is a separate library but has integration with Sympy.\n\n.. note::\n\n    This is for interoperability only.  Qiskit will not accept or work with raw Sympy or\n    Symegine expressions in its parameters, because they do not contain the tracking\n    information used in circuit-parameter binding and assignment.",
        "api_signature": "sympify(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameterexpression.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Qubit.__init__",
        "api_description": "Creates a qubit.\n\nArgs:\n    register (QuantumRegister): Optional. A quantum register containing the bit.\n    index (int): Optional. The index of the bit in its containing register.\n\nRaises:\n    CircuitError: if the provided register is not a valid :class:`QuantumRegister`",
        "api_signature": "__init__(self, register, index)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumregister.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ParameterView.__init__",
        "api_description": "",
        "api_signature": "__init__(self, iterable)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametertable.py"
    },
    {
        "api_name": "copy",
        "full_api_name": "ParameterView.copy",
        "api_description": "Copy the ParameterView.",
        "api_signature": "copy(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametertable.py"
    },
    {
        "api_name": "isdisjoint",
        "full_api_name": "ParameterView.isdisjoint",
        "api_description": "Check whether self and the input are disjoint.",
        "api_signature": "isdisjoint(self, x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametertable.py"
    },
    {
        "api_name": "remove",
        "full_api_name": "ParameterView.remove",
        "api_description": "Remove an existing element from the view.",
        "api_signature": "remove(self, x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametertable.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "ParameterView.__repr__",
        "api_description": "Format the class as string.",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametertable.py"
    },
    {
        "api_name": "__getitem__",
        "full_api_name": "ParameterView.__getitem__",
        "api_description": "Get items.",
        "api_signature": "__getitem__(self, index)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametertable.py"
    },
    {
        "api_name": "__and__",
        "full_api_name": "ParameterView.__and__",
        "api_description": "Get the intersection between self and the input.",
        "api_signature": "__and__(self, x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametertable.py"
    },
    {
        "api_name": "__rand__",
        "full_api_name": "ParameterView.__rand__",
        "api_description": "Get the intersection between self and the input.",
        "api_signature": "__rand__(self, x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametertable.py"
    },
    {
        "api_name": "__iand__",
        "full_api_name": "ParameterView.__iand__",
        "api_description": "Get the intersection between self and the input in-place.",
        "api_signature": "__iand__(self, x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametertable.py"
    },
    {
        "api_name": "__len__",
        "full_api_name": "ParameterView.__len__",
        "api_description": "Get the length.",
        "api_signature": "__len__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametertable.py"
    },
    {
        "api_name": "__or__",
        "full_api_name": "ParameterView.__or__",
        "api_description": "Get the union of self and the input.",
        "api_signature": "__or__(self, x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametertable.py"
    },
    {
        "api_name": "__sub__",
        "full_api_name": "ParameterView.__sub__",
        "api_description": "Get the difference between self and the input.",
        "api_signature": "__sub__(self, x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametertable.py"
    },
    {
        "api_name": "__xor__",
        "full_api_name": "ParameterView.__xor__",
        "api_description": "Get the symmetric difference between self and the input.",
        "api_signature": "__xor__(self, x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametertable.py"
    },
    {
        "api_name": "__ne__",
        "full_api_name": "ParameterView.__ne__",
        "api_description": "",
        "api_signature": "__ne__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametertable.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "ParameterView.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametertable.py"
    },
    {
        "api_name": "__le__",
        "full_api_name": "ParameterView.__le__",
        "api_description": "",
        "api_signature": "__le__(self, x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametertable.py"
    },
    {
        "api_name": "__lt__",
        "full_api_name": "ParameterView.__lt__",
        "api_description": "",
        "api_signature": "__lt__(self, x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametertable.py"
    },
    {
        "api_name": "__ge__",
        "full_api_name": "ParameterView.__ge__",
        "api_description": "",
        "api_signature": "__ge__(self, x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametertable.py"
    },
    {
        "api_name": "__gt__",
        "full_api_name": "ParameterView.__gt__",
        "api_description": "",
        "api_signature": "__gt__(self, x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametertable.py"
    },
    {
        "api_name": "__iter__",
        "full_api_name": "ParameterView.__iter__",
        "api_description": "",
        "api_signature": "__iter__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametertable.py"
    },
    {
        "api_name": "__contains__",
        "full_api_name": "ParameterView.__contains__",
        "api_description": "",
        "api_signature": "__contains__(self, x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametertable.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Delay.__init__",
        "api_description": "Args:\n    duration: the length of time of the duration.  Given in units of ``unit``.\n    unit: the unit of the duration.  Must be ``\"dt\"`` or an SI-prefixed seconds unit.",
        "api_signature": "__init__(self, duration, unit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/delay.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "Delay.inverse",
        "api_description": "Special case. Return self.",
        "api_signature": "inverse(self, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/delay.py"
    },
    {
        "api_name": "c_if",
        "full_api_name": "Delay.c_if",
        "api_description": "",
        "api_signature": "c_if(self, classical, val)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/delay.py"
    },
    {
        "api_name": "duration",
        "full_api_name": "Delay.duration",
        "api_description": "Get the duration of this delay.",
        "api_signature": "duration(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/delay.py"
    },
    {
        "api_name": "duration",
        "full_api_name": "Delay.duration",
        "api_description": "Set the duration of this delay.",
        "api_signature": "duration(self, duration)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/delay.py"
    },
    {
        "api_name": "to_matrix",
        "full_api_name": "Delay.to_matrix",
        "api_description": "Return a Numpy.array for the unitary matrix. This has been\nadded to enable simulation without making delay a full Gate type.\n\nReturns:\n    np.ndarray: matrix representation.",
        "api_signature": "to_matrix(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/delay.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "Delay.__repr__",
        "api_description": "Return the official string representing the delay.",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/delay.py"
    },
    {
        "api_name": "validate_parameter",
        "full_api_name": "Delay.validate_parameter",
        "api_description": "Delay parameter (i.e. duration) must be int, float or ParameterExpression.",
        "api_signature": "validate_parameter(self, parameter)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/delay.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Bit.__init__",
        "api_description": "Create a new generic bit.",
        "api_signature": "__init__(self, register, index)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/bit.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "Bit.__repr__",
        "api_description": "Return the official string representing the bit.",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/bit.py"
    },
    {
        "api_name": "__hash__",
        "full_api_name": "Bit.__hash__",
        "api_description": "",
        "api_signature": "__hash__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/bit.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "Bit.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/bit.py"
    },
    {
        "api_name": "__copy__",
        "full_api_name": "Bit.__copy__",
        "api_description": "",
        "api_signature": "__copy__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/bit.py"
    },
    {
        "api_name": "__deepcopy__",
        "full_api_name": "Bit.__deepcopy__",
        "api_description": "",
        "api_signature": "__deepcopy__(self, memo)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/bit.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Barrier.__init__",
        "api_description": "Args:\n    num_qubits: the number of qubits for the barrier.\n    label: the optional label of this barrier.",
        "api_signature": "__init__(self, num_qubits, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/barrier.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "Barrier.inverse",
        "api_description": "Special case. Return self.",
        "api_signature": "inverse(self, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/barrier.py"
    },
    {
        "api_name": "c_if",
        "full_api_name": "Barrier.c_if",
        "api_description": "",
        "api_signature": "c_if(self, classical, val)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/barrier.py"
    },
    {
        "api_name": "name",
        "full_api_name": "Operation.name",
        "api_description": "Unique string identifier for operation type.",
        "api_signature": "name(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/operation.py"
    },
    {
        "api_name": "num_qubits",
        "full_api_name": "Operation.num_qubits",
        "api_description": "Number of qubits.",
        "api_signature": "num_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/operation.py"
    },
    {
        "api_name": "num_clbits",
        "full_api_name": "Operation.num_clbits",
        "api_description": "Number of classical bits.",
        "api_signature": "num_clbits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/operation.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "EquivalenceLibrary.__init__",
        "api_description": "Create a new equivalence library.\n\nArgs:\n    base (Optional[EquivalenceLibrary]):  Base equivalence library to\n        be referenced if an entry is not found in this library.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/equivalence.py"
    },
    {
        "api_name": "graph",
        "full_api_name": "EquivalenceLibrary.graph",
        "api_description": "Return graph representing the equivalence library data.\n\nThis property should be treated as read-only as it provides\na reference to the internal state of the :class:`~.EquivalenceLibrary` object.\nIf the graph returned by this property is mutated it could corrupt the\nthe contents of the object. If you need to modify the output ``PyDiGraph``\nbe sure to make a copy prior to any modification.\n\nReturns:\n    PyDiGraph: A graph object with equivalence data in each node.",
        "api_signature": "graph(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/equivalence.py"
    },
    {
        "api_name": "_set_default_node",
        "full_api_name": "EquivalenceLibrary._set_default_node",
        "api_description": "Create a new node if key not found",
        "api_signature": "_set_default_node(self, key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/equivalence.py"
    },
    {
        "api_name": "add_equivalence",
        "full_api_name": "EquivalenceLibrary.add_equivalence",
        "api_description": "Add a new equivalence to the library. Future queries for the Gate\nwill include the given circuit, in addition to all existing equivalences\n(including those from base).\n\nParameterized Gates (those including `qiskit.circuit.Parameters` in their\n`Gate.params`) can be marked equivalent to parameterized circuits,\nprovided the parameters match.\n\nArgs:\n    gate (Gate): A Gate instance.\n    equivalent_circuit (QuantumCircuit): A circuit equivalently\n        implementing the given Gate.",
        "api_signature": "add_equivalence(self, gate, equivalent_circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/equivalence.py"
    },
    {
        "api_name": "has_entry",
        "full_api_name": "EquivalenceLibrary.has_entry",
        "api_description": "Check if a library contains any decompositions for gate.\n\nArgs:\n    gate (Gate): A Gate instance.\n\nReturns:\n    Bool: True if gate has a known decomposition in the library.\n        False otherwise.",
        "api_signature": "has_entry(self, gate)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/equivalence.py"
    },
    {
        "api_name": "set_entry",
        "full_api_name": "EquivalenceLibrary.set_entry",
        "api_description": "Set the equivalence record for a Gate. Future queries for the Gate\nwill return only the circuits provided.\n\nParameterized Gates (those including `qiskit.circuit.Parameters` in their\n`Gate.params`) can be marked equivalent to parameterized circuits,\nprovided the parameters match.\n\nArgs:\n    gate (Gate): A Gate instance.\n    entry (List['QuantumCircuit']) : A list of QuantumCircuits, each\n        equivalently implementing the given Gate.",
        "api_signature": "set_entry(self, gate, entry)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/equivalence.py"
    },
    {
        "api_name": "get_entry",
        "full_api_name": "EquivalenceLibrary.get_entry",
        "api_description": "Gets the set of QuantumCircuits circuits from the library which\nequivalently implement the given Gate.\n\nParameterized circuits will have their parameters replaced with the\ncorresponding entries from Gate.params.\n\nArgs:\n    gate (Gate) - Gate: A Gate instance.\n\nReturns:\n    List[QuantumCircuit]: A list of equivalent QuantumCircuits. If empty,\n        library contains no known decompositions of Gate.\n\n        Returned circuits will be ordered according to their insertion in\n        the library, from earliest to latest, from top to base. The\n        ordering of the StandardEquivalenceLibrary will not generally be\n        consistent across Qiskit versions.",
        "api_signature": "get_entry(self, gate)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/equivalence.py"
    },
    {
        "api_name": "keys",
        "full_api_name": "EquivalenceLibrary.keys",
        "api_description": "Return list of keys to key to node index map.\n\nReturns:\n    List: Keys to the key to node index map.",
        "api_signature": "keys(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/equivalence.py"
    },
    {
        "api_name": "node_index",
        "full_api_name": "EquivalenceLibrary.node_index",
        "api_description": "Return node index for a given key.\n\nArgs:\n    key (Key): Key to an equivalence.\n\nReturns:\n    Int: Index to the node in the graph for the given key.",
        "api_signature": "node_index(self, key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/equivalence.py"
    },
    {
        "api_name": "draw",
        "full_api_name": "EquivalenceLibrary.draw",
        "api_description": "Draws the equivalence relations available in the library.\n\nArgs:\n    filename (str): An optional path to write the output image to\n        if specified this method will return None.\n\nReturns:\n    PIL.Image or IPython.display.SVG: Drawn equivalence library as an\n        IPython SVG if in a jupyter notebook, or as a PIL.Image otherwise.\n\nRaises:\n    InvalidFileError: if filename is not valid.",
        "api_signature": "draw(self, filename)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/equivalence.py"
    },
    {
        "api_name": "_build_basis_graph",
        "full_api_name": "EquivalenceLibrary._build_basis_graph",
        "api_description": "",
        "api_signature": "_build_basis_graph(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/equivalence.py"
    },
    {
        "api_name": "_get_equivalences",
        "full_api_name": "EquivalenceLibrary._get_equivalences",
        "api_description": "Get all the equivalences for the given key",
        "api_signature": "_get_equivalences(self, key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/equivalence.py"
    },
    {
        "api_name": "_raise_if_param_mismatch",
        "full_api_name": "_raise_if_param_mismatch",
        "api_description": "",
        "api_signature": "_raise_if_param_mismatch(gate_params, circuit_parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/equivalence.py"
    },
    {
        "api_name": "_raise_if_shape_mismatch",
        "full_api_name": "_raise_if_shape_mismatch",
        "api_description": "",
        "api_signature": "_raise_if_shape_mismatch(gate, circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/equivalence.py"
    },
    {
        "api_name": "_rebind_equiv",
        "full_api_name": "_rebind_equiv",
        "api_description": "",
        "api_signature": "_rebind_equiv(equiv, query_params)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/equivalence.py"
    },
    {
        "api_name": "_handle_equal_types",
        "full_api_name": "_handle_equal_types",
        "api_description": "",
        "api_signature": "_handle_equal_types()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/store.py"
    },
    {
        "api_name": "_handle_implicit_cast",
        "full_api_name": "_handle_implicit_cast",
        "api_description": "",
        "api_signature": "_handle_implicit_cast()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/store.py"
    },
    {
        "api_name": "_requires_lossless_cast",
        "full_api_name": "_requires_lossless_cast",
        "api_description": "",
        "api_signature": "_requires_lossless_cast()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/store.py"
    },
    {
        "api_name": "_requires_dangerous_cast",
        "full_api_name": "_requires_dangerous_cast",
        "api_description": "",
        "api_signature": "_requires_dangerous_cast()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/store.py"
    },
    {
        "api_name": "_no_cast_possible",
        "full_api_name": "_no_cast_possible",
        "api_description": "",
        "api_signature": "_no_cast_possible(lvalue, rvalue)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/store.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Store.__init__",
        "api_description": "Args:\n    lvalue: the memory location being stored into.\n    rvalue: the expression result being stored.",
        "api_signature": "__init__(self, lvalue, rvalue)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/store.py"
    },
    {
        "api_name": "lvalue",
        "full_api_name": "Store.lvalue",
        "api_description": "Get the l-value :class:`~.expr.Expr` node that is being stored to.",
        "api_signature": "lvalue(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/store.py"
    },
    {
        "api_name": "rvalue",
        "full_api_name": "Store.rvalue",
        "api_description": "Get the r-value :class:`~.expr.Expr` node that is being written into the l-value.",
        "api_signature": "rvalue(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/store.py"
    },
    {
        "api_name": "c_if",
        "full_api_name": "Store.c_if",
        "api_description": ":meta hidden:",
        "api_signature": "c_if(self, classical, val)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/store.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Reset.__init__",
        "api_description": "Args:\n    label: optional string label of this instruction.",
        "api_signature": "__init__(self, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/reset.py"
    },
    {
        "api_name": "broadcast_arguments",
        "full_api_name": "Reset.broadcast_arguments",
        "api_description": "",
        "api_signature": "broadcast_arguments(self, qargs, cargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/reset.py"
    },
    {
        "api_name": "duration_in_dt",
        "full_api_name": "duration_in_dt",
        "api_description": "Return duration in dt.\n\nArgs:\n    duration_in_sec: duration [s] to be converted.\n    dt_in_sec: duration of dt in seconds used for conversion.\n\nReturns:\n    Duration in dt.",
        "api_signature": "duration_in_dt(duration_in_sec, dt_in_sec)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/duration.py"
    },
    {
        "api_name": "convert_durations_to_dt",
        "full_api_name": "convert_durations_to_dt",
        "api_description": "Convert all the durations in SI (seconds) into those in dt.\n\nReturns a new circuit if `inplace=False`.\n\nParameters:\n    qc (QuantumCircuit): Duration of dt in seconds used for conversion.\n    dt_in_sec (float): Duration of dt in seconds used for conversion.\n    inplace (bool): All durations are converted inplace or return new circuit.\n\nReturns:\n    QuantumCircuit: Converted circuit if `inplace = False`, otherwise None.\n\nRaises:\n    CircuitError: if fail to convert durations.",
        "api_signature": "convert_durations_to_dt(qc, dt_in_sec, inplace)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/duration.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "InstructionSet.__init__",
        "api_description": "New collection of instructions.\n\nThe context (``qargs`` and ``cargs`` that each instruction is attached to) is also stored\nseparately for each instruction.\n\nArgs:\n    resource_requester: A callable that takes in the classical resource used in the\n        condition, verifies that it is present in the attached circuit, resolves any indices\n        into concrete :obj:`.Clbit` instances, and returns the concrete resource.  If this\n        is not given, specifying a condition with an index is forbidden, and all concrete\n        :obj:`.Clbit` and :obj:`.ClassicalRegister` resources will be assumed to be valid.\n\n        .. note::\n\n            The callback ``resource_requester`` is called once for each call to\n            :meth:`.c_if`, and assumes that a call implies that the resource will now be\n            used.  It may throw an error if the resource is not valid for usage.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instructionset.py"
    },
    {
        "api_name": "__len__",
        "full_api_name": "InstructionSet.__len__",
        "api_description": "Return number of instructions in set",
        "api_signature": "__len__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instructionset.py"
    },
    {
        "api_name": "__getitem__",
        "full_api_name": "InstructionSet.__getitem__",
        "api_description": "Return instruction at index",
        "api_signature": "__getitem__(self, i)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instructionset.py"
    },
    {
        "api_name": "add",
        "full_api_name": "InstructionSet.add",
        "api_description": "Add an instruction and its context (where it is attached).",
        "api_signature": "add(self, instruction, qargs, cargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instructionset.py"
    },
    {
        "api_name": "_add_ref",
        "full_api_name": "InstructionSet._add_ref",
        "api_description": "Add a reference to an instruction and its context within a mutable sequence.\nUpdates to the instruction set will modify the specified sequence in place.",
        "api_signature": "_add_ref(self, data, pos)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instructionset.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "InstructionSet.inverse",
        "api_description": "Invert all instructions.\n\n.. note::\n    It is preferable to take the inverse *before* appending the gate(s) to the circuit.",
        "api_signature": "inverse(self, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instructionset.py"
    },
    {
        "api_name": "c_if",
        "full_api_name": "InstructionSet.c_if",
        "api_description": "Set a classical equality condition on all the instructions in this set between the\n:obj:`.ClassicalRegister` or :obj:`.Clbit` ``classical`` and value ``val``.\n\n.. note::\n    You should prefer to use the :meth:`.QuantumCircuit.if_test` builder interface, rather\n    than using this method.\n\n.. note::\n\n    This is a setter method, not an additive one.  Calling this multiple times will silently\n    override any previously set condition on any of the contained instructions; it does not\n    stack.\n\nArgs:\n    classical: the classical resource the equality condition should be on.  If this is given\n        as an integer, it will be resolved into a :obj:`.Clbit` using the same conventions\n        as the circuit these instructions are attached to.\n    val: the value the classical resource should be equal to.\n\nReturns:\n    This same instance of :obj:`.InstructionSet`, but now mutated to have the given equality\n    condition.\n\nRaises:\n    CircuitError: if the passed classical resource is invalid, or otherwise not resolvable\n        to a concrete resource that these instructions are permitted to access.",
        "api_signature": "c_if(self, classical, val)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instructionset.py"
    },
    {
        "api_name": "_instructions_iter",
        "full_api_name": "InstructionSet._instructions_iter",
        "api_description": "",
        "api_signature": "_instructions_iter(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instructionset.py"
    },
    {
        "api_name": "instructions",
        "full_api_name": "InstructionSet.instructions",
        "api_description": "Legacy getter for the instruction components of an instruction set.  This does not\nsupport mutation.",
        "api_signature": "instructions(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instructionset.py"
    },
    {
        "api_name": "qargs",
        "full_api_name": "InstructionSet.qargs",
        "api_description": "Legacy getter for the qargs components of an instruction set.  This does not support\nmutation.",
        "api_signature": "qargs(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instructionset.py"
    },
    {
        "api_name": "cargs",
        "full_api_name": "InstructionSet.cargs",
        "api_description": "Legacy getter for the cargs components of an instruction set.  This does not support\nmutation.",
        "api_signature": "cargs(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instructionset.py"
    },
    {
        "api_name": "_compute_control_matrix",
        "full_api_name": "_compute_control_matrix",
        "api_description": "Compute the controlled version of the input matrix with qiskit ordering.\nThis function computes the controlled unitary with :math:`n` control qubits\nand :math:`m` target qubits,\n\n.. math::\n\n    V_n^j(U_{2^m}) = (U_{2^m} \\otimes |j\\rangle\\!\\langle j|) +\n                     (I_{2^m} \\otimes (I_{2^n} - |j\\rangle\\!\\langle j|)).\n\nwhere :math:`|j\\rangle \\in \\mathcal{H}^{2^n}` is the control state.\n\nArgs:\n    base_mat (ndarray): unitary to be controlled\n    num_ctrl_qubits (int): number of controls for new unitary\n    ctrl_state (int or str or None): The control state in decimal or as\n        a bitstring (e.g. '111'). If None, use 2**num_ctrl_qubits-1.\n\nReturns:\n    ndarray: controlled version of base matrix.\n\nRaises:\n    QiskitError: unrecognized mode or invalid ctrl_state",
        "api_signature": "_compute_control_matrix(base_mat, num_ctrl_qubits, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/_utils.py"
    },
    {
        "api_name": "_ctrl_state_to_int",
        "full_api_name": "_ctrl_state_to_int",
        "api_description": "Convert ctrl_state to int.\n\nArgs:\n    ctrl_state (None, str, int): ctrl_state. If None, set to 2**num_ctrl_qubits-1.\n        If str, convert to int. If int, pass.\n    num_ctrl_qubits (int): The number of control qubits.\n\nReturn:\n    int: ctrl_state\n\nRaises:\n    CircuitError: invalid ctrl_state",
        "api_signature": "_ctrl_state_to_int(ctrl_state, num_ctrl_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/_utils.py"
    },
    {
        "api_name": "with_gate_array",
        "full_api_name": "with_gate_array",
        "api_description": "Class decorator that adds an ``__array__`` method to a :class:`.Gate` instance that returns a\nsingleton nonwritable view onto the complex matrix described by ``base_array``.",
        "api_signature": "with_gate_array(base_array)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/_utils.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "__array__",
        "api_description": "",
        "api_signature": "__array__(_self, dtype, copy)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/_utils.py"
    },
    {
        "api_name": "decorator",
        "full_api_name": "decorator",
        "api_description": "",
        "api_signature": "decorator(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/_utils.py"
    },
    {
        "api_name": "with_controlled_gate_array",
        "full_api_name": "with_controlled_gate_array",
        "api_description": "Class decorator that adds an ``__array__`` method to a :class:`.ControlledGate` instance that\nreturns singleton nonwritable views onto a relevant precomputed complex matrix for the given\ncontrol state.\n\nIf ``cached_states`` is not given, then all possible control states are precomputed.  If it is\ngiven, it should be an iterable of integers, and only these control states will be cached.",
        "api_signature": "with_controlled_gate_array(base_array, num_ctrl_qubits, cached_states)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/_utils.py"
    },
    {
        "api_name": "matrix_for_control_state",
        "full_api_name": "matrix_for_control_state",
        "api_description": "",
        "api_signature": "matrix_for_control_state(state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/_utils.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "__array__",
        "api_description": "",
        "api_signature": "__array__(self, dtype, copy)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/_utils.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "__array__",
        "api_description": "",
        "api_signature": "__array__(self, dtype, copy)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/_utils.py"
    },
    {
        "api_name": "decorator",
        "full_api_name": "decorator",
        "api_description": "",
        "api_signature": "decorator(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/_utils.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Register.__init__",
        "api_description": "Create a new generic register.\n\nEither the ``size`` or the ``bits`` argument must be provided. If\n``size`` is not None, the register will be pre-populated with bits of the\ncorrect type.\n\nArgs:\n    size (int): Optional. The number of bits to include in the register.\n    name (str): Optional. The name of the register. If not provided, a\n       unique name will be auto-generated from the register type.\n    bits (list[Bit]): Optional. A list of Bit() instances to be used to\n       populate the register.\n\nRaises:\n    CircuitError: if both the ``size`` and ``bits`` arguments are\n        provided, or if neither are.\n    CircuitError: if ``size`` is not valid.\n    CircuitError: if ``name`` is not a valid name according to the\n        OpenQASM spec.\n    CircuitError: if ``bits`` contained duplicated bits.\n    CircuitError: if ``bits`` contained bits of an incorrect type.",
        "api_signature": "__init__(self, size, name, bits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/register.py"
    },
    {
        "api_name": "name",
        "full_api_name": "Register.name",
        "api_description": "Get the register name.",
        "api_signature": "name(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/register.py"
    },
    {
        "api_name": "size",
        "full_api_name": "Register.size",
        "api_description": "Get the register size.",
        "api_signature": "size(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/register.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "Register.__repr__",
        "api_description": "Return the official string representing the register.",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/register.py"
    },
    {
        "api_name": "__len__",
        "full_api_name": "Register.__len__",
        "api_description": "Return register size.",
        "api_signature": "__len__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/register.py"
    },
    {
        "api_name": "__getitem__",
        "full_api_name": "Register.__getitem__",
        "api_description": "Arg:\n    bit_type (Qubit or Clbit): a constructor type return element/s.\n    key (int or slice or list): index of the bit to be retrieved.\n\nReturns:\n    Qubit or Clbit or list(Qubit) or list(Clbit): a Qubit or Clbit instance if\n    key is int. If key is a slice, returns a list of these instances.\n\nRaises:\n    CircuitError: if the `key` is not an integer or not in the range `(0, self.size)`.",
        "api_signature": "__getitem__(self, key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/register.py"
    },
    {
        "api_name": "__iter__",
        "full_api_name": "Register.__iter__",
        "api_description": "",
        "api_signature": "__iter__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/register.py"
    },
    {
        "api_name": "__contains__",
        "full_api_name": "Register.__contains__",
        "api_description": "",
        "api_signature": "__contains__(self, bit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/register.py"
    },
    {
        "api_name": "index",
        "full_api_name": "Register.index",
        "api_description": "Find the index of the provided bit within this register.",
        "api_signature": "index(self, bit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/register.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "Register.__eq__",
        "api_description": "Two Registers are the same if they are of the same type\n(i.e. quantum/classical), and have the same name and size. Additionally,\nif either Register contains new-style bits, the bits in both registers\nwill be checked for pairwise equality. If two registers are equal,\nthey will have behave identically when specified as circuit args.\n\nArgs:\n    other (Register): other Register\n\nReturns:\n    bool: `self` and `other` are equal.",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/register.py"
    },
    {
        "api_name": "__hash__",
        "full_api_name": "Register.__hash__",
        "api_description": "Make object hashable, based on the name and size to hash.",
        "api_signature": "__hash__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/register.py"
    },
    {
        "api_name": "__getstate__",
        "full_api_name": "Register.__getstate__",
        "api_description": "",
        "api_signature": "__getstate__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/register.py"
    },
    {
        "api_name": "__setstate__",
        "full_api_name": "Register.__setstate__",
        "api_description": "",
        "api_signature": "__setstate__(self, state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/register.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QuantumCircuitData.__init__",
        "api_description": "",
        "api_signature": "__init__(self, circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuitdata.py"
    },
    {
        "api_name": "__getitem__",
        "full_api_name": "QuantumCircuitData.__getitem__",
        "api_description": "",
        "api_signature": "__getitem__(self, i)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuitdata.py"
    },
    {
        "api_name": "__setitem__",
        "full_api_name": "QuantumCircuitData.__setitem__",
        "api_description": "",
        "api_signature": "__setitem__(self, key, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuitdata.py"
    },
    {
        "api_name": "_resolve_legacy_value",
        "full_api_name": "QuantumCircuitData._resolve_legacy_value",
        "api_description": "Resolve the old-style 3-tuple into the new :class:`CircuitInstruction` type.",
        "api_signature": "_resolve_legacy_value(self, operation, qargs, cargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuitdata.py"
    },
    {
        "api_name": "insert",
        "full_api_name": "QuantumCircuitData.insert",
        "api_description": "",
        "api_signature": "insert(self, index, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuitdata.py"
    },
    {
        "api_name": "__iter__",
        "full_api_name": "QuantumCircuitData.__iter__",
        "api_description": "",
        "api_signature": "__iter__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuitdata.py"
    },
    {
        "api_name": "__delitem__",
        "full_api_name": "QuantumCircuitData.__delitem__",
        "api_description": "",
        "api_signature": "__delitem__(self, i)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuitdata.py"
    },
    {
        "api_name": "__len__",
        "full_api_name": "QuantumCircuitData.__len__",
        "api_description": "",
        "api_signature": "__len__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuitdata.py"
    },
    {
        "api_name": "__cast",
        "full_api_name": "QuantumCircuitData.__cast",
        "api_description": "",
        "api_signature": "__cast(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuitdata.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "QuantumCircuitData.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuitdata.py"
    },
    {
        "api_name": "__lt__",
        "full_api_name": "QuantumCircuitData.__lt__",
        "api_description": "",
        "api_signature": "__lt__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuitdata.py"
    },
    {
        "api_name": "__le__",
        "full_api_name": "QuantumCircuitData.__le__",
        "api_description": "",
        "api_signature": "__le__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuitdata.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "QuantumCircuitData.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuitdata.py"
    },
    {
        "api_name": "__gt__",
        "full_api_name": "QuantumCircuitData.__gt__",
        "api_description": "",
        "api_signature": "__gt__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuitdata.py"
    },
    {
        "api_name": "__ge__",
        "full_api_name": "QuantumCircuitData.__ge__",
        "api_description": "",
        "api_signature": "__ge__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuitdata.py"
    },
    {
        "api_name": "__add__",
        "full_api_name": "QuantumCircuitData.__add__",
        "api_description": "",
        "api_signature": "__add__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuitdata.py"
    },
    {
        "api_name": "__radd__",
        "full_api_name": "QuantumCircuitData.__radd__",
        "api_description": "",
        "api_signature": "__radd__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuitdata.py"
    },
    {
        "api_name": "__mul__",
        "full_api_name": "QuantumCircuitData.__mul__",
        "api_description": "",
        "api_signature": "__mul__(self, n)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuitdata.py"
    },
    {
        "api_name": "__rmul__",
        "full_api_name": "QuantumCircuitData.__rmul__",
        "api_description": "",
        "api_signature": "__rmul__(self, n)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuitdata.py"
    },
    {
        "api_name": "sort",
        "full_api_name": "QuantumCircuitData.sort",
        "api_description": "In-place stable sort. Accepts arguments of list.sort.",
        "api_signature": "sort(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuitdata.py"
    },
    {
        "api_name": "copy",
        "full_api_name": "QuantumCircuitData.copy",
        "api_description": "Returns a shallow copy of instruction list.",
        "api_signature": "copy(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuitdata.py"
    },
    {
        "api_name": "_impl_init_subclass",
        "full_api_name": "_impl_init_subclass",
        "api_description": "",
        "api_signature": "_impl_init_subclass(base, overrides)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/singleton.py"
    },
    {
        "api_name": "__init_subclass__",
        "full_api_name": "__init_subclass__",
        "api_description": "",
        "api_signature": "__init_subclass__(instruction_class)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/singleton.py"
    },
    {
        "api_name": "__new__",
        "full_api_name": "_Singleton.__new__",
        "api_description": "",
        "api_signature": "__new__(singleton_class)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/singleton.py"
    },
    {
        "api_name": "base_class",
        "full_api_name": "_Singleton.base_class",
        "api_description": "",
        "api_signature": "base_class(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/singleton.py"
    },
    {
        "api_name": "mutable",
        "full_api_name": "_Singleton.mutable",
        "api_description": "",
        "api_signature": "mutable(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/singleton.py"
    },
    {
        "api_name": "to_mutable",
        "full_api_name": "_Singleton.to_mutable",
        "api_description": "",
        "api_signature": "to_mutable(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/singleton.py"
    },
    {
        "api_name": "__setattr__",
        "full_api_name": "_Singleton.__setattr__",
        "api_description": "",
        "api_signature": "__setattr__(self, key, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/singleton.py"
    },
    {
        "api_name": "__copy__",
        "full_api_name": "_Singleton.__copy__",
        "api_description": "",
        "api_signature": "__copy__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/singleton.py"
    },
    {
        "api_name": "__deepcopy__",
        "full_api_name": "_Singleton.__deepcopy__",
        "api_description": "",
        "api_signature": "__deepcopy__(self, memo)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/singleton.py"
    },
    {
        "api_name": "__reduce__",
        "full_api_name": "_Singleton.__reduce__",
        "api_description": "",
        "api_signature": "__reduce__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/singleton.py"
    },
    {
        "api_name": "_create_singleton_instance",
        "full_api_name": "_create_singleton_instance",
        "api_description": "",
        "api_signature": "_create_singleton_instance(args, kwargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/singleton.py"
    },
    {
        "api_name": "__new__",
        "full_api_name": "_SingletonMeta.__new__",
        "api_description": "",
        "api_signature": "__new__(mcs, name, bases, namespace)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/singleton.py"
    },
    {
        "api_name": "__call__",
        "full_api_name": "_SingletonMeta.__call__",
        "api_description": "",
        "api_signature": "__call__(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/singleton.py"
    },
    {
        "api_name": "_singleton_lookup_key",
        "full_api_name": "_SingletonBase._singleton_lookup_key",
        "api_description": "Given the arguments to the constructor, return a key tuple that identifies the singleton\ninstance to retrieve, or ``None`` if the arguments imply that a mutable object must be\ncreated.\n\nFor performance, as a special case, this method will not be called if the class constructor\nwas given zero arguments (e.g. the construction ``XGate()`` will not call this method, but\n``XGate(label=None)`` will), and the default singleton will immediately be returned.\n\nThis static method can (and probably should) be overridden by subclasses.  The derived\nsignature should match the class's ``__init__``; this method should then examine the\narguments to determine whether it requires mutability, or what the cache key (if any) should\nbe.\n\nThe function should return either ``None`` or valid ``dict`` key (i.e. hashable and\nimplements equality).  Returning ``None`` means that the created instance must be mutable.\nNo further singleton-based processing will be done, and the class creation will proceed as\nif there was no singleton handling.  Otherwise, the returned key can be anything hashable\nand no special meaning is ascribed to it.  Whenever this method returns the same key, the\nsame singleton instance will be returned.  We suggest that you use a tuple of the values of\nall arguments that can be set while maintaining the singleton nature.\n\nOnly keys that match the default arguments or arguments given to ``additional_singletons``\nat class-creation time will actually return singletons; other values will return a standard\nmutable instance.\n\n.. note::\n\n    The singleton machinery will handle an unhashable return from this function gracefully\n    by returning a mutable instance.  Subclasses should ensure that their key is hashable in\n    the happy path, but they do not need to manually verify that the user-supplied arguments\n    are hashable.  For example, it's safe to implement this as::\n\n        @staticmethod\n        def _singleton_lookup_key(*args, **kwargs):\n            return None if kwargs else args\n\n    even though a user might give some unhashable type as one of the ``args``.",
        "api_signature": "_singleton_lookup_key()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/singleton.py"
    },
    {
        "api_name": "_reject_mutation",
        "full_api_name": "_frozenlist._reject_mutation",
        "api_description": "",
        "api_signature": "_reject_mutation(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/singleton.py"
    },
    {
        "api_name": "_prepare_singleton_instance",
        "full_api_name": "_SingletonInstructionOverrides._prepare_singleton_instance",
        "api_description": "Class-creation hook point.  Given an instance of the type that these overrides correspond\nto, this method should ensure that all lazy properties and caches that require mutation to\nwrite to are eagerly defined.\n\nSubclass \"overrides\" classes can override this method if the user/library-author-facing\nclass they are providing overrides for has more lazy attributes or user-exposed state\nwith interior mutability.",
        "api_signature": "_prepare_singleton_instance(instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/singleton.py"
    },
    {
        "api_name": "c_if",
        "full_api_name": "_SingletonInstructionOverrides.c_if",
        "api_description": "",
        "api_signature": "c_if(self, classical, val)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/singleton.py"
    },
    {
        "api_name": "copy",
        "full_api_name": "_SingletonInstructionOverrides.copy",
        "api_description": "",
        "api_signature": "copy(self, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/singleton.py"
    },
    {
        "api_name": "stdlib_singleton_key",
        "full_api_name": "stdlib_singleton_key",
        "api_description": "Create an implementation of the abstract method\n:meth:`SingletonInstruction._singleton_lookup_key`, for standard-library instructions whose\n``__init__`` signatures match the one given here.\n\n.. warning::\n\n    This method is not safe for use in classes defined outside of Qiskit; it is not included in\n    the backwards compatibility guarantees.  This is because we guarantee that the call\n    signatures of the base classes are backwards compatible in the sense that we will only\n    replace them (without warning) contravariantly, but if you use this method, you effectively\n    use the signature *invariantly*, and we cannot guarantee that.\n\nArgs:\n    num_ctrl_qubits: if given, this implies that the gate is a :class:`.ControlledGate`, and\n        will have a fixed number of qubits that are used as the control.  This is necessary to\n        allow ``ctrl_state`` to be given as either ``None`` or as an all-ones integer/string.",
        "api_signature": "stdlib_singleton_key()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/singleton.py"
    },
    {
        "api_name": "key",
        "full_api_name": "key",
        "api_description": "",
        "api_signature": "key(label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/singleton.py"
    },
    {
        "api_name": "key",
        "full_api_name": "key",
        "api_description": "",
        "api_signature": "key(label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/singleton.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ControlledGate.__init__",
        "api_description": "Create a new ControlledGate. In the new gate the first ``num_ctrl_qubits``\nof the gate are the controls.\n\nArgs:\n    name: The name of the gate.\n    num_qubits: The number of qubits the gate acts on.\n    params: A list of parameters for the gate.\n    label: An optional label for the gate.\n    num_ctrl_qubits: Number of control qubits.\n    definition: A list of gate rules for implementing this gate. The\n        elements of the list are tuples of (:meth:`~qiskit.circuit.Gate`, [qubit_list],\n        [clbit_list]).\n    ctrl_state: The control state in decimal or as\n        a bitstring (e.g. '111'). If specified as a bitstring the length\n        must equal num_ctrl_qubits, MSB on left. If None, use\n        2**num_ctrl_qubits-1.\n    base_gate: Gate object to be controlled.\n\nRaises:\n    CircuitError: If ``num_ctrl_qubits`` >= ``num_qubits``.\n    CircuitError: ctrl_state < 0 or ctrl_state > 2**num_ctrl_qubits.\n\nExamples:\n\nCreate a controlled standard gate and apply it to a circuit.\n\n.. plot::\n   :include-source:\n\n   from qiskit import QuantumCircuit, QuantumRegister\n   from qiskit.circuit.library.standard_gates import HGate\n\n   qr = QuantumRegister(3)\n   qc = QuantumCircuit(qr)\n   c3h_gate = HGate().control(2)\n   qc.append(c3h_gate, qr)\n   qc.draw('mpl')\n\nCreate a controlled custom gate and apply it to a circuit.\n\n.. plot::\n   :include-source:\n\n   from qiskit import QuantumCircuit, QuantumRegister\n   from qiskit.circuit.library.standard_gates import HGate\n\n   qc1 = QuantumCircuit(2)\n   qc1.x(0)\n   qc1.h(1)\n   custom = qc1.to_gate().control(2)\n\n   qc2 = QuantumCircuit(4)\n   qc2.append(custom, [0, 3, 1, 2])\n   qc2.draw('mpl')",
        "api_signature": "__init__(self, name, num_qubits, params, label, num_ctrl_qubits, definition, ctrl_state, base_gate, duration, unit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlledgate.py"
    },
    {
        "api_name": "definition",
        "full_api_name": "ControlledGate.definition",
        "api_description": "Return definition in terms of other basic gates. If the gate has\nopen controls, as determined from :attr:`ctrl_state`, the returned\ndefinition is conjugated with X without changing the internal\n``_definition``.",
        "api_signature": "definition(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlledgate.py"
    },
    {
        "api_name": "definition",
        "full_api_name": "ControlledGate.definition",
        "api_description": "Set controlled gate definition with closed controls.\n\nArgs:\n    excited_def: The circuit with all closed controls.",
        "api_signature": "definition(self, excited_def)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlledgate.py"
    },
    {
        "api_name": "name",
        "full_api_name": "ControlledGate.name",
        "api_description": "Get name of gate. If the gate has open controls the gate name\nwill become:\n\n   <original_name_o<ctrl_state>\n\nwhere <original_name> is the gate name for the default case of\nclosed control qubits and <ctrl_state> is the integer value of\nthe control state for the gate.",
        "api_signature": "name(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlledgate.py"
    },
    {
        "api_name": "name",
        "full_api_name": "ControlledGate.name",
        "api_description": "Set the name of the gate. Note the reported name may differ\nfrom the set name if the gate has open controls.",
        "api_signature": "name(self, name_str)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlledgate.py"
    },
    {
        "api_name": "num_ctrl_qubits",
        "full_api_name": "ControlledGate.num_ctrl_qubits",
        "api_description": "Get number of control qubits.\n\nReturns:\n    int: The number of control qubits for the gate.",
        "api_signature": "num_ctrl_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlledgate.py"
    },
    {
        "api_name": "num_ctrl_qubits",
        "full_api_name": "ControlledGate.num_ctrl_qubits",
        "api_description": "Set the number of control qubits.\n\nArgs:\n    num_ctrl_qubits (int): The number of control qubits.\n\nRaises:\n    CircuitError: ``num_ctrl_qubits`` is not an integer in ``[1, num_qubits]``.",
        "api_signature": "num_ctrl_qubits(self, num_ctrl_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlledgate.py"
    },
    {
        "api_name": "ctrl_state",
        "full_api_name": "ControlledGate.ctrl_state",
        "api_description": "Return the control state of the gate as a decimal integer.",
        "api_signature": "ctrl_state(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlledgate.py"
    },
    {
        "api_name": "ctrl_state",
        "full_api_name": "ControlledGate.ctrl_state",
        "api_description": "Set the control state of this gate.\n\nArgs:\n    ctrl_state: The control state of the gate.\n\nRaises:\n    CircuitError: ctrl_state is invalid.",
        "api_signature": "ctrl_state(self, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlledgate.py"
    },
    {
        "api_name": "params",
        "full_api_name": "ControlledGate.params",
        "api_description": "Get parameters from base_gate.\n\nReturns:\n    list: List of gate parameters.\n\nRaises:\n    CircuitError: Controlled gate does not define a base gate",
        "api_signature": "params(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlledgate.py"
    },
    {
        "api_name": "params",
        "full_api_name": "ControlledGate.params",
        "api_description": "Set base gate parameters.\n\nArgs:\n    parameters (list): The list of parameters to set.\n\nRaises:\n    CircuitError: If controlled gate does not define a base gate.",
        "api_signature": "params(self, parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlledgate.py"
    },
    {
        "api_name": "__deepcopy__",
        "full_api_name": "ControlledGate.__deepcopy__",
        "api_description": "",
        "api_signature": "__deepcopy__(self, memo)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlledgate.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "ControlledGate.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlledgate.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "ControlledGate.inverse",
        "api_description": "Invert this gate by calling inverse on the base gate.",
        "api_signature": "inverse(self, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlledgate.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ParameterVectorElement.__init__",
        "api_description": "",
        "api_signature": "__init__(self, vector, index, uuid)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametervector.py"
    },
    {
        "api_name": "index",
        "full_api_name": "ParameterVectorElement.index",
        "api_description": "Get the index of this element in the parent vector.",
        "api_signature": "index(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametervector.py"
    },
    {
        "api_name": "vector",
        "full_api_name": "ParameterVectorElement.vector",
        "api_description": "Get the parent vector instance.",
        "api_signature": "vector(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametervector.py"
    },
    {
        "api_name": "__getstate__",
        "full_api_name": "ParameterVectorElement.__getstate__",
        "api_description": "",
        "api_signature": "__getstate__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametervector.py"
    },
    {
        "api_name": "__setstate__",
        "full_api_name": "ParameterVectorElement.__setstate__",
        "api_description": "",
        "api_signature": "__setstate__(self, state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametervector.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ParameterVector.__init__",
        "api_description": "",
        "api_signature": "__init__(self, name, length)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametervector.py"
    },
    {
        "api_name": "name",
        "full_api_name": "ParameterVector.name",
        "api_description": "Returns the name of the ParameterVector.",
        "api_signature": "name(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametervector.py"
    },
    {
        "api_name": "params",
        "full_api_name": "ParameterVector.params",
        "api_description": "Returns the list of parameters in the ParameterVector.",
        "api_signature": "params(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametervector.py"
    },
    {
        "api_name": "index",
        "full_api_name": "ParameterVector.index",
        "api_description": "Returns first index of value.",
        "api_signature": "index(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametervector.py"
    },
    {
        "api_name": "__getitem__",
        "full_api_name": "ParameterVector.__getitem__",
        "api_description": "",
        "api_signature": "__getitem__(self, key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametervector.py"
    },
    {
        "api_name": "__iter__",
        "full_api_name": "ParameterVector.__iter__",
        "api_description": "",
        "api_signature": "__iter__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametervector.py"
    },
    {
        "api_name": "__len__",
        "full_api_name": "ParameterVector.__len__",
        "api_description": "",
        "api_signature": "__len__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametervector.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "ParameterVector.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametervector.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "ParameterVector.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametervector.py"
    },
    {
        "api_name": "resize",
        "full_api_name": "ParameterVector.resize",
        "api_description": "Resize the parameter vector.  If necessary, new elements are generated.\n\nNote that the UUID of each :class:`.Parameter` element will be generated\ndeterministically given the root UUID of the ``ParameterVector`` and the index\nof the element.  In particular, if a ``ParameterVector`` is resized to\nbe smaller and then later resized to be larger, the UUID of the later\ngenerated element at a given index will be the same as the UUID of the\nprevious element at that index.\nThis is to ensure that the parameter instances do not change.\n\n>>> from qiskit.circuit import ParameterVector\n>>> pv = ParameterVector(\"theta\", 20)\n>>> elt_19 = pv[19]\n>>> rv.resize(10)\n>>> rv.resize(20)\n>>> pv[19] == elt_19\nTrue",
        "api_signature": "resize(self, length)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parametervector.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Gate.__init__",
        "api_description": "Create a new gate.\n\nArgs:\n    name: The Qobj name of the gate.\n    num_qubits: The number of qubits the gate acts on.\n    params: A list of parameters.\n    label: An optional label for the gate.",
        "api_signature": "__init__(self, name, num_qubits, params, label, duration, unit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/gate.py"
    },
    {
        "api_name": "to_matrix",
        "full_api_name": "Gate.to_matrix",
        "api_description": "Return a Numpy.array for the gate unitary matrix.\n\nReturns:\n    np.ndarray: if the Gate subclass has a matrix definition.\n\nRaises:\n    CircuitError: If a Gate subclass does not implement this method an\n        exception will be raised when this base class method is called.",
        "api_signature": "to_matrix(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/gate.py"
    },
    {
        "api_name": "power",
        "full_api_name": "Gate.power",
        "api_description": "Raise this gate to the power of ``exponent``.\n\nImplemented either as a unitary gate (ref. :class:`~.library.UnitaryGate`)\nor as an annotated operation (ref. :class:`.AnnotatedOperation`). In the case of several standard\ngates, such as :class:`.RXGate`, when the power of a gate can be expressed in terms of another\nstandard gate that is returned directly.\n\nArgs:\n    exponent (float): the power to raise the gate to\n    annotated (bool): indicates whether the power gate can be implemented\n        as an annotated operation. In the case of several standard\n        gates, such as :class:`.RXGate`, this argument is ignored when\n        the power of a gate can be expressed in terms of another\n        standard gate.\n\nReturns:\n    An operation implementing ``gate^exponent``\n\nRaises:\n    CircuitError: If gate is not unitary",
        "api_signature": "power(self, exponent, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/gate.py"
    },
    {
        "api_name": "__pow__",
        "full_api_name": "Gate.__pow__",
        "api_description": "",
        "api_signature": "__pow__(self, exponent)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/gate.py"
    },
    {
        "api_name": "_return_repeat",
        "full_api_name": "Gate._return_repeat",
        "api_description": "",
        "api_signature": "_return_repeat(self, exponent)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/gate.py"
    },
    {
        "api_name": "control",
        "full_api_name": "Gate.control",
        "api_description": "Return the controlled version of itself.\n\nImplemented either as a controlled gate (ref. :class:`.ControlledGate`)\nor as an annotated operation (ref. :class:`.AnnotatedOperation`).\n\nArgs:\n    num_ctrl_qubits: number of controls to add to gate (default: ``1``)\n    label: optional gate label. Ignored if implemented as an annotated\n        operation.\n    ctrl_state: the control state in decimal or as a bitstring\n        (e.g. ``'111'``). If ``None``, use ``2**num_ctrl_qubits-1``.\n    annotated: indicates whether the controlled gate is implemented\n        as an annotated gate. If ``None``, this is set to ``False``\n        if the controlled gate can directly be constructed, and otherwise\n        set to ``True``. This allows defering the construction process in case the\n        synthesis of the controlled gate requires more information (e.g.\n        values of unbound parameters).\n\nReturns:\n    Controlled version of the given operation.\n\nRaises:\n    QiskitError: unrecognized mode or invalid ctrl_state",
        "api_signature": "control(self, num_ctrl_qubits, label, ctrl_state, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/gate.py"
    },
    {
        "api_name": "_broadcast_single_argument",
        "full_api_name": "Gate._broadcast_single_argument",
        "api_description": "Expands a single argument.\n\nFor example: [q[0], q[1]] -> [q[0]], [q[1]]",
        "api_signature": "_broadcast_single_argument(qarg)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/gate.py"
    },
    {
        "api_name": "_broadcast_2_arguments",
        "full_api_name": "Gate._broadcast_2_arguments",
        "api_description": "",
        "api_signature": "_broadcast_2_arguments(qarg0, qarg1)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/gate.py"
    },
    {
        "api_name": "_broadcast_3_or_more_args",
        "full_api_name": "Gate._broadcast_3_or_more_args",
        "api_description": "",
        "api_signature": "_broadcast_3_or_more_args(qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/gate.py"
    },
    {
        "api_name": "broadcast_arguments",
        "full_api_name": "Gate.broadcast_arguments",
        "api_description": "Validation and handling of the arguments and its relationship.\n\nFor example, ``cx([q[0],q[1]], q[2])`` means ``cx(q[0], q[2]); cx(q[1], q[2])``. This\nmethod yields the arguments in the right grouping. In the given example::\n\n    in: [[q[0],q[1]], q[2]],[]\n    outs: [q[0], q[2]], []\n          [q[1], q[2]], []\n\nThe general broadcasting rules are:\n\n    * If len(qargs) == 1::\n\n        [q[0], q[1]] -> [q[0]],[q[1]]\n\n    * If len(qargs) == 2::\n\n        [[q[0], q[1]], [r[0], r[1]]] -> [q[0], r[0]], [q[1], r[1]]\n        [[q[0]], [r[0], r[1]]]       -> [q[0], r[0]], [q[0], r[1]]\n        [[q[0], q[1]], [r[0]]]       -> [q[0], r[0]], [q[1], r[0]]\n\n    * If len(qargs) >= 3::\n\n        [q[0], q[1]], [r[0], r[1]],  ...] -> [q[0], r[0], ...], [q[1], r[1], ...]\n\nArgs:\n    qargs: List of quantum bit arguments.\n    cargs: List of classical bit arguments.\n\nReturns:\n    A tuple with single arguments.\n\nRaises:\n    CircuitError: If the input is not valid. For example, the number of\n        arguments does not match the gate expectation.",
        "api_signature": "broadcast_arguments(self, qargs, cargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/gate.py"
    },
    {
        "api_name": "validate_parameter",
        "full_api_name": "Gate.validate_parameter",
        "api_description": "Gate parameters should be int, float, or ParameterExpression",
        "api_signature": "validate_parameter(self, parameter)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/gate.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Measure.__init__",
        "api_description": "Args:\n    label: optional string label for this instruction.",
        "api_signature": "__init__(self, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/measure.py"
    },
    {
        "api_name": "broadcast_arguments",
        "full_api_name": "Measure.broadcast_arguments",
        "api_description": "",
        "api_signature": "broadcast_arguments(self, qargs, cargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/measure.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "VariableMapper.__init__",
        "api_description": "",
        "api_signature": "__init__(self, target_cregs, bit_map, var_map)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/_classical_resource_map.py"
    },
    {
        "api_name": "_map_register",
        "full_api_name": "VariableMapper._map_register",
        "api_description": "Map the target's registers to suitable equivalents in the destination, adding an\nextra one if there's no exact match.",
        "api_signature": "_map_register(self, theirs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/_classical_resource_map.py"
    },
    {
        "api_name": "map_condition",
        "full_api_name": "VariableMapper.map_condition",
        "api_description": "Map the given ``condition`` so that it only references variables in the destination\ncircuit (as given to this class on initialization).\n\nIf ``allow_reorder`` is ``True``, then when a legacy condition (the two-tuple form) is made\non a register that has a counterpart in the destination with all the same (mapped) bits but\nin a different order, then that register will be used and the value suitably modified to\nmake the equality condition work.  This is maintaining legacy (tested) behavior of\n:meth:`.DAGCircuit.compose`; nowhere else does this, and in general this would require *far*\nmore complex classical rewriting than Terra needs to worry about in the full expression era.",
        "api_signature": "map_condition()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/_classical_resource_map.py"
    },
    {
        "api_name": "map_target",
        "full_api_name": "VariableMapper.map_target",
        "api_description": "Map the real-time variables in a ``target`` of a :class:`.SwitchCaseOp` to the new\ncircuit, as defined in the ``circuit`` argument of the initializer of this class.",
        "api_signature": "map_target()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/_classical_resource_map.py"
    },
    {
        "api_name": "map_expr",
        "full_api_name": "VariableMapper.map_expr",
        "api_description": "Map the variables in an :class:`~.expr.Expr` node to the new circuit.",
        "api_signature": "map_expr()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/_classical_resource_map.py"
    },
    {
        "api_name": "visit_var",
        "full_api_name": "VariableMapper.visit_var",
        "api_description": "",
        "api_signature": "visit_var()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/_classical_resource_map.py"
    },
    {
        "api_name": "visit_value",
        "full_api_name": "VariableMapper.visit_value",
        "api_description": "",
        "api_signature": "visit_value()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/_classical_resource_map.py"
    },
    {
        "api_name": "visit_unary",
        "full_api_name": "VariableMapper.visit_unary",
        "api_description": "",
        "api_signature": "visit_unary()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/_classical_resource_map.py"
    },
    {
        "api_name": "visit_binary",
        "full_api_name": "VariableMapper.visit_binary",
        "api_description": "",
        "api_signature": "visit_binary()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/_classical_resource_map.py"
    },
    {
        "api_name": "visit_cast",
        "full_api_name": "VariableMapper.visit_cast",
        "api_description": "",
        "api_signature": "visit_cast()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/_classical_resource_map.py"
    },
    {
        "api_name": "visit_index",
        "full_api_name": "VariableMapper.visit_index",
        "api_description": "",
        "api_signature": "visit_index()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/_classical_resource_map.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Clbit.__init__",
        "api_description": "Creates a classical bit.\n\nArgs:\n    register (ClassicalRegister): Optional. A classical register containing the bit.\n    index (int): Optional. The index of the bit in its containing register.\n\nRaises:\n    CircuitError: if the provided register is not a valid :class:`ClassicalRegister`",
        "api_signature": "__init__(self, register, index)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classicalregister.py"
    },
    {
        "api_name": "add_control",
        "full_api_name": "add_control",
        "api_description": "For standard gates, if the controlled version already exists in the\nlibrary, it will be returned (e.g. XGate.control() = CnotGate().\n\nFor more generic gates, this method implements the controlled\nversion by first decomposing into the ['u1', 'u3', 'cx'] basis, then\ncontrolling each gate in the decomposition.\n\nOpen controls are implemented by conjugating the control line with\nX gates. Adds num_ctrl_qubits controls to operation.\n\nThis function is meant to be called from the\n:method:`qiskit.circuit.gate.Gate.control()` method.\n\nArgs:\n    operation: The operation to be controlled.\n    num_ctrl_qubits: The number of controls to add to gate.\n    label: An optional gate label.\n    ctrl_state: The control state in decimal or as a bitstring\n        (e.g. '111'). If specified as a bitstring the length\n        must equal num_ctrl_qubits, MSB on left. If None, use\n        2**num_ctrl_qubits-1.\n\nReturns:\n    Controlled version of gate.",
        "api_signature": "add_control(operation, num_ctrl_qubits, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/add_control.py"
    },
    {
        "api_name": "control",
        "full_api_name": "control",
        "api_description": "Return controlled version of gate using controlled rotations. This function\nfirst checks the name of the operation to see if it knows of a method from which\nto generate a controlled version. Currently, these are ``x``, ``rx``, ``ry``, and ``rz``.\nIf a method is not directly known, it calls the unroller to convert to `u1`, `u3`,\nand `cx` gates.\n\nArgs:\n    operation: The gate used to create the ControlledGate.\n    num_ctrl_qubits: The number of controls to add to gate (default=1).\n    label: An optional gate label.\n    ctrl_state: The control state in decimal or as\n        a bitstring (e.g. '111'). If specified as a bitstring the length\n        must equal num_ctrl_qubits, MSB on left. If None, use\n        2**num_ctrl_qubits-1.\n\nReturns:\n    Controlled version of gate.\n\nRaises:\n    CircuitError: gate contains non-gate in definition",
        "api_signature": "control(operation, num_ctrl_qubits, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/add_control.py"
    },
    {
        "api_name": "_gate_to_circuit",
        "full_api_name": "_gate_to_circuit",
        "api_description": "Converts a gate instance to a QuantumCircuit",
        "api_signature": "_gate_to_circuit(operation)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/add_control.py"
    },
    {
        "api_name": "_unroll_gate",
        "full_api_name": "_unroll_gate",
        "api_description": "Unrolls a gate, possibly composite, to the target basis",
        "api_signature": "_unroll_gate(operation, basis_gates)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/add_control.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Instruction.__init__",
        "api_description": "Create a new instruction.\n\nArgs:\n    name (str): instruction name\n    num_qubits (int): instruction's qubit width\n    num_clbits (int): instruction's clbit width\n    params (list[int|float|complex|str|ndarray|list|ParameterExpression]):\n        list of parameters\n    duration (int or float): instruction's duration. it must be integer if ``unit`` is 'dt'\n    unit (str): time unit of duration\n    label (str or None): An optional label for identifying the instruction.\n\nRaises:\n    CircuitError: when the register is not in the correct format.\n    TypeError: when the optional label is provided, but it is not a string.",
        "api_signature": "__init__(self, name, num_qubits, num_clbits, params, duration, unit, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "base_class",
        "full_api_name": "Instruction.base_class",
        "api_description": "Get the base class of this instruction.  This is guaranteed to be in the inheritance tree\nof ``self``.\n\nThe \"base class\" of an instruction is the lowest class in its inheritance tree that the\nobject should be considered entirely compatible with for _all_ circuit applications.  This\ntypically means that the subclass is defined purely to offer some sort of programmer\nconvenience over the base class, and the base class is the \"true\" class for a behavioral\nperspective.  In particular, you should *not* override :attr:`base_class` if you are\ndefining a custom version of an instruction that will be implemented differently by\nhardware, such as an alternative measurement strategy, or a version of a parametrized gate\nwith a particular set of parameters for the purposes of distinguishing it in a\n:class:`.Target` from the full parametrized gate.\n\nThis is often exactly equivalent to ``type(obj)``, except in the case of singleton instances\nof standard-library instructions.  These singleton instances are special subclasses of their\nbase class, and this property will return that base.  For example::\n\n    >>> isinstance(XGate(), XGate)\n    True\n    >>> type(XGate()) is XGate\n    False\n    >>> XGate().base_class is XGate\n    True\n\nIn general, you should not rely on the precise class of an instruction; within a given\ncircuit, it is expected that :attr:`Instruction.name` should be a more suitable\ndiscriminator in most situations.",
        "api_signature": "base_class(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "mutable",
        "full_api_name": "Instruction.mutable",
        "api_description": "Is this instance is a mutable unique instance or not.\n\nIf this attribute is ``False`` the gate instance is a shared singleton\nand is not mutable.",
        "api_signature": "mutable(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "to_mutable",
        "full_api_name": "Instruction.to_mutable",
        "api_description": "Return a mutable copy of this gate.\n\nThis method will return a new mutable copy of this gate instance.\nIf a singleton instance is being used this will be a new unique\ninstance that can be mutated. If the instance is already mutable it\nwill be a deepcopy of that instance.",
        "api_signature": "to_mutable(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "condition",
        "full_api_name": "Instruction.condition",
        "api_description": "The classical condition on the instruction.",
        "api_signature": "condition(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "condition",
        "full_api_name": "Instruction.condition",
        "api_description": "",
        "api_signature": "condition(self, condition)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "Instruction.__eq__",
        "api_description": "Two instructions are the same if they have the same name,\nsame dimensions, and same params.\n\nArgs:\n    other (instruction): other instruction\n\nReturns:\n    bool: are self and other equal.",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "Instruction.__repr__",
        "api_description": "Generates a representation of the Instruction object instance\nReturns:\n    str: A representation of the Instruction instance with the name,\n         number of qubits, classical bits and params( if any )",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "soft_compare",
        "full_api_name": "Instruction.soft_compare",
        "api_description": "Soft comparison between gates. Their names, number of qubits, and classical\nbit numbers must match. The number of parameters must match. Each parameter\nis compared. If one is a ParameterExpression then it is not taken into\naccount.\n\nArgs:\n    other (instruction): other instruction.\n\nReturns:\n    bool: are self and other equal up to parameter expressions.",
        "api_signature": "soft_compare(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "Instruction._define",
        "api_description": "Populate the cached :attr:`_definition` field of this :class:`Instruction`.\n\nSubclasses should implement this method to provide lazy construction of their public\n:attr:`definition` attribute.  A subclass can use its :attr:`params` at the time of the\ncall.  The method should populate :attr:`_definition` with a :class:`.QuantumCircuit` and\nnot return a value.",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "params",
        "full_api_name": "Instruction.params",
        "api_description": "The parameters of this :class:`Instruction`.  Ideally these will be gate angles.",
        "api_signature": "params(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "params",
        "full_api_name": "Instruction.params",
        "api_description": "",
        "api_signature": "params(self, parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "validate_parameter",
        "full_api_name": "Instruction.validate_parameter",
        "api_description": "Instruction parameters has no validation or normalization.",
        "api_signature": "validate_parameter(self, parameter)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "is_parameterized",
        "full_api_name": "Instruction.is_parameterized",
        "api_description": "Return whether the :class:`Instruction` contains :ref:`compile-time parameters\n<circuit-compile-time-parameters>`.",
        "api_signature": "is_parameterized(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "definition",
        "full_api_name": "Instruction.definition",
        "api_description": "Return definition in terms of other basic gates.",
        "api_signature": "definition(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "definition",
        "full_api_name": "Instruction.definition",
        "api_description": "Set gate representation",
        "api_signature": "definition(self, array)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "decompositions",
        "full_api_name": "Instruction.decompositions",
        "api_description": "Get the decompositions of the instruction from the SessionEquivalenceLibrary.",
        "api_signature": "decompositions(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "decompositions",
        "full_api_name": "Instruction.decompositions",
        "api_description": "Set the decompositions of the instruction from the SessionEquivalenceLibrary.",
        "api_signature": "decompositions(self, decompositions)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "add_decomposition",
        "full_api_name": "Instruction.add_decomposition",
        "api_description": "Add a decomposition of the instruction to the SessionEquivalenceLibrary.",
        "api_signature": "add_decomposition(self, decomposition)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "duration",
        "full_api_name": "Instruction.duration",
        "api_description": "Get the duration.",
        "api_signature": "duration(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "duration",
        "full_api_name": "Instruction.duration",
        "api_description": "Set the duration.",
        "api_signature": "duration(self, duration)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "unit",
        "full_api_name": "Instruction.unit",
        "api_description": "Get the time unit of duration.",
        "api_signature": "unit(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "unit",
        "full_api_name": "Instruction.unit",
        "api_description": "Set the time unit of duration.",
        "api_signature": "unit(self, unit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "assemble",
        "full_api_name": "Instruction.assemble",
        "api_description": "Assemble a QasmQobjInstruction",
        "api_signature": "assemble(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "_assemble",
        "full_api_name": "Instruction._assemble",
        "api_description": "",
        "api_signature": "_assemble(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "label",
        "full_api_name": "Instruction.label",
        "api_description": "Return instruction label",
        "api_signature": "label(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "label",
        "full_api_name": "Instruction.label",
        "api_description": "Set instruction label to name\n\nArgs:\n    name (str or None): label to assign instruction\n\nRaises:\n    TypeError: name is not string or None.",
        "api_signature": "label(self, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "reverse_ops",
        "full_api_name": "Instruction.reverse_ops",
        "api_description": "For a composite instruction, reverse the order of sub-instructions.\n\nThis is done by recursively reversing all sub-instructions.\nIt does not invert any gate.\n\nReturns:\n    qiskit.circuit.Instruction: a new instruction with\n        sub-instructions reversed.",
        "api_signature": "reverse_ops(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "Instruction.inverse",
        "api_description": "Invert this instruction.\n\nIf `annotated` is `False`, the inverse instruction is implemented as\na fresh instruction with the recursively inverted definition.\n\nIf `annotated` is `True`, the inverse instruction is implemented as\n:class:`.AnnotatedOperation`, and corresponds to the given instruction\nannotated with the \"inverse modifier\".\n\nSpecial instructions inheriting from Instruction can\nimplement their own inverse (e.g. T and Tdg, Barrier, etc.)\nIn particular, they can choose how to handle the argument ``annotated``\nwhich may include ignoring it and always returning a concrete gate class\nif the inverse is defined as a standard gate.\n\nArgs:\n    annotated: if set to `True` the output inverse gate will be returned\n        as :class:`.AnnotatedOperation`.\n\nReturns:\n    The inverse operation.\n\nRaises:\n    CircuitError: if the instruction is not composite\n        and an inverse has not been implemented for it.",
        "api_signature": "inverse(self, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "c_if",
        "full_api_name": "Instruction.c_if",
        "api_description": "Set a classical equality condition on this instruction between the register or cbit\n``classical`` and value ``val``.\n\n.. note::\n\n    This is a setter method, not an additive one.  Calling this multiple times will silently\n    override any previously set condition; it does not stack.",
        "api_signature": "c_if(self, classical, val)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "copy",
        "full_api_name": "Instruction.copy",
        "api_description": "Copy of the instruction.\n\nArgs:\n    name (str): name to be given to the copied circuit, if ``None`` then the name stays the same.\n\nReturns:\n    qiskit.circuit.Instruction: a copy of the current instruction, with the name updated if it\n    was provided",
        "api_signature": "copy(self, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "__deepcopy__",
        "full_api_name": "Instruction.__deepcopy__",
        "api_description": "",
        "api_signature": "__deepcopy__(self, memo)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "broadcast_arguments",
        "full_api_name": "Instruction.broadcast_arguments",
        "api_description": "Validation of the arguments.\n\nArgs:\n    qargs (List): List of quantum bit arguments.\n    cargs (List): List of classical bit arguments.\n\nYields:\n    Tuple(List, List): A tuple with single arguments.\n\nRaises:\n    CircuitError: If the input is not valid. For example, the number of\n        arguments does not match the gate expectation.",
        "api_signature": "broadcast_arguments(self, qargs, cargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "_return_repeat",
        "full_api_name": "Instruction._return_repeat",
        "api_description": "",
        "api_signature": "_return_repeat(self, exponent)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "repeat",
        "full_api_name": "Instruction.repeat",
        "api_description": "Creates an instruction with ``self`` repeated :math`n` times.\n\nIf this operation has a conditional, the output instruction will have the same conditional\nand the inner repeated operations will be unconditional; instructions within a compound\ndefinition cannot be conditioned on registers within Qiskit's data model.  This means that\nit is not valid to apply a repeated instruction to a clbit that it both writes to and reads\nfrom in its condition.\n\nArgs:\n    n (int): Number of times to repeat the instruction\n\nReturns:\n    qiskit.circuit.Instruction: Containing the definition.\n\nRaises:\n    CircuitError: If n < 1.",
        "api_signature": "repeat(self, n)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "condition_bits",
        "full_api_name": "Instruction.condition_bits",
        "api_description": "Get Clbits in condition.",
        "api_signature": "condition_bits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "name",
        "full_api_name": "Instruction.name",
        "api_description": "Return the name.",
        "api_signature": "name(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "name",
        "full_api_name": "Instruction.name",
        "api_description": "Set the name.",
        "api_signature": "name(self, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "num_qubits",
        "full_api_name": "Instruction.num_qubits",
        "api_description": "Return the number of qubits.",
        "api_signature": "num_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "num_qubits",
        "full_api_name": "Instruction.num_qubits",
        "api_description": "Set num_qubits.",
        "api_signature": "num_qubits(self, num_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "num_clbits",
        "full_api_name": "Instruction.num_clbits",
        "api_description": "Return the number of clbits.",
        "api_signature": "num_clbits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "num_clbits",
        "full_api_name": "Instruction.num_clbits",
        "api_description": "Set num_clbits.",
        "api_signature": "num_clbits(self, num_clbits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "_compare_parameters",
        "full_api_name": "Instruction._compare_parameters",
        "api_description": "",
        "api_signature": "_compare_parameters(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/instruction.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QuantumCircuit.__init__",
        "api_description": "Default constructor of :class:`QuantumCircuit`.\n\n..\n    `QuantumCirucit` documents its `__init__` method explicitly, unlike most classes where\n    it's implicitly appended to the class-level documentation, just because the class is so\n    huge and has a lot of introductory material to its class docstring.\n\nArgs:\n    regs: The registers to be included in the circuit.\n\n        * If a list of :class:`~.Register` objects, represents the :class:`.QuantumRegister`\n          and/or :class:`.ClassicalRegister` objects to include in the circuit.\n\n          For example:\n\n            * ``QuantumCircuit(QuantumRegister(4))``\n            * ``QuantumCircuit(QuantumRegister(4), ClassicalRegister(3))``\n            * ``QuantumCircuit(QuantumRegister(4, 'qr0'), QuantumRegister(2, 'qr1'))``\n\n        * If a list of ``int``, the amount of qubits and/or classical bits to include in\n          the circuit. It can either be a single int for just the number of quantum bits,\n          or 2 ints for the number of quantum bits and classical bits, respectively.\n\n          For example:\n\n            * ``QuantumCircuit(4) # A QuantumCircuit with 4 qubits``\n            * ``QuantumCircuit(4, 3) # A QuantumCircuit with 4 qubits and 3 classical bits``\n\n        * If a list of python lists containing :class:`.Bit` objects, a collection of\n          :class:`.Bit` s to be added to the circuit.\n\n    name: the name of the quantum circuit. If not set, an automatically generated string\n        will be assigned.\n    global_phase: The global phase of the circuit in radians.\n    metadata: Arbitrary key value metadata to associate with the circuit. This gets\n        stored as free-form data in a dict in the\n        :attr:`~qiskit.circuit.QuantumCircuit.metadata` attribute. It will not be directly\n        used in the circuit.\n    inputs: any variables to declare as ``input`` runtime variables for this circuit.  These\n        should already be existing :class:`.expr.Var` nodes that you build from somewhere\n        else; if you need to create the inputs as well, use\n        :meth:`QuantumCircuit.add_input`.  The variables given in this argument will be\n        passed directly to :meth:`add_input`.  A circuit cannot have both ``inputs`` and\n        ``captures``.\n    captures: any variables that that this circuit scope should capture from a containing\n        scope.  The variables given here will be passed directly to :meth:`add_capture`.  A\n        circuit cannot have both ``inputs`` and ``captures``.\n    declarations: any variables that this circuit should declare and initialize immediately.\n        You can order this input so that later declarations depend on earlier ones\n        (including inputs or captures). If you need to depend on values that will be\n        computed later at runtime, use :meth:`add_var` at an appropriate point in the\n        circuit execution.\n\n        This argument is intended for convenient circuit initialization when you already\n        have a set of created variables.  The variables used here will be directly passed to\n        :meth:`add_var`, which you can use directly if this is the first time you are\n        creating the variable.\n\nRaises:\n    CircuitError: if the circuit name, if given, is not valid.\n    CircuitError: if both ``inputs`` and ``captures`` are given.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "_from_circuit_data",
        "full_api_name": "QuantumCircuit._from_circuit_data",
        "api_description": "A private constructor from rust space circuit data.",
        "api_signature": "_from_circuit_data(cls, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "from_instructions",
        "full_api_name": "QuantumCircuit.from_instructions",
        "api_description": "Construct a circuit from an iterable of :class:`.CircuitInstruction`\\ s.\n\nArgs:\n    instructions: The instructions to add to the circuit.\n    qubits: Any qubits to add to the circuit. This argument can be used,\n        for example, to enforce a particular ordering of qubits.\n    clbits: Any classical bits to add to the circuit. This argument can be used,\n        for example, to enforce a particular ordering of classical bits.\n    name: The name of the circuit.\n    global_phase: The global phase of the circuit in radians.\n    metadata: Arbitrary key value metadata to associate with the circuit.\n\nReturns:\n    The quantum circuit.",
        "api_signature": "from_instructions(instructions)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "layout",
        "full_api_name": "QuantumCircuit.layout",
        "api_description": "Return any associated layout information about the circuit\n\nThis attribute contains an optional :class:`~.TranspileLayout`\nobject. This is typically set on the output from :func:`~.transpile`\nor :meth:`.PassManager.run` to retain information about the\npermutations caused on the input circuit by transpilation.\n\nThere are two types of permutations caused by the :func:`~.transpile`\nfunction, an initial layout which permutes the qubits based on the\nselected physical qubits on the :class:`~.Target`, and a final layout\nwhich is an output permutation caused by :class:`~.SwapGate`\\s\ninserted during routing.",
        "api_signature": "layout(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "data",
        "full_api_name": "QuantumCircuit.data",
        "api_description": "The circuit data (instructions and context).\n\nReturns:\n    QuantumCircuitData: a list-like object containing the :class:`.CircuitInstruction`\\ s\n    for each instruction.",
        "api_signature": "data(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "data",
        "full_api_name": "QuantumCircuit.data",
        "api_description": "Sets the circuit data from a list of instructions and context.\n\nArgs:\n    data_input (Iterable): A sequence of instructions with their execution contexts.  The\n        elements must either be instances of :class:`.CircuitInstruction` (preferred), or a\n        3-tuple of ``(instruction, qargs, cargs)`` (legacy).  In the legacy format,\n        ``instruction`` must be an :class:`~.circuit.Instruction`, while ``qargs`` and\n        ``cargs`` must be iterables of :class:`~.circuit.Qubit` or :class:`.Clbit`\n        specifiers (similar to the allowed forms in calls to :meth:`append`).",
        "api_signature": "data(self, data_input)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "op_start_times",
        "full_api_name": "QuantumCircuit.op_start_times",
        "api_description": "Return a list of operation start times.\n\nThis attribute is enabled once one of scheduling analysis passes\nruns on the quantum circuit.\n\nReturns:\n    List of integers representing instruction start times.\n    The index corresponds to the index of instruction in :attr:`QuantumCircuit.data`.\n\nRaises:\n    AttributeError: When circuit is not scheduled.",
        "api_signature": "op_start_times(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "calibrations",
        "full_api_name": "QuantumCircuit.calibrations",
        "api_description": "Return calibration dictionary.\n\nThe custom pulse definition of a given gate is of the form\n``{'gate_name': {(qubits, params): schedule}}``",
        "api_signature": "calibrations(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "calibrations",
        "full_api_name": "QuantumCircuit.calibrations",
        "api_description": "Set the circuit calibration data from a dictionary of calibration definition.\n\nArgs:\n    calibrations (dict): A dictionary of input in the format\n       ``{'gate_name': {(qubits, gate_params): schedule}}``",
        "api_signature": "calibrations(self, calibrations)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "has_calibration_for",
        "full_api_name": "QuantumCircuit.has_calibration_for",
        "api_description": "Return True if the circuit has a calibration defined for the instruction context. In this\ncase, the operation does not need to be translated to the device basis.",
        "api_signature": "has_calibration_for(self, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "metadata",
        "full_api_name": "QuantumCircuit.metadata",
        "api_description": "The user provided metadata associated with the circuit.\n\nThe metadata for the circuit is a user provided ``dict`` of metadata\nfor the circuit. It will not be used to influence the execution or\noperation of the circuit, but it is expected to be passed between\nall transforms of the circuit (ie transpilation) and that providers will\nassociate any circuit metadata with the results it returns from\nexecution of that circuit.",
        "api_signature": "metadata(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "metadata",
        "full_api_name": "QuantumCircuit.metadata",
        "api_description": "Update the circuit metadata",
        "api_signature": "metadata(self, metadata)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "QuantumCircuit.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "QuantumCircuit.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "__deepcopy__",
        "full_api_name": "QuantumCircuit.__deepcopy__",
        "api_description": "",
        "api_signature": "__deepcopy__(self, memo)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "_increment_instances",
        "full_api_name": "QuantumCircuit._increment_instances",
        "api_description": "",
        "api_signature": "_increment_instances(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "cls_instances",
        "full_api_name": "QuantumCircuit.cls_instances",
        "api_description": "Return the current number of instances of this class,\nuseful for auto naming.",
        "api_signature": "cls_instances(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "_cls_instances",
        "full_api_name": "QuantumCircuit._cls_instances",
        "api_description": "Return the current number of instances of this class,\nuseful for auto naming.",
        "api_signature": "_cls_instances(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "cls_prefix",
        "full_api_name": "QuantumCircuit.cls_prefix",
        "api_description": "Return the prefix to use for auto naming.",
        "api_signature": "cls_prefix(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "_cls_prefix",
        "full_api_name": "QuantumCircuit._cls_prefix",
        "api_description": "Return the prefix to use for auto naming.",
        "api_signature": "_cls_prefix(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "_name_update",
        "full_api_name": "QuantumCircuit._name_update",
        "api_description": "update name of instance using instance number",
        "api_signature": "_name_update(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "has_register",
        "full_api_name": "QuantumCircuit.has_register",
        "api_description": "Test if this circuit has the register r.\n\nArgs:\n    register (Register): a quantum or classical register.\n\nReturns:\n    bool: True if the register is contained in this circuit.",
        "api_signature": "has_register(self, register)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "reverse_ops",
        "full_api_name": "QuantumCircuit.reverse_ops",
        "api_description": "Reverse the circuit by reversing the order of instructions.\n\nThis is done by recursively reversing all instructions.\nIt does not invert (adjoint) any gate.\n\nReturns:\n    QuantumCircuit: the reversed circuit.\n\nExamples:\n\n    input:\n\n    .. parsed-literal::\n\n             \u250c\u2500\u2500\u2500\u2510\n        q_0: \u2524 H \u251c\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\n             \u2514\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2510\n        q_1: \u2500\u2500\u2500\u2500\u2500\u2524 RX(1.57) \u251c\n                  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    output:\n\n    .. parsed-literal::\n\n                         \u250c\u2500\u2500\u2500\u2510\n        q_0: \u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2524 H \u251c\n             \u250c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2510\u2514\u2500\u2500\u2500\u2518\n        q_1: \u2524 RX(1.57) \u251c\u2500\u2500\u2500\u2500\u2500\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
        "api_signature": "reverse_ops(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "reverse_bits",
        "full_api_name": "QuantumCircuit.reverse_bits",
        "api_description": "Return a circuit with the opposite order of wires.\n\nThe circuit is \"vertically\" flipped. If a circuit is\ndefined over multiple registers, the resulting circuit will have\nthe same registers but with their order flipped.\n\nThis method is useful for converting a circuit written in little-endian\nconvention to the big-endian equivalent, and vice versa.\n\nReturns:\n    QuantumCircuit: the circuit with reversed bit order.\n\nExamples:\n\n    input:\n\n    .. parsed-literal::\n\n             \u250c\u2500\u2500\u2500\u2510\n        a_0: \u2524 H \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n             \u2514\u2500\u2500\u2500\u2518\u250c\u2500\u2534\u2500\u2510\n        a_1: \u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                  \u2514\u2500\u2500\u2500\u2518\u250c\u2500\u2534\u2500\u2510\n        a_2: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                       \u2514\u2500\u2500\u2500\u2518\u250c\u2500\u2534\u2500\u2510\n        b_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u25a0\u2500\u2500\n                            \u2514\u2500\u2500\u2500\u2518\u250c\u2500\u2534\u2500\u2510\n        b_1: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\n                                 \u2514\u2500\u2500\u2500\u2518\n\n    output:\n\n    .. parsed-literal::\n\n                                 \u250c\u2500\u2500\u2500\u2510\n        b_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\n                            \u250c\u2500\u2500\u2500\u2510\u2514\u2500\u252c\u2500\u2518\n        b_1: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u25a0\u2500\u2500\n                       \u250c\u2500\u2500\u2500\u2510\u2514\u2500\u252c\u2500\u2518\n        a_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                  \u250c\u2500\u2500\u2500\u2510\u2514\u2500\u252c\u2500\u2518\n        a_1: \u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n             \u250c\u2500\u2500\u2500\u2510\u2514\u2500\u252c\u2500\u2518\n        a_2: \u2524 H \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n             \u2514\u2500\u2500\u2500\u2518",
        "api_signature": "reverse_bits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "QuantumCircuit.inverse",
        "api_description": "Invert (take adjoint of) this circuit.\n\nThis is done by recursively inverting all gates.\n\nArgs:\n    annotated: indicates whether the inverse gate can be implemented\n        as an annotated gate.\n\nReturns:\n    QuantumCircuit: the inverted circuit\n\nRaises:\n    CircuitError: if the circuit cannot be inverted.\n\nExamples:\n\n    input:\n\n    .. parsed-literal::\n\n             \u250c\u2500\u2500\u2500\u2510\n        q_0: \u2524 H \u251c\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\n             \u2514\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2510\n        q_1: \u2500\u2500\u2500\u2500\u2500\u2524 RX(1.57) \u251c\n                  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    output:\n\n    .. parsed-literal::\n\n                          \u250c\u2500\u2500\u2500\u2510\n        q_0: \u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2524 H \u251c\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2510\u2514\u2500\u2500\u2500\u2518\n        q_1: \u2524 RX(-1.57) \u251c\u2500\u2500\u2500\u2500\u2500\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
        "api_signature": "inverse(self, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "repeat",
        "full_api_name": "QuantumCircuit.repeat",
        "api_description": "Repeat this circuit ``reps`` times.\n\nArgs:\n    reps (int): How often this circuit should be repeated.\n    insert_barriers (bool): Whether to include barriers between circuit repetitions.\n\nReturns:\n    QuantumCircuit: A circuit containing ``reps`` repetitions of this circuit.",
        "api_signature": "repeat(self, reps)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "power",
        "full_api_name": "QuantumCircuit.power",
        "api_description": "Raise this circuit to the power of ``power``.\n\nIf ``power`` is a positive integer and both ``matrix_power`` and ``annotated``\nare ``False``, this implementation defaults to calling ``repeat``. Otherwise,\nthe circuit is converted into a gate, and a new circuit, containing this gate\nraised to the given power, is returned. The gate raised to the given power is\nimplemented either as a unitary gate if ``annotated`` is ``False`` or as an\nannotated operation if ``annotated`` is ``True``.\n\nArgs:\n    power (float): The power to raise this circuit to.\n    matrix_power (bool): indicates whether the inner power gate can be implemented\n        as a unitary gate.\n    annotated (bool): indicates whether the inner power gate can be implemented\n        as an annotated operation.\n\nRaises:\n    CircuitError: If the circuit needs to be converted to a unitary gate, but is\n        not unitary.\n\nReturns:\n    QuantumCircuit: A circuit implementing this circuit raised to the power of ``power``.",
        "api_signature": "power(self, power, matrix_power, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "control",
        "full_api_name": "QuantumCircuit.control",
        "api_description": "Control this circuit on ``num_ctrl_qubits`` qubits.\n\nArgs:\n    num_ctrl_qubits (int): The number of control qubits.\n    label (str): An optional label to give the controlled operation for visualization.\n    ctrl_state (str or int): The control state in decimal or as a bitstring\n        (e.g. '111'). If None, use ``2**num_ctrl_qubits - 1``.\n    annotated: indicates whether the controlled gate should be implemented\n        as an annotated gate.\n\nReturns:\n    QuantumCircuit: The controlled version of this circuit.\n\nRaises:\n    CircuitError: If the circuit contains a non-unitary operation and cannot be controlled.",
        "api_signature": "control(self, num_ctrl_qubits, label, ctrl_state, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "compose",
        "full_api_name": "QuantumCircuit.compose",
        "api_description": "Apply the instructions from one circuit onto specified qubits and/or clbits on another.\n\n.. note::\n\n    By default, this creates a new circuit object, leaving ``self`` untouched.  For most\n    uses of this function, it is far more efficient to set ``inplace=True`` and modify the\n    base circuit in-place.\n\nWhen dealing with realtime variables (:class:`.expr.Var` instances), there are two principal\nstrategies for using :meth:`compose`:\n\n1. The ``other`` circuit is treated as entirely additive, including its variables.  The\n   variables in ``other`` must be entirely distinct from those in ``self`` (use\n   ``var_remap`` to help with this), and all variables in ``other`` will be declared anew in\n   the output with matching input/capture/local scoping to how they are in ``other``.  This\n   is generally what you want if you're joining two unrelated circuits.\n\n2. The ``other`` circuit was created as an exact extension to ``self`` to be inlined onto\n   it, including acting on the existing variables in their states at the end of ``self``.\n   In this case, ``other`` should be created with all these variables to be inlined declared\n   as \"captures\", and then you can use ``inline_captures=True`` in this method to link them.\n   This is generally what you want if you're building up a circuit by defining layers\n   on-the-fly, or rebuilding a circuit using layers taken from itself.  You might find the\n   ``vars_mode=\"captures\"`` argument to :meth:`copy_empty_like` useful to create each\n   layer's base, in this case.\n\nArgs:\n    other (qiskit.circuit.Instruction or QuantumCircuit):\n        (sub)circuit or instruction to compose onto self.  If not a :obj:`.QuantumCircuit`,\n        this can be anything that :obj:`.append` will accept.\n    qubits (list[Qubit|int]): qubits of self to compose onto.\n    clbits (list[Clbit|int]): clbits of self to compose onto.\n    front (bool): If ``True``, front composition will be performed.  This is not possible within\n        control-flow builder context managers.\n    inplace (bool): If ``True``, modify the object. Otherwise, return composed circuit.\n    copy (bool): If ``True`` (the default), then the input is treated as shared, and any\n        contained instructions will be copied, if they might need to be mutated in the\n        future.  You can set this to ``False`` if the input should be considered owned by\n        the base circuit, in order to avoid unnecessary copies; in this case, it is not\n        valid to use ``other`` afterward, and some instructions may have been mutated in\n        place.\n    var_remap (Mapping): mapping to use to rewrite :class:`.expr.Var` nodes in ``other`` as\n        they are inlined into ``self``.  This can be used to avoid naming conflicts.\n\n        Both keys and values can be given as strings or direct :class:`.expr.Var` instances.\n        If a key is a string, it matches any :class:`~.expr.Var` with the same name.  If a\n        value is a string, whenever a new key matches a it, a new :class:`~.expr.Var` is\n        created with the correct type.  If a value is a :class:`~.expr.Var`, its\n        :class:`~.expr.Expr.type` must exactly match that of the variable it is replacing.\n    inline_captures (bool): if ``True``, then all \"captured\" :class:`~.expr.Var` nodes in\n        the ``other`` :class:`.QuantumCircuit` are assumed to refer to variables already\n        declared in ``self`` (as any input/capture/local type), and the uses in ``other``\n        will apply to the existing variables.  If you want to build up a layer for an\n        existing circuit to use with :meth:`compose`, you might find the\n        ``vars_mode=\"captures\"`` argument to :meth:`copy_empty_like` useful.  Any remapping\n        in ``vars_remap`` occurs before evaluating this variable inlining.\n\n        If this is ``False`` (the default), then all variables in ``other`` will be required\n        to be distinct from those in ``self``, and new declarations will be made for them.\n    wrap (bool): If True, wraps the other circuit into a gate (or instruction, depending on\n        whether it contains only unitary instructions) before composing it onto self.\n        Rather than using this option, it is almost always better to manually control this\n        yourself by using :meth:`to_instruction` or :meth:`to_gate`, and then call\n        :meth:`append`.\n\nReturns:\n    QuantumCircuit: the composed circuit (returns None if inplace==True).\n\nRaises:\n    CircuitError: if no correct wire mapping can be made between the two circuits, such as\n        if ``other`` is wider than ``self``.\n    CircuitError: if trying to emit a new circuit while ``self`` has a partially built\n        control-flow context active, such as the context-manager forms of :meth:`if_test`,\n        :meth:`for_loop` and :meth:`while_loop`.\n    CircuitError: if trying to compose to the front of a circuit when a control-flow builder\n        block is active; there is no clear meaning to this action.\n\nExamples:\n    .. code-block:: python\n\n        >>> lhs.compose(rhs, qubits=[3, 2], inplace=True)\n\n    .. parsed-literal::\n\n                    \u250c\u2500\u2500\u2500\u2510                   \u250c\u2500\u2500\u2500\u2500\u2500\u2510                \u250c\u2500\u2500\u2500\u2510\n        lqr_1_0: \u2500\u2500\u2500\u2524 H \u251c\u2500\u2500\u2500    rqr_0: \u2500\u2500\u25a0\u2500\u2500\u2524 Tdg \u251c    lqr_1_0: \u2500\u2500\u2500\u2524 H \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                    \u251c\u2500\u2500\u2500\u2524              \u250c\u2500\u2534\u2500\u2510\u2514\u2500\u2500\u2500\u2500\u2500\u2518                \u251c\u2500\u2500\u2500\u2524\n        lqr_1_1: \u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500    rqr_1: \u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500    lqr_1_1: \u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                 \u250c\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2510           \u2514\u2500\u2500\u2500\u2518                    \u250c\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\n        lqr_1_2: \u2524 U1(0.1) \u251c  +                     =  lqr_1_2: \u2524 U1(0.1) \u251c\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n        lqr_2_0: \u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500                           lqr_2_0: \u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2524 Tdg \u251c\n                    \u250c\u2500\u2534\u2500\u2510                                          \u250c\u2500\u2534\u2500\u2510        \u2514\u2500\u2500\u2500\u2500\u2500\u2518\n        lqr_2_1: \u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500                           lqr_2_1: \u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                    \u2514\u2500\u2500\u2500\u2518                                          \u2514\u2500\u2500\u2500\u2518\n        lcr_0: 0 \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550                           lcr_0: 0 \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n        lcr_1: 0 \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550                           lcr_1: 0 \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
        "api_signature": "compose(self, other, qubits, clbits, front, inplace, wrap)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "replace_var",
        "full_api_name": "QuantumCircuit.replace_var",
        "api_description": "",
        "api_signature": "replace_var(var, cache)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "copy_with_remapping",
        "full_api_name": "QuantumCircuit.copy_with_remapping",
        "api_description": "",
        "api_signature": "copy_with_remapping(source, dest, bit_map, var_map, inline_captures, new_qubits, new_clbits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "recurse_block",
        "full_api_name": "QuantumCircuit.recurse_block",
        "api_description": "",
        "api_signature": "recurse_block(block)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "map_vars",
        "full_api_name": "QuantumCircuit.map_vars",
        "api_description": "",
        "api_signature": "map_vars(op)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "tensor",
        "full_api_name": "QuantumCircuit.tensor",
        "api_description": "Tensor ``self`` with ``other``.\n\nRemember that in the little-endian convention the leftmost operation will be at the bottom\nof the circuit. See also\n`the docs <https://docs.quantum.ibm.com/build/circuit-construction>`__\nfor more information.\n\n.. parsed-literal::\n\n         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510        \u250c\u2500\u2500\u2500\u2500\u2500\u2510          \u250c\u2500\u2500\u2500\u2500\u2500\u2510\n    q_0: \u2524 bottom \u251c \u2297 q_0: \u2524 top \u251c  = q_0: \u2500\u2524 top \u251c\u2500\u2500\n         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518        \u2514\u2500\u2500\u2500\u2500\u2500\u2518         \u250c\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2510\n                                      q_1: \u2524 bottom \u251c\n                                           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nArgs:\n    other (QuantumCircuit): The other circuit to tensor this circuit with.\n    inplace (bool): If ``True``, modify the object. Otherwise return composed circuit.\n\nExamples:\n\n    .. plot::\n       :include-source:\n\n       from qiskit import QuantumCircuit\n       top = QuantumCircuit(1)\n       top.x(0);\n       bottom = QuantumCircuit(2)\n       bottom.cry(0.2, 0, 1);\n       tensored = bottom.tensor(top)\n       tensored.draw('mpl')\n\nReturns:\n    QuantumCircuit: The tensored circuit (returns ``None`` if ``inplace=True``).",
        "api_signature": "tensor(self, other, inplace)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "qubits",
        "full_api_name": "QuantumCircuit.qubits",
        "api_description": "A list of :class:`Qubit`\\ s in the order that they were added.  You should not mutate\nthis.",
        "api_signature": "qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "clbits",
        "full_api_name": "QuantumCircuit.clbits",
        "api_description": "A list of :class:`Clbit`\\ s in the order that they were added.  You should not mutate\nthis.",
        "api_signature": "clbits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "ancillas",
        "full_api_name": "QuantumCircuit.ancillas",
        "api_description": "A list of :class:`AncillaQubit`\\ s in the order that they were added.  You should not\nmutate this.",
        "api_signature": "ancillas(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "num_vars",
        "full_api_name": "QuantumCircuit.num_vars",
        "api_description": "The number of real-time classical variables in the circuit.\n\nThis is the length of the :meth:`iter_vars` iterable.",
        "api_signature": "num_vars(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "num_input_vars",
        "full_api_name": "QuantumCircuit.num_input_vars",
        "api_description": "The number of real-time classical variables in the circuit marked as circuit inputs.\n\nThis is the length of the :meth:`iter_input_vars` iterable.  If this is non-zero,\n:attr:`num_captured_vars` must be zero.",
        "api_signature": "num_input_vars(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "num_captured_vars",
        "full_api_name": "QuantumCircuit.num_captured_vars",
        "api_description": "The number of real-time classical variables in the circuit marked as captured from an\nenclosing scope.\n\nThis is the length of the :meth:`iter_captured_vars` iterable.  If this is non-zero,\n:attr:`num_input_vars` must be zero.",
        "api_signature": "num_captured_vars(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "num_declared_vars",
        "full_api_name": "QuantumCircuit.num_declared_vars",
        "api_description": "The number of real-time classical variables in the circuit that are declared by this\ncircuit scope, excluding inputs or captures.\n\nThis is the length of the :meth:`iter_declared_vars` iterable.",
        "api_signature": "num_declared_vars(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "iter_vars",
        "full_api_name": "QuantumCircuit.iter_vars",
        "api_description": "Get an iterable over all real-time classical variables in scope within this circuit.\n\nThis method will iterate over all variables in scope.  For more fine-grained iterators, see\n:meth:`iter_declared_vars`, :meth:`iter_input_vars` and :meth:`iter_captured_vars`.",
        "api_signature": "iter_vars(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "iter_declared_vars",
        "full_api_name": "QuantumCircuit.iter_declared_vars",
        "api_description": "Get an iterable over all real-time classical variables that are declared with automatic\nstorage duration in this scope.  This excludes input variables (see :meth:`iter_input_vars`)\nand captured variables (see :meth:`iter_captured_vars`).",
        "api_signature": "iter_declared_vars(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "iter_input_vars",
        "full_api_name": "QuantumCircuit.iter_input_vars",
        "api_description": "Get an iterable over all real-time classical variables that are declared as inputs to\nthis circuit scope.  This excludes locally declared variables (see\n:meth:`iter_declared_vars`) and captured variables (see :meth:`iter_captured_vars`).",
        "api_signature": "iter_input_vars(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "iter_captured_vars",
        "full_api_name": "QuantumCircuit.iter_captured_vars",
        "api_description": "Get an iterable over all real-time classical variables that are captured by this circuit\nscope from a containing scope.  This excludes input variables (see :meth:`iter_input_vars`)\nand locally declared variables (see :meth:`iter_declared_vars`).",
        "api_signature": "iter_captured_vars(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "__and__",
        "full_api_name": "QuantumCircuit.__and__",
        "api_description": "Overload & to implement self.compose.",
        "api_signature": "__and__(self, rhs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "__iand__",
        "full_api_name": "QuantumCircuit.__iand__",
        "api_description": "Overload &= to implement self.compose in place.",
        "api_signature": "__iand__(self, rhs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "__xor__",
        "full_api_name": "QuantumCircuit.__xor__",
        "api_description": "Overload ^ to implement self.tensor.",
        "api_signature": "__xor__(self, top)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "__ixor__",
        "full_api_name": "QuantumCircuit.__ixor__",
        "api_description": "Overload ^= to implement self.tensor in place.",
        "api_signature": "__ixor__(self, top)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "__len__",
        "full_api_name": "QuantumCircuit.__len__",
        "api_description": "Return number of operations in circuit.",
        "api_signature": "__len__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "__getitem__",
        "full_api_name": "QuantumCircuit.__getitem__",
        "api_description": "",
        "api_signature": "__getitem__(self, item)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "__getitem__",
        "full_api_name": "QuantumCircuit.__getitem__",
        "api_description": "",
        "api_signature": "__getitem__(self, item)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "__getitem__",
        "full_api_name": "QuantumCircuit.__getitem__",
        "api_description": "Return indexed operation.",
        "api_signature": "__getitem__(self, item)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "cast",
        "full_api_name": "QuantumCircuit.cast",
        "api_description": "Best effort to cast value to type. Otherwise, returns the value.",
        "api_signature": "cast(value, type_)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "_cast",
        "full_api_name": "QuantumCircuit._cast",
        "api_description": "Best effort to cast value to type. Otherwise, returns the value.",
        "api_signature": "_cast(value, type_)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "qbit_argument_conversion",
        "full_api_name": "QuantumCircuit.qbit_argument_conversion",
        "api_description": "Converts several qubit representations (such as indexes, range, etc.)\ninto a list of qubits.\n\nArgs:\n    qubit_representation: Representation to expand.\n\nReturns:\n    The resolved instances of the qubits.",
        "api_signature": "qbit_argument_conversion(self, qubit_representation)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "_qbit_argument_conversion",
        "full_api_name": "QuantumCircuit._qbit_argument_conversion",
        "api_description": "Converts several qubit representations (such as indexes, range, etc.)\ninto a list of qubits.\n\nArgs:\n    qubit_representation: Representation to expand.\n\nReturns:\n    The resolved instances of the qubits.",
        "api_signature": "_qbit_argument_conversion(self, qubit_representation)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "cbit_argument_conversion",
        "full_api_name": "QuantumCircuit.cbit_argument_conversion",
        "api_description": "Converts several classical bit representations (such as indexes, range, etc.)\ninto a list of classical bits.\n\nArgs:\n    clbit_representation : Representation to expand.\n\nReturns:\n    A list of tuples where each tuple is a classical bit.",
        "api_signature": "cbit_argument_conversion(self, clbit_representation)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "_cbit_argument_conversion",
        "full_api_name": "QuantumCircuit._cbit_argument_conversion",
        "api_description": "Converts several classical bit representations (such as indexes, range, etc.)\ninto a list of classical bits.\n\nArgs:\n    clbit_representation: Representation to expand.\n\nReturns:\n    A list of tuples where each tuple is a classical bit.",
        "api_signature": "_cbit_argument_conversion(self, clbit_representation)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "_append_standard_gate",
        "full_api_name": "QuantumCircuit._append_standard_gate",
        "api_description": "An internal method to bypass some checking when directly appending a standard gate.",
        "api_signature": "_append_standard_gate(self, op, qargs, params, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "append",
        "full_api_name": "QuantumCircuit.append",
        "api_description": "Append one or more instructions to the end of the circuit, modifying the circuit in\nplace.\n\nThe ``qargs`` and ``cargs`` will be expanded and broadcast according to the rules of the\ngiven :class:`~.circuit.Instruction`, and any non-:class:`.Bit` specifiers (such as\ninteger indices) will be resolved into the relevant instances.\n\nIf a :class:`.CircuitInstruction` is given, it will be unwrapped, verified in the context of\nthis circuit, and a new object will be appended to the circuit.  In this case, you may not\npass ``qargs`` or ``cargs`` separately.\n\nArgs:\n    instruction: :class:`~.circuit.Instruction` instance to append, or a\n        :class:`.CircuitInstruction` with all its context.\n    qargs: specifiers of the :class:`~.circuit.Qubit`\\ s to attach instruction to.\n    cargs: specifiers of the :class:`.Clbit`\\ s to attach instruction to.\n    copy: if ``True`` (the default), then the incoming ``instruction`` is copied before\n        adding it to the circuit if it contains symbolic parameters, so it can be safely\n        mutated without affecting other circuits the same instruction might be in.  If you\n        are sure this instruction will not be in other circuits, you can set this ``False``\n        for a small speedup.\n\nReturns:\n    qiskit.circuit.InstructionSet: a handle to the :class:`.CircuitInstruction`\\ s that\n    were actually added to the circuit.\n\nRaises:\n    CircuitError: if the operation passed is not an instance of :class:`~.circuit.Instruction` .",
        "api_signature": "append(self, instruction, qargs, cargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "_append",
        "full_api_name": "QuantumCircuit._append",
        "api_description": "",
        "api_signature": "_append(self, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "_append",
        "full_api_name": "QuantumCircuit._append",
        "api_description": "",
        "api_signature": "_append(self, instruction, qargs, cargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "_append",
        "full_api_name": "QuantumCircuit._append",
        "api_description": "Append an instruction to the end of the circuit, modifying the circuit in place.\n\n.. warning::\n\n    This is an internal fast-path function, and it is the responsibility of the caller to\n    ensure that all the arguments are valid; there is no error checking here.  In\n    particular:\n\n    * all the qubits and clbits must already exist in the circuit and there can be no\n      duplicates in the list.\n    * any control-flow operations or classically conditioned instructions must act only on\n      variables present in the circuit.\n    * the circuit must not be within a control-flow builder context.\n\n.. note::\n\n    This function may be used by callers other than :obj:`.QuantumCircuit` when the caller\n    is sure that all error-checking, broadcasting and scoping has already been performed,\n    and the only reference to the circuit the instructions are being appended to is within\n    that same function.  In particular, it is not safe to call\n    :meth:`QuantumCircuit._append` on a circuit that is received by a function argument.\n    This is because :meth:`.QuantumCircuit._append` will not recognize the scoping\n    constructs of the control-flow builder interface.\n\nArgs:\n    instruction: A complete well-formed :class:`.CircuitInstruction` of the operation and\n        its context to be added.\n\n        In the legacy compatibility form, this can be a bare :class:`.Operation`, in which\n        case ``qargs`` and ``cargs`` must be explicitly given.\n    qargs: Legacy argument for qubits to attach the bare :class:`.Operation` to.  Ignored if\n        the first argument is in the preferential :class:`.CircuitInstruction` form.\n    cargs: Legacy argument for clbits to attach the bare :class:`.Operation` to.  Ignored if\n        the first argument is in the preferential :class:`.CircuitInstruction` form.\n\nReturns:\n    CircuitInstruction: a handle to the instruction that was just added.\n\n:meta public:",
        "api_signature": "_append(self, instruction, qargs, cargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "get_parameter",
        "full_api_name": "QuantumCircuit.get_parameter",
        "api_description": "",
        "api_signature": "get_parameter(self, name, default)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "get_parameter",
        "full_api_name": "QuantumCircuit.get_parameter",
        "api_description": "",
        "api_signature": "get_parameter(self, name, default)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "get_parameter",
        "full_api_name": "QuantumCircuit.get_parameter",
        "api_description": "Retrieve a compile-time parameter that is accessible in this circuit scope by name.\n\nArgs:\n    name: the name of the parameter to retrieve.\n    default: if given, this value will be returned if the parameter is not present.  If it\n        is not given, a :exc:`KeyError` is raised instead.\n\nReturns:\n    The corresponding parameter.\n\nRaises:\n    KeyError: if no default is given, but the parameter does not exist in the circuit.\n\nExamples:\n    Retrieve a parameter by name from a circuit::\n\n        from qiskit.circuit import QuantumCircuit, Parameter\n\n        my_param = Parameter(\"my_param\")\n\n        # Create a parametrized circuit.\n        qc = QuantumCircuit(1)\n        qc.rx(my_param, 0)\n\n        # We can use 'my_param' as a parameter, but let's say we've lost the Python object\n        # and need to retrieve it.\n        my_param_again = qc.get_parameter(\"my_param\")\n\n        assert my_param is my_param_again\n\n    Get a variable from a circuit by name, returning some default if it is not present::\n\n        assert qc.get_parameter(\"my_param\", None) is my_param\n        assert qc.get_parameter(\"unknown_param\", None) is None\n\nSee also:\n    :meth:`get_var`\n        A similar method, but for :class:`.expr.Var` run-time variables instead of\n        :class:`.Parameter` compile-time parameters.",
        "api_signature": "get_parameter(self, name, default)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "has_parameter",
        "full_api_name": "QuantumCircuit.has_parameter",
        "api_description": "Check whether a parameter object exists in this circuit.\n\nArgs:\n    name_or_param: the parameter, or name of a parameter to check.  If this is a\n        :class:`.Parameter` node, the parameter must be exactly the given one for this\n        function to return ``True``.\n\nReturns:\n    whether a matching parameter is assignable in this circuit.\n\nSee also:\n    :meth:`QuantumCircuit.get_parameter`\n        Retrieve the :class:`.Parameter` instance from this circuit by name.\n    :meth:`QuantumCircuit.has_var`\n        A similar method to this, but for run-time :class:`.expr.Var` variables instead of\n        compile-time :class:`.Parameter`\\ s.",
        "api_signature": "has_parameter()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "get_var",
        "full_api_name": "QuantumCircuit.get_var",
        "api_description": "",
        "api_signature": "get_var(self, name, default)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "get_var",
        "full_api_name": "QuantumCircuit.get_var",
        "api_description": "",
        "api_signature": "get_var(self, name, default)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "get_var",
        "full_api_name": "QuantumCircuit.get_var",
        "api_description": "Retrieve a variable that is accessible in this circuit scope by name.\n\nArgs:\n    name: the name of the variable to retrieve.\n    default: if given, this value will be returned if the variable is not present.  If it\n        is not given, a :exc:`KeyError` is raised instead.\n\nReturns:\n    The corresponding variable.\n\nRaises:\n    KeyError: if no default is given, but the variable does not exist.\n\nExamples:\n    Retrieve a variable by name from a circuit::\n\n        from qiskit.circuit import QuantumCircuit\n\n        # Create a circuit and create a variable in it.\n        qc = QuantumCircuit()\n        my_var = qc.add_var(\"my_var\", False)\n\n        # We can use 'my_var' as a variable, but let's say we've lost the Python object and\n        # need to retrieve it.\n        my_var_again = qc.get_var(\"my_var\")\n\n        assert my_var is my_var_again\n\n    Get a variable from a circuit by name, returning some default if it is not present::\n\n        assert qc.get_var(\"my_var\", None) is my_var\n        assert qc.get_var(\"unknown_variable\", None) is None\n\nSee also:\n    :meth:`get_parameter`\n        A similar method, but for :class:`.Parameter` compile-time parameters instead of\n        :class:`.expr.Var` run-time variables.",
        "api_signature": "get_var(self, name, default)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "has_var",
        "full_api_name": "QuantumCircuit.has_var",
        "api_description": "Check whether a variable is accessible in this scope.\n\nArgs:\n    name_or_var: the variable, or name of a variable to check.  If this is a\n        :class:`.expr.Var` node, the variable must be exactly the given one for this\n        function to return ``True``.\n\nReturns:\n    whether a matching variable is accessible.\n\nSee also:\n    :meth:`QuantumCircuit.get_var`\n        Retrieve the :class:`.expr.Var` instance from this circuit by name.\n    :meth:`QuantumCircuit.has_parameter`\n        A similar method to this, but for compile-time :class:`.Parameter`\\ s instead of\n        run-time :class:`.expr.Var` variables.",
        "api_signature": "has_var()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "_prepare_new_var",
        "full_api_name": "QuantumCircuit._prepare_new_var",
        "api_description": "The common logic for preparing and validating a new :class:`~.expr.Var` for the circuit.\n\nThe given ``type_`` can be ``None`` if the variable specifier is already a :class:`.Var`,\nand must be a :class:`~.types.Type` if it is a string.  The argument is ignored if the given\nfirst argument is a :class:`.Var` already.\n\nReturns the validated variable, which is guaranteed to be safe to add to the circuit.",
        "api_signature": "_prepare_new_var()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "add_var",
        "full_api_name": "QuantumCircuit.add_var",
        "api_description": "Add a classical variable with automatic storage and scope to this circuit.\n\nThe variable is considered to have been \"declared\" at the beginning of the circuit, but it\nonly becomes initialized at the point of the circuit that you call this method, so it can\ndepend on variables defined before it.\n\nArgs:\n    name_or_var: either a string of the variable name, or an existing instance of\n        :class:`~.expr.Var` to re-use.  Variables cannot shadow names that are already in\n        use within the circuit.\n    initial: the value to initialize this variable with.  If the first argument was given\n        as a string name, the type of the resulting variable is inferred from the initial\n        expression; to control this more manually, either use :meth:`.Var.new` to manually\n        construct a new variable with the desired type, or use :func:`.expr.cast` to cast\n        the initializer to the desired type.\n\n        This must be either a :class:`~.expr.Expr` node, or a value that can be lifted to\n        one using :class:`.expr.lift`.\n\nReturns:\n    The created variable.  If a :class:`~.expr.Var` instance was given, the exact same\n    object will be returned.\n\nRaises:\n    CircuitError: if the variable cannot be created due to shadowing an existing variable.\n\nExamples:\n    Define a new variable given just a name and an initializer expression::\n\n        from qiskit.circuit import QuantumCircuit\n\n        qc = QuantumCircuit(2)\n        my_var = qc.add_var(\"my_var\", False)\n\n    Reuse a variable that may have been taken from a related circuit, or otherwise\n    constructed manually, and initialize it to some more complicated expression::\n\n        from qiskit.circuit import QuantumCircuit, QuantumRegister, ClassicalRegister\n        from qiskit.circuit.classical import expr, types\n\n        my_var = expr.Var.new(\"my_var\", types.Uint(8))\n\n        cr1 = ClassicalRegister(8, \"cr1\")\n        cr2 = ClassicalRegister(8, \"cr2\")\n        qc = QuantumCircuit(QuantumRegister(8), cr1, cr2)\n\n        # Get some measurement results into each register.\n        qc.h(0)\n        for i in range(1, 8):\n            qc.cx(0, i)\n        qc.measure(range(8), cr1)\n\n        qc.reset(range(8))\n        qc.h(0)\n        for i in range(1, 8):\n            qc.cx(0, i)\n        qc.measure(range(8), cr2)\n\n        # Now when we add the variable, it is initialized using the real-time state of the\n        # two classical registers we measured into above.\n        qc.add_var(my_var, expr.bit_and(cr1, cr2))",
        "api_signature": "add_var(initial)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "add_uninitialized_var",
        "full_api_name": "QuantumCircuit.add_uninitialized_var",
        "api_description": "Add a variable with no initializer.\n\nIn most cases, you should use :meth:`add_var` to initialize the variable.  To use this\nfunction, you must already hold a :class:`~.expr.Var` instance, as the use of the function\ntypically only makes sense in copying contexts.\n\n.. warning::\n\n    Qiskit makes no assertions about what an uninitialized variable will evaluate to at\n    runtime, and some hardware may reject this as an error.\n\n    You should treat this function with caution, and as a low-level primitive that is useful\n    only in special cases of programmatically rebuilding two like circuits.\n\nArgs:\n    var: the variable to add.",
        "api_signature": "add_uninitialized_var()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "add_capture",
        "full_api_name": "QuantumCircuit.add_capture",
        "api_description": "Add a variable to the circuit that it should capture from a scope it will be contained\nwithin.\n\nThis method requires a :class:`~.expr.Var` node to enforce that you've got a handle to one,\nbecause you will need to declare the same variable using the same object into the outer\ncircuit.\n\nThis is a low-level method, which is only really useful if you are manually constructing\ncontrol-flow operations. You typically will not need to call this method, assuming you\nare using the builder interface for control-flow scopes (``with`` context-manager statements\nfor :meth:`if_test` and the other scoping constructs).  The builder interface will\nautomatically make the inner scopes closures on your behalf by capturing any variables that\nare used within them.\n\nArgs:\n    var: the variable to capture from an enclosing scope.\n\nRaises:\n    CircuitError: if the variable cannot be created due to shadowing an existing variable.",
        "api_signature": "add_capture(self, var)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "add_input",
        "full_api_name": "QuantumCircuit.add_input",
        "api_description": "",
        "api_signature": "add_input()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "add_input",
        "full_api_name": "QuantumCircuit.add_input",
        "api_description": "",
        "api_signature": "add_input()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "add_input",
        "full_api_name": "QuantumCircuit.add_input",
        "api_description": "Register a variable as an input to the circuit.\n\nArgs:\n    name_or_var: either a string name, or an existing :class:`~.expr.Var` node to use as the\n        input variable.\n    type_: if the name is given as a string, then this must be a :class:`~.types.Type` to\n        use for the variable.  If the variable is given as an existing :class:`~.expr.Var`,\n        then this must not be given, and will instead be read from the object itself.\n\nReturns:\n    the variable created, or the same variable as was passed in.\n\nRaises:\n    CircuitError: if the variable cannot be created due to shadowing an existing variable.",
        "api_signature": "add_input()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "add_register",
        "full_api_name": "QuantumCircuit.add_register",
        "api_description": "Add registers.",
        "api_signature": "add_register(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "add_bits",
        "full_api_name": "QuantumCircuit.add_bits",
        "api_description": "Add Bits to the circuit.",
        "api_signature": "add_bits(self, bits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "find_bit",
        "full_api_name": "QuantumCircuit.find_bit",
        "api_description": "Find locations in the circuit which can be used to reference a given :obj:`~Bit`.\n\nIn particular, this function can find the integer index of a qubit, which corresponds to its\nhardware index for a transpiled circuit.\n\n.. note::\n    The circuit index of a :class:`.AncillaQubit` will be its index in :attr:`qubits`, not\n    :attr:`ancillas`.\n\nArgs:\n    bit (Bit): The bit to locate.\n\nReturns:\n    namedtuple(int, List[Tuple(Register, int)]): A 2-tuple. The first element (``index``)\n    contains the index at which the ``Bit`` can be found (in either\n    :obj:`~QuantumCircuit.qubits`, :obj:`~QuantumCircuit.clbits`, depending on its\n    type). The second element (``registers``) is a list of ``(register, index)``\n    pairs with an entry for each :obj:`~Register` in the circuit which contains the\n    :obj:`~Bit` (and the index in the :obj:`~Register` at which it can be found).\n\nRaises:\n    CircuitError: If the supplied :obj:`~Bit` was of an unknown type.\n    CircuitError: If the supplied :obj:`~Bit` could not be found on the circuit.\n\nExamples:\n    Loop through a circuit, getting the qubit and clbit indices of each operation::\n\n        from qiskit.circuit import QuantumCircuit, Qubit\n\n        qc = QuantumCircuit(3, 3)\n        qc.h(0)\n        qc.cx(0, 1)\n        qc.cx(1, 2)\n        qc.measure([0, 1, 2], [0, 1, 2])\n\n        # The `.qubits` and `.clbits` fields are not integers.\n        assert isinstance(qc.data[0].qubits[0], Qubit)\n        # ... but we can use `find_bit` to retrieve them.\n        assert qc.find_bit(qc.data[0].qubits[0]).index == 0\n\n        simple = [\n            (\n                instruction.operation.name,\n                [qc.find_bit(bit).index for bit in instruction.qubits],\n                [qc.find_bit(bit).index for bit in instruction.clbits],\n            )\n            for instruction in qc.data\n        ]",
        "api_signature": "find_bit(self, bit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "_check_dups",
        "full_api_name": "QuantumCircuit._check_dups",
        "api_description": "Raise exception if list of qubits contains duplicates.",
        "api_signature": "_check_dups(self, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "to_instruction",
        "full_api_name": "QuantumCircuit.to_instruction",
        "api_description": "Create an :class:`~.circuit.Instruction` out of this circuit.\n\n.. seealso::\n    :func:`circuit_to_instruction`\n        The underlying driver of this method.\n\nArgs:\n    parameter_map: For parameterized circuits, a mapping from\n       parameters in the circuit to parameters to be used in the\n       instruction. If None, existing circuit parameters will also\n       parameterize the instruction.\n    label: Optional gate label.\n\nReturns:\n    qiskit.circuit.Instruction: a composite instruction encapsulating this circuit (can be\n        decomposed back).",
        "api_signature": "to_instruction(self, parameter_map, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "to_gate",
        "full_api_name": "QuantumCircuit.to_gate",
        "api_description": "Create a :class:`.Gate` out of this circuit.  The circuit must act only qubits and\ncontain only unitary operations.\n\n.. seealso::\n    :func:`circuit_to_gate`\n        The underlying driver of this method.\n\nArgs:\n    parameter_map: For parameterized circuits, a mapping from parameters in the circuit to\n        parameters to be used in the gate. If ``None``, existing circuit parameters will\n        also parameterize the gate.\n    label : Optional gate label.\n\nReturns:\n    Gate: a composite gate encapsulating this circuit (can be decomposed back).",
        "api_signature": "to_gate(self, parameter_map, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "decompose",
        "full_api_name": "QuantumCircuit.decompose",
        "api_description": "Call a decomposition pass on this circuit,\nto decompose one level (shallow decompose).\n\nArgs:\n    gates_to_decompose (type or str or list(type, str)): Optional subset of gates\n        to decompose. Can be a gate type, such as ``HGate``, or a gate name, such\n        as 'h', or a gate label, such as 'My H Gate', or a list of any combination\n        of these. If a gate name is entered, it will decompose all gates with that\n        name, whether the gates have labels or not. Defaults to all gates in circuit.\n    reps (int): Optional number of times the circuit should be decomposed.\n        For instance, ``reps=2`` equals calling ``circuit.decompose().decompose()``.\n        can decompose specific gates specific time\n\nReturns:\n    QuantumCircuit: a circuit one level decomposed",
        "api_signature": "decompose(self, gates_to_decompose, reps)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "draw",
        "full_api_name": "QuantumCircuit.draw",
        "api_description": "Draw the quantum circuit. Use the output parameter to choose the drawing format:\n\n**text**: ASCII art TextDrawing that can be printed in the console.\n\n**mpl**: images with color rendered purely in Python using matplotlib.\n\n**latex**: high-quality images compiled via latex.\n\n**latex_source**: raw uncompiled latex output.\n\n.. warning::\n\n    Support for :class:`~.expr.Expr` nodes in conditions and :attr:`.SwitchCaseOp.target`\n    fields is preliminary and incomplete.  The ``text`` and ``mpl`` drawers will make a\n    best-effort attempt to show data dependencies, but the LaTeX-based drawers will skip\n    these completely.\n\nArgs:\n    output: Select the output method to use for drawing the circuit.\n        Valid choices are ``text``, ``mpl``, ``latex``, ``latex_source``.\n        By default, the ``text`` drawer is used unless the user config file\n        (usually ``~/.qiskit/settings.conf``) has an alternative backend set\n        as the default. For example, ``circuit_drawer = latex``. If the output\n        kwarg is set, that backend will always be used over the default in\n        the user config file.\n    scale: Scale of image to draw (shrink if ``< 1.0``). Only used by\n        the ``mpl``, ``latex`` and ``latex_source`` outputs. Defaults to ``1.0``.\n    filename: File path to save image to. Defaults to ``None`` (result not saved in a file).\n    style: Style name, file name of style JSON file, or a dictionary specifying the style.\n\n        * The supported style names are ``\"iqp\"`` (default), ``\"iqp-dark\"``, ``\"clifford\"``,\n          ``\"textbook\"`` and ``\"bw\"``.\n        * If given a JSON file, e.g. ``my_style.json`` or ``my_style`` (the ``.json``\n          extension may be omitted), this function attempts to load the style dictionary\n          from that location. Note, that the JSON file must completely specify the\n          visualization specifications. The file is searched for in\n          ``qiskit/visualization/circuit/styles``, the current working directory, and\n          the location specified in ``~/.qiskit/settings.conf``.\n        * If a dictionary, every entry overrides the default configuration. If the\n          ``\"name\"`` key is given, the default configuration is given by that style.\n          For example, ``{\"name\": \"textbook\", \"subfontsize\": 5}`` loads the ``\"texbook\"``\n          style and sets the subfontsize (e.g. the gate angles) to ``5``.\n        * If ``None`` the default style ``\"iqp\"`` is used or, if given, the default style\n          specified in ``~/.qiskit/settings.conf``.\n\n    interactive: When set to ``True``, show the circuit in a new window\n        (for ``mpl`` this depends on the matplotlib backend being used\n        supporting this). Note when used with either the `text` or the\n        ``latex_source`` output type this has no effect and will be silently\n        ignored. Defaults to ``False``.\n    reverse_bits: When set to ``True``, reverse the bit order inside\n        registers for the output visualization. Defaults to ``False`` unless the\n        user config file (usually ``~/.qiskit/settings.conf``) has an\n        alternative value set. For example, ``circuit_reverse_bits = True``.\n    plot_barriers: Enable/disable drawing barriers in the output\n        circuit. Defaults to ``True``.\n    justify: Options are ``\"left\"``, ``\"right\"`` or ``\"none\"`` (str).\n        If anything else is supplied, left justified will be used instead.\n        It refers to where gates should be placed in the output circuit if\n        there is an option. ``none`` results in each gate being placed in\n        its own column. Defaults to ``left``.\n    vertical_compression: ``high``, ``medium`` or ``low``. It\n        merges the lines generated by the `text` output so the drawing\n        will take less vertical room.  Default is ``medium``. Only used by\n        the ``text`` output, will be silently ignored otherwise.\n    idle_wires: Include idle wires (wires with no circuit elements)\n        in output visualization. Default is ``True`` unless the\n        user config file (usually ``~/.qiskit/settings.conf``) has an\n        alternative value set. For example, ``circuit_idle_wires = False``.\n    with_layout: Include layout information, with labels on the\n        physical layout. Default is ``True``.\n    fold: Sets pagination. It can be disabled using -1. In ``text``,\n        sets the length of the lines. This is useful when the drawing does\n        not fit in the console. If None (default), it will try to guess the\n        console width using ``shutil.get_terminal_size()``. However, if\n        running in jupyter, the default line length is set to 80 characters.\n        In ``mpl``, it is the number of (visual) layers before folding.\n        Default is 25.\n    ax: Only used by the `mpl` backend. An optional ``matplotlib.axes.Axes``\n        object to be used for the visualization output. If none is\n        specified, a new matplotlib Figure will be created and used.\n        Additionally, if specified there will be no returned Figure since\n        it is redundant.\n    initial_state: Adds :math:`|0\\rangle` in the beginning of the qubit wires and\n        :math:`0` to classical wires. Default is ``False``.\n    cregbundle: If set to ``True``, bundle classical registers.\n        Default is ``True``, except for when ``output`` is set to  ``\"text\"``.\n    wire_order: A list of integers used to reorder the display\n        of the bits. The list must have an entry for every bit with the bits\n        in the range 0 to (``num_qubits`` + ``num_clbits``).\n    expr_len: The number of characters to display if an :class:`~.expr.Expr`\n        is used for the condition in a :class:`.ControlFlowOp`. If this number is exceeded,\n        the string will be truncated at that number and '...' added to the end.\n\nReturns:\n    :class:`.TextDrawing` or :class:`matplotlib.figure` or :class:`PIL.Image` or\n    :class:`str`:\n\n    * ``TextDrawing`` (if ``output='text'``)\n        A drawing that can be printed as ascii art.\n    * ``matplotlib.figure.Figure`` (if ``output='mpl'``)\n        A matplotlib figure object for the circuit diagram.\n    * ``PIL.Image`` (if ``output='latex``')\n        An in-memory representation of the image of the circuit diagram.\n    * ``str`` (if ``output='latex_source'``)\n        The LaTeX source code for visualizing the circuit diagram.\n\nRaises:\n    VisualizationError: when an invalid output method is selected\n    ImportError: when the output methods requires non-installed libraries.\n\nExample:\n    .. plot::\n       :include-source:\n\n       from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit\n       qc = QuantumCircuit(1, 1)\n       qc.h(0)\n       qc.measure(0, 0)\n       qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})",
        "api_signature": "draw(self, output, scale, filename, style, interactive, plot_barriers, reverse_bits, justify, vertical_compression, idle_wires, with_layout, fold, ax, initial_state, cregbundle, wire_order, expr_len)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "size",
        "full_api_name": "QuantumCircuit.size",
        "api_description": "Returns total number of instructions in circuit.\n\nArgs:\n    filter_function (callable): a function to filter out some instructions.\n        Should take as input a tuple of (Instruction, list(Qubit), list(Clbit)).\n        By default, filters out \"directives\", such as barrier or snapshot.\n\nReturns:\n    int: Total number of gate operations.",
        "api_signature": "size(self, filter_function)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "depth",
        "full_api_name": "QuantumCircuit.depth",
        "api_description": "Return circuit depth (i.e., length of critical path).\n\n.. warning::\n    This operation is not well defined if the circuit contains control-flow operations.\n\nArgs:\n    filter_function: A function to decide which instructions count to increase depth.\n        Should take as a single positional input a :class:`CircuitInstruction`.\n        Instructions for which the function returns ``False`` are ignored in the\n        computation of the circuit depth.  By default, filters out \"directives\", such as\n        :class:`.Barrier`.\n\nReturns:\n    int: Depth of circuit.\n\nExamples:\n    Simple calculation of total circuit depth::\n\n        from qiskit.circuit import QuantumCircuit\n        qc = QuantumCircuit(4)\n        qc.h(0)\n        qc.cx(0, 1)\n        qc.h(2)\n        qc.cx(2, 3)\n        assert qc.depth() == 2\n\n    Modifying the previous example to only calculate the depth of multi-qubit gates::\n\n        assert qc.depth(lambda instr: len(instr.qubits) > 1) == 1",
        "api_signature": "depth(self, filter_function)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "update_from_expr",
        "full_api_name": "QuantumCircuit.update_from_expr",
        "api_description": "",
        "api_signature": "update_from_expr(objects, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "width",
        "full_api_name": "QuantumCircuit.width",
        "api_description": "Return number of qubits plus clbits in circuit.\n\nReturns:\n    int: Width of circuit.",
        "api_signature": "width(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "num_qubits",
        "full_api_name": "QuantumCircuit.num_qubits",
        "api_description": "Return number of qubits.",
        "api_signature": "num_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "num_ancillas",
        "full_api_name": "QuantumCircuit.num_ancillas",
        "api_description": "Return the number of ancilla qubits.",
        "api_signature": "num_ancillas(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "num_clbits",
        "full_api_name": "QuantumCircuit.num_clbits",
        "api_description": "Return number of classical bits.",
        "api_signature": "num_clbits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "count_ops",
        "full_api_name": "QuantumCircuit.count_ops",
        "api_description": "Count each operation kind in the circuit.\n\nReturns:\n    OrderedDict: a breakdown of how many operations of each kind, sorted by amount.",
        "api_signature": "count_ops(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "num_nonlocal_gates",
        "full_api_name": "QuantumCircuit.num_nonlocal_gates",
        "api_description": "Return number of non-local gates (i.e. involving 2+ qubits).\n\nConditional nonlocal gates are also included.",
        "api_signature": "num_nonlocal_gates(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "get_instructions",
        "full_api_name": "QuantumCircuit.get_instructions",
        "api_description": "Get instructions matching name.\n\nArgs:\n    name (str): The name of instruction to.\n\nReturns:\n    list(tuple): list of (instruction, qargs, cargs).",
        "api_signature": "get_instructions(self, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "num_connected_components",
        "full_api_name": "QuantumCircuit.num_connected_components",
        "api_description": "How many non-entangled subcircuits can the circuit be factored to.\n\nArgs:\n    unitary_only (bool): Compute only unitary part of graph.\n\nReturns:\n    int: Number of connected components in circuit.",
        "api_signature": "num_connected_components(self, unitary_only)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "num_unitary_factors",
        "full_api_name": "QuantumCircuit.num_unitary_factors",
        "api_description": "Computes the number of tensor factors in the unitary\n(quantum) part of the circuit only.",
        "api_signature": "num_unitary_factors(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "num_tensor_factors",
        "full_api_name": "QuantumCircuit.num_tensor_factors",
        "api_description": "Computes the number of tensor factors in the unitary\n(quantum) part of the circuit only.\n\nNotes:\n    This is here for backwards compatibility, and will be\n    removed in a future release of Qiskit. You should call\n    `num_unitary_factors` instead.",
        "api_signature": "num_tensor_factors(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "copy",
        "full_api_name": "QuantumCircuit.copy",
        "api_description": "Copy the circuit.\n\nArgs:\n  name (str): name to be given to the copied circuit. If None, then the name stays the same.\n\nReturns:\n  QuantumCircuit: a deepcopy of the current circuit, with the specified name",
        "api_signature": "copy(self, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "copy_empty_like",
        "full_api_name": "QuantumCircuit.copy_empty_like",
        "api_description": "Return a copy of self with the same structure but empty.\n\nThat structure includes:\n\n* name, calibrations and other metadata\n* global phase\n* all the qubits and clbits, including the registers\n* the realtime variables defined in the circuit, handled according to the ``vars`` keyword\n  argument.\n\n.. warning::\n\n    If the circuit contains any local variable declarations (those added by the\n    ``declarations`` argument to the circuit constructor, or using :meth:`add_var`), they\n    may be **uninitialized** in the output circuit.  You will need to manually add store\n    instructions for them (see :class:`.Store` and :meth:`.QuantumCircuit.store`) to\n    initialize them.\n\nArgs:\n    name: Name for the copied circuit. If None, then the name stays the same.\n    vars_mode: The mode to handle realtime variables in.\n\n        alike\n            The variables in the output circuit will have the same declaration semantics as\n            in the original circuit.  For example, ``input`` variables in the source will be\n            ``input`` variables in the output circuit.\n\n        captures\n            All variables will be converted to captured variables.  This is useful when you\n            are building a new layer for an existing circuit that you will want to\n            :meth:`compose` onto the base, since :meth:`compose` can inline captures onto\n            the base circuit (but not other variables).\n\n        drop\n            The output circuit will have no variables defined.\n\nReturns:\n    QuantumCircuit: An empty copy of self.",
        "api_signature": "copy_empty_like(self, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "clear",
        "full_api_name": "QuantumCircuit.clear",
        "api_description": "Clear all instructions in self.\n\nClearing the circuits will keep the metadata and calibrations.\n\n.. seealso::\n    :meth:`copy_empty_like`\n        A method to produce a new circuit with no instructions and all the same tracking of\n        quantum and classical typed data, but without mutating the original circuit.",
        "api_signature": "clear(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "_create_creg",
        "full_api_name": "QuantumCircuit._create_creg",
        "api_description": "Creates a creg, checking if ClassicalRegister with same name exists",
        "api_signature": "_create_creg(self, length, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "_create_qreg",
        "full_api_name": "QuantumCircuit._create_qreg",
        "api_description": "Creates a qreg, checking if QuantumRegister with same name exists",
        "api_signature": "_create_qreg(self, length, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "reset",
        "full_api_name": "QuantumCircuit.reset",
        "api_description": "Reset the quantum bit(s) to their default state.\n\nArgs:\n    qubit: qubit(s) to reset.\n\nReturns:\n    qiskit.circuit.InstructionSet: handle to the added instruction.",
        "api_signature": "reset(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "store",
        "full_api_name": "QuantumCircuit.store",
        "api_description": "Store the result of the given real-time classical expression ``rvalue`` in the memory\nlocation defined by ``lvalue``.\n\nTypically ``lvalue`` will be a :class:`~.expr.Var` node and ``rvalue`` will be some\n:class:`~.expr.Expr` to write into it, but anything that :func:`.expr.lift` can raise to an\n:class:`~.expr.Expr` is permissible in both places, and it will be called on them.\n\nArgs:\n    lvalue: a valid specifier for a memory location in the circuit.  This will typically be\n        a :class:`~.expr.Var` node, but you can also write to :class:`.Clbit` or\n        :class:`.ClassicalRegister` memory locations if your hardware supports it.  The\n        memory location must already be present in the circuit.\n    rvalue: a real-time classical expression whose result should be written into the given\n        memory location.\n\n.. seealso::\n    :class:`~.circuit.Store`\n        The backing :class:`~.circuit.Instruction` class that represents this operation.\n\n    :meth:`add_var`\n        Create a new variable in the circuit that can be written to with this method.",
        "api_signature": "store()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "measure",
        "full_api_name": "QuantumCircuit.measure",
        "api_description": "Measure a quantum bit (``qubit``) in the Z basis into a classical bit (``cbit``).\n\nWhen a quantum state is measured, a qubit is projected in the computational (Pauli Z) basis\nto either :math:`\\lvert 0 \\rangle` or :math:`\\lvert 1 \\rangle`. The classical bit ``cbit``\nindicates the result\nof that projection as a ``0`` or a ``1`` respectively. This operation is non-reversible.\n\nArgs:\n    qubit: qubit(s) to measure.\n    cbit: classical bit(s) to place the measurement result(s) in.\n\nReturns:\n    qiskit.circuit.InstructionSet: handle to the added instructions.\n\nRaises:\n    CircuitError: if arguments have bad format.\n\nExamples:\n    In this example, a qubit is measured and the result of that measurement is stored in the\n    classical bit (usually expressed in diagrams as a double line):\n\n    .. code-block::\n\n       from qiskit import QuantumCircuit\n       circuit = QuantumCircuit(1, 1)\n       circuit.h(0)\n       circuit.measure(0, 0)\n       circuit.draw()\n\n\n    .. parsed-literal::\n\n              \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2510\n           q: \u2524 H \u251c\u2524M\u251c\n              \u2514\u2500\u2500\u2500\u2518\u2514\u2565\u2518\n         c: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\n                    0\n\n    It is possible to call ``measure`` with lists of ``qubits`` and ``cbits`` as a shortcut\n    for one-to-one measurement. These two forms produce identical results:\n\n    .. code-block::\n\n       circuit = QuantumCircuit(2, 2)\n       circuit.measure([0,1], [0,1])\n\n    .. code-block::\n\n       circuit = QuantumCircuit(2, 2)\n       circuit.measure(0, 0)\n       circuit.measure(1, 1)\n\n    Instead of lists, you can use :class:`~qiskit.circuit.QuantumRegister` and\n    :class:`~qiskit.circuit.ClassicalRegister` under the same logic.\n\n    .. code-block::\n\n        from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister\n        qreg = QuantumRegister(2, \"qreg\")\n        creg = ClassicalRegister(2, \"creg\")\n        circuit = QuantumCircuit(qreg, creg)\n        circuit.measure(qreg, creg)\n\n    This is equivalent to:\n\n    .. code-block::\n\n        circuit = QuantumCircuit(qreg, creg)\n        circuit.measure(qreg[0], creg[0])\n        circuit.measure(qreg[1], creg[1])",
        "api_signature": "measure(self, qubit, cbit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "measure_active",
        "full_api_name": "QuantumCircuit.measure_active",
        "api_description": "Adds measurement to all non-idle qubits. Creates a new ClassicalRegister with\na size equal to the number of non-idle qubits being measured.\n\nReturns a new circuit with measurements if `inplace=False`.\n\nArgs:\n    inplace (bool): All measurements inplace or return new circuit.\n\nReturns:\n    QuantumCircuit: Returns circuit with measurements when ``inplace = False``.",
        "api_signature": "measure_active(self, inplace)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "measure_all",
        "full_api_name": "QuantumCircuit.measure_all",
        "api_description": "Adds measurement to all qubits.\n\nBy default, adds new classical bits in a :obj:`.ClassicalRegister` to store these\nmeasurements.  If ``add_bits=False``, the results of the measurements will instead be stored\nin the already existing classical bits, with qubit ``n`` being measured into classical bit\n``n``.\n\nReturns a new circuit with measurements if ``inplace=False``.\n\nArgs:\n    inplace (bool): All measurements inplace or return new circuit.\n    add_bits (bool): Whether to add new bits to store the results.\n\nReturns:\n    QuantumCircuit: Returns circuit with measurements when ``inplace=False``.\n\nRaises:\n    CircuitError: if ``add_bits=False`` but there are not enough classical bits.",
        "api_signature": "measure_all(self, inplace, add_bits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "remove_final_measurements",
        "full_api_name": "QuantumCircuit.remove_final_measurements",
        "api_description": "Removes final measurements and barriers on all qubits if they are present.\nDeletes the classical registers that were used to store the values from these measurements\nthat become idle as a result of this operation, and deletes classical bits that are\nreferenced only by removed registers, or that aren't referenced at all but have\nbecome idle as a result of this operation.\n\nMeasurements and barriers are considered final if they are\nfollowed by no other operations (aside from other measurements or barriers.)\n\n.. note::\n    This method has rather complex behavior, particularly around the removal of newly idle\n    classical bits and registers.  It is much more efficient to avoid adding unnecessary\n    classical data in the first place, rather than trying to remove it later.\n\n.. seealso::\n    :class:`.RemoveFinalMeasurements`\n        A transpiler pass that removes final measurements and barriers.  This does not\n        remove the classical data.  If this is your goal, you can call that with::\n\n            from qiskit.circuit import QuantumCircuit\n            from qiskit.transpiler.passes import RemoveFinalMeasurements\n\n            qc = QuantumCircuit(2, 2)\n            qc.h(0)\n            qc.cx(0, 1)\n            qc.barrier()\n            qc.measure([0, 1], [0, 1])\n\n            pass_ = RemoveFinalMeasurements()\n            just_bell = pass_(qc)\n\nArgs:\n    inplace (bool): All measurements removed inplace or return new circuit.\n\nReturns:\n    QuantumCircuit: Returns the resulting circuit when ``inplace=False``, else None.",
        "api_signature": "remove_final_measurements(self, inplace)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "from_qasm_file",
        "full_api_name": "QuantumCircuit.from_qasm_file",
        "api_description": "Read an OpenQASM 2.0 program from a file and convert to an instance of\n:class:`.QuantumCircuit`.\n\nArgs:\n  path (str): Path to the file for an OpenQASM 2 program\n\nReturn:\n  QuantumCircuit: The QuantumCircuit object for the input OpenQASM 2.\n\nSee also:\n    :func:`.qasm2.load`: the complete interface to the OpenQASM 2 importer.",
        "api_signature": "from_qasm_file(path)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "from_qasm_str",
        "full_api_name": "QuantumCircuit.from_qasm_str",
        "api_description": "Convert a string containing an OpenQASM 2.0 program to a :class:`.QuantumCircuit`.\n\nArgs:\n  qasm_str (str): A string containing an OpenQASM 2.0 program.\nReturn:\n  QuantumCircuit: The QuantumCircuit object for the input OpenQASM 2\n\nSee also:\n    :func:`.qasm2.loads`: the complete interface to the OpenQASM 2 importer.",
        "api_signature": "from_qasm_str(qasm_str)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "global_phase",
        "full_api_name": "QuantumCircuit.global_phase",
        "api_description": "The global phase of the current circuit scope in radians.",
        "api_signature": "global_phase(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "global_phase",
        "full_api_name": "QuantumCircuit.global_phase",
        "api_description": "Set the phase of the current circuit scope.\n\nArgs:\n    angle (float, ParameterExpression): radians",
        "api_signature": "global_phase(self, angle)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "parameters",
        "full_api_name": "QuantumCircuit.parameters",
        "api_description": "The parameters defined in the circuit.\n\nThis attribute returns the :class:`.Parameter` objects in the circuit sorted\nalphabetically. Note that parameters instantiated with a :class:`.ParameterVector`\nare still sorted numerically.\n\nExamples:\n\n    The snippet below shows that insertion order of parameters does not matter.\n\n    .. code-block:: python\n\n        >>> from qiskit.circuit import QuantumCircuit, Parameter\n        >>> a, b, elephant = Parameter(\"a\"), Parameter(\"b\"), Parameter(\"elephant\")\n        >>> circuit = QuantumCircuit(1)\n        >>> circuit.rx(b, 0)\n        >>> circuit.rz(elephant, 0)\n        >>> circuit.ry(a, 0)\n        >>> circuit.parameters  # sorted alphabetically!\n        ParameterView([Parameter(a), Parameter(b), Parameter(elephant)])\n\n    Bear in mind that alphabetical sorting might be unintuitive when it comes to numbers.\n    The literal \"10\" comes before \"2\" in strict alphabetical sorting.\n\n    .. code-block:: python\n\n        >>> from qiskit.circuit import QuantumCircuit, Parameter\n        >>> angles = [Parameter(\"angle_1\"), Parameter(\"angle_2\"), Parameter(\"angle_10\")]\n        >>> circuit = QuantumCircuit(1)\n        >>> circuit.u(*angles, 0)\n        >>> circuit.draw()\n           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q: \u2524 U(angle_1,angle_2,angle_10) \u251c\n           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        >>> circuit.parameters\n        ParameterView([Parameter(angle_1), Parameter(angle_10), Parameter(angle_2)])\n\n    To respect numerical sorting, a :class:`.ParameterVector` can be used.\n\n    .. code-block:: python\n\n        >>> from qiskit.circuit import QuantumCircuit, Parameter, ParameterVector\n        >>> x = ParameterVector(\"x\", 12)\n        >>> circuit = QuantumCircuit(1)\n        >>> for x_i in x:\n        ...     circuit.rx(x_i, 0)\n        >>> circuit.parameters\n        ParameterView([\n            ParameterVectorElement(x[0]), ParameterVectorElement(x[1]),\n            ParameterVectorElement(x[2]), ParameterVectorElement(x[3]),\n            ..., ParameterVectorElement(x[11])\n        ])\n\n\nReturns:\n    The sorted :class:`.Parameter` objects in the circuit.",
        "api_signature": "parameters(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "num_parameters",
        "full_api_name": "QuantumCircuit.num_parameters",
        "api_description": "The number of parameter objects in the circuit.",
        "api_signature": "num_parameters(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "_unsorted_parameters",
        "full_api_name": "QuantumCircuit._unsorted_parameters",
        "api_description": "Efficiently get all parameters in the circuit, without any sorting overhead.\n\n.. warning::\n\n    The returned object may directly view onto the ``ParameterTable`` internals, and so\n    should not be mutated.  This is an internal performance detail.  Code outside of this\n    package should not use this method.",
        "api_signature": "_unsorted_parameters(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "assign_parameters",
        "full_api_name": "QuantumCircuit.assign_parameters",
        "api_description": "",
        "api_signature": "assign_parameters(self, parameters, inplace)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "assign_parameters",
        "full_api_name": "QuantumCircuit.assign_parameters",
        "api_description": "",
        "api_signature": "assign_parameters(self, parameters, inplace)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "assign_parameters",
        "full_api_name": "QuantumCircuit.assign_parameters",
        "api_description": "Assign parameters to new parameters or values.\n\nIf ``parameters`` is passed as a dictionary, the keys should be :class:`.Parameter`\ninstances in the current circuit. The values of the dictionary can either be numeric values\nor new parameter objects.\n\nIf ``parameters`` is passed as a list or array, the elements are assigned to the\ncurrent parameters in the order of :attr:`parameters` which is sorted\nalphabetically (while respecting the ordering in :class:`.ParameterVector` objects).\n\nThe values can be assigned to the current circuit object or to a copy of it.\n\n.. note::\n    When ``parameters`` is given as a mapping, it is permissible to have keys that are\n    strings of the parameter names; these will be looked up using :meth:`get_parameter`.\n    You can also have keys that are :class:`.ParameterVector` instances, and in this case,\n    the dictionary value should be a sequence of values of the same length as the vector.\n\n    If you use either of these cases, you must leave the setting ``flat_input=False``;\n    changing this to ``True`` enables the fast path, where all keys must be\n    :class:`.Parameter` instances.\n\nArgs:\n    parameters: Either a dictionary or iterable specifying the new parameter values.\n    inplace: If False, a copy of the circuit with the bound parameters is returned.\n        If True the circuit instance itself is modified.\n    flat_input: If ``True`` and ``parameters`` is a mapping type, it is assumed to be\n        exactly a mapping of ``{parameter: value}``.  By default (``False``), the mapping\n        may also contain :class:`.ParameterVector` keys that point to a corresponding\n        sequence of values, and these will be unrolled during the mapping, or string keys,\n        which will be converted to :class:`.Parameter` instances using\n        :meth:`get_parameter`.\n    strict: If ``False``, any parameters given in the mapping that are not used in the\n        circuit will be ignored.  If ``True`` (the default), an error will be raised\n        indicating a logic error.\n\nRaises:\n    CircuitError: If parameters is a dict and contains parameters not present in the\n        circuit.\n    ValueError: If parameters is a list/array and the length mismatches the number of free\n        parameters in the circuit.\n\nReturns:\n    A copy of the circuit with bound parameters if ``inplace`` is False, otherwise None.\n\nExamples:\n\n    Create a parameterized circuit and assign the parameters in-place.\n\n    .. plot::\n       :include-source:\n\n       from qiskit.circuit import QuantumCircuit, Parameter\n\n       circuit = QuantumCircuit(2)\n       params = [Parameter('A'), Parameter('B'), Parameter('C')]\n       circuit.ry(params[0], 0)\n       circuit.crx(params[1], 0, 1)\n       circuit.draw('mpl')\n       circuit.assign_parameters({params[0]: params[2]}, inplace=True)\n       circuit.draw('mpl')\n\n    Bind the values out-of-place by list and get a copy of the original circuit.\n\n    .. plot::\n       :include-source:\n\n       from qiskit.circuit import QuantumCircuit, ParameterVector\n\n       circuit = QuantumCircuit(2)\n       params = ParameterVector('P', 2)\n       circuit.ry(params[0], 0)\n       circuit.crx(params[1], 0, 1)\n\n       bound_circuit = circuit.assign_parameters([1, 2])\n       bound_circuit.draw('mpl')\n\n       circuit.draw('mpl')",
        "api_signature": "assign_parameters(self, parameters, inplace)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "map_calibration",
        "full_api_name": "QuantumCircuit.map_calibration",
        "api_description": "",
        "api_signature": "map_calibration(qubits, parameters, schedule)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "_unroll_param_dict",
        "full_api_name": "QuantumCircuit._unroll_param_dict",
        "api_description": "",
        "api_signature": "_unroll_param_dict(self, parameter_binds)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "barrier",
        "full_api_name": "QuantumCircuit.barrier",
        "api_description": "Apply :class:`~.library.Barrier`. If ``qargs`` is empty, applies to all qubits\nin the circuit.\n\nArgs:\n    qargs (QubitSpecifier): Specification for one or more qubit arguments.\n    label (str): The string label of the barrier.\n\nReturns:\n    qiskit.circuit.InstructionSet: handle to the added instructions.",
        "api_signature": "barrier(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "delay",
        "full_api_name": "QuantumCircuit.delay",
        "api_description": "Apply :class:`~.circuit.Delay`. If qarg is ``None``, applies to all qubits.\nWhen applying to multiple qubits, delays with the same duration will be created.\n\nArgs:\n    duration (int or float or ParameterExpression): duration of the delay.\n    qarg (Object): qubit argument to apply this delay.\n    unit (str): unit of the duration. Supported units: ``'s'``, ``'ms'``, ``'us'``,\n        ``'ns'``, ``'ps'``, and ``'dt'``. Default is ``'dt'``, i.e. integer time unit\n        depending on the target backend.\n\nReturns:\n    qiskit.circuit.InstructionSet: handle to the added instructions.\n\nRaises:\n    CircuitError: if arguments have bad format.",
        "api_signature": "delay(self, duration, qarg, unit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "h",
        "full_api_name": "QuantumCircuit.h",
        "api_description": "Apply :class:`~qiskit.circuit.library.HGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    qubit: The qubit(s) to apply the gate to.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "h(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "ch",
        "full_api_name": "QuantumCircuit.ch",
        "api_description": "Apply :class:`~qiskit.circuit.library.CHGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    control_qubit: The qubit(s) used as the control.\n    target_qubit: The qubit(s) targeted by the gate.\n    label: The string label of the gate in the circuit.\n    ctrl_state:\n        The control state in decimal, or as a bitstring (e.g. '1').  Defaults to controlling\n        on the '1' state.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "ch(self, control_qubit, target_qubit, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "id",
        "full_api_name": "QuantumCircuit.id",
        "api_description": "Apply :class:`~qiskit.circuit.library.IGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    qubit: The qubit(s) to apply the gate to.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "id(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "ms",
        "full_api_name": "QuantumCircuit.ms",
        "api_description": "Apply :class:`~qiskit.circuit.library.MSGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    theta: The angle of the rotation.\n    qubits: The qubits to apply the gate to.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "ms(self, theta, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "p",
        "full_api_name": "QuantumCircuit.p",
        "api_description": "Apply :class:`~qiskit.circuit.library.PhaseGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    theta: THe angle of the rotation.\n    qubit: The qubit(s) to apply the gate to.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "p(self, theta, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "cp",
        "full_api_name": "QuantumCircuit.cp",
        "api_description": "Apply :class:`~qiskit.circuit.library.CPhaseGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    theta: The angle of the rotation.\n    control_qubit: The qubit(s) used as the control.\n    target_qubit: The qubit(s) targeted by the gate.\n    label: The string label of the gate in the circuit.\n    ctrl_state:\n        The control state in decimal, or as a bitstring (e.g. '1').  Defaults to controlling\n        on the '1' state.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "cp(self, theta, control_qubit, target_qubit, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "mcp",
        "full_api_name": "QuantumCircuit.mcp",
        "api_description": "Apply :class:`~qiskit.circuit.library.MCPhaseGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    lam: The angle of the rotation.\n    control_qubits: The qubits used as the controls.\n    target_qubit: The qubit(s) targeted by the gate.\n    ctrl_state:\n        The control state in decimal, or as a bitstring (e.g. '1').  Defaults to controlling\n        on the '1' state.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "mcp(self, lam, control_qubits, target_qubit, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "r",
        "full_api_name": "QuantumCircuit.r",
        "api_description": "Apply :class:`~qiskit.circuit.library.RGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    theta: The angle of the rotation.\n    phi: The angle of the axis of rotation in the x-y plane.\n    qubit: The qubit(s) to apply the gate to.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "r(self, theta, phi, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "rv",
        "full_api_name": "QuantumCircuit.rv",
        "api_description": "Apply :class:`~qiskit.circuit.library.RVGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nRotation around an arbitrary rotation axis :math:`v`, where :math:`|v|` is the angle of\nrotation in radians.\n\nArgs:\n    vx: x-component of the rotation axis.\n    vy: y-component of the rotation axis.\n    vz: z-component of the rotation axis.\n    qubit: The qubit(s) to apply the gate to.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "rv(self, vx, vy, vz, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "rccx",
        "full_api_name": "QuantumCircuit.rccx",
        "api_description": "Apply :class:`~qiskit.circuit.library.RCCXGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    control_qubit1: The qubit(s) used as the first control.\n    control_qubit2: The qubit(s) used as the second control.\n    target_qubit: The qubit(s) targeted by the gate.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "rccx(self, control_qubit1, control_qubit2, target_qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "rcccx",
        "full_api_name": "QuantumCircuit.rcccx",
        "api_description": "Apply :class:`~qiskit.circuit.library.RC3XGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    control_qubit1: The qubit(s) used as the first control.\n    control_qubit2: The qubit(s) used as the second control.\n    control_qubit3: The qubit(s) used as the third control.\n    target_qubit: The qubit(s) targeted by the gate.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "rcccx(self, control_qubit1, control_qubit2, control_qubit3, target_qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "rx",
        "full_api_name": "QuantumCircuit.rx",
        "api_description": "Apply :class:`~qiskit.circuit.library.RXGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    theta: The rotation angle of the gate.\n    qubit: The qubit(s) to apply the gate to.\n    label: The string label of the gate in the circuit.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "rx(self, theta, qubit, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "crx",
        "full_api_name": "QuantumCircuit.crx",
        "api_description": "Apply :class:`~qiskit.circuit.library.CRXGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    theta: The angle of the rotation.\n    control_qubit: The qubit(s) used as the control.\n    target_qubit: The qubit(s) targeted by the gate.\n    label: The string label of the gate in the circuit.\n    ctrl_state:\n        The control state in decimal, or as a bitstring (e.g. '1').  Defaults to controlling\n        on the '1' state.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "crx(self, theta, control_qubit, target_qubit, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "rxx",
        "full_api_name": "QuantumCircuit.rxx",
        "api_description": "Apply :class:`~qiskit.circuit.library.RXXGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    theta: The angle of the rotation.\n    qubit1: The qubit(s) to apply the gate to.\n    qubit2: The qubit(s) to apply the gate to.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "rxx(self, theta, qubit1, qubit2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "ry",
        "full_api_name": "QuantumCircuit.ry",
        "api_description": "Apply :class:`~qiskit.circuit.library.RYGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    theta: The rotation angle of the gate.\n    qubit: The qubit(s) to apply the gate to.\n    label: The string label of the gate in the circuit.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "ry(self, theta, qubit, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "cry",
        "full_api_name": "QuantumCircuit.cry",
        "api_description": "Apply :class:`~qiskit.circuit.library.CRYGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    theta: The angle of the rotation.\n    control_qubit: The qubit(s) used as the control.\n    target_qubit: The qubit(s) targeted by the gate.\n    label: The string label of the gate in the circuit.\n    ctrl_state:\n        The control state in decimal, or as a bitstring (e.g. '1').  Defaults to controlling\n        on the '1' state.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "cry(self, theta, control_qubit, target_qubit, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "ryy",
        "full_api_name": "QuantumCircuit.ryy",
        "api_description": "Apply :class:`~qiskit.circuit.library.RYYGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    theta: The rotation angle of the gate.\n    qubit1: The qubit(s) to apply the gate to.\n    qubit2: The qubit(s) to apply the gate to.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "ryy(self, theta, qubit1, qubit2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "rz",
        "full_api_name": "QuantumCircuit.rz",
        "api_description": "Apply :class:`~qiskit.circuit.library.RZGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    phi: The rotation angle of the gate.\n    qubit: The qubit(s) to apply the gate to.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "rz(self, phi, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "crz",
        "full_api_name": "QuantumCircuit.crz",
        "api_description": "Apply :class:`~qiskit.circuit.library.CRZGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    theta: The angle of the rotation.\n    control_qubit: The qubit(s) used as the control.\n    target_qubit: The qubit(s) targeted by the gate.\n    label: The string label of the gate in the circuit.\n    ctrl_state:\n        The control state in decimal, or as a bitstring (e.g. '1').  Defaults to controlling\n        on the '1' state.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "crz(self, theta, control_qubit, target_qubit, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "rzx",
        "full_api_name": "QuantumCircuit.rzx",
        "api_description": "Apply :class:`~qiskit.circuit.library.RZXGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    theta: The rotation angle of the gate.\n    qubit1: The qubit(s) to apply the gate to.\n    qubit2: The qubit(s) to apply the gate to.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "rzx(self, theta, qubit1, qubit2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "rzz",
        "full_api_name": "QuantumCircuit.rzz",
        "api_description": "Apply :class:`~qiskit.circuit.library.RZZGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    theta: The rotation angle of the gate.\n    qubit1: The qubit(s) to apply the gate to.\n    qubit2: The qubit(s) to apply the gate to.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "rzz(self, theta, qubit1, qubit2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "ecr",
        "full_api_name": "QuantumCircuit.ecr",
        "api_description": "Apply :class:`~qiskit.circuit.library.ECRGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    qubit1, qubit2: The qubits to apply the gate to.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "ecr(self, qubit1, qubit2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "s",
        "full_api_name": "QuantumCircuit.s",
        "api_description": "Apply :class:`~qiskit.circuit.library.SGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    qubit: The qubit(s) to apply the gate to.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "s(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "sdg",
        "full_api_name": "QuantumCircuit.sdg",
        "api_description": "Apply :class:`~qiskit.circuit.library.SdgGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    qubit: The qubit(s) to apply the gate to.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "sdg(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "cs",
        "full_api_name": "QuantumCircuit.cs",
        "api_description": "Apply :class:`~qiskit.circuit.library.CSGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    control_qubit: The qubit(s) used as the control.\n    target_qubit: The qubit(s) targeted by the gate.\n    label: The string label of the gate in the circuit.\n    ctrl_state:\n        The control state in decimal, or as a bitstring (e.g. '1').  Defaults to controlling\n        on the '1' state.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "cs(self, control_qubit, target_qubit, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "csdg",
        "full_api_name": "QuantumCircuit.csdg",
        "api_description": "Apply :class:`~qiskit.circuit.library.CSdgGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    control_qubit: The qubit(s) used as the control.\n    target_qubit: The qubit(s) targeted by the gate.\n    label: The string label of the gate in the circuit.\n    ctrl_state:\n        The control state in decimal, or as a bitstring (e.g. '1').  Defaults to controlling\n        on the '1' state.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "csdg(self, control_qubit, target_qubit, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "swap",
        "full_api_name": "QuantumCircuit.swap",
        "api_description": "Apply :class:`~qiskit.circuit.library.SwapGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    qubit1, qubit2: The qubits to apply the gate to.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "swap(self, qubit1, qubit2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "iswap",
        "full_api_name": "QuantumCircuit.iswap",
        "api_description": "Apply :class:`~qiskit.circuit.library.iSwapGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    qubit1, qubit2: The qubits to apply the gate to.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "iswap(self, qubit1, qubit2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "cswap",
        "full_api_name": "QuantumCircuit.cswap",
        "api_description": "Apply :class:`~qiskit.circuit.library.CSwapGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    control_qubit: The qubit(s) used as the control.\n    target_qubit1: The qubit(s) targeted by the gate.\n    target_qubit2: The qubit(s) targeted by the gate.\n    label: The string label of the gate in the circuit.\n    ctrl_state:\n        The control state in decimal, or as a bitstring (e.g. ``'1'``).  Defaults to controlling\n        on the ``'1'`` state.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "cswap(self, control_qubit, target_qubit1, target_qubit2, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "sx",
        "full_api_name": "QuantumCircuit.sx",
        "api_description": "Apply :class:`~qiskit.circuit.library.SXGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    qubit: The qubit(s) to apply the gate to.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "sx(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "sxdg",
        "full_api_name": "QuantumCircuit.sxdg",
        "api_description": "Apply :class:`~qiskit.circuit.library.SXdgGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    qubit: The qubit(s) to apply the gate to.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "sxdg(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "csx",
        "full_api_name": "QuantumCircuit.csx",
        "api_description": "Apply :class:`~qiskit.circuit.library.CSXGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    control_qubit: The qubit(s) used as the control.\n    target_qubit: The qubit(s) targeted by the gate.\n    label: The string label of the gate in the circuit.\n    ctrl_state:\n        The control state in decimal, or as a bitstring (e.g. '1').  Defaults to controlling\n        on the '1' state.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "csx(self, control_qubit, target_qubit, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "t",
        "full_api_name": "QuantumCircuit.t",
        "api_description": "Apply :class:`~qiskit.circuit.library.TGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    qubit: The qubit(s) to apply the gate to.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "t(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "tdg",
        "full_api_name": "QuantumCircuit.tdg",
        "api_description": "Apply :class:`~qiskit.circuit.library.TdgGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    qubit: The qubit(s) to apply the gate to.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "tdg(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "u",
        "full_api_name": "QuantumCircuit.u",
        "api_description": "Apply :class:`~qiskit.circuit.library.UGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    theta: The :math:`\\theta` rotation angle of the gate.\n    phi: The :math:`\\phi` rotation angle of the gate.\n    lam: The :math:`\\lambda` rotation angle of the gate.\n    qubit: The qubit(s) to apply the gate to.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "u(self, theta, phi, lam, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "cu",
        "full_api_name": "QuantumCircuit.cu",
        "api_description": "Apply :class:`~qiskit.circuit.library.CUGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    theta: The :math:`\\theta` rotation angle of the gate.\n    phi: The :math:`\\phi` rotation angle of the gate.\n    lam: The :math:`\\lambda` rotation angle of the gate.\n    gamma: The global phase applied of the U gate, if applied.\n    control_qubit: The qubit(s) used as the control.\n    target_qubit: The qubit(s) targeted by the gate.\n    label: The string label of the gate in the circuit.\n    ctrl_state:\n        The control state in decimal, or as a bitstring (e.g. '1').  Defaults to controlling\n        on the '1' state.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "cu(self, theta, phi, lam, gamma, control_qubit, target_qubit, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "x",
        "full_api_name": "QuantumCircuit.x",
        "api_description": "Apply :class:`~qiskit.circuit.library.XGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    qubit: The qubit(s) to apply the gate to.\n    label: The string label of the gate in the circuit.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "x(self, qubit, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "cx",
        "full_api_name": "QuantumCircuit.cx",
        "api_description": "Apply :class:`~qiskit.circuit.library.CXGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    control_qubit: The qubit(s) used as the control.\n    target_qubit: The qubit(s) targeted by the gate.\n    label: The string label of the gate in the circuit.\n    ctrl_state:\n        The control state in decimal, or as a bitstring (e.g. '1').  Defaults to controlling\n        on the '1' state.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "cx(self, control_qubit, target_qubit, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "dcx",
        "full_api_name": "QuantumCircuit.dcx",
        "api_description": "Apply :class:`~qiskit.circuit.library.DCXGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    qubit1: The qubit(s) to apply the gate to.\n    qubit2: The qubit(s) to apply the gate to.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "dcx(self, qubit1, qubit2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "ccx",
        "full_api_name": "QuantumCircuit.ccx",
        "api_description": "Apply :class:`~qiskit.circuit.library.CCXGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    control_qubit1: The qubit(s) used as the first control.\n    control_qubit2: The qubit(s) used as the second control.\n    target_qubit: The qubit(s) targeted by the gate.\n    ctrl_state:\n        The control state in decimal, or as a bitstring (e.g. '1').  Defaults to controlling\n        on the '1' state.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "ccx(self, control_qubit1, control_qubit2, target_qubit, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "mcx",
        "full_api_name": "QuantumCircuit.mcx",
        "api_description": "Apply :class:`~qiskit.circuit.library.MCXGate`.\n\nThe multi-cX gate can be implemented using different techniques, which use different numbers\nof ancilla qubits and have varying circuit depth. These modes are:\n\n- ``'noancilla'``: Requires 0 ancilla qubits.\n- ``'recursion'``: Requires 1 ancilla qubit if more than 4 controls are used, otherwise 0.\n- ``'v-chain'``: Requires 2 less ancillas than the number of control qubits.\n- ``'v-chain-dirty'``: Same as for the clean ancillas (but the circuit will be longer).\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    control_qubits: The qubits used as the controls.\n    target_qubit: The qubit(s) targeted by the gate.\n    ancilla_qubits: The qubits used as the ancillae, if the mode requires them.\n    mode: The choice of mode, explained further above.\n    ctrl_state:\n        The control state in decimal, or as a bitstring (e.g. '1').  Defaults to controlling\n        on the '1' state.\n\nReturns:\n    A handle to the instructions created.\n\nRaises:\n    ValueError: if the given mode is not known, or if too few ancilla qubits are passed.\n    AttributeError: if no ancilla qubits are passed, but some are needed.",
        "api_signature": "mcx(self, control_qubits, target_qubit, ancilla_qubits, mode, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "y",
        "full_api_name": "QuantumCircuit.y",
        "api_description": "Apply :class:`~qiskit.circuit.library.YGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    qubit: The qubit(s) to apply the gate to.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "y(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "cy",
        "full_api_name": "QuantumCircuit.cy",
        "api_description": "Apply :class:`~qiskit.circuit.library.CYGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    control_qubit: The qubit(s) used as the controls.\n    target_qubit: The qubit(s) targeted by the gate.\n    label: The string label of the gate in the circuit.\n    ctrl_state:\n        The control state in decimal, or as a bitstring (e.g. '1').  Defaults to controlling\n        on the '1' state.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "cy(self, control_qubit, target_qubit, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "z",
        "full_api_name": "QuantumCircuit.z",
        "api_description": "Apply :class:`~qiskit.circuit.library.ZGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    qubit: The qubit(s) to apply the gate to.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "z(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "cz",
        "full_api_name": "QuantumCircuit.cz",
        "api_description": "Apply :class:`~qiskit.circuit.library.CZGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    control_qubit: The qubit(s) used as the controls.\n    target_qubit: The qubit(s) targeted by the gate.\n    label: The string label of the gate in the circuit.\n    ctrl_state:\n        The control state in decimal, or as a bitstring (e.g. '1').  Defaults to controlling\n        on the '1' state.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "cz(self, control_qubit, target_qubit, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "ccz",
        "full_api_name": "QuantumCircuit.ccz",
        "api_description": "Apply :class:`~qiskit.circuit.library.CCZGate`.\n\nFor the full matrix form of this gate, see the underlying gate documentation.\n\nArgs:\n    control_qubit1: The qubit(s) used as the first control.\n    control_qubit2: The qubit(s) used as the second control.\n    target_qubit: The qubit(s) targeted by the gate.\n    label: The string label of the gate in the circuit.\n    ctrl_state:\n        The control state in decimal, or as a bitstring (e.g. '10').  Defaults to controlling\n        on the '11' state.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "ccz(self, control_qubit1, control_qubit2, target_qubit, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "pauli",
        "full_api_name": "QuantumCircuit.pauli",
        "api_description": "Apply :class:`~qiskit.circuit.library.PauliGate`.\n\nArgs:\n    pauli_string: A string representing the Pauli operator to apply, e.g. 'XX'.\n    qubits: The qubits to apply this gate to.\n\nReturns:\n    A handle to the instructions created.",
        "api_signature": "pauli(self, pauli_string, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "prepare_state",
        "full_api_name": "QuantumCircuit.prepare_state",
        "api_description": "Prepare qubits in a specific state.\n\nThis class implements a state preparing unitary. Unlike\n:meth:`.initialize` it does not reset the qubits first.\n\nArgs:\n    state: The state to initialize to, can be either of the following.\n\n        * Statevector or vector of complex amplitudes to initialize to.\n        * Labels of basis states of the Pauli eigenstates Z, X, Y. See\n          :meth:`.Statevector.from_label`. Notice the order of the labels is reversed with\n          respect to the qubit index to be applied to. Example label '01' initializes the\n          qubit zero to :math:`|1\\rangle` and the qubit one to :math:`|0\\rangle`.\n        * An integer that is used as a bitmap indicating which qubits to initialize to\n          :math:`|1\\rangle`. Example: setting params to 5 would initialize qubit 0 and qubit\n          2 to :math:`|1\\rangle` and qubit 1 to :math:`|0\\rangle`.\n\n    qubits: Qubits to initialize. If ``None`` the initialization is applied to all qubits in\n        the circuit.\n    label: An optional label for the gate\n    normalize: Whether to normalize an input array to a unit vector.\n\nReturns:\n    A handle to the instruction that was just initialized\n\nExamples:\n    Prepare a qubit in the state :math:`(|0\\rangle - |1\\rangle) / \\sqrt{2}`.\n\n    .. code-block::\n\n        import numpy as np\n        from qiskit import QuantumCircuit\n\n        circuit = QuantumCircuit(1)\n        circuit.prepare_state([1/np.sqrt(2), -1/np.sqrt(2)], 0)\n        circuit.draw()\n\n    output:\n\n    .. parsed-literal::\n\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_0: \u2524 State Preparation(0.70711,-0.70711) \u251c\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n\n    Prepare from a string two qubits in the state :math:`|10\\rangle`.\n    The order of the labels is reversed with respect to qubit index.\n    More information about labels for basis states are in\n    :meth:`.Statevector.from_label`.\n\n    .. code-block::\n\n        import numpy as np\n        from qiskit import QuantumCircuit\n\n        circuit = QuantumCircuit(2)\n        circuit.prepare_state('01', circuit.qubits)\n        circuit.draw()\n\n    output:\n\n    .. parsed-literal::\n\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_0: \u25240                        \u251c\n             \u2502  State Preparation(0,1) \u2502\n        q_1: \u25241                        \u251c\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n\n    Initialize two qubits from an array of complex amplitudes\n    .. code-block::\n\n        import numpy as np\n        from qiskit import QuantumCircuit\n\n        circuit = QuantumCircuit(2)\n        circuit.prepare_state([0, 1/np.sqrt(2), -1.j/np.sqrt(2), 0], circuit.qubits)\n        circuit.draw()\n\n    output:\n\n    .. parsed-literal::\n\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_0: \u25240                                          \u251c\n             \u2502  State Preparation(0,0.70711,-0.70711j,0) \u2502\n        q_1: \u25241                                          \u251c\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
        "api_signature": "prepare_state(self, state, qubits, label, normalize)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "initialize",
        "full_api_name": "QuantumCircuit.initialize",
        "api_description": "Initialize qubits in a specific state.\n\nQubit initialization is done by first resetting the qubits to :math:`|0\\rangle`\nfollowed by calling :class:`~qiskit.circuit.library.StatePreparation`\nclass to prepare the qubits in a specified state.\nBoth these steps are included in the\n:class:`~qiskit.circuit.library.Initialize` instruction.\n\nArgs:\n    params: The state to initialize to, can be either of the following.\n\n        * Statevector or vector of complex amplitudes to initialize to.\n        * Labels of basis states of the Pauli eigenstates Z, X, Y. See\n          :meth:`.Statevector.from_label`. Notice the order of the labels is reversed with\n          respect to the qubit index to be applied to. Example label ``'01'`` initializes the\n          qubit zero to :math:`|1\\rangle` and the qubit one to :math:`|0\\rangle`.\n        * An integer that is used as a bitmap indicating which qubits to initialize to\n          :math:`|1\\rangle`. Example: setting params to 5 would initialize qubit 0 and qubit\n          2 to :math:`|1\\rangle` and qubit 1 to :math:`|0\\rangle`.\n\n    qubits: Qubits to initialize. If ``None`` the initialization is applied to all qubits in\n        the circuit.\n    normalize: Whether to normalize an input array to a unit vector.\n\nReturns:\n    A handle to the instructions created.\n\nExamples:\n    Prepare a qubit in the state :math:`(|0\\rangle - |1\\rangle) / \\sqrt{2}`.\n\n    .. code-block::\n\n        import numpy as np\n        from qiskit import QuantumCircuit\n\n        circuit = QuantumCircuit(1)\n        circuit.initialize([1/np.sqrt(2), -1/np.sqrt(2)], 0)\n        circuit.draw()\n\n    output:\n\n    .. parsed-literal::\n\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_0: \u2524 Initialize(0.70711,-0.70711) \u251c\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n\n    Initialize from a string two qubits in the state :math:`|10\\rangle`.\n    The order of the labels is reversed with respect to qubit index.\n    More information about labels for basis states are in\n    :meth:`.Statevector.from_label`.\n\n    .. code-block::\n\n        import numpy as np\n        from qiskit import QuantumCircuit\n\n        circuit = QuantumCircuit(2)\n        circuit.initialize('01', circuit.qubits)\n        circuit.draw()\n\n    output:\n\n    .. parsed-literal::\n\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_0: \u25240                 \u251c\n             \u2502  Initialize(0,1) \u2502\n        q_1: \u25241                 \u251c\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    Initialize two qubits from an array of complex amplitudes.\n\n    .. code-block::\n\n        import numpy as np\n        from qiskit import QuantumCircuit\n\n        circuit = QuantumCircuit(2)\n        circuit.initialize([0, 1/np.sqrt(2), -1.j/np.sqrt(2), 0], circuit.qubits)\n        circuit.draw()\n\n    output:\n\n    .. parsed-literal::\n\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_0: \u25240                                   \u251c\n             \u2502  Initialize(0,0.70711,-0.70711j,0) \u2502\n        q_1: \u25241                                   \u251c\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
        "api_signature": "initialize(self, params, qubits, normalize)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "unitary",
        "full_api_name": "QuantumCircuit.unitary",
        "api_description": "Apply unitary gate specified by ``obj`` to ``qubits``.\n\nArgs:\n    obj: Unitary operator.\n    qubits: The circuit qubits to apply the transformation to.\n    label: Unitary name for backend [Default: None].\n\nReturns:\n    QuantumCircuit: The quantum circuit.\n\nExample:\n\n    Apply a gate specified by a unitary matrix to a quantum circuit\n\n    .. code-block:: python\n\n        from qiskit import QuantumCircuit\n        matrix = [[0, 0, 0, 1],\n                [0, 0, 1, 0],\n                [1, 0, 0, 0],\n                [0, 1, 0, 0]]\n        circuit = QuantumCircuit(2)\n        circuit.unitary(matrix, [0, 1])",
        "api_signature": "unitary(self, obj, qubits, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "_current_scope",
        "full_api_name": "QuantumCircuit._current_scope",
        "api_description": "",
        "api_signature": "_current_scope(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "_push_scope",
        "full_api_name": "QuantumCircuit._push_scope",
        "api_description": "Add a scope for collecting instructions into this circuit.\n\nThis should only be done by the control-flow context managers, which will handle cleaning up\nafter themselves at the end as well.\n\nArgs:\n    qubits: Any qubits that this scope should automatically use.\n    clbits: Any clbits that this scope should automatically use.\n    allow_jumps: Whether this scope allows jumps to be used within it.\n    forbidden_message: If given, all attempts to add instructions to this scope will raise a\n        :exc:`.CircuitError` with this message.",
        "api_signature": "_push_scope(self, qubits, clbits, registers, allow_jumps, forbidden_message)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "_pop_scope",
        "full_api_name": "QuantumCircuit._pop_scope",
        "api_description": "Finish a scope used in the control-flow builder interface, and return it to the caller.\n\nThis should only be done by the control-flow context managers, since they naturally\nsynchronize the creation and deletion of stack elements.",
        "api_signature": "_pop_scope(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "_peek_previous_instruction_in_scope",
        "full_api_name": "QuantumCircuit._peek_previous_instruction_in_scope",
        "api_description": "Return the instruction 3-tuple of the most recent instruction in the current scope, even\nif that scope is currently under construction.\n\nThis function is only intended for use by the control-flow ``if``-statement builders, which\nmay need to modify a previous instruction.",
        "api_signature": "_peek_previous_instruction_in_scope(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "_pop_previous_instruction_in_scope",
        "full_api_name": "QuantumCircuit._pop_previous_instruction_in_scope",
        "api_description": "Return the instruction 3-tuple of the most recent instruction in the current scope, even\nif that scope is currently under construction, and remove it from that scope.\n\nThis function is only intended for use by the control-flow ``if``-statement builders, which\nmay need to replace a previous instruction with another.",
        "api_signature": "_pop_previous_instruction_in_scope(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "while_loop",
        "full_api_name": "QuantumCircuit.while_loop",
        "api_description": "",
        "api_signature": "while_loop(self, condition, body, qubits, clbits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "while_loop",
        "full_api_name": "QuantumCircuit.while_loop",
        "api_description": "",
        "api_signature": "while_loop(self, condition, body, qubits, clbits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "while_loop",
        "full_api_name": "QuantumCircuit.while_loop",
        "api_description": "Create a ``while`` loop on this circuit.\n\nThere are two forms for calling this function.  If called with all its arguments (with the\npossible exception of ``label``), it will create a\n:obj:`~qiskit.circuit.controlflow.WhileLoopOp` with the given ``body``.  If ``body`` (and\n``qubits`` and ``clbits``) are *not* passed, then this acts as a context manager, which\nwill automatically build a :obj:`~qiskit.circuit.controlflow.WhileLoopOp` when the scope\nfinishes.  In this form, you do not need to keep track of the qubits or clbits you are\nusing, because the scope will handle it for you.\n\nExample usage::\n\n    from qiskit.circuit import QuantumCircuit, Clbit, Qubit\n    bits = [Qubit(), Qubit(), Clbit()]\n    qc = QuantumCircuit(bits)\n\n    with qc.while_loop((bits[2], 0)):\n        qc.h(0)\n        qc.cx(0, 1)\n        qc.measure(0, 0)\n\nArgs:\n    condition (Tuple[Union[ClassicalRegister, Clbit], int]): An equality condition to be\n        checked prior to executing ``body``. The left-hand side of the condition must be a\n        :obj:`~ClassicalRegister` or a :obj:`~Clbit`, and the right-hand side must be an\n        integer or boolean.\n    body (Optional[QuantumCircuit]): The loop body to be repeatedly executed.  Omit this to\n        use the context-manager mode.\n    qubits (Optional[Sequence[Qubit]]): The circuit qubits over which the loop body should\n        be run.  Omit this to use the context-manager mode.\n    clbits (Optional[Sequence[Clbit]]): The circuit clbits over which the loop body should\n        be run.  Omit this to use the context-manager mode.\n    label (Optional[str]): The string label of the instruction in the circuit.\n\nReturns:\n    InstructionSet or WhileLoopContext: If used in context-manager mode, then this should be\n    used as a ``with`` resource, which will infer the block content and operands on exit.\n    If the full form is used, then this returns a handle to the instructions created.\n\nRaises:\n    CircuitError: if an incorrect calling convention is used.",
        "api_signature": "while_loop(self, condition, body, qubits, clbits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "for_loop",
        "full_api_name": "QuantumCircuit.for_loop",
        "api_description": "",
        "api_signature": "for_loop(self, indexset, loop_parameter, body, qubits, clbits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "for_loop",
        "full_api_name": "QuantumCircuit.for_loop",
        "api_description": "",
        "api_signature": "for_loop(self, indexset, loop_parameter, body, qubits, clbits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "for_loop",
        "full_api_name": "QuantumCircuit.for_loop",
        "api_description": "Create a ``for`` loop on this circuit.\n\nThere are two forms for calling this function.  If called with all its arguments (with the\npossible exception of ``label``), it will create a\n:class:`~qiskit.circuit.ForLoopOp` with the given ``body``.  If ``body`` (and\n``qubits`` and ``clbits``) are *not* passed, then this acts as a context manager, which,\nwhen entered, provides a loop variable (unless one is given, in which case it will be\nreused) and will automatically build a :class:`~qiskit.circuit.ForLoopOp` when the\nscope finishes.  In this form, you do not need to keep track of the qubits or clbits you are\nusing, because the scope will handle it for you.\n\nFor example::\n\n    from qiskit import QuantumCircuit\n    qc = QuantumCircuit(2, 1)\n\n    with qc.for_loop(range(5)) as i:\n        qc.h(0)\n        qc.cx(0, 1)\n        qc.measure(0, 0)\n        qc.break_loop().c_if(0, True)\n\nArgs:\n    indexset (Iterable[int]): A collection of integers to loop over.  Always necessary.\n    loop_parameter (Optional[Parameter]): The parameter used within ``body`` to which\n        the values from ``indexset`` will be assigned.  In the context-manager form, if this\n        argument is not supplied, then a loop parameter will be allocated for you and\n        returned as the value of the ``with`` statement.  This will only be bound into the\n        circuit if it is used within the body.\n\n        If this argument is ``None`` in the manual form of this method, ``body`` will be\n        repeated once for each of the items in ``indexset`` but their values will be\n        ignored.\n    body (Optional[QuantumCircuit]): The loop body to be repeatedly executed.  Omit this to\n        use the context-manager mode.\n    qubits (Optional[Sequence[QubitSpecifier]]): The circuit qubits over which the loop body\n        should be run.  Omit this to use the context-manager mode.\n    clbits (Optional[Sequence[ClbitSpecifier]]): The circuit clbits over which the loop body\n        should be run.  Omit this to use the context-manager mode.\n    label (Optional[str]): The string label of the instruction in the circuit.\n\nReturns:\n    InstructionSet or ForLoopContext: depending on the call signature, either a context\n    manager for creating the for loop (it will automatically be added to the circuit at the\n    end of the block), or an :obj:`~InstructionSet` handle to the appended loop operation.\n\nRaises:\n    CircuitError: if an incorrect calling convention is used.",
        "api_signature": "for_loop(self, indexset, loop_parameter, body, qubits, clbits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "if_test",
        "full_api_name": "QuantumCircuit.if_test",
        "api_description": "",
        "api_signature": "if_test(self, condition)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "if_test",
        "full_api_name": "QuantumCircuit.if_test",
        "api_description": "",
        "api_signature": "if_test(self, condition, true_body, qubits, clbits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "if_test",
        "full_api_name": "QuantumCircuit.if_test",
        "api_description": "Create an ``if`` statement on this circuit.\n\nThere are two forms for calling this function.  If called with all its arguments (with the\npossible exception of ``label``), it will create a\n:obj:`~qiskit.circuit.IfElseOp` with the given ``true_body``, and there will be\nno branch for the ``false`` condition (see also the :meth:`.if_else` method).  However, if\n``true_body`` (and ``qubits`` and ``clbits``) are *not* passed, then this acts as a context\nmanager, which can be used to build ``if`` statements.  The return value of the ``with``\nstatement is a chainable context manager, which can be used to create subsequent ``else``\nblocks.  In this form, you do not need to keep track of the qubits or clbits you are using,\nbecause the scope will handle it for you.\n\nFor example::\n\n    from qiskit.circuit import QuantumCircuit, Qubit, Clbit\n    bits = [Qubit(), Qubit(), Qubit(), Clbit(), Clbit()]\n    qc = QuantumCircuit(bits)\n\n    qc.h(0)\n    qc.cx(0, 1)\n    qc.measure(0, 0)\n    qc.h(0)\n    qc.cx(0, 1)\n    qc.measure(0, 1)\n\n    with qc.if_test((bits[3], 0)) as else_:\n        qc.x(2)\n    with else_:\n        qc.h(2)\n        qc.z(2)\n\nArgs:\n    condition (Tuple[Union[ClassicalRegister, Clbit], int]): A condition to be evaluated in\n        real time during circuit execution, which, if true, will trigger the evaluation of\n        ``true_body``. Can be specified as either a tuple of a ``ClassicalRegister`` to be\n        tested for equality with a given ``int``, or as a tuple of a ``Clbit`` to be\n        compared to either a ``bool`` or an ``int``.\n    true_body (Optional[QuantumCircuit]): The circuit body to be run if ``condition`` is\n        true.\n    qubits (Optional[Sequence[QubitSpecifier]]): The circuit qubits over which the if/else\n        should be run.\n    clbits (Optional[Sequence[ClbitSpecifier]]): The circuit clbits over which the if/else\n        should be run.\n    label (Optional[str]): The string label of the instruction in the circuit.\n\nReturns:\n    InstructionSet or IfContext: depending on the call signature, either a context\n    manager for creating the ``if`` block (it will automatically be added to the circuit at\n    the end of the block), or an :obj:`~InstructionSet` handle to the appended conditional\n    operation.\n\nRaises:\n    CircuitError: If the provided condition references Clbits outside the\n        enclosing circuit.\n    CircuitError: if an incorrect calling convention is used.\n\nReturns:\n    A handle to the instruction created.",
        "api_signature": "if_test(self, condition, true_body, qubits, clbits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "if_else",
        "full_api_name": "QuantumCircuit.if_else",
        "api_description": "Apply :class:`~qiskit.circuit.IfElseOp`.\n\n.. note::\n\n    This method does not have an associated context-manager form, because it is already\n    handled by the :meth:`.if_test` method.  You can use the ``else`` part of that with\n    something such as::\n\n        from qiskit.circuit import QuantumCircuit, Qubit, Clbit\n        bits = [Qubit(), Qubit(), Clbit()]\n        qc = QuantumCircuit(bits)\n        qc.h(0)\n        qc.cx(0, 1)\n        qc.measure(0, 0)\n        with qc.if_test((bits[2], 0)) as else_:\n            qc.h(0)\n        with else_:\n            qc.x(0)\n\nArgs:\n    condition: A condition to be evaluated in real time at circuit execution, which,\n        if true, will trigger the evaluation of ``true_body``. Can be\n        specified as either a tuple of a ``ClassicalRegister`` to be\n        tested for equality with a given ``int``, or as a tuple of a\n        ``Clbit`` to be compared to either a ``bool`` or an ``int``.\n    true_body: The circuit body to be run if ``condition`` is true.\n    false_body: The circuit to be run if ``condition`` is false.\n    qubits: The circuit qubits over which the if/else should be run.\n    clbits: The circuit clbits over which the if/else should be run.\n    label: The string label of the instruction in the circuit.\n\nRaises:\n    CircuitError: If the provided condition references Clbits outside the\n        enclosing circuit.\n\nReturns:\n    A handle to the instruction created.",
        "api_signature": "if_else(self, condition, true_body, false_body, qubits, clbits, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "switch",
        "full_api_name": "QuantumCircuit.switch",
        "api_description": "",
        "api_signature": "switch(self, target, cases, qubits, clbits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "switch",
        "full_api_name": "QuantumCircuit.switch",
        "api_description": "",
        "api_signature": "switch(self, target, cases, qubits, clbits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "switch",
        "full_api_name": "QuantumCircuit.switch",
        "api_description": "Create a ``switch``/``case`` structure on this circuit.\n\nThere are two forms for calling this function.  If called with all its arguments (with the\npossible exception of ``label``), it will create a :class:`.SwitchCaseOp` with the given\ncase structure.  If ``cases`` (and ``qubits`` and ``clbits``) are *not* passed, then this\nacts as a context manager, which will automatically build a :class:`.SwitchCaseOp` when the\nscope finishes.  In this form, you do not need to keep track of the qubits or clbits you are\nusing, because the scope will handle it for you.\n\nExample usage::\n\n    from qiskit.circuit import QuantumCircuit, ClassicalRegister, QuantumRegister\n    qreg = QuantumRegister(3)\n    creg = ClassicalRegister(3)\n    qc = QuantumCircuit(qreg, creg)\n    qc.h([0, 1, 2])\n    qc.measure([0, 1, 2], [0, 1, 2])\n\n    with qc.switch(creg) as case:\n        with case(0):\n            qc.x(0)\n        with case(1, 2):\n            qc.z(1)\n        with case(case.DEFAULT):\n            qc.cx(0, 1)\n\nArgs:\n    target (Union[ClassicalRegister, Clbit]): The classical value to switch one.  This must\n        be integer-like.\n    cases (Iterable[Tuple[typing.Any, QuantumCircuit]]): A sequence of case specifiers.\n        Each tuple defines one case body (the second item).  The first item of the tuple can\n        be either a single integer value, the special value :data:`.CASE_DEFAULT`, or a\n        tuple of several integer values.  Each of the integer values will be tried in turn;\n        control will then pass to the body corresponding to the first match.\n        :data:`.CASE_DEFAULT` matches all possible values.  Omit in context-manager form.\n    qubits (Sequence[Qubit]): The circuit qubits over which all case bodies execute. Omit in\n        context-manager form.\n    clbits (Sequence[Clbit]): The circuit clbits over which all case bodies execute. Omit in\n        context-manager form.\n    label (Optional[str]): The string label of the instruction in the circuit.\n\nReturns:\n    InstructionSet or SwitchCaseContext: If used in context-manager mode, then this should\n    be used as a ``with`` resource, which will return an object that can be repeatedly\n    entered to produce cases for the switch statement.  If the full form is used, then this\n    returns a handle to the instructions created.\n\nRaises:\n    CircuitError: if an incorrect calling convention is used.",
        "api_signature": "switch(self, target, cases, qubits, clbits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "break_loop",
        "full_api_name": "QuantumCircuit.break_loop",
        "api_description": "Apply :class:`~qiskit.circuit.BreakLoopOp`.\n\n.. warning::\n\n    If you are using the context-manager \"builder\" forms of :meth:`.if_test`,\n    :meth:`.for_loop` or :meth:`.while_loop`, you can only call this method if you are\n    within a loop context, because otherwise the \"resource width\" of the operation cannot be\n    determined.  This would quickly lead to invalid circuits, and so if you are trying to\n    construct a reusable loop body (without the context managers), you must also use the\n    non-context-manager form of :meth:`.if_test` and :meth:`.if_else`.  Take care that the\n    :obj:`.BreakLoopOp` instruction must span all the resources of its containing loop, not\n    just the immediate scope.\n\nReturns:\n    A handle to the instruction created.\n\nRaises:\n    CircuitError: if this method was called within a builder context, but not contained\n        within a loop.",
        "api_signature": "break_loop(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "continue_loop",
        "full_api_name": "QuantumCircuit.continue_loop",
        "api_description": "Apply :class:`~qiskit.circuit.ContinueLoopOp`.\n\n.. warning::\n\n    If you are using the context-manager \"builder\" forms of :meth:`.if_test`,\n    :meth:`.for_loop` or :meth:`.while_loop`, you can only call this method if you are\n    within a loop context, because otherwise the \"resource width\" of the operation cannot be\n    determined.  This would quickly lead to invalid circuits, and so if you are trying to\n    construct a reusable loop body (without the context managers), you must also use the\n    non-context-manager form of :meth:`.if_test` and :meth:`.if_else`.  Take care that the\n    :class:`~qiskit.circuit.ContinueLoopOp` instruction must span all the resources of its\n    containing loop, not just the immediate scope.\n\nReturns:\n    A handle to the instruction created.\n\nRaises:\n    CircuitError: if this method was called within a builder context, but not contained\n        within a loop.",
        "api_signature": "continue_loop(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "add_calibration",
        "full_api_name": "QuantumCircuit.add_calibration",
        "api_description": "Register a low-level, custom pulse definition for the given gate.\n\nArgs:\n    gate (Union[Gate, str]): Gate information.\n    qubits (Union[int, Tuple[int]]): List of qubits to be measured.\n    schedule (Schedule): Schedule information.\n    params (Optional[List[Union[float, Parameter]]]): A list of parameters.\n\nRaises:\n    Exception: if the gate is of type string and params is None.",
        "api_signature": "add_calibration(self, gate, qubits, schedule, params)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "_format",
        "full_api_name": "QuantumCircuit._format",
        "api_description": "",
        "api_signature": "_format(operand)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "qubit_duration",
        "full_api_name": "QuantumCircuit.qubit_duration",
        "api_description": "Return the duration between the start and stop time of the first and last instructions,\nexcluding delays, over the supplied qubits. Its time unit is ``self.unit``.\n\nArgs:\n    *qubits: Qubits within ``self`` to include.\n\nReturns:\n    Return the duration between the first start and last stop time of non-delay instructions",
        "api_signature": "qubit_duration(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "qubit_start_time",
        "full_api_name": "QuantumCircuit.qubit_start_time",
        "api_description": "Return the start time of the first instruction, excluding delays,\nover the supplied qubits. Its time unit is ``self.unit``.\n\nReturn 0 if there are no instructions over qubits\n\nArgs:\n    *qubits: Qubits within ``self`` to include. Integers are allowed for qubits, indicating\n    indices of ``self.qubits``.\n\nReturns:\n    Return the start time of the first instruction, excluding delays, over the qubits\n\nRaises:\n    CircuitError: if ``self`` is a not-yet scheduled circuit.",
        "api_signature": "qubit_start_time(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "qubit_stop_time",
        "full_api_name": "QuantumCircuit.qubit_stop_time",
        "api_description": "Return the stop time of the last instruction, excluding delays, over the supplied qubits.\nIts time unit is ``self.unit``.\n\nReturn 0 if there are no instructions over qubits\n\nArgs:\n    *qubits: Qubits within ``self`` to include. Integers are allowed for qubits, indicating\n    indices of ``self.qubits``.\n\nReturns:\n    Return the stop time of the last instruction, excluding delays, over the qubits\n\nRaises:\n    CircuitError: if ``self`` is a not-yet scheduled circuit.",
        "api_signature": "qubit_stop_time(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "_OuterCircuitScopeInterface.__init__",
        "api_description": "",
        "api_signature": "__init__(self, circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "instructions",
        "full_api_name": "_OuterCircuitScopeInterface.instructions",
        "api_description": "",
        "api_signature": "instructions(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "append",
        "full_api_name": "_OuterCircuitScopeInterface.append",
        "api_description": "",
        "api_signature": "append(self, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "extend",
        "full_api_name": "_OuterCircuitScopeInterface.extend",
        "api_description": "",
        "api_signature": "extend(self, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "resolve_classical_resource",
        "full_api_name": "_OuterCircuitScopeInterface.resolve_classical_resource",
        "api_description": "",
        "api_signature": "resolve_classical_resource(self, specifier)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "add_uninitialized_var",
        "full_api_name": "_OuterCircuitScopeInterface.add_uninitialized_var",
        "api_description": "",
        "api_signature": "add_uninitialized_var(self, var)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "remove_var",
        "full_api_name": "_OuterCircuitScopeInterface.remove_var",
        "api_description": "",
        "api_signature": "remove_var(self, var)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "get_var",
        "full_api_name": "_OuterCircuitScopeInterface.get_var",
        "api_description": "",
        "api_signature": "get_var(self, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "use_var",
        "full_api_name": "_OuterCircuitScopeInterface.use_var",
        "api_description": "",
        "api_signature": "use_var(self, var)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "_validate_expr",
        "full_api_name": "_validate_expr",
        "api_description": "",
        "api_signature": "_validate_expr(circuit_scope, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "_ParameterBindsDict.__init__",
        "api_description": "",
        "api_signature": "__init__(self, mapping, allowed_keys)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "items",
        "full_api_name": "_ParameterBindsDict.items",
        "api_description": "Iterator through all the keys in the mapping that we care about.  Wrapping the main\nmapping allows us to avoid reconstructing a new 'dict', but just use the given 'mapping'\nwithout any copy / reconstruction.",
        "api_signature": "items(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "_ParameterBindsSequence.__init__",
        "api_description": "",
        "api_signature": "__init__(self, parameters, values)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "items",
        "full_api_name": "_ParameterBindsSequence.items",
        "api_description": "Iterator through all the keys in the mapping that we care about.",
        "api_signature": "items(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "mapping",
        "full_api_name": "_ParameterBindsSequence.mapping",
        "api_description": "Cached version of a mapping.  This is only generated on demand.",
        "api_signature": "mapping(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "_bit_argument_conversion",
        "full_api_name": "_bit_argument_conversion",
        "api_description": "Get the list of bits referred to by the specifier ``specifier``.\n\nValid types for ``specifier`` are integers, bits of the correct type (as given in ``type_``), or\niterables of one of those two scalar types.  Integers are interpreted as indices into the\nsequence ``bit_sequence``.  All allowed bits must be in ``bit_set`` (which should implement\nfast lookup), which is assumed to contain the same bits as ``bit_sequence``.\n\nReturns:\n    List[Bit]: a list of the specified bits from ``bits``.\n\nRaises:\n    CircuitError: if an incorrect type or index is encountered, if the same bit is specified\n        more than once, or if the specifier is to a bit not in the ``bit_set``.",
        "api_signature": "_bit_argument_conversion(specifier, bit_sequence, bit_set, type_)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "_bit_argument_conversion_scalar",
        "full_api_name": "_bit_argument_conversion_scalar",
        "api_description": "",
        "api_signature": "_bit_argument_conversion_scalar(specifier, bit_sequence, bit_set, type_)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/quantumcircuit.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ControlModifier.__init__",
        "api_description": "",
        "api_signature": "__init__(self, num_ctrl_qubits, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/annotated_operation.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "AnnotatedOperation.__init__",
        "api_description": "Create a new AnnotatedOperation.\n\nAn \"annotated operation\" allows to add a list of modifiers to the\n\"base\" operation. For now, the only supported modifiers are of\ntypes :class:`~.InverseModifier`, :class:`~.ControlModifier` and\n:class:`~.PowerModifier`.\n\nAn annotated operation can be viewed as an extension of\n:class:`~.ControlledGate` (which also allows adding control to the\nbase operation). However, an important difference is that the\ncircuit definition of an annotated operation is not constructed when\nthe operation is declared, and instead happens during transpilation,\nspecifically during the :class:`~.HighLevelSynthesis` transpiler pass.\n\nAn annotated operation can be also viewed as a \"higher-level\"\nor \"more abstract\" object that can be added to a quantum circuit.\nThis enables writing transpiler optimization passes that make use of\nthis higher-level representation, for instance removing a gate\nthat is immediately followed by its inverse.\n\nArgs:\n    base_op: base operation being modified\n    modifiers: ordered list of modifiers. Supported modifiers include\n        ``InverseModifier``, ``ControlModifier`` and ``PowerModifier``.\n\nExamples::\n\n    op1 = AnnotatedOperation(SGate(), [InverseModifier(), ControlModifier(2)])\n\n    op2_inner = AnnotatedGate(SGate(), InverseModifier())\n    op2 = AnnotatedGate(op2_inner, ControlModifier(2))\n\nBoth op1 and op2 are semantically equivalent to an ``SGate()`` which is first\ninverted and then controlled by 2 qubits.",
        "api_signature": "__init__(self, base_op, modifiers)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/annotated_operation.py"
    },
    {
        "api_name": "name",
        "full_api_name": "AnnotatedOperation.name",
        "api_description": "Unique string identifier for operation type.",
        "api_signature": "name(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/annotated_operation.py"
    },
    {
        "api_name": "num_qubits",
        "full_api_name": "AnnotatedOperation.num_qubits",
        "api_description": "Number of qubits.",
        "api_signature": "num_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/annotated_operation.py"
    },
    {
        "api_name": "num_clbits",
        "full_api_name": "AnnotatedOperation.num_clbits",
        "api_description": "Number of classical bits.",
        "api_signature": "num_clbits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/annotated_operation.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "AnnotatedOperation.__eq__",
        "api_description": "Checks if two AnnotatedOperations are equal.",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/annotated_operation.py"
    },
    {
        "api_name": "copy",
        "full_api_name": "AnnotatedOperation.copy",
        "api_description": "Return a copy of the :class:`~.AnnotatedOperation`.",
        "api_signature": "copy(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/annotated_operation.py"
    },
    {
        "api_name": "to_matrix",
        "full_api_name": "AnnotatedOperation.to_matrix",
        "api_description": "Return a matrix representation (allowing to construct Operator).",
        "api_signature": "to_matrix(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/annotated_operation.py"
    },
    {
        "api_name": "control",
        "full_api_name": "AnnotatedOperation.control",
        "api_description": "Return the controlled version of itself.\n\nImplemented as an annotated operation, see  :class:`.AnnotatedOperation`.\n\nArgs:\n    num_ctrl_qubits: number of controls to add to gate (default: ``1``)\n    label: ignored (used for consistency with other control methods)\n    ctrl_state: The control state in decimal or as a bitstring\n        (e.g. ``'111'``). If ``None``, use ``2**num_ctrl_qubits-1``.\n    annotated: ignored (used for consistency with other control methods)\n\nReturns:\n    Controlled version of the given operation.",
        "api_signature": "control(self, num_ctrl_qubits, label, ctrl_state, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/annotated_operation.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "AnnotatedOperation.inverse",
        "api_description": "Return the inverse version of itself.\n\nImplemented as an annotated operation, see  :class:`.AnnotatedOperation`.\n\nArgs:\n    annotated: ignored (used for consistency with other inverse methods)\n\nReturns:\n    Inverse version of the given operation.",
        "api_signature": "inverse(self, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/annotated_operation.py"
    },
    {
        "api_name": "power",
        "full_api_name": "AnnotatedOperation.power",
        "api_description": "Raise this gate to the power of ``exponent``.\n\nImplemented as an annotated operation, see  :class:`.AnnotatedOperation`.\n\nArgs:\n    exponent: the power to raise the gate to\n    annotated: ignored (used for consistency with other power methods)\n\nReturns:\n    An operation implementing ``gate^exponent``",
        "api_signature": "power(self, exponent, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/annotated_operation.py"
    },
    {
        "api_name": "params",
        "full_api_name": "AnnotatedOperation.params",
        "api_description": "The params of the underlying base operation.",
        "api_signature": "params(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/annotated_operation.py"
    },
    {
        "api_name": "params",
        "full_api_name": "AnnotatedOperation.params",
        "api_description": "",
        "api_signature": "params(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/annotated_operation.py"
    },
    {
        "api_name": "validate_parameter",
        "full_api_name": "AnnotatedOperation.validate_parameter",
        "api_description": "Validate a parameter for the underlying base operation.",
        "api_signature": "validate_parameter(self, parameter)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/annotated_operation.py"
    },
    {
        "api_name": "_canonicalize_modifiers",
        "full_api_name": "_canonicalize_modifiers",
        "api_description": "Returns the canonical representative of the modifier list. This is possible\nsince all the modifiers commute; also note that InverseModifier is a special\ncase of PowerModifier. The current solution is to compute the total number\nof control qubits / control state and the total power. The InverseModifier\nwill be present if total power is negative, whereas the power modifier will\nbe present only with positive powers different from 1.",
        "api_signature": "_canonicalize_modifiers(modifiers)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/annotated_operation.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Parameter.__init__",
        "api_description": "Args:\n    name: name of the ``Parameter``, used for visual representation. This can\n        be any Unicode string, e.g. \"\u03d5\".\n    uuid: For advanced usage only.  Override the UUID of this parameter, in order to make it\n        compare equal to some other parameter object.  By default, two parameters with the\n        same name do not compare equal to help catch shadowing bugs when two circuits\n        containing the same named parameters are spurious combined.  Setting the ``uuid``\n        field when creating two parameters to the same thing (along with the same name)\n        allows them to be equal.  This is useful during serialization and deserialization.",
        "api_signature": "__init__(self, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameter.py"
    },
    {
        "api_name": "assign",
        "full_api_name": "Parameter.assign",
        "api_description": "",
        "api_signature": "assign(self, parameter, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameter.py"
    },
    {
        "api_name": "subs",
        "full_api_name": "Parameter.subs",
        "api_description": "Substitute self with the corresponding parameter in ``parameter_map``.",
        "api_signature": "subs(self, parameter_map, allow_unknown_parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameter.py"
    },
    {
        "api_name": "name",
        "full_api_name": "Parameter.name",
        "api_description": "Returns the name of the :class:`Parameter`.",
        "api_signature": "name(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameter.py"
    },
    {
        "api_name": "uuid",
        "full_api_name": "Parameter.uuid",
        "api_description": "Returns the :class:`~uuid.UUID` of the :class:`Parameter`.\n\nIn advanced use cases, this property can be passed to the\n:class:`Parameter` constructor to produce an instance that compares\nequal to another instance.",
        "api_signature": "uuid(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameter.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "Parameter.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameter.py"
    },
    {
        "api_name": "__copy__",
        "full_api_name": "Parameter.__copy__",
        "api_description": "",
        "api_signature": "__copy__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameter.py"
    },
    {
        "api_name": "__deepcopy__",
        "full_api_name": "Parameter.__deepcopy__",
        "api_description": "",
        "api_signature": "__deepcopy__(self, memo)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameter.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "Parameter.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameter.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "Parameter.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameter.py"
    },
    {
        "api_name": "_hash_key",
        "full_api_name": "Parameter._hash_key",
        "api_description": "",
        "api_signature": "_hash_key(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameter.py"
    },
    {
        "api_name": "__hash__",
        "full_api_name": "Parameter.__hash__",
        "api_description": "",
        "api_signature": "__hash__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameter.py"
    },
    {
        "api_name": "__getstate__",
        "full_api_name": "Parameter.__getstate__",
        "api_description": "",
        "api_signature": "__getstate__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameter.py"
    },
    {
        "api_name": "__setstate__",
        "full_api_name": "Parameter.__setstate__",
        "api_description": "",
        "api_signature": "__setstate__(self, state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/parameter.py"
    },
    {
        "api_name": "_identity_op",
        "full_api_name": "_identity_op",
        "api_description": "Cached identity matrix",
        "api_signature": "_identity_op(num_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/commutation_checker.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CommutationChecker.__init__",
        "api_description": "",
        "api_signature": "__init__(self, standard_gate_commutations, cache_max_entries)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/commutation_checker.py"
    },
    {
        "api_name": "commute_nodes",
        "full_api_name": "CommutationChecker.commute_nodes",
        "api_description": "Checks if two DAGOpNodes commute.",
        "api_signature": "commute_nodes(self, op1, op2, max_num_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/commutation_checker.py"
    },
    {
        "api_name": "commute",
        "full_api_name": "CommutationChecker.commute",
        "api_description": "Checks if two Operations commute. The return value of `True` means that the operations\ntruly commute, and the return value of `False` means that either the operations do not\ncommute or that the commutation check was skipped (for example, when the operations\nhave conditions or have too many qubits).\n\nArgs:\n    op1: first operation.\n    qargs1: first operation's qubits.\n    cargs1: first operation's clbits.\n    op2: second operation.\n    qargs2: second operation's qubits.\n    cargs2: second operation's clbits.\n    max_num_qubits: the maximum number of qubits to consider, the check may be skipped if\n        the number of qubits for either operation exceeds this amount.\n\nReturns:\n    bool: whether two operations commute.",
        "api_signature": "commute(self, op1, qargs1, cargs1, op2, qargs2, cargs2, max_num_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/commutation_checker.py"
    },
    {
        "api_name": "num_cached_entries",
        "full_api_name": "CommutationChecker.num_cached_entries",
        "api_description": "Returns number of cached entries",
        "api_signature": "num_cached_entries(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/commutation_checker.py"
    },
    {
        "api_name": "clear_cached_commutations",
        "full_api_name": "CommutationChecker.clear_cached_commutations",
        "api_description": "Clears the dictionary holding cached commutations",
        "api_signature": "clear_cached_commutations(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/commutation_checker.py"
    },
    {
        "api_name": "check_commutation_entries",
        "full_api_name": "CommutationChecker.check_commutation_entries",
        "api_description": "Returns stored commutation relation if any\n\nArgs:\n    first_op: first operation.\n    first_qargs: first operation's qubits.\n    second_op: second operation.\n    second_qargs: second operation's qubits.\n\nReturn:\n    bool: True if the gates commute and false if it is not the case.",
        "api_signature": "check_commutation_entries(self, first_op, first_qargs, second_op, second_qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/commutation_checker.py"
    },
    {
        "api_name": "_hashable_parameters",
        "full_api_name": "_hashable_parameters",
        "api_description": "Convert the parameters of a gate into a hashable format for lookup in a dictionary.\n\nThis aims to be fast in common cases, and is not intended to work outside of the lifetime of a\nsingle commutation pass; it does not handle mutable state correctly if the state is actually\nchanged.",
        "api_signature": "_hashable_parameters(params)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/commutation_checker.py"
    },
    {
        "api_name": "is_commutation_supported",
        "full_api_name": "is_commutation_supported",
        "api_description": "Filter operations whose commutation is not supported due to bugs in transpiler passes invoking\ncommutation analysis.\nArgs:\n    op (Operation): operation to be checked for commutation relation.\n    qargs (list[Qubit]): qubits the operation acts on.\n    max_num_qubits (int): The maximum number of qubits to check commutativity for.\n\nReturn:\n    True if determining the commutation of op is currently supported",
        "api_signature": "is_commutation_supported(op, qargs, max_num_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/commutation_checker.py"
    },
    {
        "api_name": "_commutation_precheck",
        "full_api_name": "_commutation_precheck",
        "api_description": "",
        "api_signature": "_commutation_precheck(op1, qargs1, cargs1, op2, qargs2, cargs2, max_num_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/commutation_checker.py"
    },
    {
        "api_name": "_get_relative_placement",
        "full_api_name": "_get_relative_placement",
        "api_description": "Determines the relative qubit placement of two gates. Note: this is NOT symmetric.\n\nArgs:\n    first_qargs (DAGOpNode): first gate\n    second_qargs (DAGOpNode): second gate\n\nReturn:\n    A tuple that describes the relative qubit placement: E.g.\n    _get_relative_placement(CX(0, 1), CX(1, 2)) would return (None, 0) as there is no overlap on\n    the first qubit of the first gate but there is an overlap on the second qubit of the first gate,\n    i.e. qubit 0 of the second gate. Likewise,\n    _get_relative_placement(CX(1, 2), CX(0, 1)) would return (1, None)",
        "api_signature": "_get_relative_placement(first_qargs, second_qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/commutation_checker.py"
    },
    {
        "api_name": "_persistent_id",
        "full_api_name": "_persistent_id",
        "api_description": "Returns an integer id of a string that is persistent over different python executions (note that\n    hash() can not be used, i.e. its value can change over two python executions)\nArgs:\n    op_name (str): The string whose integer id should be determined.\nReturn:\n    The integer id of the input string.",
        "api_signature": "_persistent_id(op_name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/commutation_checker.py"
    },
    {
        "api_name": "_order_operations",
        "full_api_name": "_order_operations",
        "api_description": "Orders two operations in a canonical way that is persistent over\n@different python versions and executions\nArgs:\n    op1: first operation.\n    qargs1: first operation's qubits.\n    cargs1: first operation's clbits.\n    op2: second operation.\n    qargs2: second operation's qubits.\n    cargs2: second operation's clbits.\nReturn:\n    The input operations in a persistent, canonical order.",
        "api_signature": "_order_operations(op1, qargs1, cargs1, op2, qargs2, cargs2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/commutation_checker.py"
    },
    {
        "api_name": "_query_commutation",
        "full_api_name": "_query_commutation",
        "api_description": "Queries and returns the commutation of a pair of operations from a provided commutation library\nArgs:\n    first_op: first operation.\n    first_qargs: first operation's qubits.\n    first_cargs: first operation's clbits.\n    second_op: second operation.\n    second_qargs: second operation's qubits.\n    second_cargs: second operation's clbits.\n    _commutation_lib (dict): dictionary of commutation relations\nReturn:\n    True if first_op and second_op commute, False if they do not commute and\n    None if the commutation is not in the library",
        "api_signature": "_query_commutation(first_op, first_qargs, second_op, second_qargs, _commutation_lib)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/commutation_checker.py"
    },
    {
        "api_name": "_commute_matmul",
        "full_api_name": "_commute_matmul",
        "api_description": "",
        "api_signature": "_commute_matmul(first_ops, first_qargs, second_op, second_qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/commutation_checker.py"
    },
    {
        "api_name": "simulate",
        "full_api_name": "ClassicalElement.simulate",
        "api_description": "Evaluate the expression on a bitstring.\n\nThis evaluation is done classically.\n\nArgs:\n    bitstring: The bitstring for which to evaluate.\n\nReturns:\n    bool: result of the evaluation.",
        "api_signature": "simulate(self, bitstring)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classicalfunction/classical_element.py"
    },
    {
        "api_name": "synth",
        "full_api_name": "ClassicalElement.synth",
        "api_description": "Synthesis the logic network into a :class:`~qiskit.circuit.QuantumCircuit`.\n\nArgs:\n    registerless (bool): Default ``True``. If ``False`` uses the parameter names\n        to create registers with those names. Otherwise, creates a circuit with a flat\n        quantum register.\n    synthesizer (callable): A callable that takes a Logic Network and returns a Tweedledum\n        circuit.\nReturns:\n    QuantumCircuit: A circuit implementing the logic network.",
        "api_signature": "synth(self, registerless, synthesizer)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classicalfunction/classical_element.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "ClassicalElement._define",
        "api_description": "The definition of the boolean expression is its synthesis",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classicalfunction/classical_element.py"
    },
    {
        "api_name": "_convert_tweedledum_operator",
        "full_api_name": "_convert_tweedledum_operator",
        "api_description": "",
        "api_signature": "_convert_tweedledum_operator(op)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classicalfunction/utils.py"
    },
    {
        "api_name": "tweedledum2qiskit",
        "full_api_name": "tweedledum2qiskit",
        "api_description": "Converts a `Tweedledum <https://github.com/boschmitt/tweedledum>`_\ncircuit into a Qiskit circuit.\nArgs:\n    tweedledum_circuit (tweedledum.ir.Circuit): Tweedledum circuit.\n    name (str): Name for the resulting Qiskit circuit.\n    qregs (list(QuantumRegister)): Optional. List of QuantumRegisters on which the\n       circuit would operate. If not provided, it will create a flat register.\n\nReturns:\n    QuantumCircuit: The Tweedledum circuit converted to a Qiskit circuit.\n\nRaises:\n    ClassicalFunctionCompilerError: If a gate in the Tweedledum circuit has no Qiskit equivalent.",
        "api_signature": "tweedledum2qiskit(tweedledum_circuit, name, qregs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classicalfunction/utils.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BooleanExpression.__init__",
        "api_description": "Args:\n    expression (str): The logical expression string.\n    name (str): Optional. Instruction gate name. Otherwise part of the expression is\n       going to be used.\n    var_order(list): A list with the order in which variables will be created.\n       (default: by appearance)",
        "api_signature": "__init__(self, expression, name, var_order)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classicalfunction/boolean_expression.py"
    },
    {
        "api_name": "simulate",
        "full_api_name": "BooleanExpression.simulate",
        "api_description": "Evaluate the expression on a bitstring.\n\nThis evaluation is done classically.\n\nArgs:\n    bitstring: The bitstring for which to evaluate.\n\nReturns:\n    bool: result of the evaluation.",
        "api_signature": "simulate(self, bitstring)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classicalfunction/boolean_expression.py"
    },
    {
        "api_name": "synth",
        "full_api_name": "BooleanExpression.synth",
        "api_description": "Synthesis the logic network into a :class:`~qiskit.circuit.QuantumCircuit`.\n\nArgs:\n    registerless: Default ``True``. If ``False`` uses the parameter names\n        to create registers with those names. Otherwise, creates a circuit with a flat\n        quantum register.\n    synthesizer: A callable that takes self and returns a Tweedledum\n        circuit.\nReturns:\n    QuantumCircuit: A circuit implementing the logic network.",
        "api_signature": "synth(self, registerless, synthesizer)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classicalfunction/boolean_expression.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "BooleanExpression._define",
        "api_description": "The definition of the boolean expression is its synthesis",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classicalfunction/boolean_expression.py"
    },
    {
        "api_name": "from_dimacs_file",
        "full_api_name": "BooleanExpression.from_dimacs_file",
        "api_description": "Create a BooleanExpression from the string in the DIMACS format.\nArgs:\n    filename: A file in DIMACS format.\n\nReturns:\n    BooleanExpression: A gate for the input string\n\nRaises:\n    FileNotFoundError: If filename is not found.",
        "api_signature": "from_dimacs_file(cls, filename)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classicalfunction/boolean_expression.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ClassicalFunction.__init__",
        "api_description": "Creates a ``ClassicalFunction`` from Python source code in ``source``.\n\nThe code should be a single function with types.\n\nArgs:\n    source (str): Python code with type hints.\n    name (str): Optional. Default: \"*classicalfunction*\". ClassicalFunction name.\n\nRaises:\n    QiskitError: If source is not a string.",
        "api_signature": "__init__(self, source, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classicalfunction/classicalfunction.py"
    },
    {
        "api_name": "compile",
        "full_api_name": "ClassicalFunction.compile",
        "api_description": "Parses and creates the logical circuit",
        "api_signature": "compile(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classicalfunction/classicalfunction.py"
    },
    {
        "api_name": "network",
        "full_api_name": "ClassicalFunction.network",
        "api_description": "Returns the logical network",
        "api_signature": "network(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classicalfunction/classicalfunction.py"
    },
    {
        "api_name": "scopes",
        "full_api_name": "ClassicalFunction.scopes",
        "api_description": "Returns the scope dict",
        "api_signature": "scopes(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classicalfunction/classicalfunction.py"
    },
    {
        "api_name": "args",
        "full_api_name": "ClassicalFunction.args",
        "api_description": "Returns the classicalfunction arguments",
        "api_signature": "args(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classicalfunction/classicalfunction.py"
    },
    {
        "api_name": "types",
        "full_api_name": "ClassicalFunction.types",
        "api_description": "Dumps a list of scopes with their variables and types.\n\nReturns:\n    list(dict): A list of scopes as dicts, where key is the variable name and\n    value is its type.",
        "api_signature": "types(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classicalfunction/classicalfunction.py"
    },
    {
        "api_name": "simulate",
        "full_api_name": "ClassicalFunction.simulate",
        "api_description": "Evaluate the expression on a bitstring.\n\nThis evaluation is done classically.\n\nArgs:\n    bitstring: The bitstring for which to evaluate.\n\nReturns:\n    bool: result of the evaluation.",
        "api_signature": "simulate(self, bitstring)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classicalfunction/classicalfunction.py"
    },
    {
        "api_name": "simulate_all",
        "full_api_name": "ClassicalFunction.simulate_all",
        "api_description": "Returns a truth table.\n\nReturns:\n    str: a bitstring with a truth table",
        "api_signature": "simulate_all(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classicalfunction/classicalfunction.py"
    },
    {
        "api_name": "truth_table",
        "full_api_name": "ClassicalFunction.truth_table",
        "api_description": "Returns (and computes) the truth table",
        "api_signature": "truth_table(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classicalfunction/classicalfunction.py"
    },
    {
        "api_name": "synth",
        "full_api_name": "ClassicalFunction.synth",
        "api_description": "Synthesis the logic network into a :class:`~qiskit.circuit.QuantumCircuit`.\n\nArgs:\n    registerless: Default ``True``. If ``False`` uses the parameter names to create\n    registers with those names. Otherwise, creates a circuit with a flat quantum register.\n    synthesizer: Optional. If None tweedledum's pkrm_synth is used.\n\nReturns:\n    QuantumCircuit: A circuit implementing the logic network.",
        "api_signature": "synth(self, registerless, synthesizer)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classicalfunction/classicalfunction.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "ClassicalFunction._define",
        "api_description": "The definition of the classical function is its synthesis",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classicalfunction/classicalfunction.py"
    },
    {
        "api_name": "qregs",
        "full_api_name": "ClassicalFunction.qregs",
        "api_description": "The list of qregs used by the classicalfunction",
        "api_signature": "qregs(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classicalfunction/classicalfunction.py"
    },
    {
        "api_name": "classical_function",
        "full_api_name": "classical_function",
        "api_description": "Parses and type checks the callable ``func`` to compile it into an ``ClassicalFunction``\nthat can be synthesized into a ``QuantumCircuit``.\n\nArgs:\n    func (callable): A callable (with type hints) to compile into an ``ClassicalFunction``.\n\nReturns:\n    ClassicalFunction: An object that can synthesis into a QuantumCircuit (via ``synth()``\n    method).",
        "api_signature": "classical_function(func)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classicalfunction/__init__.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ClassicalFunctionVisitor.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classicalfunction/classical_function_visitor.py"
    },
    {
        "api_name": "visit_Module",
        "full_api_name": "ClassicalFunctionVisitor.visit_Module",
        "api_description": "The full snippet should contain a single function",
        "api_signature": "visit_Module(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classicalfunction/classical_function_visitor.py"
    },
    {
        "api_name": "visit_FunctionDef",
        "full_api_name": "ClassicalFunctionVisitor.visit_FunctionDef",
        "api_description": "The function definition should have type hints",
        "api_signature": "visit_FunctionDef(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classicalfunction/classical_function_visitor.py"
    },
    {
        "api_name": "visit_Return",
        "full_api_name": "ClassicalFunctionVisitor.visit_Return",
        "api_description": "The return type should match the return type hint.",
        "api_signature": "visit_Return(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classicalfunction/classical_function_visitor.py"
    },
    {
        "api_name": "visit_Assign",
        "full_api_name": "ClassicalFunctionVisitor.visit_Assign",
        "api_description": "When assign, the scope needs to be updated with the right type",
        "api_signature": "visit_Assign(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classicalfunction/classical_function_visitor.py"
    },
    {
        "api_name": "bit_binop",
        "full_api_name": "ClassicalFunctionVisitor.bit_binop",
        "api_description": "Uses ClassicalFunctionVisitor.bitops to extend self._network",
        "api_signature": "bit_binop(self, op, values)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classicalfunction/classical_function_visitor.py"
    },
    {
        "api_name": "visit_BoolOp",
        "full_api_name": "ClassicalFunctionVisitor.visit_BoolOp",
        "api_description": "Handles ``and`` and ``or``.\nnode.left=Int1 and node.right=Int1 return Int1",
        "api_signature": "visit_BoolOp(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classicalfunction/classical_function_visitor.py"
    },
    {
        "api_name": "visit_BinOp",
        "full_api_name": "ClassicalFunctionVisitor.visit_BinOp",
        "api_description": "Handles ``&``, ``^``, and ``|``.\nnode.left=Int1 and node.right=Int1 return Int1",
        "api_signature": "visit_BinOp(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classicalfunction/classical_function_visitor.py"
    },
    {
        "api_name": "visit_UnaryOp",
        "full_api_name": "ClassicalFunctionVisitor.visit_UnaryOp",
        "api_description": "Handles ``~``. Cannot operate on Int1s.",
        "api_signature": "visit_UnaryOp(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classicalfunction/classical_function_visitor.py"
    },
    {
        "api_name": "visit_Name",
        "full_api_name": "ClassicalFunctionVisitor.visit_Name",
        "api_description": "Reduce variable names.",
        "api_signature": "visit_Name(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classicalfunction/classical_function_visitor.py"
    },
    {
        "api_name": "generic_visit",
        "full_api_name": "ClassicalFunctionVisitor.generic_visit",
        "api_description": "Catch all for the unhandled nodes.",
        "api_signature": "generic_visit(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classicalfunction/classical_function_visitor.py"
    },
    {
        "api_name": "extend_scope",
        "full_api_name": "ClassicalFunctionVisitor.extend_scope",
        "api_description": "Add the arguments to the scope",
        "api_signature": "extend_scope(self, args_node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classicalfunction/classical_function_visitor.py"
    },
    {
        "api_name": "random_circuit",
        "full_api_name": "random_circuit",
        "api_description": "Generate random circuit of arbitrary size and form.\n\nThis function will generate a random circuit by randomly selecting gates\nfrom the set of standard gates in :mod:`qiskit.circuit.library.standard_gates`. For example:\n\n.. plot::\n   :include-source:\n\n   from qiskit.circuit.random import random_circuit\n\n   circ = random_circuit(2, 2, measure=True)\n   circ.draw(output='mpl')\n\nArgs:\n    num_qubits (int): number of quantum wires\n    depth (int): layers of operations (i.e. critical path length)\n    max_operands (int): maximum qubit operands of each gate (between 1 and 4)\n    measure (bool): if True, measure all qubits at the end\n    conditional (bool): if True, insert middle measurements and conditionals\n    reset (bool): if True, insert middle resets\n    seed (int): sets random seed (optional)\n    num_operand_distribution (dict): a distribution of gates that specifies the ratio\n    of 1-qubit, 2-qubit, 3-qubit, ..., n-qubit gates in the random circuit. Expect a\n    deviation from the specified ratios that depends on the size of the requested\n    random circuit. (optional)\n\nReturns:\n    QuantumCircuit: constructed circuit\n\nRaises:\n    CircuitError: when invalid options given",
        "api_signature": "random_circuit(num_qubits, depth, max_operands, measure, conditional, reset, seed, num_operand_distribution)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/random/utils.py"
    },
    {
        "api_name": "random_clifford_circuit",
        "full_api_name": "random_clifford_circuit",
        "api_description": "Generate a pseudo-random Clifford circuit.\n\nThis function will generate a Clifford circuit by randomly selecting the chosen amount of Clifford\ngates from the set of standard gates in :mod:`qiskit.circuit.library.standard_gates`. For example:\n\n.. plot::\n   :include-source:\n\n   from qiskit.circuit.random import random_clifford_circuit\n\n   circ = random_clifford_circuit(num_qubits=2, num_gates=6)\n   circ.draw(output='mpl')\n\nArgs:\n    num_qubits (int): number of quantum wires.\n    num_gates (int): number of gates in the circuit.\n    gates (list[str]): optional list of Clifford gate names to randomly sample from.\n        If ``\"all\"`` (default), use all Clifford gates in the standard library.\n    seed (int | np.random.Generator): sets random seed/generator (optional).\n\nReturns:\n    QuantumCircuit: constructed circuit",
        "api_signature": "random_clifford_circuit(num_qubits, num_gates, gates, seed)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/random/utils.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PauliEvolutionGate.__init__",
        "api_description": "Args:\n    operator (Pauli | SparsePauliOp | list):\n        The operator to evolve. Can also be provided as list of non-commuting\n        operators where the elements are sums of commuting operators.\n        For example: ``[XY + YX, ZZ + ZI + IZ, YY]``.\n    time: The evolution time.\n    label: A label for the gate to display in visualizations. Per default, the label is\n        set to ``exp(-it <operators>)`` where ``<operators>`` is the sum of the Paulis.\n        Note that the label does not include any coefficients of the Paulis. See the\n        class docstring for an example.\n    synthesis: A synthesis strategy. If None, the default synthesis is the Lie-Trotter\n        product formula with a single repetition.",
        "api_signature": "__init__(self, operator, time, label, synthesis)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/pauli_evolution.py"
    },
    {
        "api_name": "time",
        "full_api_name": "PauliEvolutionGate.time",
        "api_description": "Return the evolution time as stored in the gate parameters.\n\nReturns:\n    The evolution time.",
        "api_signature": "time(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/pauli_evolution.py"
    },
    {
        "api_name": "time",
        "full_api_name": "PauliEvolutionGate.time",
        "api_description": "Set the evolution time.\n\nArgs:\n    time: The evolution time.",
        "api_signature": "time(self, time)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/pauli_evolution.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "PauliEvolutionGate._define",
        "api_description": "Unroll, where the default synthesis is matrix based.",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/pauli_evolution.py"
    },
    {
        "api_name": "validate_parameter",
        "full_api_name": "PauliEvolutionGate.validate_parameter",
        "api_description": "Gate parameters should be int, float, or ParameterExpression",
        "api_signature": "validate_parameter(self, parameter)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/pauli_evolution.py"
    },
    {
        "api_name": "_to_sparse_pauli_op",
        "full_api_name": "_to_sparse_pauli_op",
        "api_description": "Cast the operator to a SparsePauliOp.",
        "api_signature": "_to_sparse_pauli_op(operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/pauli_evolution.py"
    },
    {
        "api_name": "_get_default_label",
        "full_api_name": "_get_default_label",
        "api_description": "",
        "api_signature": "_get_default_label(operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/pauli_evolution.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QuantumVolume.__init__",
        "api_description": "Create quantum volume model circuit of size num_qubits x depth.\n\nArgs:\n    num_qubits: number of active qubits in model circuit.\n    depth: layers of SU(4) operations in model circuit.\n    seed: Random number generator or generator seed.\n    classical_permutation: use classical permutations at every layer,\n        rather than quantum.\n    flatten: If ``False`` (the default), construct a circuit that contains a single\n        instruction, which in turn has the actual volume structure.  If ``True``, construct\n        the volume structure directly.",
        "api_signature": "__init__(self, num_qubits, depth, seed, classical_permutation)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/quantum_volume.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "IQP.__init__",
        "api_description": "Create IQP circuit.\n\nArgs:\n    interactions: input n-by-n symmetric matrix.\n\nRaises:\n    CircuitError: if the inputs is not as symmetric matrix.",
        "api_signature": "__init__(self, interactions)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/iqp.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "HiddenLinearFunction.__init__",
        "api_description": "Create new HLF circuit.\n\nArgs:\n    adjacency_matrix: a symmetric n-by-n list of 0-1 lists.\n        n will be the number of qubits.\n\nRaises:\n    CircuitError: If A is not symmetric.",
        "api_signature": "__init__(self, adjacency_matrix)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/hidden_linear_function.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "FourierChecking.__init__",
        "api_description": "Create Fourier checking circuit.\n\nArgs:\n    f: truth table for f, length 2**n list of {1,-1}.\n    g: truth table for g, length 2**n list of {1,-1}.\n\nRaises:\n    CircuitError: if the inputs f and g are not valid.\n\nReference Circuit:\n    .. plot::\n\n       from qiskit.circuit.library import FourierChecking\n       from qiskit.visualization.library import _generate_circuit_library_visualization\n       f = [1, -1, -1, -1]\n       g = [1, 1, -1, -1]\n       circuit = FourierChecking(f, g)\n       _generate_circuit_library_visualization(circuit)",
        "api_signature": "__init__(self, f, g)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/fourier_checking.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PhaseOracle.__init__",
        "api_description": "Creates a PhaseOracle object\n\nArgs:\n    expression: A Python-like boolean expression.\n    synthesizer: Optional. A function to convert a BooleanExpression into a QuantumCircuit\n       If None is provided, Tweedledum's `pkrm_synth` with `phase_esop` will be used.\n    var_order(list): A list with the order in which variables will be created.\n       (default: by appearance)",
        "api_signature": "__init__(self, expression, synthesizer, var_order)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/phase_oracle.py"
    },
    {
        "api_name": "synthesizer",
        "full_api_name": "PhaseOracle.synthesizer",
        "api_description": "",
        "api_signature": "synthesizer(boolean_expression)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/phase_oracle.py"
    },
    {
        "api_name": "evaluate_bitstring",
        "full_api_name": "PhaseOracle.evaluate_bitstring",
        "api_description": "Evaluate the oracle on a bitstring.\nThis evaluation is done classically without any quantum circuit.\n\nArgs:\n    bitstring: The bitstring for which to evaluate. The input bitstring is expected to be\n        in little-endian order.\n\nReturns:\n    True if the bitstring is a good state, False otherwise.",
        "api_signature": "evaluate_bitstring(self, bitstring)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/phase_oracle.py"
    },
    {
        "api_name": "from_dimacs_file",
        "full_api_name": "PhaseOracle.from_dimacs_file",
        "api_description": "Create a PhaseOracle from the string in the DIMACS format.\n\nIt is possible to build a PhaseOracle from a file in `DIMACS CNF format\n<http://www.satcompetition.org/2009/format-benchmarks2009.html>`__,\nwhich is the standard format for specifying SATisfiability (SAT) problem instances in\n`Conjunctive Normal Form (CNF) <https://en.wikipedia.org/wiki/Conjunctive_normal_form>`__,\nwhich is a conjunction of one or more clauses, where a clause is a disjunction of one\nor more literals.\n\nThe following is an example of a CNF expressed in the DIMACS format:\n\n.. code:: text\n\n  c DIMACS CNF file with 3 satisfying assignments: 1 -2 3, -1 -2 -3, 1 2 -3.\n  p cnf 3 5\n  -1 -2 -3 0\n  1 -2 3 0\n  1 2 -3 0\n  1 -2 -3 0\n  -1 2 3 0\n\nThe first line, following the `c` character, is a comment. The second line specifies that\nthe CNF is over three boolean variables --- let us call them  :math:`x_1, x_2, x_3`, and\ncontains five clauses.  The five clauses, listed afterwards, are implicitly joined by the\nlogical `AND` operator, :math:`\\land`, while the variables in each clause, represented by\ntheir indices, are implicitly disjoined by the logical `OR` operator, :math:`lor`. The\n:math:`-` symbol preceding a boolean variable index corresponds to the logical `NOT`\noperator, :math:`lnot`. Character `0` (zero) marks the end of each clause.  Essentially,\nthe code above corresponds to the following CNF:\n\n:math:`(\\lnot x_1 \\lor \\lnot x_2 \\lor \\lnot x_3)\n\\land (x_1 \\lor \\lnot x_2 \\lor x_3)\n\\land (x_1 \\lor x_2 \\lor \\lnot x_3)\n\\land (x_1 \\lor \\lnot x_2 \\lor \\lnot x_3)\n\\land (\\lnot x_1 \\lor x_2 \\lor x_3)`.\n\n\nArgs:\n    filename: A file in DIMACS format.\n\nReturns:\n    PhaseOracle: A quantum circuit with a phase oracle.",
        "api_signature": "from_dimacs_file(cls, filename)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/phase_oracle.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "UnitaryOverlap.__init__",
        "api_description": "Args:\n    unitary1: Unitary acting on the ket vector.\n    unitary2: Unitary whose inverse operates on the bra vector.\n    prefix1: The name of the parameter vector associated to ``unitary1``,\n        if it is parameterized. Defaults to ``\"p1\"``.\n    prefix2: The name of the parameter vector associated to ``unitary2``,\n        if it is parameterized. Defaults to ``\"p2\"``.\n    insert_barrier: Whether to insert a barrier between the two unitaries.\n\nRaises:\n    CircuitError: Number of qubits in ``unitary1`` and ``unitary2`` does not match.\n    CircuitError: Inputs contain measurements and/or resets.",
        "api_signature": "__init__(self, unitary1, unitary2, prefix1, prefix2, insert_barrier)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/overlap.py"
    },
    {
        "api_name": "_check_unitary",
        "full_api_name": "_check_unitary",
        "api_description": "Check a circuit is unitary by checking if all operations are of type ``Gate``.",
        "api_signature": "_check_unitary(circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/overlap.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PhaseEstimation.__init__",
        "api_description": "Args:\n    num_evaluation_qubits: The number of evaluation qubits.\n    unitary: The unitary operation :math:`U` which will be repeated and controlled.\n    iqft: A inverse Quantum Fourier Transform, per default the inverse of\n        :class:`~qiskit.circuit.library.QFT` is used. Note that the QFT should not include\n        the usual swaps!\n    name: The name of the circuit.\n\n.. note::\n\n    The inverse QFT should not include a swap of the qubit order.\n\nReference Circuit:\n    .. plot::\n\n       from qiskit.circuit import QuantumCircuit\n       from qiskit.circuit.library import PhaseEstimation\n       from qiskit.visualization.library import _generate_circuit_library_visualization\n       unitary = QuantumCircuit(2)\n       unitary.x(0)\n       unitary.y(1)\n       circuit = PhaseEstimation(3, unitary)\n       _generate_circuit_library_visualization(circuit)",
        "api_signature": "__init__(self, num_evaluation_qubits, unitary, iqft, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/phase_estimation.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "GroverOperator.__init__",
        "api_description": "Args:\n    oracle: The phase oracle implementing a reflection about the bad state. Note that this\n        is not a bitflip oracle, see the docstring for more information.\n    state_preparation: The operator preparing the good and bad state.\n        For Grover's algorithm, this is a n-qubit Hadamard gate and for amplitude\n        amplification or estimation the operator :math:`\\mathcal{A}`.\n    zero_reflection: The reflection about the zero state, :math:`\\mathcal{S}_0`.\n    reflection_qubits: Qubits on which the zero reflection acts on.\n    insert_barriers: Whether barriers should be inserted between the reflections and A.\n    mcx_mode: The mode to use for building the default zero reflection.\n    name: The name of the circuit.",
        "api_signature": "__init__(self, oracle, state_preparation, zero_reflection, reflection_qubits, insert_barriers, mcx_mode, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/grover_operator.py"
    },
    {
        "api_name": "reflection_qubits",
        "full_api_name": "GroverOperator.reflection_qubits",
        "api_description": "Reflection qubits, on which S0 is applied (if S0 is not user-specified).",
        "api_signature": "reflection_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/grover_operator.py"
    },
    {
        "api_name": "zero_reflection",
        "full_api_name": "GroverOperator.zero_reflection",
        "api_description": "The subcircuit implementing the reflection about 0.",
        "api_signature": "zero_reflection(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/grover_operator.py"
    },
    {
        "api_name": "state_preparation",
        "full_api_name": "GroverOperator.state_preparation",
        "api_description": "The subcircuit implementing the A operator or Hadamards.",
        "api_signature": "state_preparation(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/grover_operator.py"
    },
    {
        "api_name": "oracle",
        "full_api_name": "GroverOperator.oracle",
        "api_description": "The oracle implementing a reflection about the bad state.",
        "api_signature": "oracle(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/grover_operator.py"
    },
    {
        "api_name": "_build",
        "full_api_name": "GroverOperator._build",
        "api_description": "",
        "api_signature": "_build(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/grover_operator.py"
    },
    {
        "api_name": "_zero_reflection",
        "full_api_name": "_zero_reflection",
        "api_description": "",
        "api_signature": "_zero_reflection(num_state_qubits, qubits, mcx_mode)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/grover_operator.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BlueprintCircuit.__init__",
        "api_description": "Create a new blueprint circuit.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/blueprintcircuit.py"
    },
    {
        "api_name": "_check_configuration",
        "full_api_name": "BlueprintCircuit._check_configuration",
        "api_description": "Check if the current configuration allows the circuit to be built.\n\nArgs:\n    raise_on_failure: If True, raise if the configuration is invalid. If False, return\n        False if the configuration is invalid.\n\nReturns:\n    True, if the configuration is valid. Otherwise, depending on the value of\n    ``raise_on_failure`` an error is raised or False is returned.",
        "api_signature": "_check_configuration(self, raise_on_failure)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/blueprintcircuit.py"
    },
    {
        "api_name": "_build",
        "full_api_name": "BlueprintCircuit._build",
        "api_description": "Build the circuit.",
        "api_signature": "_build(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/blueprintcircuit.py"
    },
    {
        "api_name": "_invalidate",
        "full_api_name": "BlueprintCircuit._invalidate",
        "api_description": "Invalidate the current circuit build.",
        "api_signature": "_invalidate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/blueprintcircuit.py"
    },
    {
        "api_name": "qregs",
        "full_api_name": "BlueprintCircuit.qregs",
        "api_description": "A list of the quantum registers associated with the circuit.",
        "api_signature": "qregs(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/blueprintcircuit.py"
    },
    {
        "api_name": "qregs",
        "full_api_name": "BlueprintCircuit.qregs",
        "api_description": "Set the quantum registers associated with the circuit.",
        "api_signature": "qregs(self, qregs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/blueprintcircuit.py"
    },
    {
        "api_name": "data",
        "full_api_name": "BlueprintCircuit.data",
        "api_description": "",
        "api_signature": "data(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/blueprintcircuit.py"
    },
    {
        "api_name": "decompose",
        "full_api_name": "BlueprintCircuit.decompose",
        "api_description": "",
        "api_signature": "decompose(self, gates_to_decompose, reps)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/blueprintcircuit.py"
    },
    {
        "api_name": "draw",
        "full_api_name": "BlueprintCircuit.draw",
        "api_description": "",
        "api_signature": "draw(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/blueprintcircuit.py"
    },
    {
        "api_name": "num_parameters",
        "full_api_name": "BlueprintCircuit.num_parameters",
        "api_description": "",
        "api_signature": "num_parameters(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/blueprintcircuit.py"
    },
    {
        "api_name": "parameters",
        "full_api_name": "BlueprintCircuit.parameters",
        "api_description": "",
        "api_signature": "parameters(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/blueprintcircuit.py"
    },
    {
        "api_name": "_append",
        "full_api_name": "BlueprintCircuit._append",
        "api_description": "",
        "api_signature": "_append(self, instruction, _qargs, _cargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/blueprintcircuit.py"
    },
    {
        "api_name": "compose",
        "full_api_name": "BlueprintCircuit.compose",
        "api_description": "",
        "api_signature": "compose(self, other, qubits, clbits, front, inplace, wrap)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/blueprintcircuit.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "BlueprintCircuit.inverse",
        "api_description": "",
        "api_signature": "inverse(self, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/blueprintcircuit.py"
    },
    {
        "api_name": "__len__",
        "full_api_name": "BlueprintCircuit.__len__",
        "api_description": "",
        "api_signature": "__len__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/blueprintcircuit.py"
    },
    {
        "api_name": "__getitem__",
        "full_api_name": "BlueprintCircuit.__getitem__",
        "api_description": "",
        "api_signature": "__getitem__(self, item)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/blueprintcircuit.py"
    },
    {
        "api_name": "size",
        "full_api_name": "BlueprintCircuit.size",
        "api_description": "",
        "api_signature": "size(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/blueprintcircuit.py"
    },
    {
        "api_name": "to_instruction",
        "full_api_name": "BlueprintCircuit.to_instruction",
        "api_description": "",
        "api_signature": "to_instruction(self, parameter_map, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/blueprintcircuit.py"
    },
    {
        "api_name": "to_gate",
        "full_api_name": "BlueprintCircuit.to_gate",
        "api_description": "",
        "api_signature": "to_gate(self, parameter_map, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/blueprintcircuit.py"
    },
    {
        "api_name": "depth",
        "full_api_name": "BlueprintCircuit.depth",
        "api_description": "",
        "api_signature": "depth(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/blueprintcircuit.py"
    },
    {
        "api_name": "count_ops",
        "full_api_name": "BlueprintCircuit.count_ops",
        "api_description": "",
        "api_signature": "count_ops(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/blueprintcircuit.py"
    },
    {
        "api_name": "num_nonlocal_gates",
        "full_api_name": "BlueprintCircuit.num_nonlocal_gates",
        "api_description": "",
        "api_signature": "num_nonlocal_gates(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/blueprintcircuit.py"
    },
    {
        "api_name": "num_connected_components",
        "full_api_name": "BlueprintCircuit.num_connected_components",
        "api_description": "",
        "api_signature": "num_connected_components(self, unitary_only)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/blueprintcircuit.py"
    },
    {
        "api_name": "copy_empty_like",
        "full_api_name": "BlueprintCircuit.copy_empty_like",
        "api_description": "",
        "api_signature": "copy_empty_like(self, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/blueprintcircuit.py"
    },
    {
        "api_name": "copy",
        "full_api_name": "BlueprintCircuit.copy",
        "api_description": "",
        "api_signature": "copy(self, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/blueprintcircuit.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "HamiltonianGate.__init__",
        "api_description": "Args:\n    data: A hermitian operator.\n    time: Time evolution parameter.\n    label: Unitary name for backend [Default: ``None``].\n\nRaises:\n    ValueError: if input data is not an N-qubit unitary operator.",
        "api_signature": "__init__(self, data, time, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/hamiltonian_gate.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "HamiltonianGate.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/hamiltonian_gate.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "HamiltonianGate.__array__",
        "api_description": "Return matrix for the unitary.",
        "api_signature": "__array__(self, dtype, copy)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/hamiltonian_gate.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "HamiltonianGate.inverse",
        "api_description": "Return the adjoint of the unitary.",
        "api_signature": "inverse(self, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/hamiltonian_gate.py"
    },
    {
        "api_name": "conjugate",
        "full_api_name": "HamiltonianGate.conjugate",
        "api_description": "Return the conjugate of the Hamiltonian.",
        "api_signature": "conjugate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/hamiltonian_gate.py"
    },
    {
        "api_name": "adjoint",
        "full_api_name": "HamiltonianGate.adjoint",
        "api_description": "Return the adjoint of the unitary.",
        "api_signature": "adjoint(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/hamiltonian_gate.py"
    },
    {
        "api_name": "transpose",
        "full_api_name": "HamiltonianGate.transpose",
        "api_description": "Return the transpose of the Hamiltonian.",
        "api_signature": "transpose(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/hamiltonian_gate.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "HamiltonianGate._define",
        "api_description": "Calculate a subcircuit that implements this unitary.",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/hamiltonian_gate.py"
    },
    {
        "api_name": "validate_parameter",
        "full_api_name": "HamiltonianGate.validate_parameter",
        "api_description": "Hamiltonian parameter has to be an ndarray, operator or float.",
        "api_signature": "validate_parameter(self, parameter)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/hamiltonian_gate.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "GraphState.__init__",
        "api_description": "Create graph state preparation circuit.\n\nArgs:\n    adjacency_matrix: input graph as n-by-n list of 0-1 lists\n\nRaises:\n    CircuitError: If adjacency_matrix is not symmetric.\n\nThe circuit prepares a graph state with the given adjacency\nmatrix.",
        "api_signature": "__init__(self, adjacency_matrix)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/graph_state.py"
    },
    {
        "api_name": "clifford_8_1",
        "full_api_name": "clifford_8_1",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "clifford_8_1()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/clifford/clifford_8_1.py"
    },
    {
        "api_name": "clifford_3_1",
        "full_api_name": "clifford_3_1",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "clifford_3_1()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/clifford/clifford_3_1.py"
    },
    {
        "api_name": "clifford_6_5",
        "full_api_name": "clifford_6_5",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "clifford_6_5()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/clifford/clifford_6_5.py"
    },
    {
        "api_name": "clifford_8_3",
        "full_api_name": "clifford_8_3",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "clifford_8_3()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/clifford/clifford_8_3.py"
    },
    {
        "api_name": "clifford_6_2",
        "full_api_name": "clifford_6_2",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "clifford_6_2()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/clifford/clifford_6_2.py"
    },
    {
        "api_name": "clifford_8_2",
        "full_api_name": "clifford_8_2",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "clifford_8_2()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/clifford/clifford_8_2.py"
    },
    {
        "api_name": "clifford_6_1",
        "full_api_name": "clifford_6_1",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "clifford_6_1()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/clifford/clifford_6_1.py"
    },
    {
        "api_name": "clifford_4_4",
        "full_api_name": "clifford_4_4",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "clifford_4_4()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/clifford/clifford_4_4.py"
    },
    {
        "api_name": "clifford_2_2",
        "full_api_name": "clifford_2_2",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "clifford_2_2()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/clifford/clifford_2_2.py"
    },
    {
        "api_name": "clifford_5_1",
        "full_api_name": "clifford_5_1",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "clifford_5_1()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/clifford/clifford_5_1.py"
    },
    {
        "api_name": "clifford_4_2",
        "full_api_name": "clifford_4_2",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "clifford_4_2()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/clifford/clifford_4_2.py"
    },
    {
        "api_name": "clifford_6_4",
        "full_api_name": "clifford_6_4",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "clifford_6_4()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/clifford/clifford_6_4.py"
    },
    {
        "api_name": "clifford_2_3",
        "full_api_name": "clifford_2_3",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "clifford_2_3()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/clifford/clifford_2_3.py"
    },
    {
        "api_name": "clifford_4_3",
        "full_api_name": "clifford_4_3",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "clifford_4_3()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/clifford/clifford_4_3.py"
    },
    {
        "api_name": "clifford_2_4",
        "full_api_name": "clifford_2_4",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "clifford_2_4()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/clifford/clifford_2_4.py"
    },
    {
        "api_name": "clifford_6_3",
        "full_api_name": "clifford_6_3",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "clifford_6_3()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/clifford/clifford_6_3.py"
    },
    {
        "api_name": "clifford_4_1",
        "full_api_name": "clifford_4_1",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "clifford_4_1()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/clifford/clifford_4_1.py"
    },
    {
        "api_name": "clifford_2_1",
        "full_api_name": "clifford_2_1",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "clifford_2_1()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/clifford/clifford_2_1.py"
    },
    {
        "api_name": "rzx_cy",
        "full_api_name": "rzx_cy",
        "api_description": "Template for CX - RYGate - CX.",
        "api_signature": "rzx_cy(theta)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/rzx/rzx_cy.py"
    },
    {
        "api_name": "rzx_zz2",
        "full_api_name": "rzx_zz2",
        "api_description": "Template for CX - RZGate - CX.",
        "api_signature": "rzx_zz2(theta)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/rzx/rzx_zz2.py"
    },
    {
        "api_name": "rzx_xz",
        "full_api_name": "rzx_xz",
        "api_description": "Template for CX - RXGate - CX.",
        "api_signature": "rzx_xz(theta)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/rzx/rzx_xz.py"
    },
    {
        "api_name": "rzx_zz3",
        "full_api_name": "rzx_zz3",
        "api_description": "Template for CX - RZGate - CX.",
        "api_signature": "rzx_zz3(theta)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/rzx/rzx_zz3.py"
    },
    {
        "api_name": "rzx_zz1",
        "full_api_name": "rzx_zz1",
        "api_description": "Template for CX - RZGate - CX.",
        "api_signature": "rzx_zz1(theta)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/rzx/rzx_zz1.py"
    },
    {
        "api_name": "rzx_yz",
        "full_api_name": "rzx_yz",
        "api_description": "Template for CX - RYGate - CX.",
        "api_signature": "rzx_yz(theta)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/rzx/rzx_yz.py"
    },
    {
        "api_name": "template_nct_9c_6",
        "full_api_name": "template_nct_9c_6",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_9c_6()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_9c_6.py"
    },
    {
        "api_name": "template_nct_9c_1",
        "full_api_name": "template_nct_9c_1",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_9c_1()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_9c_1.py"
    },
    {
        "api_name": "template_nct_9d_5",
        "full_api_name": "template_nct_9d_5",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_9d_5()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_9d_5.py"
    },
    {
        "api_name": "template_nct_4b_1",
        "full_api_name": "template_nct_4b_1",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_4b_1()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_4b_1.py"
    },
    {
        "api_name": "template_nct_9d_8",
        "full_api_name": "template_nct_9d_8",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_9d_8()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_9d_8.py"
    },
    {
        "api_name": "template_nct_9c_11",
        "full_api_name": "template_nct_9c_11",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_9c_11()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_9c_11.py"
    },
    {
        "api_name": "template_nct_6b_1",
        "full_api_name": "template_nct_6b_1",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_6b_1()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_6b_1.py"
    },
    {
        "api_name": "template_nct_5a_2",
        "full_api_name": "template_nct_5a_2",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_5a_2()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_5a_2.py"
    },
    {
        "api_name": "template_nct_6a_3",
        "full_api_name": "template_nct_6a_3",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_6a_3()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_6a_3.py"
    },
    {
        "api_name": "template_nct_5a_4",
        "full_api_name": "template_nct_5a_4",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_5a_4()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_5a_4.py"
    },
    {
        "api_name": "template_nct_9d_9",
        "full_api_name": "template_nct_9d_9",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_9d_9()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_9d_9.py"
    },
    {
        "api_name": "template_nct_2a_3",
        "full_api_name": "template_nct_2a_3",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_2a_3()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_2a_3.py"
    },
    {
        "api_name": "template_nct_9d_1",
        "full_api_name": "template_nct_9d_1",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_9d_1()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_9d_1.py"
    },
    {
        "api_name": "template_nct_9c_5",
        "full_api_name": "template_nct_9c_5",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_9c_5()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_9c_5.py"
    },
    {
        "api_name": "template_nct_6a_4",
        "full_api_name": "template_nct_6a_4",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_6a_4()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_6a_4.py"
    },
    {
        "api_name": "template_nct_6a_1",
        "full_api_name": "template_nct_6a_1",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_6a_1()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_6a_1.py"
    },
    {
        "api_name": "template_nct_7a_1",
        "full_api_name": "template_nct_7a_1",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_7a_1()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_7a_1.py"
    },
    {
        "api_name": "template_nct_9c_12",
        "full_api_name": "template_nct_9c_12",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_9c_12()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_9c_12.py"
    },
    {
        "api_name": "template_nct_9c_7",
        "full_api_name": "template_nct_9c_7",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_9c_7()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_9c_7.py"
    },
    {
        "api_name": "template_nct_7c_1",
        "full_api_name": "template_nct_7c_1",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_7c_1()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_7c_1.py"
    },
    {
        "api_name": "template_nct_6c_1",
        "full_api_name": "template_nct_6c_1",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_6c_1()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_6c_1.py"
    },
    {
        "api_name": "template_nct_4b_2",
        "full_api_name": "template_nct_4b_2",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_4b_2()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_4b_2.py"
    },
    {
        "api_name": "template_nct_2a_1",
        "full_api_name": "template_nct_2a_1",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_2a_1()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_2a_1.py"
    },
    {
        "api_name": "template_nct_5a_3",
        "full_api_name": "template_nct_5a_3",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_5a_3()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_5a_3.py"
    },
    {
        "api_name": "template_nct_9c_9",
        "full_api_name": "template_nct_9c_9",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_9c_9()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_9c_9.py"
    },
    {
        "api_name": "template_nct_9d_4",
        "full_api_name": "template_nct_9d_4",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_9d_4()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_9d_4.py"
    },
    {
        "api_name": "template_nct_9c_10",
        "full_api_name": "template_nct_9c_10",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_9c_10()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_9c_10.py"
    },
    {
        "api_name": "template_nct_9a_1",
        "full_api_name": "template_nct_9a_1",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_9a_1()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_9a_1.py"
    },
    {
        "api_name": "template_nct_9c_3",
        "full_api_name": "template_nct_9c_3",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_9c_3()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_9c_3.py"
    },
    {
        "api_name": "template_nct_6a_2",
        "full_api_name": "template_nct_6a_2",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_6a_2()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_6a_2.py"
    },
    {
        "api_name": "template_nct_9d_10",
        "full_api_name": "template_nct_9d_10",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_9d_10()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_9d_10.py"
    },
    {
        "api_name": "template_nct_4a_3",
        "full_api_name": "template_nct_4a_3",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_4a_3()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_4a_3.py"
    },
    {
        "api_name": "template_nct_9d_2",
        "full_api_name": "template_nct_9d_2",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_9d_2()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_9d_2.py"
    },
    {
        "api_name": "template_nct_9c_4",
        "full_api_name": "template_nct_9c_4",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_9c_4()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_9c_4.py"
    },
    {
        "api_name": "template_nct_9d_3",
        "full_api_name": "template_nct_9d_3",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_9d_3()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_9d_3.py"
    },
    {
        "api_name": "template_nct_4a_1",
        "full_api_name": "template_nct_4a_1",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_4a_1()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_4a_1.py"
    },
    {
        "api_name": "template_nct_4a_2",
        "full_api_name": "template_nct_4a_2",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_4a_2()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_4a_2.py"
    },
    {
        "api_name": "template_nct_5a_1",
        "full_api_name": "template_nct_5a_1",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_5a_1()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_5a_1.py"
    },
    {
        "api_name": "template_nct_9c_8",
        "full_api_name": "template_nct_9c_8",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_9c_8()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_9c_8.py"
    },
    {
        "api_name": "template_nct_6b_2",
        "full_api_name": "template_nct_6b_2",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_6b_2()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_6b_2.py"
    },
    {
        "api_name": "template_nct_7d_1",
        "full_api_name": "template_nct_7d_1",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_7d_1()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_7d_1.py"
    },
    {
        "api_name": "template_nct_7b_1",
        "full_api_name": "template_nct_7b_1",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_7b_1()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_7b_1.py"
    },
    {
        "api_name": "template_nct_9d_6",
        "full_api_name": "template_nct_9d_6",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_9d_6()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_9d_6.py"
    },
    {
        "api_name": "template_nct_9d_7",
        "full_api_name": "template_nct_9d_7",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_9d_7()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_9d_7.py"
    },
    {
        "api_name": "template_nct_7e_1",
        "full_api_name": "template_nct_7e_1",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_7e_1()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_7e_1.py"
    },
    {
        "api_name": "template_nct_2a_2",
        "full_api_name": "template_nct_2a_2",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_2a_2()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_2a_2.py"
    },
    {
        "api_name": "template_nct_9c_2",
        "full_api_name": "template_nct_9c_2",
        "api_description": "Returns:\n    QuantumCircuit: template as a quantum circuit.",
        "api_signature": "template_nct_9c_2()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/templates/nct/template_nct_9c_2.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PiecewiseLinearPauliRotations.__init__",
        "api_description": "Construct piecewise-linearly-controlled Pauli rotations.\n\nArgs:\n    num_state_qubits: The number of qubits representing the state.\n    breakpoints: The breakpoints to define the piecewise-linear function.\n        Defaults to ``[0]``.\n    slopes: The slopes for different segments of the piecewise-linear function.\n        Defaults to ``[1]``.\n    offsets: The offsets for different segments of the piecewise-linear function.\n        Defaults to ``[0]``.\n    basis: The type of Pauli rotation (``'X'``, ``'Y'``, ``'Z'``).\n    name: The name of the circuit.",
        "api_signature": "__init__(self, num_state_qubits, breakpoints, slopes, offsets, basis, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_linear_pauli_rotations.py"
    },
    {
        "api_name": "breakpoints",
        "full_api_name": "PiecewiseLinearPauliRotations.breakpoints",
        "api_description": "The breakpoints of the piecewise linear function.\n\nThe function is linear in the intervals ``[point_i, point_{i+1}]`` where the last\npoint implicitly is ``2**(num_state_qubits + 1)``.",
        "api_signature": "breakpoints(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_linear_pauli_rotations.py"
    },
    {
        "api_name": "breakpoints",
        "full_api_name": "PiecewiseLinearPauliRotations.breakpoints",
        "api_description": "Set the breakpoints.\n\nArgs:\n    breakpoints: The new breakpoints.",
        "api_signature": "breakpoints(self, breakpoints)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_linear_pauli_rotations.py"
    },
    {
        "api_name": "slopes",
        "full_api_name": "PiecewiseLinearPauliRotations.slopes",
        "api_description": "The breakpoints of the piecewise linear function.\n\nThe function is linear in the intervals ``[point_i, point_{i+1}]`` where the last\npoint implicitly is ``2**(num_state_qubits + 1)``.",
        "api_signature": "slopes(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_linear_pauli_rotations.py"
    },
    {
        "api_name": "slopes",
        "full_api_name": "PiecewiseLinearPauliRotations.slopes",
        "api_description": "Set the slopes.\n\nArgs:\n    slopes: The new slopes.",
        "api_signature": "slopes(self, slopes)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_linear_pauli_rotations.py"
    },
    {
        "api_name": "offsets",
        "full_api_name": "PiecewiseLinearPauliRotations.offsets",
        "api_description": "The breakpoints of the piecewise linear function.\n\nThe function is linear in the intervals ``[point_i, point_{i+1}]`` where the last\npoint implicitly is ``2**(num_state_qubits + 1)``.",
        "api_signature": "offsets(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_linear_pauli_rotations.py"
    },
    {
        "api_name": "offsets",
        "full_api_name": "PiecewiseLinearPauliRotations.offsets",
        "api_description": "Set the offsets.\n\nArgs:\n    offsets: The new offsets.",
        "api_signature": "offsets(self, offsets)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_linear_pauli_rotations.py"
    },
    {
        "api_name": "mapped_slopes",
        "full_api_name": "PiecewiseLinearPauliRotations.mapped_slopes",
        "api_description": "The slopes mapped to the internal representation.\n\nReturns:\n    The mapped slopes.",
        "api_signature": "mapped_slopes(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_linear_pauli_rotations.py"
    },
    {
        "api_name": "mapped_offsets",
        "full_api_name": "PiecewiseLinearPauliRotations.mapped_offsets",
        "api_description": "The offsets mapped to the internal representation.\n\nReturns:\n    The mapped offsets.",
        "api_signature": "mapped_offsets(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_linear_pauli_rotations.py"
    },
    {
        "api_name": "contains_zero_breakpoint",
        "full_api_name": "PiecewiseLinearPauliRotations.contains_zero_breakpoint",
        "api_description": "Whether 0 is the first breakpoint.\n\nReturns:\n    True, if 0 is the first breakpoint, otherwise False.",
        "api_signature": "contains_zero_breakpoint(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_linear_pauli_rotations.py"
    },
    {
        "api_name": "evaluate",
        "full_api_name": "PiecewiseLinearPauliRotations.evaluate",
        "api_description": "Classically evaluate the piecewise linear rotation.\n\nArgs:\n    x: Value to be evaluated at.\n\nReturns:\n    Value of piecewise linear function at x.",
        "api_signature": "evaluate(self, x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_linear_pauli_rotations.py"
    },
    {
        "api_name": "_check_configuration",
        "full_api_name": "PiecewiseLinearPauliRotations._check_configuration",
        "api_description": "Check if the current configuration is valid.",
        "api_signature": "_check_configuration(self, raise_on_failure)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_linear_pauli_rotations.py"
    },
    {
        "api_name": "_reset_registers",
        "full_api_name": "PiecewiseLinearPauliRotations._reset_registers",
        "api_description": "Reset the registers.",
        "api_signature": "_reset_registers(self, num_state_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_linear_pauli_rotations.py"
    },
    {
        "api_name": "_build",
        "full_api_name": "PiecewiseLinearPauliRotations._build",
        "api_description": "If not already built, build the circuit.",
        "api_signature": "_build(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_linear_pauli_rotations.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QuadraticForm.__init__",
        "api_description": "Args:\n    num_result_qubits: The number of qubits to encode the result. Called :math:`m` in\n        the class documentation.\n    quadratic: A matrix containing the quadratic coefficients, :math:`A`.\n    linear: An array containing the linear coefficients, :math:`b`.\n    offset: A constant offset, :math:`c`.\n    little_endian: Encode the result in little endianness.\n\nRaises:\n    ValueError: If ``linear`` and ``quadratic`` have mismatching sizes.\n    ValueError: If ``num_result_qubits`` is unspecified but cannot be determined because\n        some values of the quadratic form are parameterized.",
        "api_signature": "__init__(self, num_result_qubits, quadratic, linear, offset, little_endian)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/quadratic_form.py"
    },
    {
        "api_name": "required_result_qubits",
        "full_api_name": "QuadraticForm.required_result_qubits",
        "api_description": "Get the number of required result qubits.\n\nArgs:\n    quadratic: A matrix containing the quadratic coefficients.\n    linear: An array containing the linear coefficients.\n    offset: A constant offset.\n\nReturns:\n    The number of qubits needed to represent the value of the quadratic form\n    in twos complement.",
        "api_signature": "required_result_qubits(quadratic, linear, offset)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/quadratic_form.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "LinearPauliRotations.__init__",
        "api_description": "Create a new linear rotation circuit.\n\nArgs:\n    num_state_qubits: The number of qubits representing the state :math:`|x\\rangle`.\n    slope: The slope of the controlled rotation.\n    offset: The offset of the controlled rotation.\n    basis: The type of Pauli rotation ('X', 'Y', 'Z').\n    name: The name of the circuit object.",
        "api_signature": "__init__(self, num_state_qubits, slope, offset, basis, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/linear_pauli_rotations.py"
    },
    {
        "api_name": "slope",
        "full_api_name": "LinearPauliRotations.slope",
        "api_description": "The multiplicative factor in the rotation angle of the controlled rotations.\n\nThe rotation angles are ``slope * 2^0``, ``slope * 2^1``, ... , ``slope * 2^(n-1)`` where\n``n`` is the number of state qubits.\n\nReturns:\n    The rotation angle common in all controlled rotations.",
        "api_signature": "slope(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/linear_pauli_rotations.py"
    },
    {
        "api_name": "slope",
        "full_api_name": "LinearPauliRotations.slope",
        "api_description": "Set the multiplicative factor of the rotation angles.\n\nArgs:\n    The slope of the rotation angles.",
        "api_signature": "slope(self, slope)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/linear_pauli_rotations.py"
    },
    {
        "api_name": "offset",
        "full_api_name": "LinearPauliRotations.offset",
        "api_description": "The angle of the single qubit offset rotation on the target qubit.\n\nBefore applying the controlled rotations, a single rotation of angle ``offset`` is\napplied to the target qubit.\n\nReturns:\n    The offset angle.",
        "api_signature": "offset(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/linear_pauli_rotations.py"
    },
    {
        "api_name": "offset",
        "full_api_name": "LinearPauliRotations.offset",
        "api_description": "Set the angle for the offset rotation on the target qubit.\n\nArgs:\n    offset: The offset rotation angle.",
        "api_signature": "offset(self, offset)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/linear_pauli_rotations.py"
    },
    {
        "api_name": "_reset_registers",
        "full_api_name": "LinearPauliRotations._reset_registers",
        "api_description": "Set the number of state qubits.\n\nNote that this changes the underlying quantum register, if the number of state qubits\nchanges.\n\nArgs:\n    num_state_qubits: The new number of qubits.",
        "api_signature": "_reset_registers(self, num_state_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/linear_pauli_rotations.py"
    },
    {
        "api_name": "_check_configuration",
        "full_api_name": "LinearPauliRotations._check_configuration",
        "api_description": "Check if the current configuration is valid.",
        "api_signature": "_check_configuration(self, raise_on_failure)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/linear_pauli_rotations.py"
    },
    {
        "api_name": "_build",
        "full_api_name": "LinearPauliRotations._build",
        "api_description": "If not already built, build the circuit.",
        "api_signature": "_build(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/linear_pauli_rotations.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "LinearAmplitudeFunction.__init__",
        "api_description": "Args:\n    num_state_qubits: The number of qubits used to encode the variable :math:`x`.\n    slope: The slope of the linear function. Can be a list of slopes if it is a piecewise\n        linear function.\n    offset: The offset of the linear function. Can be a list of offsets if it is a piecewise\n        linear function.\n    domain: The domain of the function as tuple :math:`(x_\\min{}, x_\\max{})`.\n    image: The image of the function as tuple :math:`(f_\\min{}, f_\\max{})`.\n    rescaling_factor: The rescaling factor to adjust the accuracy in the Taylor\n        approximation.\n    breakpoints: The breakpoints if the function is piecewise linear. If None, the function\n        is not piecewise.\n    name: Name of the circuit.",
        "api_signature": "__init__(self, num_state_qubits, slope, offset, domain, image, rescaling_factor, breakpoints, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/linear_amplitude_function.py"
    },
    {
        "api_name": "post_processing",
        "full_api_name": "LinearAmplitudeFunction.post_processing",
        "api_description": "Map the function value of the approximated :math:`\\hat{f}` to :math:`f`.\n\nArgs:\n    scaled_value: A function value from the Taylor expansion of :math:`\\hat{f}(x)`.\n\nReturns:\n    The ``scaled_value`` mapped back to the domain of :math:`f`, by first inverting\n    the transformation used for the Taylor approximation and then mapping back from\n    :math:`[0, 1]` to the original domain.",
        "api_signature": "post_processing(self, scaled_value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/linear_amplitude_function.py"
    },
    {
        "api_name": "_check_sorted_and_in_range",
        "full_api_name": "_check_sorted_and_in_range",
        "api_description": "",
        "api_signature": "_check_sorted_and_in_range(breakpoints, domain)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/linear_amplitude_function.py"
    },
    {
        "api_name": "_check_sizes_match",
        "full_api_name": "_check_sizes_match",
        "api_description": "",
        "api_signature": "_check_sizes_match(slope, offset, breakpoints)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/linear_amplitude_function.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PiecewisePolynomialPauliRotations.__init__",
        "api_description": "Args:\n    num_state_qubits: The number of qubits representing the state.\n    breakpoints: The breakpoints to define the piecewise-linear function.\n        Defaults to ``[0]``.\n    coeffs: The coefficients of the polynomials for different segments of the\n    piecewise-linear function. ``coeffs[j][i]`` is the coefficient of the i-th power of x\n    for the j-th polynomial.\n        Defaults to linear: ``[[1]]``.\n    basis: The type of Pauli rotation (``'X'``, ``'Y'``, ``'Z'``).\n    name: The name of the circuit.",
        "api_signature": "__init__(self, num_state_qubits, breakpoints, coeffs, basis, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_polynomial_pauli_rotations.py"
    },
    {
        "api_name": "breakpoints",
        "full_api_name": "PiecewisePolynomialPauliRotations.breakpoints",
        "api_description": "The breakpoints of the piecewise polynomial function.\n\nThe function is polynomial in the intervals ``[point_i, point_{i+1}]`` where the last\npoint implicitly is ``2**(num_state_qubits + 1)``.\n\nReturns:\n    The list of breakpoints.",
        "api_signature": "breakpoints(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_polynomial_pauli_rotations.py"
    },
    {
        "api_name": "breakpoints",
        "full_api_name": "PiecewisePolynomialPauliRotations.breakpoints",
        "api_description": "Set the breakpoints.\n\nArgs:\n    breakpoints: The new breakpoints.",
        "api_signature": "breakpoints(self, breakpoints)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_polynomial_pauli_rotations.py"
    },
    {
        "api_name": "coeffs",
        "full_api_name": "PiecewisePolynomialPauliRotations.coeffs",
        "api_description": "The coefficients of the polynomials.\n\nReturns:\n    The polynomial coefficients per interval as nested lists.",
        "api_signature": "coeffs(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_polynomial_pauli_rotations.py"
    },
    {
        "api_name": "coeffs",
        "full_api_name": "PiecewisePolynomialPauliRotations.coeffs",
        "api_description": "Set the polynomials.\n\nArgs:\n    coeffs: The new polynomials.",
        "api_signature": "coeffs(self, coeffs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_polynomial_pauli_rotations.py"
    },
    {
        "api_name": "mapped_coeffs",
        "full_api_name": "PiecewisePolynomialPauliRotations.mapped_coeffs",
        "api_description": "The coefficients mapped to the internal representation, since we only compare\nx>=breakpoint.\n\nReturns:\n    The mapped coefficients.",
        "api_signature": "mapped_coeffs(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_polynomial_pauli_rotations.py"
    },
    {
        "api_name": "contains_zero_breakpoint",
        "full_api_name": "PiecewisePolynomialPauliRotations.contains_zero_breakpoint",
        "api_description": "Whether 0 is the first breakpoint.\n\nReturns:\n    True, if 0 is the first breakpoint, otherwise False.",
        "api_signature": "contains_zero_breakpoint(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_polynomial_pauli_rotations.py"
    },
    {
        "api_name": "evaluate",
        "full_api_name": "PiecewisePolynomialPauliRotations.evaluate",
        "api_description": "Classically evaluate the piecewise polynomial rotation.\n\nArgs:\n    x: Value to be evaluated at.\n\nReturns:\n    Value of piecewise polynomial function at x.",
        "api_signature": "evaluate(self, x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_polynomial_pauli_rotations.py"
    },
    {
        "api_name": "_check_configuration",
        "full_api_name": "PiecewisePolynomialPauliRotations._check_configuration",
        "api_description": "Check if the current configuration is valid.",
        "api_signature": "_check_configuration(self, raise_on_failure)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_polynomial_pauli_rotations.py"
    },
    {
        "api_name": "_reset_registers",
        "full_api_name": "PiecewisePolynomialPauliRotations._reset_registers",
        "api_description": "Reset the registers.",
        "api_signature": "_reset_registers(self, num_state_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_polynomial_pauli_rotations.py"
    },
    {
        "api_name": "_build",
        "full_api_name": "PiecewisePolynomialPauliRotations._build",
        "api_description": "If not already built, build the circuit.",
        "api_signature": "_build(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_polynomial_pauli_rotations.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PiecewiseChebyshev.__init__",
        "api_description": "Args:\n    f_x: the function to be approximated. Constant functions should be specified\n     as f_x = constant.\n    degree: the degree of the polynomials.\n        Defaults to ``1``.\n    breakpoints: the breakpoints to define the piecewise-linear function.\n        Defaults to the full interval.\n    num_state_qubits: number of qubits representing the state.\n    name: The name of the circuit object.",
        "api_signature": "__init__(self, f_x, degree, breakpoints, num_state_qubits, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_chebyshev.py"
    },
    {
        "api_name": "_check_configuration",
        "full_api_name": "PiecewiseChebyshev._check_configuration",
        "api_description": "Check if the current configuration is valid.",
        "api_signature": "_check_configuration(self, raise_on_failure)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_chebyshev.py"
    },
    {
        "api_name": "f_x",
        "full_api_name": "PiecewiseChebyshev.f_x",
        "api_description": "The function to be approximated.\n\nReturns:\n    The function to be approximated.",
        "api_signature": "f_x(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_chebyshev.py"
    },
    {
        "api_name": "f_x",
        "full_api_name": "PiecewiseChebyshev.f_x",
        "api_description": "Set the function to be approximated.\n\nNote that this may change the underlying quantum register, if the number of state qubits\nchanges.\n\nArgs:\n    f_x: The new function to be approximated.",
        "api_signature": "f_x(self, f_x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_chebyshev.py"
    },
    {
        "api_name": "degree",
        "full_api_name": "PiecewiseChebyshev.degree",
        "api_description": "The degree of the polynomials.\n\nReturns:\n    The degree of the polynomials.",
        "api_signature": "degree(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_chebyshev.py"
    },
    {
        "api_name": "degree",
        "full_api_name": "PiecewiseChebyshev.degree",
        "api_description": "Set the error tolerance.\n\nNote that this may change the underlying quantum register, if the number of state qubits\nchanges.\n\nArgs:\n    degree: The new degree.",
        "api_signature": "degree(self, degree)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_chebyshev.py"
    },
    {
        "api_name": "breakpoints",
        "full_api_name": "PiecewiseChebyshev.breakpoints",
        "api_description": "The breakpoints for the piecewise approximation.\n\nReturns:\n    The breakpoints for the piecewise approximation.",
        "api_signature": "breakpoints(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_chebyshev.py"
    },
    {
        "api_name": "breakpoints",
        "full_api_name": "PiecewiseChebyshev.breakpoints",
        "api_description": "Set the breakpoints for the piecewise approximation.\n\nNote that this may change the underlying quantum register, if the number of state qubits\nchanges.\n\nArgs:\n    breakpoints: The new breakpoints for the piecewise approximation.",
        "api_signature": "breakpoints(self, breakpoints)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_chebyshev.py"
    },
    {
        "api_name": "polynomials",
        "full_api_name": "PiecewiseChebyshev.polynomials",
        "api_description": "The polynomials for the piecewise approximation.\n\nReturns:\n    The polynomials for the piecewise approximation.\n\nRaises:\n    TypeError: If the input function is not in the correct format.",
        "api_signature": "polynomials(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_chebyshev.py"
    },
    {
        "api_name": "polynomials",
        "full_api_name": "PiecewiseChebyshev.polynomials",
        "api_description": "Set the polynomials for the piecewise approximation.\n\nNote that this may change the underlying quantum register, if the number of state qubits\nchanges.\n\nArgs:\n    polynomials: The new breakpoints for the piecewise approximation.",
        "api_signature": "polynomials(self, polynomials)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_chebyshev.py"
    },
    {
        "api_name": "num_state_qubits",
        "full_api_name": "PiecewiseChebyshev.num_state_qubits",
        "api_description": "The number of state qubits representing the state :math:`|x\\rangle`.\n\nReturns:\n    The number of state qubits.",
        "api_signature": "num_state_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_chebyshev.py"
    },
    {
        "api_name": "num_state_qubits",
        "full_api_name": "PiecewiseChebyshev.num_state_qubits",
        "api_description": "Set the number of state qubits.\n\nNote that this may change the underlying quantum register, if the number of state qubits\nchanges.\n\nArgs:\n    num_state_qubits: The new number of qubits.",
        "api_signature": "num_state_qubits(self, num_state_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_chebyshev.py"
    },
    {
        "api_name": "_reset_registers",
        "full_api_name": "PiecewiseChebyshev._reset_registers",
        "api_description": "Reset the registers.",
        "api_signature": "_reset_registers(self, num_state_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_chebyshev.py"
    },
    {
        "api_name": "_build",
        "full_api_name": "PiecewiseChebyshev._build",
        "api_description": "Build the circuit if not already build. The operation is considered successful\nwhen q_objective is :math:`|1>`",
        "api_signature": "_build(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/piecewise_chebyshev.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ExactReciprocal.__init__",
        "api_description": "Args:\n    num_state_qubits: The number of qubits representing the value to invert.\n    scaling: Scaling factor :math:`s` of the reciprocal function, i.e. to compute\n        :math:`s / x`.\n    neg_vals: Whether :math:`x` might represent negative values. In this case the first\n        qubit is the sign, with :math:`|1\\rangle` for negative and :math:`|0\\rangle` for\n        positive.  For the negative case it is assumed that the remaining string represents\n        :math:`1 - x`. This is because :math:`e^{-2 \\pi i x} = e^{2 \\pi i (1 - x)}` for\n        :math:`x \\in [0,1)`.\n    name: The name of the object.\n\n.. note::\n\n    It is assumed that the binary string :math:`x` represents a number < 1.",
        "api_signature": "__init__(self, num_state_qubits, scaling, neg_vals, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/exact_reciprocal.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "WeightedAdder.__init__",
        "api_description": "Computes the weighted sum controlled by state qubits.\n\nArgs:\n    num_state_qubits: The number of state qubits.\n    weights: List of weights, one for each state qubit. If none are provided they\n        default to 1 for every qubit.\n    name: The name of the circuit.",
        "api_signature": "__init__(self, num_state_qubits, weights, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/weighted_adder.py"
    },
    {
        "api_name": "num_sum_qubits",
        "full_api_name": "WeightedAdder.num_sum_qubits",
        "api_description": "The number of sum qubits in the circuit.\n\nReturns:\n    The number of qubits needed to represent the weighted sum of the qubits.",
        "api_signature": "num_sum_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/weighted_adder.py"
    },
    {
        "api_name": "weights",
        "full_api_name": "WeightedAdder.weights",
        "api_description": "The weights for the qubit states.\n\nReturns:\n    The weight for the qubit states.",
        "api_signature": "weights(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/weighted_adder.py"
    },
    {
        "api_name": "weights",
        "full_api_name": "WeightedAdder.weights",
        "api_description": "Set the weights for summing the qubit states.\n\nArgs:\n    weights: The new weights.\n\nRaises:\n    ValueError: If not all weights are close to an integer.",
        "api_signature": "weights(self, weights)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/weighted_adder.py"
    },
    {
        "api_name": "num_state_qubits",
        "full_api_name": "WeightedAdder.num_state_qubits",
        "api_description": "The number of qubits to be summed.\n\nReturns:\n    The number of state qubits.",
        "api_signature": "num_state_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/weighted_adder.py"
    },
    {
        "api_name": "num_state_qubits",
        "full_api_name": "WeightedAdder.num_state_qubits",
        "api_description": "Set the number of state qubits.\n\nArgs:\n    num_state_qubits: The new number of state qubits.",
        "api_signature": "num_state_qubits(self, num_state_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/weighted_adder.py"
    },
    {
        "api_name": "_reset_registers",
        "full_api_name": "WeightedAdder._reset_registers",
        "api_description": "Reset the registers.",
        "api_signature": "_reset_registers(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/weighted_adder.py"
    },
    {
        "api_name": "num_carry_qubits",
        "full_api_name": "WeightedAdder.num_carry_qubits",
        "api_description": "The number of carry qubits required to compute the sum.\n\nNote that this is not necessarily equal to the number of ancilla qubits, these can\nbe queried using ``num_ancilla_qubits``.\n\nReturns:\n    The number of carry qubits required to compute the sum.",
        "api_signature": "num_carry_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/weighted_adder.py"
    },
    {
        "api_name": "num_control_qubits",
        "full_api_name": "WeightedAdder.num_control_qubits",
        "api_description": "The number of additional control qubits required.\n\nNote that the total number of ancilla qubits can be obtained by calling the\nmethod ``num_ancilla_qubits``.\n\nReturns:\n    The number of additional control qubits required (0 or 1).",
        "api_signature": "num_control_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/weighted_adder.py"
    },
    {
        "api_name": "_check_configuration",
        "full_api_name": "WeightedAdder._check_configuration",
        "api_description": "Check if the current configuration is valid.",
        "api_signature": "_check_configuration(self, raise_on_failure)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/weighted_adder.py"
    },
    {
        "api_name": "_build",
        "full_api_name": "WeightedAdder._build",
        "api_description": "If not already built, build the circuit.",
        "api_signature": "_build(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/weighted_adder.py"
    },
    {
        "api_name": "_binomial_coefficients",
        "full_api_name": "_binomial_coefficients",
        "api_description": "Return a dictionary of binomial coefficients\n\nBased-on/forked from sympy's binomial_coefficients() function [#]\n\n.. [#] https://github.com/sympy/sympy/blob/sympy-1.5.1/sympy/ntheory/multinomial.py",
        "api_signature": "_binomial_coefficients(n)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/polynomial_pauli_rotations.py"
    },
    {
        "api_name": "_large_coefficients_iter",
        "full_api_name": "_large_coefficients_iter",
        "api_description": "Return an iterator of multinomial coefficients\n\nBased-on/forked from sympy's multinomial_coefficients_iterator() function [#]\n\n.. [#] https://github.com/sympy/sympy/blob/sympy-1.5.1/sympy/ntheory/multinomial.py",
        "api_signature": "_large_coefficients_iter(m, n)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/polynomial_pauli_rotations.py"
    },
    {
        "api_name": "_multinomial_coefficients",
        "full_api_name": "_multinomial_coefficients",
        "api_description": "Return an iterator of multinomial coefficients\n\nBased-on/forked from sympy's multinomial_coefficients() function [#]\n\n.. [#] https://github.com/sympy/sympy/blob/sympy-1.5.1/sympy/ntheory/multinomial.py",
        "api_signature": "_multinomial_coefficients(m, n)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/polynomial_pauli_rotations.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PolynomialPauliRotations.__init__",
        "api_description": "Prepare an approximation to a state with amplitudes specified by a polynomial.\n\nArgs:\n    num_state_qubits: The number of qubits representing the state.\n    coeffs: The coefficients of the polynomial. ``coeffs[i]`` is the coefficient of the\n        i-th power of x. Defaults to linear: [0, 1].\n    basis: The type of Pauli rotation ('X', 'Y', 'Z').\n    name: The name of the circuit.",
        "api_signature": "__init__(self, num_state_qubits, coeffs, basis, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/polynomial_pauli_rotations.py"
    },
    {
        "api_name": "coeffs",
        "full_api_name": "PolynomialPauliRotations.coeffs",
        "api_description": "The coefficients of the polynomial.\n\n``coeffs[i]`` is the coefficient of the i-th power of the function input :math:`x`,\nthat means that the rotation angles are based on the coefficients value,\nfollowing the formula\n\n.. math::\n\n    c_j x^j ,  j=0, ..., d\n\nwhere :math:`d` is the degree of the polynomial :math:`p(x)` and :math:`c` are the coefficients\n``coeffs``.\n\nReturns:\n    The coefficients of the polynomial.",
        "api_signature": "coeffs(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/polynomial_pauli_rotations.py"
    },
    {
        "api_name": "coeffs",
        "full_api_name": "PolynomialPauliRotations.coeffs",
        "api_description": "Set the coefficients of the polynomial.\n\n``coeffs[i]`` is the coefficient of the i-th power of x.\n\nArgs:\n    The coefficients of the polynomial.",
        "api_signature": "coeffs(self, coeffs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/polynomial_pauli_rotations.py"
    },
    {
        "api_name": "degree",
        "full_api_name": "PolynomialPauliRotations.degree",
        "api_description": "Return the degree of the polynomial, equals to the number of coefficients minus 1.\n\nReturns:\n    The degree of the polynomial. If the coefficients have not been set, return 0.",
        "api_signature": "degree(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/polynomial_pauli_rotations.py"
    },
    {
        "api_name": "_reset_registers",
        "full_api_name": "PolynomialPauliRotations._reset_registers",
        "api_description": "Reset the registers.",
        "api_signature": "_reset_registers(self, num_state_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/polynomial_pauli_rotations.py"
    },
    {
        "api_name": "_check_configuration",
        "full_api_name": "PolynomialPauliRotations._check_configuration",
        "api_description": "Check if the current configuration is valid.",
        "api_signature": "_check_configuration(self, raise_on_failure)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/polynomial_pauli_rotations.py"
    },
    {
        "api_name": "_get_rotation_coefficients",
        "full_api_name": "PolynomialPauliRotations._get_rotation_coefficients",
        "api_description": "Compute the coefficient of each monomial.\n\nReturns:\n    A dictionary with pairs ``{control_state: rotation angle}`` where ``control_state``\n    is a tuple of ``0`` or ``1`` bits.",
        "api_signature": "_get_rotation_coefficients(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/polynomial_pauli_rotations.py"
    },
    {
        "api_name": "_build",
        "full_api_name": "PolynomialPauliRotations._build",
        "api_description": "If not already built, build the circuit.",
        "api_signature": "_build(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/polynomial_pauli_rotations.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "IntegerComparator.__init__",
        "api_description": "Create a new fixed value comparator circuit.\n\nArgs:\n    num_state_qubits: Number of state qubits. If this is set it will determine the number\n        of qubits required for the circuit.\n    value: The fixed value to compare with.\n    geq: If True, evaluate a ``>=`` condition, else ``<``.\n    name: Name of the circuit.",
        "api_signature": "__init__(self, num_state_qubits, value, geq, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/integer_comparator.py"
    },
    {
        "api_name": "value",
        "full_api_name": "IntegerComparator.value",
        "api_description": "The value to compare the qubit register to.\n\nReturns:\n    The value against which the value of the qubit register is compared.",
        "api_signature": "value(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/integer_comparator.py"
    },
    {
        "api_name": "value",
        "full_api_name": "IntegerComparator.value",
        "api_description": "",
        "api_signature": "value(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/integer_comparator.py"
    },
    {
        "api_name": "geq",
        "full_api_name": "IntegerComparator.geq",
        "api_description": "Return whether the comparator compares greater or less equal.\n\nReturns:\n    True, if the comparator compares ``>=``, False if ``<``.",
        "api_signature": "geq(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/integer_comparator.py"
    },
    {
        "api_name": "geq",
        "full_api_name": "IntegerComparator.geq",
        "api_description": "Set whether the comparator compares greater or less equal.\n\nArgs:\n    geq: If True, the comparator compares ``>=``, if False ``<``.",
        "api_signature": "geq(self, geq)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/integer_comparator.py"
    },
    {
        "api_name": "num_state_qubits",
        "full_api_name": "IntegerComparator.num_state_qubits",
        "api_description": "The number of qubits encoding the state for the comparison.\n\nReturns:\n    The number of state qubits.",
        "api_signature": "num_state_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/integer_comparator.py"
    },
    {
        "api_name": "num_state_qubits",
        "full_api_name": "IntegerComparator.num_state_qubits",
        "api_description": "Set the number of state qubits.\n\nNote that this will change the quantum registers.\n\nArgs:\n    num_state_qubits: The new number of state qubits.",
        "api_signature": "num_state_qubits(self, num_state_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/integer_comparator.py"
    },
    {
        "api_name": "_get_twos_complement",
        "full_api_name": "IntegerComparator._get_twos_complement",
        "api_description": "Returns the 2's complement of ``self.value`` as array.\n\nReturns:\n     The 2's complement of ``self.value``.",
        "api_signature": "_get_twos_complement(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/integer_comparator.py"
    },
    {
        "api_name": "_check_configuration",
        "full_api_name": "IntegerComparator._check_configuration",
        "api_description": "Check if the current configuration is valid.",
        "api_signature": "_check_configuration(self, raise_on_failure)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/integer_comparator.py"
    },
    {
        "api_name": "_build",
        "full_api_name": "IntegerComparator._build",
        "api_description": "If not already built, build the circuit.",
        "api_signature": "_build(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/integer_comparator.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "FunctionalPauliRotations.__init__",
        "api_description": "Create a new functional Pauli rotation circuit.\n\nArgs:\n    num_state_qubits: The number of qubits representing the state :math:`|x\\rangle`.\n    basis: The kind of Pauli rotation to use. Must be 'X', 'Y' or 'Z'.\n    name: The name of the circuit object.",
        "api_signature": "__init__(self, num_state_qubits, basis, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/functional_pauli_rotations.py"
    },
    {
        "api_name": "basis",
        "full_api_name": "FunctionalPauliRotations.basis",
        "api_description": "The kind of Pauli rotation to be used.\n\nSet the basis to 'X', 'Y' or 'Z' for controlled-X, -Y, or -Z rotations respectively.\n\nReturns:\n    The kind of Pauli rotation used in controlled rotation.",
        "api_signature": "basis(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/functional_pauli_rotations.py"
    },
    {
        "api_name": "basis",
        "full_api_name": "FunctionalPauliRotations.basis",
        "api_description": "Set the kind of Pauli rotation to be used.\n\nArgs:\n    basis: The Pauli rotation to be used.\n\nRaises:\n    ValueError: The provided basis in not X, Y or Z.",
        "api_signature": "basis(self, basis)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/functional_pauli_rotations.py"
    },
    {
        "api_name": "num_state_qubits",
        "full_api_name": "FunctionalPauliRotations.num_state_qubits",
        "api_description": "The number of state qubits representing the state :math:`|x\\rangle`.\n\nReturns:\n    The number of state qubits.",
        "api_signature": "num_state_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/functional_pauli_rotations.py"
    },
    {
        "api_name": "num_state_qubits",
        "full_api_name": "FunctionalPauliRotations.num_state_qubits",
        "api_description": "Set the number of state qubits.\n\nNote that this may change the underlying quantum register, if the number of state qubits\nchanges.\n\nArgs:\n    num_state_qubits: The new number of qubits.",
        "api_signature": "num_state_qubits(self, num_state_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/functional_pauli_rotations.py"
    },
    {
        "api_name": "_reset_registers",
        "full_api_name": "FunctionalPauliRotations._reset_registers",
        "api_description": "Reset the registers according to the new number of state qubits.\n\nArgs:\n    num_state_qubits: The new number of qubits.",
        "api_signature": "_reset_registers(self, num_state_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/functional_pauli_rotations.py"
    },
    {
        "api_name": "num_ancilla_qubits",
        "full_api_name": "FunctionalPauliRotations.num_ancilla_qubits",
        "api_description": "The minimum number of ancilla qubits in the circuit.\n\nReturns:\n    The minimal number of ancillas required.",
        "api_signature": "num_ancilla_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/functional_pauli_rotations.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "RGQFTMultiplier.__init__",
        "api_description": "Args:\n    num_state_qubits: The number of qubits in either input register for\n        state :math:`|a\\rangle` or :math:`|b\\rangle`. The two input\n        registers must have the same number of qubits.\n    num_result_qubits: The number of result qubits to limit the output to.\n        If number of result qubits is :math:`n`, multiplication modulo :math:`2^n` is performed\n        to limit the output to the specified number of qubits. Default\n        value is ``2 * num_state_qubits`` to represent any possible\n        result from the multiplication of the two inputs.\n    name: The name of the circuit object.",
        "api_signature": "__init__(self, num_state_qubits, num_result_qubits, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/multipliers/rg_qft_multiplier.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "HRSCumulativeMultiplier.__init__",
        "api_description": "Args:\n    num_state_qubits: The number of qubits in either input register for\n        state :math:`|a\\rangle` or :math:`|b\\rangle`. The two input\n        registers must have the same number of qubits.\n    num_result_qubits: The number of result qubits to limit the output to.\n        If number of result qubits is :math:`n`, multiplication modulo :math:`2^n` is performed\n        to limit the output to the specified number of qubits. Default\n        value is ``2 * num_state_qubits`` to represent any possible\n        result from the multiplication of the two inputs.\n    adder: Half adder circuit to be used for performing multiplication. The\n        CDKMRippleCarryAdder is used as default if no adder is provided.\n    name: The name of the circuit object.\nRaises:\n    NotImplementedError: If ``num_result_qubits`` is not default and a custom adder is provided.",
        "api_signature": "__init__(self, num_state_qubits, num_result_qubits, adder, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/multipliers/hrs_cumulative_multiplier.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Multiplier.__init__",
        "api_description": "Args:\n    num_state_qubits: The number of qubits in each of the input registers.\n    num_result_qubits: The number of result qubits to limit the output to.\n        Default value is ``2 * num_state_qubits`` to represent any possible\n        result from the multiplication of the two inputs.\n    name: The name of the circuit.\nRaises:\n    ValueError: If ``num_state_qubits`` is smaller than 1.\n    ValueError: If ``num_result_qubits`` is smaller than ``num_state_qubits``.\n    ValueError: If ``num_result_qubits`` is larger than ``2 * num_state_qubits``.",
        "api_signature": "__init__(self, num_state_qubits, num_result_qubits, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/multipliers/multiplier.py"
    },
    {
        "api_name": "num_state_qubits",
        "full_api_name": "Multiplier.num_state_qubits",
        "api_description": "The number of state qubits, i.e. the number of bits in each input register.\n\nReturns:\n    The number of state qubits.",
        "api_signature": "num_state_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/multipliers/multiplier.py"
    },
    {
        "api_name": "num_result_qubits",
        "full_api_name": "Multiplier.num_result_qubits",
        "api_description": "The number of result qubits to limit the output to.\n\nReturns:\n    The number of result qubits.",
        "api_signature": "num_result_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/multipliers/multiplier.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "DraperQFTAdder.__init__",
        "api_description": "Args:\n    num_state_qubits: The number of qubits in either input register for\n        state :math:`|a\\rangle` or :math:`|b\\rangle`. The two input\n        registers must have the same number of qubits.\n    kind: The kind of adder, can be ``'half'`` for a half adder or\n        ``'fixed'`` for a fixed-sized adder. A half adder contains a carry-out to represent\n        the most-significant bit, but the fixed-sized adder doesn't and hence performs\n        addition modulo ``2 ** num_state_qubits``.\n    name: The name of the circuit object.\nRaises:\n    ValueError: If ``num_state_qubits`` is lower than 1.",
        "api_signature": "__init__(self, num_state_qubits, kind, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/adders/draper_qft_adder.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Adder.__init__",
        "api_description": "Args:\n    num_state_qubits: The number of qubits in each of the registers.\n    name: The name of the circuit.",
        "api_signature": "__init__(self, num_state_qubits, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/adders/adder.py"
    },
    {
        "api_name": "num_state_qubits",
        "full_api_name": "Adder.num_state_qubits",
        "api_description": "The number of state qubits, i.e. the number of bits in each input register.\n\nReturns:\n    The number of state qubits.",
        "api_signature": "num_state_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/adders/adder.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "VBERippleCarryAdder.__init__",
        "api_description": "Args:\n    num_state_qubits: The size of the register.\n    kind: The kind of adder, can be ``'full'`` for a full adder, ``'half'`` for a half\n        adder, or ``'fixed'`` for a fixed-sized adder. A full adder includes both carry-in\n        and carry-out, a half only carry-out, and a fixed-sized adder neither carry-in\n        nor carry-out.\n    name: The name of the circuit.\n\nRaises:\n    ValueError: If ``num_state_qubits`` is lower than 1.",
        "api_signature": "__init__(self, num_state_qubits, kind, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/adders/vbe_ripple_carry_adder.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CDKMRippleCarryAdder.__init__",
        "api_description": "Args:\n    num_state_qubits: The number of qubits in either input register for\n        state :math:`|a\\rangle` or :math:`|b\\rangle`. The two input\n        registers must have the same number of qubits.\n    kind: The kind of adder, can be ``'full'`` for a full adder, ``'half'`` for a half\n        adder, or ``'fixed'`` for a fixed-sized adder. A full adder includes both carry-in\n        and carry-out, a half only carry-out, and a fixed-sized adder neither carry-in\n        nor carry-out.\n    name: The name of the circuit object.\nRaises:\n    ValueError: If ``num_state_qubits`` is lower than 1.",
        "api_signature": "__init__(self, num_state_qubits, kind, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/arithmetic/adders/cdkm_ripple_carry_adder.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "UCGate.__init__",
        "api_description": "Args:\n    gate_list: List of two qubit unitaries :math:`[U_0, ..., U_{2^{k-1}}]`, where each\n        single-qubit unitary :math:`U_i` is given as a :math:`2 \\times 2` numpy array.\n    up_to_diagonal: Determines if the gate is implemented up to a diagonal.\n        or if it is decomposed completely (default: False).\n        If the ``UCGate`` :math:`U` is decomposed up to a diagonal :math:`D`, this means\n        that the circuit implements a unitary :math:`U'` such that :math:`D U' = U`.\n\nRaises:\n    QiskitError: in case of bad input to the constructor",
        "api_signature": "__init__(self, gate_list, up_to_diagonal)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/uc.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "UCGate.inverse",
        "api_description": "Return the inverse.\n\nThis does not re-compute the decomposition for the multiplexer with the inverse of the\ngates but simply inverts the existing decomposition.",
        "api_signature": "inverse(self, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/uc.py"
    },
    {
        "api_name": "_get_diagonal",
        "full_api_name": "UCGate._get_diagonal",
        "api_description": "",
        "api_signature": "_get_diagonal(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/uc.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "UCGate._define",
        "api_description": "",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/uc.py"
    },
    {
        "api_name": "_dec_ucg",
        "full_api_name": "UCGate._dec_ucg",
        "api_description": "Call to create a circuit that implements the uniformly controlled gate. If\nup_to_diagonal=True, the circuit implements the gate up to a diagonal gate and\nthe diagonal gate is also returned.",
        "api_signature": "_dec_ucg(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/uc.py"
    },
    {
        "api_name": "_dec_ucg_help",
        "full_api_name": "UCGate._dec_ucg_help",
        "api_description": "This method finds the single qubit gate arising in the decomposition of UCGates given in\nhttps://arxiv.org/pdf/quant-ph/0410066.pdf.",
        "api_signature": "_dec_ucg_help(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/uc.py"
    },
    {
        "api_name": "_rz",
        "full_api_name": "UCGate._rz",
        "api_description": "",
        "api_signature": "_rz(alpha)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/uc.py"
    },
    {
        "api_name": "validate_parameter",
        "full_api_name": "UCGate.validate_parameter",
        "api_description": "Uniformly controlled gate parameter has to be an ndarray.",
        "api_signature": "validate_parameter(self, parameter)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/uc.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Isometry.__init__",
        "api_description": "Args:\n    isometry: An isometry from :math:`m` to :math`n` qubits, i.e., a complex\n        ``np.ndarray`` of dimension :math:`2^n \\times 2^m` with orthonormal columns (given\n        in the computational basis specified by the order of the ancillas\n        and the input qubits, where the ancillas are considered to be more\n        significant than the input qubits).\n    num_ancillas_zero: Number of additional ancillas that start in the state :math:`|0\\rangle`\n        (the :math:`n-m` ancillas required for providing the output of the isometry are\n        not accounted for here).\n    num_ancillas_dirty: Number of additional ancillas that start in an arbitrary state.\n    epsilon: Error tolerance of calculations.",
        "api_signature": "__init__(self, isometry, num_ancillas_zero, num_ancillas_dirty, epsilon)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/isometry.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "Isometry._define",
        "api_description": "",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/isometry.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "Isometry.inverse",
        "api_description": "",
        "api_signature": "inverse(self, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/isometry.py"
    },
    {
        "api_name": "_gates_to_uncompute",
        "full_api_name": "Isometry._gates_to_uncompute",
        "api_description": "Call to create a circuit with gates that take the desired isometry to the first 2^m columns\n of the 2^n*2^n identity matrix (see https://arxiv.org/abs/1501.06911)",
        "api_signature": "_gates_to_uncompute(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/isometry.py"
    },
    {
        "api_name": "_decompose_column",
        "full_api_name": "Isometry._decompose_column",
        "api_description": "Decomposes the column with index column_index.",
        "api_signature": "_decompose_column(self, circuit, q, diag, remaining_isometry, column_index)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/isometry.py"
    },
    {
        "api_name": "_disentangle",
        "full_api_name": "Isometry._disentangle",
        "api_description": "Disentangle the s-th significant qubit (starting with s = 0) into the zero or the one state\n(dependent on column_index)",
        "api_signature": "_disentangle(self, circuit, q, diag, remaining_isometry, column_index, s)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/isometry.py"
    },
    {
        "api_name": "_find_squs_for_disentangling",
        "full_api_name": "Isometry._find_squs_for_disentangling",
        "api_description": "",
        "api_signature": "_find_squs_for_disentangling(self, v, k, s)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/isometry.py"
    },
    {
        "api_name": "_append_ucg_up_to_diagonal",
        "full_api_name": "Isometry._append_ucg_up_to_diagonal",
        "api_description": "",
        "api_signature": "_append_ucg_up_to_diagonal(self, circ, q, single_qubit_gates, control_labels, target_label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/isometry.py"
    },
    {
        "api_name": "_append_mcg_up_to_diagonal",
        "full_api_name": "Isometry._append_mcg_up_to_diagonal",
        "api_description": "",
        "api_signature": "_append_mcg_up_to_diagonal(self, circ, q, gate, control_labels, target_label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/isometry.py"
    },
    {
        "api_name": "_define_qubit_role",
        "full_api_name": "Isometry._define_qubit_role",
        "api_description": "",
        "api_signature": "_define_qubit_role(self, q)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/isometry.py"
    },
    {
        "api_name": "validate_parameter",
        "full_api_name": "Isometry.validate_parameter",
        "api_description": "Isometry parameter has to be an ndarray.",
        "api_signature": "validate_parameter(self, parameter)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/isometry.py"
    },
    {
        "api_name": "inv_gate",
        "full_api_name": "Isometry.inv_gate",
        "api_description": "Return the adjoint of the unitary.",
        "api_signature": "inv_gate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/isometry.py"
    },
    {
        "api_name": "_get_qubits_by_label",
        "full_api_name": "_get_qubits_by_label",
        "api_description": "",
        "api_signature": "_get_qubits_by_label(labels, qubits, num_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/isometry.py"
    },
    {
        "api_name": "_reverse_qubit_oder",
        "full_api_name": "_reverse_qubit_oder",
        "api_description": "",
        "api_signature": "_reverse_qubit_oder(qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/isometry.py"
    },
    {
        "api_name": "_get_binary_rep_as_list",
        "full_api_name": "_get_binary_rep_as_list",
        "api_description": "",
        "api_signature": "_get_binary_rep_as_list(n, num_digits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/isometry.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Diagonal.__init__",
        "api_description": "Args:\n    diag: List of the :math:`2^k` diagonal entries (for a diagonal gate on :math:`k` qubits).\n\nRaises:\n    CircuitError: if the list of the diagonal entries or the qubit list is in bad format;\n        if the number of diagonal entries is not :math:`2^k`, where :math:`k` denotes the\n        number of qubits.",
        "api_signature": "__init__(self, diag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/diagonal.py"
    },
    {
        "api_name": "_check_input",
        "full_api_name": "Diagonal._check_input",
        "api_description": "Check if ``diag`` is in valid format.",
        "api_signature": "_check_input(diag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/diagonal.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "DiagonalGate.__init__",
        "api_description": "Args:\n    diag: list of the :math:`2^k` diagonal entries (for a diagonal gate on :math:`k` qubits).",
        "api_signature": "__init__(self, diag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/diagonal.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "DiagonalGate._define",
        "api_description": "",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/diagonal.py"
    },
    {
        "api_name": "validate_parameter",
        "full_api_name": "DiagonalGate.validate_parameter",
        "api_description": "Diagonal Gate parameter should accept complex\n(in addition to the Gate parameter types) and always return build-in complex.",
        "api_signature": "validate_parameter(self, parameter)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/diagonal.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "DiagonalGate.inverse",
        "api_description": "Return the inverse of the diagonal gate.",
        "api_signature": "inverse(self, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/diagonal.py"
    },
    {
        "api_name": "_extract_rz",
        "full_api_name": "_extract_rz",
        "api_description": "Extract a Rz rotation (angle given by first output) such that exp(j*phase)*Rz(z_angle)\nis equal to the diagonal matrix with entires exp(1j*ph1) and exp(1j*ph2).",
        "api_signature": "_extract_rz(phi1, phi2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/diagonal.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "GR.__init__",
        "api_description": "Create a new Global R (GR) gate.\n\nArgs:\n    num_qubits: number of qubits.\n    theta: rotation angle about axis determined by phi\n    phi: angle of rotation axis in xy-plane",
        "api_signature": "__init__(self, num_qubits, theta, phi)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/gr.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "GRX.__init__",
        "api_description": "Create a new Global RX (GRX) gate.\n\nArgs:\n    num_qubits: number of qubits.\n    theta: rotation angle about x-axis",
        "api_signature": "__init__(self, num_qubits, theta)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/gr.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "GRY.__init__",
        "api_description": "Create a new Global RY (GRY) gate.\n\nArgs:\n    num_qubits: number of qubits.\n    theta: rotation angle about y-axis",
        "api_signature": "__init__(self, num_qubits, theta)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/gr.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "GRZ.__init__",
        "api_description": "Create a new Global RZ (GRZ) gate.\n\nArgs:\n    num_qubits: number of qubits.\n    phi: rotation angle about z-axis",
        "api_signature": "__init__(self, num_qubits, phi)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/gr.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "LinearFunction.__init__",
        "api_description": "Create a new linear function.\n\nArgs:\n    linear: data from which a linear function can be constructed. It can be either a\n        nxn matrix (describing the linear transformation), a permutation (which is a\n        special case of a linear function), another linear function, a clifford (when\n        it corresponds to a linear function), or a quantum circuit composed of\n        linear gates (CX and SWAP) and other objects described above, including\n        nested subcircuits.\n\n    validate_input: if True, performs more expensive input validation checks,\n        such as checking that a given n x n matrix is invertible.\n\nRaises:\n    CircuitError: if the input is invalid:\n        either the input matrix is not square or not invertible,\n        or the input quantum circuit contains non-linear objects\n        (for example, a Hadamard gate, or a Clifford that does\n        not correspond to a linear function).",
        "api_signature": "__init__(self, linear, validate_input)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/linear_function.py"
    },
    {
        "api_name": "_circuit_to_mat",
        "full_api_name": "LinearFunction._circuit_to_mat",
        "api_description": "This creates a nxn matrix corresponding to the given quantum circuit.",
        "api_signature": "_circuit_to_mat(qc)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/linear_function.py"
    },
    {
        "api_name": "_clifford_to_mat",
        "full_api_name": "LinearFunction._clifford_to_mat",
        "api_description": "This creates a nxn matrix corresponding to the given Clifford, when Clifford\ncan be converted to a linear function. This is possible when the clifford has\ntableau of the form [[A, B], [C, D]], with B = C = 0 and D = A^{-1}^t, and zero\nphase vector. In this case, the required matrix is A^t.\nRaises an error otherwise.",
        "api_signature": "_clifford_to_mat(cliff)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/linear_function.py"
    },
    {
        "api_name": "_permutation_to_mat",
        "full_api_name": "LinearFunction._permutation_to_mat",
        "api_description": "This creates a nxn matrix from a given permutation gate.",
        "api_signature": "_permutation_to_mat(perm)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/linear_function.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "LinearFunction.__eq__",
        "api_description": "Check if two linear functions represent the same matrix.",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/linear_function.py"
    },
    {
        "api_name": "validate_parameter",
        "full_api_name": "LinearFunction.validate_parameter",
        "api_description": "Parameter validation",
        "api_signature": "validate_parameter(self, parameter)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/linear_function.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "LinearFunction._define",
        "api_description": "Populates self.definition with a decomposition of this gate.",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/linear_function.py"
    },
    {
        "api_name": "synthesize",
        "full_api_name": "LinearFunction.synthesize",
        "api_description": "Synthesizes the linear function into a quantum circuit.\n\nReturns:\n    QuantumCircuit: A circuit implementing the evolution.",
        "api_signature": "synthesize(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/linear_function.py"
    },
    {
        "api_name": "linear",
        "full_api_name": "LinearFunction.linear",
        "api_description": "Returns the n x n matrix representing this linear function.",
        "api_signature": "linear(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/linear_function.py"
    },
    {
        "api_name": "original_circuit",
        "full_api_name": "LinearFunction.original_circuit",
        "api_description": "Returns the original circuit used to construct this linear function\n(including None, when the linear function is not constructed from a circuit).",
        "api_signature": "original_circuit(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/linear_function.py"
    },
    {
        "api_name": "is_permutation",
        "full_api_name": "LinearFunction.is_permutation",
        "api_description": "Returns whether this linear function is a permutation,\nthat is whether every row and every column of the n x n matrix\nhas exactly one 1.",
        "api_signature": "is_permutation(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/linear_function.py"
    },
    {
        "api_name": "permutation_pattern",
        "full_api_name": "LinearFunction.permutation_pattern",
        "api_description": "This method first checks if a linear function is a permutation and raises a\n`qiskit.circuit.exceptions.CircuitError` if not. In the case that this linear function\nis a permutation, returns the permutation pattern.",
        "api_signature": "permutation_pattern(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/linear_function.py"
    },
    {
        "api_name": "extend_with_identity",
        "full_api_name": "LinearFunction.extend_with_identity",
        "api_description": "Extend linear function to a linear function over nq qubits,\nwith identities on other subsystems.\n\nArgs:\n    num_qubits: number of qubits of the extended function.\n\n    positions: describes the positions of original qubits in the extended\n        function's qubits.\n\nReturns:\n    LinearFunction: extended linear function.",
        "api_signature": "extend_with_identity(self, num_qubits, positions)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/linear_function.py"
    },
    {
        "api_name": "mat_str",
        "full_api_name": "LinearFunction.mat_str",
        "api_description": "Return string representation of the linear function\nviewed as a matrix with 0/1 entries.",
        "api_signature": "mat_str(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/linear_function.py"
    },
    {
        "api_name": "function_str",
        "full_api_name": "LinearFunction.function_str",
        "api_description": "Return string representation of the linear function\nviewed as a linear transformation.",
        "api_signature": "function_str(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/linear_function.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Permutation.__init__",
        "api_description": "Return an n_qubit permutation circuit implemented using SWAPs.\n\nArgs:\n    num_qubits: circuit width.\n    pattern: permutation pattern, describing which qubits occupy the\n        positions 0, 1, 2, etc. after applying the permutation, that\n        is ``pattern[k] = m`` when the permutation maps qubit ``m``\n        to position ``k``. As an example, the pattern ``[2, 4, 3, 0, 1]``\n        means that qubit ``2`` goes to position ``0``, qubit ``4``\n        goes to the position ``1``, etc. The pattern can also be ``None``,\n        in which case a random permutation over ``num_qubits`` is\n        created.\n    seed: random seed in case a random permutation is requested.\n\nRaises:\n    CircuitError: if permutation pattern is malformed.\n\nReference Circuit:\n    .. plot::\n\n       from qiskit.circuit.library import Permutation\n       A = [2,4,3,0,1]\n       circuit = Permutation(5, A)\n       circuit.draw('mpl')\n\nExpanded Circuit:\n    .. plot::\n\n       from qiskit.circuit.library import Permutation\n       from qiskit.visualization.library import _generate_circuit_library_visualization\n       A = [2,4,3,0,1]\n       circuit = Permutation(5, A)\n       _generate_circuit_library_visualization(circuit.decompose())",
        "api_signature": "__init__(self, num_qubits, pattern, seed)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/permutation.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PermutationGate.__init__",
        "api_description": "Return a permutation gate.\n\nArgs:\n    pattern: permutation pattern, describing which qubits occupy the\n        positions 0, 1, 2, etc. after applying the permutation, that\n        is ``pattern[k] = m`` when the permutation maps qubit ``m``\n        to position ``k``. As an example, the pattern ``[2, 4, 3, 0, 1]``\n        means that qubit ``2`` goes to position ``0``, qubit ``4``\n        goes to the position ``1``, etc.\n\nRaises:\n    CircuitError: if permutation pattern is malformed.\n\nReference Circuit:\n    .. plot::\n\n        from qiskit.circuit.quantumcircuit import QuantumCircuit\n        from qiskit.circuit.library import PermutationGate\n        A = [2,4,3,0,1]\n        permutation = PermutationGate(A)\n        circuit = QuantumCircuit(5)\n        circuit.append(permutation, [0, 1, 2, 3, 4])\n        circuit.draw('mpl')\n\nExpanded Circuit:\n    .. plot::\n\n        from qiskit.circuit.quantumcircuit import QuantumCircuit\n        from qiskit.circuit.library import PermutationGate\n        from qiskit.visualization.library import _generate_circuit_library_visualization\n        A = [2,4,3,0,1]\n        permutation = PermutationGate(A)\n        circuit = QuantumCircuit(5)\n        circuit.append(permutation, [0, 1, 2, 3, 4])\n\n        _generate_circuit_library_visualization(circuit.decompose())",
        "api_signature": "__init__(self, pattern)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/permutation.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "PermutationGate.__array__",
        "api_description": "Return a numpy.array for the Permutation gate.",
        "api_signature": "__array__(self, dtype, copy)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/permutation.py"
    },
    {
        "api_name": "validate_parameter",
        "full_api_name": "PermutationGate.validate_parameter",
        "api_description": "Parameter validation.",
        "api_signature": "validate_parameter(self, parameter)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/permutation.py"
    },
    {
        "api_name": "pattern",
        "full_api_name": "PermutationGate.pattern",
        "api_description": "Returns the permutation pattern defining this permutation.",
        "api_signature": "pattern(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/permutation.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "PermutationGate.inverse",
        "api_description": "Returns the inverse of the permutation.",
        "api_signature": "inverse(self, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/permutation.py"
    },
    {
        "api_name": "_qasm2_decomposition",
        "full_api_name": "PermutationGate._qasm2_decomposition",
        "api_description": "",
        "api_signature": "_qasm2_decomposition(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/permutation.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "UCRYGate.__init__",
        "api_description": "Args:\n    angle_list: List of rotation angles :math:`[a_0, ..., a_{2^{k-1}}]`.",
        "api_signature": "__init__(self, angle_list)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/ucry.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "UCRXGate.__init__",
        "api_description": "Args:\n    angle_list: List of rotation angles :math:`[a_0, ..., a_{2^{k-1}}]`.",
        "api_signature": "__init__(self, angle_list)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/ucrx.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "GMS.__init__",
        "api_description": "Create a new Global M\u00f8lmer\u2013S\u00f8rensen (GMS) gate.\n\nArgs:\n    num_qubits: width of gate.\n    theta: a num_qubits x num_qubits symmetric matrix of\n        interaction angles for each qubit pair. The upper\n        triangle is considered.",
        "api_signature": "__init__(self, num_qubits, theta)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/gms.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "MSGate.__init__",
        "api_description": "Create new MS gate.",
        "api_signature": "__init__(self, num_qubits, theta, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/gms.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "MSGate._define",
        "api_description": "",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/gms.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "UnitaryGate.__init__",
        "api_description": "Create a gate from a numeric unitary matrix.\n\nArgs:\n    data: Unitary operator.\n    label: Unitary name for backend [Default: ``None``].\n    check_input: If set to ``False`` this asserts the input\n        is known to be unitary and the checking to validate this will\n        be skipped. This should only ever be used if you know the\n        input is unitary, setting this to ``False`` and passing in\n        a non-unitary matrix will result unexpected behavior and errors.\n    num_qubits: If given, the number of qubits in the matrix.  If not given, it is inferred.\n\nRaises:\n    ValueError: If input data is not an N-qubit unitary operator.",
        "api_signature": "__init__(self, data, label, check_input)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/unitary.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "UnitaryGate.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/unitary.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "UnitaryGate.__array__",
        "api_description": "Return matrix for the unitary.",
        "api_signature": "__array__(self, dtype, copy)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/unitary.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "UnitaryGate.inverse",
        "api_description": "Return the adjoint of the unitary.",
        "api_signature": "inverse(self, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/unitary.py"
    },
    {
        "api_name": "conjugate",
        "full_api_name": "UnitaryGate.conjugate",
        "api_description": "Return the conjugate of the unitary.",
        "api_signature": "conjugate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/unitary.py"
    },
    {
        "api_name": "adjoint",
        "full_api_name": "UnitaryGate.adjoint",
        "api_description": "Return the adjoint of the unitary.",
        "api_signature": "adjoint(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/unitary.py"
    },
    {
        "api_name": "transpose",
        "full_api_name": "UnitaryGate.transpose",
        "api_description": "Return the transpose of the unitary.",
        "api_signature": "transpose(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/unitary.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "UnitaryGate._define",
        "api_description": "Calculate a subcircuit that implements this unitary.",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/unitary.py"
    },
    {
        "api_name": "control",
        "full_api_name": "UnitaryGate.control",
        "api_description": "Return controlled version of gate.\n\nArgs:\n    num_ctrl_qubits: Number of controls to add to gate (default is 1).\n    label: Optional gate label.\n    ctrl_state: The control state in decimal or as a bit string (e.g. ``\"1011\"``).\n        If ``None``, use ``2**num_ctrl_qubits - 1``.\n    annotated: indicates whether the controlled gate should be implemented\n        as an annotated gate. If ``None``, this is handled as ``False``.\n\nReturns:\n    Controlled version of gate.",
        "api_signature": "control(self, num_ctrl_qubits, label, ctrl_state, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/unitary.py"
    },
    {
        "api_name": "_qasm2_decomposition",
        "full_api_name": "UnitaryGate._qasm2_decomposition",
        "api_description": "Return an unparameterized version of ourselves, so the OQ2 exporter doesn't choke on the\nnon-standard things in our `params` field.",
        "api_signature": "_qasm2_decomposition(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/unitary.py"
    },
    {
        "api_name": "validate_parameter",
        "full_api_name": "UnitaryGate.validate_parameter",
        "api_description": "Unitary gate parameter has to be an ndarray.",
        "api_signature": "validate_parameter(self, parameter)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/unitary.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "UCPauliRotGate.__init__",
        "api_description": "Args:\n    angle_list: List of rotation angles :math:`[a_0, ..., a_{2^{k-1}}]`.\n    rot_axis: Rotation axis. Must be either of ``\"X\"``, ``\"Y\"`` or ``\"Z\"``.",
        "api_signature": "__init__(self, angle_list, rot_axis)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/uc_pauli_rot.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "UCPauliRotGate._define",
        "api_description": "",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/uc_pauli_rot.py"
    },
    {
        "api_name": "_dec_ucrot",
        "full_api_name": "UCPauliRotGate._dec_ucrot",
        "api_description": "Finds a decomposition of a UC rotation gate into elementary gates\n(C-NOTs and single-qubit rotations).",
        "api_signature": "_dec_ucrot(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/uc_pauli_rot.py"
    },
    {
        "api_name": "_dec_uc_rotations",
        "full_api_name": "UCPauliRotGate._dec_uc_rotations",
        "api_description": "Calculates rotation angles for a uniformly controlled R_t gate with a C-NOT gate at\nthe end of the circuit. The rotation angles of the gate R_t are stored in\nangles[start_index:end_index]. If reversed_dec == True, it decomposes the gate such that\nthere is a C-NOT gate at the start of the circuit (in fact, the circuit topology for\nthe reversed decomposition is the reversed one of the original decomposition)",
        "api_signature": "_dec_uc_rotations(angles, start_index, end_index, reversed_dec)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/uc_pauli_rot.py"
    },
    {
        "api_name": "_update_angles",
        "full_api_name": "UCPauliRotGate._update_angles",
        "api_description": "Calculate the new rotation angles according to Shende's decomposition.",
        "api_signature": "_update_angles(angle1, angle2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/uc_pauli_rot.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "UCRZGate.__init__",
        "api_description": "Args:\n    angle_list: List of rotation angles :math:`[a_0, ..., a_{2^{k-1}}]`.",
        "api_signature": "__init__(self, angle_list)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/ucrz.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "MCGupDiag.__init__",
        "api_description": "Args:\n    gate: :math:`2 \\times 2` unitary given as a (complex) ``ndarray``.\n    num_controls: Number of control qubits.\n    num_ancillas_zero: Number of ancilla qubits that start in the state zero.\n    num_ancillas_dirty: Number of ancilla qubits that are allowed to start in an\n        arbitrary state.\n\nRaises:\n    QiskitError: if the input format is wrong; if the array gate is not unitary",
        "api_signature": "__init__(self, gate, num_controls, num_ancillas_zero, num_ancillas_dirty)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/mcg_up_to_diagonal.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "MCGupDiag._define",
        "api_description": "",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/mcg_up_to_diagonal.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "MCGupDiag.inverse",
        "api_description": "Return the inverse.\n\nNote that the resulting Gate object has an empty ``params`` property.",
        "api_signature": "inverse(self, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/mcg_up_to_diagonal.py"
    },
    {
        "api_name": "_get_diagonal",
        "full_api_name": "MCGupDiag._get_diagonal",
        "api_description": "",
        "api_signature": "_get_diagonal(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/mcg_up_to_diagonal.py"
    },
    {
        "api_name": "_dec_mcg_up_diag",
        "full_api_name": "MCGupDiag._dec_mcg_up_diag",
        "api_description": "Call to create a circuit with gates that implement the MCG up to a diagonal gate.\nRemark: The qubits the gate acts on are ordered in the following way:\n    q=[q_target,q_controls,q_ancilla_zero,q_ancilla_dirty]",
        "api_signature": "_dec_mcg_up_diag(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/mcg_up_to_diagonal.py"
    },
    {
        "api_name": "_define_qubit_role",
        "full_api_name": "MCGupDiag._define_qubit_role",
        "api_description": "",
        "api_signature": "_define_qubit_role(self, q)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/mcg_up_to_diagonal.py"
    },
    {
        "api_name": "validate_parameter",
        "full_api_name": "MCGupDiag.validate_parameter",
        "api_description": "Multi controlled single-qubit unitary gate parameter has to be an ndarray.",
        "api_signature": "validate_parameter(self, parameter)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/mcg_up_to_diagonal.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "RVGate.__init__",
        "api_description": "Create new rv single-qubit gate.\n\nArgs:\n    v_x (float): x-component\n    v_y (float): y-component\n    v_z (float): z-component\n    basis (str, optional): basis (see\n        :class:`~qiskit.synthesis.one_qubit.one_qubit_decompose.OneQubitEulerDecomposer`)",
        "api_signature": "__init__(self, v_x, v_y, v_z, basis)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/rv.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "RVGate._define",
        "api_description": "",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/rv.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "RVGate.inverse",
        "api_description": "Invert this gate.",
        "api_signature": "inverse(self, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/rv.py"
    },
    {
        "api_name": "to_matrix",
        "full_api_name": "RVGate.to_matrix",
        "api_description": "Return a numpy.array for the R(v) gate.",
        "api_signature": "to_matrix(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/rv.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "MCMT.__init__",
        "api_description": "Create a new multi-control multi-target gate.\n\nArgs:\n    gate: The gate to be applied controlled on the control qubits and applied to the target\n        qubits. Can be either a Gate or a circuit method.\n        If it is a callable, it will be casted to a Gate.\n    num_ctrl_qubits: The number of control qubits.\n    num_target_qubits: The number of target qubits.\n\nRaises:\n    AttributeError: If the gate cannot be casted to a controlled gate.\n    AttributeError: If the number of controls or targets is 0.",
        "api_signature": "__init__(self, gate, num_ctrl_qubits, num_target_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/mcmt.py"
    },
    {
        "api_name": "_build",
        "full_api_name": "MCMT._build",
        "api_description": "Define the MCMT gate without ancillas.",
        "api_signature": "_build(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/mcmt.py"
    },
    {
        "api_name": "num_ancilla_qubits",
        "full_api_name": "MCMT.num_ancilla_qubits",
        "api_description": "Return the number of ancillas.",
        "api_signature": "num_ancilla_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/mcmt.py"
    },
    {
        "api_name": "_identify_gate",
        "full_api_name": "MCMT._identify_gate",
        "api_description": "Case the gate input to a gate.",
        "api_signature": "_identify_gate(self, gate)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/mcmt.py"
    },
    {
        "api_name": "control",
        "full_api_name": "MCMT.control",
        "api_description": "Return the controlled version of the MCMT circuit.",
        "api_signature": "control(self, num_ctrl_qubits, label, ctrl_state, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/mcmt.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "MCMT.inverse",
        "api_description": "Return the inverse MCMT circuit, which is itself.",
        "api_signature": "inverse(self, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/mcmt.py"
    },
    {
        "api_name": "_build",
        "full_api_name": "MCMTVChain._build",
        "api_description": "Define the MCMT gate.",
        "api_signature": "_build(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/mcmt.py"
    },
    {
        "api_name": "num_ancilla_qubits",
        "full_api_name": "MCMTVChain.num_ancilla_qubits",
        "api_description": "Return the number of ancilla qubits required.",
        "api_signature": "num_ancilla_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/mcmt.py"
    },
    {
        "api_name": "_ccx_v_chain_rule",
        "full_api_name": "MCMTVChain._ccx_v_chain_rule",
        "api_description": "Get the rule for the CCX V-chain.\n\nThe CCX V-chain progressively computes the CCX of the control qubits and puts the final\nresult in the last ancillary qubit.\n\nArgs:\n    control_qubits: The control qubits.\n    ancilla_qubits: The ancilla qubits.\n    reverse: If True, compute the chain down to the qubit. If False, compute upwards.\n\nReturns:\n    The rule for the (reversed) CCX V-chain.\n\nRaises:\n    QiskitError: If an insufficient number of ancilla qubits was provided.",
        "api_signature": "_ccx_v_chain_rule(self, control_qubits, ancilla_qubits, reverse)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/mcmt.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "MCMTVChain.inverse",
        "api_description": "",
        "api_signature": "inverse(self, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/mcmt.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PauliGate.__init__",
        "api_description": "",
        "api_signature": "__init__(self, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/pauli.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "PauliGate._define",
        "api_description": "gate pauli (p1 a1,...,pn an) { p1 a1; ... ; pn an; }",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/pauli.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "PauliGate.inverse",
        "api_description": "Return inverted pauli gate (itself).",
        "api_signature": "inverse(self, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/pauli.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "PauliGate.__array__",
        "api_description": "Return a Numpy.array for the pauli gate.\ni.e. tensor product of the paulis",
        "api_signature": "__array__(self, dtype, copy)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/pauli.py"
    },
    {
        "api_name": "validate_parameter",
        "full_api_name": "PauliGate.validate_parameter",
        "api_description": "",
        "api_signature": "validate_parameter(self, parameter)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/generalized_gates/pauli.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "HGate.__init__",
        "api_description": "Create new H gate.",
        "api_signature": "__init__(self, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/h.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "HGate._define",
        "api_description": "gate h a { u2(0,pi) a; }",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/h.py"
    },
    {
        "api_name": "control",
        "full_api_name": "HGate.control",
        "api_description": "Return a (multi-)controlled-H gate.\n\nOne control qubit returns a CH gate.\n\nArgs:\n    num_ctrl_qubits: number of control qubits.\n    label: An optional label for the gate [Default: ``None``]\n    ctrl_state: control state expressed as integer,\n        string (e.g.``'110'``), or ``None``. If ``None``, use all 1s.\n    annotated: indicates whether the controlled gate should be implemented\n        as an annotated gate. If ``None``, this is handled as ``False``.\n\nReturns:\n    ControlledGate: controlled version of this gate.",
        "api_signature": "control(self, num_ctrl_qubits, label, ctrl_state, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/h.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "HGate.inverse",
        "api_description": "Return inverted H gate (itself).\n\nArgs:\n    annotated: when set to ``True``, this is typically used to return an\n        :class:`.AnnotatedOperation` with an inverse modifier set instead of a concrete\n        :class:`.Gate`. However, for this class this argument is ignored as this gate\n        is self-inverse.\n\nReturns:\n    HGate: inverse gate (self-inverse).",
        "api_signature": "inverse(self, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/h.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "HGate.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/h.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CHGate.__init__",
        "api_description": "Create new CH gate.",
        "api_signature": "__init__(self, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/h.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "CHGate._define",
        "api_description": "gate ch a,b {\n    s b;\n    h b;\n    t b;\n    cx a, b;\n    tdg b;\n    h b;\n    sdg b;\n}",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/h.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "CHGate.inverse",
        "api_description": "Return inverted CH gate (itself).",
        "api_signature": "inverse(self, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/h.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "CHGate.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/h.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "UGate.__init__",
        "api_description": "Create new U gate.",
        "api_signature": "__init__(self, theta, phi, lam, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "UGate.inverse",
        "api_description": "Return inverted U gate.\n\n:math:`U(\\theta,\\phi,\\lambda)^{\\dagger} =U(-\\theta,-\\lambda,-\\phi))`\n\nArgs:\n    annotated: when set to ``True``, this is typically used to return an\n        :class:`.AnnotatedOperation` with an inverse modifier set instead of a concrete\n        :class:`.Gate`. However, for this class this argument is ignored as the\n        inverse of this gate is always a :class:`.UGate` with inverse parameter values.\n\nReturns:\n    UGate: inverse gate.",
        "api_signature": "inverse(self, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u.py"
    },
    {
        "api_name": "control",
        "full_api_name": "UGate.control",
        "api_description": "Return a (multi-)controlled-U gate.\n\nArgs:\n    num_ctrl_qubits: number of control qubits.\n    label: An optional label for the gate [Default: ``None``]\n    ctrl_state: control state expressed as integer,\n        string (e.g.``'110'``), or ``None``. If ``None``, use all 1s.\n    annotated: indicates whether the controlled gate should be implemented\n        as an annotated gate. If ``None``, this is set to ``True`` if\n        the gate contains free parameters and more than one control qubit, in which\n        case it cannot yet be synthesized. Otherwise it is set to ``False``.\n\nReturns:\n    ControlledGate: controlled version of this gate.",
        "api_signature": "control(self, num_ctrl_qubits, label, ctrl_state, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "UGate.__array__",
        "api_description": "Return a numpy.array for the U gate.",
        "api_signature": "__array__(self, dtype, copy)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "UGate.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "_CUGateParams.__init__",
        "api_description": "",
        "api_signature": "__init__(self, gate)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u.py"
    },
    {
        "api_name": "__setitem__",
        "full_api_name": "_CUGateParams.__setitem__",
        "api_description": "",
        "api_signature": "__setitem__(self, key, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CUGate.__init__",
        "api_description": "Create new CU gate.",
        "api_signature": "__init__(self, theta, phi, lam, gamma, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "CUGate._define",
        "api_description": "gate cu(theta,phi,lambda,gamma) c, t\n{ phase(gamma) c;\n  phase((lambda+phi)/2) c;\n  phase((lambda-phi)/2) t;\n  cx c,t;\n  u(-theta/2,0,-(phi+lambda)/2) t;\n  cx c,t;\n  u(theta/2,phi,0) t;\n}",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "CUGate.inverse",
        "api_description": "Return inverted CU gate.\n\n:math:`CU(\\theta,\\phi,\\lambda,\\gamma)^{\\dagger} = CU(-\\theta,-\\phi,-\\lambda,-\\gamma))`\n\nArgs:\n    annotated: when set to ``True``, this is typically used to return an\n        :class:`.AnnotatedOperation` with an inverse modifier set instead of a concrete\n        :class:`.Gate`. However, for this class this argument is ignored as the inverse\n        of this gate is always a :class:`.CUGate` with inverse parameter\n        values.\n\nReturns:\n    CUGate: inverse gate.",
        "api_signature": "inverse(self, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "CUGate.__array__",
        "api_description": "Return a numpy.array for the CU gate.",
        "api_signature": "__array__(self, dtype, copy)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u.py"
    },
    {
        "api_name": "params",
        "full_api_name": "CUGate.params",
        "api_description": "",
        "api_signature": "params(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u.py"
    },
    {
        "api_name": "params",
        "full_api_name": "CUGate.params",
        "api_description": "",
        "api_signature": "params(self, parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u.py"
    },
    {
        "api_name": "__deepcopy__",
        "full_api_name": "CUGate.__deepcopy__",
        "api_description": "",
        "api_signature": "__deepcopy__(self, memo)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ZGate.__init__",
        "api_description": "Create new Z gate.",
        "api_signature": "__init__(self, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/z.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "ZGate._define",
        "api_description": "",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/z.py"
    },
    {
        "api_name": "control",
        "full_api_name": "ZGate.control",
        "api_description": "Return a (multi-)controlled-Z gate.\n\nOne control returns a CZ gate.\n\nArgs:\n    num_ctrl_qubits: number of control qubits.\n    label: An optional label for the gate [Default: ``None``]\n    ctrl_state: control state expressed as integer,\n        string (e.g.``'110'``), or ``None``. If ``None``, use all 1s.\n    annotated: indicates whether the controlled gate should be implemented\n        as an annotated gate.\n\nReturns:\n    ControlledGate: controlled version of this gate.",
        "api_signature": "control(self, num_ctrl_qubits, label, ctrl_state, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/z.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "ZGate.inverse",
        "api_description": "Return inverted Z gate (itself).\n\nArgs:\n    annotated: when set to ``True``, this is typically used to return an\n        :class:`.AnnotatedOperation` with an inverse modifier set instead of a concrete\n        :class:`.Gate`. However, for this class this argument is ignored as this gate\n        is self-inverse.\n\nReturns:\n    ZGate: inverse gate (self-inverse).",
        "api_signature": "inverse(self, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/z.py"
    },
    {
        "api_name": "power",
        "full_api_name": "ZGate.power",
        "api_description": "",
        "api_signature": "power(self, exponent, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/z.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "ZGate.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/z.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CZGate.__init__",
        "api_description": "Create new CZ gate.",
        "api_signature": "__init__(self, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/z.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "CZGate._define",
        "api_description": "gate cz a,b { h b; cx a,b; h b; }",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/z.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "CZGate.inverse",
        "api_description": "Return inverted CZ gate (itself).\n\nArgs:\n    annotated: when set to ``True``, this is typically used to return an\n        :class:`.AnnotatedOperation` with an inverse modifier set instead of a concrete\n        :class:`.Gate`. However, for this class this argument is ignored as this gate\n        is self-inverse.\n\nReturns:\n    CZGate: inverse gate (self-inverse).",
        "api_signature": "inverse(self, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/z.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "CZGate.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/z.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CCZGate.__init__",
        "api_description": "Create new CCZ gate.",
        "api_signature": "__init__(self, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/z.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "CCZGate._define",
        "api_description": "gate ccz a,b,c { h c; ccx a,b,c; h c; }",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/z.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "CCZGate.inverse",
        "api_description": "Return inverted CCZ gate (itself).\n\nArgs:\n    annotated: when set to ``True``, this is typically used to return an\n        :class:`.AnnotatedOperation` with an inverse modifier set instead of a concrete\n        :class:`.Gate`. However, for this class this argument is ignored as this gate\n        is self-inverse.\n\nReturns:\n    CCZGate: inverse gate (self-inverse).",
        "api_signature": "inverse(self, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/z.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "CCZGate.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/z.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "RZGate.__init__",
        "api_description": "Create new RZ gate.",
        "api_signature": "__init__(self, phi, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rz.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "RZGate._define",
        "api_description": "gate rz(phi) a { u1(phi) a; }",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rz.py"
    },
    {
        "api_name": "control",
        "full_api_name": "RZGate.control",
        "api_description": "Return a (multi-)controlled-RZ gate.\n\nArgs:\n    num_ctrl_qubits: number of control qubits.\n    label: An optional label for the gate [Default: ``None``]\n    ctrl_state: control state expressed as integer,\n        string (e.g.``'110'``), or ``None``. If ``None``, use all 1s.\n    annotated: indicates whether the controlled gate should be implemented\n        as an annotated gate. If ``None``, this is set to ``True`` if\n        the gate contains free parameters and more than one control qubit, in which\n        case it cannot yet be synthesized. Otherwise it is set to ``False``.\n\nReturns:\n    ControlledGate: controlled version of this gate.",
        "api_signature": "control(self, num_ctrl_qubits, label, ctrl_state, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rz.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "RZGate.inverse",
        "api_description": "Return inverted RZ gate\n\n:math:`RZ(\\lambda)^{\\dagger} = RZ(-\\lambda)`\n\nArgs:\n    annotated: when set to ``True``, this is typically used to return an\n        :class:`.AnnotatedOperation` with an inverse modifier set instead of a concrete\n        :class:`.Gate`. However, for this class this argument is ignored as the inverse\n        of this gate is always a :class:`.RZGate` with an inverted parameter value.\n\nReturns:\n    RZGate: inverse gate.",
        "api_signature": "inverse(self, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rz.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "RZGate.__array__",
        "api_description": "Return a numpy.array for the RZ gate.",
        "api_signature": "__array__(self, dtype, copy)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rz.py"
    },
    {
        "api_name": "power",
        "full_api_name": "RZGate.power",
        "api_description": "",
        "api_signature": "power(self, exponent, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rz.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "RZGate.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rz.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CRZGate.__init__",
        "api_description": "Create new CRZ gate.",
        "api_signature": "__init__(self, theta, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rz.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "CRZGate._define",
        "api_description": "gate crz(lambda) a,b\n{ rz(lambda/2) b; cx a,b;\n  rz(-lambda/2) b; cx a,b;\n}",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rz.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "CRZGate.inverse",
        "api_description": "Return inverse CRZ gate (i.e. with the negative rotation angle).\n\nArgs:\n    annotated: when set to ``True``, this is typically used to return an\n        :class:`.AnnotatedOperation` with an inverse modifier set instead of a concrete\n        :class:`.Gate`. However, for this class this argument is ignored as the inverse\n        of this gate is always a :class:`.CRZGate` with an inverted parameter value.\n\n Returns:\n    CRZGate: inverse gate.",
        "api_signature": "inverse(self, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rz.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "CRZGate.__array__",
        "api_description": "Return a numpy.array for the CRZ gate.",
        "api_signature": "__array__(self, dtype, copy)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rz.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "CRZGate.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rz.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "DCXGate.__init__",
        "api_description": "Create new DCX gate.",
        "api_signature": "__init__(self, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/dcx.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "DCXGate._define",
        "api_description": "gate dcx a, b { cx a, b; cx b, a; }",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/dcx.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "DCXGate.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/dcx.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "U2Gate.__init__",
        "api_description": "Create new U2 gate.",
        "api_signature": "__init__(self, phi, lam, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u2.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "U2Gate._define",
        "api_description": "",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u2.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "U2Gate.inverse",
        "api_description": "Return inverted U2 gate.\n\n:math:`U2(\\phi, \\lambda)^{\\dagger} =U2(-\\lambda-\\pi, -\\phi+\\pi))`\n\nArgs:\n    annotated: when set to ``True``, this is typically used to return an\n        :class:`.AnnotatedOperation` with an inverse modifier set instead of a concrete\n        :class:`.Gate`. However, for this class this argument is ignored as the inverse\n        of this gate is always a :class:`.U2Gate` with inverse parameter values.\n\nReturns:\n    U2Gate: inverse gate.",
        "api_signature": "inverse(self, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u2.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "U2Gate.__array__",
        "api_description": "Return a Numpy.array for the U2 gate.",
        "api_signature": "__array__(self, dtype, copy)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u2.py"
    },
    {
        "api_name": "_cnot_rxx_decompose",
        "full_api_name": "_cnot_rxx_decompose",
        "api_description": "Decomposition of CNOT gate.\n\nNOTE: this differs to CNOT by a global phase.\nThe matrix returned is given by exp(1j * pi/4) * CNOT\n\nArgs:\n    plus_ry (bool): positive initial RY rotation\n    plus_rxx (bool): positive RXX rotation.\n\nReturns:\n    QuantumCircuit: The decomposed circuit for CNOT gate (up to\n    global phase).",
        "api_signature": "_cnot_rxx_decompose(plus_ry, plus_rxx)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/equivalence_library.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PhaseGate.__init__",
        "api_description": "Create new Phase gate.",
        "api_signature": "__init__(self, theta, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/p.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "PhaseGate._define",
        "api_description": "",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/p.py"
    },
    {
        "api_name": "control",
        "full_api_name": "PhaseGate.control",
        "api_description": "Return a (multi-)controlled-Phase gate.\n\nArgs:\n    num_ctrl_qubits: number of control qubits.\n    label: An optional label for the gate [Default: ``None``]\n    ctrl_state: control state expressed as integer,\n        string (e.g. ``'110'``), or ``None``. If ``None``, use all 1s.\n    annotated: indicates whether the controlled gate should be implemented\n        as an annotated gate. If ``None``, this is handled as ``False``.\n\nReturns:\n    ControlledGate: controlled version of this gate.",
        "api_signature": "control(self, num_ctrl_qubits, label, ctrl_state, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/p.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "PhaseGate.inverse",
        "api_description": "Return inverted Phase gate (:math:`Phase(\\lambda)^{\\dagger} = Phase(-\\lambda)`)\n\nArgs:\n    annotated: when set to ``True``, this is typically used to return an\n        :class:`.AnnotatedOperation` with an inverse modifier set instead of a concrete\n        :class:`.Gate`. However, for this class this argument is ignored as the inverse\n        of this gate is always another :class:`.PGate` with an inverse parameter value.\n\nReturns:\n    PGate: inverse gate.",
        "api_signature": "inverse(self, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/p.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "PhaseGate.__array__",
        "api_description": "Return a numpy.array for the Phase gate.",
        "api_signature": "__array__(self, dtype, copy)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/p.py"
    },
    {
        "api_name": "power",
        "full_api_name": "PhaseGate.power",
        "api_description": "",
        "api_signature": "power(self, exponent, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/p.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "PhaseGate.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/p.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CPhaseGate.__init__",
        "api_description": "Create new CPhase gate.",
        "api_signature": "__init__(self, theta, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/p.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "CPhaseGate._define",
        "api_description": "gate cphase(lambda) a,b\n{ phase(lambda/2) a; cx a,b;\n  phase(-lambda/2) b; cx a,b;\n  phase(lambda/2) b;\n}",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/p.py"
    },
    {
        "api_name": "control",
        "full_api_name": "CPhaseGate.control",
        "api_description": "Controlled version of this gate.\n\nArgs:\n    num_ctrl_qubits: number of control qubits.\n    label: An optional label for the gate [Default: ``None``]\n    ctrl_state: control state expressed as integer,\n        string (e.g.``'110'``), or ``None``. If ``None``, use all 1s.\n    annotated: indicates whether the controlled gate should be implemented\n        as an annotated gate. If ``None``, this is handled as ``False``.\n\nReturns:\n    ControlledGate: controlled version of this gate.",
        "api_signature": "control(self, num_ctrl_qubits, label, ctrl_state, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/p.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "CPhaseGate.inverse",
        "api_description": "Return inverted CPhase gate (:math:`CPhase(\\lambda)^{\\dagger} = CPhase(-\\lambda)`)",
        "api_signature": "inverse(self, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/p.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "CPhaseGate.__array__",
        "api_description": "Return a numpy.array for the CPhase gate.",
        "api_signature": "__array__(self, dtype, copy)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/p.py"
    },
    {
        "api_name": "power",
        "full_api_name": "CPhaseGate.power",
        "api_description": "",
        "api_signature": "power(self, exponent, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/p.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "CPhaseGate.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/p.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "MCPhaseGate.__init__",
        "api_description": "Create new MCPhase gate.",
        "api_signature": "__init__(self, lam, num_ctrl_qubits, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/p.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "MCPhaseGate._define",
        "api_description": "",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/p.py"
    },
    {
        "api_name": "control",
        "full_api_name": "MCPhaseGate.control",
        "api_description": "Controlled version of this gate.\n\nArgs:\n    num_ctrl_qubits: number of control qubits.\n    label: An optional label for the gate [Default: ``None``]\n    ctrl_state: control state expressed as integer,\n        string (e.g.``'110'``), or ``None``. If ``None``, use all 1s.\n    annotated: indicates whether the controlled gate should be implemented\n        as an annotated gate. If ``None``, this is handled as ``False``.\n\nReturns:\n    ControlledGate: controlled version of this gate.",
        "api_signature": "control(self, num_ctrl_qubits, label, ctrl_state, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/p.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "MCPhaseGate.inverse",
        "api_description": "Return inverted MCPhase gate (:math:`MCPhase(\\lambda)^{\\dagger} = MCPhase(-\\lambda)`)",
        "api_signature": "inverse(self, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/p.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "RYGate.__init__",
        "api_description": "Create new RY gate.",
        "api_signature": "__init__(self, theta, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/ry.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "RYGate._define",
        "api_description": "gate ry(theta) a { r(theta, pi/2) a; }",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/ry.py"
    },
    {
        "api_name": "control",
        "full_api_name": "RYGate.control",
        "api_description": "Return a (multi-)controlled-RY gate.\n\nArgs:\n    num_ctrl_qubits: number of control qubits.\n    label: An optional label for the gate [Default: ``None``]\n    ctrl_state: control state expressed as integer,\n        string (e.g.``'110'``), or ``None``. If ``None``, use all 1s.\n    annotated: indicates whether the controlled gate should be implemented\n        as an annotated gate. If ``None``, this is set to ``True`` if\n        the gate contains free parameters and more than one control qubit, in which\n        case it cannot yet be synthesized. Otherwise it is set to ``False``.\n\nReturns:\n    ControlledGate: controlled version of this gate.",
        "api_signature": "control(self, num_ctrl_qubits, label, ctrl_state, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/ry.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "RYGate.inverse",
        "api_description": "Return inverse RY gate.\n\n:math:`RY(\\lambda)^{\\dagger} = RY(-\\lambda)`\n\nArgs:\n    annotated: when set to ``True``, this is typically used to return an\n        :class:`.AnnotatedOperation` with an inverse modifier set instead of a concrete\n        :class:`.Gate`. However, for this class this argument is ignored as the inverse\n        of this gate is always a :class:`.RYGate` with an inverted parameter value.\n\nReturns:\n    RYGate: inverse gate.",
        "api_signature": "inverse(self, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/ry.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "RYGate.__array__",
        "api_description": "Return a numpy.array for the RY gate.",
        "api_signature": "__array__(self, dtype, copy)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/ry.py"
    },
    {
        "api_name": "power",
        "full_api_name": "RYGate.power",
        "api_description": "",
        "api_signature": "power(self, exponent, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/ry.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "RYGate.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/ry.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CRYGate.__init__",
        "api_description": "Create new CRY gate.",
        "api_signature": "__init__(self, theta, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/ry.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "CRYGate._define",
        "api_description": "gate cry(lambda) a,b\n{ u3(lambda/2,0,0) b; cx a,b;\n  u3(-lambda/2,0,0) b; cx a,b;\n}",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/ry.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "CRYGate.inverse",
        "api_description": "Return inverse CRY gate (i.e. with the negative rotation angle)\n\nArgs:\n    annotated: when set to ``True``, this is typically used to return an\n        :class:`.AnnotatedOperation` with an inverse modifier set instead of a concrete\n        :class:`.Gate`. However, for this class this argument is ignored as the inverse\n        of this gate is always a :class:`.CRYGate` with an inverted parameter value.\n\nReturns:\n    CRYGate: inverse gate.\n.",
        "api_signature": "inverse(self, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/ry.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "CRYGate.__array__",
        "api_description": "Return a numpy.array for the CRY gate.",
        "api_signature": "__array__(self, dtype, copy)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/ry.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "CRYGate.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/ry.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "XGate.__init__",
        "api_description": "Create new X gate.",
        "api_signature": "__init__(self, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "XGate._define",
        "api_description": "gate x a { u3(pi,0,pi) a; }",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "control",
        "full_api_name": "XGate.control",
        "api_description": "Return a (multi-)controlled-X gate.\n\nOne control returns a CX gate. Two controls returns a CCX gate.\n\nArgs:\n    num_ctrl_qubits: number of control qubits.\n    label: An optional label for the gate [Default: ``None``]\n    ctrl_state: control state expressed as integer,\n        string (e.g. ``'110'``), or ``None``. If ``None``, use all 1s.\n    annotated: indicates whether the controlled gate should be implemented\n        as an annotated gate.\n\nReturns:\n    ControlledGate: controlled version of this gate.",
        "api_signature": "control(self, num_ctrl_qubits, label, ctrl_state, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "XGate.inverse",
        "api_description": "Return inverted X gate (itself).\n\nArgs:\n    annotated: when set to ``True``, this is typically used to return an\n        :class:`.AnnotatedOperation` with an inverse modifier set instead of a concrete\n        :class:`.Gate`. However, for this class this argument is ignored as this gate\n        is self-inverse.\n\nReturns:\n    XGate: inverse gate (self-inverse).",
        "api_signature": "inverse(self, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "XGate.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CXGate.__init__",
        "api_description": "Create new CX gate.",
        "api_signature": "__init__(self, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "control",
        "full_api_name": "CXGate.control",
        "api_description": "Return a controlled-X gate with more control lines.\n\nArgs:\n    num_ctrl_qubits: number of control qubits.\n    label: An optional label for the gate [Default: ``None``]\n    ctrl_state: control state expressed as integer,\n        string (e.g. ``'110'``), or ``None``. If ``None``, use all 1s.\n    annotated: indicates whether the controlled gate should be implemented\n        as an annotated gate.\n\nReturns:\n    ControlledGate: controlled version of this gate.",
        "api_signature": "control(self, num_ctrl_qubits, label, ctrl_state, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "CXGate.inverse",
        "api_description": "Return inverted CX gate (itself).\n\nArgs:\n    annotated: when set to ``True``, this is typically used to return an\n        :class:`.AnnotatedOperation` with an inverse modifier set instead of a concrete\n        :class:`.Gate`. However, for this class this argument is ignored as this gate\n        is self-inverse.\n\nReturns:\n    CXGate: inverse gate (self-inverse).",
        "api_signature": "inverse(self, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "CXGate.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CCXGate.__init__",
        "api_description": "Create new CCX gate.",
        "api_signature": "__init__(self, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "CCXGate._define",
        "api_description": "gate ccx a,b,c\n{\nh c; cx b,c; tdg c; cx a,c;\nt c; cx b,c; tdg c; cx a,c;\nt b; t c; h c; cx a,b;\nt a; tdg b; cx a,b;}",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "control",
        "full_api_name": "CCXGate.control",
        "api_description": "Controlled version of this gate.\n\nArgs:\n    num_ctrl_qubits: number of control qubits.\n    label: An optional label for the gate [Default: ``None``]\n    ctrl_state: control state expressed as integer,\n        string (e.g. ``'110'``), or ``None``. If ``None``, use all 1s.\n    annotated: indicates whether the controlled gate should be implemented\n        as an annotated gate.\n\nReturns:\n    ControlledGate: controlled version of this gate.",
        "api_signature": "control(self, num_ctrl_qubits, label, ctrl_state, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "CCXGate.inverse",
        "api_description": "Return an inverted CCX gate (also a CCX).\n\nArgs:\n    annotated: when set to ``True``, this is typically used to return an\n        :class:`.AnnotatedOperation` with an inverse modifier set instead of a concrete\n        :class:`.Gate`. However, for this class this argument is ignored as this gate\n        is self-inverse.\n\nReturns:\n    CCXGate: inverse gate (self-inverse).",
        "api_signature": "inverse(self, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "CCXGate.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "RCCXGate.__init__",
        "api_description": "Create a new simplified CCX gate.",
        "api_signature": "__init__(self, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "RCCXGate._define",
        "api_description": "gate rccx a,b,c\n{ u2(0,pi) c;\n  u1(pi/4) c;\n  cx b, c;\n  u1(-pi/4) c;\n  cx a, c;\n  u1(pi/4) c;\n  cx b, c;\n  u1(-pi/4) c;\n  u2(0,pi) c;\n}",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "RCCXGate.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "C3SXGate.__init__",
        "api_description": "Create a new 3-qubit controlled sqrt-X gate.\n\nArgs:\n    label: An optional label for the gate [Default: ``None``]\n    ctrl_state: control state expressed as integer,\n        string (e.g. ``'110'``), or ``None``. If ``None``, use all 1s.",
        "api_signature": "__init__(self, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "C3SXGate._define",
        "api_description": "gate c3sqrtx a,b,c,d\n{\n    h d; cu1(pi/8) a,d; h d;\n    cx a,b;\n    h d; cu1(-pi/8) b,d; h d;\n    cx a,b;\n    h d; cu1(pi/8) b,d; h d;\n    cx b,c;\n    h d; cu1(-pi/8) c,d; h d;\n    cx a,c;\n    h d; cu1(pi/8) c,d; h d;\n    cx b,c;\n    h d; cu1(-pi/8) c,d; h d;\n    cx a,c;\n    h d; cu1(pi/8) c,d; h d;\n}",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "C3SXGate.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "C3XGate.__init__",
        "api_description": "Create a new 3-qubit controlled X gate.",
        "api_signature": "__init__(self, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "C3XGate._define",
        "api_description": "gate c3x a,b,c,d\n{\n    h d;\n    p(pi/8) a;\n    p(pi/8) b;\n    p(pi/8) c;\n    p(pi/8) d;\n    cx a, b;\n    p(-pi/8) b;\n    cx a, b;\n    cx b, c;\n    p(-pi/8) c;\n    cx a, c;\n    p(pi/8) c;\n    cx b, c;\n    p(-pi/8) c;\n    cx a, c;\n    cx c, d;\n    p(-pi/8) d;\n    cx b, d;\n    p(pi/8) d;\n    cx c, d;\n    p(-pi/8) d;\n    cx a, d;\n    p(pi/8) d;\n    cx c, d;\n    p(-pi/8) d;\n    cx b, d;\n    p(pi/8) d;\n    cx c, d;\n    p(-pi/8) d;\n    cx a, d;\n    h d;\n}",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "control",
        "full_api_name": "C3XGate.control",
        "api_description": "Controlled version of this gate.\n\nArgs:\n    num_ctrl_qubits: number of control qubits.\n    label: An optional label for the gate [Default: ``None``]\n    ctrl_state: control state expressed as integer,\n        string (e.g. ``'110'``), or ``None``. If ``None``, use all 1s.\n    annotated: indicates whether the controlled gate should be implemented\n        as an annotated gate.\n\nReturns:\n    ControlledGate: controlled version of this gate.",
        "api_signature": "control(self, num_ctrl_qubits, label, ctrl_state, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "C3XGate.inverse",
        "api_description": "Invert this gate. The C3X is its own inverse.\n\nArgs:\n    annotated: when set to ``True``, this is typically used to return an\n        :class:`.AnnotatedOperation` with an inverse modifier set instead of a concrete\n        :class:`.Gate`. However, for this class this argument is ignored as this gate\n        is self-inverse.\n\nReturns:\n    C3XGate: inverse gate (self-inverse).",
        "api_signature": "inverse(self, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "C3XGate.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "RC3XGate.__init__",
        "api_description": "Create a new RC3X gate.",
        "api_signature": "__init__(self, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "RC3XGate._define",
        "api_description": "gate rc3x a,b,c,d\n{ u2(0,pi) d;\n  u1(pi/4) d;\n  cx c,d;\n  u1(-pi/4) d;\n  u2(0,pi) d;\n  cx a,d;\n  u1(pi/4) d;\n  cx b,d;\n  u1(-pi/4) d;\n  cx a,d;\n  u1(pi/4) d;\n  cx b,d;\n  u1(-pi/4) d;\n  u2(0,pi) d;\n  u1(pi/4) d;\n  cx c,d;\n  u1(-pi/4) d;\n  u2(0,pi) d;\n}",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "RC3XGate.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "C4XGate.__init__",
        "api_description": "Create a new 4-qubit controlled X gate.",
        "api_signature": "__init__(self, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "C4XGate._define",
        "api_description": "gate c3sqrtx a,b,c,d\n{\n    h d; cu1(pi/8) a,d; h d;\n    cx a,b;\n    h d; cu1(-pi/8) b,d; h d;\n    cx a,b;\n    h d; cu1(pi/8) b,d; h d;\n    cx b,c;\n    h d; cu1(-pi/8) c,d; h d;\n    cx a,c;\n    h d; cu1(pi/8) c,d; h d;\n    cx b,c;\n    h d; cu1(-pi/8) c,d; h d;\n    cx a,c;\n    h d; cu1(pi/8) c,d; h d;\n}\ngate c4x a,b,c,d,e\n{\n    h e; cu1(pi/2) d,e; h e;\n    rc3x a,b,c,d;\n    h e; cu1(-pi/2) d,e; h e;\n    rc3x a,b,c,d;\n    c3sqrtx a,b,c,e;\n}",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "control",
        "full_api_name": "C4XGate.control",
        "api_description": "Controlled version of this gate.\n\nArgs:\n    num_ctrl_qubits: number of control qubits.\n    label: An optional label for the gate [Default: ``None``]\n    ctrl_state: control state expressed as integer,\n        string (e.g. ``'110'``), or ``None``. If ``None``, use all 1s.\n    annotated: indicates whether the controlled gate should be implemented\n        as an annotated gate.\n\nReturns:\n    ControlledGate: controlled version of this gate.",
        "api_signature": "control(self, num_ctrl_qubits, label, ctrl_state, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "C4XGate.inverse",
        "api_description": "Invert this gate. The C4X is its own inverse.\n\nArgs:\n    annotated: when set to ``True``, this is typically used to return an\n        :class:`.AnnotatedOperation` with an inverse modifier set instead of a concrete\n        :class:`.Gate`. However, for this class this argument is ignored as this gate\n        is self-inverse.\n\nReturns:\n    C4XGate: inverse gate (self-inverse).",
        "api_signature": "inverse(self, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "C4XGate.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "__new__",
        "full_api_name": "MCXGate.__new__",
        "api_description": "Create a new MCX instance.\n\nDepending on the number of controls and which mode of the MCX, this creates an\nexplicit CX, CCX, C3X or C4X instance or a generic MCX gate.",
        "api_signature": "__new__(cls, num_ctrl_qubits, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "MCXGate.__init__",
        "api_description": "Create new MCX gate.",
        "api_signature": "__init__(self, num_ctrl_qubits, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "MCXGate.inverse",
        "api_description": "Invert this gate. The MCX is its own inverse.\n\nArgs:\n    annotated: when set to ``True``, this is typically used to return an\n        :class:`.AnnotatedOperation` with an inverse modifier set instead of a concrete\n        :class:`.Gate`. However, for this class this argument is ignored as this gate\n        is self-inverse.\n\nReturns:\n    MCXGate: inverse gate (self-inverse).",
        "api_signature": "inverse(self, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "get_num_ancilla_qubits",
        "full_api_name": "MCXGate.get_num_ancilla_qubits",
        "api_description": "Get the number of required ancilla qubits without instantiating the class.\n\nThis staticmethod might be necessary to check the number of ancillas before\ncreating the gate, or to use the number of ancillas in the initialization.",
        "api_signature": "get_num_ancilla_qubits(num_ctrl_qubits, mode)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "MCXGate._define",
        "api_description": "This definition is based on MCPhaseGate implementation.",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "num_ancilla_qubits",
        "full_api_name": "MCXGate.num_ancilla_qubits",
        "api_description": "The number of ancilla qubits.",
        "api_signature": "num_ancilla_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "control",
        "full_api_name": "MCXGate.control",
        "api_description": "Return a multi-controlled-X gate with more control lines.\n\nArgs:\n    num_ctrl_qubits: number of control qubits.\n    label: An optional label for the gate [Default: ``None``]\n    ctrl_state: control state expressed as integer,\n        string (e.g. ``'110'``), or ``None``. If ``None``, use all 1s.\n    annotated: indicates whether the controlled gate should be implemented\n        as an annotated gate.\n\nReturns:\n    ControlledGate: controlled version of this gate.",
        "api_signature": "control(self, num_ctrl_qubits, label, ctrl_state, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "__new__",
        "full_api_name": "MCXGrayCode.__new__",
        "api_description": "Create a new MCXGrayCode instance",
        "api_signature": "__new__(cls, num_ctrl_qubits, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "MCXGrayCode.__init__",
        "api_description": "",
        "api_signature": "__init__(self, num_ctrl_qubits, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "MCXGrayCode.inverse",
        "api_description": "Invert this gate. The MCX is its own inverse.\n\nArgs:\n    annotated: when set to ``True``, this is typically used to return an\n        :class:`.AnnotatedOperation` with an inverse modifier set instead of a concrete\n        :class:`.Gate`. However, for this class this argument is ignored as this gate\n        is self-inverse.\n\nReturns:\n    MCXGrayCode: inverse gate (self-inverse).",
        "api_signature": "inverse(self, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "MCXGrayCode._define",
        "api_description": "Define the MCX gate using the Gray code.",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "MCXRecursive.__init__",
        "api_description": "",
        "api_signature": "__init__(self, num_ctrl_qubits, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "get_num_ancilla_qubits",
        "full_api_name": "MCXRecursive.get_num_ancilla_qubits",
        "api_description": "Get the number of required ancilla qubits.",
        "api_signature": "get_num_ancilla_qubits(num_ctrl_qubits, mode)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "MCXRecursive.inverse",
        "api_description": "Invert this gate. The MCX is its own inverse.\n\nArgs:\n    annotated: when set to ``True``, this is typically used to return an\n        :class:`.AnnotatedOperation` with an inverse modifier set instead of a concrete\n        :class:`.Gate`. However, for this class this argument is ignored as this gate\n        is self-inverse.\n\nReturns:\n    MCXRecursive: inverse gate (self-inverse).",
        "api_signature": "inverse(self, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "MCXRecursive._define",
        "api_description": "Define the MCX gate using recursion.",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "__new__",
        "full_api_name": "MCXVChain.__new__",
        "api_description": "Create a new MCX instance.\n\nThis must be defined anew to include the additional argument ``dirty_ancillas``.",
        "api_signature": "__new__(cls, num_ctrl_qubits, dirty_ancillas, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "MCXVChain.__init__",
        "api_description": "Args:\n    dirty_ancillas: when set to ``True``, the method applies an optimized multicontrolled-X gate\n        up to a relative phase using dirty ancillary qubits with the properties of lemmas 7 and 8\n        from arXiv:1501.06911, with at most 8*k - 6 CNOT gates.\n        For k within the range {1, ..., ceil(n/2)}. And for n representing the total number of\n        qubits.\n    relative_phase: when set to ``True``, the method applies the optimized multicontrolled-X gate\n        up to a relative phase, in a way that, by lemma 7 of arXiv:1501.06911, the relative\n        phases of the ``action part`` cancel out with the phases of the ``reset part``.\n\n    action_only: when set to ``True``, the method applies only the action part of lemma 8\n        from arXiv:1501.06911.",
        "api_signature": "__init__(self, num_ctrl_qubits, dirty_ancillas, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "MCXVChain.inverse",
        "api_description": "Invert this gate. The MCX is its own inverse.\n\nArgs:\n    annotated: when set to ``True``, this is typically used to return an\n        :class:`.AnnotatedOperation` with an inverse modifier set instead of a concrete\n        :class:`.Gate`. However, for this class this argument is ignored as this gate\n        is self-inverse.\n\nReturns:\n    MCXVChain: inverse gate (self-inverse).",
        "api_signature": "inverse(self, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "get_num_ancilla_qubits",
        "full_api_name": "MCXVChain.get_num_ancilla_qubits",
        "api_description": "Get the number of required ancilla qubits.",
        "api_signature": "get_num_ancilla_qubits(num_ctrl_qubits, mode)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "MCXVChain._define",
        "api_description": "Define the MCX gate using a V-chain of CX gates.",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/x.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SGate.__init__",
        "api_description": "Create new S gate.",
        "api_signature": "__init__(self, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/s.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "SGate._define",
        "api_description": "gate s a { u1(pi/2) a; }",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/s.py"
    },
    {
        "api_name": "control",
        "full_api_name": "SGate.control",
        "api_description": "Return a (multi-)controlled-S gate.\n\nOne control qubit returns a :class:`.CSGate`.\n\nArgs:\n    num_ctrl_qubits: number of control qubits.\n    label: An optional label for the gate [Default: ``None``]\n    ctrl_state: control state expressed as integer,\n        string (e.g.``'110'``), or ``None``. If ``None``, use all 1s.\n    annotated: indicates whether the controlled gate should be implemented\n        as an annotated gate. If ``None``, this is handled as ``False``.\n\nReturns:\n    ControlledGate: controlled version of this gate.",
        "api_signature": "control(self, num_ctrl_qubits, label, ctrl_state, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/s.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "SGate.inverse",
        "api_description": "Return inverse of S (SdgGate).\n\nArgs:\n    annotated: when set to ``True``, this is typically used to return an\n        :class:`.AnnotatedOperation` with an inverse modifier set instead of a concrete\n        :class:`.Gate`. However, for this class this argument is ignored as the inverse\n        of this gate is always a :class:`.SdgGate`.\n\nReturns:\n    SdgGate: inverse of :class:`.SGate`",
        "api_signature": "inverse(self, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/s.py"
    },
    {
        "api_name": "power",
        "full_api_name": "SGate.power",
        "api_description": "",
        "api_signature": "power(self, exponent, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/s.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "SGate.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/s.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SdgGate.__init__",
        "api_description": "Create new Sdg gate.",
        "api_signature": "__init__(self, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/s.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "SdgGate._define",
        "api_description": "gate sdg a { u1(-pi/2) a; }",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/s.py"
    },
    {
        "api_name": "control",
        "full_api_name": "SdgGate.control",
        "api_description": "Return a (multi-)controlled-Sdg gate.\n\nOne control qubit returns a :class:`.CSdgGate`.\n\nArgs:\n    num_ctrl_qubits: number of control qubits.\n    label: An optional label for the gate [Default: ``None``]\n    ctrl_state: control state expressed as integer,\n        string (e.g.``'110'``), or ``None``. If ``None``, use all 1s.\n    annotated: indicates whether the controlled gate should be implemented\n        as an annotated gate. If ``None``, this is handled as ``False``.\n\nReturns:\n    ControlledGate: controlled version of this gate.",
        "api_signature": "control(self, num_ctrl_qubits, label, ctrl_state, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/s.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "SdgGate.inverse",
        "api_description": "Return inverse of Sdg (SGate).\n\nArgs:\n    annotated: when set to ``True``, this is typically used to return an\n        :class:`.AnnotatedOperation` with an inverse modifier set instead of a concrete\n        :class:`.Gate`. However, for this class this argument is ignored as the inverse\n        of this gate is always a :class:`.SGate`.\n\nReturns:\n    SGate: inverse of :class:`.SdgGate`",
        "api_signature": "inverse(self, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/s.py"
    },
    {
        "api_name": "power",
        "full_api_name": "SdgGate.power",
        "api_description": "",
        "api_signature": "power(self, exponent, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/s.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "SdgGate.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/s.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CSGate.__init__",
        "api_description": "Create new CS gate.",
        "api_signature": "__init__(self, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/s.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "CSGate._define",
        "api_description": "gate cs a,b { h b; cp(pi/2) a,b; h b; }",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/s.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "CSGate.inverse",
        "api_description": "Return inverse of CSGate (CSdgGate).\n\nArgs:\n    annotated: when set to ``True``, this is typically used to return an\n        :class:`.AnnotatedOperation` with an inverse modifier set instead of a concrete\n        :class:`.Gate`. However, for this class this argument is ignored as the inverse\n        of this gate is always a :class:`.CSdgGate`.\n\nReturns:\n    CSdgGate: inverse of :class:`.CSGate`",
        "api_signature": "inverse(self, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/s.py"
    },
    {
        "api_name": "power",
        "full_api_name": "CSGate.power",
        "api_description": "",
        "api_signature": "power(self, exponent, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/s.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "CSGate.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/s.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CSdgGate.__init__",
        "api_description": "Create new CSdg gate.",
        "api_signature": "__init__(self, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/s.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "CSdgGate._define",
        "api_description": "gate csdg a,b { h b; cp(-pi/2) a,b; h b; }",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/s.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "CSdgGate.inverse",
        "api_description": "Return inverse of CSdgGate (CSGate).\n\nArgs:\n    annotated: when set to ``True``, this is typically used to return an\n        :class:`.AnnotatedOperation` with an inverse modifier set instead of a concrete\n        :class:`.Gate`. However, for this class this argument is ignored as the inverse\n        of this gate is always a :class:`.CSGate`.\n\nReturns:\n    CSGate: inverse of :class:`.CSdgGate`",
        "api_signature": "inverse(self, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/s.py"
    },
    {
        "api_name": "power",
        "full_api_name": "CSdgGate.power",
        "api_description": "",
        "api_signature": "power(self, exponent, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/s.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "CSdgGate.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/s.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "RZZGate.__init__",
        "api_description": "Create new RZZ gate.",
        "api_signature": "__init__(self, theta, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rzz.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "RZZGate._define",
        "api_description": "gate rzz(theta) a, b { cx a, b; u1(theta) b; cx a, b; }",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rzz.py"
    },
    {
        "api_name": "control",
        "full_api_name": "RZZGate.control",
        "api_description": "Return a (multi-)controlled-RZZ gate.\n\nArgs:\n    num_ctrl_qubits: number of control qubits.\n    label: An optional label for the gate [Default: ``None``]\n    ctrl_state: control state expressed as integer,\n        string (e.g.``'110'``), or ``None``. If ``None``, use all 1s.\n    annotated: indicates whether the controlled gate should be implemented\n        as an annotated gate. If ``None``, this is set to ``True`` if\n        the gate contains free parameters, in which case it cannot\n        yet be synthesized.\n\nReturns:\n    ControlledGate: controlled version of this gate.",
        "api_signature": "control(self, num_ctrl_qubits, label, ctrl_state, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rzz.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "RZZGate.inverse",
        "api_description": "Return inverse RZZ gate (i.e. with the negative rotation angle).\n\nArgs:\n    annotated: when set to ``True``, this is typically used to return an\n        :class:`.AnnotatedOperation` with an inverse modifier set instead of a concrete\n        :class:`.Gate`. However, for this class this argument is ignored as the inverse\n        of this gate is always a :class:`.RZZGate` with an inverted parameter value.\n\nReturns:\n    RZZGate: inverse gate.",
        "api_signature": "inverse(self, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rzz.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "RZZGate.__array__",
        "api_description": "Return a numpy.array for the RZZ gate.",
        "api_signature": "__array__(self, dtype, copy)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rzz.py"
    },
    {
        "api_name": "power",
        "full_api_name": "RZZGate.power",
        "api_description": "",
        "api_signature": "power(self, exponent, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rzz.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "RZZGate.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rzz.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "RGate.__init__",
        "api_description": "Create new r single-qubit gate.",
        "api_signature": "__init__(self, theta, phi, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/r.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "RGate._define",
        "api_description": "gate r(\u03b8, \u03c6) a {u3(\u03b8, \u03c6 - \u03c0/2, -\u03c6 + \u03c0/2) a;}",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/r.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "RGate.inverse",
        "api_description": "Invert this gate as: :math:`r(\u03b8, \u03c6)^dagger = r(-\u03b8, \u03c6)`\n\nArgs:\n    annotated: when set to ``True``, this is typically used to return an\n        :class:`.AnnotatedOperation` with an inverse modifier set instead of a concrete\n        :class:`.Gate`. However, for this class this argument is ignored as the inverse\n        of this gate is always a :class:`.RGate` with an inverted parameter value.\n\nReturns:\n    RGate: inverse gate.",
        "api_signature": "inverse(self, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/r.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "RGate.__array__",
        "api_description": "Return a numpy.array for the R gate.",
        "api_signature": "__array__(self, dtype, copy)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/r.py"
    },
    {
        "api_name": "power",
        "full_api_name": "RGate.power",
        "api_description": "",
        "api_signature": "power(self, exponent, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/r.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "RGate.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/r.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "iSwapGate.__init__",
        "api_description": "Create new iSwap gate.",
        "api_signature": "__init__(self, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/iswap.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "iSwapGate._define",
        "api_description": "gate iswap a,b {\n    s q[0];\n    s q[1];\n    h q[0];\n    cx q[0],q[1];\n    cx q[1],q[0];\n    h q[1];\n}",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/iswap.py"
    },
    {
        "api_name": "power",
        "full_api_name": "iSwapGate.power",
        "api_description": "",
        "api_signature": "power(self, exponent, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/iswap.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "iSwapGate.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/iswap.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "RYYGate.__init__",
        "api_description": "Create new RYY gate.",
        "api_signature": "__init__(self, theta, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/ryy.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "RYYGate._define",
        "api_description": "Calculate a subcircuit that implements this unitary.",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/ryy.py"
    },
    {
        "api_name": "control",
        "full_api_name": "RYYGate.control",
        "api_description": "Return a (multi-)controlled-YY gate.\n\nArgs:\n    num_ctrl_qubits: number of control qubits.\n    label: An optional label for the gate [Default: ``None``]\n    ctrl_state: control state expressed as integer,\n        string (e.g.``'110'``), or ``None``. If ``None``, use all 1s.\n    annotated: indicates whether the controlled gate should be implemented\n        as an annotated gate. If ``None``, this is set to ``True`` if\n        the gate contains free parameters, in which case it cannot\n        yet be synthesized.\n\nReturns:\n    ControlledGate: controlled version of this gate.",
        "api_signature": "control(self, num_ctrl_qubits, label, ctrl_state, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/ryy.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "RYYGate.inverse",
        "api_description": "Return inverse RYY gate (i.e. with the negative rotation angle).\n\nArgs:\n    annotated: when set to ``True``, this is typically used to return an\n        :class:`.AnnotatedOperation` with an inverse modifier set instead of a concrete\n        :class:`.Gate`. However, for this class this argument is ignored as the inverse\n        of this gate is always a :class:`.RYYGate` with an inverted parameter value.\n\nReturns:\n    RYYGate: inverse gate.",
        "api_signature": "inverse(self, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/ryy.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "RYYGate.__array__",
        "api_description": "Return a numpy.array for the RYY gate.",
        "api_signature": "__array__(self, dtype, copy)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/ryy.py"
    },
    {
        "api_name": "power",
        "full_api_name": "RYYGate.power",
        "api_description": "",
        "api_signature": "power(self, exponent, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/ryy.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "RYYGate.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/ryy.py"
    },
    {
        "api_name": "_apply_cu",
        "full_api_name": "_apply_cu",
        "api_description": "",
        "api_signature": "_apply_cu(circuit, theta, phi, lam, control, target, use_basis_gates)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/multi_control_rotation_gates.py"
    },
    {
        "api_name": "_apply_mcu_graycode",
        "full_api_name": "_apply_mcu_graycode",
        "api_description": "Apply multi-controlled u gate from ctls to tgt using graycode\npattern with single-step angles theta, phi, lam.",
        "api_signature": "_apply_mcu_graycode(circuit, theta, phi, lam, ctls, tgt, use_basis_gates)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/multi_control_rotation_gates.py"
    },
    {
        "api_name": "_mcsu2_real_diagonal",
        "full_api_name": "_mcsu2_real_diagonal",
        "api_description": "Return a multi-controlled SU(2) gate [1]_ with a real main diagonal or secondary diagonal.\n\nArgs:\n    unitary: SU(2) unitary matrix with one real diagonal.\n    num_controls: The number of control qubits.\n    ctrl_state: The state on which the SU(2) operation is controlled. Defaults to all\n        control qubits being in state 1.\n    use_basis_gates: If ``True``, use ``[p, u, cx]`` gates to implement the decomposition.\n\nReturns:\n    A :class:`.QuantumCircuit` implementing the multi-controlled SU(2) gate.\n\nRaises:\n    QiskitError: If the input matrix is invalid.\n\nReferences:\n\n    .. [1]: R. Vale et al. Decomposition of Multi-controlled Special Unitary Single-Qubit Gates\n        `arXiv:2302.06377 (2023) <https://arxiv.org/abs/2302.06377>`__",
        "api_signature": "_mcsu2_real_diagonal(unitary, num_controls, ctrl_state, use_basis_gates)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/multi_control_rotation_gates.py"
    },
    {
        "api_name": "mcrx",
        "full_api_name": "mcrx",
        "api_description": "Apply Multiple-Controlled X rotation gate\n\nArgs:\n    self (QuantumCircuit): The QuantumCircuit object to apply the mcrx gate on.\n    theta (float): angle theta\n    q_controls (QuantumRegister or list(Qubit)): The list of control qubits\n    q_target (Qubit): The target qubit\n    use_basis_gates (bool): use p, u, cx\n\nRaises:\n    QiskitError: parameter errors",
        "api_signature": "mcrx(self, theta, q_controls, q_target, use_basis_gates)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/multi_control_rotation_gates.py"
    },
    {
        "api_name": "mcry",
        "full_api_name": "mcry",
        "api_description": "Apply Multiple-Controlled Y rotation gate\n\nArgs:\n    self (QuantumCircuit): The QuantumCircuit object to apply the mcry gate on.\n    theta (float): angle theta\n    q_controls (list(Qubit)): The list of control qubits\n    q_target (Qubit): The target qubit\n    q_ancillae (QuantumRegister or tuple(QuantumRegister, int)): The list of ancillary qubits.\n    mode (string): The implementation mode to use\n    use_basis_gates (bool): use p, u, cx\n\nRaises:\n    QiskitError: parameter errors",
        "api_signature": "mcry(self, theta, q_controls, q_target, q_ancillae, mode, use_basis_gates)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/multi_control_rotation_gates.py"
    },
    {
        "api_name": "mcrz",
        "full_api_name": "mcrz",
        "api_description": "Apply Multiple-Controlled Z rotation gate\n\nArgs:\n    self (QuantumCircuit): The QuantumCircuit object to apply the mcrz gate on.\n    lam (float): angle lambda\n    q_controls (list(Qubit)): The list of control qubits\n    q_target (Qubit): The target qubit\n    use_basis_gates (bool): use p, u, cx\n\nRaises:\n    QiskitError: parameter errors",
        "api_signature": "mcrz(self, lam, q_controls, q_target, use_basis_gates)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/multi_control_rotation_gates.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "RXGate.__init__",
        "api_description": "Create new RX gate.",
        "api_signature": "__init__(self, theta, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rx.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "RXGate._define",
        "api_description": "gate rx(theta) a {r(theta, 0) a;}",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rx.py"
    },
    {
        "api_name": "control",
        "full_api_name": "RXGate.control",
        "api_description": "Return a (multi-)controlled-RX gate.\n\nArgs:\n    num_ctrl_qubits: number of control qubits.\n    label: An optional label for the gate [Default: ``None``]\n    ctrl_state: control state expressed as integer,\n        string (e.g.``'110'``), or ``None``. If ``None``, use all 1s.\n    annotated: indicates whether the controlled gate should be implemented\n        as an annotated gate. If ``None``, this is set to ``True`` if\n        the gate contains free parameters and more than one control qubit, in which\n        case it cannot yet be synthesized. Otherwise it is set to ``False``.\n\nReturns:\n    ControlledGate: controlled version of this gate.",
        "api_signature": "control(self, num_ctrl_qubits, label, ctrl_state, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rx.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "RXGate.inverse",
        "api_description": "Return inverted RX gate.\n\n:math:`RX(\\lambda)^{\\dagger} = RX(-\\lambda)`\n\nArgs:\n    annotated: when set to ``True``, this is typically used to return an\n        :class:`.AnnotatedOperation` with an inverse modifier set instead of a concrete\n        :class:`.Gate`. However, for this class this argument is ignored as the inverse\n        of this gate is always a :class:`.RXGate` with an inverted parameter value.\n\nReturns:\n    RXGate: inverse gate.",
        "api_signature": "inverse(self, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rx.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "RXGate.__array__",
        "api_description": "Return a numpy.array for the RX gate.",
        "api_signature": "__array__(self, dtype, copy)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rx.py"
    },
    {
        "api_name": "power",
        "full_api_name": "RXGate.power",
        "api_description": "",
        "api_signature": "power(self, exponent, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rx.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "RXGate.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rx.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CRXGate.__init__",
        "api_description": "Create new CRX gate.",
        "api_signature": "__init__(self, theta, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rx.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "CRXGate._define",
        "api_description": "gate cu3(theta,phi,lambda) c, t\n{ u1(pi/2) t;\n  cx c,t;\n  u3(-theta/2,0,0) t;\n  cx c,t;\n  u3(theta/2,-pi/2,0) t;\n}",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rx.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "CRXGate.inverse",
        "api_description": "Return inverse CRX gate (i.e. with the negative rotation angle).\n\nArgs:\n    annotated: when set to ``True``, this is typically used to return an\n        :class:`.AnnotatedOperation` with an inverse modifier set instead of a concrete\n        :class:`.Gate`. However, for this class this argument is ignored as the inverse\n        of this gate is always a :class:`.CRXGate` with an inverted parameter value.\n\nReturns:\n    CRXGate: inverse gate.",
        "api_signature": "inverse(self, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rx.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "CRXGate.__array__",
        "api_description": "Return a numpy.array for the CRX gate.",
        "api_signature": "__array__(self, dtype, copy)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rx.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "CRXGate.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rx.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "U1Gate.__init__",
        "api_description": "Create new U1 gate.",
        "api_signature": "__init__(self, theta, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u1.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "U1Gate._define",
        "api_description": "",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u1.py"
    },
    {
        "api_name": "control",
        "full_api_name": "U1Gate.control",
        "api_description": "Return a (multi-)controlled-U1 gate.\n\nArgs:\n    num_ctrl_qubits: number of control qubits.\n    label: An optional label for the gate [Default: ``None``]\n    ctrl_state: control state expressed as integer,\n        string (e.g.``'110'``), or ``None``. If ``None``, use all 1s.\n    annotated: indicates whether the controlled gate should be implemented\n        as an annotated gate.\n\nReturns:\n    ControlledGate: controlled version of this gate.",
        "api_signature": "control(self, num_ctrl_qubits, label, ctrl_state, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u1.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "U1Gate.inverse",
        "api_description": "Return inverted U1 gate (:math:`U1(\\lambda)^{\\dagger} = U1(-\\lambda))`\n\nArgs:\n    annotated: when set to ``True``, this is typically used to return an\n        :class:`.AnnotatedOperation` with an inverse modifier set instead of a concrete\n        :class:`.Gate`. However, for this class this argument is ignored as the inverse\n        of this gate is always a :class:`.U1Gate` with inverse parameter values.\n\nReturns:\n    U1Gate: inverse gate.",
        "api_signature": "inverse(self, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u1.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "U1Gate.__array__",
        "api_description": "Return a numpy.array for the U1 gate.",
        "api_signature": "__array__(self, dtype, copy)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u1.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CU1Gate.__init__",
        "api_description": "Create new CU1 gate.",
        "api_signature": "__init__(self, theta, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u1.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "CU1Gate._define",
        "api_description": "gate cu1(lambda) a,b\n{ u1(lambda/2) a; cx a,b;\n  u1(-lambda/2) b; cx a,b;\n  u1(lambda/2) b;\n}",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u1.py"
    },
    {
        "api_name": "control",
        "full_api_name": "CU1Gate.control",
        "api_description": "Controlled version of this gate.\n\nArgs:\n    num_ctrl_qubits: number of control qubits.\n    label: An optional label for the gate [Default: ``None``]\n    ctrl_state: control state expressed as integer,\n        string (e.g.``'110'``), or ``None``. If ``None``, use all 1s.\n    annotated: indicates whether the controlled gate should be implemented\n        as an annotated gate.\n\nReturns:\n    ControlledGate: controlled version of this gate.",
        "api_signature": "control(self, num_ctrl_qubits, label, ctrl_state, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u1.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "CU1Gate.inverse",
        "api_description": "Return inverted CU1 gate (:math:`CU1(\\lambda)^{\\dagger} = CU1(-\\lambda))`\n\nArgs:\n    annotated: when set to ``True``, this is typically used to return an\n        :class:`.AnnotatedOperation` with an inverse modifier set instead of a concrete\n        :class:`.Gate`. However, for this class this argument is ignored as the inverse\n        of this gate is always a :class:`.CU1Gate` with inverse parameter\n        values.\n\nReturns:\n    CU1Gate: inverse gate.",
        "api_signature": "inverse(self, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u1.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "CU1Gate.__array__",
        "api_description": "Return a numpy.array for the CU1 gate.",
        "api_signature": "__array__(self, dtype, copy)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u1.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "MCU1Gate.__init__",
        "api_description": "Create new MCU1 gate.",
        "api_signature": "__init__(self, lam, num_ctrl_qubits, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u1.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "MCU1Gate._define",
        "api_description": "",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u1.py"
    },
    {
        "api_name": "control",
        "full_api_name": "MCU1Gate.control",
        "api_description": "Controlled version of this gate.\n\nArgs:\n    num_ctrl_qubits: number of control qubits.\n    label: An optional label for the gate [Default: ``None``]\n    ctrl_state: control state expressed as integer,\n        string (e.g.``'110'``), or ``None``. If ``None``, use all 1s.\n    annotated: indicates whether the controlled gate should be implemented\n        as an annotated gate.\n\nReturns:\n    ControlledGate: controlled version of this gate.",
        "api_signature": "control(self, num_ctrl_qubits, label, ctrl_state, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u1.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "MCU1Gate.inverse",
        "api_description": "Return inverted MCU1 gate (:math:`MCU1(\\lambda)^{\\dagger} = MCU1(-\\lambda))`\n\nArgs:\n    annotated: when set to ``True``, this is typically used to return an\n        :class:`.AnnotatedOperation` with an inverse modifier set instead of a concrete\n        :class:`.Gate`. However, for this class this argument is ignored as the inverse\n        of this gate is always a :class:`.MCU1Gate` with inverse\n        parameter values.\n\nReturns:\n    MCU1Gate: inverse gate.",
        "api_signature": "inverse(self, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u1.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "GlobalPhaseGate.__init__",
        "api_description": "Args:\n    phase: The value of phase it takes.\n    label: An optional label for the gate.",
        "api_signature": "__init__(self, phase, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/global_phase.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "GlobalPhaseGate._define",
        "api_description": "",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/global_phase.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "GlobalPhaseGate.inverse",
        "api_description": "Return inverse GlobalPhaseGate gate.\n\n:math:`\\text{GlobalPhaseGate}(\\lambda)^{\\dagger} = \\text{GlobalPhaseGate}(-\\lambda)`\n\nArgs:\n    annotated: when set to ``True``, this is typically used to return an\n        :class:`.AnnotatedOperation` with an inverse modifier set instead of a concrete\n        :class:`.Gate`. However, for this class this argument is ignored as the inverse\n        is always another :class:`.GlobalPhaseGate` with an inverted\n        parameter value.\n\nReturns:\n    GlobalPhaseGate: inverse gate.",
        "api_signature": "inverse(self, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/global_phase.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "GlobalPhaseGate.__array__",
        "api_description": "Return a numpy.array for the global_phase gate.",
        "api_signature": "__array__(self, dtype, copy)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/global_phase.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "GlobalPhaseGate.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/global_phase.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SwapGate.__init__",
        "api_description": "Create new SWAP gate.",
        "api_signature": "__init__(self, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/swap.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "SwapGate._define",
        "api_description": "gate swap a,b { cx a,b; cx b,a; cx a,b; }",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/swap.py"
    },
    {
        "api_name": "control",
        "full_api_name": "SwapGate.control",
        "api_description": "Return a (multi-)controlled-SWAP gate.\n\nOne control returns a CSWAP (Fredkin) gate.\n\nArgs:\n    num_ctrl_qubits: number of control qubits.\n    label: An optional label for the gate [Default: ``None``]\n    ctrl_state: control state expressed as integer,\n        string (e.g.``'110'``), or ``None``. If ``None``, use all 1s.\n    annotated: indicates whether the controlled gate should be implemented\n        as an annotated gate. If ``None``, this is handled as ``False``.\n\nReturns:\n    ControlledGate: controlled version of this gate.",
        "api_signature": "control(self, num_ctrl_qubits, label, ctrl_state, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/swap.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "SwapGate.inverse",
        "api_description": "Return inverse Swap gate (itself).\n\nArgs:\n    annotated: when set to ``True``, this is typically used to return an\n        :class:`.AnnotatedOperation` with an inverse modifier set instead of a concrete\n        :class:`.Gate`. However, for this class this argument is ignored as this gate\n        is self-inverse.\n\nReturns:\n    SwapGate: inverse gate (self-inverse).",
        "api_signature": "inverse(self, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/swap.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "SwapGate.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/swap.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CSwapGate.__init__",
        "api_description": "Create new CSWAP gate.",
        "api_signature": "__init__(self, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/swap.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "CSwapGate._define",
        "api_description": "gate cswap a,b,c\n{ cx c,b;\n  ccx a,b,c;\n  cx c,b;\n}",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/swap.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "CSwapGate.inverse",
        "api_description": "Return inverse CSwap gate (itself).\n\nArgs:\n    annotated: when set to ``True``, this is typically used to return an\n        :class:`.AnnotatedOperation` with an inverse modifier set instead of a concrete\n        :class:`.Gate`. However, for this class this argument is ignored as this gate\n        is self-inverse.\n\nReturns:\n    CSwapGate: inverse gate (self-inverse).",
        "api_signature": "inverse(self, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/swap.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "CSwapGate.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/swap.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "U3Gate.__init__",
        "api_description": "Create new U3 gate.",
        "api_signature": "__init__(self, theta, phi, lam, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u3.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "U3Gate.inverse",
        "api_description": "Return inverted U3 gate.\n\n:math:`U3(\\theta,\\phi,\\lambda)^{\\dagger} =U3(-\\theta,-\\lambda,-\\phi))`\n\nArgs:\n    annotated: when set to ``True``, this is typically used to return an\n        :class:`.AnnotatedOperation` with an inverse modifier set instead of a concrete\n        :class:`.Gate`. However, for this class this argument is ignored as the inverse\n        of this gate is always a :class:`.U3Gate` with inverse parameter values.\n\nReturns:\n    U3Gate: inverse gate.",
        "api_signature": "inverse(self, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u3.py"
    },
    {
        "api_name": "control",
        "full_api_name": "U3Gate.control",
        "api_description": "Return a (multi-)controlled-U3 gate.\n\nArgs:\n    num_ctrl_qubits: number of control qubits.\n    label: An optional label for the gate [Default: ``None``]\n    ctrl_state: control state expressed as integer,\n        string (e.g.``'110'``), or ``None``. If ``None``, use all 1s.\n    annotated: indicates whether the controlled gate should be implemented\n        as an annotated gate. If ``None``, this is set to ``True`` if\n        the gate contains free parameters and more than one control qubit, in which\n        case it cannot yet be synthesized. Otherwise it is set to ``False``.\n\nReturns:\n    ControlledGate: controlled version of this gate.",
        "api_signature": "control(self, num_ctrl_qubits, label, ctrl_state, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u3.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "U3Gate._define",
        "api_description": "",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u3.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "U3Gate.__array__",
        "api_description": "Return a Numpy.array for the U3 gate.",
        "api_signature": "__array__(self, dtype, copy)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u3.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CU3Gate.__init__",
        "api_description": "Create new CU3 gate.",
        "api_signature": "__init__(self, theta, phi, lam, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u3.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "CU3Gate._define",
        "api_description": "gate cu3(theta,phi,lambda) c, t\n{ u1((lambda+phi)/2) c;\n  u1((lambda-phi)/2) t;\n  cx c,t;\n  u3(-theta/2,0,-(phi+lambda)/2) t;\n  cx c,t;\n  u3(theta/2,phi,0) t;\n}",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u3.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "CU3Gate.inverse",
        "api_description": "Return inverted CU3 gate.\n\n:math:`CU3(\\theta,\\phi,\\lambda)^{\\dagger} =CU3(-\\theta,-\\phi,-\\lambda))`\n\nArgs:\n    annotated: when set to ``True``, this is typically used to return an\n        :class:`.AnnotatedOperation` with an inverse modifier set instead of a concrete\n        :class:`.Gate`. However, for this class this argument is ignored as the inverse\n        of this gate is always a :class:`.CU3Gate` with inverse\n        parameter values.\n\nReturns:\n    CU3Gate: inverse gate.",
        "api_signature": "inverse(self, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u3.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "CU3Gate.__array__",
        "api_description": "Return a numpy.array for the CU3 gate.",
        "api_signature": "__array__(self, dtype, copy)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u3.py"
    },
    {
        "api_name": "_generate_gray_code",
        "full_api_name": "_generate_gray_code",
        "api_description": "Generate the gray code for ``num_bits`` bits.",
        "api_signature": "_generate_gray_code(num_bits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u3.py"
    },
    {
        "api_name": "_gray_code_chain",
        "full_api_name": "_gray_code_chain",
        "api_description": "Apply the gate to the last qubit in the register ``q``, controlled on all\npreceding qubits. This function uses the gray code to propagate down to the last qubit.\n\nPorted and adapted from Aqua (github.com/Qiskit/qiskit-aqua),\ncommit 769ca8d, file qiskit/aqua/circuits/gates/multi_control_u1_gate.py.",
        "api_signature": "_gray_code_chain(q, num_ctrl_qubits, gate)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/u3.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "TGate.__init__",
        "api_description": "Create new T gate.",
        "api_signature": "__init__(self, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/t.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "TGate._define",
        "api_description": "gate t a { u1(pi/4) a; }",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/t.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "TGate.inverse",
        "api_description": "Return inverse T gate (i.e. Tdg).\n\nArgs:\n    annotated: when set to ``True``, this is typically used to return an\n        :class:`.AnnotatedOperation` with an inverse modifier set instead of a concrete\n        :class:`.Gate`. However, for this class this argument is ignored as the inverse\n        of this gate is always a :class:`.TdgGate`.\n\nReturns:\n    TdgGate: inverse of :class:`.TGate`",
        "api_signature": "inverse(self, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/t.py"
    },
    {
        "api_name": "power",
        "full_api_name": "TGate.power",
        "api_description": "",
        "api_signature": "power(self, exponent, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/t.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "TGate.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/t.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "TdgGate.__init__",
        "api_description": "Create new Tdg gate.",
        "api_signature": "__init__(self, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/t.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "TdgGate._define",
        "api_description": "gate tdg a { u1(pi/4) a; }",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/t.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "TdgGate.inverse",
        "api_description": "Return inverse Tdg gate (i.e. T).\n\nArgs:\n    annotated: when set to ``True``, this is typically used to return an\n        :class:`.AnnotatedOperation` with an inverse modifier set instead of a concrete\n        :class:`.Gate`. However, for this class this argument is ignored as the inverse\n        of this gate is always a :class:`.TGate`.\n\nReturns:\n    TGate: inverse of :class:`.TdgGate`",
        "api_signature": "inverse(self, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/t.py"
    },
    {
        "api_name": "power",
        "full_api_name": "TdgGate.power",
        "api_description": "",
        "api_signature": "power(self, exponent, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/t.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "TdgGate.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/t.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "IGate.__init__",
        "api_description": "Create new Identity gate.",
        "api_signature": "__init__(self, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/i.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "IGate.inverse",
        "api_description": "Returne the inverse gate (itself).\n\nArgs:\n    annotated: when set to ``True``, this is typically used to return an\n        :class:`.AnnotatedOperation` with an inverse modifier set instead of a concrete\n        :class:`.Gate`. However, for this class this argument is ignored as this gate\n        is self-inverse.\n\nReturns:\n    IGate: inverse gate (self-inverse).\n.",
        "api_signature": "inverse(self, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/i.py"
    },
    {
        "api_name": "power",
        "full_api_name": "IGate.power",
        "api_description": "",
        "api_signature": "power(self, exponent, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/i.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "IGate.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/i.py"
    },
    {
        "api_name": "get_standard_gate_name_mapping",
        "full_api_name": "get_standard_gate_name_mapping",
        "api_description": "Return a dictionary mapping the name of standard gates and instructions to an object for\nthat name.",
        "api_signature": "get_standard_gate_name_mapping()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/__init__.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "RZXGate.__init__",
        "api_description": "Create new RZX gate.",
        "api_signature": "__init__(self, theta, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rzx.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "RZXGate._define",
        "api_description": "gate rzx(theta) a, b { h b; cx a, b; u1(theta) b; cx a, b; h b;}",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rzx.py"
    },
    {
        "api_name": "control",
        "full_api_name": "RZXGate.control",
        "api_description": "Return a (multi-)controlled-RZX gate.\n\nArgs:\n    num_ctrl_qubits: number of control qubits.\n    label: An optional label for the gate [Default: ``None``]\n    ctrl_state: control state expressed as integer,\n        string (e.g.``'110'``), or ``None``. If ``None``, use all 1s.\n    annotated: indicates whether the controlled gate should be implemented\n        as an annotated gate. If ``None``, this is set to ``True`` if\n        the gate contains free parameters, in which case it cannot\n        yet be synthesized.\n\nReturns:\n    ControlledGate: controlled version of this gate.",
        "api_signature": "control(self, num_ctrl_qubits, label, ctrl_state, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rzx.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "RZXGate.inverse",
        "api_description": "Return inverse RZX gate (i.e. with the negative rotation angle).\n\nArgs:\n    annotated: when set to ``True``, this is typically used to return an\n        :class:`.AnnotatedOperation` with an inverse modifier set instead of a concrete\n        :class:`.Gate`. However, for this class this argument is ignored as the inverse\n        of this gate is always a :class:`.RZXGate` with an inverted parameter value.\n\n Returns:\n    RZXGate: inverse gate.",
        "api_signature": "inverse(self, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rzx.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "RZXGate.__array__",
        "api_description": "Return a numpy.array for the RZX gate.",
        "api_signature": "__array__(self, dtype, copy)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rzx.py"
    },
    {
        "api_name": "power",
        "full_api_name": "RZXGate.power",
        "api_description": "",
        "api_signature": "power(self, exponent, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rzx.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "RZXGate.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rzx.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SXGate.__init__",
        "api_description": "Create new SX gate.",
        "api_signature": "__init__(self, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/sx.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "SXGate._define",
        "api_description": "gate sx a { rz(-pi/2) a; h a; rz(-pi/2); }",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/sx.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "SXGate.inverse",
        "api_description": "Return inverse SX gate (i.e. SXdg).\n\nArgs:\n    annotated: when set to ``True``, this is typically used to return an\n        :class:`.AnnotatedOperation` with an inverse modifier set instead of a concrete\n        :class:`.Gate`. However, for this class this argument is ignored as the inverse\n        of this gate is always a :class:`.SXdgGate`.\n\nReturns:\n    SXdgGate: inverse of :class:`.SXGate`.",
        "api_signature": "inverse(self, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/sx.py"
    },
    {
        "api_name": "control",
        "full_api_name": "SXGate.control",
        "api_description": "Return a (multi-)controlled-SX gate.\n\nOne control returns a CSX gate.\n\nArgs:\n    num_ctrl_qubits: number of control qubits.\n    label: An optional label for the gate [Default: ``None``]\n    ctrl_state: control state expressed as integer,\n        string (e.g.``'110'``), or ``None``. If ``None``, use all 1s.\n    annotated: indicates whether the controlled gate should be implemented\n        as an annotated gate. If ``None``, this is handled as ``False``.\n\nReturns:\n    SingletonControlledGate: controlled version of this gate.",
        "api_signature": "control(self, num_ctrl_qubits, label, ctrl_state, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/sx.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "SXGate.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/sx.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SXdgGate.__init__",
        "api_description": "Create new SXdg gate.",
        "api_signature": "__init__(self, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/sx.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "SXdgGate._define",
        "api_description": "gate sxdg a { rz(pi/2) a; h a; rz(pi/2); }",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/sx.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "SXdgGate.inverse",
        "api_description": "Return inverse SXdg gate (i.e. SX).\n\nArgs:\n    annotated: when set to ``True``, this is typically used to return an\n        :class:`.AnnotatedOperation` with an inverse modifier set instead of a concrete\n        :class:`.Gate`. However, for this class this argument is ignored as the inverse\n        of this gate is always a :class:`.SXGate`.\n\nReturns:\n    SXGate: inverse of :class:`.SXdgGate`",
        "api_signature": "inverse(self, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/sx.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "SXdgGate.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/sx.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CSXGate.__init__",
        "api_description": "Create new CSX gate.",
        "api_signature": "__init__(self, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/sx.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "CSXGate._define",
        "api_description": "gate csx a,b { h b; cu1(pi/2) a,b; h b; }",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/sx.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "CSXGate.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/sx.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "XXMinusYYGate.__init__",
        "api_description": "Create new XX-YY gate.\n\nArgs:\n    theta: The rotation angle.\n    beta: The phase angle.\n    label: The label of the gate.",
        "api_signature": "__init__(self, theta, beta, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/xx_minus_yy.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "XXMinusYYGate._define",
        "api_description": "gate xx_minus_yy(theta, beta) a, b {\n    rz(-beta) b;\n    rz(-pi/2) a;\n    sx a;\n    rz(pi/2) a;\n    s b;\n    cx a, b;\n    ry(theta/2) a;\n    ry(-theta/2) b;\n    cx a, b;\n    sdg b;\n    rz(-pi/2) a;\n    sxdg a;\n    rz(pi/2) a;\n    rz(beta) b;\n}",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/xx_minus_yy.py"
    },
    {
        "api_name": "control",
        "full_api_name": "XXMinusYYGate.control",
        "api_description": "Return a (multi-)controlled-(XX-YY) gate.\n\nArgs:\n    num_ctrl_qubits: number of control qubits.\n    label: An optional label for the gate [Default: ``None``]\n    ctrl_state: control state expressed as integer,\n        string (e.g.``'110'``), or ``None``. If ``None``, use all 1s.\n    annotated: indicates whether the controlled gate should be implemented\n        as an annotated gate. If ``None``, this is set to ``True`` if\n        the gate contains free parameters, in which case it cannot\n        yet be synthesized.\n\nReturns:\n    ControlledGate: controlled version of this gate.",
        "api_signature": "control(self, num_ctrl_qubits, label, ctrl_state, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/xx_minus_yy.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "XXMinusYYGate.inverse",
        "api_description": "Inverse gate.\n\nArgs:\n    annotated: when set to ``True``, this is typically used to return an\n        :class:`.AnnotatedOperation` with an inverse modifier set instead of a concrete\n        :class:`.Gate`. However, for this class this argument is ignored as the inverse\n        of this gate is always a :class:`.XXMinusYYGate` with inverse\n        parameter values.\n\nReturns:\n    XXMinusYYGate: inverse gate.",
        "api_signature": "inverse(self, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/xx_minus_yy.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "XXMinusYYGate.__array__",
        "api_description": "Gate matrix.",
        "api_signature": "__array__(self, dtype, copy)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/xx_minus_yy.py"
    },
    {
        "api_name": "power",
        "full_api_name": "XXMinusYYGate.power",
        "api_description": "",
        "api_signature": "power(self, exponent, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/xx_minus_yy.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "XXMinusYYGate.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/xx_minus_yy.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ECRGate.__init__",
        "api_description": "Create new ECR gate.",
        "api_signature": "__init__(self, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/ecr.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "ECRGate._define",
        "api_description": "gate ecr a, b { rzx(pi/4) a, b; x a; rzx(-pi/4) a, b;}",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/ecr.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "ECRGate.inverse",
        "api_description": "Return inverse ECR gate (itself).\n\nArgs:\n    annotated: when set to ``True``, this is typically used to return an\n        :class:`.AnnotatedOperation` with an inverse modifier set instead of a concrete\n        :class:`.Gate`. However, for this class this argument is ignored as this gate\n        is self-inverse.\n\nReturns:\n    ECRGate: inverse gate (self-inverse).",
        "api_signature": "inverse(self, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/ecr.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "ECRGate.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/ecr.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "YGate.__init__",
        "api_description": "Create new Y gate.",
        "api_signature": "__init__(self, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/y.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "YGate._define",
        "api_description": "",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/y.py"
    },
    {
        "api_name": "control",
        "full_api_name": "YGate.control",
        "api_description": "Return a (multi-)controlled-Y gate.\n\nOne control returns a CY gate.\n\nArgs:\n    num_ctrl_qubits: number of control qubits.\n    label: An optional label for the gate [Default: ``None``]\n    ctrl_state: control state expressed as integer,\n        string (e.g.``'110'``), or ``None``. If ``None``, use all 1s.\n    annotated: indicates whether the controlled gate should be implemented\n        as an annotated gate.\n\nReturns:\n    ControlledGate: controlled version of this gate.",
        "api_signature": "control(self, num_ctrl_qubits, label, ctrl_state, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/y.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "YGate.inverse",
        "api_description": "Return inverted Y gate (:math:`Y^{\\dagger} = Y`)\n\nArgs:\n    annotated: when set to ``True``, this is typically used to return an\n        :class:`.AnnotatedOperation` with an inverse modifier set instead of a concrete\n        :class:`.Gate`. However, for this class this argument is ignored as this gate\n        is self-inverse.\n\nReturns:\n    YGate: inverse gate (self-inverse).",
        "api_signature": "inverse(self, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/y.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "YGate.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/y.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CYGate.__init__",
        "api_description": "Create new CY gate.",
        "api_signature": "__init__(self, label, ctrl_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/y.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "CYGate._define",
        "api_description": "gate cy a,b { sdg b; cx a,b; s b; }",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/y.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "CYGate.inverse",
        "api_description": "Return inverted CY gate (itself).\n\nArgs:\n    annotated: when set to ``True``, this is typically used to return an\n        :class:`.AnnotatedOperation` with an inverse modifier set instead of a concrete\n        :class:`.Gate`. However, for this class this argument is ignored as this gate\n        is self-inverse.\n\nReturns:\n    CYGate: inverse gate (self-inverse).",
        "api_signature": "inverse(self, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/y.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "CYGate.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/y.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "RXXGate.__init__",
        "api_description": "Create new RXX gate.",
        "api_signature": "__init__(self, theta, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rxx.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "RXXGate._define",
        "api_description": "Calculate a subcircuit that implements this unitary.",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rxx.py"
    },
    {
        "api_name": "control",
        "full_api_name": "RXXGate.control",
        "api_description": "Return a (multi-)controlled-RXX gate.\n\nArgs:\n    num_ctrl_qubits: number of control qubits.\n    label: An optional label for the gate [Default: ``None``]\n    ctrl_state: control state expressed as integer,\n        string (e.g.``'110'``), or ``None``. If ``None``, use all 1s.\n    annotated: indicates whether the controlled gate should be implemented\n        as an annotated gate. If ``None``, this is set to ``True`` if\n        the gate contains free parameters, in which case it cannot\n        yet be synthesized.\n\nReturns:\n    ControlledGate: controlled version of this gate.",
        "api_signature": "control(self, num_ctrl_qubits, label, ctrl_state, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rxx.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "RXXGate.inverse",
        "api_description": "Return inverse RXX gate (i.e. with the negative rotation angle).\n\nArgs:\n    annotated: when set to ``True``, this is typically used to return an\n        :class:`.AnnotatedOperation` with an inverse modifier set instead of a concrete\n        :class:`.Gate`. However, for this class this argument is ignored as the inverse\n        of this gate is always a :class:`.RXXGate` with an inverted parameter value.\n\nReturns:\n    RXXGate: inverse gate.",
        "api_signature": "inverse(self, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rxx.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "RXXGate.__array__",
        "api_description": "Return a Numpy.array for the RXX gate.",
        "api_signature": "__array__(self, dtype, copy)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rxx.py"
    },
    {
        "api_name": "power",
        "full_api_name": "RXXGate.power",
        "api_description": "",
        "api_signature": "power(self, exponent, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rxx.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "RXXGate.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/rxx.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "XXPlusYYGate.__init__",
        "api_description": "Create new XX+YY gate.\n\nArgs:\n    theta: The rotation angle.\n    beta: The phase angle.\n    label: The label of the gate.",
        "api_signature": "__init__(self, theta, beta, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/xx_plus_yy.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "XXPlusYYGate._define",
        "api_description": "gate xx_plus_yy(theta, beta) a, b {\n    rz(beta) b;\n    rz(-pi/2) a;\n    sx a;\n    rz(pi/2) a;\n    s b;\n    cx a, b;\n    ry(theta/2) a;\n    ry(theta/2) b;\n    cx a, b;\n    sdg b;\n    rz(-pi/2) a;\n    sxdg a;\n    rz(pi/2) a;\n    rz(-beta) b;\n}",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/xx_plus_yy.py"
    },
    {
        "api_name": "control",
        "full_api_name": "XXPlusYYGate.control",
        "api_description": "Return a (multi-)controlled-(XX+YY) gate.\n\nArgs:\n    num_ctrl_qubits: number of control qubits.\n    label: An optional label for the gate [Default: ``None``]\n    ctrl_state: control state expressed as integer,\n        string (e.g.``'110'``), or ``None``. If ``None``, use all 1s.\n    annotated: indicates whether the controlled gate should be implemented\n        as an annotated gate. If ``None``, this is set to ``True`` if\n        the gate contains free parameters, in which case it cannot\n        yet be synthesized.\n\nReturns:\n    ControlledGate: controlled version of this gate.",
        "api_signature": "control(self, num_ctrl_qubits, label, ctrl_state, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/xx_plus_yy.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "XXPlusYYGate.inverse",
        "api_description": "Return inverse XX+YY gate (i.e. with the negative rotation angle and same phase angle).\n\nArgs:\n    annotated: when set to ``True``, this is typically used to return an\n        :class:`.AnnotatedOperation` with an inverse modifier set instead of a concrete\n        :class:`.Gate`. However, for this class this argument is ignored as the inverse\n        of this gate is always a :class:`.XXPlusYYGate` with inverse\n        parameter values.\n\nReturns:\n    XXPlusYYGate: inverse gate.",
        "api_signature": "inverse(self, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/xx_plus_yy.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "XXPlusYYGate.__array__",
        "api_description": "Return a numpy.array for the XX+YY gate.",
        "api_signature": "__array__(self, dtype, copy)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/xx_plus_yy.py"
    },
    {
        "api_name": "power",
        "full_api_name": "XXPlusYYGate.power",
        "api_description": "",
        "api_signature": "power(self, exponent, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/xx_plus_yy.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "XXPlusYYGate.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/standard_gates/xx_plus_yy.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QFT.__init__",
        "api_description": "Construct a new QFT circuit.\n\nArgs:\n    num_qubits: The number of qubits on which the QFT acts.\n    approximation_degree: The degree of approximation (0 for no approximation).\n    do_swaps: Whether to include the final swaps in the QFT.\n    inverse: If True, the inverse Fourier transform is constructed.\n    insert_barriers: If True, barriers are inserted as visualization improvement.\n    name: The name of the circuit.",
        "api_signature": "__init__(self, num_qubits, approximation_degree, do_swaps, inverse, insert_barriers, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/basis_change/qft.py"
    },
    {
        "api_name": "num_qubits",
        "full_api_name": "QFT.num_qubits",
        "api_description": "The number of qubits in the QFT circuit.\n\nReturns:\n    The number of qubits in the circuit.",
        "api_signature": "num_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/basis_change/qft.py"
    },
    {
        "api_name": "num_qubits",
        "full_api_name": "QFT.num_qubits",
        "api_description": "Set the number of qubits.\n\nNote that this changes the registers of the circuit.\n\nArgs:\n    num_qubits: The new number of qubits.",
        "api_signature": "num_qubits(self, num_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/basis_change/qft.py"
    },
    {
        "api_name": "approximation_degree",
        "full_api_name": "QFT.approximation_degree",
        "api_description": "The approximation degree of the QFT.\n\nReturns:\n    The currently set approximation degree.",
        "api_signature": "approximation_degree(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/basis_change/qft.py"
    },
    {
        "api_name": "approximation_degree",
        "full_api_name": "QFT.approximation_degree",
        "api_description": "Set the approximation degree of the QFT.\n\nArgs:\n    approximation_degree: The new approximation degree.\n\nRaises:\n    ValueError: If the approximation degree is smaller than 0.",
        "api_signature": "approximation_degree(self, approximation_degree)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/basis_change/qft.py"
    },
    {
        "api_name": "insert_barriers",
        "full_api_name": "QFT.insert_barriers",
        "api_description": "Whether barriers are inserted for better visualization or not.\n\nReturns:\n    True, if barriers are inserted, False if not.",
        "api_signature": "insert_barriers(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/basis_change/qft.py"
    },
    {
        "api_name": "insert_barriers",
        "full_api_name": "QFT.insert_barriers",
        "api_description": "Specify whether barriers are inserted for better visualization or not.\n\nArgs:\n    insert_barriers: If True, barriers are inserted, if False not.",
        "api_signature": "insert_barriers(self, insert_barriers)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/basis_change/qft.py"
    },
    {
        "api_name": "do_swaps",
        "full_api_name": "QFT.do_swaps",
        "api_description": "Whether the final swaps of the QFT are applied or not.\n\nReturns:\n    True, if the final swaps are applied, False if not.",
        "api_signature": "do_swaps(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/basis_change/qft.py"
    },
    {
        "api_name": "do_swaps",
        "full_api_name": "QFT.do_swaps",
        "api_description": "Specify whether to do the final swaps of the QFT circuit or not.\n\nArgs:\n    do_swaps: If True, the final swaps are applied, if False not.",
        "api_signature": "do_swaps(self, do_swaps)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/basis_change/qft.py"
    },
    {
        "api_name": "is_inverse",
        "full_api_name": "QFT.is_inverse",
        "api_description": "Whether the inverse Fourier transform is implemented.\n\nReturns:\n    True, if the inverse Fourier transform is implemented, False otherwise.",
        "api_signature": "is_inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/basis_change/qft.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "QFT.inverse",
        "api_description": "Invert this circuit.\n\nArgs:\n    annotated: indicates whether the inverse gate can be implemented\n        as an annotated gate. The value of this argument is ignored as the\n        inverse of a QFT is an IQFT which is just another instance of\n        :class:`.QFT`.\n\nReturns:\n    The inverted circuit.",
        "api_signature": "inverse(self, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/basis_change/qft.py"
    },
    {
        "api_name": "_warn_if_precision_loss",
        "full_api_name": "QFT._warn_if_precision_loss",
        "api_description": "Issue a warning if constructing the circuit will lose precision.\n\nIf we need an angle smaller than ``pi * 2**-1022``, we start to lose precision by going into\nthe subnormal numbers.  We won't lose _all_ precision until an exponent of about 1075, but\nbeyond 1022 we're using fractional bits to represent leading zeros.",
        "api_signature": "_warn_if_precision_loss(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/basis_change/qft.py"
    },
    {
        "api_name": "_check_configuration",
        "full_api_name": "QFT._check_configuration",
        "api_description": "Check if the current configuration is valid.",
        "api_signature": "_check_configuration(self, raise_on_failure)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/basis_change/qft.py"
    },
    {
        "api_name": "_build",
        "full_api_name": "QFT._build",
        "api_description": "If not already built, build the circuit.",
        "api_signature": "_build(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/basis_change/qft.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QFTGate.__init__",
        "api_description": "Args:\n    num_qubits: The number of qubits on which the QFT acts.",
        "api_signature": "__init__(self, num_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/basis_change/qft.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "QFTGate.__array__",
        "api_description": "Return a numpy array for the QFTGate.",
        "api_signature": "__array__(self, dtype)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/basis_change/qft.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "QFTGate._define",
        "api_description": "Provide a specific decomposition of the QFTGate into a quantum circuit.",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/basis_change/qft.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Initialize.__init__",
        "api_description": "Args:\n    params: The state to initialize to, can be either of the following.\n\n        * Statevector or vector of complex amplitudes to initialize to.\n        * Labels of basis states of the Pauli eigenstates Z, X, Y. See\n          :meth:`.Statevector.from_label`. Notice the order of the labels is reversed with\n          respect to the qubit index to be applied to. Example label '01' initializes the\n          qubit zero to :math:`|1\\rangle` and the qubit one to :math:`|0\\rangle`.\n        * An integer that is used as a bitmap indicating which qubits to initialize to\n          :math:`|1\\rangle`. Example: setting params to 5 would initialize qubit 0 and qubit\n          2 to :math:`|1\\rangle` and qubit 1 to :math:`|0\\rangle`.\n\n    num_qubits: This parameter is only used if params is an int. Indicates the total\n        number of qubits in the `initialize` call. Example: `initialize` covers 5 qubits\n        and params is 3. This allows qubits 0 and 1 to be initialized to :math:`|1\\rangle`\n        and the remaining 3 qubits to be initialized to :math:`|0\\rangle`.\n    normalize: Whether to normalize an input array to a unit vector.",
        "api_signature": "__init__(self, params, num_qubits, normalize)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/initializer.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "Initialize._define",
        "api_description": "",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/initializer.py"
    },
    {
        "api_name": "gates_to_uncompute",
        "full_api_name": "Initialize.gates_to_uncompute",
        "api_description": "Call to create a circuit with gates that take the desired vector to zero.\n\nReturns:\n    Circuit to take ``self.params`` vector to :math:`|{00\\ldots0}\\rangle`",
        "api_signature": "gates_to_uncompute(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/initializer.py"
    },
    {
        "api_name": "params",
        "full_api_name": "Initialize.params",
        "api_description": "Return initialize params.",
        "api_signature": "params(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/initializer.py"
    },
    {
        "api_name": "params",
        "full_api_name": "Initialize.params",
        "api_description": "Set initialize params.",
        "api_signature": "params(self, parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/initializer.py"
    },
    {
        "api_name": "broadcast_arguments",
        "full_api_name": "Initialize.broadcast_arguments",
        "api_description": "",
        "api_signature": "broadcast_arguments(self, qargs, cargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/initializer.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PauliFeatureMap.__init__",
        "api_description": "Create a new Pauli expansion circuit.\n\nArgs:\n    feature_dimension: Number of qubits in the circuit.\n    reps: The number of repeated circuits.\n    entanglement: Specifies the entanglement structure. Refer to\n        :class:`~qiskit.circuit.library.NLocal` for detail.\n    alpha: The Pauli rotation factor, multiplicative to the pauli rotations\n    paulis: A list of strings for to-be-used paulis. If None are provided, ``['Z', 'ZZ']``\n        will be used.\n    data_map_func: A mapping function for data x which can be supplied to override the\n        default mapping from :meth:`self_product`.\n    parameter_prefix: The prefix used if default parameters are generated.\n    insert_barriers: If True, barriers are inserted in between the evolution instructions\n        and hadamard layers.",
        "api_signature": "__init__(self, feature_dimension, reps, entanglement, alpha, paulis, data_map_func, parameter_prefix, insert_barriers, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/pauli_feature_map.py"
    },
    {
        "api_name": "_parameter_generator",
        "full_api_name": "PauliFeatureMap._parameter_generator",
        "api_description": "If certain blocks should use certain parameters this method can be overridden.",
        "api_signature": "_parameter_generator(self, rep, block, indices)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/pauli_feature_map.py"
    },
    {
        "api_name": "num_parameters_settable",
        "full_api_name": "PauliFeatureMap.num_parameters_settable",
        "api_description": "The number of distinct parameters.",
        "api_signature": "num_parameters_settable(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/pauli_feature_map.py"
    },
    {
        "api_name": "paulis",
        "full_api_name": "PauliFeatureMap.paulis",
        "api_description": "The Pauli strings used in the entanglement of the qubits.\n\nReturns:\n    The Pauli strings as list.",
        "api_signature": "paulis(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/pauli_feature_map.py"
    },
    {
        "api_name": "paulis",
        "full_api_name": "PauliFeatureMap.paulis",
        "api_description": "Set the pauli strings.\n\nArgs:\n    paulis: The new pauli strings.",
        "api_signature": "paulis(self, paulis)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/pauli_feature_map.py"
    },
    {
        "api_name": "alpha",
        "full_api_name": "PauliFeatureMap.alpha",
        "api_description": "The Pauli rotation factor (alpha).\n\nReturns:\n    The Pauli rotation factor.",
        "api_signature": "alpha(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/pauli_feature_map.py"
    },
    {
        "api_name": "alpha",
        "full_api_name": "PauliFeatureMap.alpha",
        "api_description": "Set the Pauli rotation factor (alpha).\n\nArgs:\n    alpha: Pauli rotation factor",
        "api_signature": "alpha(self, alpha)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/pauli_feature_map.py"
    },
    {
        "api_name": "entanglement_blocks",
        "full_api_name": "PauliFeatureMap.entanglement_blocks",
        "api_description": "",
        "api_signature": "entanglement_blocks(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/pauli_feature_map.py"
    },
    {
        "api_name": "entanglement_blocks",
        "full_api_name": "PauliFeatureMap.entanglement_blocks",
        "api_description": "",
        "api_signature": "entanglement_blocks(self, entanglement_blocks)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/pauli_feature_map.py"
    },
    {
        "api_name": "feature_dimension",
        "full_api_name": "PauliFeatureMap.feature_dimension",
        "api_description": "Returns the feature dimension (which is equal to the number of qubits).\n\nReturns:\n    The feature dimension of this feature map.",
        "api_signature": "feature_dimension(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/pauli_feature_map.py"
    },
    {
        "api_name": "feature_dimension",
        "full_api_name": "PauliFeatureMap.feature_dimension",
        "api_description": "Set the feature dimension.\n\nArgs:\n    feature_dimension: The new feature dimension.",
        "api_signature": "feature_dimension(self, feature_dimension)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/pauli_feature_map.py"
    },
    {
        "api_name": "_extract_data_for_rotation",
        "full_api_name": "PauliFeatureMap._extract_data_for_rotation",
        "api_description": "",
        "api_signature": "_extract_data_for_rotation(self, pauli, x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/pauli_feature_map.py"
    },
    {
        "api_name": "pauli_block",
        "full_api_name": "PauliFeatureMap.pauli_block",
        "api_description": "Get the Pauli block for the feature map circuit.",
        "api_signature": "pauli_block(self, pauli_string)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/pauli_feature_map.py"
    },
    {
        "api_name": "pauli_evolution",
        "full_api_name": "PauliFeatureMap.pauli_evolution",
        "api_description": "Get the evolution block for the given pauli string.",
        "api_signature": "pauli_evolution(self, pauli_string, time)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/pauli_feature_map.py"
    },
    {
        "api_name": "basis_change",
        "full_api_name": "PauliFeatureMap.basis_change",
        "api_description": "",
        "api_signature": "basis_change(circuit, inverse)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/pauli_feature_map.py"
    },
    {
        "api_name": "cx_chain",
        "full_api_name": "PauliFeatureMap.cx_chain",
        "api_description": "",
        "api_signature": "cx_chain(circuit, inverse)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/pauli_feature_map.py"
    },
    {
        "api_name": "self_product",
        "full_api_name": "self_product",
        "api_description": "Define a function map from R^n to R.\n\nArgs:\n    x: data\n\nReturns:\n    float: the mapped value",
        "api_signature": "self_product(x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/pauli_feature_map.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "StatePreparation.__init__",
        "api_description": "Args:\n    params:\n        * Statevector: Statevector to initialize to.\n        * list: vector of complex amplitudes to initialize to.\n        * string: labels of basis states of the Pauli eigenstates Z, X, Y. See\n          :meth:`.Statevector.from_label`.\n          Notice the order of the labels is reversed with respect to the qubit index to\n          be applied to. Example label '01' initializes the qubit zero to :math:`|1\\rangle`\n          and the qubit one to :math:`|0\\rangle`.\n        * int: an integer that is used as a bitmap indicating which qubits to initialize\n          to :math:`|1\\rangle`. Example: setting params to 5 would initialize qubit 0 and qubit 2\n          to :math:`|1\\rangle` and qubit 1 to :math:`|0\\rangle`.\n    num_qubits: This parameter is only used if params is an int. Indicates the total\n        number of qubits in the `initialize` call. Example: `initialize` covers 5 qubits\n        and params is 3. This allows qubits 0 and 1 to be initialized to :math:`|1\\rangle`\n        and the remaining 3 qubits to be initialized to :math:`|0\\rangle`.\n    inverse: if True, the inverse state is constructed.\n    label: An optional label for the gate\n    normalize (bool): Whether to normalize an input array to a unit vector.\n\nRaises:\n    QiskitError: ``num_qubits`` parameter used when ``params`` is not an integer\n\nWhen a Statevector argument is passed the state is prepared based on the\n:class:`~.library.Isometry` synthesis described in [1].\n\nReferences:\n    1. Iten et al., Quantum circuits for isometries (2016).\n       `Phys. Rev. A 93, 032318\n       <https://journals.aps.org/pra/abstract/10.1103/PhysRevA.93.032318>`__.",
        "api_signature": "__init__(self, params, num_qubits, inverse, label, normalize)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/state_preparation.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "StatePreparation._define",
        "api_description": "",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/state_preparation.py"
    },
    {
        "api_name": "_define_from_label",
        "full_api_name": "StatePreparation._define_from_label",
        "api_description": "",
        "api_signature": "_define_from_label(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/state_preparation.py"
    },
    {
        "api_name": "_define_from_int",
        "full_api_name": "StatePreparation._define_from_int",
        "api_description": "",
        "api_signature": "_define_from_int(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/state_preparation.py"
    },
    {
        "api_name": "_define_synthesis_isom",
        "full_api_name": "StatePreparation._define_synthesis_isom",
        "api_description": "Calculate a subcircuit that implements this initialization via isometry",
        "api_signature": "_define_synthesis_isom(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/state_preparation.py"
    },
    {
        "api_name": "_get_num_qubits",
        "full_api_name": "StatePreparation._get_num_qubits",
        "api_description": "Get number of qubits needed for state preparation",
        "api_signature": "_get_num_qubits(self, num_qubits, params)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/state_preparation.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "StatePreparation.inverse",
        "api_description": "Return inverted StatePreparation",
        "api_signature": "inverse(self, annotated)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/state_preparation.py"
    },
    {
        "api_name": "broadcast_arguments",
        "full_api_name": "StatePreparation.broadcast_arguments",
        "api_description": "",
        "api_signature": "broadcast_arguments(self, qargs, cargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/state_preparation.py"
    },
    {
        "api_name": "validate_parameter",
        "full_api_name": "StatePreparation.validate_parameter",
        "api_description": "StatePreparation instruction parameter can be str, int, float, and complex.",
        "api_signature": "validate_parameter(self, parameter)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/state_preparation.py"
    },
    {
        "api_name": "_return_repeat",
        "full_api_name": "StatePreparation._return_repeat",
        "api_description": "",
        "api_signature": "_return_repeat(self, exponent)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/state_preparation.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "UniformSuperpositionGate.__init__",
        "api_description": "Args:\n    num_superpos_states (int):\n        A positive integer M = num_superpos_states (> 1) representing the number of computational\n        basis states with an amplitude of 1/sqrt(M) in the uniform superposition\n        state (:math:`\\frac{1}{\\sqrt{M}} \\sum_{j=0}^{M-1}  |j\\rangle`, where\n        :math:`1< M <= 2^n`). Note that the remaining (:math:`2^n - M`) computational basis\n        states have zero amplitudes. Here M need not be an integer power of 2.\n\n    num_qubits (int):\n        A positive integer representing the number of qubits used.  If num_qubits is None\n        or is not specified, then num_qubits is set to ceil(log2(num_superpos_states)).\n\nRaises:\n    ValueError: num_qubits must be an integer greater than or equal to log2(num_superpos_states).",
        "api_signature": "__init__(self, num_superpos_states, num_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/state_preparation.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "UniformSuperpositionGate._define",
        "api_description": "",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/state_preparation.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ZZFeatureMap.__init__",
        "api_description": "Create a new second-order Pauli-Z expansion.\n\nArgs:\n    feature_dimension: Number of features.\n    reps: The number of repeated circuits, has a min. value of 1.\n    entanglement: Specifies the entanglement structure. Refer to\n        :class:`~qiskit.circuit.library.NLocal` for detail.\n    data_map_func: A mapping function for data x.\n    parameter_prefix: The prefix used if default parameters are generated.\n    insert_barriers: If True, barriers are inserted in between the evolution instructions\n        and hadamard layers.\n\nRaises:\n    ValueError: If the feature dimension is smaller than 2.",
        "api_signature": "__init__(self, feature_dimension, reps, entanglement, data_map_func, parameter_prefix, insert_barriers, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/zz_feature_map.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ZFeatureMap.__init__",
        "api_description": "Create a new first-order Pauli-Z expansion circuit.\n\nArgs:\n    feature_dimension: The number of features\n    reps: The number of repeated circuits. Defaults to 2, has a minimum value of 1.\n    data_map_func: A mapping function for data x which can be supplied to override the\n        default mapping from :meth:`self_product`.\n    parameter_prefix: The prefix used if default parameters are generated.\n    insert_barriers: If True, barriers are inserted in between the evolution instructions\n        and hadamard layers.",
        "api_signature": "__init__(self, feature_dimension, reps, data_map_func, parameter_prefix, insert_barriers, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/data_preparation/z_feature_map.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "OR.__init__",
        "api_description": "Create a new logical OR circuit.\n\nArgs:\n    num_variable_qubits: The qubits of which the OR is computed. The result will be written\n        into an additional result qubit.\n    flags: A list of +1/0/-1 marking negations or omissions of qubits.\n    mcx_mode: The mode to be used to implement the multi-controlled X gate.",
        "api_signature": "__init__(self, num_variable_qubits, flags, mcx_mode)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/boolean_logic/quantum_or.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "AND.__init__",
        "api_description": "Create a new logical AND circuit.\n\nArgs:\n    num_variable_qubits: The qubits of which the OR is computed. The result will be written\n        into an additional result qubit.\n    flags: A list of +1/0/-1 marking negations or omissions of qubits.\n    mcx_mode: The mode to be used to implement the multi-controlled X gate.",
        "api_signature": "__init__(self, num_variable_qubits, flags, mcx_mode)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/boolean_logic/quantum_and.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "InnerProduct.__init__",
        "api_description": "Return a circuit to compute the inner product of 2 n-qubit registers.\n\nArgs:\n    num_qubits: width of top and bottom registers (half total circuit width)",
        "api_signature": "__init__(self, num_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/boolean_logic/inner_product.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "XOR.__init__",
        "api_description": "Return a circuit implementing bitwise xor.\n\nArgs:\n    num_qubits: the width of circuit.\n    amount: the xor amount in decimal form.\n    seed: random seed in case a random xor is requested.\n\nRaises:\n    CircuitError: if the xor bitstring exceeds available qubits.\n\nReference Circuit:\n    .. plot::\n\n       from qiskit.circuit.library import XOR\n       from qiskit.visualization.library import _generate_circuit_library_visualization\n       circuit = XOR(5, seed=42)\n       _generate_circuit_library_visualization(circuit)",
        "api_signature": "__init__(self, num_qubits, amount, seed)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/boolean_logic/quantum_xor.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "RealAmplitudes.__init__",
        "api_description": "Args:\n    num_qubits: The number of qubits of the RealAmplitudes circuit.\n    reps: Specifies how often the structure of a rotation layer followed by an entanglement\n        layer is repeated.\n    entanglement: Specifies the entanglement structure. Can be a string ('full', 'linear'\n        'reverse_linear, 'circular' or 'sca'), a list of integer-pairs specifying the indices\n        of qubits entangled with one another, or a callable returning such a list provided with\n        the index of the entanglement layer.\n        Default to 'reverse_linear' entanglement.\n        Note that 'reverse_linear' entanglement provides the same unitary as 'full'\n        with fewer entangling gates.\n        See the Examples section of :class:`~qiskit.circuit.library.TwoLocal` for more\n        detail.\n    initial_state: A `QuantumCircuit` object to prepend to the circuit.\n    skip_unentangled_qubits: If True, the single qubit gates are only applied to qubits\n        that are entangled with another qubit. If False, the single qubit gates are applied\n        to each qubit in the Ansatz. Defaults to False.\n    skip_final_rotation_layer: If False, a rotation layer is added at the end of the\n        ansatz. If True, no rotation layer is added.\n    parameter_prefix: The parameterized gates require a parameter to be defined, for which\n        we use :class:`~qiskit.circuit.ParameterVector`.\n    insert_barriers: If True, barriers are inserted in between each layer. If False,\n        no barriers are inserted.\n    flatten: Set this to ``True`` to output a flat circuit instead of nesting it inside multiple\n        layers of gate objects. By default currently the contents of\n        the output circuit will be wrapped in nested objects for\n        cleaner visualization. However, if you're using this circuit\n        for anything besides visualization its **strongly** recommended\n        to set this flag to ``True`` to avoid a large performance\n        overhead for parameter binding.",
        "api_signature": "__init__(self, num_qubits, entanglement, reps, skip_unentangled_qubits, skip_final_rotation_layer, parameter_prefix, insert_barriers, initial_state, name, flatten)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/real_amplitudes.py"
    },
    {
        "api_name": "parameter_bounds",
        "full_api_name": "RealAmplitudes.parameter_bounds",
        "api_description": "Return the parameter bounds.\n\nReturns:\n    The parameter bounds.",
        "api_signature": "parameter_bounds(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/real_amplitudes.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QAOAAnsatz.__init__",
        "api_description": "Args:\n    cost_operator (BaseOperator or OperatorBase, optional): The operator\n        representing the cost of the optimization problem, denoted as :math:`U(C, \\gamma)`\n        in the original paper. Must be set either in the constructor or via property setter.\n    reps (int): The integer parameter p, which determines the depth of the circuit,\n        as specified in the original paper, default is 1.\n    initial_state (QuantumCircuit, optional): An optional initial state to use.\n        If `None` is passed then a set of Hadamard gates is applied as an initial state\n        to all qubits.\n    mixer_operator (BaseOperator or OperatorBase or QuantumCircuit, optional): An optional\n        custom mixer to use instead of the global X-rotations, denoted as :math:`U(B, \\beta)`\n        in the original paper. Can be an operator or an optionally parameterized quantum\n        circuit.\n    name (str): A name of the circuit, default 'qaoa'\n    flatten: Set this to ``True`` to output a flat circuit instead of nesting it inside multiple\n        layers of gate objects. By default currently the contents of\n        the output circuit will be wrapped in nested objects for\n        cleaner visualization. However, if you're using this circuit\n        for anything besides visualization its **strongly** recommended\n        to set this flag to ``True`` to avoid a large performance\n        overhead for parameter binding.",
        "api_signature": "__init__(self, cost_operator, reps, initial_state, mixer_operator, name, flatten)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/qaoa_ansatz.py"
    },
    {
        "api_name": "_check_configuration",
        "full_api_name": "QAOAAnsatz._check_configuration",
        "api_description": "Check if the current configuration is valid.",
        "api_signature": "_check_configuration(self, raise_on_failure)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/qaoa_ansatz.py"
    },
    {
        "api_name": "parameter_bounds",
        "full_api_name": "QAOAAnsatz.parameter_bounds",
        "api_description": "The parameter bounds for the unbound parameters in the circuit.\n\nReturns:\n    A list of pairs indicating the bounds, as (lower, upper). None indicates an unbounded\n    parameter in the corresponding direction. If None is returned, problem is fully\n    unbounded.",
        "api_signature": "parameter_bounds(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/qaoa_ansatz.py"
    },
    {
        "api_name": "parameter_bounds",
        "full_api_name": "QAOAAnsatz.parameter_bounds",
        "api_description": "Set the parameter bounds.\n\nArgs:\n    bounds: The new parameter bounds.",
        "api_signature": "parameter_bounds(self, bounds)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/qaoa_ansatz.py"
    },
    {
        "api_name": "operators",
        "full_api_name": "QAOAAnsatz.operators",
        "api_description": "The operators that are evolved in this circuit.\n\nReturns:\n     List[Union[BaseOperator, OperatorBase, QuantumCircuit]]: The operators to be evolved\n        (and circuits) in this ansatz.",
        "api_signature": "operators(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/qaoa_ansatz.py"
    },
    {
        "api_name": "cost_operator",
        "full_api_name": "QAOAAnsatz.cost_operator",
        "api_description": "Returns an operator representing the cost of the optimization problem.\n\nReturns:\n    BaseOperator or OperatorBase: cost operator.",
        "api_signature": "cost_operator(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/qaoa_ansatz.py"
    },
    {
        "api_name": "cost_operator",
        "full_api_name": "QAOAAnsatz.cost_operator",
        "api_description": "Sets cost operator.\n\nArgs:\n    cost_operator (BaseOperator or OperatorBase, optional): cost operator to set.",
        "api_signature": "cost_operator(self, cost_operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/qaoa_ansatz.py"
    },
    {
        "api_name": "reps",
        "full_api_name": "QAOAAnsatz.reps",
        "api_description": "Returns the `reps` parameter, which determines the depth of the circuit.",
        "api_signature": "reps(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/qaoa_ansatz.py"
    },
    {
        "api_name": "reps",
        "full_api_name": "QAOAAnsatz.reps",
        "api_description": "Sets the `reps` parameter.",
        "api_signature": "reps(self, reps)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/qaoa_ansatz.py"
    },
    {
        "api_name": "initial_state",
        "full_api_name": "QAOAAnsatz.initial_state",
        "api_description": "Returns an optional initial state as a circuit",
        "api_signature": "initial_state(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/qaoa_ansatz.py"
    },
    {
        "api_name": "initial_state",
        "full_api_name": "QAOAAnsatz.initial_state",
        "api_description": "Sets initial state.",
        "api_signature": "initial_state(self, initial_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/qaoa_ansatz.py"
    },
    {
        "api_name": "mixer_operator",
        "full_api_name": "QAOAAnsatz.mixer_operator",
        "api_description": "Returns an optional mixer operator expressed as an operator or a quantum circuit.\n\nReturns:\n    BaseOperator or OperatorBase or QuantumCircuit, optional: mixer operator or circuit.",
        "api_signature": "mixer_operator(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/qaoa_ansatz.py"
    },
    {
        "api_name": "mixer_operator",
        "full_api_name": "QAOAAnsatz.mixer_operator",
        "api_description": "Sets mixer operator.\n\nArgs:\n    mixer_operator (BaseOperator or OperatorBase or QuantumCircuit, optional): mixer\n        operator or circuit to set.",
        "api_signature": "mixer_operator(self, mixer_operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/qaoa_ansatz.py"
    },
    {
        "api_name": "num_qubits",
        "full_api_name": "QAOAAnsatz.num_qubits",
        "api_description": "",
        "api_signature": "num_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/qaoa_ansatz.py"
    },
    {
        "api_name": "_build",
        "full_api_name": "QAOAAnsatz._build",
        "api_description": "If not already built, build the circuit.",
        "api_signature": "_build(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/qaoa_ansatz.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PauliTwoDesign.__init__",
        "api_description": "Args:\n    num_qubits: The number of qubits of the Pauli Two-Design circuit.\n    reps: Specifies how often a block consisting of a rotation layer and entanglement\n        layer is repeated.\n    seed: The seed for randomly choosing the axes of the Pauli rotations.\n    insert_barriers: If ``True``, barriers are inserted in between each layer. If ``False``,\n        no barriers are inserted. Defaults to ``False``.",
        "api_signature": "__init__(self, num_qubits, reps, seed, insert_barriers, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/pauli_two_design.py"
    },
    {
        "api_name": "_invalidate",
        "full_api_name": "PauliTwoDesign._invalidate",
        "api_description": "Invalidate the circuit and reset the random number.",
        "api_signature": "_invalidate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/pauli_two_design.py"
    },
    {
        "api_name": "_build_rotation_layer",
        "full_api_name": "PauliTwoDesign._build_rotation_layer",
        "api_description": "Build a rotation layer.",
        "api_signature": "_build_rotation_layer(self, circuit, param_iter, i)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/pauli_two_design.py"
    },
    {
        "api_name": "num_parameters_settable",
        "full_api_name": "PauliTwoDesign.num_parameters_settable",
        "api_description": "Return the number of settable parameters.\n\nReturns:\n    The number of possibly distinct parameters.",
        "api_signature": "num_parameters_settable(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/pauli_two_design.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "EfficientSU2.__init__",
        "api_description": "Args:\n    num_qubits: The number of qubits of the EfficientSU2 circuit.\n    reps: Specifies how often the structure of a rotation layer followed by an entanglement\n        layer is repeated.\n    su2_gates: The SU(2) single qubit gates to apply in single qubit gate layers.\n        If only one gate is provided, the same gate is applied to each qubit.\n        If a list of gates is provided, all gates are applied to each qubit in the provided\n        order.\n    entanglement: Specifies the entanglement structure. Can be a string\n        ('full', 'linear', 'reverse_linear', 'pairwise', 'circular', or 'sca'),\n        a list of integer-pairs specifying the indices of qubits entangled with one another,\n        or a callable returning such a list provided with the index of the entanglement layer.\n        Defaults to 'reverse_linear' entanglement.\n        Note that 'reverse_linear' entanglement provides the same unitary as 'full'\n        with fewer entangling gates.\n        See the Examples section of :class:`~qiskit.circuit.library.TwoLocal` for more\n        detail.\n    initial_state: A `QuantumCircuit` object to prepend to the circuit.\n    skip_unentangled_qubits: If True, the single qubit gates are only applied to qubits\n        that are entangled with another qubit. If False, the single qubit gates are applied\n        to each qubit in the Ansatz. Defaults to False.\n    skip_final_rotation_layer: If False, a rotation layer is added at the end of the\n        ansatz. If True, no rotation layer is added.\n    parameter_prefix: The parameterized gates require a parameter to be defined, for which\n        we use :class:`~qiskit.circuit.ParameterVector`.\n    insert_barriers: If True, barriers are inserted in between each layer. If False,\n        no barriers are inserted.\n    flatten: Set this to ``True`` to output a flat circuit instead of nesting it inside multiple\n        layers of gate objects. By default currently the contents of\n        the output circuit will be wrapped in nested objects for\n        cleaner visualization. However, if you're using this circuit\n        for anything besides visualization its **strongly** recommended\n        to set this flag to ``True`` to avoid a large performance\n        overhead for parameter binding.",
        "api_signature": "__init__(self, num_qubits, su2_gates, entanglement, reps, skip_unentangled_qubits, skip_final_rotation_layer, parameter_prefix, insert_barriers, initial_state, name, flatten)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/efficient_su2.py"
    },
    {
        "api_name": "parameter_bounds",
        "full_api_name": "EfficientSU2.parameter_bounds",
        "api_description": "Return the parameter bounds.\n\nReturns:\n    The parameter bounds.",
        "api_signature": "parameter_bounds(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/efficient_su2.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "TwoLocal.__init__",
        "api_description": "Args:\n    num_qubits: The number of qubits of the two-local circuit.\n    rotation_blocks: The gates used in the rotation layer. Can be specified via the name of\n        a gate (e.g. ``'ry'``) or the gate type itself (e.g. :class:`.RYGate`).\n        If only one gate is provided, the gate same gate is applied to each qubit.\n        If a list of gates is provided, all gates are applied to each qubit in the provided\n        order.\n        See the Examples section for more detail.\n    entanglement_blocks: The gates used in the entanglement layer. Can be specified in\n        the same format as ``rotation_blocks``.\n    entanglement: Specifies the entanglement structure. Can be a string (``'full'``,\n        ``'linear'``, ``'reverse_linear'``, ``'circular'`` or ``'sca'``),\n        a list of integer-pairs specifying the indices\n        of qubits entangled with one another, or a callable returning such a list provided with\n        the index of the entanglement layer.\n        Default to ``'full'`` entanglement.\n        Note that if ``entanglement_blocks = 'cx'``, then ``'full'`` entanglement provides the\n        same unitary as ``'reverse_linear'`` but the latter option has fewer entangling gates.\n        See the Examples section for more detail.\n    reps: Specifies how often a block consisting of a rotation layer and entanglement\n        layer is repeated.\n    skip_unentangled_qubits: If ``True``, the single qubit gates are only applied to qubits\n        that are entangled with another qubit. If ``False``, the single qubit gates are applied\n        to each qubit in the ansatz. Defaults to ``False``.\n    skip_final_rotation_layer: If ``False``, a rotation layer is added at the end of the\n        ansatz. If ``True``, no rotation layer is added.\n    parameter_prefix: The parameterized gates require a parameter to be defined, for which\n        we use instances of :class:`~qiskit.circuit.Parameter`. The name of each parameter will\n        be this specified prefix plus its index.\n    insert_barriers: If ``True``, barriers are inserted in between each layer. If ``False``,\n        no barriers are inserted. Defaults to ``False``.\n    initial_state: A :class:`.QuantumCircuit` object to prepend to the circuit.\n    flatten: Set this to ``True`` to output a flat circuit instead of nesting it inside multiple\n        layers of gate objects. By default currently the contents of\n        the output circuit will be wrapped in nested objects for\n        cleaner visualization. However, if you're using this circuit\n        for anything besides visualization its **strongly** recommended\n        to set this flag to ``True`` to avoid a large performance\n        overhead for parameter binding.",
        "api_signature": "__init__(self, num_qubits, rotation_blocks, entanglement_blocks, entanglement, reps, skip_unentangled_qubits, skip_final_rotation_layer, parameter_prefix, insert_barriers, initial_state, name, flatten)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/two_local.py"
    },
    {
        "api_name": "_convert_to_block",
        "full_api_name": "TwoLocal._convert_to_block",
        "api_description": "For a layer provided as str (e.g. ``'ry'``) or type (e.g. :class:`.RYGate`) this function\n returns the\n according layer type along with the number of parameters (e.g. ``(RYGate, 1)``).\n\nArgs:\n    layer: The qubit layer.\n\nReturns:\n    The specified layer with the required number of parameters.\n\nRaises:\n    TypeError: The type of ``layer`` is invalid.\n    ValueError: The type of ``layer`` is str but the name is unknown.\n    ValueError: The type of ``layer`` is type but the layer type is unknown.\n\nNote:\n    Outlook: If layers knew their number of parameters as static property, we could also\n    allow custom layer types.",
        "api_signature": "_convert_to_block(self, layer)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/two_local.py"
    },
    {
        "api_name": "get_entangler_map",
        "full_api_name": "TwoLocal.get_entangler_map",
        "api_description": "Overloading to handle the special case of 1 qubit where the entanglement are ignored.",
        "api_signature": "get_entangler_map(self, rep_num, block_num, num_block_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/two_local.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "NLocal.__init__",
        "api_description": "Args:\n    num_qubits: The number of qubits of the circuit.\n    rotation_blocks: The blocks used in the rotation layers. If multiple are passed,\n        these will be applied one after another (like new sub-layers).\n    entanglement_blocks: The blocks used in the entanglement layers. If multiple are passed,\n        these will be applied one after another. To use different entanglements for\n        the sub-layers, see :meth:`get_entangler_map`.\n    entanglement: The indices specifying on which qubits the input blocks act. If ``None``, the\n        entanglement blocks are applied at the top of the circuit.\n    reps: Specifies how often the rotation blocks and entanglement blocks are repeated.\n    insert_barriers: If ``True``, barriers are inserted in between each layer. If ``False``,\n        no barriers are inserted.\n    parameter_prefix: The prefix used if default parameters are generated.\n    overwrite_block_parameters: If the parameters in the added blocks should be overwritten.\n        If ``False``, the parameters in the blocks are not changed.\n    skip_final_rotation_layer: Whether a final rotation layer is added to the circuit.\n    skip_unentangled_qubits: If ``True``, the rotation gates act only on qubits that\n        are entangled. If ``False``, the rotation gates act on all qubits.\n    initial_state: A :class:`.QuantumCircuit` object which can be used to describe an initial\n        state prepended to the NLocal circuit.\n    name: The name of the circuit.\n    flatten: Set this to ``True`` to output a flat circuit instead of nesting it inside multiple\n        layers of gate objects. By default currently the contents of\n        the output circuit will be wrapped in nested objects for\n        cleaner visualization. However, if you're using this circuit\n        for anything besides visualization its **strongly** recommended\n        to set this flag to ``True`` to avoid a large performance\n        overhead for parameter binding.\n\nRaises:\n    ValueError: If ``reps`` parameter is less than or equal to 0.\n    TypeError: If ``reps`` parameter is not an int value.",
        "api_signature": "__init__(self, num_qubits, rotation_blocks, entanglement_blocks, entanglement, reps, insert_barriers, parameter_prefix, overwrite_block_parameters, skip_final_rotation_layer, skip_unentangled_qubits, initial_state, name, flatten)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "num_qubits",
        "full_api_name": "NLocal.num_qubits",
        "api_description": "Returns the number of qubits in this circuit.\n\nReturns:\n    The number of qubits.",
        "api_signature": "num_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "num_qubits",
        "full_api_name": "NLocal.num_qubits",
        "api_description": "Set the number of qubits for the n-local circuit.\n\nArgs:\n    The new number of qubits.",
        "api_signature": "num_qubits(self, num_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "flatten",
        "full_api_name": "NLocal.flatten",
        "api_description": "Returns whether the circuit is wrapped in nested gates/instructions or flattened.",
        "api_signature": "flatten(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "flatten",
        "full_api_name": "NLocal.flatten",
        "api_description": "",
        "api_signature": "flatten(self, flatten)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "_convert_to_block",
        "full_api_name": "NLocal._convert_to_block",
        "api_description": "Try to convert ``layer`` to a QuantumCircuit.\n\nArgs:\n    layer: The object to be converted to an NLocal block / Instruction.\n\nReturns:\n    The layer converted to a circuit.\n\nRaises:\n    TypeError: If the input cannot be converted to a circuit.",
        "api_signature": "_convert_to_block(self, layer)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "rotation_blocks",
        "full_api_name": "NLocal.rotation_blocks",
        "api_description": "The blocks in the rotation layers.\n\nReturns:\n    The blocks in the rotation layers.",
        "api_signature": "rotation_blocks(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "rotation_blocks",
        "full_api_name": "NLocal.rotation_blocks",
        "api_description": "Set the blocks in the rotation layers.\n\nArgs:\n    blocks: The new blocks for the rotation layers.",
        "api_signature": "rotation_blocks(self, blocks)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "entanglement_blocks",
        "full_api_name": "NLocal.entanglement_blocks",
        "api_description": "The blocks in the entanglement layers.\n\nReturns:\n    The blocks in the entanglement layers.",
        "api_signature": "entanglement_blocks(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "entanglement_blocks",
        "full_api_name": "NLocal.entanglement_blocks",
        "api_description": "Set the blocks in the entanglement layers.\n\nArgs:\n    blocks: The new blocks for the entanglement layers.",
        "api_signature": "entanglement_blocks(self, blocks)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "entanglement",
        "full_api_name": "NLocal.entanglement",
        "api_description": "Get the entanglement strategy.\n\nReturns:\n    The entanglement strategy, see :meth:`get_entangler_map` for more detail on how the\n    format is interpreted.",
        "api_signature": "entanglement(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "entanglement",
        "full_api_name": "NLocal.entanglement",
        "api_description": "Set the entanglement strategy.\n\nArgs:\n    entanglement: The entanglement strategy. See :meth:`get_entangler_map` for more detail\n        on the supported formats.",
        "api_signature": "entanglement(self, entanglement)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "num_layers",
        "full_api_name": "NLocal.num_layers",
        "api_description": "Return the number of layers in the n-local circuit.\n\nReturns:\n    The number of layers in the circuit.",
        "api_signature": "num_layers(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "_check_configuration",
        "full_api_name": "NLocal._check_configuration",
        "api_description": "Check if the configuration of the NLocal class is valid.\n\nArgs:\n    raise_on_failure: Whether to raise on failure.\n\nReturns:\n    True, if the configuration is valid and the circuit can be constructed. Otherwise\n    an ValueError is raised.\n\nRaises:\n    ValueError: If the blocks are not set.\n    ValueError: If the number of repetitions is not set.\n    ValueError: If the qubit indices are not set.\n    ValueError: If the number of qubit indices does not match the number of blocks.\n    ValueError: If an index in the repetitions list exceeds the number of blocks.\n    ValueError: If the number of repetitions does not match the number of block-wise\n        parameters.\n    ValueError: If a specified qubit index is larger than the (manually set) number of\n        qubits.",
        "api_signature": "_check_configuration(self, raise_on_failure)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "ordered_parameters",
        "full_api_name": "NLocal.ordered_parameters",
        "api_description": "The parameters used in the underlying circuit.\n\nThis includes float values and duplicates.\n\nExamples:\n\n    >>> # prepare circuit ...\n    >>> print(nlocal)\n         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    q_0: \u2524 Ry(1) \u251c\u2524 Ry(\u03b8[1]) \u251c\u2524 Ry(\u03b8[1]) \u251c\u2524 Ry(\u03b8[3]) \u251c\n         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    >>> nlocal.parameters\n    {Parameter(\u03b8[1]), Parameter(\u03b8[3])}\n    >>> nlocal.ordered_parameters\n    [1, Parameter(\u03b8[1]), Parameter(\u03b8[1]), Parameter(\u03b8[3])]\n\nReturns:\n    The parameters objects used in the circuit.",
        "api_signature": "ordered_parameters(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "ordered_parameters",
        "full_api_name": "NLocal.ordered_parameters",
        "api_description": "Set the parameters used in the underlying circuit.\n\nArgs:\n    The parameters to be used in the underlying circuit.\n\nRaises:\n    ValueError: If the length of ordered parameters does not match the number of\n        parameters in the circuit and they are not a ``ParameterVector`` (which could\n        be resized to fit the number of parameters).",
        "api_signature": "ordered_parameters(self, parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "insert_barriers",
        "full_api_name": "NLocal.insert_barriers",
        "api_description": "If barriers are inserted in between the layers or not.\n\nReturns:\n    ``True``, if barriers are inserted in between the layers, ``False`` if not.",
        "api_signature": "insert_barriers(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "insert_barriers",
        "full_api_name": "NLocal.insert_barriers",
        "api_description": "Specify whether barriers should be inserted in between the layers or not.\n\nArgs:\n    insert_barriers: If True, barriers are inserted, if False not.",
        "api_signature": "insert_barriers(self, insert_barriers)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "get_unentangled_qubits",
        "full_api_name": "NLocal.get_unentangled_qubits",
        "api_description": "Get the indices of unentangled qubits in a set.\n\nReturns:\n    The unentangled qubits.",
        "api_signature": "get_unentangled_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "num_parameters_settable",
        "full_api_name": "NLocal.num_parameters_settable",
        "api_description": "The number of total parameters that can be set to distinct values.\n\nThis does not change when the parameters are bound or exchanged for same parameters,\nand therefore is different from ``num_parameters`` which counts the number of unique\n:class:`~qiskit.circuit.Parameter` objects currently in the circuit.\n\nReturns:\n    The number of parameters originally available in the circuit.\n\nNote:\n    This quantity does not require the circuit to be built yet.",
        "api_signature": "num_parameters_settable(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "reps",
        "full_api_name": "NLocal.reps",
        "api_description": "The number of times rotation and entanglement block are repeated.\n\nReturns:\n    The number of repetitions.",
        "api_signature": "reps(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "reps",
        "full_api_name": "NLocal.reps",
        "api_description": "Set the repetitions.\n\nIf the repetitions are `0`, only one rotation layer with no entanglement\nlayers is applied (unless ``self.skip_final_rotation_layer`` is set to ``True``).\n\nArgs:\n    repetitions: The new repetitions.\n\nRaises:\n    ValueError: If reps setter has parameter repetitions < 0.",
        "api_signature": "reps(self, repetitions)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "print_settings",
        "full_api_name": "NLocal.print_settings",
        "api_description": "Returns information about the setting.\n\nReturns:\n    The class name and the attributes/parameters of the instance as ``str``.",
        "api_signature": "print_settings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "preferred_init_points",
        "full_api_name": "NLocal.preferred_init_points",
        "api_description": "The initial points for the parameters. Can be stored as initial guess in optimization.\n\nReturns:\n    The initial values for the parameters, or None, if none have been set.",
        "api_signature": "preferred_init_points(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "get_entangler_map",
        "full_api_name": "NLocal.get_entangler_map",
        "api_description": "Get the entangler map for in the repetition ``rep_num`` and the block ``block_num``.\n\nThe entangler map for the current block is derived from the value of ``self.entanglement``.\nBelow the different cases are listed, where ``i`` and ``j`` denote the repetition number\nand the block number, respectively, and ``n`` the number of qubits in the block.\n\n=================================== ========================================================\nentanglement type                   entangler map\n=================================== ========================================================\n``None``                            ``[[0, ..., n - 1]]``\n``str`` (e.g ``'full'``)            the specified connectivity on ``n`` qubits\n``List[int]``                       [``entanglement``]\n``List[List[int]]``                 ``entanglement``\n``List[List[List[int]]]``           ``entanglement[i]``\n``List[List[List[List[int]]]]``     ``entanglement[i][j]``\n``List[str]``                       the connectivity specified in ``entanglement[i]``\n``List[List[str]]``                 the connectivity specified in ``entanglement[i][j]``\n``Callable[int, str]``              same as ``List[str]``\n``Callable[int, List[List[int]]]``  same as ``List[List[List[int]]]``\n=================================== ========================================================\n\n\nNote that all indices are to be taken modulo the length of the array they act on, i.e.\nno out-of-bounds index error will be raised but we re-iterate from the beginning of the\nlist.\n\nArgs:\n    rep_num: The current repetition we are in.\n    block_num: The block number within the entanglement layers.\n    num_block_qubits: The number of qubits in the block.\n\nReturns:\n    The entangler map for the current block in the current repetition.\n\nRaises:\n    ValueError: If the value of ``entanglement`` could not be cast to a corresponding\n        entangler map.",
        "api_signature": "get_entangler_map(self, rep_num, block_num, num_block_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "initial_state",
        "full_api_name": "NLocal.initial_state",
        "api_description": "Return the initial state that is added in front of the n-local circuit.\n\nReturns:\n    The initial state.",
        "api_signature": "initial_state(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "initial_state",
        "full_api_name": "NLocal.initial_state",
        "api_description": "Set the initial state.\n\nArgs:\n    initial_state: The new initial state.\n\nRaises:\n    ValueError: If the number of qubits has been set before and the initial state\n        does not match the number of qubits.",
        "api_signature": "initial_state(self, initial_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "parameter_bounds",
        "full_api_name": "NLocal.parameter_bounds",
        "api_description": "The parameter bounds for the unbound parameters in the circuit.\n\nReturns:\n    A list of pairs indicating the bounds, as (lower, upper). None indicates an unbounded\n    parameter in the corresponding direction. If ``None`` is returned, problem is fully\n    unbounded.",
        "api_signature": "parameter_bounds(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "parameter_bounds",
        "full_api_name": "NLocal.parameter_bounds",
        "api_description": "Set the parameter bounds.\n\nArgs:\n    bounds: The new parameter bounds.",
        "api_signature": "parameter_bounds(self, bounds)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "add_layer",
        "full_api_name": "NLocal.add_layer",
        "api_description": "Append another layer to the NLocal.\n\nArgs:\n    other: The layer to compose, can be another NLocal, an Instruction or Gate,\n        or a QuantumCircuit.\n    entanglement: The entanglement or qubit indices.\n    front: If True, ``other`` is appended to the front, else to the back.\n\nReturns:\n    self, such that chained composes are possible.\n\nRaises:\n    TypeError: If `other` is not compatible, i.e. is no Instruction and does not have a\n        `to_instruction` method.",
        "api_signature": "add_layer(self, other, entanglement, front)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "assign_parameters",
        "full_api_name": "NLocal.assign_parameters",
        "api_description": "Assign parameters to the n-local circuit.\n\nThis method also supports passing a list instead of a dictionary. If a list\nis passed, the list must have the same length as the number of unbound parameters in\nthe circuit. The parameters are assigned in the order of the parameters in\n:meth:`ordered_parameters`.\n\nReturns:\n    A copy of the NLocal circuit with the specified parameters.\n\nRaises:\n    AttributeError: If the parameters are given as list and do not match the number\n        of parameters.",
        "api_signature": "assign_parameters(self, parameters, inplace)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "_parameterize_block",
        "full_api_name": "NLocal._parameterize_block",
        "api_description": "Convert ``block`` to a circuit of correct width and parameterized using the iterator.",
        "api_signature": "_parameterize_block(self, block, param_iter, rep_num, block_num, indices, params)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "_build_rotation_layer",
        "full_api_name": "NLocal._build_rotation_layer",
        "api_description": "Build a rotation layer.",
        "api_signature": "_build_rotation_layer(self, circuit, param_iter, i)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "_build_entanglement_layer",
        "full_api_name": "NLocal._build_entanglement_layer",
        "api_description": "Build an entanglement layer.",
        "api_signature": "_build_entanglement_layer(self, circuit, param_iter, i)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "_build_additional_layers",
        "full_api_name": "NLocal._build_additional_layers",
        "api_description": "",
        "api_signature": "_build_additional_layers(self, circuit, which)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "_build",
        "full_api_name": "NLocal._build",
        "api_description": "If not already built, build the circuit.",
        "api_signature": "_build(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "_parameter_generator",
        "full_api_name": "NLocal._parameter_generator",
        "api_description": "If certain blocks should use certain parameters this method can be overridden.",
        "api_signature": "_parameter_generator(self, rep, block, indices)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "get_parameters",
        "full_api_name": "get_parameters",
        "api_description": "Return the list of Parameters objects inside a circuit or instruction.\n\nThis is required since, in a standard gate the parameters are not necessarily Parameter\nobjects (e.g. U3Gate(0.1, 0.2, 0.3).params == [0.1, 0.2, 0.3]) and instructions and\ncircuits do not have the same interface for parameters.",
        "api_signature": "get_parameters(block)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "get_entangler_map",
        "full_api_name": "get_entangler_map",
        "api_description": "Get an entangler map for an arbitrary number of qubits.\n\nArgs:\n    num_block_qubits: The number of qubits of the entangling block.\n    num_circuit_qubits: The number of qubits of the circuit.\n    entanglement: The entanglement strategy.\n    offset: The block offset, can be used if the entanglements differ per block.\n        See mode ``sca`` for instance.\n\nReturns:\n    The entangler map using mode ``entanglement`` to scatter a block of ``num_block_qubits``\n    qubits on ``num_circuit_qubits`` qubits.\n\nRaises:\n    ValueError: If the entanglement mode ist not supported.",
        "api_signature": "get_entangler_map(num_block_qubits, num_circuit_qubits, entanglement, offset)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "_stdlib_gate_from_simple_block",
        "full_api_name": "_stdlib_gate_from_simple_block",
        "api_description": "",
        "api_signature": "_stdlib_gate_from_simple_block(block)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/n_local.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ExcitationPreserving.__init__",
        "api_description": "Args:\n    num_qubits: The number of qubits of the ExcitationPreserving circuit.\n    mode: Choose the entangler mode, can be `'iswap'` or `'fsim'`.\n    reps: Specifies how often the structure of a rotation layer followed by an entanglement\n        layer is repeated.\n    entanglement: Specifies the entanglement structure. Can be a string ('full', 'linear'\n        or 'sca'), a list of integer-pairs specifying the indices of qubits\n        entangled with one another, or a callable returning such a list provided with\n        the index of the entanglement layer.\n        See the Examples section of :class:`~qiskit.circuit.library.TwoLocal` for more\n        detail.\n    initial_state: A `QuantumCircuit` object to prepend to the circuit.\n    skip_unentangled_qubits: If True, the single qubit gates are only applied to qubits\n        that are entangled with another qubit. If False, the single qubit gates are applied\n        to each qubit in the Ansatz. Defaults to False.\n    skip_final_rotation_layer: If True, a rotation layer is added at the end of the\n        ansatz. If False, no rotation layer is added. Defaults to True.\n    parameter_prefix: The parameterized gates require a parameter to be defined, for which\n        we use :class:`~qiskit.circuit.ParameterVector`.\n    insert_barriers: If True, barriers are inserted in between each layer. If False,\n        no barriers are inserted.\n    flatten: Set this to ``True`` to output a flat circuit instead of nesting it inside multiple\n        layers of gate objects. By default currently the contents of\n        the output circuit will be wrapped in nested objects for\n        cleaner visualization. However, if you're using this circuit\n        for anything besides visualization its **strongly** recommended\n        to set this flag to ``True`` to avoid a large performance\n        overhead for parameter binding.\n\nRaises:\n    ValueError: If the selected mode is not supported.",
        "api_signature": "__init__(self, num_qubits, mode, entanglement, reps, skip_unentangled_qubits, skip_final_rotation_layer, parameter_prefix, insert_barriers, initial_state, name, flatten)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/excitation_preserving.py"
    },
    {
        "api_name": "parameter_bounds",
        "full_api_name": "ExcitationPreserving.parameter_bounds",
        "api_description": "Return the parameter bounds.\n\nReturns:\n    The parameter bounds.",
        "api_signature": "parameter_bounds(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/excitation_preserving.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "EvolvedOperatorAnsatz.__init__",
        "api_description": "Args:\n    operators (BaseOperator | QuantumCircuit | list | None): The operators\n        to evolve. If a circuit is passed, we assume it implements an already evolved\n        operator and thus the circuit is not evolved again. Can be a single operator\n        (circuit) or a list of operators (and circuits).\n    reps: The number of times to repeat the evolved operators.\n    evolution (EvolutionBase | EvolutionSynthesis | None):\n        A specification of which evolution synthesis to use for the\n        :class:`.PauliEvolutionGate`.\n        Defaults to first order Trotterization.\n    insert_barriers: Whether to insert barriers in between each evolution.\n    name: The name of the circuit.\n    parameter_prefix: Set the names of the circuit parameters. If a string, the same prefix\n        will be used for each parameters. Can also be a list to specify a prefix per\n        operator.\n    initial_state: A :class:`.QuantumCircuit` object to prepend to the circuit.\n    flatten: Set this to ``True`` to output a flat circuit instead of nesting it inside multiple\n        layers of gate objects. By default currently the contents of\n        the output circuit will be wrapped in nested objects for\n        cleaner visualization. However, if you're using this circuit\n        for anything besides visualization its **strongly** recommended\n        to set this flag to ``True`` to avoid a large performance\n        overhead for parameter binding.",
        "api_signature": "__init__(self, operators, reps, evolution, insert_barriers, name, parameter_prefix, initial_state, flatten)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/evolved_operator_ansatz.py"
    },
    {
        "api_name": "_check_configuration",
        "full_api_name": "EvolvedOperatorAnsatz._check_configuration",
        "api_description": "Check if the current configuration is valid.",
        "api_signature": "_check_configuration(self, raise_on_failure)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/evolved_operator_ansatz.py"
    },
    {
        "api_name": "num_qubits",
        "full_api_name": "EvolvedOperatorAnsatz.num_qubits",
        "api_description": "Returns the number of qubits in this circuit.\n\nReturns:\n    The number of qubits.",
        "api_signature": "num_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/evolved_operator_ansatz.py"
    },
    {
        "api_name": "evolution",
        "full_api_name": "EvolvedOperatorAnsatz.evolution",
        "api_description": "The evolution converter used to compute the evolution.\n\nReturns:\n    EvolutionSynthesis: The evolution converter used to compute the evolution.",
        "api_signature": "evolution(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/evolved_operator_ansatz.py"
    },
    {
        "api_name": "evolution",
        "full_api_name": "EvolvedOperatorAnsatz.evolution",
        "api_description": "Sets the evolution converter used to compute the evolution.\n\nArgs:\n    evol (EvolutionSynthesis): An evolution synthesis object",
        "api_signature": "evolution(self, evol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/evolved_operator_ansatz.py"
    },
    {
        "api_name": "operators",
        "full_api_name": "EvolvedOperatorAnsatz.operators",
        "api_description": "The operators that are evolved in this circuit.\n\nReturns:\n    list: The operators to be evolved (and circuits) contained in this ansatz.",
        "api_signature": "operators(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/evolved_operator_ansatz.py"
    },
    {
        "api_name": "operators",
        "full_api_name": "EvolvedOperatorAnsatz.operators",
        "api_description": "Set the operators to be evolved.\n\noperators (Optional[Union[QuantumCircuit, list]]): The operators to evolve.\n    If a circuit is passed, we assume it implements an already evolved operator and thus\n    the circuit is not evolved again. Can be a single operator (circuit) or a list of\n    operators (and circuits).",
        "api_signature": "operators(self, operators)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/evolved_operator_ansatz.py"
    },
    {
        "api_name": "preferred_init_points",
        "full_api_name": "EvolvedOperatorAnsatz.preferred_init_points",
        "api_description": "Getter of preferred initial points based on the given initial state.",
        "api_signature": "preferred_init_points(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/evolved_operator_ansatz.py"
    },
    {
        "api_name": "_evolve_operator",
        "full_api_name": "EvolvedOperatorAnsatz._evolve_operator",
        "api_description": "",
        "api_signature": "_evolve_operator(self, operator, time)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/evolved_operator_ansatz.py"
    },
    {
        "api_name": "_build",
        "full_api_name": "EvolvedOperatorAnsatz._build",
        "api_description": "",
        "api_signature": "_build(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/evolved_operator_ansatz.py"
    },
    {
        "api_name": "_validate_operators",
        "full_api_name": "_validate_operators",
        "api_description": "",
        "api_signature": "_validate_operators(operators)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/evolved_operator_ansatz.py"
    },
    {
        "api_name": "_validate_prefix",
        "full_api_name": "_validate_prefix",
        "api_description": "",
        "api_signature": "_validate_prefix(parameter_prefix, operators)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/evolved_operator_ansatz.py"
    },
    {
        "api_name": "_is_pauli_identity",
        "full_api_name": "_is_pauli_identity",
        "api_description": "",
        "api_signature": "_is_pauli_identity(operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/library/n_local/evolved_operator_ansatz.py"
    },
    {
        "api_name": "pi_check",
        "full_api_name": "pi_check",
        "api_description": "Computes if a number is close to an integer\nfraction or multiple of PI and returns the\ncorresponding string.\n\nArgs:\n    inpt (float): Number to check.\n    eps (float): EPS to check against.\n    output (str): Options are 'text' (default),\n                  'latex', 'mpl', and 'qasm'.\n    ndigits (int or None): Number of digits to print\n                           if returning raw inpt.\n                           If `None` (default), Python's\n                           default float formatting is used.\n\nReturns:\n    str: string representation of output.\n\nRaises:\n    QiskitError: if output is not a valid option.",
        "api_signature": "pi_check(inpt, eps, output, ndigits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/tools/pi_check.py"
    },
    {
        "api_name": "normalize",
        "full_api_name": "normalize",
        "api_description": "",
        "api_signature": "normalize(single_inpt)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/tools/pi_check.py"
    },
    {
        "api_name": "_get_singleton_instance",
        "full_api_name": "_Singleton._get_singleton_instance",
        "api_description": "",
        "api_signature": "_get_singleton_instance(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/types/types.py"
    },
    {
        "api_name": "__prepare__",
        "full_api_name": "_Singleton.__prepare__",
        "api_description": "",
        "api_signature": "__prepare__(mcs, name, bases)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/types/types.py"
    },
    {
        "api_name": "__new__",
        "full_api_name": "_Singleton.__new__",
        "api_description": "",
        "api_signature": "__new__(cls, name, bases, namespace)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/types/types.py"
    },
    {
        "api_name": "kind",
        "full_api_name": "Type.kind",
        "api_description": "Get the kind of this type.  This is exactly equal to the Python type object that defines\nthis type, that is ``t.kind is type(t)``, but is exposed like this to make it clear that\nthis a hashable enum-like discriminator you can rely on.",
        "api_signature": "kind(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/types/types.py"
    },
    {
        "api_name": "__setattr__",
        "full_api_name": "Type.__setattr__",
        "api_description": "",
        "api_signature": "__setattr__(self, _key, _value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/types/types.py"
    },
    {
        "api_name": "__copy__",
        "full_api_name": "Type.__copy__",
        "api_description": "",
        "api_signature": "__copy__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/types/types.py"
    },
    {
        "api_name": "__deepcopy__",
        "full_api_name": "Type.__deepcopy__",
        "api_description": "",
        "api_signature": "__deepcopy__(self, _memo)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/types/types.py"
    },
    {
        "api_name": "__setstate__",
        "full_api_name": "Type.__setstate__",
        "api_description": "",
        "api_signature": "__setstate__(self, state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/types/types.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "Bool.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/types/types.py"
    },
    {
        "api_name": "__hash__",
        "full_api_name": "Bool.__hash__",
        "api_description": "",
        "api_signature": "__hash__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/types/types.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "Bool.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/types/types.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Uint.__init__",
        "api_description": "",
        "api_signature": "__init__(self, width)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/types/types.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "Uint.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/types/types.py"
    },
    {
        "api_name": "__hash__",
        "full_api_name": "Uint.__hash__",
        "api_description": "",
        "api_signature": "__hash__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/types/types.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "Uint.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/types/types.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "Ordering.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/types/ordering.py"
    },
    {
        "api_name": "_order_bool_bool",
        "full_api_name": "_order_bool_bool",
        "api_description": "",
        "api_signature": "_order_bool_bool()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/types/ordering.py"
    },
    {
        "api_name": "_order_uint_uint",
        "full_api_name": "_order_uint_uint",
        "api_description": "",
        "api_signature": "_order_uint_uint()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/types/ordering.py"
    },
    {
        "api_name": "order",
        "full_api_name": "order",
        "api_description": "Get the ordering relationship between the two types as an enumeration value.\n\nExamples:\n    Compare two :class:`Uint` types of different widths::\n\n        >>> from qiskit.circuit.classical import types\n        >>> types.order(types.Uint(8), types.Uint(16))\n        Ordering.LESS\n\n    Compare two types that have no ordering between them::\n\n        >>> types.order(types.Uint(8), types.Bool())\n        Ordering.NONE",
        "api_signature": "order()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/types/ordering.py"
    },
    {
        "api_name": "is_subtype",
        "full_api_name": "is_subtype",
        "api_description": "Does the relation :math:`\\text{left} \\le \\text{right}` hold?  If there is no ordering\nrelation between the two types, then this returns ``False``.  If ``strict``, then the equality\nis also forbidden.\n\nExamples:\n    Check if one type is a subclass of another::\n\n        >>> from qiskit.circuit.classical import types\n        >>> types.is_subtype(types.Uint(8), types.Uint(16))\n        True\n\n    Check if one type is a strict subclass of another::\n\n        >>> types.is_subtype(types.Bool(), types.Bool())\n        True\n        >>> types.is_subtype(types.Bool(), types.Bool(), strict=True)\n        False",
        "api_signature": "is_subtype(strict)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/types/ordering.py"
    },
    {
        "api_name": "is_supertype",
        "full_api_name": "is_supertype",
        "api_description": "Does the relation :math:`\\text{left} \\ge \\text{right}` hold?  If there is no ordering\nrelation between the two types, then this returns ``False``.  If ``strict``, then the equality\nis also forbidden.\n\nExamples:\n    Check if one type is a superclass of another::\n\n        >>> from qiskit.circuit.classical import types\n        >>> types.is_supertype(types.Uint(8), types.Uint(16))\n        False\n\n    Check if one type is a strict superclass of another::\n\n        >>> types.is_supertype(types.Bool(), types.Bool())\n        True\n        >>> types.is_supertype(types.Bool(), types.Bool(), strict=True)\n        False",
        "api_signature": "is_supertype(strict)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/types/ordering.py"
    },
    {
        "api_name": "greater",
        "full_api_name": "greater",
        "api_description": "Get the greater of the two types, assuming that there is an ordering relation between them.\nTechnically, this is a slightly restricted version of the concept of the 'meet' of the two\ntypes in that the return value must be one of the inputs. In practice in the type system there\nis no concept of a 'sum' type, so the 'meet' exists if and only if there is an ordering between\nthe two types, and is equal to the greater of the two types.\n\nReturns:\n    The greater of the two types.\n\nRaises:\n    TypeError: if there is no ordering relation between the two types.\n\nExamples:\n    Find the greater of two :class:`Uint` types::\n\n        >>> from qiskit.circuit.classical import types\n        >>> types.greater(types.Uint(8), types.Uint(16))\n        types.Uint(16)",
        "api_signature": "greater()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/types/ordering.py"
    },
    {
        "api_name": "_uint_cast",
        "full_api_name": "_uint_cast",
        "api_description": "",
        "api_signature": "_uint_cast()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/types/ordering.py"
    },
    {
        "api_name": "cast_kind",
        "full_api_name": "cast_kind",
        "api_description": "Determine the sort of cast that is required to move from the left type to the right type.\n\nExamples:\n\n    .. code-block:: python\n\n        >>> from qiskit.circuit.classical import types\n        >>> types.cast_kind(types.Bool(), types.Bool())\n        <CastKind.EQUAL: 1>\n        >>> types.cast_kind(types.Uint(8), types.Bool())\n        <CastKind.IMPLICIT: 2>\n        >>> types.cast_kind(types.Bool(), types.Uint(8))\n        <CastKind.LOSSLESS: 3>\n        >>> types.cast_kind(types.Uint(16), types.Uint(8))\n        <CastKind.DANGEROUS: 4>",
        "api_signature": "cast_kind()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/types/ordering.py"
    },
    {
        "api_name": "_coerce_lossless",
        "full_api_name": "_coerce_lossless",
        "api_description": "Coerce ``expr`` to ``type`` by inserting a suitable :class:`Cast` node, if the cast is\nlossless.  Otherwise, raise a ``TypeError``.",
        "api_signature": "_coerce_lossless(expr, type)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/constructors.py"
    },
    {
        "api_name": "lift_legacy_condition",
        "full_api_name": "lift_legacy_condition",
        "api_description": "Lift a legacy two-tuple equality condition into a new-style :class:`Expr`.\n\nExamples:\n    Taking an old-style conditional instruction and getting an :class:`Expr` from its\n    condition::\n\n        from qiskit.circuit import ClassicalRegister\n        from qiskit.circuit.library import HGate\n        from qiskit.circuit.classical import expr\n\n        cr = ClassicalRegister(2)\n        instr = HGate().c_if(cr, 3)\n\n        lifted = expr.lift_legacy_condition(instr.condition)",
        "api_signature": "lift_legacy_condition()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/constructors.py"
    },
    {
        "api_name": "lift",
        "full_api_name": "lift",
        "api_description": "Lift the given Python ``value`` to a :class:`~.expr.Value` or :class:`~.expr.Var`.\n\nIf an explicit ``type`` is given, the typing in the output will reflect that.\n\nExamples:\n    Lifting simple circuit objects to be :class:`~.expr.Var` instances::\n\n        >>> from qiskit.circuit import Clbit, ClassicalRegister\n        >>> from qiskit.circuit.classical import expr\n        >>> expr.lift(Clbit())\n        Var(<clbit>, Bool())\n        >>> expr.lift(ClassicalRegister(3, \"c\"))\n        Var(ClassicalRegister(3, \"c\"), Uint(3))\n\n    The type of the return value can be influenced, if the given value could be interpreted\n    losslessly as the given type (use :func:`cast` to perform a full set of casting\n    operations, include lossy ones)::\n\n        >>> from qiskit.circuit import ClassicalRegister\n        >>> from qiskit.circuit.classical import expr, types\n        >>> expr.lift(ClassicalRegister(3, \"c\"), types.Uint(5))\n        Var(ClassicalRegister(3, \"c\"), Uint(5))\n        >>> expr.lift(5, types.Uint(4))\n        Value(5, Uint(4))",
        "api_signature": "lift(type)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/constructors.py"
    },
    {
        "api_name": "cast",
        "full_api_name": "cast",
        "api_description": "Create an explicit cast from the given value to the given type.\n\nExamples:\n    Add an explicit cast node that explicitly casts a higher precision type to a lower precision\n    one::\n\n        >>> from qiskit.circuit.classical import expr, types\n        >>> value = expr.value(5, types.Uint(32))\n        >>> expr.cast(value, types.Uint(8))\n        Cast(Value(5, types.Uint(32)), types.Uint(8), implicit=False)",
        "api_signature": "cast()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/constructors.py"
    },
    {
        "api_name": "bit_not",
        "full_api_name": "bit_not",
        "api_description": "Create a bitwise 'not' expression node from the given value, resolving any implicit casts and\nlifting the value into a :class:`Value` node if required.\n\nExamples:\n    Bitwise negation of a :class:`.ClassicalRegister`::\n\n        >>> from qiskit.circuit import ClassicalRegister\n        >>> from qiskit.circuit.classical import expr\n        >>> expr.bit_not(ClassicalRegister(3, \"c\"))\n        Unary(Unary.Op.BIT_NOT, Var(ClassicalRegister(3, 'c'), Uint(3)), Uint(3))",
        "api_signature": "bit_not()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/constructors.py"
    },
    {
        "api_name": "logic_not",
        "full_api_name": "logic_not",
        "api_description": "Create a logical 'not' expression node from the given value, resolving any implicit casts and\nlifting the value into a :class:`Value` node if required.\n\nExamples:\n    Logical negation of a :class:`.ClassicalRegister`::\n\n        >>> from qiskit.circuit import ClassicalRegister\n        >>> from qiskit.circuit.classical import expr\n        >>> expr.logic_not(ClassicalRegister(3, \"c\"))\n        Unary(Unary.Op.LOGIC_NOT, Cast(Var(ClassicalRegister(3, 'c'), Uint(3)), Bool(), implicit=True), Bool())",
        "api_signature": "logic_not()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/constructors.py"
    },
    {
        "api_name": "_lift_binary_operands",
        "full_api_name": "_lift_binary_operands",
        "api_description": "Lift two binary operands simultaneously, inferring the widths of integer literals in either\nposition to match the other operand.",
        "api_signature": "_lift_binary_operands(left, right)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/constructors.py"
    },
    {
        "api_name": "_binary_bitwise",
        "full_api_name": "_binary_bitwise",
        "api_description": "",
        "api_signature": "_binary_bitwise(op, left, right)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/constructors.py"
    },
    {
        "api_name": "bit_and",
        "full_api_name": "bit_and",
        "api_description": "Create a bitwise 'and' expression node from the given value, resolving any implicit casts and\nlifting the values into :class:`Value` nodes if required.\n\nExamples:\n    Bitwise 'and' of a classical register and an integer literal::\n\n        >>> from qiskit.circuit import ClassicalRegister\n        >>> from qiskit.circuit.classical import expr\n        >>> expr.bit_and(ClassicalRegister(3, \"c\"), 0b111)\n        Binary(Binary.Op.BIT_AND, Var(ClassicalRegister(3, 'c'), Uint(3)), Value(7, Uint(3)), Uint(3))\n    ",
        "api_signature": "bit_and()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/constructors.py"
    },
    {
        "api_name": "bit_or",
        "full_api_name": "bit_or",
        "api_description": "Create a bitwise 'or' expression node from the given value, resolving any implicit casts and\nlifting the values into :class:`Value` nodes if required.\n\nExamples:\n    Bitwise 'or' of a classical register and an integer literal::\n\n        >>> from qiskit.circuit import ClassicalRegister\n        >>> from qiskit.circuit.classical import expr\n        >>> expr.bit_or(ClassicalRegister(3, \"c\"), 0b101)\n        Binary(Binary.Op.BIT_OR, Var(ClassicalRegister(3, 'c'), Uint(3)), Value(5, Uint(3)), Uint(3))",
        "api_signature": "bit_or()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/constructors.py"
    },
    {
        "api_name": "bit_xor",
        "full_api_name": "bit_xor",
        "api_description": "Create a bitwise 'exclusive or' expression node from the given value, resolving any implicit\ncasts and lifting the values into :class:`Value` nodes if required.\n\nExamples:\n    Bitwise 'exclusive or' of a classical register and an integer literal::\n\n        >>> from qiskit.circuit import ClassicalRegister\n        >>> from qiskit.circuit.classical import expr\n        >>> expr.bit_xor(ClassicalRegister(3, \"c\"), 0b101)\n        Binary(Binary.Op.BIT_XOR, Var(ClassicalRegister(3, 'c'), Uint(3)), Value(5, Uint(3)), Uint(3))",
        "api_signature": "bit_xor()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/constructors.py"
    },
    {
        "api_name": "_binary_logical",
        "full_api_name": "_binary_logical",
        "api_description": "",
        "api_signature": "_binary_logical(op, left, right)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/constructors.py"
    },
    {
        "api_name": "logic_and",
        "full_api_name": "logic_and",
        "api_description": "Create a logical 'and' expression node from the given value, resolving any implicit casts and\nlifting the values into :class:`Value` nodes if required.\n\nExamples:\n    Logical 'and' of two classical bits::\n\n        >>> from qiskit.circuit import Clbit\n        >>> from qiskit.circuit.classical import expr\n        >>> expr.logical_and(Clbit(), Clbit())\n        Binary(Binary.Op.LOGIC_AND, Var(<clbit 0>, Bool()), Var(<clbit 1>, Bool()), Bool())",
        "api_signature": "logic_and()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/constructors.py"
    },
    {
        "api_name": "logic_or",
        "full_api_name": "logic_or",
        "api_description": "Create a logical 'or' expression node from the given value, resolving any implicit casts and\nlifting the values into :class:`Value` nodes if required.\n\nExamples:\n    Logical 'or' of two classical bits\n\n        >>> from qiskit.circuit import Clbit\n        >>> from qiskit.circuit.classical import expr\n        >>> expr.logical_and(Clbit(), Clbit())\n        Binary(Binary.Op.LOGIC_OR, Var(<clbit 0>, Bool()), Var(<clbit 1>, Bool()), Bool())",
        "api_signature": "logic_or()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/constructors.py"
    },
    {
        "api_name": "_equal_like",
        "full_api_name": "_equal_like",
        "api_description": "",
        "api_signature": "_equal_like(op, left, right)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/constructors.py"
    },
    {
        "api_name": "equal",
        "full_api_name": "equal",
        "api_description": "Create an 'equal' expression node from the given value, resolving any implicit casts and\nlifting the values into :class:`Value` nodes if required.\n\nExamples:\n    Equality between a classical register and an integer::\n\n        >>> from qiskit.circuit import ClassicalRegister\n        >>> from qiskit.circuit.classical import expr\n        >>> expr.equal(ClassicalRegister(3, \"c\"), 7)\n        Binary(Binary.Op.EQUAL, Var(ClassicalRegister(3, \"c\"), Uint(3)), Value(7, Uint(3)), Uint(3))",
        "api_signature": "equal()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/constructors.py"
    },
    {
        "api_name": "not_equal",
        "full_api_name": "not_equal",
        "api_description": "Create a 'not equal' expression node from the given value, resolving any implicit casts and\nlifting the values into :class:`Value` nodes if required.\n\nExamples:\n    Inequality between a classical register and an integer::\n\n        >>> from qiskit.circuit import ClassicalRegister\n        >>> from qiskit.circuit.classical import expr\n        >>> expr.not_equal(ClassicalRegister(3, \"c\"), 7)\n        Binary(Binary.Op.NOT_EQUAL, Var(ClassicalRegister(3, \"c\"), Uint(3)), Value(7, Uint(3)), Uint(3))",
        "api_signature": "not_equal()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/constructors.py"
    },
    {
        "api_name": "_binary_relation",
        "full_api_name": "_binary_relation",
        "api_description": "",
        "api_signature": "_binary_relation(op, left, right)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/constructors.py"
    },
    {
        "api_name": "less",
        "full_api_name": "less",
        "api_description": "Create a 'less than' expression node from the given value, resolving any implicit casts and\nlifting the values into :class:`Value` nodes if required.\n\nExamples:\n    Query if a classical register is less than an integer::\n\n        >>> from qiskit.circuit import ClassicalRegister\n        >>> from qiskit.circuit.classical import expr\n        >>> expr.less(ClassicalRegister(3, \"c\"), 5)\n        Binary(Binary.Op.LESS, Var(ClassicalRegister(3, \"c\"), Uint(3)), Value(5, Uint(3)), Uint(3))",
        "api_signature": "less()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/constructors.py"
    },
    {
        "api_name": "less_equal",
        "full_api_name": "less_equal",
        "api_description": "Create a 'less than or equal to' expression node from the given value, resolving any implicit\ncasts and lifting the values into :class:`Value` nodes if required.\n\nExamples:\n    Query if a classical register is less than or equal to another::\n\n        >>> from qiskit.circuit import ClassicalRegister\n        >>> from qiskit.circuit.classical import expr\n        >>> expr.less(ClassicalRegister(3, \"a\"), ClassicalRegister(3, \"b\"))\n        Binary(Binary.Op.LESS_EQUAL, Var(ClassicalRegister(3, \"a\"), Uint(3)), Var(ClassicalRegister(3, \"b\"), Uint(3)), Uint(3))",
        "api_signature": "less_equal()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/constructors.py"
    },
    {
        "api_name": "greater",
        "full_api_name": "greater",
        "api_description": "Create a 'greater than' expression node from the given value, resolving any implicit casts\nand lifting the values into :class:`Value` nodes if required.\n\nExamples:\n    Query if a classical register is greater than an integer::\n\n        >>> from qiskit.circuit import ClassicalRegister\n        >>> from qiskit.circuit.classical import expr\n        >>> expr.less(ClassicalRegister(3, \"c\"), 5)\n        Binary(Binary.Op.GREATER, Var(ClassicalRegister(3, \"c\"), Uint(3)), Value(5, Uint(3)), Uint(3))",
        "api_signature": "greater()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/constructors.py"
    },
    {
        "api_name": "greater_equal",
        "full_api_name": "greater_equal",
        "api_description": "Create a 'greater than or equal to' expression node from the given value, resolving any\nimplicit casts and lifting the values into :class:`Value` nodes if required.\n\nExamples:\n    Query if a classical register is greater than or equal to another::\n\n        >>> from qiskit.circuit import ClassicalRegister\n        >>> from qiskit.circuit.classical import expr\n        >>> expr.less(ClassicalRegister(3, \"a\"), ClassicalRegister(3, \"b\"))\n        Binary(Binary.Op.GREATER_EQUAL, Var(ClassicalRegister(3, \"a\"), Uint(3)), Var(ClassicalRegister(3, \"b\"), Uint(3)), Uint(3))",
        "api_signature": "greater_equal()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/constructors.py"
    },
    {
        "api_name": "_shift_like",
        "full_api_name": "_shift_like",
        "api_description": "",
        "api_signature": "_shift_like(op, left, right, type)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/constructors.py"
    },
    {
        "api_name": "shift_left",
        "full_api_name": "shift_left",
        "api_description": "Create a 'bitshift left' expression node from the given two values, resolving any implicit\ncasts and lifting the values into :class:`Value` nodes if required.\n\nIf ``type`` is given, the ``left`` operand will be coerced to it (if possible).\n\nExamples:\n    Shift the value of a standalone variable left by some amount::\n\n        >>> from qiskit.circuit.classical import expr, types\n        >>> a = expr.Var.new(\"a\", types.Uint(8))\n        >>> expr.shift_left(a, 4)\n        Binary(Binary.Op.SHIFT_LEFT, Var(<UUID>, Uint(8), name='a'), Value(4, Uint(3)), Uint(8))\n\n    Shift an integer literal by a variable amount, coercing the type of the literal::\n\n        >>> expr.shift_left(3, a, types.Uint(16))\n        Binary(Binary.Op.SHIFT_LEFT, Value(3, Uint(16)), Var(<UUID>, Uint(8), name='a'), Uint(16))",
        "api_signature": "shift_left(type)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/constructors.py"
    },
    {
        "api_name": "shift_right",
        "full_api_name": "shift_right",
        "api_description": "Create a 'bitshift right' expression node from the given values, resolving any implicit casts\nand lifting the values into :class:`Value` nodes if required.\n\nIf ``type`` is given, the ``left`` operand will be coerced to it (if possible).\n\nExamples:\n    Shift the value of a classical register right by some amount::\n\n        >>> from qiskit.circuit import ClassicalRegister\n        >>> from qiskit.circuit.classical import expr\n        >>> expr.shift_right(ClassicalRegister(8, \"a\"), 4)\n        Binary(Binary.Op.SHIFT_RIGHT, Var(ClassicalRegister(8, \"a\"), Uint(8)), Value(4, Uint(3)), Uint(8))",
        "api_signature": "shift_right(type)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/constructors.py"
    },
    {
        "api_name": "index",
        "full_api_name": "index",
        "api_description": "Index into the ``target`` with the given integer ``index``, lifting the values into\n:class:`Value` nodes if required.\n\nThis can be used as the target of a :class:`.Store`, if the ``target`` is itself an lvalue.\n\nExamples:\n    Index into a classical register with a literal::\n\n        >>> from qiskit.circuit import ClassicalRegister\n        >>> from qiskit.circuit.classical import expr\n        >>> expr.index(ClassicalRegister(8, \"a\"), 3)\n        Index(Var(ClassicalRegister(8, \"a\"), Uint(8)), Value(3, Uint(2)), Bool())",
        "api_signature": "index()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/constructors.py"
    },
    {
        "api_name": "visit_generic",
        "full_api_name": "ExprVisitor.visit_generic",
        "api_description": "",
        "api_signature": "visit_generic()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/visitors.py"
    },
    {
        "api_name": "visit_var",
        "full_api_name": "ExprVisitor.visit_var",
        "api_description": "",
        "api_signature": "visit_var()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/visitors.py"
    },
    {
        "api_name": "visit_value",
        "full_api_name": "ExprVisitor.visit_value",
        "api_description": "",
        "api_signature": "visit_value()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/visitors.py"
    },
    {
        "api_name": "visit_unary",
        "full_api_name": "ExprVisitor.visit_unary",
        "api_description": "",
        "api_signature": "visit_unary()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/visitors.py"
    },
    {
        "api_name": "visit_binary",
        "full_api_name": "ExprVisitor.visit_binary",
        "api_description": "",
        "api_signature": "visit_binary()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/visitors.py"
    },
    {
        "api_name": "visit_cast",
        "full_api_name": "ExprVisitor.visit_cast",
        "api_description": "",
        "api_signature": "visit_cast()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/visitors.py"
    },
    {
        "api_name": "visit_index",
        "full_api_name": "ExprVisitor.visit_index",
        "api_description": "",
        "api_signature": "visit_index()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/visitors.py"
    },
    {
        "api_name": "visit_var",
        "full_api_name": "_VarWalkerImpl.visit_var",
        "api_description": "",
        "api_signature": "visit_var()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/visitors.py"
    },
    {
        "api_name": "visit_value",
        "full_api_name": "_VarWalkerImpl.visit_value",
        "api_description": "",
        "api_signature": "visit_value()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/visitors.py"
    },
    {
        "api_name": "visit_unary",
        "full_api_name": "_VarWalkerImpl.visit_unary",
        "api_description": "",
        "api_signature": "visit_unary()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/visitors.py"
    },
    {
        "api_name": "visit_binary",
        "full_api_name": "_VarWalkerImpl.visit_binary",
        "api_description": "",
        "api_signature": "visit_binary()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/visitors.py"
    },
    {
        "api_name": "visit_cast",
        "full_api_name": "_VarWalkerImpl.visit_cast",
        "api_description": "",
        "api_signature": "visit_cast()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/visitors.py"
    },
    {
        "api_name": "visit_index",
        "full_api_name": "_VarWalkerImpl.visit_index",
        "api_description": "",
        "api_signature": "visit_index()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/visitors.py"
    },
    {
        "api_name": "iter_vars",
        "full_api_name": "iter_vars",
        "api_description": "Get an iterator over the :class:`~.expr.Var` nodes referenced at any level in the given\n:class:`~.expr.Expr`.\n\nExamples:\n    Print out the name of each :class:`.ClassicalRegister` encountered::\n\n        from qiskit.circuit import ClassicalRegister\n        from qiskit.circuit.classical import expr\n\n        cr1 = ClassicalRegister(3, \"a\")\n        cr2 = ClassicalRegister(3, \"b\")\n\n        for node in expr.iter_vars(expr.bit_and(expr.bit_not(cr1), cr2)):\n            if isinstance(node.var, ClassicalRegister):\n                print(node.var.name)",
        "api_signature": "iter_vars(node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/visitors.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "_StructuralEquivalenceImpl.__init__",
        "api_description": "",
        "api_signature": "__init__(self, other, self_key, other_key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/visitors.py"
    },
    {
        "api_name": "visit_var",
        "full_api_name": "_StructuralEquivalenceImpl.visit_var",
        "api_description": "",
        "api_signature": "visit_var()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/visitors.py"
    },
    {
        "api_name": "visit_value",
        "full_api_name": "_StructuralEquivalenceImpl.visit_value",
        "api_description": "",
        "api_signature": "visit_value()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/visitors.py"
    },
    {
        "api_name": "visit_unary",
        "full_api_name": "_StructuralEquivalenceImpl.visit_unary",
        "api_description": "",
        "api_signature": "visit_unary()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/visitors.py"
    },
    {
        "api_name": "visit_binary",
        "full_api_name": "_StructuralEquivalenceImpl.visit_binary",
        "api_description": "",
        "api_signature": "visit_binary()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/visitors.py"
    },
    {
        "api_name": "visit_cast",
        "full_api_name": "_StructuralEquivalenceImpl.visit_cast",
        "api_description": "",
        "api_signature": "visit_cast()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/visitors.py"
    },
    {
        "api_name": "visit_index",
        "full_api_name": "_StructuralEquivalenceImpl.visit_index",
        "api_description": "",
        "api_signature": "visit_index()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/visitors.py"
    },
    {
        "api_name": "structurally_equivalent",
        "full_api_name": "structurally_equivalent",
        "api_description": "Do these two expressions have exactly the same tree structure, up to some key function for\nthe :class:`~.expr.Var` objects?\n\nIn other words, are these two expressions the exact same trees, except we compare the\n:attr:`.Var.var` fields by calling the appropriate ``*_var_key`` function on them, and comparing\nthat output for equality.  This function does not allow any semantic \"equivalences\" such as\nasserting that ``a == b`` is equivalent to ``b == a``; the evaluation order of the operands\ncould, in general, cause such a statement to be false (consider hypothetical ``extern``\nfunctions that access global state).\n\nThere's no requirements on the key functions, except that their outputs should have general\n``__eq__`` methods.  If a key function returns ``None``, the variable will be used verbatim\ninstead.\n\nArgs:\n    left: one of the :class:`~.expr.Expr` nodes.\n    right: the other :class:`~.expr.Expr` node.\n    left_var_key: a callable whose output should be used when comparing :attr:`.Var.var`\n        attributes.  If this argument is ``None`` or its output is ``None`` for a given\n        variable in ``left``, the variable will be used verbatim.\n    right_var_key: same as ``left_var_key``, but used on the variables in ``right`` instead.\n\nExamples:\n    Comparing two expressions for structural equivalence, with no remapping of the variables.\n    These are different because the different :class:`.Clbit` instances compare differently::\n\n        >>> from qiskit.circuit import Clbit\n        >>> from qiskit.circuit.classical import expr\n        >>> left_bits = [Clbit(), Clbit()]\n        >>> right_bits = [Clbit(), Clbit()]\n        >>> left = expr.logic_and(expr.logic_not(left_bits[0]), left_bits[1])\n        >>> right = expr.logic_and(expr.logic_not(right_bits[0]), right_bits[1])\n        >>> expr.structurally_equivalent(left, right)\n        False\n\n    Comparing the same two expressions, but this time using mapping functions that associate\n    the bits with simple indices::\n\n        >>> left_key = {var: i for i, var in enumerate(left_bits)}.get\n        >>> right_key = {var: i for i, var in enumerate(right_bits)}.get\n        >>> expr.structurally_equivalent(left, right, left_key, right_key)\n        True",
        "api_signature": "structurally_equivalent(left, right, left_var_key, right_var_key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/visitors.py"
    },
    {
        "api_name": "visit_var",
        "full_api_name": "_IsLValueImpl.visit_var",
        "api_description": "",
        "api_signature": "visit_var()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/visitors.py"
    },
    {
        "api_name": "visit_value",
        "full_api_name": "_IsLValueImpl.visit_value",
        "api_description": "",
        "api_signature": "visit_value()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/visitors.py"
    },
    {
        "api_name": "visit_unary",
        "full_api_name": "_IsLValueImpl.visit_unary",
        "api_description": "",
        "api_signature": "visit_unary()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/visitors.py"
    },
    {
        "api_name": "visit_binary",
        "full_api_name": "_IsLValueImpl.visit_binary",
        "api_description": "",
        "api_signature": "visit_binary()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/visitors.py"
    },
    {
        "api_name": "visit_cast",
        "full_api_name": "_IsLValueImpl.visit_cast",
        "api_description": "",
        "api_signature": "visit_cast()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/visitors.py"
    },
    {
        "api_name": "visit_index",
        "full_api_name": "_IsLValueImpl.visit_index",
        "api_description": "",
        "api_signature": "visit_index()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/visitors.py"
    },
    {
        "api_name": "is_lvalue",
        "full_api_name": "is_lvalue",
        "api_description": "Return whether this expression can be used in l-value positions, that is, whether it has a\nwell-defined location in memory, such as one that might be writeable.\n\nBeing an l-value is a necessary but not sufficient for this location to be writeable; it is\npermissible that a larger object containing this memory location may not allow writing from\nthe scope that attempts to write to it.  This would be an access property of the containing\nprogram, however, and not an inherent property of the expression system.\n\nExamples:\n    Literal values are never l-values; there's no memory location associated with (for example)\n    the constant ``1``::\n\n        >>> from qiskit.circuit.classical import expr\n        >>> expr.is_lvalue(expr.lift(2))\n        False\n\n    :class:`~.expr.Var` nodes are always l-values, because they always have some associated\n    memory location::\n\n        >>> from qiskit.circuit.classical import types\n        >>> from qiskit.circuit import Clbit\n        >>> expr.is_lvalue(expr.Var.new(\"a\", types.Bool()))\n        True\n        >>> expr.is_lvalue(expr.lift(Clbit()))\n        True\n\n    Currently there are no unary or binary operations on variables that can produce an l-value\n    expression, but it is likely in the future that some sort of \"indexing\" operation will be\n    added, which could produce l-values::\n\n        >>> a = expr.Var.new(\"a\", types.Uint(8))\n        >>> b = expr.Var.new(\"b\", types.Uint(8))\n        >>> expr.is_lvalue(a) and expr.is_lvalue(b)\n        True\n        >>> expr.is_lvalue(expr.bit_and(a, b))\n        False",
        "api_signature": "is_lvalue()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/visitors.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Expr.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/expr.py"
    },
    {
        "api_name": "accept",
        "full_api_name": "Expr.accept",
        "api_description": "Call the relevant ``visit_*`` method on the given :class:`ExprVisitor`.  The usual entry\npoint for a simple visitor is to construct it, and then call :meth:`accept` on the root\nobject to be visited.  For example::\n\n    expr = ...\n    visitor = MyVisitor()\n    visitor.accept(expr)\n\nSubclasses of :class:`Expr` should override this to call the correct virtual method on the\nvisitor.  This implements double dispatch with the visitor.",
        "api_signature": "accept()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/expr.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Cast.__init__",
        "api_description": "",
        "api_signature": "__init__(self, operand, type, implicit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/expr.py"
    },
    {
        "api_name": "accept",
        "full_api_name": "Cast.accept",
        "api_description": "",
        "api_signature": "accept()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/expr.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "Cast.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/expr.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "Cast.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/expr.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Var.__init__",
        "api_description": "",
        "api_signature": "__init__(self, var, type)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/expr.py"
    },
    {
        "api_name": "new",
        "full_api_name": "Var.new",
        "api_description": "Generate a new named variable that owns its own backing storage.",
        "api_signature": "new(cls, name, type)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/expr.py"
    },
    {
        "api_name": "standalone",
        "full_api_name": "Var.standalone",
        "api_description": "Whether this :class:`Var` is a standalone variable that owns its storage location.  If\nfalse, this is a wrapper :class:`Var` around a pre-existing circuit object.",
        "api_signature": "standalone(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/expr.py"
    },
    {
        "api_name": "accept",
        "full_api_name": "Var.accept",
        "api_description": "",
        "api_signature": "accept()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/expr.py"
    },
    {
        "api_name": "__setattr__",
        "full_api_name": "Var.__setattr__",
        "api_description": "",
        "api_signature": "__setattr__(self, key, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/expr.py"
    },
    {
        "api_name": "__hash__",
        "full_api_name": "Var.__hash__",
        "api_description": "",
        "api_signature": "__hash__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/expr.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "Var.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/expr.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "Var.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/expr.py"
    },
    {
        "api_name": "__getstate__",
        "full_api_name": "Var.__getstate__",
        "api_description": "",
        "api_signature": "__getstate__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/expr.py"
    },
    {
        "api_name": "__setstate__",
        "full_api_name": "Var.__setstate__",
        "api_description": "",
        "api_signature": "__setstate__(self, state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/expr.py"
    },
    {
        "api_name": "__copy__",
        "full_api_name": "Var.__copy__",
        "api_description": "",
        "api_signature": "__copy__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/expr.py"
    },
    {
        "api_name": "__deepcopy__",
        "full_api_name": "Var.__deepcopy__",
        "api_description": "",
        "api_signature": "__deepcopy__(self, memo)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/expr.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Value.__init__",
        "api_description": "",
        "api_signature": "__init__(self, value, type)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/expr.py"
    },
    {
        "api_name": "accept",
        "full_api_name": "Value.accept",
        "api_description": "",
        "api_signature": "accept()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/expr.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "Value.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/expr.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "Value.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/expr.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "Op.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/expr.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "Op.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/expr.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "__init__",
        "api_description": "",
        "api_signature": "__init__(self, op, operand, type)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/expr.py"
    },
    {
        "api_name": "accept",
        "full_api_name": "accept",
        "api_description": "",
        "api_signature": "accept()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/expr.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/expr.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/expr.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "Op.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/expr.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "Op.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/expr.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "__init__",
        "api_description": "",
        "api_signature": "__init__(self, op, left, right, type)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/expr.py"
    },
    {
        "api_name": "accept",
        "full_api_name": "accept",
        "api_description": "",
        "api_signature": "accept()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/expr.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/expr.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/expr.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Index.__init__",
        "api_description": "",
        "api_signature": "__init__(self, target, index, type)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/expr.py"
    },
    {
        "api_name": "accept",
        "full_api_name": "Index.accept",
        "api_description": "",
        "api_signature": "accept()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/expr.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "Index.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/expr.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "Index.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/classical/expr/expr.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "WhileLoopOp.__init__",
        "api_description": "Args:\n    condition: A condition to be checked prior to executing ``body``. Can be\n        specified as either a tuple of a ``ClassicalRegister`` to be tested\n        for equality with a given ``int``, or as a tuple of a ``Clbit`` to\n        be compared to either a ``bool`` or an ``int``.\n    body: The loop body to be repeatedly executed.\n    label: An optional label for identifying the instruction.",
        "api_signature": "__init__(self, condition, body, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/while_loop.py"
    },
    {
        "api_name": "params",
        "full_api_name": "WhileLoopOp.params",
        "api_description": "",
        "api_signature": "params(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/while_loop.py"
    },
    {
        "api_name": "params",
        "full_api_name": "WhileLoopOp.params",
        "api_description": "",
        "api_signature": "params(self, parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/while_loop.py"
    },
    {
        "api_name": "blocks",
        "full_api_name": "WhileLoopOp.blocks",
        "api_description": "",
        "api_signature": "blocks(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/while_loop.py"
    },
    {
        "api_name": "replace_blocks",
        "full_api_name": "WhileLoopOp.replace_blocks",
        "api_description": "",
        "api_signature": "replace_blocks(self, blocks)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/while_loop.py"
    },
    {
        "api_name": "c_if",
        "full_api_name": "WhileLoopOp.c_if",
        "api_description": "",
        "api_signature": "c_if(self, classical, val)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/while_loop.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "WhileLoopContext.__init__",
        "api_description": "",
        "api_signature": "__init__(self, circuit, condition)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/while_loop.py"
    },
    {
        "api_name": "__enter__",
        "full_api_name": "WhileLoopContext.__enter__",
        "api_description": "",
        "api_signature": "__enter__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/while_loop.py"
    },
    {
        "api_name": "__exit__",
        "full_api_name": "WhileLoopContext.__exit__",
        "api_description": "",
        "api_signature": "__exit__(self, exc_type, exc_val, exc_tb)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/while_loop.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "IfElseOp.__init__",
        "api_description": "Args:\n    condition: A condition to be evaluated in real time during circuit execution which,\n        if true, will trigger the evaluation of ``true_body``. Can be\n        specified as either a tuple of a ``ClassicalRegister`` to be\n        tested for equality with a given ``int``, or as a tuple of a\n        ``Clbit`` to be compared to either a ``bool`` or an ``int``.\n    true_body: A program to be executed if ``condition`` evaluates\n        to true.\n    false_body: A optional program to be executed if ``condition``\n        evaluates to false.\n    label: An optional label for identifying the instruction.",
        "api_signature": "__init__(self, condition, true_body, false_body, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/if_else.py"
    },
    {
        "api_name": "params",
        "full_api_name": "IfElseOp.params",
        "api_description": "",
        "api_signature": "params(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/if_else.py"
    },
    {
        "api_name": "params",
        "full_api_name": "IfElseOp.params",
        "api_description": "",
        "api_signature": "params(self, parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/if_else.py"
    },
    {
        "api_name": "blocks",
        "full_api_name": "IfElseOp.blocks",
        "api_description": "",
        "api_signature": "blocks(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/if_else.py"
    },
    {
        "api_name": "replace_blocks",
        "full_api_name": "IfElseOp.replace_blocks",
        "api_description": "Replace blocks and return new instruction.\n\nArgs:\n    blocks: Iterable of circuits for \"if\" and \"else\" condition. If there is no \"else\"\n        circuit it may be set to None or omitted.\n\nReturns:\n    New IfElseOp with replaced blocks.",
        "api_signature": "replace_blocks(self, blocks)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/if_else.py"
    },
    {
        "api_name": "c_if",
        "full_api_name": "IfElseOp.c_if",
        "api_description": "",
        "api_signature": "c_if(self, classical, val)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/if_else.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "IfElsePlaceholder.__init__",
        "api_description": "Args:\n    condition: the condition to execute the true block on.  This has the same semantics as\n        the ``condition`` argument to :obj:`.IfElseOp`.\n    true_block: the unbuilt scope block that will become the \"true\" branch at creation time.\n    false_block: if given, the unbuilt scope block that will become the \"false\" branch at\n        creation time.\n    label: the label to give the operator when it is created.",
        "api_signature": "__init__(self, condition, true_block, false_block)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/if_else.py"
    },
    {
        "api_name": "with_false_block",
        "full_api_name": "IfElsePlaceholder.with_false_block",
        "api_description": "Return a new placeholder instruction, with the false block set to the given value,\nupdating the bits used by both it and the true body, if necessary.\n\nIt is an error to try and set the false block on a placeholder that already has one.\n\nArgs:\n    false_block: The (unbuilt) instruction scope to set the false body to.\n\nReturns:\n    A new placeholder, with ``false_block`` set to the given input, and both true and false\n    blocks expanded to account for all resources.\n\nRaises:\n    CircuitError: if the false block of this placeholder instruction is already set.",
        "api_signature": "with_false_block(self, false_block)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/if_else.py"
    },
    {
        "api_name": "registers",
        "full_api_name": "IfElsePlaceholder.registers",
        "api_description": "Get the registers used by the interior blocks.",
        "api_signature": "registers(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/if_else.py"
    },
    {
        "api_name": "_calculate_placeholder_resources",
        "full_api_name": "IfElsePlaceholder._calculate_placeholder_resources",
        "api_description": "Get the placeholder resources (see :meth:`.placeholder_resources`).\n\nThis is a separate function because we use the resources during the initialization to\ndetermine how we should set our ``num_qubits`` and ``num_clbits``, so we implement the\npublic version as a cache access for efficiency.",
        "api_signature": "_calculate_placeholder_resources(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/if_else.py"
    },
    {
        "api_name": "placeholder_resources",
        "full_api_name": "IfElsePlaceholder.placeholder_resources",
        "api_description": "",
        "api_signature": "placeholder_resources(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/if_else.py"
    },
    {
        "api_name": "concrete_instruction",
        "full_api_name": "IfElsePlaceholder.concrete_instruction",
        "api_description": "",
        "api_signature": "concrete_instruction(self, qubits, clbits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/if_else.py"
    },
    {
        "api_name": "c_if",
        "full_api_name": "IfElsePlaceholder.c_if",
        "api_description": "",
        "api_signature": "c_if(self, classical, val)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/if_else.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "IfContext.__init__",
        "api_description": "",
        "api_signature": "__init__(self, circuit, condition)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/if_else.py"
    },
    {
        "api_name": "circuit",
        "full_api_name": "IfContext.circuit",
        "api_description": "Get the circuit that this context manager is attached to.",
        "api_signature": "circuit(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/if_else.py"
    },
    {
        "api_name": "condition",
        "full_api_name": "IfContext.condition",
        "api_description": "Get the expression that this statement is conditioned on.",
        "api_signature": "condition(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/if_else.py"
    },
    {
        "api_name": "appended_instructions",
        "full_api_name": "IfContext.appended_instructions",
        "api_description": "Get the instruction set that was created when this block finished.  If the block has not\nyet finished, then this will be ``None``.",
        "api_signature": "appended_instructions(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/if_else.py"
    },
    {
        "api_name": "in_loop",
        "full_api_name": "IfContext.in_loop",
        "api_description": "Whether this context manager is enclosed within a loop.",
        "api_signature": "in_loop(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/if_else.py"
    },
    {
        "api_name": "__enter__",
        "full_api_name": "IfContext.__enter__",
        "api_description": "",
        "api_signature": "__enter__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/if_else.py"
    },
    {
        "api_name": "__exit__",
        "full_api_name": "IfContext.__exit__",
        "api_description": "",
        "api_signature": "__exit__(self, exc_type, exc_val, exc_tb)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/if_else.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ElseContext.__init__",
        "api_description": "",
        "api_signature": "__init__(self, if_context)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/if_else.py"
    },
    {
        "api_name": "__enter__",
        "full_api_name": "ElseContext.__enter__",
        "api_description": "",
        "api_signature": "__enter__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/if_else.py"
    },
    {
        "api_name": "__exit__",
        "full_api_name": "ElseContext.__exit__",
        "api_description": "",
        "api_signature": "__exit__(self, exc_type, exc_val, exc_tb)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/if_else.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ControlFlowOp.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/control_flow.py"
    },
    {
        "api_name": "blocks",
        "full_api_name": "ControlFlowOp.blocks",
        "api_description": "Tuple of :class:`.QuantumCircuit`\\ s which may be executed as part of the\nexecution of this :class:`ControlFlowOp`.",
        "api_signature": "blocks(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/control_flow.py"
    },
    {
        "api_name": "replace_blocks",
        "full_api_name": "ControlFlowOp.replace_blocks",
        "api_description": "Return a new version of this control-flow operations with the :attr:`blocks` mapped to\nthe given new ones.\n\nTypically this is used in a workflow such as::\n\n    existing_op = ...\n\n    def map_block(block: QuantumCircuit) -> QuantumCircuit:\n        new_block = block.copy_empty_like()\n        # ... do something to `new_block` ...\n        return new_block\n\n    new_op = existing_op.replace_blocks(\n        map_block(block) for block in existing_op.blocks\n    )\n\nIt is the caller's responsibility to ensure that the mapped blocks are defined over a\nunified set of circuit resources, much like constructing a :class:`ControlFlowOp` using its\ndefault constructor.\n\nArgs:\n    blocks: the new subcircuit blocks to use.\n\nReturns:\n    New :class:`ControlFlowOp` with replaced blocks.",
        "api_signature": "replace_blocks(self, blocks)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/control_flow.py"
    },
    {
        "api_name": "iter_captured_vars",
        "full_api_name": "ControlFlowOp.iter_captured_vars",
        "api_description": "Get an iterator over the unique captured variables in all blocks of this construct.",
        "api_signature": "iter_captured_vars(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/control_flow.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BreakLoopOp.__init__",
        "api_description": "Args:\n    num_qubits: the number of qubits this affects.\n    num_clbits: the number of qubits this affects.\n    label: an optional string label for the instruction.",
        "api_signature": "__init__(self, num_qubits, num_clbits, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/break_loop.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BreakLoopPlaceholder.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/break_loop.py"
    },
    {
        "api_name": "concrete_instruction",
        "full_api_name": "BreakLoopPlaceholder.concrete_instruction",
        "api_description": "",
        "api_signature": "concrete_instruction(self, qubits, clbits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/break_loop.py"
    },
    {
        "api_name": "placeholder_resources",
        "full_api_name": "BreakLoopPlaceholder.placeholder_resources",
        "api_description": "",
        "api_signature": "placeholder_resources(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/break_loop.py"
    },
    {
        "api_name": "instructions",
        "full_api_name": "CircuitScopeInterface.instructions",
        "api_description": "Indexable view onto the :class:`.CircuitInstruction`s backing this scope.",
        "api_signature": "instructions(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/builder.py"
    },
    {
        "api_name": "append",
        "full_api_name": "CircuitScopeInterface.append",
        "api_description": "Low-level 'append' primitive; this may assume that the qubits, clbits and operation are\nall valid for the circuit.\n\nAbstraction of :meth:`.QuantumCircuit._append` (the low-level one, not the high-level).\n\nArgs:\n    instruction: the resource-validated instruction context object.\n\nReturns:\n    the instruction context object actually appended.  This is not required to be the same\n    as the object given (but typically will be).",
        "api_signature": "append(self, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/builder.py"
    },
    {
        "api_name": "extend",
        "full_api_name": "CircuitScopeInterface.extend",
        "api_description": "Appends all instructions from ``data`` to the scope.\n\nArgs:\n    data: The instruction listing.",
        "api_signature": "extend(self, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/builder.py"
    },
    {
        "api_name": "resolve_classical_resource",
        "full_api_name": "CircuitScopeInterface.resolve_classical_resource",
        "api_description": "Resolve a single bit-like classical-resource specifier.\n\nA resource refers to either a classical bit or a register, where integers index into the\nclassical bits of the greater circuit.\n\nThis is called whenever a classical bit or register is being used outside the standard\n:class:`.Clbit` usage of instructions in :meth:`append`, such as in a legacy two-tuple\ncondition.\n\nArgs:\n    specifier: the classical resource specifier.\n\nReturns:\n    the resolved resource.  This cannot be an integer any more; an integer input is resolved\n    into a classical bit.\n\nRaises:\n    CircuitError: if the resource cannot be used by the scope, such as an out-of-range index\n        or a :class:`.Clbit` that isn't actually in the circuit.",
        "api_signature": "resolve_classical_resource(self, specifier)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/builder.py"
    },
    {
        "api_name": "add_uninitialized_var",
        "full_api_name": "CircuitScopeInterface.add_uninitialized_var",
        "api_description": "Add an uninitialized variable to the circuit scope.\n\nThe general circuit context is responsible for ensuring the variable is initialized.  These\nuninitialized variables are guaranteed to be standalone.\n\nArgs:\n    var: the variable to add, if valid.\n\nRaises:\n    CircuitError: if the variable cannot be added, such as because it invalidly shadows or\n        redefines an existing name.",
        "api_signature": "add_uninitialized_var(self, var)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/builder.py"
    },
    {
        "api_name": "remove_var",
        "full_api_name": "CircuitScopeInterface.remove_var",
        "api_description": "Remove a variable from the locals of this scope.\n\nThis is only called in the case that an exception occurred while initializing the variable,\nand is not exposed to users.\n\nArgs:\n    var: the variable to remove.  It can be assumed that this was already the subject of an\n        :meth:`add_uninitialized_var` call.",
        "api_signature": "remove_var(self, var)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/builder.py"
    },
    {
        "api_name": "use_var",
        "full_api_name": "CircuitScopeInterface.use_var",
        "api_description": "Called for every standalone classical real-time variable being used by some circuit\ninstruction.\n\nThe given variable is guaranteed to be a stand-alone variable; bit-like resource-wrapping\nvariables will have been filtered out and their resources given to\n:meth:`resolve_classical_resource`.\n\nArgs:\n    var: the variable to validate.\n\nReturns:\n    the same variable.\n\nRaises:\n    CircuitError: if the variable is not valid for this scope.",
        "api_signature": "use_var(self, var)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/builder.py"
    },
    {
        "api_name": "get_var",
        "full_api_name": "CircuitScopeInterface.get_var",
        "api_description": "Get the variable (if any) in scope with the given name.\n\nThis should call up to the parent scope if in a control-flow builder scope, in case the\nvariable exists in an outer scope.\n\nArgs:\n    name: the name of the symbol to lookup.\n\nReturns:\n    the variable if it is found, otherwise ``None``.",
        "api_signature": "get_var(self, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/builder.py"
    },
    {
        "api_name": "concrete_instruction",
        "full_api_name": "InstructionPlaceholder.concrete_instruction",
        "api_description": "Get a concrete, complete instruction that is valid to act over all the given resources.\n\nThe returned resources may not be the full width of the given resources, but will certainly\nbe a subset of them; this can occur if (for example) a placeholder ``if`` statement is\npresent, but does not itself contain any placeholder instructions.  For resource efficiency,\nthe returned :class:`.ControlFlowOp` will not unnecessarily span all resources, but only the\nones that it needs.\n\n.. note::\n\n    The caller of this function is responsible for ensuring that the inputs to this function\n    are non-strict supersets of the bits returned by :meth:`placeholder_resources`.\n\nAny condition added in by a call to :obj:`.Instruction.c_if` will be propagated through, but\nset properties like ``duration`` will not; it doesn't make sense for control-flow operations\nto have pulse scheduling on them.\n\nArgs:\n    qubits: The qubits the created instruction should be defined across.\n    clbits: The clbits the created instruction should be defined across.\n\nReturns:\n    A full version of the relevant control-flow instruction, and the resources that it uses.\n    This is a \"proper\" instruction instance, as if it had been defined with the correct\n    number of qubits and clbits from the beginning.",
        "api_signature": "concrete_instruction(self, qubits, clbits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/builder.py"
    },
    {
        "api_name": "placeholder_resources",
        "full_api_name": "InstructionPlaceholder.placeholder_resources",
        "api_description": "Get the qubit and clbit resources that this placeholder instruction should be considered\nas using before construction.\n\nThis will likely not include *all* resources after the block has been built, but using the\noutput of this method ensures that all resources will pass through a\n:meth:`.QuantumCircuit.append` call, even if they come from a placeholder, and consequently\nwill be tracked by the scope managers.\n\nReturns:\n    A collection of the quantum and classical resources this placeholder instruction will\n    certainly use.",
        "api_signature": "placeholder_resources(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/builder.py"
    },
    {
        "api_name": "_copy_mutable_properties",
        "full_api_name": "InstructionPlaceholder._copy_mutable_properties",
        "api_description": "Copy mutable properties from ourselves onto a non-placeholder instruction.\n\nThe mutable properties are expected to be things like ``condition``, added onto a\nplaceholder by the :meth:`c_if` method.  This mutates ``instruction``, and returns the same\ninstance that was passed.  This is mostly intended to make writing concrete versions of\n:meth:`.concrete_instruction` easy.\n\nThe complete list of mutations is:\n\n* ``condition``, added by :meth:`c_if`.\n\nArgs:\n    instruction: the concrete instruction instance to be mutated.\n\nReturns:\n    The same instruction instance that was passed, but mutated to propagate the tracked\n    changes to this class.",
        "api_signature": "_copy_mutable_properties(self, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/builder.py"
    },
    {
        "api_name": "assemble",
        "full_api_name": "InstructionPlaceholder.assemble",
        "api_description": "",
        "api_signature": "assemble(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/builder.py"
    },
    {
        "api_name": "repeat",
        "full_api_name": "InstructionPlaceholder.repeat",
        "api_description": "",
        "api_signature": "repeat(self, n)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/builder.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ControlFlowBuilderBlock.__init__",
        "api_description": "Args:\n    qubits: Any qubits this scope should consider itself as using from the beginning.\n    clbits: Any clbits this scope should consider itself as using from the beginning.  Along\n        with ``qubits``, this is useful for things such as ``if`` and ``while`` loop\n        builders, where the classical condition has associated resources, and is known when\n        this scope is created.\n    registers: Any registers this scope should consider itself as using from the\n        beginning.  This is useful for :obj:`.IfElseOp` and :obj:`.WhileLoopOp` instances\n        which use a classical register as their condition.\n    allow_jumps: Whether this builder scope should allow ``break`` and ``continue``\n        statements within it.  This is intended to help give sensible error messages when\n        dangerous behavior is encountered, such as using ``break`` inside an ``if`` context\n        manager that is not within a ``for`` manager.  This can only be safe if the user is\n        going to place the resulting :obj:`.QuantumCircuit` inside a :obj:`.ForLoopOp` that\n        uses *exactly* the same set of resources.  We cannot verify this from within the\n        builder interface (and it is too expensive to do when the ``for`` op is made), so we\n        fail safe, and require the user to use the more verbose, internal form.\n    parent: The scope interface of the containing scope.\n    forbidden_message: If a string is given here, a :exc:`.CircuitError` will be raised on\n        any attempts to append instructions to the scope with this message.  This is used by\n        pseudo scopes where the state machine of the builder scopes has changed into a\n        position where no instructions should be accepted, such as when inside a ``switch``\n        but outside any cases.",
        "api_signature": "__init__(self, qubits, clbits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/builder.py"
    },
    {
        "api_name": "qubits",
        "full_api_name": "ControlFlowBuilderBlock.qubits",
        "api_description": "The set of qubits associated with this scope.",
        "api_signature": "qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/builder.py"
    },
    {
        "api_name": "clbits",
        "full_api_name": "ControlFlowBuilderBlock.clbits",
        "api_description": "The set of clbits associated with this scope.",
        "api_signature": "clbits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/builder.py"
    },
    {
        "api_name": "allow_jumps",
        "full_api_name": "ControlFlowBuilderBlock.allow_jumps",
        "api_description": "Whether this builder scope should allow ``break`` and ``continue`` statements within it.\n\nThis is intended to help give sensible error messages when dangerous behavior is\nencountered, such as using ``break`` inside an ``if`` context manager that is not within a\n``for`` manager.  This can only be safe if the user is going to place the resulting\n:obj:`.QuantumCircuit` inside a :obj:`.ForLoopOp` that uses *exactly* the same set of\nresources.  We cannot verify this from within the builder interface (and it is too expensive\nto do when the ``for`` op is made), so we fail safe, and require the user to use the more\nverbose, internal form.",
        "api_signature": "allow_jumps(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/builder.py"
    },
    {
        "api_name": "instructions",
        "full_api_name": "ControlFlowBuilderBlock.instructions",
        "api_description": "",
        "api_signature": "instructions(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/builder.py"
    },
    {
        "api_name": "_raise_on_jump",
        "full_api_name": "ControlFlowBuilderBlock._raise_on_jump",
        "api_description": "",
        "api_signature": "_raise_on_jump(operation)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/builder.py"
    },
    {
        "api_name": "append",
        "full_api_name": "ControlFlowBuilderBlock.append",
        "api_description": "",
        "api_signature": "append(self, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/builder.py"
    },
    {
        "api_name": "extend",
        "full_api_name": "ControlFlowBuilderBlock.extend",
        "api_description": "",
        "api_signature": "extend(self, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/builder.py"
    },
    {
        "api_name": "resolve_classical_resource",
        "full_api_name": "ControlFlowBuilderBlock.resolve_classical_resource",
        "api_description": "",
        "api_signature": "resolve_classical_resource(self, specifier)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/builder.py"
    },
    {
        "api_name": "add_uninitialized_var",
        "full_api_name": "ControlFlowBuilderBlock.add_uninitialized_var",
        "api_description": "",
        "api_signature": "add_uninitialized_var(self, var)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/builder.py"
    },
    {
        "api_name": "remove_var",
        "full_api_name": "ControlFlowBuilderBlock.remove_var",
        "api_description": "",
        "api_signature": "remove_var(self, var)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/builder.py"
    },
    {
        "api_name": "get_var",
        "full_api_name": "ControlFlowBuilderBlock.get_var",
        "api_description": "",
        "api_signature": "get_var(self, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/builder.py"
    },
    {
        "api_name": "use_var",
        "full_api_name": "ControlFlowBuilderBlock.use_var",
        "api_description": "",
        "api_signature": "use_var(self, var)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/builder.py"
    },
    {
        "api_name": "iter_local_vars",
        "full_api_name": "ControlFlowBuilderBlock.iter_local_vars",
        "api_description": "Iterator over the variables currently declared in this scope.",
        "api_signature": "iter_local_vars(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/builder.py"
    },
    {
        "api_name": "iter_captured_vars",
        "full_api_name": "ControlFlowBuilderBlock.iter_captured_vars",
        "api_description": "Iterator over the variables currently captured in this scope.",
        "api_signature": "iter_captured_vars(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/builder.py"
    },
    {
        "api_name": "peek",
        "full_api_name": "ControlFlowBuilderBlock.peek",
        "api_description": "Get the value of the most recent instruction tuple in this scope.",
        "api_signature": "peek(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/builder.py"
    },
    {
        "api_name": "pop",
        "full_api_name": "ControlFlowBuilderBlock.pop",
        "api_description": "Get the value of the most recent instruction in this scope, and remove it from this\nobject.",
        "api_signature": "pop(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/builder.py"
    },
    {
        "api_name": "add_bits",
        "full_api_name": "ControlFlowBuilderBlock.add_bits",
        "api_description": "Add extra bits to this scope that are not associated with any concrete instruction yet.\n\nThis is useful for expanding a scope's resource width when it may contain ``break`` or\n``continue`` statements, or when its width needs to be expanded to match another scope's\nwidth (as in the case of :obj:`.IfElseOp`).\n\nArgs:\n    bits: The qubits and clbits that should be added to a scope.  It is not an error if\n        there are duplicates, either within the iterable or with the bits currently in\n        scope.\n\nRaises:\n    TypeError: if the provided bit is of an incorrect type.",
        "api_signature": "add_bits(self, bits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/builder.py"
    },
    {
        "api_name": "add_register",
        "full_api_name": "ControlFlowBuilderBlock.add_register",
        "api_description": "Add a :obj:`.Register` to the set of resources used by this block, ensuring that\nall bits contained within are also accounted for.\n\nArgs:\n    register: the register to add to the block.",
        "api_signature": "add_register(self, register)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/builder.py"
    },
    {
        "api_name": "build",
        "full_api_name": "ControlFlowBuilderBlock.build",
        "api_description": "Build this scoped block into a complete :obj:`.QuantumCircuit` instance.\n\nThis will build a circuit which contains all of the necessary qubits and clbits and no\nothers.\n\nThe ``qubits`` and ``clbits`` arguments should be sets that contains all the resources in\nthe outer scope; these will be passed down to inner placeholder instructions, so they can\napply themselves across the whole scope should they need to.  The resulting\n:obj:`.QuantumCircuit` will be defined over a (nonstrict) subset of these resources.  This\nis used to let ``break`` and ``continue`` span all resources, even if they are nested within\nseveral :obj:`.IfElsePlaceholder` objects, without requiring :obj:`.IfElsePlaceholder`\nobjects *without* any ``break`` or ``continue`` statements to be full-width.\n\nArgs:\n    all_qubits: all the qubits in the containing scope of this block.  The block may expand\n        to use some or all of these qubits, but will never gain qubits that are not in this\n        set.\n    all_clbits: all the clbits in the containing scope of this block.  The block may expand\n        to use some or all of these clbits, but will never gain clbits that are not in this\n        set.\n\nReturns:\n    A circuit containing concrete versions of all the instructions that were in the scope,\n    and using the minimal set of resources necessary to support them, within the enclosing\n    scope.",
        "api_signature": "build(self, all_qubits, all_clbits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/builder.py"
    },
    {
        "api_name": "update_registers",
        "full_api_name": "ControlFlowBuilderBlock.update_registers",
        "api_description": "",
        "api_signature": "update_registers(index, op)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/builder.py"
    },
    {
        "api_name": "copy",
        "full_api_name": "ControlFlowBuilderBlock.copy",
        "api_description": "Return a semi-shallow copy of this builder block.\n\nThe instruction lists and sets of qubits and clbits will be new instances (so mutations will\nnot propagate), but any :obj:`.Instruction` instances within them will not be copied.\n\nReturns:\n    a semi-shallow copy of this object.",
        "api_signature": "copy(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/builder.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "_DefaultCaseType.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/switch_case.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SwitchCaseOp.__init__",
        "api_description": "Args:\n    target: the real-time value to switch on.\n    cases: an ordered iterable of the corresponding value of the ``target`` and the circuit\n        block that should be executed if this is matched.  There is no fall-through between\n        blocks, and the order matters.",
        "api_signature": "__init__(self, target, cases)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/switch_case.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "SwitchCaseOp.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/switch_case.py"
    },
    {
        "api_name": "cases_specifier",
        "full_api_name": "SwitchCaseOp.cases_specifier",
        "api_description": "Return an iterable where each element is a 2-tuple whose first element is a tuple of\njump values, and whose second is the single circuit block that is associated with those\nvalues.\n\nThis is an abstract specification of the jump table suitable for creating new\n:class:`.SwitchCaseOp` instances.\n\n.. seealso::\n    :meth:`.SwitchCaseOp.cases`\n        Create a lookup table that you can use for your own purposes to jump from values to\n        the circuit that would be executed.",
        "api_signature": "cases_specifier(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/switch_case.py"
    },
    {
        "api_name": "cases",
        "full_api_name": "SwitchCaseOp.cases",
        "api_description": "Return a lookup table from case labels to the circuit that would be executed in that\ncase.  This object is not generally suitable for creating a new :class:`.SwitchCaseOp`\nbecause any keys that point to the same object will not be grouped.\n\n.. seealso::\n    :meth:`.SwitchCaseOp.cases_specifier`\n        An alternate method that produces its output in a suitable format for creating new\n        :class:`.SwitchCaseOp` instances.",
        "api_signature": "cases(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/switch_case.py"
    },
    {
        "api_name": "blocks",
        "full_api_name": "SwitchCaseOp.blocks",
        "api_description": "",
        "api_signature": "blocks(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/switch_case.py"
    },
    {
        "api_name": "replace_blocks",
        "full_api_name": "SwitchCaseOp.replace_blocks",
        "api_description": "",
        "api_signature": "replace_blocks(self, blocks)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/switch_case.py"
    },
    {
        "api_name": "c_if",
        "full_api_name": "SwitchCaseOp.c_if",
        "api_description": "",
        "api_signature": "c_if(self, classical, val)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/switch_case.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SwitchCasePlaceholder.__init__",
        "api_description": "",
        "api_signature": "__init__(self, target, cases)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/switch_case.py"
    },
    {
        "api_name": "_calculate_placeholder_resources",
        "full_api_name": "SwitchCasePlaceholder._calculate_placeholder_resources",
        "api_description": "",
        "api_signature": "_calculate_placeholder_resources(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/switch_case.py"
    },
    {
        "api_name": "placeholder_resources",
        "full_api_name": "SwitchCasePlaceholder.placeholder_resources",
        "api_description": "",
        "api_signature": "placeholder_resources(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/switch_case.py"
    },
    {
        "api_name": "concrete_instruction",
        "full_api_name": "SwitchCasePlaceholder.concrete_instruction",
        "api_description": "",
        "api_signature": "concrete_instruction(self, qubits, clbits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/switch_case.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SwitchContext.__init__",
        "api_description": "",
        "api_signature": "__init__(self, circuit, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/switch_case.py"
    },
    {
        "api_name": "label_in_use",
        "full_api_name": "SwitchContext.label_in_use",
        "api_description": "Return whether a case label is already accounted for in the switch statement.",
        "api_signature": "label_in_use(self, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/switch_case.py"
    },
    {
        "api_name": "add_case",
        "full_api_name": "SwitchContext.add_case",
        "api_description": "Add a sequence of conditions and the single block that should be run if they are\ntriggered to the context.  The labels are assumed to have already been validated using\n:meth:`label_in_use`.",
        "api_signature": "add_case(self, labels, block)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/switch_case.py"
    },
    {
        "api_name": "__enter__",
        "full_api_name": "SwitchContext.__enter__",
        "api_description": "",
        "api_signature": "__enter__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/switch_case.py"
    },
    {
        "api_name": "__exit__",
        "full_api_name": "SwitchContext.__exit__",
        "api_description": "",
        "api_signature": "__exit__(self, exc_type, exc_val, exc_tb)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/switch_case.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CaseBuilder.__init__",
        "api_description": "",
        "api_signature": "__init__(self, parent)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/switch_case.py"
    },
    {
        "api_name": "__call__",
        "full_api_name": "CaseBuilder.__call__",
        "api_description": "",
        "api_signature": "__call__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/switch_case.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ForLoopOp.__init__",
        "api_description": "Args:\n    indexset: A collection of integers to loop over.\n    loop_parameter: The placeholder parameterizing ``body`` to which\n        the values from ``indexset`` will be assigned.\n    body: The loop body to be repeatedly executed.\n    label: An optional label for identifying the instruction.",
        "api_signature": "__init__(self, indexset, loop_parameter, body, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/for_loop.py"
    },
    {
        "api_name": "params",
        "full_api_name": "ForLoopOp.params",
        "api_description": "",
        "api_signature": "params(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/for_loop.py"
    },
    {
        "api_name": "params",
        "full_api_name": "ForLoopOp.params",
        "api_description": "",
        "api_signature": "params(self, parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/for_loop.py"
    },
    {
        "api_name": "blocks",
        "full_api_name": "ForLoopOp.blocks",
        "api_description": "",
        "api_signature": "blocks(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/for_loop.py"
    },
    {
        "api_name": "replace_blocks",
        "full_api_name": "ForLoopOp.replace_blocks",
        "api_description": "",
        "api_signature": "replace_blocks(self, blocks)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/for_loop.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ForLoopContext.__init__",
        "api_description": "",
        "api_signature": "__init__(self, circuit, indexset, loop_parameter)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/for_loop.py"
    },
    {
        "api_name": "__enter__",
        "full_api_name": "ForLoopContext.__enter__",
        "api_description": "",
        "api_signature": "__enter__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/for_loop.py"
    },
    {
        "api_name": "__exit__",
        "full_api_name": "ForLoopContext.__exit__",
        "api_description": "",
        "api_signature": "__exit__(self, exc_type, exc_val, exc_tb)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/for_loop.py"
    },
    {
        "api_name": "validate_condition",
        "full_api_name": "validate_condition",
        "api_description": "Validate that a condition is in a valid format and return it, but raise if it is invalid.\n\nArgs:\n    condition: the condition to be tested for validity.  Must be either the legacy 2-tuple\n        format, or a :class:`~.expr.Expr` that has `Bool` type.\n\nRaises:\n    CircuitError: if the condition is not in a valid format.\n\nReturns:\n    The same condition as passed, if it was valid.",
        "api_signature": "validate_condition(condition)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/_builder_utils.py"
    },
    {
        "api_name": "node_resources",
        "full_api_name": "node_resources",
        "api_description": "Get the legacy classical resources (:class:`.Clbit` and :class:`.ClassicalRegister`)\nreferenced by an :class:`~.expr.Expr`.",
        "api_signature": "node_resources(node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/_builder_utils.py"
    },
    {
        "api_name": "condition_resources",
        "full_api_name": "condition_resources",
        "api_description": "Get the legacy classical resources (:class:`.Clbit` and :class:`.ClassicalRegister`)\nreferenced by a legacy condition or an :class:`~.expr.Expr`.",
        "api_signature": "condition_resources(condition)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/_builder_utils.py"
    },
    {
        "api_name": "partition_registers",
        "full_api_name": "partition_registers",
        "api_description": "Partition a sequence of registers into its quantum and classical registers.",
        "api_signature": "partition_registers(registers)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/_builder_utils.py"
    },
    {
        "api_name": "unify_circuit_resources",
        "full_api_name": "unify_circuit_resources",
        "api_description": "Ensure that all the given ``circuits`` have all the same qubits, clbits and registers, and\nthat they are defined in the same order.  The order is important for binding when the bodies are\nused in the 3-tuple :obj:`.Instruction` context.\n\nThis function will preferentially try to mutate its inputs if they share an ordering, but if\nnot, it will rebuild two new circuits.  This is to avoid coupling too tightly to the inner\nclass; there is no real support for deleting or re-ordering bits within a :obj:`.QuantumCircuit`\ncontext, and we don't want to rely on the *current* behavior of the private APIs, since they\nare very liable to change.  No matter the method used, circuits with unified bits and registers\nare returned.",
        "api_signature": "unify_circuit_resources(circuits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/_builder_utils.py"
    },
    {
        "api_name": "_unify_circuit_resources_rebuild",
        "full_api_name": "_unify_circuit_resources_rebuild",
        "api_description": "Ensure that all the given circuits have all the same qubits and clbits, and that they\nare defined in the same order.  The order is important for binding when the bodies are used in\nthe 3-tuple :obj:`.Instruction` context.\n\nThis function will always rebuild the objects into new :class:`.QuantumCircuit` instances.",
        "api_signature": "_unify_circuit_resources_rebuild(circuits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/_builder_utils.py"
    },
    {
        "api_name": "_unify_circuit_registers",
        "full_api_name": "_unify_circuit_registers",
        "api_description": "Ensure that ``true_body`` and ``false_body`` have the same registers defined within them.  These\ndo not need to be in the same order between circuits.  The two input circuits are returned,\nmutated to have the same registers.",
        "api_signature": "_unify_circuit_registers(circuits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/_builder_utils.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ContinueLoopOp.__init__",
        "api_description": "Args:\n    num_qubits: the number of qubits this affects.\n    num_clbits: the number of qubits this affects.\n    label: an optional string label for the instruction.",
        "api_signature": "__init__(self, num_qubits, num_clbits, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/continue_loop.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ContinueLoopPlaceholder.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/continue_loop.py"
    },
    {
        "api_name": "concrete_instruction",
        "full_api_name": "ContinueLoopPlaceholder.concrete_instruction",
        "api_description": "",
        "api_signature": "concrete_instruction(self, qubits, clbits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/continue_loop.py"
    },
    {
        "api_name": "placeholder_resources",
        "full_api_name": "ContinueLoopPlaceholder.placeholder_resources",
        "api_description": "",
        "api_signature": "placeholder_resources(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/circuit/controlflow/continue_loop.py"
    },
    {
        "api_name": "transpile",
        "full_api_name": "transpile",
        "api_description": "Transpile one or more circuits, according to some desired transpilation targets.\n\nTranspilation is potentially done in parallel using multiprocessing when ``circuits``\nis a list with > 1 :class:`~.QuantumCircuit` object, depending on the local environment\nand configuration.\n\nThe prioritization of transpilation target constraints works as follows: if a ``target``\ninput is provided, it will take priority over any ``backend`` input or loose constraints\n(``basis_gates``, ``inst_map``, ``coupling_map``, ``backend_properties``, ``instruction_durations``,\n``dt`` or ``timing_constraints``). If a ``backend`` is provided together with any loose constraint\nfrom the list above, the loose constraint will take priority over the corresponding backend\nconstraint. This behavior is independent of whether the ``backend`` instance is of type\n:class:`.BackendV1` or :class:`.BackendV2`, as summarized in the table below. The first column\nin the table summarizes the potential user-provided constraints, and each cell shows whether\nthe priority is assigned to that specific constraint input or another input\n(`target`/`backend(V1)`/`backend(V2)`).\n\n============================ ========= ======================== =======================\nUser Provided                target    backend(V1)              backend(V2)\n============================ ========= ======================== =======================\n**basis_gates**              target    basis_gates              basis_gates\n**coupling_map**             target    coupling_map             coupling_map\n**instruction_durations**    target    instruction_durations    instruction_durations\n**inst_map**                 target    inst_map                 inst_map\n**dt**                       target    dt                       dt\n**timing_constraints**       target    timing_constraints       timing_constraints\n**backend_properties**       target    backend_properties       backend_properties\n============================ ========= ======================== =======================\n\nArgs:\n    circuits: Circuit(s) to transpile\n    backend: If set, the transpiler will compile the input circuit to this target\n        device. If any other option is explicitly set (e.g., ``coupling_map``), it\n        will override the backend's.\n    basis_gates: List of basis gate names to unroll to\n        (e.g: ``['u1', 'u2', 'u3', 'cx']``). If ``None``, do not unroll.\n    inst_map: Mapping of unrolled gates to pulse schedules. If this is not provided,\n        transpiler tries to get from the backend. If any user defined calibration\n        is found in the map and this is used in a circuit, transpiler attaches\n        the custom gate definition to the circuit. This enables one to flexibly\n        override the low-level instruction implementation. This feature is available\n        iff the backend supports the pulse gate experiment.\n    coupling_map: Directed coupling map (perhaps custom) to target in mapping. If\n        the coupling map is symmetric, both directions need to be specified.\n\n        Multiple formats are supported:\n\n        #. ``CouplingMap`` instance\n        #. List, must be given as an adjacency matrix, where each entry\n           specifies all directed two-qubit interactions supported by backend,\n           e.g: ``[[0, 1], [0, 3], [1, 2], [1, 5], [2, 5], [4, 1], [5, 3]]``\n\n    backend_properties: properties returned by a backend, including information on gate\n        errors, readout errors, qubit coherence times, etc. Find a backend\n        that provides this information with: ``backend.properties()``\n    initial_layout: Initial position of virtual qubits on physical qubits.\n        If this layout makes the circuit compatible with the coupling_map\n        constraints, it will be used. The final layout is not guaranteed to be the same,\n        as the transpiler may permute qubits through swaps or other means.\n        Multiple formats are supported:\n\n        #. ``Layout`` instance\n        #. Dict\n           * virtual to physical::\n\n                {qr[0]: 0,\n                 qr[1]: 3,\n                 qr[2]: 5}\n\n           * physical to virtual::\n\n                {0: qr[0],\n                 3: qr[1],\n                 5: qr[2]}\n\n        #. List\n\n           * virtual to physical::\n\n                [0, 3, 5]  # virtual qubits are ordered (in addition to named)\n\n           * physical to virtual::\n\n                [qr[0], None, None, qr[1], None, qr[2]]\n\n    layout_method: Name of layout selection pass ('trivial', 'dense', 'sabre').\n        This can also be the external plugin name to use for the ``layout`` stage.\n        You can see a list of installed plugins by using :func:`~.list_stage_plugins` with\n        ``\"layout\"`` for the ``stage_name`` argument.\n    routing_method: Name of routing pass\n        ('basic', 'lookahead', 'stochastic', 'sabre', 'none'). Note\n        This can also be the external plugin name to use for the ``routing`` stage.\n        You can see a list of installed plugins by using :func:`~.list_stage_plugins` with\n        ``\"routing\"`` for the ``stage_name`` argument.\n    translation_method: Name of translation pass ('unroller', 'translator', 'synthesis')\n        This can also be the external plugin name to use for the ``translation`` stage.\n        You can see a list of installed plugins by using :func:`~.list_stage_plugins` with\n        ``\"translation\"`` for the ``stage_name`` argument.\n    scheduling_method: Name of scheduling pass.\n        * ``'as_soon_as_possible'``: Schedule instructions greedily, as early as possible\n        on a qubit resource. (alias: ``'asap'``)\n        * ``'as_late_as_possible'``: Schedule instructions late, i.e. keeping qubits\n        in the ground state when possible. (alias: ``'alap'``)\n        If ``None``, no scheduling will be done. This can also be the external plugin name\n        to use for the ``scheduling`` stage. You can see a list of installed plugins by\n        using :func:`~.list_stage_plugins` with ``\"scheduling\"`` for the ``stage_name``\n        argument.\n    instruction_durations: Durations of instructions.\n        Applicable only if scheduling_method is specified.\n        The gate lengths defined in ``backend.properties`` are used as default.\n        They are overwritten if this ``instruction_durations`` is specified.\n        The format of ``instruction_durations`` must be as follows.\n        The `instruction_durations` must be given as a list of tuples\n        [(instruction_name, qubits, duration, unit), ...].\n        | [('cx', [0, 1], 12.3, 'ns'), ('u3', [0], 4.56, 'ns')]\n        | [('cx', [0, 1], 1000), ('u3', [0], 300)]\n        If unit is omitted, the default is 'dt', which is a sample time depending on backend.\n        If the time unit is 'dt', the duration must be an integer.\n    dt: Backend sample time (resolution) in seconds.\n        If ``None`` (default), ``backend.configuration().dt`` is used.\n    approximation_degree (float): heuristic dial used for circuit approximation\n        (1.0=no approximation, 0.0=maximal approximation)\n    timing_constraints: An optional control hardware restriction on instruction time resolution.\n        A quantum computer backend may report a set of restrictions, namely:\n\n        - granularity: An integer value representing minimum pulse gate\n          resolution in units of ``dt``. A user-defined pulse gate should have\n          duration of a multiple of this granularity value.\n        - min_length: An integer value representing minimum pulse gate\n          length in units of ``dt``. A user-defined pulse gate should be longer\n          than this length.\n        - pulse_alignment: An integer value representing a time resolution of gate\n          instruction starting time. Gate instruction should start at time which\n          is a multiple of the alignment value.\n        - acquire_alignment: An integer value representing a time resolution of measure\n          instruction starting time. Measure instruction should start at time which\n          is a multiple of the alignment value.\n\n        This information will be provided by the backend configuration.\n        If the backend doesn't have any restriction on the instruction time allocation,\n        then ``timing_constraints`` is None and no adjustment will be performed.\n    seed_transpiler: Sets random seed for the stochastic parts of the transpiler\n    optimization_level: How much optimization to perform on the circuits.\n        Higher levels generate more optimized circuits,\n        at the expense of longer transpilation time.\n\n        * 0: no optimization\n        * 1: light optimization\n        * 2: heavy optimization\n        * 3: even heavier optimization\n\n        If ``None``, level 1 will be chosen as default.\n    callback: A callback function that will be called after each\n        pass execution. The function will be called with 5 keyword\n        arguments,\n        | ``pass_``: the pass being run.\n        | ``dag``: the dag output of the pass.\n        | ``time``: the time to execute the pass.\n        | ``property_set``: the property set.\n        | ``count``: the index for the pass execution.\n        The exact arguments passed expose the internals of the pass manager,\n        and are subject to change as the pass manager internals change. If\n        you intend to reuse a callback function over multiple releases, be\n        sure to check that the arguments being passed are the same.\n        To use the callback feature, define a function that will\n        take in kwargs dict and access the variables. For example::\n\n            def callback_func(**kwargs):\n                pass_ = kwargs['pass_']\n                dag = kwargs['dag']\n                time = kwargs['time']\n                property_set = kwargs['property_set']\n                count = kwargs['count']\n                ...\n            transpile(circ, callback=callback_func)\n\n    output_name: A list with strings to identify the output circuits. The length of\n        the list should be exactly the length of the ``circuits`` parameter.\n    unitary_synthesis_method (str): The name of the unitary synthesis\n        method to use. By default ``'default'`` is used. You can see a list of installed\n        plugins with :func:`.unitary_synthesis_plugin_names`.\n    unitary_synthesis_plugin_config: An optional configuration dictionary\n        that will be passed directly to the unitary synthesis plugin. By\n        default this setting will have no effect as the default unitary\n        synthesis method does not take custom configuration. This should\n        only be necessary when a unitary synthesis plugin is specified with\n        the ``unitary_synthesis_method`` argument. As this is custom for each\n        unitary synthesis plugin refer to the plugin documentation for how\n        to use this option.\n    target: A backend transpiler target. Normally this is specified as part of\n        the ``backend`` argument, but if you have manually constructed a\n        :class:`~qiskit.transpiler.Target` object you can specify it manually here.\n        This will override the target from ``backend``.\n    hls_config: An optional configuration class\n        :class:`~qiskit.transpiler.passes.synthesis.HLSConfig` that will be passed directly\n        to :class:`~qiskit.transpiler.passes.synthesis.HighLevelSynthesis` transformation pass.\n        This configuration class allows to specify for various high-level objects the lists of\n        synthesis algorithms and their parameters.\n    init_method: The plugin name to use for the ``init`` stage. By default an external\n        plugin is not used. You can see a list of installed plugins by\n        using :func:`~.list_stage_plugins` with ``\"init\"`` for the stage\n        name argument.\n    optimization_method: The plugin name to use for the\n        ``optimization`` stage. By default an external\n        plugin is not used. You can see a list of installed plugins by\n        using :func:`~.list_stage_plugins` with ``\"optimization\"`` for the\n        ``stage_name`` argument.\n    ignore_backend_supplied_default_methods: If set to ``True`` any default methods specified by\n        a backend will be ignored. Some backends specify alternative default methods\n        to support custom compilation target-specific passes/plugins which support\n        backend-specific compilation techniques. If you'd prefer that these defaults were\n        not used this option is used to disable those backend-specific defaults.\n    num_processes: The maximum number of parallel processes to launch for this call to\n        transpile if parallel execution is enabled. This argument overrides\n        ``num_processes`` in the user configuration file, and the ``QISKIT_NUM_PROCS``\n        environment variable. If set to ``None`` the system default or local user configuration\n        will be used.\n\nReturns:\n    The transpiled circuit(s).\n\nRaises:\n    TranspilerError: in case of bad inputs to transpiler (like conflicting parameters)\n        or errors in passes",
        "api_signature": "transpile(circuits, backend, basis_gates, inst_map, coupling_map, backend_properties, initial_layout, layout_method, routing_method, translation_method, scheduling_method, instruction_durations, dt, approximation_degree, timing_constraints, seed_transpiler, optimization_level, callback, output_name, unitary_synthesis_method, unitary_synthesis_plugin_config, target, hls_config, init_method, optimization_method, ignore_backend_supplied_default_methods, num_processes)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/compiler/transpiler.py"
    },
    {
        "api_name": "_check_circuits_coupling_map",
        "full_api_name": "_check_circuits_coupling_map",
        "api_description": "",
        "api_signature": "_check_circuits_coupling_map(circuits, cmap, backend)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/compiler/transpiler.py"
    },
    {
        "api_name": "_log_transpile_time",
        "full_api_name": "_log_transpile_time",
        "api_description": "",
        "api_signature": "_log_transpile_time(start_time, end_time)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/compiler/transpiler.py"
    },
    {
        "api_name": "_parse_coupling_map",
        "full_api_name": "_parse_coupling_map",
        "api_description": "",
        "api_signature": "_parse_coupling_map(coupling_map)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/compiler/transpiler.py"
    },
    {
        "api_name": "_parse_output_name",
        "full_api_name": "_parse_output_name",
        "api_description": "",
        "api_signature": "_parse_output_name(output_name, circuits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/compiler/transpiler.py"
    },
    {
        "api_name": "_log_schedule_time",
        "full_api_name": "_log_schedule_time",
        "api_description": "",
        "api_signature": "_log_schedule_time(start_time, end_time)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/compiler/scheduler.py"
    },
    {
        "api_name": "schedule",
        "full_api_name": "schedule",
        "api_description": "Schedule a circuit to a pulse ``Schedule``, using the backend, according to any specified\nmethods. Supported methods are documented in :py:mod:`qiskit.scheduler.schedule_circuit`.\n\nArgs:\n    circuits: The quantum circuit or circuits to translate\n    backend: A backend instance, which contains hardware-specific data required for scheduling\n    inst_map: Mapping of circuit operations to pulse schedules. If ``None``, defaults to the\n              ``backend``'s ``instruction_schedule_map``\n    meas_map: List of sets of qubits that must be measured together. If ``None``, defaults to\n              the ``backend``'s ``meas_map``\n    dt: The output sample rate of backend control electronics. For scheduled circuits\n        which contain time information, dt is required. If not provided, it will be\n        obtained from the backend configuration\n    method: Optionally specify a particular scheduling method\n\nReturns:\n    A pulse ``Schedule`` that implements the input circuit\n\nRaises:\n    QiskitError: If ``inst_map`` and ``meas_map`` are not passed and ``backend`` is not passed",
        "api_signature": "schedule(circuits, backend, inst_map, meas_map, dt, method)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/compiler/scheduler.py"
    },
    {
        "api_name": "_log_assembly_time",
        "full_api_name": "_log_assembly_time",
        "api_description": "",
        "api_signature": "_log_assembly_time(start_time, end_time)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/compiler/assembler.py"
    },
    {
        "api_name": "assemble",
        "full_api_name": "assemble",
        "api_description": "Assemble a list of circuits or pulse schedules into a ``Qobj``.\n\nThis function serializes the payloads, which could be either circuits or schedules,\nto create ``Qobj`` \"experiments\". It further annotates the experiment payload with\nheader and configurations.\n\nNOTE: ``Backend.options`` is not used within assemble. The required values\n(previously given by backend.set_options) should be manually extracted\nfrom options and supplied directly when calling.\n\nArgs:\n    experiments: Circuit(s) or pulse schedule(s) to execute\n    backend: If set, some runtime options are automatically grabbed from\n        ``backend.configuration()`` and ``backend.defaults()``.\n        If any other option is explicitly set (e.g., ``rep_time``), it\n        will override the backend's.\n        If any other options is set in the run_config, it will\n        also override the backend's.\n    qobj_id: String identifier to annotate the ``Qobj``\n    qobj_header: User input that will be inserted in ``Qobj`` header, and will also be\n        copied to the corresponding Result header. Headers do not affect the run.\n    shots: Number of repetitions of each circuit, for sampling. Default: 1024\n        or ``max_shots`` from the backend configuration, whichever is smaller\n    memory: If ``True``, per-shot measurement bitstrings are returned as well\n        (provided the backend supports it). For OpenPulse jobs, only\n        measurement level 2 supports this option.\n    seed_simulator: Random seed to control sampling, for when backend is a simulator\n    qubit_lo_freq: List of job level qubit drive LO frequencies in Hz. Overridden by\n        ``schedule_los`` if specified. Must have length ``n_qubits.``\n    meas_lo_freq: List of measurement LO frequencies in Hz. Overridden by ``schedule_los`` if\n        specified. Must have length ``n_qubits.``\n    qubit_lo_range: List of job level drive LO ranges each of form ``[range_min, range_max]``\n        in Hz. Used to validate ``qubit_lo_freq``. Must have length ``n_qubits.``\n    meas_lo_range: List of job level measurement LO ranges each of form\n        ``[range_min, range_max]`` in Hz. Used to validate ``meas_lo_freq``. Must have length\n        ``n_qubits.``\n    schedule_los: Experiment level (ie circuit or schedule) LO frequency configurations for\n        qubit drive and measurement channels. These values override the job level values from\n        ``default_qubit_los`` and ``default_meas_los``. Frequencies are in Hz. Settable for\n        OpenQASM 2 and pulse jobs.\n    meas_level: Set the appropriate level of the measurement output for pulse experiments.\n    meas_return: Level of measurement data for the backend to return.\n\n        For ``meas_level`` 0 and 1:\n            * ``single`` returns information from every shot.\n            * ``avg`` returns average measurement output (averaged over number of shots).\n    meas_map: List of lists, containing qubits that must be measured together.\n    memory_slot_size: Size of each memory slot if the output is Level 0.\n    rep_time (int): Time per program execution in seconds. Must be from the list provided\n        by the backend (``backend.configuration().rep_times``). Defaults to the first entry.\n    rep_delay (float): Delay between programs in seconds. Only supported on certain\n        backends (if ``backend.configuration().dynamic_reprate_enabled=True``). If supported,\n        ``rep_delay`` will be used instead of ``rep_time`` and must be from the range supplied\n        by the backend (``backend.configuration().rep_delay_range``). Default is given by\n        ``backend.configuration().default_rep_delay``.\n    parameter_binds: List of Parameter bindings over which the set of experiments will be\n        executed. Each list element (bind) should be of the form\n        {Parameter1: value1, Parameter2: value2, ...}. All binds will be\n        executed across all experiments; e.g., if parameter_binds is a\n        length-n list, and there are m experiments, a total of m x n\n        experiments will be run (one for each experiment/bind pair).\n    parametric_pulses: A list of pulse shapes which are supported internally on the backend.\n        Example::\n\n        ['gaussian', 'constant']\n    init_qubits: Whether to reset the qubits to the ground state for each shot.\n                 Default: ``True``.\n    **run_config: Extra arguments used to configure the run (e.g., for Aer configurable\n        backends). Refer to the backend documentation for details on these\n        arguments.\n\nReturns:\n        A ``Qobj`` that can be run on a backend. Depending on the type of input,\n        this will be either a ``QasmQobj`` or a ``PulseQobj``.\n\nRaises:\n    QiskitError: if the input cannot be interpreted as either circuits or schedules",
        "api_signature": "assemble(experiments, backend, qobj_id, qobj_header, shots, memory, seed_simulator, qubit_lo_freq, meas_lo_freq, qubit_lo_range, meas_lo_range, schedule_los, meas_level, meas_return, meas_map, memory_slot_size, rep_time, rep_delay, parameter_binds, parametric_pulses, init_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/compiler/assembler.py"
    },
    {
        "api_name": "_assemble",
        "full_api_name": "_assemble",
        "api_description": "",
        "api_signature": "_assemble(experiments, backend, qobj_id, qobj_header, shots, memory, seed_simulator, qubit_lo_freq, meas_lo_freq, qubit_lo_range, meas_lo_range, schedule_los, meas_level, meas_return, meas_map, memory_slot_size, rep_time, rep_delay, parameter_binds, parametric_pulses, init_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/compiler/assembler.py"
    },
    {
        "api_name": "_parse_common_args",
        "full_api_name": "_parse_common_args",
        "api_description": "Resolve the various types of args allowed to the assemble() function through\nduck typing, overriding args, etc. Refer to the assemble() docstring for details on\nwhat types of inputs are allowed.\n\nHere the args are resolved by converting them to standard instances, and prioritizing\nthem in case a run option is passed through multiple args (explicitly setting an arg\nhas more priority than the arg set by backend)\n\nReturns:\n    RunConfig: a run config, which is a standardized object that configures the qobj\n        and determines the runtime environment.\n\nRaises:\n    QiskitError:\n        - If the memory arg is True and the backend does not support memory.\n        - If ``shots`` exceeds ``max_shots`` for the configured backend.\n        - If ``shots`` are not int type.\n        - If any of qubit or meas lo's, or associated ranges do not have length equal to\n        ``n_qubits``.\n        - If qubit or meas lo's do not fit into prescribed ranges.",
        "api_signature": "_parse_common_args(backend, qobj_id, qobj_header, shots, memory, seed_simulator, init_qubits, rep_delay, qubit_lo_freq, meas_lo_freq, qubit_lo_range, meas_lo_range, schedule_los, pulse_qobj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/compiler/assembler.py"
    },
    {
        "api_name": "_check_lo_freqs",
        "full_api_name": "_check_lo_freqs",
        "api_description": "Check that LO frequencies are within the perscribed LO range.\n\nNOTE: Only checks if frequency/range lists have equal length. And does not check that the lists\nhave length ``n_qubits``. This is because some backends, like simulator backends, do not\nrequire these constraints. For real hardware, these parameters will be validated on the backend.\n\nArgs:\n    lo_freq: List of LO frequencies.\n    lo_range: Nested list of LO frequency ranges. Inner list is of the form\n        ``[lo_min, lo_max]``.\n    lo_type: The type of LO value--\"qubit\" or \"meas\".\n\nRaises:\n    QiskitError:\n        - If each element of the LO range is not a 2d list.\n        - If the LO frequency is not in the LO range for a given qubit.",
        "api_signature": "_check_lo_freqs(lo_freq, lo_range, lo_type)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/compiler/assembler.py"
    },
    {
        "api_name": "_parse_pulse_args",
        "full_api_name": "_parse_pulse_args",
        "api_description": "Build a pulse RunConfig replacing unset arguments with defaults derived from the `backend`.\nSee `assemble` for more information on the required arguments.\n\nReturns:\n    RunConfig: a run config, which is a standardized object that configures the qobj\n        and determines the runtime environment.\nRaises:\n    QiskitError: If the given meas_level is not allowed for the given `backend`.",
        "api_signature": "_parse_pulse_args(backend, meas_level, meas_return, meas_map, memory_slot_size, rep_time, parametric_pulses)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/compiler/assembler.py"
    },
    {
        "api_name": "_parse_circuit_args",
        "full_api_name": "_parse_circuit_args",
        "api_description": "Build a circuit RunConfig replacing unset arguments with defaults derived from the `backend`.\nSee `assemble` for more information on the required arguments.\n\nReturns:\n    RunConfig: a run config, which is a standardized object that configures the qobj\n        and determines the runtime environment.",
        "api_signature": "_parse_circuit_args(parameter_binds, backend, meas_level, meas_return, parametric_pulses)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/compiler/assembler.py"
    },
    {
        "api_name": "_parse_rep_delay",
        "full_api_name": "_parse_rep_delay",
        "api_description": "Parse and set ``rep_delay`` parameter in runtime config.\n\nArgs:\n    rep_delay: Initial rep delay.\n    default_rep_delay: Backend default rep delay.\n    rep_delay_range: Backend list defining allowable range of rep delays.\n\nRaises:\n    QiskitError: If rep_delay is not in the backend rep_delay_range.\nReturns:\n    float: Modified rep delay after parsing.",
        "api_signature": "_parse_rep_delay(rep_delay, default_rep_delay, rep_delay_range)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/compiler/assembler.py"
    },
    {
        "api_name": "_expand_parameters",
        "full_api_name": "_expand_parameters",
        "api_description": "Verifies that there is a single common set of parameters shared between\nall circuits and all parameter binds in the run_config. Returns an expanded\nlist of circuits (if parameterized) with all parameters bound, and a copy of\nthe run_config with parameter_binds cleared.\n\nIf neither the circuits nor the run_config specify parameters, the two are\nreturned unmodified.\n\nRaises:\n    QiskitError: if run_config parameters are not compatible with circuit parameters\n\nReturns:\n    Tuple(List[QuantumCircuit], RunConfig):\n      - List of input circuits expanded and with parameters bound\n      - RunConfig with parameter_binds removed",
        "api_signature": "_expand_parameters(circuits, run_config)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/compiler/assembler.py"
    },
    {
        "api_name": "sequence",
        "full_api_name": "sequence",
        "api_description": "Schedule a scheduled circuit to a pulse ``Schedule``, using the backend.\n\nArgs:\n    scheduled_circuits: Scheduled circuit(s) to be translated\n    backend: A backend instance, which contains hardware-specific data required for scheduling\n    inst_map: Mapping of circuit operations to pulse schedules. If ``None``, defaults to the\n              ``backend``'s ``instruction_schedule_map``\n    meas_map: List of sets of qubits that must be measured together. If ``None``, defaults to\n              the ``backend``'s ``meas_map``\n    dt: The output sample rate of backend control electronics. For scheduled circuits\n        which contain time information, dt is required. If not provided, it will be\n        obtained from the backend configuration\n\nReturns:\n    A pulse ``Schedule`` that implements the input circuit\n\nRaises:\n    QiskitError: If ``inst_map`` and ``meas_map`` are not passed and ``backend`` is not passed",
        "api_signature": "sequence(scheduled_circuits, backend, inst_map, meas_map, dt)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/compiler/sequencer.py"
    },
    {
        "api_name": "dump",
        "full_api_name": "dump",
        "api_description": "Dump a circuit as an OpenQASM 2 program to a file or stream.\n\nArgs:\n    circuit: the :class:`.QuantumCircuit` to be exported.\n    filename_or_stream: either a path-like object (likely a :class:`str` or\n        :class:`pathlib.Path`), or an already opened text-mode stream.\n\nRaises:\n    QASM2ExportError: if the circuit cannot be represented by OpenQASM 2.",
        "api_signature": "dump()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm2/export.py"
    },
    {
        "api_name": "dumps",
        "full_api_name": "dumps",
        "api_description": "Export a circuit to an OpenQASM 2 program in a string.\n\nArgs:\n    circuit: the :class:`.QuantumCircuit` to be exported.\n\nReturns:\n    An OpenQASM 2 string representing the circuit.\n\nRaises:\n    QASM2ExportError: if the circuit cannot be represented by OpenQASM 2.",
        "api_signature": "dumps()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm2/export.py"
    },
    {
        "api_name": "_escape_name",
        "full_api_name": "_escape_name",
        "api_description": "Returns a valid OpenQASM 2.0 identifier, using `prefix` as a prefix if necessary.  `prefix`\nmust itself be a valid identifier.",
        "api_signature": "_escape_name(name, prefix)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm2/export.py"
    },
    {
        "api_name": "_make_unique",
        "full_api_name": "_make_unique",
        "api_description": "Generate a name by suffixing the given stem that is unique within the defined set.",
        "api_signature": "_make_unique(name, already_defined)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm2/export.py"
    },
    {
        "api_name": "_rename_operation",
        "full_api_name": "_rename_operation",
        "api_description": "Returns the operation with a new name following this pattern: {operation name}_{operation id}",
        "api_signature": "_rename_operation(operation)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm2/export.py"
    },
    {
        "api_name": "_instruction_call_site",
        "full_api_name": "_instruction_call_site",
        "api_description": "Return an OpenQASM 2 string for the instruction.",
        "api_signature": "_instruction_call_site(operation)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm2/export.py"
    },
    {
        "api_name": "_custom_operation_statement",
        "full_api_name": "_custom_operation_statement",
        "api_description": "",
        "api_signature": "_custom_operation_statement(instruction, gates_to_define, bit_labels)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm2/export.py"
    },
    {
        "api_name": "_define_custom_operation",
        "full_api_name": "_define_custom_operation",
        "api_description": "Extract a custom definition from the given operation, and append any necessary additional\nsubcomponents' definitions to the ``gates_to_define`` ordered dictionary.\n\nReturns a potentially new :class:`.Instruction`, which should be used for the\n:meth:`~.Instruction.qasm` call (it may have been renamed).",
        "api_signature": "_define_custom_operation(operation, gates_to_define)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm2/export.py"
    },
    {
        "api_name": "_generate_delay",
        "full_api_name": "_generate_delay",
        "api_description": "",
        "api_signature": "_generate_delay(time)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm2/parse.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "_U0Gate.__init__",
        "api_description": "",
        "api_signature": "__init__(self, count)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm2/parse.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "_U0Gate._define",
        "api_description": "",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm2/parse.py"
    },
    {
        "api_name": "from_bytecode",
        "full_api_name": "from_bytecode",
        "api_description": "Loop through the Rust bytecode iterator `bytecode` producing a\n:class:`~qiskit.circuit.QuantumCircuit` instance from it.  All the hard work is done in Rust\nspace where operations are faster; here, we're just about looping through the instructions as\nfast as possible, doing as little calculation as we can in Python space.  The Python-space\ncomponents are the vast majority of the runtime.\n\nThe \"bytecode\", and so also this Python function, is very tightly coupled to the output of the\nRust parser.  The bytecode itself is largely defined by Rust; from Python space, the iterator is\nover essentially a 2-tuple of `(opcode, operands)`.  The `operands` are fixed by Rust, and\nassumed to be correct by this function.\n\nThe Rust code is responsible for all validation.  If this function causes any errors to be\nraised by Qiskit (except perhaps for some symbolic manipulations of `Parameter` objects), we\nshould consider that a bug in the Rust code.",
        "api_signature": "from_bytecode(bytecode, custom_instructions)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm2/parse.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "_DefinedGate.__init__",
        "api_description": "",
        "api_signature": "__init__(self, name, num_qubits, params, gates, bytecode)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm2/parse.py"
    },
    {
        "api_name": "_define",
        "full_api_name": "_DefinedGate._define",
        "api_description": "",
        "api_signature": "_define(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm2/parse.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "_DefinedGate.__array__",
        "api_description": "",
        "api_signature": "__array__(self, dtype, copy)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm2/parse.py"
    },
    {
        "api_name": "__getstate__",
        "full_api_name": "_DefinedGate.__getstate__",
        "api_description": "",
        "api_signature": "__getstate__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm2/parse.py"
    },
    {
        "api_name": "__setstate__",
        "full_api_name": "_DefinedGate.__setstate__",
        "api_description": "",
        "api_signature": "__setstate__(self, state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm2/parse.py"
    },
    {
        "api_name": "_gate_builder",
        "full_api_name": "_gate_builder",
        "api_description": "Create a gate-builder function of the signature `*params -> Gate` for a gate with a given\n`name`.  This produces a `_DefinedGate` class, whose `_define` method runs through the given\n`bytecode` using the current list of `known_gates` to interpret the gate indices.\n\nThe indirection here is mostly needed to correctly close over `known_gates` and `bytecode`.",
        "api_signature": "_gate_builder(name, num_qubits, known_gates, bytecode)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm2/parse.py"
    },
    {
        "api_name": "definer",
        "full_api_name": "definer",
        "api_description": "",
        "api_signature": "definer()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm2/parse.py"
    },
    {
        "api_name": "_opaque_builder",
        "full_api_name": "_opaque_builder",
        "api_description": "Create a gate-builder function of the signature `*params -> Gate` for an opaque gate with a\ngiven `name`, which takes the given numbers of qubits.",
        "api_signature": "_opaque_builder(name, num_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm2/parse.py"
    },
    {
        "api_name": "definer",
        "full_api_name": "definer",
        "api_description": "",
        "api_signature": "definer()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm2/parse.py"
    },
    {
        "api_name": "_evaluate_argument",
        "full_api_name": "_evaluate_argument",
        "api_description": "Inner recursive function to calculate the value of a mathematical expression given the\nconcrete values in the `parameters` field.",
        "api_signature": "_evaluate_argument(expr, parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm2/parse.py"
    },
    {
        "api_name": "_normalize_path",
        "full_api_name": "_normalize_path",
        "api_description": "Normalize a given path into a path-like object that can be passed to Rust.\n\nIdeally this would be something that we can convert to Rust's `OSString`, but in practice,\nPython uses `os.fsencode` to produce a `bytes` object, but this doesn't map especially well.",
        "api_signature": "_normalize_path(path)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm2/__init__.py"
    },
    {
        "api_name": "loads",
        "full_api_name": "loads",
        "api_description": "Parse an OpenQASM 2 program from a string into a :class:`.QuantumCircuit`.\n\nArgs:\n    string: The OpenQASM 2 program in a string.\n    include_path: order of directories to search when evaluating ``include`` statements.\n    custom_instructions: any custom constructors that should be used for specific gates or\n        opaque instructions during circuit construction.  See :ref:`qasm2-custom-instructions`\n        for more.\n    custom_classical: any custom classical functions that should be used during the parsing of\n        classical expressions.  See :ref:`qasm2-custom-classical` for more.\n    strict: whether to run in :ref:`strict mode <qasm2-strict-mode>`.\n\nReturns:\n    A circuit object representing the same OpenQASM 2 program.",
        "api_signature": "loads(string)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm2/__init__.py"
    },
    {
        "api_name": "load",
        "full_api_name": "load",
        "api_description": "Parse an OpenQASM 2 program from a file into a :class:`.QuantumCircuit`.  The given path\nshould be ASCII or UTF-8 encoded, and contain the OpenQASM 2 program.\n\nArgs:\n    filename: The OpenQASM 2 program in a string.\n    include_path: order of directories to search when evaluating ``include`` statements.\n    include_input_directory: Whether to add the directory of the input file to the\n        ``include_path``, and if so, whether to *append* it to search last, or *prepend* it to\n        search first.  Pass ``None`` to suppress adding this directory entirely.\n    custom_instructions: any custom constructors that should be used for specific gates or\n        opaque instructions during circuit construction.  See :ref:`qasm2-custom-instructions`\n        for more.\n    custom_classical: any custom classical functions that should be used during the parsing of\n        classical expressions.  See :ref:`qasm2-custom-classical` for more.\n    strict: whether to run in :ref:`strict mode <qasm2-strict-mode>`.\n\nReturns:\n    A circuit object representing the same OpenQASM 2 program.",
        "api_signature": "load(filename)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qasm2/__init__.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QobjDictField.__init__",
        "api_description": "Instantiate a new Qobj dict field object.\n\nArgs:\n    kwargs: arbitrary keyword arguments that can be accessed as\n        attributes of the object.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/common.py"
    },
    {
        "api_name": "to_dict",
        "full_api_name": "QobjDictField.to_dict",
        "api_description": "Return a dictionary format representation of the OpenQASM 2 Qobj.\n\nReturns:\n    dict: The dictionary form of the QobjHeader.",
        "api_signature": "to_dict(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/common.py"
    },
    {
        "api_name": "from_dict",
        "full_api_name": "QobjDictField.from_dict",
        "api_description": "Create a new QobjHeader object from a dictionary.\n\nArgs:\n    data (dict): A dictionary representing the QobjHeader to create. It\n        will be in the same format as output by :func:`to_dict`.\n\nReturns:\n    QobjDictFieldr: The QobjDictField from the input dictionary.",
        "api_signature": "from_dict(cls, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/common.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "QobjDictField.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/common.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QasmQobjInstruction.__init__",
        "api_description": "Instantiate a new QasmQobjInstruction object.\n\nArgs:\n    name (str): The name of the instruction\n    params (list): The list of parameters for the gate\n    qubits (list): A list of ``int`` representing the qubits the\n        instruction operates on\n    register (list): If a ``measure`` instruction this is a list\n        of ``int`` containing the list of register slots in which to\n        store the measurement results (must be the same length as\n        qubits). If a ``bfunc`` instruction this is a single ``int``\n        of the register slot in which to store the result.\n    memory (list): If a ``measure`` instruction this is a list\n        of ``int`` containing the list of memory slots to store the\n        measurement results in (must be the same length as qubits).\n        If a ``bfunc`` instruction this is a single ``int`` of the\n        memory slot to store the boolean function result in.\n    condition (tuple): A tuple of the form ``(int, int)`` where the\n        first ``int`` is the control register and the second ``int`` is\n        the control value if the gate has a condition.\n    conditional (int):  The register index of the condition\n    label (str): An optional label assigned to the instruction\n    mask (int): For a ``bfunc`` instruction the hex value which is\n        applied as an ``AND`` to the register bits.\n    relation (str): Relational  operator  for  comparing  the  masked\n        register to the ``val`` kwarg. Can be either ``==`` (equals) or\n        ``!=`` (not equals).\n    val (int): Value to which to compare the masked register. In other\n        words, the output of the function is ``(register AND mask)``\n    snapshot_type (str): For snapshot instructions the type of snapshot\n        to use",
        "api_signature": "__init__(self, name, params, qubits, register, memory, condition, conditional, label, mask, relation, val, snapshot_type)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/qasm_qobj.py"
    },
    {
        "api_name": "to_dict",
        "full_api_name": "QasmQobjInstruction.to_dict",
        "api_description": "Return a dictionary format representation of the Instruction.\n\nReturns:\n    dict: The dictionary form of the QasmQobjInstruction.",
        "api_signature": "to_dict(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/qasm_qobj.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "QasmQobjInstruction.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/qasm_qobj.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "QasmQobjInstruction.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/qasm_qobj.py"
    },
    {
        "api_name": "from_dict",
        "full_api_name": "QasmQobjInstruction.from_dict",
        "api_description": "Create a new QasmQobjInstruction object from a dictionary.\n\nArgs:\n    data (dict): A dictionary for the experiment config\n\nReturns:\n    QasmQobjInstruction: The object from the input dictionary.",
        "api_signature": "from_dict(cls, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/qasm_qobj.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "QasmQobjInstruction.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/qasm_qobj.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QasmQobjExperiment.__init__",
        "api_description": "Instantiate a QasmQobjExperiment.\n\nArgs:\n    config (QasmQobjExperimentConfig): A config object for the experiment\n    header (QasmQobjExperimentHeader): A header object for the experiment\n    instructions (list): A list of :class:`QasmQobjInstruction` objects",
        "api_signature": "__init__(self, config, header, instructions)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/qasm_qobj.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "QasmQobjExperiment.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/qasm_qobj.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "QasmQobjExperiment.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/qasm_qobj.py"
    },
    {
        "api_name": "to_dict",
        "full_api_name": "QasmQobjExperiment.to_dict",
        "api_description": "Return a dictionary format representation of the Experiment.\n\nReturns:\n    dict: The dictionary form of the QasmQObjExperiment.",
        "api_signature": "to_dict(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/qasm_qobj.py"
    },
    {
        "api_name": "from_dict",
        "full_api_name": "QasmQobjExperiment.from_dict",
        "api_description": "Create a new QasmQobjExperiment object from a dictionary.\n\nArgs:\n    data (dict): A dictionary for the experiment config\n\nReturns:\n    QasmQobjExperiment: The object from the input dictionary.",
        "api_signature": "from_dict(cls, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/qasm_qobj.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "QasmQobjExperiment.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/qasm_qobj.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QasmQobjConfig.__init__",
        "api_description": "Model for RunConfig.\n\nArgs:\n    shots (int): the number of shots.\n    seed_simulator (int): the seed to use in the simulator\n    memory (bool): whether to request memory from backend (per-shot readouts)\n    parameter_binds (list[dict]): List of parameter bindings\n    meas_level (int): Measurement level 0, 1, or 2\n    meas_return (str): For measurement level < 2, whether single or avg shots are returned\n    memory_slots (int): The number of memory slots on the device\n    n_qubits (int): The number of qubits on the device\n    pulse_library (list): List of :class:`PulseLibraryItem`.\n    calibrations (QasmExperimentCalibrations): Information required for Pulse gates.\n    rep_delay (float): Delay between programs in sec. Only supported on certain\n        backends (``backend.configuration().dynamic_reprate_enabled`` ). Must be from the\n        range supplied by the backend (``backend.configuration().rep_delay_range``). Default\n        is ``backend.configuration().default_rep_delay``.\n    qubit_lo_freq (list): List of frequencies (as floats) for the qubit driver LO's in GHz.\n    meas_lo_freq (list): List of frequencies (as floats) for the measurement driver LO's in\n        GHz.\n    kwargs: Additional free form key value fields to add to the\n        configuration.",
        "api_signature": "__init__(self, shots, seed_simulator, memory, parameter_binds, meas_level, meas_return, memory_slots, n_qubits, pulse_library, calibrations, rep_delay, qubit_lo_freq, meas_lo_freq)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/qasm_qobj.py"
    },
    {
        "api_name": "to_dict",
        "full_api_name": "QasmQobjConfig.to_dict",
        "api_description": "Return a dictionary format representation of the OpenQASM 2 Qobj config.\n\nReturns:\n    dict: The dictionary form of the QasmQobjConfig.",
        "api_signature": "to_dict(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/qasm_qobj.py"
    },
    {
        "api_name": "from_dict",
        "full_api_name": "QasmQobjConfig.from_dict",
        "api_description": "Create a new QasmQobjConfig object from a dictionary.\n\nArgs:\n    data (dict): A dictionary for the config\n\nReturns:\n    QasmQobjConfig: The object from the input dictionary.",
        "api_signature": "from_dict(cls, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/qasm_qobj.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "QasmQobjConfig.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/qasm_qobj.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QasmQobjExperimentConfig.__init__",
        "api_description": "Args:\n    calibrations (QasmExperimentCalibrations): Information required for Pulse gates.\n    qubit_lo_freq (List[float]): List of qubit LO frequencies in GHz.\n    meas_lo_freq (List[float]): List of meas readout LO frequencies in GHz.\n    kwargs: Additional free form key value fields to add to the configuration",
        "api_signature": "__init__(self, calibrations, qubit_lo_freq, meas_lo_freq)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/qasm_qobj.py"
    },
    {
        "api_name": "to_dict",
        "full_api_name": "QasmQobjExperimentConfig.to_dict",
        "api_description": "",
        "api_signature": "to_dict(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/qasm_qobj.py"
    },
    {
        "api_name": "from_dict",
        "full_api_name": "QasmQobjExperimentConfig.from_dict",
        "api_description": "",
        "api_signature": "from_dict(cls, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/qasm_qobj.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QasmExperimentCalibrations.__init__",
        "api_description": "Initialize a container for calibrations.\n\nArgs:\n    gates (list(GateCalibration))",
        "api_signature": "__init__(self, gates)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/qasm_qobj.py"
    },
    {
        "api_name": "to_dict",
        "full_api_name": "QasmExperimentCalibrations.to_dict",
        "api_description": "Return a dictionary format representation of the calibrations.\n\nReturns:\n    dict: The dictionary form of the GateCalibration.",
        "api_signature": "to_dict(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/qasm_qobj.py"
    },
    {
        "api_name": "from_dict",
        "full_api_name": "QasmExperimentCalibrations.from_dict",
        "api_description": "Create a new GateCalibration object from a dictionary.\n\nArgs:\n    data (dict): A dictionary representing the QasmExperimentCalibrations to\n                 create. It will be in the same format as output by :func:`to_dict`.\n\nReturns:\n    QasmExperimentCalibrations: The QasmExperimentCalibrations from the input dictionary.",
        "api_signature": "from_dict(cls, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/qasm_qobj.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "GateCalibration.__init__",
        "api_description": "Initialize a single gate calibration. Instructions may reference waveforms which should be\nmade available in the pulse_library.\n\nArgs:\n    name (str): Gate name.\n    qubits (list(int)): Qubits the gate applies to.\n    params (list(complex)): Gate parameter values, if any.\n    instructions (list(PulseQobjInstruction)): The gate implementation.",
        "api_signature": "__init__(self, name, qubits, params, instructions)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/qasm_qobj.py"
    },
    {
        "api_name": "__hash__",
        "full_api_name": "GateCalibration.__hash__",
        "api_description": "",
        "api_signature": "__hash__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/qasm_qobj.py"
    },
    {
        "api_name": "to_dict",
        "full_api_name": "GateCalibration.to_dict",
        "api_description": "Return a dictionary format representation of the Gate Calibration.\n\nReturns:\n    dict: The dictionary form of the GateCalibration.",
        "api_signature": "to_dict(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/qasm_qobj.py"
    },
    {
        "api_name": "from_dict",
        "full_api_name": "GateCalibration.from_dict",
        "api_description": "Create a new GateCalibration object from a dictionary.\n\nArgs:\n    data (dict): A dictionary representing the GateCalibration to create. It\n        will be in the same format as output by :func:`to_dict`.\n\nReturns:\n    GateCalibration: The GateCalibration from the input dictionary.",
        "api_signature": "from_dict(cls, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/qasm_qobj.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QasmQobj.__init__",
        "api_description": "Instantiate a new OpenQASM 2 Qobj Object.\n\nEach OpenQASM 2 Qobj object is used to represent a single payload that will\nbe passed to a Qiskit provider. It mirrors the Qobj the published\n`Qobj specification <https://arxiv.org/abs/1809.03452>`_ for OpenQASM\nexperiments.\n\nArgs:\n    qobj_id (str): An identifier for the qobj\n    config (QasmQobjRunConfig): A config for the entire run\n    header (QobjHeader): A header for the entire run\n    experiments (list): A list of lists of :class:`QasmQobjExperiment`\n        objects representing an experiment",
        "api_signature": "__init__(self, qobj_id, config, experiments, header)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/qasm_qobj.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "QasmQobj.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/qasm_qobj.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "QasmQobj.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/qasm_qobj.py"
    },
    {
        "api_name": "to_dict",
        "full_api_name": "QasmQobj.to_dict",
        "api_description": "Return a dictionary format representation of the OpenQASM 2 Qobj.\n\nNote this dict is not in the json wire format expected by IBM and Qobj\nspecification because complex numbers are still of type complex. Also,\nthis may contain native numpy arrays. When serializing this output\nfor use with IBM systems, you can leverage a json encoder that converts these\nas expected. For example:\n\n.. code-block::\n\n    import json\n    import numpy\n\n    class QobjEncoder(json.JSONEncoder):\n        def default(self, obj):\n            if isinstance(obj, numpy.ndarray):\n                return obj.tolist()\n            if isinstance(obj, complex):\n                return (obj.real, obj.imag)\n            return json.JSONEncoder.default(self, obj)\n\n    json.dumps(qobj.to_dict(), cls=QobjEncoder)\n\nReturns:\n    dict: A dictionary representation of the QasmQobj object",
        "api_signature": "to_dict(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/qasm_qobj.py"
    },
    {
        "api_name": "from_dict",
        "full_api_name": "QasmQobj.from_dict",
        "api_description": "Create a new QASMQobj object from a dictionary.\n\nArgs:\n    data (dict): A dictionary representing the QasmQobj to create. It\n        will be in the same format as output by :func:`to_dict`.\n\nReturns:\n    QasmQobj: The QasmQobj from the input dictionary.",
        "api_signature": "from_dict(cls, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/qasm_qobj.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "QasmQobj.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/qasm_qobj.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QobjMeasurementOption.__init__",
        "api_description": "Instantiate a new QobjMeasurementOption object.\n\nArgs:\n    name (str): The name of the measurement option\n    params (list): The parameters of the measurement option.",
        "api_signature": "__init__(self, name, params)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/pulse_qobj.py"
    },
    {
        "api_name": "to_dict",
        "full_api_name": "QobjMeasurementOption.to_dict",
        "api_description": "Return a dict format representation of the QobjMeasurementOption.\n\nReturns:\n    dict: The dictionary form of the QasmMeasurementOption.",
        "api_signature": "to_dict(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/pulse_qobj.py"
    },
    {
        "api_name": "from_dict",
        "full_api_name": "QobjMeasurementOption.from_dict",
        "api_description": "Create a new QobjMeasurementOption object from a dictionary.\n\nArgs:\n    data (dict): A dictionary for the experiment config\n\nReturns:\n    QobjMeasurementOption: The object from the input dictionary.",
        "api_signature": "from_dict(cls, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/pulse_qobj.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "QobjMeasurementOption.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/pulse_qobj.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PulseQobjInstruction.__init__",
        "api_description": "Instantiate a new PulseQobjInstruction object.\n\nArgs:\n    name (str): The name of the instruction\n    t0 (int): Pulse start time in integer **dt** units.\n    ch (str): The channel to apply the pulse instruction.\n    conditional (int): The register to use for a conditional for this\n        instruction\n    val (complex): Complex value to apply, bounded by an absolute value\n        of 1.\n    phase (float): if a ``fc`` instruction, the frame change phase in\n        radians.\n    frequency (float): if a ``sf`` instruction, the frequency in Hz.\n    duration (int): The duration of the pulse in **dt** units.\n    qubits (list): A list of ``int`` representing the qubits the\n        instruction operates on\n    memory_slot (list): If a ``measure`` instruction this is a list\n        of ``int`` containing the list of memory slots to store the\n        measurement results in (must be the same length as qubits).\n        If a ``bfunc`` instruction this is a single ``int`` of the\n        memory slot to store the boolean function result in.\n    register_slot (list): If a ``measure`` instruction this is a list\n        of ``int`` containing the list of register slots in which to\n        store the measurement results (must be the same length as\n        qubits). If a ``bfunc`` instruction this is a single ``int``\n        of the register slot in which to store the result.\n    kernels (list): List of :class:`QobjMeasurementOption` objects\n        defining the measurement kernels and set of parameters if the\n        measurement level is 1 or 2. Only used for ``acquire``\n        instructions.\n    discriminators (list): A list of :class:`QobjMeasurementOption`\n        used to set the discriminators to be used if the measurement\n        level is 2. Only used for ``acquire`` instructions.\n    label (str): Label of instruction\n    type (str): Type of instruction\n    pulse_shape (str): The shape of the parametric pulse\n    parameters (dict): The parameters for a parametric pulse",
        "api_signature": "__init__(self, name, t0, ch, conditional, val, phase, duration, qubits, memory_slot, register_slot, kernels, discriminators, label, type, pulse_shape, parameters, frequency)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/pulse_qobj.py"
    },
    {
        "api_name": "to_dict",
        "full_api_name": "PulseQobjInstruction.to_dict",
        "api_description": "Return a dictionary format representation of the Instruction.\n\nReturns:\n    dict: The dictionary form of the PulseQobjInstruction.",
        "api_signature": "to_dict(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/pulse_qobj.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "PulseQobjInstruction.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/pulse_qobj.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "PulseQobjInstruction.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/pulse_qobj.py"
    },
    {
        "api_name": "from_dict",
        "full_api_name": "PulseQobjInstruction.from_dict",
        "api_description": "Create a new PulseQobjExperimentConfig object from a dictionary.\n\nArgs:\n    data (dict): A dictionary for the experiment config\n\nReturns:\n    PulseQobjInstruction: The object from the input dictionary.",
        "api_signature": "from_dict(cls, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/pulse_qobj.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "PulseQobjInstruction.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/pulse_qobj.py"
    },
    {
        "api_name": "_to_complex",
        "full_api_name": "_to_complex",
        "api_description": "Convert the input value to type ``complex``.\nArgs:\n    value: Value to be converted.\nReturns:\n    Input value in ``complex``.\nRaises:\n    TypeError: If the input value is not in the expected format.",
        "api_signature": "_to_complex(value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/pulse_qobj.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PulseQobjConfig.__init__",
        "api_description": "Instantiate a PulseQobjConfig object.\n\nArgs:\n    meas_level (int): The measurement level to use.\n    meas_return (int): The level of measurement information to return.\n    pulse_library (list): A list of :class:`PulseLibraryItem` objects\n        which define the set of primitive pulses\n    qubit_lo_freq (list): List of frequencies (as floats) for the qubit\n        driver LO's in GHz.\n    meas_lo_freq (list): List of frequencies (as floats) for the'\n        measurement driver LO's in GHz.\n    memory_slot_size (int): Size of each memory slot if the output is\n        Level 0.\n    rep_time (int): Time per program execution in sec. Must be from the list provided\n        by the backend (``backend.configuration().rep_times``). Defaults to the first entry\n        in ``backend.configuration().rep_times``.\n    rep_delay (float): Delay between programs in sec. Only supported on certain\n        backends (``backend.configuration().dynamic_reprate_enabled`` ). If supported,\n        ``rep_delay`` will be used instead of ``rep_time`` and must be from the range\n        supplied by the backend (``backend.configuration().rep_delay_range``). Default is\n        ``backend.configuration().default_rep_delay``.\n    shots (int): The number of shots\n    seed_simulator (int): the seed to use in the simulator\n    memory_slots (list): The number of memory slots on the device\n    kwargs: Additional free form key value fields to add to the\n        configuration",
        "api_signature": "__init__(self, meas_level, meas_return, pulse_library, qubit_lo_freq, meas_lo_freq, memory_slot_size, rep_time, rep_delay, shots, seed_simulator, memory_slots)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/pulse_qobj.py"
    },
    {
        "api_name": "to_dict",
        "full_api_name": "PulseQobjConfig.to_dict",
        "api_description": "Return a dictionary format representation of the Pulse Qobj config.\n\nReturns:\n    dict: The dictionary form of the PulseQobjConfig.",
        "api_signature": "to_dict(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/pulse_qobj.py"
    },
    {
        "api_name": "from_dict",
        "full_api_name": "PulseQobjConfig.from_dict",
        "api_description": "Create a new PulseQobjConfig object from a dictionary.\n\nArgs:\n    data (dict): A dictionary for the config\n\nReturns:\n    PulseQobjConfig: The object from the input dictionary.",
        "api_signature": "from_dict(cls, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/pulse_qobj.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PulseQobjExperiment.__init__",
        "api_description": "Instantiate a PulseQobjExperiment.\n\nArgs:\n    config (PulseQobjExperimentConfig): A config object for the experiment\n    header (PulseQobjExperimentHeader): A header object for the experiment\n    instructions (list): A list of :class:`PulseQobjInstruction` objects",
        "api_signature": "__init__(self, instructions, config, header)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/pulse_qobj.py"
    },
    {
        "api_name": "to_dict",
        "full_api_name": "PulseQobjExperiment.to_dict",
        "api_description": "Return a dictionary format representation of the Experiment.\n\nReturns:\n    dict: The dictionary form of the PulseQobjExperiment.",
        "api_signature": "to_dict(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/pulse_qobj.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "PulseQobjExperiment.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/pulse_qobj.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "PulseQobjExperiment.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/pulse_qobj.py"
    },
    {
        "api_name": "from_dict",
        "full_api_name": "PulseQobjExperiment.from_dict",
        "api_description": "Create a new PulseQobjExperiment object from a dictionary.\n\nArgs:\n    data (dict): A dictionary for the experiment config\n\nReturns:\n    PulseQobjExperiment: The object from the input dictionary.",
        "api_signature": "from_dict(cls, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/pulse_qobj.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "PulseQobjExperiment.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/pulse_qobj.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PulseQobjExperimentConfig.__init__",
        "api_description": "Instantiate a PulseQobjExperimentConfig object.\n\nArgs:\n    qubit_lo_freq (List[float]): List of qubit LO frequencies in GHz.\n    meas_lo_freq (List[float]): List of meas readout LO frequencies in GHz.\n    kwargs: Additional free form key value fields to add to the configuration",
        "api_signature": "__init__(self, qubit_lo_freq, meas_lo_freq)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/pulse_qobj.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PulseLibraryItem.__init__",
        "api_description": "Instantiate a pulse library item.\n\nArgs:\n    name (str): A name for the pulse.\n    samples (list[complex]): A list of complex values defining pulse\n        shape.",
        "api_signature": "__init__(self, name, samples)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/pulse_qobj.py"
    },
    {
        "api_name": "to_dict",
        "full_api_name": "PulseLibraryItem.to_dict",
        "api_description": "Return a dictionary format representation of the pulse library item.\n\nReturns:\n    dict: The dictionary form of the PulseLibraryItem.",
        "api_signature": "to_dict(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/pulse_qobj.py"
    },
    {
        "api_name": "from_dict",
        "full_api_name": "PulseLibraryItem.from_dict",
        "api_description": "Create a new PulseLibraryItem object from a dictionary.\n\nArgs:\n    data (dict): A dictionary for the experiment config\n\nReturns:\n    PulseLibraryItem: The object from the input dictionary.",
        "api_signature": "from_dict(cls, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/pulse_qobj.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "PulseLibraryItem.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/pulse_qobj.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "PulseLibraryItem.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/pulse_qobj.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "PulseLibraryItem.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/pulse_qobj.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PulseQobj.__init__",
        "api_description": "Instantiate a new Pulse Qobj Object.\n\nEach Pulse Qobj object is used to represent a single payload that will\nbe passed to a Qiskit provider. It mirrors the Qobj the published\n`Qobj specification <https://arxiv.org/abs/1809.03452>`_ for Pulse\nexperiments.\n\nArgs:\n    qobj_id (str): An identifier for the qobj\n    config (PulseQobjConfig): A config for the entire run\n    header (QobjHeader): A header for the entire run\n    experiments (list): A list of lists of :class:`PulseQobjExperiment`\n        objects representing an experiment",
        "api_signature": "__init__(self, qobj_id, config, experiments, header)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/pulse_qobj.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "PulseQobj.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/pulse_qobj.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "PulseQobj.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/pulse_qobj.py"
    },
    {
        "api_name": "to_dict",
        "full_api_name": "PulseQobj.to_dict",
        "api_description": "Return a dictionary format representation of the Pulse Qobj.\n\nNote this dict is not in the json wire format expected by IBMQ and qobj\nspecification because complex numbers are still of type complex. Also\nthis may contain native numpy arrays. When serializing this output\nfor use with IBMQ you can leverage a json encoder that converts these\nas expected. For example:\n\n.. code-block::\n\n    import json\n    import numpy\n\n    class QobjEncoder(json.JSONEncoder):\n        def default(self, obj):\n            if isinstance(obj, numpy.ndarray):\n                return obj.tolist()\n            if isinstance(obj, complex):\n                return (obj.real, obj.imag)\n            return json.JSONEncoder.default(self, obj)\n\n    json.dumps(qobj.to_dict(), cls=QobjEncoder)\n\nReturns:\n    dict: A dictionary representation of the PulseQobj object",
        "api_signature": "to_dict(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/pulse_qobj.py"
    },
    {
        "api_name": "from_dict",
        "full_api_name": "PulseQobj.from_dict",
        "api_description": "Create a new PulseQobj object from a dictionary.\n\nArgs:\n    data (dict): A dictionary representing the PulseQobj to create. It\n        will be in the same format as output by :func:`to_dict`.\n\nReturns:\n    PulseQobj: The PulseQobj from the input dictionary.",
        "api_signature": "from_dict(cls, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/pulse_qobj.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "PulseQobj.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/pulse_qobj.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "LoConfigConverter.__init__",
        "api_description": "Create new converter.\n\nArgs:\n    qobj_model (Union[PulseQobjExperimentConfig, QasmQobjExperimentConfig): qobj model for\n        experiment config.\n    qubit_lo_freq (Optional[List[float]]): List of default qubit LO frequencies in Hz.\n    meas_lo_freq (Optional[List[float]]): List of default meas LO frequencies in Hz.\n    qubit_lo_range (Optional[List[List[float]]]): List of qubit LO ranges,\n        each of form ``[range_min, range_max]`` in Hz.\n    meas_lo_range (Optional[List[List[float]]]): List of measurement LO ranges,\n        each of form ``[range_min, range_max]`` in Hz.\n    n_qubits (int): Number of qubits in the system.\n    run_config (dict): experimental configuration.",
        "api_signature": "__init__(self, qobj_model, qubit_lo_freq, meas_lo_freq, qubit_lo_range, meas_lo_range)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/lo_config.py"
    },
    {
        "api_name": "__call__",
        "full_api_name": "LoConfigConverter.__call__",
        "api_description": "Return experiment config w/ LO values property configured.\n\nArgs:\n    user_lo_config (LoConfig): A dictionary of LOs to format.\n\nReturns:\n    Union[PulseQobjExperimentConfig, QasmQobjExperimentConfig]: Qobj experiment config.",
        "api_signature": "__call__(self, user_lo_config)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/lo_config.py"
    },
    {
        "api_name": "get_qubit_los",
        "full_api_name": "LoConfigConverter.get_qubit_los",
        "api_description": "Set experiment level qubit LO frequencies. Use default values from job level if\nexperiment level values not supplied. If experiment level and job level values not supplied,\nraise an error. If configured LO frequency is the same as default, this method returns\n``None``.\n\nArgs:\n    user_lo_config (LoConfig): A dictionary of LOs to format.\n\nReturns:\n    List[float]: A list of qubit LOs.\n\nRaises:\n    QiskitError: When LO frequencies are missing and no default is set at job level.",
        "api_signature": "get_qubit_los(self, user_lo_config)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/lo_config.py"
    },
    {
        "api_name": "get_meas_los",
        "full_api_name": "LoConfigConverter.get_meas_los",
        "api_description": "Set experiment level meas LO frequencies. Use default values from job level if experiment\nlevel values not supplied. If experiment level and job level values not supplied, raise an\nerror. If configured LO frequency is the same as default, this method returns ``None``.\n\nArgs:\n    user_lo_config (LoConfig): A dictionary of LOs to format.\n\nReturns:\n    List[float]: A list of measurement LOs.\n\nRaises:\n    QiskitError: When LO frequencies are missing and no default is set at job level.",
        "api_signature": "get_meas_los(self, user_lo_config)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/lo_config.py"
    },
    {
        "api_name": "from_instance",
        "full_api_name": "ParametricPulseShapes.from_instance",
        "api_description": "Get Qobj name from the pulse class instance.\n\nArgs:\n    instance: SymbolicPulse class.\n\nReturns:\n    Qobj name.\n\nRaises:\n    QiskitError: When pulse instance is not recognizable type.",
        "api_signature": "from_instance(cls, instance)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "to_type",
        "full_api_name": "ParametricPulseShapes.to_type",
        "api_description": "Get symbolic pulse class from the name.\n\nArgs:\n    name: Qobj name of the pulse.\n\nReturns:\n    Corresponding class.",
        "api_signature": "to_type(cls, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "InstructionToQobjConverter.__init__",
        "api_description": "Create new converter.\n\nArgs:\n     qobj_model: Transfer layer data schema.\n     run_config: Run configuration.",
        "api_signature": "__init__(self, qobj_model)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "__call__",
        "full_api_name": "InstructionToQobjConverter.__call__",
        "api_description": "Convert Qiskit in-memory representation to Qobj instruction.\n\nArgs:\n    instruction: Instruction data in Qiskit Pulse.\n\nReturns:\n    Qobj instruction data.\n\nRaises:\n    QiskitError: When list of instruction is provided except for Acquire.",
        "api_signature": "__call__(self, shift, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "_convert_instruction",
        "full_api_name": "InstructionToQobjConverter._convert_instruction",
        "api_description": "",
        "api_signature": "_convert_instruction(self, instruction, time_offset)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "_convert_acquire",
        "full_api_name": "InstructionToQobjConverter._convert_acquire",
        "api_description": "Return converted `Acquire`.\n\nArgs:\n    instruction: Qiskit Pulse acquire instruction.\n    time_offset: Offset time.\n\nReturns:\n    Qobj instruction data.",
        "api_signature": "_convert_acquire(self, instruction, time_offset)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "_convert_set_frequency",
        "full_api_name": "InstructionToQobjConverter._convert_set_frequency",
        "api_description": "Return converted `SetFrequency`.\n\nArgs:\n    instruction: Qiskit Pulse set frequency instruction.\n    time_offset: Offset time.\n\nReturns:\n    Qobj instruction data.",
        "api_signature": "_convert_set_frequency(self, instruction, time_offset)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "_convert_shift_frequency",
        "full_api_name": "InstructionToQobjConverter._convert_shift_frequency",
        "api_description": "Return converted `ShiftFrequency`.\n\nArgs:\n    instruction: Qiskit Pulse shift frequency instruction.\n    time_offset: Offset time.\n\nReturns:\n    Qobj instruction data.",
        "api_signature": "_convert_shift_frequency(self, instruction, time_offset)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "_convert_set_phase",
        "full_api_name": "InstructionToQobjConverter._convert_set_phase",
        "api_description": "Return converted `SetPhase`.\n\nArgs:\n    instruction: Qiskit Pulse set phase instruction.\n    time_offset: Offset time.\n\nReturns:\n    Qobj instruction data.",
        "api_signature": "_convert_set_phase(self, instruction, time_offset)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "_convert_shift_phase",
        "full_api_name": "InstructionToQobjConverter._convert_shift_phase",
        "api_description": "Return converted `ShiftPhase`.\n\nArgs:\n    instruction: Qiskit Pulse shift phase instruction.\n    time_offset: Offset time.\n\nReturns:\n    Qobj instruction data.",
        "api_signature": "_convert_shift_phase(self, instruction, time_offset)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "_convert_delay",
        "full_api_name": "InstructionToQobjConverter._convert_delay",
        "api_description": "Return converted `Delay`.\n\nArgs:\n    instruction: Qiskit Pulse delay instruction.\n    time_offset: Offset time.\n\nReturns:\n    Qobj instruction data.",
        "api_signature": "_convert_delay(self, instruction, time_offset)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "_convert_play",
        "full_api_name": "InstructionToQobjConverter._convert_play",
        "api_description": "Return converted `Play`.\n\nArgs:\n    instruction: Qiskit Pulse play instruction.\n    time_offset: Offset time.\n\nReturns:\n    Qobj instruction data.",
        "api_signature": "_convert_play(self, instruction, time_offset)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "_convert_snapshot",
        "full_api_name": "InstructionToQobjConverter._convert_snapshot",
        "api_description": "Return converted `Snapshot`.\n\nArgs:\n    time_offset: Offset time.\n    instruction: Qiskit Pulse snapshot instruction.\n\nReturns:\n    Qobj instruction data.",
        "api_signature": "_convert_snapshot(self, instruction, time_offset)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "_convert_bundled_acquire",
        "full_api_name": "InstructionToQobjConverter._convert_bundled_acquire",
        "api_description": "Return converted list of parallel `Acquire` instructions.\n\nArgs:\n    instruction_bundle: List of Qiskit Pulse acquire instruction.\n    time_offset: Offset time.\n\nReturns:\n    Qobj instruction data.\n\nRaises:\n    QiskitError: When instructions are not aligned.\n    QiskitError: When instructions have different duration.\n    QiskitError: When discriminator or kernel is missing in a part of instructions.",
        "api_signature": "_convert_bundled_acquire(self, instruction_bundle, time_offset)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QobjToInstructionConverter.__init__",
        "api_description": "Create new converter.\n\nArgs:\n    pulse_library: Pulse library in Qobj format.\n     run_config: Run configuration.",
        "api_signature": "__init__(self, pulse_library)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "__call__",
        "full_api_name": "QobjToInstructionConverter.__call__",
        "api_description": "Convert Qobj instruction to Qiskit in-memory representation.\n\nArgs:\n    instruction: Instruction data in Qobj format.\n\nReturns:\n    Scheduled Qiskit Pulse instruction in Schedule format.",
        "api_signature": "__call__(self, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "_get_sequences",
        "full_api_name": "QobjToInstructionConverter._get_sequences",
        "api_description": "A method to iterate over pulse instructions without creating Schedule.\n\n.. note::\n\n    This is internal fast-path function, and callers other than this converter class\n    might directly use this method to generate schedule from multiple\n    Qobj instructions. Because __call__ always returns a schedule with the time offset\n    parsed instruction, composing multiple Qobj instructions to create\n    a gate schedule is somewhat inefficient due to composing overhead of schedules.\n    Directly combining instructions with this method is much performant.\n\nArgs:\n    instruction: Instruction data in Qobj format.\n\nYields:\n    Qiskit Pulse instructions.\n\n:meta public:",
        "api_signature": "_get_sequences(self, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "get_supported_instructions",
        "full_api_name": "QobjToInstructionConverter.get_supported_instructions",
        "api_description": "Retrun a list of supported instructions.",
        "api_signature": "get_supported_instructions(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "get_channel",
        "full_api_name": "QobjToInstructionConverter.get_channel",
        "api_description": "Parse and retrieve channel from ch string.\n\nArgs:\n    channel: String identifier of pulse instruction channel.\n\nReturns:\n    Matched channel object.\n\nRaises:\n    QiskitError: Is raised if valid channel is not matched",
        "api_signature": "get_channel(self, channel)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "disassemble_value",
        "full_api_name": "QobjToInstructionConverter.disassemble_value",
        "api_description": "A helper function to format instruction operand.\n\nIf parameter in string representation is specified, this method parses the\ninput string and generates Qiskit ParameterExpression object.\n\nArgs:\n    value_expr: Operand value in Qobj.\n\nReturns:\n    Parsed operand value. ParameterExpression object is returned if value is not number.",
        "api_signature": "disassemble_value(value_expr)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "_convert_acquire",
        "full_api_name": "QobjToInstructionConverter._convert_acquire",
        "api_description": "Return converted `Acquire` instruction.\n\nArgs:\n    instruction: Acquire qobj\n\nYields:\n    Qiskit Pulse acquire instructions",
        "api_signature": "_convert_acquire(self, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "_convert_setp",
        "full_api_name": "QobjToInstructionConverter._convert_setp",
        "api_description": "Return converted `SetPhase` instruction.\n\nArgs:\n    instruction: SetPhase qobj instruction\n\nYields:\n    Qiskit Pulse set phase instructions",
        "api_signature": "_convert_setp(self, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "_convert_fc",
        "full_api_name": "QobjToInstructionConverter._convert_fc",
        "api_description": "Return converted `ShiftPhase` instruction.\n\nArgs:\n    instruction: ShiftPhase qobj instruction\n\nYields:\n    Qiskit Pulse shift phase schedule instructions",
        "api_signature": "_convert_fc(self, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "_convert_setf",
        "full_api_name": "QobjToInstructionConverter._convert_setf",
        "api_description": "Return converted `SetFrequencyInstruction` instruction.\n\n.. note::\n\n    We assume frequency value is expressed in string with \"GHz\".\n    Operand value is thus scaled by a factor of 10^9.\n\nArgs:\n    instruction: SetFrequency qobj instruction\n\nYields:\n    Qiskit Pulse set frequency instructions",
        "api_signature": "_convert_setf(self, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "_convert_shiftf",
        "full_api_name": "QobjToInstructionConverter._convert_shiftf",
        "api_description": "Return converted `ShiftFrequency` instruction.\n\n.. note::\n\n    We assume frequency value is expressed in string with \"GHz\".\n    Operand value is thus scaled by a factor of 10^9.\n\nArgs:\n    instruction: ShiftFrequency qobj instruction\n\nYields:\n    Qiskit Pulse shift frequency schedule instructions",
        "api_signature": "_convert_shiftf(self, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "_convert_delay",
        "full_api_name": "QobjToInstructionConverter._convert_delay",
        "api_description": "Return converted `Delay` instruction.\n\nArgs:\n    instruction: Delay qobj instruction\n\nYields:\n    Qiskit Pulse delay instructions",
        "api_signature": "_convert_delay(self, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "_convert_parametric_pulse",
        "full_api_name": "QobjToInstructionConverter._convert_parametric_pulse",
        "api_description": "Return converted `Play` instruction with parametric pulse operand.\n\n.. note::\n\n    If parametric pulse label is not provided by the backend, this method naively generates\n    a pulse name based on the pulse shape and bound parameters. This pulse name is formatted\n    to, for example, `gaussian_a4e3`, here the last four digits are a part of\n    the hash string generated based on the pulse shape and the parameters.\n    Because we are using a truncated hash for readability,\n    there may be a small risk of pulse name collision with other pulses.\n    Basically the parametric pulse name is used just for visualization purpose and\n    the pulse module should not have dependency on the parametric pulse names.\n\nArgs:\n    instruction: Play qobj instruction with parametric pulse\n\nYields:\n    Qiskit Pulse play schedule instructions",
        "api_signature": "_convert_parametric_pulse(self, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "_convert_snapshot",
        "full_api_name": "QobjToInstructionConverter._convert_snapshot",
        "api_description": "Return converted `Snapshot` instruction.\n\nArgs:\n    instruction: Snapshot qobj instruction\n\nYields:\n    Qiskit Pulse snapshot instructions",
        "api_signature": "_convert_snapshot(self, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "_convert_generic",
        "full_api_name": "QobjToInstructionConverter._convert_generic",
        "api_description": "Convert generic pulse instruction.\n\nArgs:\n    instruction: Generic qobj instruction\n\nYields:\n    Qiskit Pulse generic instructions\n\nRaises:\n    QiskitError: When instruction name not found.",
        "api_signature": "_convert_generic(self, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/qobj/converters/pulse_instruction.py"
    },
    {
        "api_name": "synth_clifford_ag",
        "full_api_name": "synth_clifford_ag",
        "api_description": "Decompose a :class:`.Clifford` operator into a :class:`.QuantumCircuit`\nbased on Aaronson-Gottesman method [1].\n\nArgs:\n    clifford: A Clifford operator.\n\nReturns:\n    A circuit implementation of the Clifford.\n\nReferences:\n    1. S. Aaronson, D. Gottesman, *Improved Simulation of Stabilizer Circuits*,\n       Phys. Rev. A 70, 052328 (2004).\n       `arXiv:quant-ph/0406196 <https://arxiv.org/abs/quant-ph/0406196>`_",
        "api_signature": "synth_clifford_ag(clifford)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/clifford/clifford_decompose_ag.py"
    },
    {
        "api_name": "_set_qubit_x_true",
        "full_api_name": "_set_qubit_x_true",
        "api_description": "Set destabilizer.X[qubit, qubit] to be True.\n\nThis is done by permuting columns l > qubit or if necessary applying\na Hadamard",
        "api_signature": "_set_qubit_x_true(clifford, circuit, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/clifford/clifford_decompose_ag.py"
    },
    {
        "api_name": "_set_row_x_zero",
        "full_api_name": "_set_row_x_zero",
        "api_description": "Set destabilizer.X[qubit, i] to False for all i > qubit.\n\nThis is done by applying CNOTs assuming :math:`k \\leq N` and A[k][k]=1",
        "api_signature": "_set_row_x_zero(clifford, circuit, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/clifford/clifford_decompose_ag.py"
    },
    {
        "api_name": "_set_row_z_zero",
        "full_api_name": "_set_row_z_zero",
        "api_description": "Set stabilizer.Z[qubit, i] to False for all i > qubit.\n\nImplemented by applying (reverse) CNOTS assumes qubit < num_qubits\nand _set_row_x_zero has been called first",
        "api_signature": "_set_row_z_zero(clifford, circuit, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/clifford/clifford_decompose_ag.py"
    },
    {
        "api_name": "synth_clifford_greedy",
        "full_api_name": "synth_clifford_greedy",
        "api_description": "Decompose a :class:`.Clifford` operator into a :class:`.QuantumCircuit` based\non the greedy Clifford compiler that is described in Appendix A of\nBravyi, Hu, Maslov and Shaydulin [1].\n\nThis method typically yields better CX cost compared to the Aaronson-Gottesman method.\n\nNote that this function only implements the greedy Clifford compiler from Appendix A\nof [1], and not the templates and symbolic Pauli gates optimizations\nthat are mentioned in the same paper.\n\nArgs:\n    clifford: A Clifford operator.\n\nReturns:\n    A circuit implementation of the Clifford.\n\nRaises:\n    QiskitError: if symplectic Gaussian elimination fails.\n\nReferences:\n    1. Sergey Bravyi, Shaohan Hu, Dmitri Maslov, Ruslan Shaydulin,\n       *Clifford Circuit Optimization with Templates and Symbolic Pauli Gates*,\n       `arXiv:2105.02291 [quant-ph] <https://arxiv.org/abs/2105.02291>`_",
        "api_signature": "synth_clifford_greedy(clifford)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/clifford/clifford_decompose_greedy.py"
    },
    {
        "api_name": "synth_clifford_full",
        "full_api_name": "synth_clifford_full",
        "api_description": "Decompose a :class:`.Clifford` operator into a :class:`.QuantumCircuit`.\n\nFor :math:`N \\leq 3` qubits this is based on optimal CX-cost decomposition\nfrom reference [1]. For :math:`N > 3` qubits this is done using the general\nnon-optimal greedy compilation routine from reference [3],\nwhich typically yields better CX cost compared to the AG method in [2].\n\nArgs:\n    clifford: A Clifford operator.\n    method: Optional, a synthesis method (``'AG'`` or ``'greedy'``).\n         If set this overrides optimal decomposition for :math:`N \\leq 3` qubits.\n\nReturns:\n    A circuit implementation of the Clifford.\n\nReferences:\n    1. S. Bravyi, D. Maslov, *Hadamard-free circuits expose the\n       structure of the Clifford group*,\n       `arXiv:2003.09412 [quant-ph] <https://arxiv.org/abs/2003.09412>`_\n\n    2. S. Aaronson, D. Gottesman, *Improved Simulation of Stabilizer Circuits*,\n       Phys. Rev. A 70, 052328 (2004).\n       `arXiv:quant-ph/0406196 <https://arxiv.org/abs/quant-ph/0406196>`_\n\n    3. Sergey Bravyi, Shaohan Hu, Dmitri Maslov, Ruslan Shaydulin,\n       *Clifford Circuit Optimization with Templates and Symbolic Pauli Gates*,\n       `arXiv:2105.02291 [quant-ph] <https://arxiv.org/abs/2105.02291>`_",
        "api_signature": "synth_clifford_full(clifford, method)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/clifford/clifford_decompose_full.py"
    },
    {
        "api_name": "synth_clifford_bm",
        "full_api_name": "synth_clifford_bm",
        "api_description": "Optimal CX-cost decomposition of a :class:`.Clifford` operator on 2 qubits\nor 3 qubits into a :class:`.QuantumCircuit` based on the Bravyi-Maslov method [1].\n\nArgs:\n    clifford: A Clifford operator.\n\nReturns:\n    A circuit implementation of the Clifford.\n\nRaises:\n    QiskitError: if Clifford is on more than 3 qubits.\n\nReferences:\n    1. S. Bravyi, D. Maslov, *Hadamard-free circuits expose the\n       structure of the Clifford group*,\n       `arXiv:2003.09412 [quant-ph] <https://arxiv.org/abs/2003.09412>`_",
        "api_signature": "synth_clifford_bm(clifford)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/clifford/clifford_decompose_bm.py"
    },
    {
        "api_name": "_default_cx_synth_func",
        "full_api_name": "_default_cx_synth_func",
        "api_description": "Construct the layer of CX gates from a boolean invertible matrix mat.",
        "api_signature": "_default_cx_synth_func(mat)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/clifford/clifford_decompose_layers.py"
    },
    {
        "api_name": "_default_cz_synth_func",
        "full_api_name": "_default_cz_synth_func",
        "api_description": "Construct the layer of CZ gates from a symmetric matrix.",
        "api_signature": "_default_cz_synth_func(symmetric_mat)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/clifford/clifford_decompose_layers.py"
    },
    {
        "api_name": "synth_clifford_layers",
        "full_api_name": "synth_clifford_layers",
        "api_description": "Synthesis of a :class:`.Clifford` into layers, it provides a similar\ndecomposition to the synthesis described in Lemma 8 of Bravyi and Maslov [1].\n\nFor example, a 5-qubit Clifford circuit is decomposed into the following layers:\n\n.. parsed-literal::\n         \u250c\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    q_0: \u25240    \u251c\u25240    \u251c\u25240       \u251c\u25240    \u251c\u25240    \u251c\u25240    \u251c\u25240    \u251c\u25240       \u251c\n         \u2502     \u2502\u2502     \u2502\u2502        \u2502\u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502        \u2502\n    q_1: \u25241    \u251c\u25241    \u251c\u25241       \u251c\u25241    \u251c\u25241    \u251c\u25241    \u251c\u25241    \u251c\u25241       \u251c\n         \u2502     \u2502\u2502     \u2502\u2502        \u2502\u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502        \u2502\n    q_2: \u25242 S2 \u251c\u25242 CZ \u251c\u25242 CX_dg \u251c\u25242 H2 \u251c\u25242 S1 \u251c\u25242 CZ \u251c\u25242 H1 \u251c\u25242 Pauli \u251c\n         \u2502     \u2502\u2502     \u2502\u2502        \u2502\u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502        \u2502\n    q_3: \u25243    \u251c\u25243    \u251c\u25243       \u251c\u25243    \u251c\u25243    \u251c\u25243    \u251c\u25243    \u251c\u25243       \u251c\n         \u2502     \u2502\u2502     \u2502\u2502        \u2502\u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502        \u2502\n    q_4: \u25244    \u251c\u25244    \u251c\u25244       \u251c\u25244    \u251c\u25244    \u251c\u25244    \u251c\u25244    \u251c\u25244       \u251c\n         \u2514\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nThis decomposition is for the default ``cz_synth_func`` and ``cx_synth_func`` functions,\nwith other functions one may see slightly different decomposition.\n\nArgs:\n    cliff: A Clifford operator.\n    cx_synth_func: A function to decompose the CX sub-circuit.\n        It gets as input a boolean invertible matrix, and outputs a :class:`.QuantumCircuit`.\n    cz_synth_func: A function to decompose the CZ sub-circuit.\n        It gets as input a boolean symmetric matrix, and outputs a :class:`.QuantumCircuit`.\n    cx_cz_synth_func (Callable): optional, a function to decompose both sub-circuits CZ and CX.\n    validate (Boolean): if True, validates the synthesis process.\n    cz_func_reverse_qubits (Boolean): True only if ``cz_synth_func`` is\n        :func:`.synth_cz_depth_line_mr`, since this function returns a circuit that reverts\n        the order of qubits.\n\nReturns:\n    A circuit implementation of the Clifford.\n\nReferences:\n    1. S. Bravyi, D. Maslov, *Hadamard-free circuits expose the\n       structure of the Clifford group*,\n       `arXiv:2003.09412 [quant-ph] <https://arxiv.org/abs/2003.09412>`_",
        "api_signature": "synth_clifford_layers(cliff, cx_synth_func, cz_synth_func, cx_cz_synth_func, cz_func_reverse_qubits, validate)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/clifford/clifford_decompose_layers.py"
    },
    {
        "api_name": "_reverse_clifford",
        "full_api_name": "_reverse_clifford",
        "api_description": "Reverse qubit order of a Clifford cliff",
        "api_signature": "_reverse_clifford(cliff)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/clifford/clifford_decompose_layers.py"
    },
    {
        "api_name": "_create_graph_state",
        "full_api_name": "_create_graph_state",
        "api_description": "Given a Clifford cliff (denoted by U) that induces a stabilizer state U |0>,\napply a layer H1 of Hadamard gates to a subset of the qubits to make H1 U |0> into a graph state,\nnamely to make cliff.stab_x matrix have full rank.\nReturns the QuantumCircuit H1_circ that includes the Hadamard gates and the updated Clifford\nthat induces the graph state.\nThe algorithm is based on Lemma 6 in [2].\n\nArgs:\n    cliff (Clifford): a Clifford operator.\n    validate (Boolean): if True, validates the synthesis process.\n\nReturns:\n    H1_circ: a circuit containing a layer of Hadamard gates.\n    cliffh: cliffh.stab_x has full rank.\n\nRaises:\n    QiskitError: if there are errors in the Gauss elimination process.\n\nReferences:\n    2. S. Aaronson, D. Gottesman, *Improved Simulation of Stabilizer Circuits*,\n       Phys. Rev. A 70, 052328 (2004).\n       `arXiv:quant-ph/0406196 <https://arxiv.org/abs/quant-ph/0406196>`_",
        "api_signature": "_create_graph_state(cliff, validate)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/clifford/clifford_decompose_layers.py"
    },
    {
        "api_name": "_decompose_graph_state",
        "full_api_name": "_decompose_graph_state",
        "api_description": "Assumes that a stabilizer state of the Clifford cliff (denoted by U) corresponds to a graph state.\nDecompose it into the layers S1 - CZ1 - H2, such that:\nS1 CZ1 H2 |0> = U |0>,\nwhere S1_circ is a circuit that can contain only S gates,\nCZ1_circ is a circuit that can contain only CZ gates, and\nH2_circ is a circuit that can contain H gates on all qubits.\n\nArgs:\n    cliff (Clifford): a Clifford operator corresponding to a graph state, cliff.stab_x has full rank.\n    validate (Boolean): if True, validates the synthesis process.\n    cz_synth_func (Callable): a function to decompose the CZ sub-circuit.\n\nReturns:\n    S1_circ: a circuit that can contain only S gates.\n    CZ1_circ: a circuit that can contain only CZ gates.\n    H2_circ: a circuit containing a layer of Hadamard gates.\n    cliff_cpy: a Hadamard-free Clifford.\n\nRaises:\n    QiskitError: if cliff does not induce a graph state.",
        "api_signature": "_decompose_graph_state(cliff, validate, cz_synth_func)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/clifford/clifford_decompose_layers.py"
    },
    {
        "api_name": "_decompose_hadamard_free",
        "full_api_name": "_decompose_hadamard_free",
        "api_description": "Assumes that the Clifford cliff is Hadamard free.\nDecompose it into the layers S2 - CZ2 - CX, where\nS2_circ is a circuit that can contain only S gates,\nCZ2_circ is a circuit that can contain only CZ gates, and\nCX_circ is a circuit that can contain CX gates.\n\nArgs:\n    cliff (Clifford): a Hadamard-free clifford operator.\n    validate (Boolean): if True, validates the synthesis process.\n    cz_synth_func (Callable): a function to decompose the CZ sub-circuit.\n    cx_synth_func (Callable): a function to decompose the CX sub-circuit.\n    cx_cz_synth_func (Callable): optional, a function to decompose both sub-circuits CZ and CX.\n    cz_func_reverse_qubits (Boolean): True only if cz_synth_func is synth_cz_depth_line_mr.\n\nReturns:\n    S2_circ: a circuit that can contain only S gates.\n    CZ2_circ: a circuit that can contain only CZ gates.\n    CX_circ: a circuit that can contain only CX gates.\n\nRaises:\n    QiskitError: if cliff is not Hadamard free.",
        "api_signature": "_decompose_hadamard_free(cliff, validate, cz_synth_func, cx_synth_func, cx_cz_synth_func, cz_func_reverse_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/clifford/clifford_decompose_layers.py"
    },
    {
        "api_name": "_calc_pauli_diff",
        "full_api_name": "_calc_pauli_diff",
        "api_description": "Given two Cliffords that differ by a Pauli, we find this Pauli.",
        "api_signature": "_calc_pauli_diff(cliff, cliff_target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/clifford/clifford_decompose_layers.py"
    },
    {
        "api_name": "synth_clifford_depth_lnn",
        "full_api_name": "synth_clifford_depth_lnn",
        "api_description": "Synthesis of a :class:`.Clifford` into layers for linear-nearest neighbor connectivity.\n\nThe depth of the synthesized n-qubit circuit is bounded by :math:`7n+2`, which is not optimal.\nIt should be replaced by a better algorithm that provides depth bounded by :math:`7n-4` [3].\n\nArgs:\n    cliff (Clifford): a Clifford operator.\n\nReturns:\n    QuantumCircuit: a circuit implementation of the Clifford.\n\nReferences:\n    1. S. Bravyi, D. Maslov, *Hadamard-free circuits expose the\n       structure of the Clifford group*,\n       `arXiv:2003.09412 [quant-ph] <https://arxiv.org/abs/2003.09412>`_\n    2. Dmitri Maslov, Martin Roetteler,\n       *Shorter stabilizer circuits via Bruhat decomposition and quantum circuit transformations*,\n       `arXiv:1705.09176 <https://arxiv.org/abs/1705.09176>`_.\n    3. Dmitri Maslov, Willers Yang, *CNOT circuits need little help to implement arbitrary\n       Hadamard-free Clifford transformations they generate*,\n       `arXiv:2210.16195 <https://arxiv.org/abs/2210.16195>`_.",
        "api_signature": "synth_clifford_depth_lnn(cliff)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/clifford/clifford_decompose_layers.py"
    },
    {
        "api_name": "_compute_trace_so3",
        "full_api_name": "_compute_trace_so3",
        "api_description": "Computes trace of an SO(3)-matrix.\n\nArgs:\n    matrix: an SO(3)-matrix\n\nReturns:\n    Trace of ``matrix``.\n\nRaises:\n    ValueError: if ``matrix`` is not an SO(3)-matrix.",
        "api_signature": "_compute_trace_so3(matrix)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/commutator_decompose.py"
    },
    {
        "api_name": "_compute_rotation_axis",
        "full_api_name": "_compute_rotation_axis",
        "api_description": "Computes rotation axis of SO(3)-matrix.\n\nArgs:\n    matrix: The SO(3)-matrix for which rotation angle needs to be computed.\n\nReturns:\n    The rotation axis of the SO(3)-matrix ``matrix``.\n\nRaises:\n    ValueError: if ``matrix`` is not an SO(3)-matrix.",
        "api_signature": "_compute_rotation_axis(matrix)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/commutator_decompose.py"
    },
    {
        "api_name": "_solve_decomposition_angle",
        "full_api_name": "_solve_decomposition_angle",
        "api_description": "Computes angle for balanced commutator of SO(3)-matrix ``matrix``.\n\nComputes angle a so that the SO(3)-matrix ``matrix`` can be decomposed\nas commutator [v,w] where v and w are both rotations of a about some axis.\nThe computation is done by solving a trigonometric equation using scipy.optimize.fsolve.\n\nArgs:\n    matrix: The SO(3)-matrix for which the decomposition angle needs to be computed.\n\nReturns:\n    Angle a so that matrix = [v,w] with v and w rotations of a about some axis.\n\nRaises:\n    ValueError: if ``matrix`` is not an SO(3)-matrix.",
        "api_signature": "_solve_decomposition_angle(matrix)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/commutator_decompose.py"
    },
    {
        "api_name": "objective",
        "full_api_name": "objective",
        "api_description": "",
        "api_signature": "objective(phi)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/commutator_decompose.py"
    },
    {
        "api_name": "_compute_rotation_from_angle_and_axis",
        "full_api_name": "_compute_rotation_from_angle_and_axis",
        "api_description": "Computes the SO(3)-matrix corresponding to the rotation of ``angle`` about ``axis``.\n\nArgs:\n    angle: The angle of the rotation.\n    axis: The axis of the rotation.\n\nReturns:\n    SO(3)-matrix that represents a rotation of ``angle`` about ``axis``.\n\nRaises:\n    ValueError: if ``axis`` is not a 3-dim unit vector.",
        "api_signature": "_compute_rotation_from_angle_and_axis(angle, axis)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/commutator_decompose.py"
    },
    {
        "api_name": "_compute_rotation_between",
        "full_api_name": "_compute_rotation_between",
        "api_description": "Computes the SO(3)-matrix for rotating ``from_vector`` to ``to_vector``.\n\nArgs:\n    from_vector: unit vector of size 3\n    to_vector: unit vector of size 3\n\nReturns:\n    SO(3)-matrix that brings ``from_vector`` to ``to_vector``.\n\nRaises:\n    ValueError: if at least one of ``from_vector`` of ``to_vector`` is not a 3-dim unit vector.",
        "api_signature": "_compute_rotation_between(from_vector, to_vector)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/commutator_decompose.py"
    },
    {
        "api_name": "_cross_product_matrix",
        "full_api_name": "_cross_product_matrix",
        "api_description": "Computes cross product matrix from vector.\n\nArgs:\n    v: Vector for which cross product matrix needs to be computed.\n\nReturns:\n    The cross product matrix corresponding to vector ``v``.",
        "api_signature": "_cross_product_matrix(v)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/commutator_decompose.py"
    },
    {
        "api_name": "_compute_commutator_so3",
        "full_api_name": "_compute_commutator_so3",
        "api_description": "Computes the commutator of the SO(3)-matrices ``a`` and ``b``.\n\nThe computation uses the fact that the inverse of an SO(3)-matrix is equal to its transpose.\n\nArgs:\n    a: SO(3)-matrix\n    b: SO(3)-matrix\n\nReturns:\n    The commutator [a,b] of ``a`` and ``b`` w\n\nRaises:\n    ValueError: if at least one of ``a`` or ``b`` is not an SO(3)-matrix.",
        "api_signature": "_compute_commutator_so3(a, b)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/commutator_decompose.py"
    },
    {
        "api_name": "commutator_decompose",
        "full_api_name": "commutator_decompose",
        "api_description": "Decompose an :math:`SO(3)`-matrix, :math:`U` as a balanced commutator.\n\nThis function finds two :math:`SO(3)` matrices :math:`V, W` such that the input matrix\nequals\n\n.. math::\n\n    U = V^\\dagger W^\\dagger V W.\n\nFor this decomposition, the following statement holds\n\n\n.. math::\n\n    ||V - I||_F, ||W - I||_F \\leq \\frac{\\sqrt{||U - I||_F}}{2},\n\nwhere :math:`I` is the identity and :math:`||\\cdot ||_F` is the Frobenius norm.\n\nArgs:\n    u_so3: SO(3)-matrix that needs to be decomposed as balanced commutator.\n    check_input: If True, checks whether the input matrix is actually SO(3).\n\nReturns:\n    Tuple of GateSequences from SO(3)-matrices :math:`V, W`.\n\nRaises:\n    ValueError: if ``u_so3`` is not an SO(3)-matrix.",
        "api_signature": "commutator_decompose(u_so3, check_input)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/commutator_decompose.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SolovayKitaevDecomposition.__init__",
        "api_description": "Args:\n    basic_approximations: A specification of the basic SU(2) approximations in terms\n        of discrete gates. At each iteration this algorithm, the remaining error is\n        approximated with the closest sequence of gates in this set.\n        If a ``str``, this specifies a ``.npy`` filename from which to load the\n        approximation. If a ``dict``, then this contains\n        ``{gates: effective_SO3_matrix}`` pairs,\n        e.g. ``{\"h t\": np.array([[0, 0.7071, -0.7071], [0, -0.7071, -0.7071], [-1, 0, 0]]}``.\n        If a list, this contains the same information as the dict, but already converted to\n        :class:`.GateSequence` objects, which contain the SO(3) matrix and gates.",
        "api_signature": "__init__(self, basic_approximations)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/solovay_kitaev.py"
    },
    {
        "api_name": "load_basic_approximations",
        "full_api_name": "SolovayKitaevDecomposition.load_basic_approximations",
        "api_description": "Load basic approximations.\n\nArgs:\n    data: If a string, specifies the path to the file from where to load the data.\n        If a dictionary, directly specifies the decompositions as ``{gates: matrix}``\n        or ``{gates: (matrix, global_phase)}``. There, ``gates`` are the names of the gates\n        producing the SO(3) matrix ``matrix``, e.g.\n        ``{\"h t\": np.array([[0, 0.7071, -0.7071], [0, -0.7071, -0.7071], [-1, 0, 0]]}``\n        and the ``global_phase`` can be given to account for a global phase difference\n        between the U(2) matrix of the quantum gates and the stored SO(3) matrix.\n        If not given, the ``global_phase`` will be assumed to be 0.\n\nReturns:\n    A list of basic approximations as type ``GateSequence``.\n\nRaises:\n    ValueError: If the number of gate combinations and associated matrices does not match.",
        "api_signature": "load_basic_approximations(data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/solovay_kitaev.py"
    },
    {
        "api_name": "run",
        "full_api_name": "SolovayKitaevDecomposition.run",
        "api_description": "Run the algorithm.\n\nArgs:\n    gate_matrix: The 2x2 matrix representing the gate. This matrix has to be SU(2)\n        up to global phase.\n    recursion_degree: The recursion degree, called :math:`n` in the paper.\n    return_dag: If ``True`` return a :class:`.DAGCircuit`, else a :class:`.QuantumCircuit`.\n    check_input: If ``True`` check that the input matrix is valid for the decomposition.\n\nReturns:\n    A one-qubit circuit approximating the ``gate_matrix`` in the specified discrete basis.",
        "api_signature": "run(self, gate_matrix, recursion_degree, return_dag, check_input)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/solovay_kitaev.py"
    },
    {
        "api_name": "_recurse",
        "full_api_name": "SolovayKitaevDecomposition._recurse",
        "api_description": "Performs ``n`` iterations of the Solovay-Kitaev algorithm on ``sequence``.\n\nArgs:\n    sequence: ``GateSequence`` to which the Solovay-Kitaev algorithm is applied.\n    n: The number of iterations that the algorithm needs to run.\n    check_input: If ``True`` check that the input matrix represented by ``GateSequence``\n        is valid for the decomposition.\n\nReturns:\n    GateSequence that approximates ``sequence``.\n\nRaises:\n    ValueError: If the matrix in ``GateSequence`` does not represent an SO(3)-matrix.",
        "api_signature": "_recurse(self, sequence, n, check_input)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/solovay_kitaev.py"
    },
    {
        "api_name": "find_basic_approximation",
        "full_api_name": "SolovayKitaevDecomposition.find_basic_approximation",
        "api_description": "Find ``GateSequence`` in ``self._basic_approximations`` that approximates ``sequence``.\n\nArgs:\n    sequence: ``GateSequence`` to find the approximation to.\n\nReturns:\n    ``GateSequence`` in ``self._basic_approximations`` that approximates ``sequence``.",
        "api_signature": "find_basic_approximation(self, sequence)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/solovay_kitaev.py"
    },
    {
        "api_name": "key",
        "full_api_name": "SolovayKitaevDecomposition.key",
        "api_description": "",
        "api_signature": "key(x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/solovay_kitaev.py"
    },
    {
        "api_name": "_remove_inverse_follows_gate",
        "full_api_name": "_remove_inverse_follows_gate",
        "api_description": "",
        "api_signature": "_remove_inverse_follows_gate(sequence)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/solovay_kitaev.py"
    },
    {
        "api_name": "_remove_identities",
        "full_api_name": "_remove_identities",
        "api_description": "",
        "api_signature": "_remove_identities(sequence)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/solovay_kitaev.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "GateSequence.__init__",
        "api_description": "Create a new sequence of gates.\n\nArgs:\n    gates: The gates in the sequence. The default is [].",
        "api_signature": "__init__(self, gates)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/gate_sequence.py"
    },
    {
        "api_name": "remove_cancelling_pair",
        "full_api_name": "GateSequence.remove_cancelling_pair",
        "api_description": "Remove a pair of indices that cancel each other and *do not* change the matrices.",
        "api_signature": "remove_cancelling_pair(self, indices)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/gate_sequence.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "GateSequence.__eq__",
        "api_description": "Check if this GateSequence is the same as the other GateSequence.\n\nArgs:\n    other: The GateSequence that will be compared to ``self``.\n\nReturns:\n    True if ``other`` is equivalent to ``self``, false otherwise.",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/gate_sequence.py"
    },
    {
        "api_name": "to_circuit",
        "full_api_name": "GateSequence.to_circuit",
        "api_description": "Convert to a circuit.\n\nIf no gates set but the product is not the identity, returns a circuit with a\nunitary operation to implement the matrix.",
        "api_signature": "to_circuit(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/gate_sequence.py"
    },
    {
        "api_name": "to_dag",
        "full_api_name": "GateSequence.to_dag",
        "api_description": "Convert to a :class:`.DAGCircuit`.\n\nIf no gates set but the product is not the identity, returns a circuit with a\nunitary operation to implement the matrix.",
        "api_signature": "to_dag(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/gate_sequence.py"
    },
    {
        "api_name": "append",
        "full_api_name": "GateSequence.append",
        "api_description": "Append gate to the sequence of gates.\n\nArgs:\n    gate: The gate to be appended.\n\nReturns:\n    GateSequence with ``gate`` appended.",
        "api_signature": "append(self, gate)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/gate_sequence.py"
    },
    {
        "api_name": "adjoint",
        "full_api_name": "GateSequence.adjoint",
        "api_description": "Get the complex conjugate.",
        "api_signature": "adjoint(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/gate_sequence.py"
    },
    {
        "api_name": "copy",
        "full_api_name": "GateSequence.copy",
        "api_description": "Create copy of the sequence of gates.\n\nReturns:\n    A new ``GateSequence`` containing copy of list of gates.",
        "api_signature": "copy(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/gate_sequence.py"
    },
    {
        "api_name": "__len__",
        "full_api_name": "GateSequence.__len__",
        "api_description": "Return length of sequence of gates.\n\nReturns:\n    Length of list containing gates.",
        "api_signature": "__len__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/gate_sequence.py"
    },
    {
        "api_name": "__getitem__",
        "full_api_name": "GateSequence.__getitem__",
        "api_description": "Returns the gate at ``index`` from the list of gates.\n\nArgs\n    index: Index of gate in list that will be returned.\n\nReturns:\n    The gate at ``index`` in the list of gates.",
        "api_signature": "__getitem__(self, index)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/gate_sequence.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "GateSequence.__repr__",
        "api_description": "Return string representation of this object.\n\nReturns:\n    Representation of this sequence of gates.",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/gate_sequence.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "GateSequence.__str__",
        "api_description": "Return string representation of this object.\n\nReturns:\n    Representation of this sequence of gates.",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/gate_sequence.py"
    },
    {
        "api_name": "from_matrix",
        "full_api_name": "GateSequence.from_matrix",
        "api_description": "Initialize the gate sequence from a matrix, without a gate sequence.\n\nArgs:\n    matrix: The matrix, can be SU(2) or SO(3).\n\nReturns:\n    A ``GateSequence`` initialized from the input matrix.\n\nRaises:\n    ValueError: If the matrix has an invalid shape.",
        "api_signature": "from_matrix(cls, matrix)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/gate_sequence.py"
    },
    {
        "api_name": "dot",
        "full_api_name": "GateSequence.dot",
        "api_description": "Compute the dot-product with another gate sequence.\n\nArgs:\n    other: The other gate sequence.\n\nReturns:\n    The dot-product as gate sequence.",
        "api_signature": "dot(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/gate_sequence.py"
    },
    {
        "api_name": "_convert_u2_to_su2",
        "full_api_name": "_convert_u2_to_su2",
        "api_description": "Convert a U(2) matrix to SU(2) by adding a global phase.",
        "api_signature": "_convert_u2_to_su2(u2_matrix)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/gate_sequence.py"
    },
    {
        "api_name": "_compute_euler_angles_from_so3",
        "full_api_name": "_compute_euler_angles_from_so3",
        "api_description": "Computes the Euler angles from the SO(3)-matrix u.\n\nUses the algorithm from Gregory Slabaugh,\nsee `here <https://www.gregslabaugh.net/publications/euler.pdf>`_.\n\nArgs:\n    matrix: The SO(3)-matrix for which the Euler angles need to be computed.\n\nReturns:\n    Tuple (phi, theta, psi), where phi is rotation about z-axis, theta rotation about y-axis\n    and psi rotation about x-axis.",
        "api_signature": "_compute_euler_angles_from_so3(matrix)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/gate_sequence.py"
    },
    {
        "api_name": "_compute_su2_from_euler_angles",
        "full_api_name": "_compute_su2_from_euler_angles",
        "api_description": "Computes SU(2)-matrix from Euler angles.\n\nArgs:\n    angles: The tuple containing the Euler angles for which the corresponding SU(2)-matrix\n        needs to be computed.\n\nReturns:\n    The SU(2)-matrix corresponding to the Euler angles in angles.",
        "api_signature": "_compute_su2_from_euler_angles(angles)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/gate_sequence.py"
    },
    {
        "api_name": "_convert_su2_to_so3",
        "full_api_name": "_convert_su2_to_so3",
        "api_description": "Computes SO(3)-matrix from input SU(2)-matrix.\n\nArgs:\n    matrix: The SU(2)-matrix for which a corresponding SO(3)-matrix needs to be computed.\n\nReturns:\n    The SO(3)-matrix corresponding to ``matrix``.\n\nRaises:\n    ValueError: if ``matrix`` is not an SU(2)-matrix.",
        "api_signature": "_convert_su2_to_so3(matrix)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/gate_sequence.py"
    },
    {
        "api_name": "_convert_so3_to_su2",
        "full_api_name": "_convert_so3_to_su2",
        "api_description": "Converts an SO(3)-matrix to a corresponding SU(2)-matrix.\n\nArgs:\n    matrix: SO(3)-matrix to convert.\n\nReturns:\n    SU(2)-matrix corresponding to SO(3)-matrix ``matrix``.\n\nRaises:\n    ValueError: if ``matrix`` is not an SO(3)-matrix.",
        "api_signature": "_convert_so3_to_su2(matrix)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/gate_sequence.py"
    },
    {
        "api_name": "_check_is_su2",
        "full_api_name": "_check_is_su2",
        "api_description": "Check whether ``matrix`` is SU(2), otherwise raise an error.",
        "api_signature": "_check_is_su2(matrix)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/gate_sequence.py"
    },
    {
        "api_name": "_check_is_so3",
        "full_api_name": "_check_is_so3",
        "api_description": "Check whether ``matrix`` is SO(3), otherwise raise an error.",
        "api_signature": "_check_is_so3(matrix)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/gate_sequence.py"
    },
    {
        "api_name": "_check_candidate",
        "full_api_name": "_check_candidate",
        "api_description": "",
        "api_signature": "_check_candidate(candidate, existing_sequences, tol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/generate_basis_approximations.py"
    },
    {
        "api_name": "_check_candidate_greedy",
        "full_api_name": "_check_candidate_greedy",
        "api_description": "",
        "api_signature": "_check_candidate_greedy(candidate, existing_sequences, tol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/generate_basis_approximations.py"
    },
    {
        "api_name": "_check_candidate_kdtree",
        "full_api_name": "_check_candidate_kdtree",
        "api_description": "Check if there's a candidate implementing the same matrix up to ``tol``.\n\nThis uses a k-d tree search and is much faster than the greedy, list-based search.",
        "api_signature": "_check_candidate_kdtree(candidate, existing_sequences, tol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/generate_basis_approximations.py"
    },
    {
        "api_name": "_process_node",
        "full_api_name": "_process_node",
        "api_description": "",
        "api_signature": "_process_node(node, basis, sequences)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/generate_basis_approximations.py"
    },
    {
        "api_name": "generate_basic_approximations",
        "full_api_name": "generate_basic_approximations",
        "api_description": "Generates a list of :class:`GateSequence`\\ s with the gates in ``basis_gates``.\n\nArgs:\n    basis_gates: The gates from which to create the sequences of gates.\n    depth: The maximum depth of the approximations.\n    filename: If provided, the basic approximations are stored in this file.\n\nReturns:\n    List of :class:`GateSequence`\\ s using the gates in ``basis_gates``.\n\nRaises:\n    ValueError: If ``basis_gates`` contains an invalid gate identifier.",
        "api_signature": "generate_basic_approximations(basis_gates, depth, filename)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/discrete_basis/generate_basis_approximations.py"
    },
    {
        "api_name": "synth_qft_full",
        "full_api_name": "synth_qft_full",
        "api_description": "Construct a circuit for the Quantum Fourier Transform using all-to-all connectivity.\n\n.. note::\n\n    With the default value of ``do_swaps = True``, this synthesis algorithm creates a\n    circuit that faithfully implements the QFT operation. This circuit contains a sequence\n    of swap gates at the end, corresponding to reversing the order of its output qubits.\n    In some applications this reversal permutation can be avoided. Setting ``do_swaps = False``\n    creates a circuit without this reversal permutation, at the expense that this circuit\n    implements the \"QFT-with-reversal\" instead of QFT. Alternatively, the\n    :class:`~.ElidePermutations` transpiler pass is able to remove these swap gates.\n\nArgs:\n    num_qubits: The number of qubits on which the Quantum Fourier Transform acts.\n    do_swaps: Whether to synthesize the \"QFT\" or the \"QFT-with-reversal\" operation.\n    approximation_degree: The degree of approximation (0 for no approximation).\n        It is possible to implement the QFT approximately by ignoring\n        controlled-phase rotations with the angle beneath a threshold. This is discussed\n        in more detail in https://arxiv.org/abs/quant-ph/9601018 or\n        https://arxiv.org/abs/quant-ph/0403071.\n    insert_barriers: If ``True``, barriers are inserted for improved visualization.\n    inverse: If ``True``, the inverse Quantum Fourier Transform is constructed.\n    name: The name of the circuit.\n\nReturns:\n    A circuit implementing the QFT operation.",
        "api_signature": "synth_qft_full(num_qubits, do_swaps, approximation_degree, insert_barriers, inverse, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/qft/qft_decompose_full.py"
    },
    {
        "api_name": "synth_qft_line",
        "full_api_name": "synth_qft_line",
        "api_description": "Construct a circuit for the Quantum Fourier Transform using linear\nneighbor connectivity.\n\nThe construction is based on Fig 2.b in Fowler et al. [1].\n\n.. note::\n\n    With the default value of ``do_swaps = True``, this synthesis algorithm creates a\n    circuit that faithfully implements the QFT operation. When ``do_swaps = False``,\n    this synthesis algorithm creates a circuit that corresponds to \"QFT-with-reversal\":\n    applying the QFT and reversing the order of its output qubits.\n\nArgs:\n    num_qubits: The number of qubits on which the Quantum Fourier Transform acts.\n    approximation_degree: The degree of approximation (0 for no approximation).\n        It is possible to implement the QFT approximately by ignoring\n        controlled-phase rotations with the angle beneath a threshold. This is discussed\n        in more detail in https://arxiv.org/abs/quant-ph/9601018 or\n        https://arxiv.org/abs/quant-ph/0403071.\n    do_swaps: Whether to synthesize the \"QFT\" or the \"QFT-with-reversal\" operation.\n\nReturns:\n    A circuit implementing the QFT operation.\n\nReferences:\n    1. A. G. Fowler, S. J. Devitt, and L. C. L. Hollenberg,\n       *Implementation of Shor's algorithm on a linear nearest neighbour qubit array*,\n       Quantum Info. Comput. 4, 4 (July 2004), 237\u2013251.\n       `arXiv:quant-ph/0402196 [quant-ph] <https://arxiv.org/abs/quant-ph/0402196>`_",
        "api_signature": "synth_qft_line(num_qubits, do_swaps, approximation_degree)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/qft/qft_decompose_lnn.py"
    },
    {
        "api_name": "_append_cx_stage1",
        "full_api_name": "_append_cx_stage1",
        "api_description": "A single layer of CX gates.",
        "api_signature": "_append_cx_stage1(qc, n)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/permutation/permutation_reverse_lnn.py"
    },
    {
        "api_name": "_append_cx_stage2",
        "full_api_name": "_append_cx_stage2",
        "api_description": "A single layer of CX gates.",
        "api_signature": "_append_cx_stage2(qc, n)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/permutation/permutation_reverse_lnn.py"
    },
    {
        "api_name": "_append_reverse_permutation_lnn_kms",
        "full_api_name": "_append_reverse_permutation_lnn_kms",
        "api_description": "Append reverse permutation to a QuantumCircuit for linear nearest-neighbor architectures\nusing Kutin, Moulton, Smithline method.\n\nSynthesis algorithm for reverse permutation from [1], section 5.\nThis algorithm synthesizes the reverse permutation on :math:`n` qubits over\na linear nearest-neighbor architecture using CX gates with depth :math:`2 * n + 2`.\n\nArgs:\n    qc: The original quantum circuit.\n    num_qubits: The number of qubits.\n\nReturns:\n    The quantum circuit with appended reverse permutation.\n\nReferences:\n    1. Kutin, S., Moulton, D. P., Smithline, L.,\n       *Computation at a distance*, Chicago J. Theor. Comput. Sci., vol. 2007, (2007),\n       `arXiv:quant-ph/0701194 <https://arxiv.org/abs/quant-ph/0701194>`_",
        "api_signature": "_append_reverse_permutation_lnn_kms(qc, num_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/permutation/permutation_reverse_lnn.py"
    },
    {
        "api_name": "synth_permutation_reverse_lnn_kms",
        "full_api_name": "synth_permutation_reverse_lnn_kms",
        "api_description": "Synthesize reverse permutation for linear nearest-neighbor architectures using\nKutin, Moulton, Smithline method.\n\nSynthesis algorithm for reverse permutation from [1], section 5.\nThis algorithm synthesizes the reverse permutation on :math:`n` qubits over\na linear nearest-neighbor architecture using CX gates with depth :math:`2 * n + 2`.\n\nArgs:\n    num_qubits: The number of qubits.\n\nReturns:\n    The synthesized quantum circuit.\n\nReferences:\n    1. Kutin, S., Moulton, D. P., Smithline, L.,\n       *Computation at a distance*, Chicago J. Theor. Comput. Sci., vol. 2007, (2007),\n       `arXiv:quant-ph/0701194 <https://arxiv.org/abs/quant-ph/0701194>`_",
        "api_signature": "synth_permutation_reverse_lnn_kms(num_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/permutation/permutation_reverse_lnn.py"
    },
    {
        "api_name": "synth_permutation_depth_lnn_kms",
        "full_api_name": "synth_permutation_depth_lnn_kms",
        "api_description": "Synthesize a permutation circuit for a linear nearest-neighbor\narchitecture using the Kutin, Moulton, Smithline method.\n\nThis is the permutation synthesis algorithm from [1], section 6.\nIt synthesizes any permutation of n qubits over linear nearest-neighbor\narchitecture using SWAP gates with depth at most :math:`n` and size at most\n:math:`n(n-1)/2` (where both depth and size are measured with respect to SWAPs).\n\nArgs:\n    pattern: Permutation pattern, describing\n        which qubits occupy the positions 0, 1, 2, etc. after applying the\n        permutation. That is, ``pattern[k] = m`` when the permutation maps\n        qubit ``m`` to position ``k``. As an example, the pattern ``[2, 4, 3, 0, 1]``\n        means that qubit ``2`` goes to position ``0``, qubit ``4`` goes to\n        position ``1``, etc.\n\nReturns:\n    The synthesized quantum circuit.\n\nReferences:\n    1. Samuel A. Kutin, David Petrie Moulton and Lawren M. Smithline.\n       *Computation at a distance.*,\n       `arXiv:quant-ph/0701194v1 <https://arxiv.org/abs/quant-ph/0701194>`_",
        "api_signature": "synth_permutation_depth_lnn_kms(pattern)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/permutation/permutation_lnn.py"
    },
    {
        "api_name": "synth_permutation_basic",
        "full_api_name": "synth_permutation_basic",
        "api_description": "Synthesize a permutation circuit for a fully-connected\narchitecture using sorting.\n\nMore precisely, if the input permutation is a cycle of length ``m``,\nthen this creates a quantum circuit with ``m-1`` SWAPs (and of depth ``m-1``);\nif the input  permutation consists of several disjoint cycles, then each cycle\nis essentially treated independently.\n\nArgs:\n    pattern: Permutation pattern, describing\n        which qubits occupy the positions 0, 1, 2, etc. after applying the\n        permutation. That is, ``pattern[k] = m`` when the permutation maps\n        qubit ``m`` to position ``k``. As an example, the pattern ``[2, 4, 3, 0, 1]``\n        means that qubit ``2`` goes to position ``0``, qubit ``4`` goes to\n        position ``1``, etc.\n\nReturns:\n    The synthesized quantum circuit.",
        "api_signature": "synth_permutation_basic(pattern)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/permutation/permutation_full.py"
    },
    {
        "api_name": "synth_permutation_acg",
        "full_api_name": "synth_permutation_acg",
        "api_description": "Synthesize a permutation circuit for a fully-connected\narchitecture using the Alon, Chung, Graham method.\n\nThis produces a quantum circuit of depth 2 (measured in the number of SWAPs).\n\nThis implementation is based on the Proposition 4.1 in reference [1] with\nthe detailed proof given in Theorem 2 in reference [2]\n\nArgs:\n    pattern: Permutation pattern, describing\n        which qubits occupy the positions 0, 1, 2, etc. after applying the\n        permutation. That is, ``pattern[k] = m`` when the permutation maps\n        qubit ``m`` to position ``k``. As an example, the pattern ``[2, 4, 3, 0, 1]``\n        means that qubit ``2`` goes to position ``0``, qubit ``4`` goes to\n        position ``1``, etc.\n\nReturns:\n    The synthesized quantum circuit.\n\nReferences:\n    1. N. Alon, F. R. K. Chung, and R. L. Graham.\n       *Routing Permutations on Graphs Via Matchings.*,\n       Proceedings of the Twenty-Fifth Annual ACM Symposium on Theory of Computing(1993).\n       Pages 583\u2013591.\n       `(Extended abstract) 10.1145/167088.167239 <https://doi.org/10.1145/167088.167239>`_\n    2. N. Alon, F. R. K. Chung, and R. L. Graham.\n       *Routing Permutations on Graphs Via Matchings.*,\n       `(Full paper) <https://www.cs.tau.ac.il/~nogaa/PDFS/r.pdf>`_",
        "api_signature": "synth_permutation_acg(pattern)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/permutation/permutation_full.py"
    },
    {
        "api_name": "synth_stabilizer_layers",
        "full_api_name": "synth_stabilizer_layers",
        "api_description": "Synthesis of a stabilizer state into layers.\n\nIt provides a similar decomposition to the synthesis described in Lemma 8 of reference [1],\nwithout the initial Hadamard-free sub-circuit which do not affect the stabilizer state.\n\nFor example, a 5-qubit stabilizer state is decomposed into the following layers:\n\n.. parsed-literal::\n         \u250c\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    q_0: \u25240    \u251c\u25240    \u251c\u25240    \u251c\u25240    \u251c\u25240       \u251c\n         \u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502        \u2502\n    q_1: \u25241    \u251c\u25241    \u251c\u25241    \u251c\u25241    \u251c\u25241       \u251c\n         \u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502        \u2502\n    q_2: \u25242 H2 \u251c\u25242 S1 \u251c\u25242 CZ \u251c\u25242 H1 \u251c\u25242 Pauli \u251c\n         \u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502        \u2502\n    q_3: \u25243    \u251c\u25243    \u251c\u25243    \u251c\u25243    \u251c\u25243       \u251c\n         \u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502        \u2502\n    q_4: \u25244    \u251c\u25244    \u251c\u25244    \u251c\u25244    \u251c\u25244       \u251c\n         \u2514\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nArgs:\n    stab: A stabilizer state.\n    cz_synth_func: A function to decompose the CZ sub-circuit.\n        It gets as input a boolean symmetric matrix, and outputs a :class:`.QuantumCircuit`.\n    cz_func_reverse_qubits: ``True`` only if ``cz_synth_func`` is\n        :func:`.synth_cz_depth_line_mr`,\n        since this function returns a circuit that reverts the order of qubits.\n    validate: If ``True``, validates the synthesis process.\n\nReturns:\n    A circuit implementation of the stabilizer state.\n\nRaises:\n    QiskitError: if the input is not a :class:`.StabilizerState`.\n\nReferences:\n    1. S. Bravyi, D. Maslov, *Hadamard-free circuits expose the\n       structure of the Clifford group*,\n       `arXiv:2003.09412 [quant-ph] <https://arxiv.org/abs/2003.09412>`_",
        "api_signature": "synth_stabilizer_layers(stab, cz_synth_func, cz_func_reverse_qubits, validate)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/stabilizer/stabilizer_decompose.py"
    },
    {
        "api_name": "_calc_pauli_diff_stabilizer",
        "full_api_name": "_calc_pauli_diff_stabilizer",
        "api_description": "Given two Cliffords whose stabilizers differ by a Pauli, we find this Pauli.",
        "api_signature": "_calc_pauli_diff_stabilizer(cliff, cliff_target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/stabilizer/stabilizer_decompose.py"
    },
    {
        "api_name": "synth_stabilizer_depth_lnn",
        "full_api_name": "synth_stabilizer_depth_lnn",
        "api_description": "Synthesis of an n-qubit stabilizer state for linear-nearest neighbor connectivity,\nin 2-qubit depth :math:`2n+2` and two distinct CX layers, using :class:`.CXGate`\\ s and phase gates\n(:class:`.SGate`, :class:`.SdgGate` or :class:`.ZGate`).\n\nArgs:\n    stab: A stabilizer state.\n\nReturns:\n    A circuit implementation of the stabilizer state.\n\nReferences:\n    1. S. Bravyi, D. Maslov, *Hadamard-free circuits expose the\n       structure of the Clifford group*,\n       `arXiv:2003.09412 [quant-ph] <https://arxiv.org/abs/2003.09412>`_\n    2. Dmitri Maslov, Martin Roetteler,\n       *Shorter stabilizer circuits via Bruhat decomposition and quantum circuit transformations*,\n       `arXiv:1705.09176 <https://arxiv.org/abs/1705.09176>`_.",
        "api_signature": "synth_stabilizer_depth_lnn(stab)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/stabilizer/stabilizer_decompose.py"
    },
    {
        "api_name": "synth_circuit_from_stabilizers",
        "full_api_name": "synth_circuit_from_stabilizers",
        "api_description": "Synthesis of a circuit that generates a state stabilized by the stabilizers\nusing Gaussian elimination with Clifford gates.\nIf the stabilizers are underconstrained, and ``allow_underconstrained`` is ``True``,\nthe circuit will output one of the states stabilized by the stabilizers.\nBased on stim implementation.\n\nArgs:\n    stabilizers: List of stabilizer strings\n    allow_redundant: Allow redundant stabilizers (i.e., some stabilizers\n        can be products of the others)\n    allow_underconstrained: Allow underconstrained set of stabilizers (i.e.,\n        the stabilizers do not specify a unique state)\n    invert: Return inverse circuit\n\nReturns:\n    A circuit that generates a state stabilized by ``stabilizers``.\n\nRaises:\n    QiskitError: if the stabilizers are invalid, do not commute, or contradict each other,\n                 if the list is underconstrained and ``allow_underconstrained`` is ``False``,\n                 or if the list is redundant and ``allow_redundant`` is ``False``.\n\nReferences:\n    1. https://github.com/quantumlib/Stim/blob/c0dd0b1c8125b2096cd54b6f72884a459e47fe3e/src/stim/stabilizers/conversions.inl#L469\n    2. https://quantumcomputing.stackexchange.com/questions/12721/how-to-calculate-destabilizer-group-of-toric-and-other-codes",
        "api_signature": "synth_circuit_from_stabilizers(stabilizers, allow_redundant, allow_underconstrained, invert)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/stabilizer/stabilizer_circuit.py"
    },
    {
        "api_name": "qs_decomposition",
        "full_api_name": "qs_decomposition",
        "api_description": "Decomposes a unitary matrix into one and two qubit gates using Quantum Shannon Decomposition,\n\nThis decomposition is described in Shende et al. [1].\n\n.. parsed-literal::\n      \u250c\u2500\u2500\u2500\u2510               \u250c\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2510\n     \u2500\u2524   \u251c\u2500       \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 Rz\u251c\u2500\u2500\u2500\u2500\u2500\u2524 Ry\u251c\u2500\u2500\u2500\u2500\u2500\u2524 Rz\u251c\u2500\u2500\u2500\u2500\u2500\n      \u2502   \u2502    \u2243     \u250c\u2500\u2500\u2500\u2510\u2514\u2500\u252c\u2500\u2518\u250c\u2500\u2500\u2500\u2510\u2514\u2500\u252c\u2500\u2518\u250c\u2500\u2500\u2500\u2510\u2514\u2500\u252c\u2500\u2518\u250c\u2500\u2500\u2500\u2510\n    /\u2500\u2524   \u251c\u2500       /\u2500\u2524   \u251c\u2500\u2500\u25a1\u2500\u2500\u2524   \u251c\u2500\u2500\u25a1\u2500\u2500\u2524   \u251c\u2500\u2500\u25a1\u2500\u2500\u2524   \u251c\n      \u2514\u2500\u2500\u2500\u2518          \u2514\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2518\n\nThe number of :class:`.CXGate`\\ s generated with the decomposition without optimizations is:\n\n.. math::\n\n    \\frac{9}{16} 4^n - \\frac{3}{2} 2^n\n\nIf ``opt_a1 = True``, the default, the CX count is reduced by:\n\n.. math::\n\n    \\frac{1}{3} 4^{n - 2} - 1.\n\nIf ``opt_a2 = True``, the default, the CX count is reduced by:\n\n.. math::\n\n    4^{n-2} - 1.\n\nArgs:\n    mat: unitary matrix to decompose\n    opt_a1: whether to try optimization A.1 from Shende et al. [1].\n        This should eliminate 1 ``cx`` per call.\n        If ``True``, :class:`.CZGate`\\s are left in the output.\n        If desired these can be further decomposed to :class:`.CXGate`\\s.\n    opt_a2: whether to try optimization A.2 from Shende et al. [1].\n        This decomposes two qubit unitaries into a diagonal gate and\n        a two cx unitary and reduces overall cx count by :math:`4^{n-2} - 1`.\n    decomposer_1q: optional 1Q decomposer. If None, uses\n        :class:`~qiskit.synthesis.OneQubitEulerDecomposer`.\n    decomposer_2q: optional 2Q decomposer. If None, uses\n        :class:`~qiskit.synthesis.TwoQubitBasisDecomposer`.\n\nReturns:\n    QuantumCircuit: Decomposed quantum circuit.\n\nReferences:\n    1. Shende, Bullock, Markov, *Synthesis of Quantum Logic Circuits*,\n       `arXiv:0406176 [quant-ph] <https://arxiv.org/abs/quant-ph/0406176>`_",
        "api_signature": "qs_decomposition(mat, opt_a1, opt_a2, decomposer_1q, decomposer_2q)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/qsd.py"
    },
    {
        "api_name": "decomp_2q",
        "full_api_name": "decomp_2q",
        "api_description": "",
        "api_signature": "decomp_2q(mat)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/qsd.py"
    },
    {
        "api_name": "_demultiplex",
        "full_api_name": "_demultiplex",
        "api_description": "Decompose a generic multiplexer.\n\n      \u2500\u2500\u2500\u2500\u25a1\u2500\u2500\u2500\u2500\n       \u250c\u2500\u2500\u2534\u2500\u2500\u2510\n     /\u2500\u2524     \u251c\u2500\n       \u2514\u2500\u2500\u2500\u2500\u2500\u2518\n\nrepresented by the block diagonal matrix\n\n        \u250f         \u2513\n        \u2503 um0     \u2503\n        \u2503     um1 \u2503\n        \u2517         \u251b\n\nto\n           \u250c\u2500\u2500\u2500\u2510\n    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 Rz\u251c\u2500\u2500\u2500\u2500\u2500\u2500\n      \u250c\u2500\u2500\u2500\u2510\u2514\u2500\u252c\u2500\u2518\u250c\u2500\u2500\u2500\u2510\n    /\u2500\u2524 w \u251c\u2500\u2500\u25a1\u2500\u2500\u2524 v \u251c\u2500\n      \u2514\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2518\n\nwhere v and w are general unitaries determined from decomposition.\n\nArgs:\n   um0 (ndarray): applied if MSB is 0\n   um1 (ndarray): applied if MSB is 1\n   opt_a1 (bool): whether to try optimization A.1 from Shende. This should eliminate 1 cnot\n      per call. If True CZ gates are left in the output. If desired these can be further decomposed\n   opt_a2 (bool): whether to try  optimization A.2 from Shende. This decomposes two qubit\n      unitaries into a diagonal gate and a two cx unitary and reduces overall cx count by\n      4^(n-2) - 1.\n   _depth (int): This is an internal variable to track the recursion depth.\n\nReturns:\n    QuantumCircuit: decomposed circuit",
        "api_signature": "_demultiplex(um0, um1, opt_a1, opt_a2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/qsd.py"
    },
    {
        "api_name": "_get_ucry_cz",
        "full_api_name": "_get_ucry_cz",
        "api_description": "Get uniformly controlled Ry gate in CZ-Ry as in UCPauliRotGate.",
        "api_signature": "_get_ucry_cz(nqubits, angles)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/qsd.py"
    },
    {
        "api_name": "_apply_a2",
        "full_api_name": "_apply_a2",
        "api_description": "",
        "api_signature": "_apply_a2(circ)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/qsd.py"
    },
    {
        "api_name": "__call__",
        "full_api_name": "Minimizer.__call__",
        "api_description": "Minimize the objective function.\n\nThis interface is based on `SciPy's optimize module <https://docs.scipy.org/doc\n/scipy/reference/generated/scipy.optimize.minimize.html>`__.\n\nArgs:\n    fun: The objective function to minimize.\n    x0: The initial point for the optimization.\n    jac: The gradient of the objective function.\n    bounds: Parameters bounds for the optimization. Note that these might not be supported\n        by all optimizers.\n\nReturns:\n     The SciPy minimization result object.",
        "api_signature": "__call__(self, fun, x0, jac, bounds)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/aqc/aqc.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "AQC.__init__",
        "api_description": "Args:\n    optimizer: an optimizer to be used in the optimization procedure of the search for\n        the best approximate circuit. By default, the scipy minimizer with the\n        ``L-BFGS-B`` method is used with max iterations set to 1000.\n    seed: a seed value to be used by a random number generator.",
        "api_signature": "__init__(self, optimizer, seed)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/aqc/aqc.py"
    },
    {
        "api_name": "compile_unitary",
        "full_api_name": "AQC.compile_unitary",
        "api_description": "Approximately compiles a circuit represented as a unitary matrix by solving an optimization\nproblem defined by ``approximating_objective`` and using ``approximate_circuit`` as a\ntemplate for the approximate circuit.\n\nArgs:\n    target_matrix: a unitary matrix to approximate.\n    approximate_circuit: a template circuit that will be filled with the parameter values\n        obtained in the optimization procedure.\n    approximating_objective: a definition of the optimization problem.\n    initial_point: initial values of angles/parameters to start optimization from.",
        "api_signature": "compile_unitary(self, target_matrix, approximate_circuit, approximating_objective, initial_point)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/aqc/aqc.py"
    },
    {
        "api_name": "_lower_limit",
        "full_api_name": "_lower_limit",
        "api_description": "Returns lower limit on the number of CNOT units that guarantees exact representation of\na unitary operator by quantum gates.\n\nArgs:\n    num_qubits: number of qubits.\n\nReturns:\n    lower limit on the number of CNOT units.",
        "api_signature": "_lower_limit(num_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/aqc/cnot_structures.py"
    },
    {
        "api_name": "make_cnot_network",
        "full_api_name": "make_cnot_network",
        "api_description": "Generates a network consisting of building blocks each containing a CNOT gate and possibly some\nsingle-qubit ones. This network models a quantum operator in question. Note, each building\nblock has 2 input and outputs corresponding to a pair of qubits. What we actually return here\nis a chain of indices of qubit pairs shared by every building block in a row.\n\nArgs:\n    num_qubits: number of qubits.\n    network_layout: type of network geometry, ``{\"sequ\", \"spin\", \"cart\", \"cyclic_spin\",\n        \"cyclic_line\"}``.\n    connectivity_type: type of inter-qubit connectivity, ``{\"full\", \"line\", \"star\"}``.\n    depth: depth of the CNOT-network, i.e. the number of layers, where each layer consists of\n        a single CNOT-block; default value will be selected, if ``L <= 0``.\n\nReturns:\n    A matrix of size ``(2, N)`` matrix that defines layers in cnot-network, where ``N``\n        is either equal ``L``, or defined by a concrete type of the network.\n\nRaises:\n     ValueError: if unsupported type of CNOT-network layout or number of qubits or combination\n        of parameters are passed.",
        "api_signature": "make_cnot_network(num_qubits, network_layout, connectivity_type, depth)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/aqc/cnot_structures.py"
    },
    {
        "api_name": "_get_connectivity",
        "full_api_name": "_get_connectivity",
        "api_description": "Generates connectivity structure between qubits.\n\nArgs:\n    num_qubits: number of qubits.\n    connectivity: type of connectivity structure, ``{\"full\", \"line\", \"star\"}``.\n\nReturns:\n    dictionary of allowed links between qubits.\n\nRaises:\n     ValueError: if unsupported type of CNOT-network layout is passed.",
        "api_signature": "_get_connectivity(num_qubits, connectivity)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/aqc/cnot_structures.py"
    },
    {
        "api_name": "_sequential_network",
        "full_api_name": "_sequential_network",
        "api_description": "Generates a sequential network.\n\nArgs:\n    num_qubits: number of qubits.\n    links: dictionary of connectivity links.\n    depth: depth of the network (number of layers of building blocks).\n\nReturns:\n    A matrix of ``(2, N)`` that defines layers in qubit network.",
        "api_signature": "_sequential_network(num_qubits, links, depth)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/aqc/cnot_structures.py"
    },
    {
        "api_name": "_spin_network",
        "full_api_name": "_spin_network",
        "api_description": "Generates a spin-like network.\n\nArgs:\n    num_qubits: number of qubits.\n    depth: depth of the network (number of layers of building blocks).\n\nReturns:\n    A matrix of size ``2 x L`` that defines layers in qubit network.",
        "api_signature": "_spin_network(num_qubits, depth)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/aqc/cnot_structures.py"
    },
    {
        "api_name": "_cartan_network",
        "full_api_name": "_cartan_network",
        "api_description": "Cartan decomposition in a recursive way, starting from n = 3.\n\nArgs:\n    num_qubits: number of qubits.\n\nReturns:\n    2xN matrix that defines layers in qubit network, where N is the\n         depth of Cartan decomposition.\n\nRaises:\n    ValueError: if number of qubits is less than 3.",
        "api_signature": "_cartan_network(num_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/aqc/cnot_structures.py"
    },
    {
        "api_name": "_cyclic_spin_network",
        "full_api_name": "_cyclic_spin_network",
        "api_description": "Same as in the spin-like network, but the first and the last qubits are also connected.\n\nArgs:\n    num_qubits: number of qubits.\n    depth: depth of the network (number of layers of building blocks).\n\nReturns:\n    A matrix of size ``2 x L`` that defines layers in qubit network.",
        "api_signature": "_cyclic_spin_network(num_qubits, depth)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/aqc/cnot_structures.py"
    },
    {
        "api_name": "_cyclic_line_network",
        "full_api_name": "_cyclic_line_network",
        "api_description": "Generates a line based CNOT structure.\n\nArgs:\n    num_qubits: number of qubits.\n    depth: depth of the network (number of layers of building blocks).\n\nReturns:\n    A matrix of size ``2 x L`` that defines layers in qubit network.",
        "api_signature": "_cyclic_line_network(num_qubits, depth)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/aqc/cnot_structures.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ApproximateCircuit.__init__",
        "api_description": "Args:\n    num_qubits: number of qubit this circuit will span.\n    name: a name of the circuit.",
        "api_signature": "__init__(self, num_qubits, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/aqc/approximate.py"
    },
    {
        "api_name": "thetas",
        "full_api_name": "ApproximateCircuit.thetas",
        "api_description": "The property is not implemented and raises a ``NotImplementedException`` exception.\n\nReturns:\n    a vector of parameters of this circuit.",
        "api_signature": "thetas(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/aqc/approximate.py"
    },
    {
        "api_name": "build",
        "full_api_name": "ApproximateCircuit.build",
        "api_description": "Constructs this circuit out of the parameters(thetas). Parameter values must be set before\n    constructing the circuit.\n\nArgs:\n    thetas: a vector of parameters to be set in this circuit.",
        "api_signature": "build(self, thetas)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/aqc/approximate.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ApproximatingObjective.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/aqc/approximate.py"
    },
    {
        "api_name": "objective",
        "full_api_name": "ApproximatingObjective.objective",
        "api_description": "Computes a value of the objective function given a vector of parameter values.\n\nArgs:\n    param_values: a vector of parameter values for the optimization problem.\n\nReturns:\n    a float value of the objective function.",
        "api_signature": "objective(self, param_values)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/aqc/approximate.py"
    },
    {
        "api_name": "gradient",
        "full_api_name": "ApproximatingObjective.gradient",
        "api_description": "Computes a gradient with respect to parameters given a vector of parameter values.\n\nArgs:\n    param_values: a vector of parameter values for the optimization problem.\n\nReturns:\n    an array of gradient values.",
        "api_signature": "gradient(self, param_values)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/aqc/approximate.py"
    },
    {
        "api_name": "target_matrix",
        "full_api_name": "ApproximatingObjective.target_matrix",
        "api_description": "Returns:\n    a matrix being approximated",
        "api_signature": "target_matrix(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/aqc/approximate.py"
    },
    {
        "api_name": "target_matrix",
        "full_api_name": "ApproximatingObjective.target_matrix",
        "api_description": "Args:\n    target_matrix: a matrix to approximate in the optimization procedure.",
        "api_signature": "target_matrix(self, target_matrix)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/aqc/approximate.py"
    },
    {
        "api_name": "num_thetas",
        "full_api_name": "ApproximatingObjective.num_thetas",
        "api_description": "Returns:\n    the number of parameters in this optimization problem.",
        "api_signature": "num_thetas(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/aqc/approximate.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CNOTUnitObjective.__init__",
        "api_description": "Args:\n    num_qubits: number of qubits.\n    cnots: a CNOT structure to be used in the optimization procedure.",
        "api_signature": "__init__(self, num_qubits, cnots)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/aqc/cnot_unit_objective.py"
    },
    {
        "api_name": "num_cnots",
        "full_api_name": "CNOTUnitObjective.num_cnots",
        "api_description": "Returns:\n    A number of CNOT units to be used by the approximate circuit.",
        "api_signature": "num_cnots(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/aqc/cnot_unit_objective.py"
    },
    {
        "api_name": "num_thetas",
        "full_api_name": "CNOTUnitObjective.num_thetas",
        "api_description": "Returns:\n    Number of parameters (angles) of rotation gates in this circuit.",
        "api_signature": "num_thetas(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/aqc/cnot_unit_objective.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "DefaultCNOTUnitObjective.__init__",
        "api_description": "Args:\n    num_qubits: number of qubits.\n    cnots: a CNOT structure to be used in the optimization procedure.",
        "api_signature": "__init__(self, num_qubits, cnots)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/aqc/cnot_unit_objective.py"
    },
    {
        "api_name": "objective",
        "full_api_name": "DefaultCNOTUnitObjective.objective",
        "api_description": "",
        "api_signature": "objective(self, param_values)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/aqc/cnot_unit_objective.py"
    },
    {
        "api_name": "gradient",
        "full_api_name": "DefaultCNOTUnitObjective.gradient",
        "api_description": "",
        "api_signature": "gradient(self, param_values)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/aqc/cnot_unit_objective.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CNOTUnitCircuit.__init__",
        "api_description": "Args:\n    num_qubits: the number of qubits in this circuit.\n    cnots: an array of dimensions ``(2, L)`` indicating where the CNOT units will be placed.\n    tol: angle parameter less or equal this (small) value is considered equal zero and\n        corresponding gate is not inserted into the output circuit (because it becomes\n        identity one in this case).\n    name: name of this circuit\n\nRaises:\n    ValueError: if an unsupported parameter is passed.",
        "api_signature": "__init__(self, num_qubits, cnots, tol, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/aqc/cnot_unit_circuit.py"
    },
    {
        "api_name": "thetas",
        "full_api_name": "CNOTUnitCircuit.thetas",
        "api_description": "Returns a vector of rotation angles used by CNOT units in this circuit.\n\nReturns:\n    Parameters of the rotation gates in this circuit.",
        "api_signature": "thetas(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/aqc/cnot_unit_circuit.py"
    },
    {
        "api_name": "build",
        "full_api_name": "CNOTUnitCircuit.build",
        "api_description": "Constructs a Qiskit quantum circuit out of the parameters (angles) of this circuit. If a\n    parameter value is less in absolute value than the specified tolerance then the\n    corresponding rotation gate will be skipped in the circuit.",
        "api_signature": "build(self, thetas)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/aqc/cnot_unit_circuit.py"
    },
    {
        "api_name": "place_unitary",
        "full_api_name": "place_unitary",
        "api_description": "Computes I(j - 1) tensor product U tensor product I(n - j), where U is a unitary matrix\nof size ``(2, 2)``.\n\nArgs:\n    unitary: a unitary matrix of size ``(2, 2)``.\n    n: num qubits.\n    j: position where to place a unitary.\n\nReturns:\n    a unitary of n qubits with u in position j.",
        "api_signature": "place_unitary(unitary, n, j)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/aqc/elementary_operations.py"
    },
    {
        "api_name": "place_cnot",
        "full_api_name": "place_cnot",
        "api_description": "Places a CNOT from j to k.\n\nArgs:\n    n: number of qubits.\n    j: control qubit.\n    k: target qubit.\n\nReturns:\n    a unitary of n qubits with CNOT placed at ``j`` and ``k``.",
        "api_signature": "place_cnot(n, j, k)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/aqc/elementary_operations.py"
    },
    {
        "api_name": "rx_matrix",
        "full_api_name": "rx_matrix",
        "api_description": "Computes an RX rotation by the angle of ``phi``.\n\nArgs:\n    phi: rotation angle.\n\nReturns:\n    an RX rotation matrix.",
        "api_signature": "rx_matrix(phi)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/aqc/elementary_operations.py"
    },
    {
        "api_name": "ry_matrix",
        "full_api_name": "ry_matrix",
        "api_description": "Computes an RY rotation by the angle of ``phi``.\n\nArgs:\n    phi: rotation angle.\n\nReturns:\n    an RY rotation matrix.",
        "api_signature": "ry_matrix(phi)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/aqc/elementary_operations.py"
    },
    {
        "api_name": "rz_matrix",
        "full_api_name": "rz_matrix",
        "api_description": "Computes an RZ rotation by the angle of ``phi``.\n\nArgs:\n    phi: rotation angle.\n\nReturns:\n    an RZ rotation matrix.",
        "api_signature": "rz_matrix(phi)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/aqc/elementary_operations.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "FastCNOTUnitObjective.__init__",
        "api_description": "",
        "api_signature": "__init__(self, num_qubits, cnots)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/aqc/fast_gradient/fast_gradient.py"
    },
    {
        "api_name": "objective",
        "full_api_name": "FastCNOTUnitObjective.objective",
        "api_description": "Computes the objective function and some intermediate data for\nthe subsequent gradient computation.\nSee description of the base class method.",
        "api_signature": "objective(self, param_values)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/aqc/fast_gradient/fast_gradient.py"
    },
    {
        "api_name": "gradient",
        "full_api_name": "FastCNOTUnitObjective.gradient",
        "api_description": "Computes the gradient of objective function.\nSee description of the base class method.",
        "api_signature": "gradient(self, param_values)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/aqc/fast_gradient/fast_gradient.py"
    },
    {
        "api_name": "_init_layers",
        "full_api_name": "FastCNOTUnitObjective._init_layers",
        "api_description": "Initializes C-layers and F-layers by corresponding gate matrices.",
        "api_signature": "_init_layers(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/aqc/fast_gradient/fast_gradient.py"
    },
    {
        "api_name": "_calc_ucf_fuc",
        "full_api_name": "FastCNOTUnitObjective._calc_ucf_fuc",
        "api_description": "Computes matrices ``ucf_mat`` and ``fuc_mat``. Both remain non-finalized.",
        "api_signature": "_calc_ucf_fuc(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/aqc/fast_gradient/fast_gradient.py"
    },
    {
        "api_name": "_calc_objective_function",
        "full_api_name": "FastCNOTUnitObjective._calc_objective_function",
        "api_description": "Computes the value of objective function.",
        "api_signature": "_calc_objective_function(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/aqc/fast_gradient/fast_gradient.py"
    },
    {
        "api_name": "_calc_gradient4d",
        "full_api_name": "FastCNOTUnitObjective._calc_gradient4d",
        "api_description": "Calculates a part gradient contributed by 2-qubit gates.",
        "api_signature": "_calc_gradient4d(self, grad4d)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/aqc/fast_gradient/fast_gradient.py"
    },
    {
        "api_name": "_calc_gradient3n",
        "full_api_name": "FastCNOTUnitObjective._calc_gradient3n",
        "api_description": "Calculates a part gradient contributed by 1-qubit gates.",
        "api_signature": "_calc_gradient3n(self, grad3n)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/aqc/fast_gradient/fast_gradient.py"
    },
    {
        "api_name": "is_permutation",
        "full_api_name": "is_permutation",
        "api_description": "Checks if array is really an index permutation.\n\nArgs:\n    1D-array of integers that supposedly represents a permutation.\n\nReturns:\n    True, if array is really a permutation of indices.",
        "api_signature": "is_permutation(x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/aqc/fast_gradient/fast_grad_utils.py"
    },
    {
        "api_name": "reverse_bits",
        "full_api_name": "reverse_bits",
        "api_description": "Reverses the bit order in a number of ``nbits`` length.\nIf ``x`` is an array, then operation is applied to every entry.\n\nArgs:\n    x: either a single integer or an array of integers.\n    nbits: number of meaningful bits in the number x.\n    enable: apply reverse operation, if enabled, otherwise leave unchanged.\n\nReturns:\n    a number or array of numbers with reversed bits.",
        "api_signature": "reverse_bits(x, nbits, enable)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/aqc/fast_gradient/fast_grad_utils.py"
    },
    {
        "api_name": "swap_bits",
        "full_api_name": "swap_bits",
        "api_description": "Swaps the bits at positions 'a' and 'b' in the number 'num'.\n\nArgs:\n    num: an integer number where bits should be swapped.\n    a: index of the first bit to be swapped.\n    b: index of the second bit to be swapped.\n\nReturns:\n    the number with swapped bits.",
        "api_signature": "swap_bits(num, a, b)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/aqc/fast_gradient/fast_grad_utils.py"
    },
    {
        "api_name": "bit_permutation_1q",
        "full_api_name": "bit_permutation_1q",
        "api_description": "Constructs index permutation that brings a circuit consisting of a single\n1-qubit gate to \"standard form\": ``kron(I(2^n/2), G)``, as we call it. Here n\nis the number of qubits, ``G`` is a 2x2 gate matrix, ``I(2^n/2)`` is the identity\nmatrix of size ``(2^n/2)x(2^n/2)``, and the full size of the circuit matrix is\n``(2^n)x(2^n)``. Circuit matrix in standard form becomes block-diagonal (with\nsub-matrices ``G`` on the main diagonal). Multiplication of such a matrix and\na dense one is much faster than generic dense-dense product. Moreover,\nwe do not need to keep the entire circuit matrix in memory but just 2x2 ``G``\none. This saves a lot of memory when the number of qubits is large.\n\nArgs:\n    n: number of qubits.\n    k: index of qubit where single 1-qubit gate is applied.\n\nReturns:\n    permutation that brings the whole layer to the standard form.",
        "api_signature": "bit_permutation_1q(n, k)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/aqc/fast_gradient/fast_grad_utils.py"
    },
    {
        "api_name": "bit_permutation_2q",
        "full_api_name": "bit_permutation_2q",
        "api_description": "Constructs index permutation that brings a circuit consisting of a single\n2-qubit gate to \"standard form\": ``kron(I(2^n/4), G)``, as we call it. Here ``n``\nis the number of qubits, ``G`` is a 4x4 gate matrix, ``I(2^n/4)`` is the identity\nmatrix of size ``(2^n/4)x(2^n/4)``, and the full size of the circuit matrix is\n``(2^n)x(2^n)``. Circuit matrix in standard form becomes block-diagonal (with\nsub-matrices ``G`` on the main diagonal). Multiplication of such a matrix and\na dense one is much faster than generic dense-dense product. Moreover,\nwe do not need to keep the entire circuit matrix in memory but just 4x4 ``G``\none. This saves a lot of memory when the number of qubits is large.\n\nArgs:\n    n: number of qubits.\n    j: index of control qubit where single 2-qubit gate is applied.\n    k: index of target qubit where single 2-qubit gate is applied.\n\nReturns:\n    permutation that brings the whole layer to the standard form.",
        "api_signature": "bit_permutation_2q(n, j, k)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/aqc/fast_gradient/fast_grad_utils.py"
    },
    {
        "api_name": "inverse_permutation",
        "full_api_name": "inverse_permutation",
        "api_description": "Returns inverse permutation.\n\nArgs:\n    perm: permutation to be reversed.\n\nReturns:\n    inverse permutation.",
        "api_signature": "inverse_permutation(perm)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/aqc/fast_gradient/fast_grad_utils.py"
    },
    {
        "api_name": "make_rx",
        "full_api_name": "make_rx",
        "api_description": "Makes a 2x2 matrix that corresponds to X-rotation gate.\nThis is a fast implementation that does not allocate the output matrix.\n\nArgs:\n    phi: rotation angle.\n    out: placeholder for the result (2x2, complex-valued matrix).\n\nReturns:\n    rotation gate, same object as referenced by \"out\".",
        "api_signature": "make_rx(phi, out)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/aqc/fast_gradient/fast_grad_utils.py"
    },
    {
        "api_name": "make_ry",
        "full_api_name": "make_ry",
        "api_description": "Makes a 2x2 matrix that corresponds to Y-rotation gate.\nThis is a fast implementation that does not allocate the output matrix.\n\nArgs:\n    phi: rotation angle.\n    out: placeholder for the result (2x2, complex-valued matrix).\n\nReturns:\n    rotation gate, same object as referenced by \"out\".",
        "api_signature": "make_ry(phi, out)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/aqc/fast_gradient/fast_grad_utils.py"
    },
    {
        "api_name": "make_rz",
        "full_api_name": "make_rz",
        "api_description": "Makes a 2x2 matrix that corresponds to Z-rotation gate.\nThis is a fast implementation that does not allocate the output matrix.\n\nArgs:\n    phi: rotation angle.\n    out: placeholder for the result (2x2, complex-valued matrix).\n\nReturns:\n    rotation gate, same object as referenced by \"out\".",
        "api_signature": "make_rz(phi, out)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/aqc/fast_gradient/fast_grad_utils.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PMatrix.__init__",
        "api_description": "Initializes the internal structures of this object but does not set\nthe matrix yet.\n\nArgs:\n    num_qubits: number of qubits.",
        "api_signature": "__init__(self, num_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/aqc/fast_gradient/pmatrix.py"
    },
    {
        "api_name": "set_matrix",
        "full_api_name": "PMatrix.set_matrix",
        "api_description": "Copies specified matrix to internal storage. Once the matrix\nis set, the object is ready for use.\n\n**Note**, the matrix will be copied, mind the size issues.\n\nArgs:\n    mat: matrix we want to multiply on the left and on the right by\n         layer matrices.",
        "api_signature": "set_matrix(self, mat)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/aqc/fast_gradient/pmatrix.py"
    },
    {
        "api_name": "_init_index_matrix",
        "full_api_name": "PMatrix._init_index_matrix",
        "api_description": "Fast multiplication can be implemented by picking up a subset of\nentries in a sparse matrix.\n\nArgs:\n    dim: problem dimensionality.\n\nReturns:\n    2d-array of indices for the fast multiplication.",
        "api_signature": "_init_index_matrix(dim)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/aqc/fast_gradient/pmatrix.py"
    },
    {
        "api_name": "mul_right_q1",
        "full_api_name": "PMatrix.mul_right_q1",
        "api_description": "Multiplies ``NxN`` matrix, wrapped by this object, by a 1-qubit layer\nmatrix of the right, where ``N`` is the actual size of matrices involved,\n``N = 2^{num. of qubits}``.\n\nArgs:\n    layer: 1-qubit layer, i.e. the layer with just one non-trivial\n           1-qubit gate and other gates are just identity operators.\n    temp_mat: a temporary NxN matrix used as a workspace.\n    dagger: if true, the right-hand side matrix will be taken as\n            conjugate transposed.",
        "api_signature": "mul_right_q1(self, layer, temp_mat, dagger)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/aqc/fast_gradient/pmatrix.py"
    },
    {
        "api_name": "mul_right_q2",
        "full_api_name": "PMatrix.mul_right_q2",
        "api_description": "Multiplies ``NxN`` matrix, wrapped by this object, by a 2-qubit layer\nmatrix on the right, where ``N`` is the actual size of matrices involved,\n``N = 2^{num. of qubits}``.\n\nArgs:\n    layer: 2-qubit layer, i.e. the layer with just one non-trivial\n           2-qubit gate and other gates are just identity operators.\n    temp_mat: a temporary NxN matrix used as a workspace.\n    dagger: if true, the right-hand side matrix will be taken as\n            conjugate transposed.",
        "api_signature": "mul_right_q2(self, layer, temp_mat, dagger)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/aqc/fast_gradient/pmatrix.py"
    },
    {
        "api_name": "mul_left_q1",
        "full_api_name": "PMatrix.mul_left_q1",
        "api_description": "Multiplies ``NxN`` matrix, wrapped by this object, by a 1-qubit layer\nmatrix of the left, where ``dim`` is the actual size of matrices involved,\n``dim = 2^{num. of qubits}``.\n\nArgs:\n    layer: 1-qubit layer, i.e. the layer with just one non-trivial\n           1-qubit gate and other gates are just identity operators.\n    temp_mat: a temporary NxN matrix used as a workspace.",
        "api_signature": "mul_left_q1(self, layer, temp_mat)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/aqc/fast_gradient/pmatrix.py"
    },
    {
        "api_name": "mul_left_q2",
        "full_api_name": "PMatrix.mul_left_q2",
        "api_description": "Multiplies ``NxN`` matrix, wrapped by this object, by a 2-qubit layer\nmatrix on the left, where ``dim`` is the actual size of matrices involved,\n``dim = 2^{num. of qubits}``.\n\nArgs:\n    layer: 2-qubit layer, i.e. the layer with just one non-trivial\n           2-qubit gate and other gates are just identity operators.\n    temp_mat: a temporary NxN matrix used as a workspace.",
        "api_signature": "mul_left_q2(self, layer, temp_mat)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/aqc/fast_gradient/pmatrix.py"
    },
    {
        "api_name": "product_q1",
        "full_api_name": "PMatrix.product_q1",
        "api_description": "Computes and returns: ``Trace(mat @ C) = Trace(mat @ P^T @ gmat @ P) =\nTrace((P @ mat @ P^T) @ gmat) = Trace(C @ (P @ mat @ P^T)) =\nvec(gmat^T)^T @ vec(P @ mat @ P^T)``, where mat is ``NxN`` matrix wrapped\nby this object, ``C`` is matrix representation of the layer ``L``, and gmat\nis 2x2 matrix of underlying 1-qubit gate.\n\n**Note**: matrix of this class must be finalized beforehand.\n\nArgs:\n    layer: 1-qubit layer.\n    tmp1: temporary, external matrix used as a workspace.\n    tmp2: temporary, external matrix used as a workspace.\n\nReturns:\n    trace of the matrix product.",
        "api_signature": "product_q1(self, layer, tmp1, tmp2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/aqc/fast_gradient/pmatrix.py"
    },
    {
        "api_name": "product_q2",
        "full_api_name": "PMatrix.product_q2",
        "api_description": "Computes and returns: ``Trace(mat @ C) = Trace(mat @ P^T @ gmat @ P) =\nTrace((P @ mat @ P^T) @ gmat) = Trace(C @ (P @ mat @ P^T)) =\nvec(gmat^T)^T @ vec(P @ mat @ P^T)``, where mat is ``NxN`` matrix wrapped\nby this object, ``C`` is matrix representation of the layer ``L``, and gmat\nis 4x4 matrix of underlying 2-qubit gate.\n\n**Note**: matrix of this class must be finalized beforehand.\n\nArgs:\n    layer: 2-qubit layer.\n    tmp1: temporary, external matrix used as a workspace.\n    tmp2: temporary, external matrix used as a workspace.\n\nReturns:\n    trace of the matrix product.",
        "api_signature": "product_q2(self, layer, tmp1, tmp2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/aqc/fast_gradient/pmatrix.py"
    },
    {
        "api_name": "finalize",
        "full_api_name": "PMatrix.finalize",
        "api_description": "Applies the left (row) and right (column) permutations to the matrix.\nat the end of computation process.\n\nArgs:\n    temp_mat: temporary, external matrix.\n\nReturns:\n    finalized matrix with all transformations applied.",
        "api_signature": "finalize(self, temp_mat)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/aqc/fast_gradient/pmatrix.py"
    },
    {
        "api_name": "set_from_matrix",
        "full_api_name": "LayerBase.set_from_matrix",
        "api_description": "Updates this layer from an external gate matrix.\n\nArgs:\n    mat: external gate matrix that initializes this layer's one.",
        "api_signature": "set_from_matrix(self, mat)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/aqc/fast_gradient/layer.py"
    },
    {
        "api_name": "get_attr",
        "full_api_name": "LayerBase.get_attr",
        "api_description": "Returns gate matrix, direct and inverse permutations.\n\nReturns:\n    (1) gate matrix; (2) direct permutation; (3) inverse permutations.",
        "api_signature": "get_attr(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/aqc/fast_gradient/layer.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Layer1Q.__init__",
        "api_description": "Args:\n    num_qubits: number of qubits.\n    k: index of the bit where gate is applied.\n    g2x2: 2x2 matrix that makes up this layer along with identity ones,\n          or None (should be set up later).",
        "api_signature": "__init__(self, num_qubits, k, g2x2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/aqc/fast_gradient/layer.py"
    },
    {
        "api_name": "set_from_matrix",
        "full_api_name": "Layer1Q.set_from_matrix",
        "api_description": "See base class description.",
        "api_signature": "set_from_matrix(self, mat)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/aqc/fast_gradient/layer.py"
    },
    {
        "api_name": "get_attr",
        "full_api_name": "Layer1Q.get_attr",
        "api_description": "See base class description.",
        "api_signature": "get_attr(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/aqc/fast_gradient/layer.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Layer2Q.__init__",
        "api_description": "Args:\n    num_qubits: number of qubits.\n    j: index of the first (control) bit.\n    k: index of the second (target) bit.\n    g4x4: 4x4 matrix that makes up this layer along with identity ones,\n          or None (should be set up later).",
        "api_signature": "__init__(self, num_qubits, j, k, g4x4)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/aqc/fast_gradient/layer.py"
    },
    {
        "api_name": "set_from_matrix",
        "full_api_name": "Layer2Q.set_from_matrix",
        "api_description": "See base class description.",
        "api_signature": "set_from_matrix(self, mat)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/aqc/fast_gradient/layer.py"
    },
    {
        "api_name": "get_attr",
        "full_api_name": "Layer2Q.get_attr",
        "api_description": "See base class description.",
        "api_signature": "get_attr(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/aqc/fast_gradient/layer.py"
    },
    {
        "api_name": "init_layer1q_matrices",
        "full_api_name": "init_layer1q_matrices",
        "api_description": "Initializes 4x4 matrices of 2-qubit gates defined in the paper.\n\nArgs:\n    thetas: depth x 4 matrix of gate parameters for every layer, where\n            \"depth\" is the number of layers.\n    dst: destination array of size depth x 4 x 4 that will receive gate\n         matrices of each layer.\n\nReturns:\n    Returns the \"dst\" array.",
        "api_signature": "init_layer1q_matrices(thetas, dst)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/aqc/fast_gradient/layer.py"
    },
    {
        "api_name": "init_layer1q_deriv_matrices",
        "full_api_name": "init_layer1q_deriv_matrices",
        "api_description": "Initializes 4x4 derivative matrices of 2-qubit gates defined in the paper.\n\nArgs:\n    thetas: depth x 4 matrix of gate parameters for every layer, where\n            \"depth\" is the number of layers.\n    dst: destination array of size depth x 4 x 4 x 4 that will receive gate\n         derivative matrices of each layer; there are 4 parameters per gate,\n         hence, 4 derivative matrices per layer.\n\nReturns:\n    Returns the \"dst\" array.",
        "api_signature": "init_layer1q_deriv_matrices(thetas, dst)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/aqc/fast_gradient/layer.py"
    },
    {
        "api_name": "init_layer2q_matrices",
        "full_api_name": "init_layer2q_matrices",
        "api_description": "Initializes 4x4 matrices of 2-qubit gates defined in the paper.\n\nArgs:\n    thetas: depth x 4 matrix of gate parameters for every layer, where\n            \"depth\" is the number of layers.\n    dst: destination array of size depth x 4 x 4 that will receive gate\n         matrices of each layer.\n\nReturns:\n    Returns the \"dst\" array.",
        "api_signature": "init_layer2q_matrices(thetas, dst)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/aqc/fast_gradient/layer.py"
    },
    {
        "api_name": "init_layer2q_deriv_matrices",
        "full_api_name": "init_layer2q_deriv_matrices",
        "api_description": "Initializes 4 x 4 derivative matrices of 2-qubit gates defined in the paper.\n\nArgs:\n    thetas: depth x 4 matrix of gate parameters for every layer, where\n            \"depth\" is the number of layers.\n    dst: destination array of size depth x 4 x 4 x 4 that will receive gate\n         derivative matrices of each layer; there are 4 parameters per gate,\n         hence, 4 derivative matrices per layer.\n\nReturns:\n    Returns the \"dst\" array.",
        "api_signature": "init_layer2q_deriv_matrices(thetas, dst)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/unitary/aqc/fast_gradient/layer.py"
    },
    {
        "api_name": "two_qubit_local_invariants",
        "full_api_name": "two_qubit_local_invariants",
        "api_description": "Computes the local invariants for a two-qubit unitary.\n\nArgs:\n    U (ndarray): Input two-qubit unitary.\n\nReturns:\n    ndarray: NumPy array of local invariants [g0, g1, g2].\n\nRaises:\n    ValueError: Input not a 2q unitary.\n\nNotes:\n    Y. Makhlin, Quant. Info. Proc. 1, 243-252 (2002).\n    Zhang et al., Phys Rev A. 67, 042313 (2003).",
        "api_signature": "two_qubit_local_invariants(U)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/two_qubit/local_invariance.py"
    },
    {
        "api_name": "local_equivalence",
        "full_api_name": "local_equivalence",
        "api_description": "Computes the equivalent local invariants from the\nWeyl coordinates.\n\nArgs:\n    weyl (ndarray): Weyl coordinates.\n\nReturns:\n    ndarray: Local equivalent coordinates [g0, g1, g3].\n\nNotes:\n    This uses Eq. 30 from Zhang et al, PRA 67, 042313 (2003),\n    but we multiply weyl coordinates by 2 since we are\n    working in the reduced chamber.",
        "api_signature": "local_equivalence(weyl)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/two_qubit/local_invariance.py"
    },
    {
        "api_name": "decompose_two_qubit_product_gate",
        "full_api_name": "decompose_two_qubit_product_gate",
        "api_description": "Decompose :math:`U = U_l \\otimes U_r` where :math:`U \\in SU(4)`,\nand :math:`U_l,~U_r \\in SU(2)`.\n\nArgs:\n    special_unitary_matrix: special unitary matrix to decompose\nRaises:\n    QiskitError: if decomposition isn't possible.",
        "api_signature": "decompose_two_qubit_product_gate(special_unitary_matrix)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/two_qubit/two_qubit_decompose.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "TwoQubitWeylDecomposition.__init__",
        "api_description": "",
        "api_signature": "__init__(self, unitary_matrix, fidelity)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/two_qubit/two_qubit_decompose.py"
    },
    {
        "api_name": "specialize",
        "full_api_name": "TwoQubitWeylDecomposition.specialize",
        "api_description": "Make changes to the decomposition to comply with any specializations.\n\nThis method will always raise a ``NotImplementedError`` because\nthere are no specializations to comply with in the current implementation.",
        "api_signature": "specialize(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/two_qubit/two_qubit_decompose.py"
    },
    {
        "api_name": "circuit",
        "full_api_name": "TwoQubitWeylDecomposition.circuit",
        "api_description": "Returns Weyl decomposition in circuit form.",
        "api_signature": "circuit(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/two_qubit/two_qubit_decompose.py"
    },
    {
        "api_name": "actual_fidelity",
        "full_api_name": "TwoQubitWeylDecomposition.actual_fidelity",
        "api_description": "Calculates the actual fidelity of the decomposed circuit to the input unitary.",
        "api_signature": "actual_fidelity(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/two_qubit/two_qubit_decompose.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "TwoQubitWeylDecomposition.__repr__",
        "api_description": "Represent with enough precision to allow copy-paste debugging of all corner cases",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/two_qubit/two_qubit_decompose.py"
    },
    {
        "api_name": "from_bytes",
        "full_api_name": "TwoQubitWeylDecomposition.from_bytes",
        "api_description": "Decode bytes into :class:`.TwoQubitWeylDecomposition`.",
        "api_signature": "from_bytes(cls, bytes_in)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/two_qubit/two_qubit_decompose.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "TwoQubitWeylDecomposition.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/two_qubit/two_qubit_decompose.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "TwoQubitControlledUDecomposer.__init__",
        "api_description": "Initialize the KAK decomposition.\n\nArgs:\n    rxx_equivalent_gate: Gate that is locally equivalent to an :class:`.RXXGate`:\n    :math:`U \\sim U_d(\\alpha, 0, 0) \\sim \\text{Ctrl-U}` gate.\nRaises:\n    QiskitError: If the gate is not locally equivalent to an :class:`.RXXGate`.",
        "api_signature": "__init__(self, rxx_equivalent_gate)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/two_qubit/two_qubit_decompose.py"
    },
    {
        "api_name": "__call__",
        "full_api_name": "TwoQubitControlledUDecomposer.__call__",
        "api_description": "Returns the Weyl decomposition in circuit form.\n\nNote: atol ist passed to OneQubitEulerDecomposer.",
        "api_signature": "__call__(self, unitary)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/two_qubit/two_qubit_decompose.py"
    },
    {
        "api_name": "_to_rxx_gate",
        "full_api_name": "TwoQubitControlledUDecomposer._to_rxx_gate",
        "api_description": "Takes an angle and returns the circuit equivalent to an RXXGate with the\nRXX equivalent gate as the two-qubit unitary.\n\nArgs:\n    angle: Rotation angle (in this case one of the Weyl parameters a, b, or c)\n\nReturns:\n    Circuit: Circuit equivalent to an RXXGate.\n\nRaises:\n    QiskitError: If the circuit is not equivalent to an RXXGate.",
        "api_signature": "_to_rxx_gate(self, angle)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/two_qubit/two_qubit_decompose.py"
    },
    {
        "api_name": "_weyl_gate",
        "full_api_name": "TwoQubitControlledUDecomposer._weyl_gate",
        "api_description": "Appends U_d(a, b, c) to the circuit.",
        "api_signature": "_weyl_gate(self, circ, atol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/two_qubit/two_qubit_decompose.py"
    },
    {
        "api_name": "Ud",
        "full_api_name": "Ud",
        "api_description": "Generates the array :math:`e^{(i a XX + i b YY + i c ZZ)}`",
        "api_signature": "Ud(a, b, c)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/two_qubit/two_qubit_decompose.py"
    },
    {
        "api_name": "trace_to_fid",
        "full_api_name": "trace_to_fid",
        "api_description": "Average gate fidelity is\n\n.. math::\n\n    \\bar{F} = \\frac{d + |\\mathrm{Tr} (U_\\text{target} \\cdot U^{\\dag})|^2}{d(d+1)}\n\nM. Horodecki, P. Horodecki and R. Horodecki, PRA 60, 1888 (1999)",
        "api_signature": "trace_to_fid(trace)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/two_qubit/two_qubit_decompose.py"
    },
    {
        "api_name": "rz_array",
        "full_api_name": "rz_array",
        "api_description": "Return numpy array for Rz(theta).\n\nRz(theta) = diag(exp(-i*theta/2),exp(i*theta/2))",
        "api_signature": "rz_array(theta)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/two_qubit/two_qubit_decompose.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "TwoQubitBasisDecomposer.__init__",
        "api_description": "",
        "api_signature": "__init__(self, gate, basis_fidelity, euler_basis, pulse_optimize)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/two_qubit/two_qubit_decompose.py"
    },
    {
        "api_name": "num_basis_gates",
        "full_api_name": "TwoQubitBasisDecomposer.num_basis_gates",
        "api_description": "Computes the number of basis gates needed in\na decomposition of input unitary",
        "api_signature": "num_basis_gates(self, unitary)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/two_qubit/two_qubit_decompose.py"
    },
    {
        "api_name": "decomp0",
        "full_api_name": "TwoQubitBasisDecomposer.decomp0",
        "api_description": "Decompose target :math:`\\sim U_d(x, y, z)` with :math:`0` uses of the basis gate.\nResult :math:`U_r` has trace:\n\n.. math::\n\n    \\Big\\vert\\text{Tr}(U_r\\cdot U_\\text{target}^{\\dag})\\Big\\vert =\n    4\\Big\\vert (\\cos(x)\\cos(y)\\cos(z)+ j \\sin(x)\\sin(y)\\sin(z)\\Big\\vert\n\nwhich is optimal for all targets and bases",
        "api_signature": "decomp0(target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/two_qubit/two_qubit_decompose.py"
    },
    {
        "api_name": "decomp1",
        "full_api_name": "TwoQubitBasisDecomposer.decomp1",
        "api_description": "Decompose target :math:`\\sim U_d(x, y, z)` with :math:`1` use of the basis gate\n:math:`\\sim U_d(a, b, c)`.\nResult :math:`U_r` has trace:\n\n.. math::\n\n    \\Big\\vert\\text{Tr}(U_r \\cdot U_\\text{target}^{\\dag})\\Big\\vert =\n    4\\Big\\vert \\cos(x-a)\\cos(y-b)\\cos(z-c) + j \\sin(x-a)\\sin(y-b)\\sin(z-c)\\Big\\vert\n\nwhich is optimal for all targets and bases with ``z==0`` or ``c==0``.",
        "api_signature": "decomp1(self, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/two_qubit/two_qubit_decompose.py"
    },
    {
        "api_name": "decomp2_supercontrolled",
        "full_api_name": "TwoQubitBasisDecomposer.decomp2_supercontrolled",
        "api_description": "Decompose target :math:`\\sim U_d(x, y, z)` with :math:`2` uses of the basis gate.\n\nFor supercontrolled basis :math:`\\sim U_d(\\pi/4, b, 0)`, all b, result :math:`U_r` has trace\n\n.. math::\n\n    \\Big\\vert\\text{Tr}(U_r \\cdot U_\\text{target}^\\dag) \\Big\\vert = 4\\cos(z)\n\nwhich is the optimal approximation for basis of CNOT-class :math:`\\sim U_d(\\pi/4, 0, 0)`\nor DCNOT-class :math:`\\sim U_d(\\pi/4, \\pi/4, 0)` and any target. It may\nbe sub-optimal for :math:`b \\neq 0` (i.e. there exists an exact decomposition for any target\nusing :math:`B \\sim U_d(\\pi/4, \\pi/8, 0)`, but it may not be this decomposition).\nThis is an exact decomposition for supercontrolled basis and target :math:`\\sim U_d(x, y, 0)`.\nNo guarantees for non-supercontrolled basis.",
        "api_signature": "decomp2_supercontrolled(self, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/two_qubit/two_qubit_decompose.py"
    },
    {
        "api_name": "decomp3_supercontrolled",
        "full_api_name": "TwoQubitBasisDecomposer.decomp3_supercontrolled",
        "api_description": "Decompose target with :math:`3` uses of the basis.\nThis is an exact decomposition for supercontrolled basis :math:`\\sim U_d(\\pi/4, b, 0)`, all b,\nand any target. No guarantees for non-supercontrolled basis.",
        "api_signature": "decomp3_supercontrolled(self, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/two_qubit/two_qubit_decompose.py"
    },
    {
        "api_name": "__call__",
        "full_api_name": "TwoQubitBasisDecomposer.__call__",
        "api_description": "Decompose a two-qubit ``unitary`` over fixed basis and :math:`SU(2)` using the best\napproximation given that each basis application has a finite ``basis_fidelity``.\n\nArgs:\n    unitary (Operator or ndarray): :math:`4 \\times 4` unitary to synthesize.\n    basis_fidelity (float or None): Fidelity to be assumed for applications of KAK Gate.\n        If given, overrides ``basis_fidelity`` given at init.\n    approximate (bool): Approximates if basis fidelities are less than 1.0.\n    use_dag (bool): If true a :class:`.DAGCircuit` is returned instead of a\n        :class:`QuantumCircuit` when this class is called.\n    _num_basis_uses (int): force a particular approximation by passing a number in [0, 3].\n\nReturns:\n    QuantumCircuit: Synthesized quantum circuit.\n\nRaises:\n    QiskitError: if ``pulse_optimize`` is True but we don't know how to do it.",
        "api_signature": "__call__(self, unitary, basis_fidelity, approximate, use_dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/two_qubit/two_qubit_decompose.py"
    },
    {
        "api_name": "traces",
        "full_api_name": "TwoQubitBasisDecomposer.traces",
        "api_description": "Give the expected traces :math:`\\Big\\vert\\text{Tr}(U \\cdot U_\\text{target}^{\\dag})\\Big\\vert`\nfor a different number of basis gates.",
        "api_signature": "traces(self, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/two_qubit/two_qubit_decompose.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "_LazyTwoQubitCXDecomposer.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/two_qubit/two_qubit_decompose.py"
    },
    {
        "api_name": "_load",
        "full_api_name": "_LazyTwoQubitCXDecomposer._load",
        "api_description": "",
        "api_signature": "_load(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/two_qubit/two_qubit_decompose.py"
    },
    {
        "api_name": "__call__",
        "full_api_name": "_LazyTwoQubitCXDecomposer.__call__",
        "api_description": "",
        "api_signature": "__call__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/two_qubit/two_qubit_decompose.py"
    },
    {
        "api_name": "traces",
        "full_api_name": "_LazyTwoQubitCXDecomposer.traces",
        "api_description": "",
        "api_signature": "traces(self, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/two_qubit/two_qubit_decompose.py"
    },
    {
        "api_name": "decomp1",
        "full_api_name": "_LazyTwoQubitCXDecomposer.decomp1",
        "api_description": "",
        "api_signature": "decomp1(self, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/two_qubit/two_qubit_decompose.py"
    },
    {
        "api_name": "decomp2_supercontrolled",
        "full_api_name": "_LazyTwoQubitCXDecomposer.decomp2_supercontrolled",
        "api_description": "",
        "api_signature": "decomp2_supercontrolled(self, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/two_qubit/two_qubit_decompose.py"
    },
    {
        "api_name": "decomp3_supercontrolled",
        "full_api_name": "_LazyTwoQubitCXDecomposer.decomp3_supercontrolled",
        "api_description": "",
        "api_signature": "decomp3_supercontrolled(self, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/two_qubit/two_qubit_decompose.py"
    },
    {
        "api_name": "num_basis_gates",
        "full_api_name": "_LazyTwoQubitCXDecomposer.num_basis_gates",
        "api_description": "",
        "api_signature": "num_basis_gates(self, unitary)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/two_qubit/two_qubit_decompose.py"
    },
    {
        "api_name": "transform_to_magic_basis",
        "full_api_name": "transform_to_magic_basis",
        "api_description": "Transform the 4-by-4 matrix ``U`` into the magic basis.\n\nThis method internally uses non-normalized versions of the basis to minimize the floating-point\nerrors that arise during the transformation.\n\nArgs:\n    U (np.ndarray): 4-by-4 matrix to transform.\n    reverse (bool): Whether to do the transformation forwards (``B @ U @ B.conj().T``, the\n    default) or backwards (``B.conj().T @ U @ B``).\n\nReturns:\n    np.ndarray: The transformed 4-by-4 matrix.",
        "api_signature": "transform_to_magic_basis(U, reverse)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/two_qubit/weyl.py"
    },
    {
        "api_name": "weyl_coordinates",
        "full_api_name": "weyl_coordinates",
        "api_description": "Computes the Weyl coordinates for a given two-qubit unitary matrix.\n\nArgs:\n    U (np.ndarray): Input two-qubit unitary.\n\nReturns:\n    np.ndarray: Array of the 3 Weyl coordinates.",
        "api_signature": "weyl_coordinates(U)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/two_qubit/weyl.py"
    },
    {
        "api_name": "get_augmented_coordinate",
        "full_api_name": "get_augmented_coordinate",
        "api_description": "Assembles a coordinate in the system used by `xx_region_polytope`.",
        "api_signature": "get_augmented_coordinate(target_coordinate, strengths)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/two_qubit/xx_decompose/paths.py"
    },
    {
        "api_name": "decomposition_hop",
        "full_api_name": "decomposition_hop",
        "api_description": "Given a `target_coordinate` and a list of interaction `strengths`, produces a new canonical\ncoordinate which is one step back along `strengths`.\n\n`target_coordinate` is taken to be in positive canonical coordinates, and the entries of\nstrengths are taken to be [0, pi], so that (sj / 2, 0, 0) is a positive canonical coordinate.",
        "api_signature": "decomposition_hop(target_coordinate, strengths)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/two_qubit/xx_decompose/paths.py"
    },
    {
        "api_name": "_average_infidelity",
        "full_api_name": "_average_infidelity",
        "api_description": "Computes the infidelity distance between two points p, q expressed in positive canonical\ncoordinates.",
        "api_signature": "_average_infidelity(p, q)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/two_qubit/xx_decompose/decomposer.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "XXDecomposer.__init__",
        "api_description": "",
        "api_signature": "__init__(self, basis_fidelity, euler_basis, embodiments, backup_optimizer)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/two_qubit/xx_decompose/decomposer.py"
    },
    {
        "api_name": "_default_embodiment",
        "full_api_name": "XXDecomposer._default_embodiment",
        "api_description": "If the user does not provide a custom implementation of XX(strength), then this routine\ndefines a default implementation using RZX.",
        "api_signature": "_default_embodiment(strength)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/two_qubit/xx_decompose/decomposer.py"
    },
    {
        "api_name": "_check_embodiments",
        "full_api_name": "XXDecomposer._check_embodiments",
        "api_description": "Checks that `self.embodiments` is populated with legal circuit embodiments: the key-value\npair (angle, circuit) satisfies Operator(circuit) approx RXX(angle).to_matrix().",
        "api_signature": "_check_embodiments(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/two_qubit/xx_decompose/decomposer.py"
    },
    {
        "api_name": "_best_decomposition",
        "full_api_name": "XXDecomposer._best_decomposition",
        "api_description": "Finds the cheapest sequence of `available_strengths` which supports the best approximation\nto `canonical_coordinate`. Returns a dictionary with keys \"cost\", \"point\", and \"operations\".\n\nNOTE: `canonical_coordinate` is a positive canonical coordinate. `strengths` is a dictionary\n      mapping the available strengths to their (infidelity) costs, with the strengths\n      themselves normalized so that pi/2 represents CX = RZX(pi/2).",
        "api_signature": "_best_decomposition(canonical_coordinate, available_strengths)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/two_qubit/xx_decompose/decomposer.py"
    },
    {
        "api_name": "num_basis_gates",
        "full_api_name": "XXDecomposer.num_basis_gates",
        "api_description": "Counts the number of gates that would be emitted during re-synthesis.\n\n.. note::\n    This method is used by :class:`.ConsolidateBlocks`.",
        "api_signature": "num_basis_gates(self, unitary)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/two_qubit/xx_decompose/decomposer.py"
    },
    {
        "api_name": "_strength_to_infidelity",
        "full_api_name": "XXDecomposer._strength_to_infidelity",
        "api_description": "Converts a dictionary mapping XX strengths to fidelities to a dictionary mapping XX\nstrengths to infidelities. Also supports one of the other formats Qiskit uses: if only a\nlone float is supplied, it extends it from CX over CX/2 and CX/3 by linear decay.",
        "api_signature": "_strength_to_infidelity(basis_fidelity, approximate)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/two_qubit/xx_decompose/decomposer.py"
    },
    {
        "api_name": "__call__",
        "full_api_name": "XXDecomposer.__call__",
        "api_description": "Fashions a circuit which (perhaps approximately) models the special unitary operation\n``unitary``, using the circuit templates supplied at initialization as ``embodiments``.  The\nroutine uses ``basis_fidelity`` to select the optimal circuit template, including when\nperforming exact synthesis; the contents of ``basis_fidelity`` is a dictionary mapping\ninteraction strengths (scaled so that :math:`CX = RZX(\\pi/2)` corresponds to :math:`\\pi/2`)\nto circuit fidelities.\n\nArgs:\n    unitary (Operator or ndarray): :math:`4 \\times 4` unitary to synthesize.\n    basis_fidelity (dict or float): Fidelity of basis gates. Can be either (1) a dictionary\n        mapping ``XX`` angle values to fidelity at that angle; or (2) a single float ``f``,\n        interpreted as ``{pi: f, pi/2: f/2, pi/3: f/3}``.\n        If given, overrides the basis_fidelity given at init.\n    approximate (bool): Approximates if basis fidelities are less than 1.0 .\n    use_dag (bool): If true a :class:`.DAGCircuit` is returned instead of a\n        :class:`QuantumCircuit` when this class is called.\n\nReturns:\n    QuantumCircuit: Synthesized circuit.",
        "api_signature": "__call__(self, unitary, basis_fidelity, approximate, use_dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/two_qubit/xx_decompose/decomposer.py"
    },
    {
        "api_name": "safe_arccos",
        "full_api_name": "safe_arccos",
        "api_description": "Computes arccos(n/d) with different (better?) numerical stability.",
        "api_signature": "safe_arccos(numerator, denominator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/two_qubit/xx_decompose/utilities.py"
    },
    {
        "api_name": "decompose_xxyy_into_xxyy_xx",
        "full_api_name": "decompose_xxyy_into_xxyy_xx",
        "api_description": "Consumes a target canonical interaction CAN(a_target, b_target) and source interactions\nCAN(a1, b1), CAN(a2), then manufactures a circuit identity of the form\n\nCAN(a_target, b_target) = (Zr, Zs) CAN(a_source, b_source) (Zu, Zv) CAN(interaction) (Zx, Zy).\n\nReturns the 6-tuple (r, s, u, v, x, y).",
        "api_signature": "decompose_xxyy_into_xxyy_xx(a_target, b_target, a_source, b_source, interaction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/two_qubit/xx_decompose/circuits.py"
    },
    {
        "api_name": "xx_circuit_step",
        "full_api_name": "xx_circuit_step",
        "api_description": "Builds a single step in an XX-based circuit.\n\n`source` and `target` are positive canonical coordinates; `strength` is the interaction strength\nat this step in the circuit as a canonical coordinate (so that CX = RZX(pi/2) corresponds to\npi/4); and `embodiment` is a Qiskit circuit which enacts the canonical gate of the prescribed\ninteraction `strength`.",
        "api_signature": "xx_circuit_step(source, strength, target, embodiment)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/two_qubit/xx_decompose/circuits.py"
    },
    {
        "api_name": "canonical_xx_circuit",
        "full_api_name": "canonical_xx_circuit",
        "api_description": "Assembles a Qiskit circuit from a specified `strength_sequence` of XX-type interactions which\nemulates the canonical gate at canonical coordinate `target`.  The circuits supplied by\n`basis_embodiments` are used to instantiate the individual XX actions.\n\nNOTE: The elements of `strength_sequence` are expected to be normalized so that np.pi/2\n    corresponds to RZX(np.pi/2) = CX; `target` is taken to be a positive canonical coordinate;\n    and `basis_embodiments` maps `strength_sequence` elements to circuits which instantiate\n    these gates.",
        "api_signature": "canonical_xx_circuit(target, strength_sequence, basis_embodiments)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/two_qubit/xx_decompose/circuits.py"
    },
    {
        "api_name": "apply_reflection",
        "full_api_name": "apply_reflection",
        "api_description": "Given a reflection type and a canonical coordinate, applies the reflection\nand describes a circuit which enacts the reflection + a global phase shift.",
        "api_signature": "apply_reflection(reflection_name, coordinate)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/two_qubit/xx_decompose/weyl.py"
    },
    {
        "api_name": "apply_shift",
        "full_api_name": "apply_shift",
        "api_description": "Given a shift type and a canonical coordinate, applies the shift and\ndescribes a circuit which enacts the shift + a global phase shift.",
        "api_signature": "apply_shift(shift_name, coordinate)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/two_qubit/xx_decompose/weyl.py"
    },
    {
        "api_name": "canonical_rotation_circuit",
        "full_api_name": "canonical_rotation_circuit",
        "api_description": "Given a pair of distinct indices 0 \u2264 (first_index, second_index) \u2264 2,\nproduces a two-qubit circuit which rotates a canonical gate\n\n    a0 XX + a1 YY + a2 ZZ\n\ninto\n\n    a[first] XX + a[second] YY + a[other] ZZ .",
        "api_signature": "canonical_rotation_circuit(first_index, second_index)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/two_qubit/xx_decompose/weyl.py"
    },
    {
        "api_name": "polytope_has_element",
        "full_api_name": "polytope_has_element",
        "api_description": "Tests whether `polytope` contains `point.",
        "api_signature": "polytope_has_element(polytope, point)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/two_qubit/xx_decompose/polytopes.py"
    },
    {
        "api_name": "manual_get_vertex",
        "full_api_name": "manual_get_vertex",
        "api_description": "Returns a single random vertex from `polytope`.",
        "api_signature": "manual_get_vertex(polytope, seed)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/two_qubit/xx_decompose/polytopes.py"
    },
    {
        "api_name": "from_strengths",
        "full_api_name": "XXPolytope.from_strengths",
        "api_description": "Constructs an XXPolytope from a sequence of strengths.",
        "api_signature": "from_strengths(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/two_qubit/xx_decompose/polytopes.py"
    },
    {
        "api_name": "add_strength",
        "full_api_name": "XXPolytope.add_strength",
        "api_description": "Returns a new XXPolytope with one new XX interaction appended.",
        "api_signature": "add_strength(self, new_strength)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/two_qubit/xx_decompose/polytopes.py"
    },
    {
        "api_name": "_offsets",
        "full_api_name": "XXPolytope._offsets",
        "api_description": "Returns b with A*x + b \u2265 0 iff x belongs to the XXPolytope.",
        "api_signature": "_offsets(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/two_qubit/xx_decompose/polytopes.py"
    },
    {
        "api_name": "member",
        "full_api_name": "XXPolytope.member",
        "api_description": "Returns True when `point` is a member of `self`.",
        "api_signature": "member(self, point)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/two_qubit/xx_decompose/polytopes.py"
    },
    {
        "api_name": "nearest",
        "full_api_name": "XXPolytope.nearest",
        "api_description": "Finds the nearest point (in Euclidean or infidelity distance) to `self`.",
        "api_signature": "nearest(self, point)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/two_qubit/xx_decompose/polytopes.py"
    },
    {
        "api_name": "synthesize",
        "full_api_name": "EvolutionSynthesis.synthesize",
        "api_description": "Synthesize an ``qiskit.circuit.library.PauliEvolutionGate``.\n\nArgs:\n    evolution (PauliEvolutionGate): The evolution gate to synthesize.\n\nReturns:\n    QuantumCircuit: A circuit implementing the evolution.",
        "api_signature": "synthesize(self, evolution)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/evolution/evolution_synthesis.py"
    },
    {
        "api_name": "settings",
        "full_api_name": "EvolutionSynthesis.settings",
        "api_description": "Return the settings in a dictionary, which can be used to reconstruct the object.\n\nReturns:\n    A dictionary containing the settings of this product formula.\n\nRaises:\n    NotImplementedError: The interface does not implement this method.",
        "api_signature": "settings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/evolution/evolution_synthesis.py"
    },
    {
        "api_name": "synthesize",
        "full_api_name": "MatrixExponential.synthesize",
        "api_description": "",
        "api_signature": "synthesize(self, evolution)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/evolution/matrix_synthesis.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QDrift.__init__",
        "api_description": "Args:\n    reps: The number of times to repeat the Trotterization circuit.\n    insert_barriers: Whether to insert barriers between the atomic evolutions.\n    cx_structure: How to arrange the CX gates for the Pauli evolutions, can be\n        ``\"chain\"``, where next neighbor connections are used, or ``\"fountain\"``, where all\n        qubits are connected to one. This only takes effect when\n        ``atomic_evolution is None``.\n    atomic_evolution: A function to apply the evolution of a single :class:`.Pauli`, or\n        :class:`.SparsePauliOp` of only commuting terms, to a circuit. The function takes in\n        three arguments: the circuit to append the evolution to, the Pauli operator to\n        evolve, and the evolution time. By default, a single Pauli evolution is decomposed\n        into a chain of ``CX`` gates and a single ``RZ`` gate.\n        Alternatively, the function can also take Pauli operator and evolution time as\n        inputs and returns the circuit that will be appended to the overall circuit being\n        built.\n    seed: An optional seed for reproducibility of the random sampling process.\n    wrap: Whether to wrap the atomic evolutions into custom gate objects. This only takes\n        effect when ``atomic_evolution is None``.",
        "api_signature": "__init__(self, reps, insert_barriers, cx_structure, atomic_evolution, seed, wrap)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/evolution/qdrift.py"
    },
    {
        "api_name": "synthesize",
        "full_api_name": "QDrift.synthesize",
        "api_description": "",
        "api_signature": "synthesize(self, evolution)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/evolution/qdrift.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ProductFormula.__init__",
        "api_description": "Args:\n    order: The order of the product formula.\n    reps: The number of time steps.\n    insert_barriers: Whether to insert barriers between the atomic evolutions.\n    cx_structure: How to arrange the CX gates for the Pauli evolutions, can be\n        ``\"chain\"``, where next neighbor connections are used, or ``\"fountain\"``,\n        where all qubits are connected to one. This only takes effect when\n        ``atomic_evolution is None``.\n    atomic_evolution: A function to apply the evolution of a single :class:`.Pauli`, or\n        :class:`.SparsePauliOp` of only commuting terms, to a circuit. The function takes in\n        three arguments: the circuit to append the evolution to, the Pauli operator to\n        evolve, and the evolution time. By default, a single Pauli evolution is decomposed\n        into a chain of ``CX`` gates and a single ``RZ`` gate.\n        Alternatively, the function can also take Pauli operator and evolution time as\n        inputs and returns the circuit that will be appended to the overall circuit being\n        built.\n    wrap: Whether to wrap the atomic evolutions into custom gate objects. This only takes\n        effect when ``atomic_evolution is None``.",
        "api_signature": "__init__(self, order, reps, insert_barriers, cx_structure, atomic_evolution, wrap)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/evolution/product_formula.py"
    },
    {
        "api_name": "wrap_atomic_evolution",
        "full_api_name": "ProductFormula.wrap_atomic_evolution",
        "api_description": "",
        "api_signature": "wrap_atomic_evolution(output, operator, time)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/evolution/product_formula.py"
    },
    {
        "api_name": "settings",
        "full_api_name": "ProductFormula.settings",
        "api_description": "Return the settings in a dictionary, which can be used to reconstruct the object.\n\nReturns:\n    A dictionary containing the settings of this product formula.\n\nRaises:\n    NotImplementedError: If a custom atomic evolution is set, which cannot be serialized.",
        "api_signature": "settings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/evolution/product_formula.py"
    },
    {
        "api_name": "evolve_pauli",
        "full_api_name": "evolve_pauli",
        "api_description": "Construct a circuit implementing the time evolution of a single Pauli string.\n\nFor a Pauli string :math:`P = \\{I, X, Y, Z\\}^{\\otimes n}` on :math:`n` qubits and an\nevolution time :math:`t`, the returned circuit implements the unitary operation\n\n.. math::\n\n    U(t) = e^{-itP}.\n\nSince only a single Pauli string is evolved the circuit decomposition is exact.\n\nArgs:\n    output: The circuit object to which to append the evolved Pauli.\n    pauli: The Pauli to evolve.\n    time: The evolution time.\n    cx_structure: Determine the structure of CX gates, can be either ``\"chain\"`` for\n        next-neighbor connections or ``\"fountain\"`` to connect directly to the top qubit.\n    wrap: Whether to wrap the single Pauli evolutions into custom gate objects.\n    label: A label for the gate.",
        "api_signature": "evolve_pauli(output, pauli, time, cx_structure, wrap, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/evolution/product_formula.py"
    },
    {
        "api_name": "_single_qubit_evolution",
        "full_api_name": "_single_qubit_evolution",
        "api_description": "",
        "api_signature": "_single_qubit_evolution(output, pauli, time, wrap)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/evolution/product_formula.py"
    },
    {
        "api_name": "_two_qubit_evolution",
        "full_api_name": "_two_qubit_evolution",
        "api_description": "",
        "api_signature": "_two_qubit_evolution(output, pauli, time, cx_structure, wrap)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/evolution/product_formula.py"
    },
    {
        "api_name": "_multi_qubit_evolution",
        "full_api_name": "_multi_qubit_evolution",
        "api_description": "",
        "api_signature": "_multi_qubit_evolution(output, pauli, time, cx_structure, wrap)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/evolution/product_formula.py"
    },
    {
        "api_name": "diagonalizing_clifford",
        "full_api_name": "diagonalizing_clifford",
        "api_description": "Get the clifford circuit to diagonalize the Pauli operator.\n\nArgs:\n    pauli: The Pauli to diagonalize.\n\nReturns:\n    A circuit to diagonalize.",
        "api_signature": "diagonalizing_clifford(pauli)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/evolution/product_formula.py"
    },
    {
        "api_name": "cnot_chain",
        "full_api_name": "cnot_chain",
        "api_description": "CX chain.\n\nFor example, for the Pauli with the label 'XYZIX'.\n\n.. parsed-literal::\n\n                   \u250c\u2500\u2500\u2500\u2510\n    q_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\n                   \u2514\u2500\u252c\u2500\u2518\n    q_1: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\n              \u250c\u2500\u2500\u2500\u2510  \u2502\n    q_2: \u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u25a0\u2500\u2500\n         \u250c\u2500\u2500\u2500\u2510\u2514\u2500\u252c\u2500\u2518\n    q_3: \u2524 X \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n         \u2514\u2500\u252c\u2500\u2518\n    q_4: \u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nArgs:\n    pauli: The Pauli for which to construct the CX chain.\n\nReturns:\n    A circuit implementing the CX chain.",
        "api_signature": "cnot_chain(pauli)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/evolution/product_formula.py"
    },
    {
        "api_name": "cnot_fountain",
        "full_api_name": "cnot_fountain",
        "api_description": "CX chain in the fountain shape.\n\nFor example, for the Pauli with the label 'XYZIX'.\n\n.. parsed-literal::\n\n         \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\n    q_0: \u2524 X \u251c\u2524 X \u251c\u2524 X \u251c\n         \u2514\u2500\u252c\u2500\u2518\u2514\u2500\u252c\u2500\u2518\u2514\u2500\u252c\u2500\u2518\n    q_1: \u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\n           \u2502    \u2502    \u2502\n    q_2: \u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\n                \u2502    \u2502\n    q_3: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\n                     \u2502\n    q_4: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\n\nArgs:\n    pauli: The Pauli for which to construct the CX chain.\n\nReturns:\n    A circuit implementing the CX chain.",
        "api_signature": "cnot_fountain(pauli)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/evolution/product_formula.py"
    },
    {
        "api_name": "_default_atomic_evolution",
        "full_api_name": "_default_atomic_evolution",
        "api_description": "",
        "api_signature": "_default_atomic_evolution(output, operator, time, cx_structure, wrap)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/evolution/product_formula.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SuzukiTrotter.__init__",
        "api_description": "Args:\n    order: The order of the product formula.\n    reps: The number of time steps.\n    insert_barriers: Whether to insert barriers between the atomic evolutions.\n    cx_structure: How to arrange the CX gates for the Pauli evolutions, can be ``\"chain\"``,\n        where next neighbor connections are used, or ``\"fountain\"``, where all qubits are\n        connected to one. This only takes effect when ``atomic_evolution is None``.\n    atomic_evolution: A function to apply the evolution of a single :class:`.Pauli`, or\n        :class:`.SparsePauliOp` of only commuting terms, to a circuit. The function takes in\n        three arguments: the circuit to append the evolution to, the Pauli operator to\n        evolve, and the evolution time. By default, a single Pauli evolution is decomposed\n        into a chain of ``CX`` gates and a single ``RZ`` gate.\n        Alternatively, the function can also take Pauli operator and evolution time as\n        inputs and returns the circuit that will be appended to the overall circuit being\n        built.\n    wrap: Whether to wrap the atomic evolutions into custom gate objects. This only takes\n        effect when ``atomic_evolution is None``.\nRaises:\n    ValueError: If order is not even",
        "api_signature": "__init__(self, order, reps, insert_barriers, cx_structure, atomic_evolution, wrap)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/evolution/suzuki_trotter.py"
    },
    {
        "api_name": "synthesize",
        "full_api_name": "SuzukiTrotter.synthesize",
        "api_description": "",
        "api_signature": "synthesize(self, evolution)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/evolution/suzuki_trotter.py"
    },
    {
        "api_name": "_recurse",
        "full_api_name": "SuzukiTrotter._recurse",
        "api_description": "",
        "api_signature": "_recurse(order, time, pauli_list)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/evolution/suzuki_trotter.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "LieTrotter.__init__",
        "api_description": "Args:\n    reps: The number of time steps.\n    insert_barriers: Whether to insert barriers between the atomic evolutions.\n    cx_structure: How to arrange the CX gates for the Pauli evolutions, can be\n        ``\"chain\"``, where next neighbor connections are used, or ``\"fountain\"``,\n        where all qubits are connected to one. This only takes effect when\n        ``atomic_evolution is None``.\n    atomic_evolution: A function to apply the evolution of a single :class:`.Pauli`, or\n        :class:`.SparsePauliOp` of only commuting terms, to a circuit. The function takes in\n        three arguments: the circuit to append the evolution to, the Pauli operator to\n        evolve, and the evolution time. By default, a single Pauli evolution is decomposed\n        into a chain of ``CX`` gates and a single ``RZ`` gate.\n        Alternatively, the function can also take Pauli operator and evolution time as\n        inputs and returns the circuit that will be appended to the overall circuit being\n        built.\n    wrap: Whether to wrap the atomic evolutions into custom gate objects. This only takes\n        effect when ``atomic_evolution is None``.",
        "api_signature": "__init__(self, reps, insert_barriers, cx_structure, atomic_evolution, wrap)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/evolution/lie_trotter.py"
    },
    {
        "api_name": "synthesize",
        "full_api_name": "LieTrotter.synthesize",
        "api_description": "",
        "api_signature": "synthesize(self, evolution)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/evolution/lie_trotter.py"
    },
    {
        "api_name": "settings",
        "full_api_name": "LieTrotter.settings",
        "api_description": "Return the settings in a dictionary, which can be used to reconstruct the object.\n\nReturns:\n    A dictionary containing the settings of this product formula.\n\nRaises:\n    NotImplementedError: If a custom atomic evolution is set, which cannot be serialized.",
        "api_signature": "settings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/evolution/lie_trotter.py"
    },
    {
        "api_name": "_odd_pattern1",
        "full_api_name": "_odd_pattern1",
        "api_description": "A pattern denoted by Pj in [1] for odd number of qubits:\n[n-2, n-4, n-4, ..., 3, 3, 1, 1, 0, 0, 2, 2, ..., n-3, n-3]",
        "api_signature": "_odd_pattern1(n)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/linear_phase/cz_depth_lnn.py"
    },
    {
        "api_name": "_odd_pattern2",
        "full_api_name": "_odd_pattern2",
        "api_description": "A pattern denoted by Pk in [1] for odd number of qubits:\n[2, 2, 4, 4, ..., n-1, n-1, n-2, n-2, n-4, n-4, ..., 5, 5, 3, 3, 1]",
        "api_signature": "_odd_pattern2(n)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/linear_phase/cz_depth_lnn.py"
    },
    {
        "api_name": "_even_pattern1",
        "full_api_name": "_even_pattern1",
        "api_description": "A pattern denoted by Pj in [1] for even number of qubits:\n[n-1, n-3, n-3, n-5, n-5, ..., 1, 1, 0, 0, 2, 2, ..., n-4, n-4, n-2]",
        "api_signature": "_even_pattern1(n)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/linear_phase/cz_depth_lnn.py"
    },
    {
        "api_name": "_even_pattern2",
        "full_api_name": "_even_pattern2",
        "api_description": "A pattern denoted by Pk in [1] for even number of qubits:\n[2, 2, 4, 4, ..., n-2, n-2, n-1, n-1, ..., 3, 3, 1, 1]",
        "api_signature": "_even_pattern2(n)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/linear_phase/cz_depth_lnn.py"
    },
    {
        "api_name": "_create_patterns",
        "full_api_name": "_create_patterns",
        "api_description": "Creating the patterns for the phase layers.",
        "api_signature": "_create_patterns(n)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/linear_phase/cz_depth_lnn.py"
    },
    {
        "api_name": "synth_cz_depth_line_mr",
        "full_api_name": "synth_cz_depth_line_mr",
        "api_description": "Synthesis of a CZ circuit for linear nearest neighbor (LNN) connectivity,\nbased on Maslov and Roetteler.\n\nNote that this method *reverts* the order of qubits in the circuit,\nand returns a circuit containing :class:`.CXGate`\\s and phase gates\n(:class:`.SGate`, :class:`.SdgGate` or :class:`.ZGate`).\n\nArgs:\n    mat: an upper-diagonal matrix representing the CZ circuit.\n        ``mat[i][j]=1 for i<j`` represents a ``cz(i,j)`` gate\n\nReturns:\n    A circuit implementation of the CZ circuit of depth :math:`2n+2` for LNN\n    connectivity.\n\nReferences:\n    1. Dmitri Maslov, Martin Roetteler,\n       *Shorter stabilizer circuits via Bruhat decomposition and quantum circuit transformations*,\n       `arXiv:1705.09176 <https://arxiv.org/abs/1705.09176>`_.",
        "api_signature": "synth_cz_depth_line_mr(mat)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/linear_phase/cz_depth_lnn.py"
    },
    {
        "api_name": "synth_cnot_phase_aam",
        "full_api_name": "synth_cnot_phase_aam",
        "api_description": "This function is an implementation of the `GraySynth` algorithm of\nAmy, Azimadeh and Mosca.\n\nGraySynth is a heuristic algorithm from [1] for synthesizing small parity networks.\nIt is inspired by Gray codes. Given a set of binary strings :math:`S`\n(called ``cnots`` bellow), the algorithm synthesizes a parity network for :math:`S` by\nrepeatedly choosing an index :math:`i` to expand and then effectively recursing on\nthe co-factors :math:`S_0` and :math:`S_1`, consisting of the strings :math:`y \\in S`,\nwith :math:`y_i = 0` or :math:`1` respectively. As a subset :math:`S` is recursively expanded,\n``cx`` gates are applied so that a designated target bit contains the\n(partial) parity :math:`\\chi_y(x)` where :math:`y_i = 1` if and only if :math:`y'_i = 1` for all\n:math:`y' \\in S`. If :math:`S` contains a single element :math:`\\{y'\\}`, then :math:`y = y'`,\nand the target bit contains the value :math:`\\chi_{y'}(x)` as desired.\n\nNotably, rather than uncomputing this sequence of ``cx`` (CNOT) gates when a subset :math:`S`\nis finished being synthesized, the algorithm maintains the invariant\nthat the remaining parities to be computed are expressed over the current state\nof bits. This allows the algorithm to avoid the 'backtracking' inherent in\nuncomputing-based methods.\n\nThe algorithm is described in detail in section 4 of [1].\n\nArgs:\n    cnots: A matrix whose columns are the parities to be synthesized\n        e.g.::\n\n            [[0, 1, 1, 1, 1, 1],\n             [1, 0, 0, 1, 1, 1],\n             [1, 0, 0, 1, 0, 0],\n             [0, 0, 1, 0, 1, 0]]\n\n        corresponds to::\n\n             x1^x2 + x0 + x0^x3 + x0^x1^x2 + x0^x1^x3 + x0^x1\n\n    angles: A list containing all the phase-shift gates which are\n        to be applied, in the same order as in ``cnots``. A number is\n        interpreted as the angle of :math:`p(angle)`, otherwise the elements\n        have to be ``'t'``, ``'tdg'``, ``'s'``, ``'sdg'`` or ``'z'``.\n\n    section_size: The size of every section in the Patel\u2013Markov\u2013Hayes algorithm.\n        ``section_size`` must be a factor of the number of qubits.\n\nReturns:\n    The decomposed quantum circuit.\n\nRaises:\n    QiskitError: when dimensions of ``cnots`` and ``angles`` don't align.\n\nReferences:\n    1. Matthew Amy, Parsiad Azimzadeh, and Michele Mosca.\n       *On the controlled-NOT complexity of controlled-NOT\u2013phase circuits.*,\n       Quantum Science and Technology 4.1 (2018): 015002.\n       `arXiv:1712.01859 <https://arxiv.org/abs/1712.01859>`_",
        "api_signature": "synth_cnot_phase_aam(cnots, angles, section_size)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/linear_phase/cnot_phase_synth.py"
    },
    {
        "api_name": "_remove_duplicates",
        "full_api_name": "_remove_duplicates",
        "api_description": "Remove duplicates in list\n\nArgs:\n    lists (list): a list which may contain duplicate elements.\n\nReturns:\n    list: a list which contains only unique elements.",
        "api_signature": "_remove_duplicates(lists)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/linear_phase/cnot_phase_synth.py"
    },
    {
        "api_name": "_initialize_phase_schedule",
        "full_api_name": "_initialize_phase_schedule",
        "api_description": "Given a CZ layer (represented as an n*n CZ matrix Mz)\nReturn a schedule of phase gates implementing Mz in a SWAP-only netwrok\n(c.f. Alg 1, [2])",
        "api_signature": "_initialize_phase_schedule(mat_z)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/linear_phase/cx_cz_depth_lnn.py"
    },
    {
        "api_name": "_shuffle",
        "full_api_name": "_shuffle",
        "api_description": "Args:\n    labels : a list of indices\n    odd : a boolean indicating whether this layer is odd or even,\nShuffle the indices in labels by swapping adjacent elements\n(c.f. Fig.2, [2])",
        "api_signature": "_shuffle(labels, odd)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/linear_phase/cx_cz_depth_lnn.py"
    },
    {
        "api_name": "_make_seq",
        "full_api_name": "_make_seq",
        "api_description": "Given the width of the circuit n,\nReturn the labels of the boxes in order from left to right, top to bottom\n(c.f. Fig.2, [2])",
        "api_signature": "_make_seq(n)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/linear_phase/cx_cz_depth_lnn.py"
    },
    {
        "api_name": "_swap_plus",
        "full_api_name": "_swap_plus",
        "api_description": "Given CX instructions (c.f. Thm 7.1, [1]) and the labels of all boxes,\nReturn a list of labels of the boxes that is SWAP+ in descending order\n    * Assumes the instruction gives gates in the order from top to bottom,\n      from left to right\n    * SWAP+ is defined in section 3.A. of [2]. Note the northwest\n      diagonalization procedure of [1] consists exactly n layers of boxes,\n      each being either a SWAP or a SWAP+. That is, each northwest\n      diagonalization circuit can be uniquely represented by which of its\n      n(n-1)/2 boxes are SWAP+ and which are SWAP.",
        "api_signature": "_swap_plus(instructions, seq)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/linear_phase/cx_cz_depth_lnn.py"
    },
    {
        "api_name": "_update_phase_schedule",
        "full_api_name": "_update_phase_schedule",
        "api_description": "Given phase_schedule initialized to induce a CZ circuit in SWAP-only network and list of SWAP+ boxes\nUpdate phase_schedule for each SWAP+ according to Algorithm 2, [2]",
        "api_signature": "_update_phase_schedule(n, phase_schedule, swap_plus)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/linear_phase/cx_cz_depth_lnn.py"
    },
    {
        "api_name": "_apply_phase_to_nw_circuit",
        "full_api_name": "_apply_phase_to_nw_circuit",
        "api_description": "Given\n    Width of the circuit (int n)\n    A CZ circuit, represented by the n*n phase schedule phase_schedule\n    A CX circuit, represented by box-labels (seq) and whether the box is SWAP+ (swap_plus)\n        *   This circuit corresponds to the CX tranformation that tranforms a matrix to\n            a NW matrix (c.f. Prop.7.4, [1])\n        *   SWAP+ is defined in section 3.A. of [2].\n        *   As previously noted, the northwest diagonalization procedure of [1] consists\n            of exactly n layers of boxes, each being either a SWAP or a SWAP+. That is,\n            each northwest diagonalization circuit can be uniquely represented by which\n            of its n(n-1)/2 boxes are SWAP+ and which are SWAP.\nReturn a QuantumCircuit that computes the phase schedule S inside CX",
        "api_signature": "_apply_phase_to_nw_circuit(n, phase_schedule, seq, swap_plus)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/linear_phase/cx_cz_depth_lnn.py"
    },
    {
        "api_name": "synth_cx_cz_depth_line_my",
        "full_api_name": "synth_cx_cz_depth_line_my",
        "api_description": "Joint synthesis of a -CZ-CX- circuit for linear nearest neighbor (LNN) connectivity,\nwith 2-qubit depth at most 5n, based on Maslov and Yang.\nThis method computes the CZ circuit inside the CX circuit via phase gate insertions.\n\nArgs:\n    mat_z : a boolean symmetric matrix representing a CZ circuit.\n        ``mat_z[i][j]=1`` represents a ``cz(i,j)`` gate\n\n    mat_x : a boolean invertible matrix representing a CX circuit.\n\nReturns:\n    A circuit implementation of a CX circuit following a CZ circuit,\n    denoted as a -CZ-CX- circuit,in two-qubit depth at most ``5n``, for LNN connectivity.\n\nReferences:\n    1. Kutin, S., Moulton, D. P., Smithline, L.,\n       *Computation at a distance*, Chicago J. Theor. Comput. Sci., vol. 2007, (2007),\n       `arXiv:quant-ph/0701194 <https://arxiv.org/abs/quant-ph/0701194>`_\n    2. Dmitri Maslov, Willers Yang, *CNOT circuits need little help to implement arbitrary\n       Hadamard-free Clifford transformations they generate*,\n       `arXiv:2210.16195 <https://arxiv.org/abs/2210.16195>`_.",
        "api_signature": "synth_cx_cz_depth_line_my(mat_x, mat_z)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/linear_phase/cx_cz_depth_lnn.py"
    },
    {
        "api_name": "synth_cnotdihedral_general",
        "full_api_name": "synth_cnotdihedral_general",
        "api_description": "Decompose a :class:`.CNOTDihedral` element into a :class:`.QuantumCircuit`.\n\nDecompose a general :class:`.CNOTDihedral` elements.\nThe number of CX gates is not necessarily optimal.\nFor a decomposition of a 1-qubit or 2-qubit element, call\n:func:`.synth_cnotdihedral_two_qubits`.\n\nArgs:\n    elem: A :class:`.CNOTDihedral` element.\n\nReturns:\n    A circuit implementation of the :class:`.CNOTDihedral` element.\n\nRaises:\n    QiskitError: if the element could not be decomposed into a circuit.\n\nReferences:\n    1. Andrew W. Cross, Easwar Magesan, Lev S. Bishop, John A. Smolin and Jay M. Gambetta,\n       *Scalable randomized benchmarking of non-Clifford gates*,\n       npj Quantum Inf 2, 16012 (2016).",
        "api_signature": "synth_cnotdihedral_general(elem)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/cnotdihedral/cnotdihedral_decompose_general.py"
    },
    {
        "api_name": "synth_cnotdihedral_full",
        "full_api_name": "synth_cnotdihedral_full",
        "api_description": "Decompose a :class:`.CNOTDihedral` element into a :class:`.QuantumCircuit`.\n\nFor :math:`N \\leq 2` qubits this is based on optimal CX-cost decomposition from reference [1].\nFor :math:`N > 2` qubits this is done using the general non-optimal compilation\nroutine from reference [2].\n\nArgs:\n    elem: A :class:`.CNOTDihedral` element.\n\nReturns:\n    A circuit implementation of the :class:`.CNOTDihedral` element.\n\nReferences:\n    1. Shelly Garion and Andrew W. Cross, *Synthesis of CNOT-Dihedral circuits\n       with optimal number of two qubit gates*, `Quantum 4(369), 2020\n       <https://quantum-journal.org/papers/q-2020-12-07-369/>`_\n    2. Andrew W. Cross, Easwar Magesan, Lev S. Bishop, John A. Smolin and Jay M. Gambetta,\n       *Scalable randomized benchmarking of non-Clifford gates*,\n       npj Quantum Inf 2, 16012 (2016).",
        "api_signature": "synth_cnotdihedral_full(elem)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/cnotdihedral/cnotdihedral_decompose_full.py"
    },
    {
        "api_name": "synth_cnotdihedral_two_qubits",
        "full_api_name": "synth_cnotdihedral_two_qubits",
        "api_description": "Decompose a :class:`.CNOTDihedral` element on a single qubit and two\nqubits into a :class:`.QuantumCircuit`.\nThis decomposition has an optimal number of :class:`.CXGate`\\ s.\n\nArgs:\n    elem: A :class:`.CNOTDihedral` element.\n\nReturns:\n    A circuit implementation of the :class:`.CNOTDihedral` element.\n\nRaises:\n    QiskitError: if the element in not 1-qubit or 2-qubit :class:`.CNOTDihedral`.\n\nReferences:\n    1. Shelly Garion and Andrew W. Cross, *On the structure of the CNOT-Dihedral group*,\n       `arXiv:2006.12042 [quant-ph] <https://arxiv.org/abs/2006.12042>`_",
        "api_signature": "synth_cnotdihedral_two_qubits(elem)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/cnotdihedral/cnotdihedral_decompose_two_qubits.py"
    },
    {
        "api_name": "synth_cnot_count_full_pmh",
        "full_api_name": "synth_cnot_count_full_pmh",
        "api_description": "Synthesize linear reversible circuits for all-to-all architecture\nusing Patel, Markov and Hayes method.\n\nThis function is an implementation of the Patel, Markov and Hayes algorithm from [1]\nfor optimal synthesis of linear reversible circuits for all-to-all architecture,\nas specified by an :math:`n \\times n` matrix.\n\nArgs:\n    state: :math:`n \\times n` boolean invertible matrix, describing\n        the state of the input circuit.\n    section_size: The size of each section in the Patel\u2013Markov\u2013Hayes algorithm [1].\n        If ``None`` it is chosen to be :math:`\\max(2, \\alpha\\log_2(n))` with\n        :math:`\\alpha = 0.56`, which approximately minimizes the upper bound on the number\n        of row operations given in [1] Eq. (3).\n\nReturns:\n    A CX-only circuit implementing the linear transformation.\n\nRaises:\n    ValueError: When ``section_size`` is larger than the number of columns.\n\nReferences:\n    1. Patel, Ketan N., Igor L. Markov, and John P. Hayes,\n       *Optimal synthesis of linear reversible circuits*,\n       Quantum Information & Computation 8.3 (2008): 282-294.\n       `arXiv:quant-ph/0302002 [quant-ph] <https://arxiv.org/abs/quant-ph/0302002>`_",
        "api_signature": "synth_cnot_count_full_pmh(state, section_size)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/linear/cnot_synth.py"
    },
    {
        "api_name": "transpose_cx_circ",
        "full_api_name": "transpose_cx_circ",
        "api_description": "Takes a circuit having only CX gates, and calculates its transpose.\nThis is done by recursively replacing CX(i, j) with CX(j, i) in all instructions.\n\nArgs:\n    qc: a :class:`.QuantumCircuit` containing only CX gates.\n\nReturns:\n    QuantumCircuit: the transposed circuit.\n\nRaises:\n    CircuitError: if qc has a non-CX gate.",
        "api_signature": "transpose_cx_circ(qc)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/linear/linear_circuits_utils.py"
    },
    {
        "api_name": "optimize_cx_4_options",
        "full_api_name": "optimize_cx_4_options",
        "api_description": "Get the best implementation of a circuit implementing a binary invertible matrix M,\nby considering all four options: M,M^(-1),M^T,M^(-1)^T.\nOptimizing either the CX count or the depth.\n\nArgs:\n    function: the synthesis function.\n    mat: a binary invertible matrix.\n    optimize_count: True if the number of CX gates in optimize, False if the depth is optimized.\n\nReturns:\n    QuantumCircuit: an optimized :class:`.QuantumCircuit`, has the best depth or CX count of\n        the four options.\n\nRaises:\n    QiskitError: if mat is not an invertible matrix.",
        "api_signature": "optimize_cx_4_options(function, mat, optimize_count)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/linear/linear_circuits_utils.py"
    },
    {
        "api_name": "check_lnn_connectivity",
        "full_api_name": "check_lnn_connectivity",
        "api_description": "Check that the synthesized circuit qc fits linear nearest neighbor connectivity.\n\nArgs:\n    qc: a :class:`.QuantumCircuit` containing only CX and single qubit gates.\n\nReturns:\n    bool: True if the circuit has linear nearest neighbor connectivity.\n\nRaises:\n    CircuitError: if qc has a non-CX two-qubit gate.",
        "api_signature": "check_lnn_connectivity(qc)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/linear/linear_circuits_utils.py"
    },
    {
        "api_name": "_row_op_update_instructions",
        "full_api_name": "_row_op_update_instructions",
        "api_description": "",
        "api_signature": "_row_op_update_instructions(cx_instructions, mat, a, b)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/linear/linear_depth_lnn.py"
    },
    {
        "api_name": "_get_lower_triangular",
        "full_api_name": "_get_lower_triangular",
        "api_description": "",
        "api_signature": "_get_lower_triangular(n, mat, mat_inv)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/linear/linear_depth_lnn.py"
    },
    {
        "api_name": "_get_label_arr",
        "full_api_name": "_get_label_arr",
        "api_description": "",
        "api_signature": "_get_label_arr(n, mat_t)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/linear/linear_depth_lnn.py"
    },
    {
        "api_name": "_in_linear_combination",
        "full_api_name": "_in_linear_combination",
        "api_description": "",
        "api_signature": "_in_linear_combination(label_arr_t, mat_inv_t, row, k)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/linear/linear_depth_lnn.py"
    },
    {
        "api_name": "_get_label_arr_t",
        "full_api_name": "_get_label_arr_t",
        "api_description": "",
        "api_signature": "_get_label_arr_t(n, label_arr)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/linear/linear_depth_lnn.py"
    },
    {
        "api_name": "_matrix_to_north_west",
        "full_api_name": "_matrix_to_north_west",
        "api_description": "",
        "api_signature": "_matrix_to_north_west(n, mat, mat_inv)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/linear/linear_depth_lnn.py"
    },
    {
        "api_name": "_north_west_to_identity",
        "full_api_name": "_north_west_to_identity",
        "api_description": "",
        "api_signature": "_north_west_to_identity(n, mat)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/linear/linear_depth_lnn.py"
    },
    {
        "api_name": "_optimize_cx_circ_depth_5n_line",
        "full_api_name": "_optimize_cx_circ_depth_5n_line",
        "api_description": "",
        "api_signature": "_optimize_cx_circ_depth_5n_line(mat)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/linear/linear_depth_lnn.py"
    },
    {
        "api_name": "synth_cnot_depth_line_kms",
        "full_api_name": "synth_cnot_depth_line_kms",
        "api_description": "Synthesize linear reversible circuit for linear nearest-neighbor architectures using\nKutin, Moulton, Smithline method.\n\nSynthesis algorithm for linear reversible circuits from [1], section 7.\nThis algorithm synthesizes any linear reversible circuit of :math:`n` qubits over\na linear nearest-neighbor architecture using CX gates with depth at most :math:`5n`.\n\nArgs:\n    mat: A boolean invertible matrix.\n\nReturns:\n    The synthesized quantum circuit.\n\nRaises:\n    QiskitError: if ``mat`` is not invertible.\n\nReferences:\n    1. Kutin, S., Moulton, D. P., Smithline, L.,\n       *Computation at a distance*, Chicago J. Theor. Comput. Sci., vol. 2007, (2007),\n       `arXiv:quant-ph/0701194 <https://arxiv.org/abs/quant-ph/0701194>`_",
        "api_signature": "synth_cnot_depth_line_kms(mat)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/linear/linear_depth_lnn.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "OneQubitEulerDecomposer.__init__",
        "api_description": "Initialize decomposer\n\nSupported bases are: ``'U'``, ``'PSX'``, ``'ZSXX'``, ``'ZSX'``, ``'U321'``, ``'U3'``,\n``'U1X'``, ``'RR'``, ``'ZYZ'``, ``'ZXZ'``, ``'XYX'``, ``'XZX'``.\n\nArgs:\n    basis: the decomposition basis [Default: ``'U3'``]\n    use_dag: If true the output from calls to the decomposer\n        will be a :class:`~qiskit.dagcircuit.DAGCircuit` object instead of\n        :class:`~qiskit.circuit.QuantumCircuit`.\n\nRaises:\n    QiskitError: If input basis is not recognized.",
        "api_signature": "__init__(self, basis, use_dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/one_qubit/one_qubit_decompose.py"
    },
    {
        "api_name": "build_circuit",
        "full_api_name": "OneQubitEulerDecomposer.build_circuit",
        "api_description": "Return the circuit or dag object from a list of gates.",
        "api_signature": "build_circuit(self, gates, global_phase)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/one_qubit/one_qubit_decompose.py"
    },
    {
        "api_name": "__call__",
        "full_api_name": "OneQubitEulerDecomposer.__call__",
        "api_description": "Decompose single qubit gate into a circuit.\n\nArgs:\n    unitary: 1-qubit unitary matrix\n    simplify: reduce gate count in decomposition [Default: True].\n    atol: absolute tolerance for checking angles when simplifying\n                 returned circuit [Default: 1e-12].\n\nReturns:\n    QuantumCircuit: the decomposed single-qubit gate circuit\n\nRaises:\n    QiskitError: if input is invalid or synthesis fails.",
        "api_signature": "__call__(self, unitary, simplify, atol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/one_qubit/one_qubit_decompose.py"
    },
    {
        "api_name": "_decompose",
        "full_api_name": "OneQubitEulerDecomposer._decompose",
        "api_description": "",
        "api_signature": "_decompose(self, unitary, simplify, atol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/one_qubit/one_qubit_decompose.py"
    },
    {
        "api_name": "basis",
        "full_api_name": "OneQubitEulerDecomposer.basis",
        "api_description": "The decomposition basis.",
        "api_signature": "basis(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/one_qubit/one_qubit_decompose.py"
    },
    {
        "api_name": "basis",
        "full_api_name": "OneQubitEulerDecomposer.basis",
        "api_description": "Set the decomposition basis.",
        "api_signature": "basis(self, basis)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/one_qubit/one_qubit_decompose.py"
    },
    {
        "api_name": "angles",
        "full_api_name": "OneQubitEulerDecomposer.angles",
        "api_description": "Return the Euler angles for input array.\n\nArgs:\n    unitary: :math:`2\\times2` unitary matrix.\n\nReturns:\n    tuple: ``(theta, phi, lambda)``.",
        "api_signature": "angles(self, unitary)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/one_qubit/one_qubit_decompose.py"
    },
    {
        "api_name": "angles_and_phase",
        "full_api_name": "OneQubitEulerDecomposer.angles_and_phase",
        "api_description": "Return the Euler angles and phase for input array.\n\nArgs:\n    unitary: :math:`2\\times2`\n\nReturns:\n    tuple: ``(theta, phi, lambda, phase)``.",
        "api_signature": "angles_and_phase(self, unitary)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/synthesis/one_qubit/one_qubit_decompose.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BackendV1.__init__",
        "api_description": "Initialize a backend class\n\nArgs:\n    configuration (BackendConfiguration): A backend configuration\n        object for the backend object.\n    provider (qiskit.providers.Provider): Optionally, the provider\n        object that this Backend comes from.\n    fields: kwargs for the values to use to override the default\n        options.\nRaises:\n    AttributeError: if input field not a valid options\n\n..\n    This next bit is necessary just because autosummary generally won't summarise private\n    methods; changing that behavior would have annoying knock-on effects through all the\n    rest of the documentation, so instead we just hard-code the automethod directive.",
        "api_signature": "__init__(self, configuration, provider)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend.py"
    },
    {
        "api_name": "_default_options",
        "full_api_name": "BackendV1._default_options",
        "api_description": "Return the default options\n\nThis method will return a :class:`qiskit.providers.Options`\nsubclass object that will be used for the default options. These\nshould be the default parameters to use for the options of the\nbackend.\n\nReturns:\n    qiskit.providers.Options: A options object with\n        default values set",
        "api_signature": "_default_options(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend.py"
    },
    {
        "api_name": "set_options",
        "full_api_name": "BackendV1.set_options",
        "api_description": "Set the options fields for the backend\n\nThis method is used to update the options of a backend. If\nyou need to change any of the options prior to running just\npass in the kwarg with the new value for the options.\n\nArgs:\n    fields: The fields to update the options\n\nRaises:\n    AttributeError: If the field passed in is not part of the\n        options",
        "api_signature": "set_options(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend.py"
    },
    {
        "api_name": "configuration",
        "full_api_name": "BackendV1.configuration",
        "api_description": "Return the backend configuration.\n\nReturns:\n    BackendConfiguration: the configuration for the backend.",
        "api_signature": "configuration(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend.py"
    },
    {
        "api_name": "properties",
        "full_api_name": "BackendV1.properties",
        "api_description": "Return the backend properties.\n\nReturns:\n    BackendProperties: the configuration for the backend. If the backend\n    does not support properties, it returns ``None``.",
        "api_signature": "properties(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend.py"
    },
    {
        "api_name": "provider",
        "full_api_name": "BackendV1.provider",
        "api_description": "Return the backend Provider.\n\nReturns:\n    Provider: the Provider responsible for the backend.",
        "api_signature": "provider(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend.py"
    },
    {
        "api_name": "status",
        "full_api_name": "BackendV1.status",
        "api_description": "Return the backend status.\n\nReturns:\n    BackendStatus: the status of the backend.",
        "api_signature": "status(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend.py"
    },
    {
        "api_name": "name",
        "full_api_name": "BackendV1.name",
        "api_description": "Return the backend name.\n\nReturns:\n    str: the name of the backend.",
        "api_signature": "name(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "BackendV1.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "BackendV1.__repr__",
        "api_description": "Official string representation of a Backend.\n\nNote that, by Qiskit convention, it is consciously *not* a fully valid\nPython expression. Subclasses should provide 'a string of the form\n<...some useful description...>'. [0]\n\n[0] https://docs.python.org/3/reference/datamodel.html#object.__repr__",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend.py"
    },
    {
        "api_name": "options",
        "full_api_name": "BackendV1.options",
        "api_description": "Return the options for the backend\n\nThe options of a backend are the dynamic parameters defining\nhow the backend is used. These are used to control the :meth:`run`\nmethod.",
        "api_signature": "options(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend.py"
    },
    {
        "api_name": "run",
        "full_api_name": "BackendV1.run",
        "api_description": "Run on the backend.\n\nThis method returns a :class:`~qiskit.providers.Job` object\nthat runs circuits. Depending on the backend this may be either an async\nor sync call. It is at the discretion of the provider to decide whether\nrunning should block until the execution is finished or not: the Job\nclass can handle either situation.\n\nArgs:\n    run_input (QuantumCircuit or Schedule or list): An individual or a\n        list of :class:`~qiskit.circuit.QuantumCircuit` or\n        :class:`~qiskit.pulse.Schedule` objects to run on the backend.\n        For legacy providers migrating to the new versioned providers,\n        provider interface a :class:`~qiskit.qobj.QasmQobj` or\n        :class:`~qiskit.qobj.PulseQobj` objects should probably be\n        supported too (but deprecated) for backwards compatibility. Be\n        sure to update the docstrings of subclasses implementing this\n        method to document that. New provider implementations should not\n        do this though as :mod:`qiskit.qobj` will be deprecated and\n        removed along with the legacy providers interface.\n    options: Any kwarg options to pass to the backend for running the\n        config. If a key is also present in the options\n        attribute/object then the expectation is that the value\n        specified will be used instead of what's set in the options\n        object.\nReturns:\n    Job: The job object for the run",
        "api_signature": "run(self, run_input)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QubitProperties.__init__",
        "api_description": "Create a new :class:`QubitProperties` object.\n\nArgs:\n    t1: The T1 time for a qubit in seconds\n    t2: The T2 time for a qubit in seconds\n    frequency: The frequency of a qubit in Hz",
        "api_signature": "__init__(self, t1, t2, frequency)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "QubitProperties.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BackendV2.__init__",
        "api_description": "Initialize a BackendV2 based backend\n\nArgs:\n    provider: An optional backwards reference to the\n        :class:`~qiskit.providers.Provider` object that the backend\n        is from\n    name: An optional name for the backend\n    description: An optional description of the backend\n    online_date: An optional datetime the backend was brought online\n    backend_version: An optional backend version string. This differs\n        from the :attr:`~qiskit.providers.BackendV2.version` attribute\n        as :attr:`~qiskit.providers.BackendV2.version` is for the\n        abstract :attr:`~qiskit.providers.Backend` abstract interface\n        version of the object while ``backend_version`` is for\n        versioning the backend itself.\n    fields: kwargs for the values to use to override the default\n        options.\n\nRaises:\n    AttributeError: If a field is specified that's outside the backend's\n        options",
        "api_signature": "__init__(self, provider, name, description, online_date, backend_version)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend.py"
    },
    {
        "api_name": "instructions",
        "full_api_name": "BackendV2.instructions",
        "api_description": "A list of Instruction tuples on the backend of the form ``(instruction, (qubits)``",
        "api_signature": "instructions(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend.py"
    },
    {
        "api_name": "operations",
        "full_api_name": "BackendV2.operations",
        "api_description": "A list of :class:`~qiskit.circuit.Instruction` instances that the backend supports.",
        "api_signature": "operations(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend.py"
    },
    {
        "api_name": "operation_names",
        "full_api_name": "BackendV2.operation_names",
        "api_description": "A list of instruction names that the backend supports.",
        "api_signature": "operation_names(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend.py"
    },
    {
        "api_name": "target",
        "full_api_name": "BackendV2.target",
        "api_description": "A :class:`qiskit.transpiler.Target` object for the backend.\n\n:rtype: Target",
        "api_signature": "target(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend.py"
    },
    {
        "api_name": "num_qubits",
        "full_api_name": "BackendV2.num_qubits",
        "api_description": "Return the number of qubits the backend has.",
        "api_signature": "num_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend.py"
    },
    {
        "api_name": "coupling_map",
        "full_api_name": "BackendV2.coupling_map",
        "api_description": "Return the :class:`~qiskit.transpiler.CouplingMap` object",
        "api_signature": "coupling_map(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend.py"
    },
    {
        "api_name": "instruction_durations",
        "full_api_name": "BackendV2.instruction_durations",
        "api_description": "Return the :class:`~qiskit.transpiler.InstructionDurations` object.",
        "api_signature": "instruction_durations(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend.py"
    },
    {
        "api_name": "max_circuits",
        "full_api_name": "BackendV2.max_circuits",
        "api_description": "The maximum number of circuits (or Pulse schedules) that can be\nrun in a single job.\n\nIf there is no limit this will return None",
        "api_signature": "max_circuits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend.py"
    },
    {
        "api_name": "_default_options",
        "full_api_name": "BackendV2._default_options",
        "api_description": "Return the default options\n\nThis method will return a :class:`qiskit.providers.Options`\nsubclass object that will be used for the default options. These\nshould be the default parameters to use for the options of the\nbackend.\n\nReturns:\n    qiskit.providers.Options: A options object with\n        default values set",
        "api_signature": "_default_options(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend.py"
    },
    {
        "api_name": "dt",
        "full_api_name": "BackendV2.dt",
        "api_description": "Return the system time resolution of input signals\n\nThis is required to be implemented if the backend supports Pulse\nscheduling.\n\nReturns:\n    The input signal timestep in seconds. If the backend doesn't define ``dt``, ``None`` will\n    be returned.",
        "api_signature": "dt(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend.py"
    },
    {
        "api_name": "dtm",
        "full_api_name": "BackendV2.dtm",
        "api_description": "Return the system time resolution of output signals\n\nReturns:\n    The output signal timestep in seconds.\n\nRaises:\n    NotImplementedError: if the backend doesn't support querying the\n        output signal timestep",
        "api_signature": "dtm(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend.py"
    },
    {
        "api_name": "meas_map",
        "full_api_name": "BackendV2.meas_map",
        "api_description": "Return the grouping of measurements which are multiplexed\n\nThis is required to be implemented if the backend supports Pulse\nscheduling.\n\nReturns:\n    The grouping of measurements which are multiplexed\n\nRaises:\n    NotImplementedError: if the backend doesn't support querying the\n        measurement mapping",
        "api_signature": "meas_map(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend.py"
    },
    {
        "api_name": "instruction_schedule_map",
        "full_api_name": "BackendV2.instruction_schedule_map",
        "api_description": "Return the :class:`~qiskit.pulse.InstructionScheduleMap` for the\ninstructions defined in this backend's target.",
        "api_signature": "instruction_schedule_map(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend.py"
    },
    {
        "api_name": "qubit_properties",
        "full_api_name": "BackendV2.qubit_properties",
        "api_description": "Return QubitProperties for a given qubit.\n\nIf there are no defined or the backend doesn't support querying these\ndetails this method does not need to be implemented.\n\nArgs:\n    qubit: The qubit to get the\n        :class:`.QubitProperties` object for. This can\n        be a single integer for 1 qubit or a list of qubits and a list\n        of :class:`.QubitProperties` objects will be\n        returned in the same order\nReturns:\n    The :class:`~.QubitProperties` object for the\n    specified qubit. If a list of qubits is provided a list will be\n    returned. If properties are missing for a qubit this can be\n    ``None``.\n\nRaises:\n    NotImplementedError: if the backend doesn't support querying the\n        qubit properties",
        "api_signature": "qubit_properties(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend.py"
    },
    {
        "api_name": "drive_channel",
        "full_api_name": "BackendV2.drive_channel",
        "api_description": "Return the drive channel for the given qubit.\n\nThis is required to be implemented if the backend supports Pulse\nscheduling.\n\nReturns:\n    DriveChannel: The Qubit drive channel\n\nRaises:\n    NotImplementedError: if the backend doesn't support querying the\n        measurement mapping",
        "api_signature": "drive_channel(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend.py"
    },
    {
        "api_name": "measure_channel",
        "full_api_name": "BackendV2.measure_channel",
        "api_description": "Return the measure stimulus channel for the given qubit.\n\nThis is required to be implemented if the backend supports Pulse\nscheduling.\n\nReturns:\n    MeasureChannel: The Qubit measurement stimulus line\n\nRaises:\n    NotImplementedError: if the backend doesn't support querying the\n        measurement mapping",
        "api_signature": "measure_channel(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend.py"
    },
    {
        "api_name": "acquire_channel",
        "full_api_name": "BackendV2.acquire_channel",
        "api_description": "Return the acquisition channel for the given qubit.\n\nThis is required to be implemented if the backend supports Pulse\nscheduling.\n\nReturns:\n    AcquireChannel: The Qubit measurement acquisition line.\n\nRaises:\n    NotImplementedError: if the backend doesn't support querying the\n        measurement mapping",
        "api_signature": "acquire_channel(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend.py"
    },
    {
        "api_name": "control_channel",
        "full_api_name": "BackendV2.control_channel",
        "api_description": "Return the secondary drive channel for the given qubit\n\nThis is typically utilized for controlling multiqubit interactions.\nThis channel is derived from other channels.\n\nThis is required to be implemented if the backend supports Pulse\nscheduling.\n\nArgs:\n    qubits: Tuple or list of qubits of the form\n        ``(control_qubit, target_qubit)``.\n\nReturns:\n    List[ControlChannel]: The multi qubit control line.\n\nRaises:\n    NotImplementedError: if the backend doesn't support querying the\n        measurement mapping",
        "api_signature": "control_channel(self, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend.py"
    },
    {
        "api_name": "set_options",
        "full_api_name": "BackendV2.set_options",
        "api_description": "Set the options fields for the backend\n\nThis method is used to update the options of a backend. If\nyou need to change any of the options prior to running just\npass in the kwarg with the new value for the options.\n\nArgs:\n    fields: The fields to update the options\n\nRaises:\n    AttributeError: If the field passed in is not part of the\n        options",
        "api_signature": "set_options(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend.py"
    },
    {
        "api_name": "options",
        "full_api_name": "BackendV2.options",
        "api_description": "Return the options for the backend\n\nThe options of a backend are the dynamic parameters defining\nhow the backend is used. These are used to control the :meth:`run`\nmethod.",
        "api_signature": "options(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend.py"
    },
    {
        "api_name": "provider",
        "full_api_name": "BackendV2.provider",
        "api_description": "Return the backend Provider.\n\nReturns:\n    Provider: the Provider responsible for the backend.",
        "api_signature": "provider(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend.py"
    },
    {
        "api_name": "run",
        "full_api_name": "BackendV2.run",
        "api_description": "Run on the backend.\n\nThis method returns a :class:`~qiskit.providers.Job` object\nthat runs circuits. Depending on the backend this may be either an async\nor sync call. It is at the discretion of the provider to decide whether\nrunning should block until the execution is finished or not: the Job\nclass can handle either situation.\n\nArgs:\n    run_input (QuantumCircuit or Schedule or ScheduleBlock or list): An\n        individual or a list of :class:`.QuantumCircuit`,\n        :class:`~qiskit.pulse.ScheduleBlock`, or :class:`~qiskit.pulse.Schedule` objects to\n        run on the backend.\n    options: Any kwarg options to pass to the backend for running the\n        config. If a key is also present in the options\n        attribute/object then the expectation is that the value\n        specified will be used instead of what's set in the options\n        object.\n\nReturns:\n    Job: The job object for the run",
        "api_signature": "run(self, run_input)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "JobV1.__init__",
        "api_description": "Initializes the asynchronous job.\n\nArgs:\n    backend: the backend used to run the job.\n    job_id: a unique id in the context of the backend used to run\n        the job.\n    kwargs: Any key value metadata to associate with this job.",
        "api_signature": "__init__(self, backend, job_id)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/job.py"
    },
    {
        "api_name": "job_id",
        "full_api_name": "JobV1.job_id",
        "api_description": "Return a unique id identifying the job.",
        "api_signature": "job_id(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/job.py"
    },
    {
        "api_name": "backend",
        "full_api_name": "JobV1.backend",
        "api_description": "Return the backend where this job was executed.",
        "api_signature": "backend(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/job.py"
    },
    {
        "api_name": "done",
        "full_api_name": "JobV1.done",
        "api_description": "Return whether the job has successfully run.",
        "api_signature": "done(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/job.py"
    },
    {
        "api_name": "running",
        "full_api_name": "JobV1.running",
        "api_description": "Return whether the job is actively running.",
        "api_signature": "running(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/job.py"
    },
    {
        "api_name": "cancelled",
        "full_api_name": "JobV1.cancelled",
        "api_description": "Return whether the job has been cancelled.",
        "api_signature": "cancelled(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/job.py"
    },
    {
        "api_name": "in_final_state",
        "full_api_name": "JobV1.in_final_state",
        "api_description": "Return whether the job is in a final job state such as ``DONE`` or ``ERROR``.",
        "api_signature": "in_final_state(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/job.py"
    },
    {
        "api_name": "wait_for_final_state",
        "full_api_name": "JobV1.wait_for_final_state",
        "api_description": "Poll the job status until it progresses to a final state such as ``DONE`` or ``ERROR``.\n\nArgs:\n    timeout: Seconds to wait for the job. If ``None``, wait indefinitely.\n    wait: Seconds between queries.\n    callback: Callback function invoked after each query.\n        The following positional arguments are provided to the callback function:\n\n        * job_id: Job ID\n        * job_status: Status of the job from the last query\n        * job: This BaseJob instance\n\n        Note: different subclass might provide different arguments to\n        the callback function.\n\nRaises:\n    JobTimeoutError: If the job does not reach a final state before the\n        specified timeout.",
        "api_signature": "wait_for_final_state(self, timeout, wait, callback)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/job.py"
    },
    {
        "api_name": "submit",
        "full_api_name": "JobV1.submit",
        "api_description": "Submit the job to the backend for execution.",
        "api_signature": "submit(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/job.py"
    },
    {
        "api_name": "result",
        "full_api_name": "JobV1.result",
        "api_description": "Return the results of the job.",
        "api_signature": "result(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/job.py"
    },
    {
        "api_name": "cancel",
        "full_api_name": "JobV1.cancel",
        "api_description": "Attempt to cancel the job.",
        "api_signature": "cancel(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/job.py"
    },
    {
        "api_name": "status",
        "full_api_name": "JobV1.status",
        "api_description": "Return the status of the job, among the values of ``JobStatus``.",
        "api_signature": "status(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/job.py"
    },
    {
        "api_name": "filter_backends",
        "full_api_name": "filter_backends",
        "api_description": "Return the backends matching the specified filtering.\n\nFilter the `backends` list by their `configuration` or `status`\nattributes, or from a boolean callable. The criteria for filtering can\nbe specified via `**kwargs` or as a callable via `filters`, and the\nbackends must fulfill all specified conditions.\n\nArgs:\n    backends (list[Backend]): list of backends.\n    filters (callable): filtering conditions as a callable.\n    **kwargs: dict of criteria.\n\nReturns:\n    list[Backend]: a list of backend instances matching the\n        conditions.",
        "api_signature": "filter_backends(backends, filters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/providerutils.py"
    },
    {
        "api_name": "_match_all",
        "full_api_name": "_match_all",
        "api_description": "Return True if all items in criteria matches items in obj.",
        "api_signature": "_match_all(obj, criteria)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/providerutils.py"
    },
    {
        "api_name": "resolve_backend_name",
        "full_api_name": "resolve_backend_name",
        "api_description": "Resolve backend name from a deprecated name or an alias.\n\nA group will be resolved in order of member priorities, depending on\navailability.\n\nArgs:\n    name (str): name of backend to resolve\n    backends (list[Backend]): list of available backends.\n    deprecated (dict[str: str]): dict of deprecated names.\n    aliased (dict[str: list[str]]): dict of aliased names.\n\nReturns:\n    str: resolved name (name of an available backend)\n\nRaises:\n    LookupError: if name cannot be resolved through regular available\n        names, nor deprecated, nor alias names.",
        "api_signature": "resolve_backend_name(name, backends, deprecated, aliased)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/providerutils.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Provider.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/provider.py"
    },
    {
        "api_name": "get_backend",
        "full_api_name": "ProviderV1.get_backend",
        "api_description": "Return a single backend matching the specified filtering.\n\nArgs:\n    name (str): name of the backend.\n    **kwargs: dict used for filtering.\n\nReturns:\n    Backend: a backend matching the filtering.\n\nRaises:\n    QiskitBackendNotFoundError: if no backend could be found or\n        more than one backend matches the filtering criteria.",
        "api_signature": "get_backend(self, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/provider.py"
    },
    {
        "api_name": "backends",
        "full_api_name": "ProviderV1.backends",
        "api_description": "Return a list of backends matching the specified filtering.\n\nArgs:\n    name (str): name of the backend.\n    **kwargs: dict used for filtering.\n\nReturns:\n    list[Backend]: a list of Backends that match the filtering\n        criteria.",
        "api_signature": "backends(self, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/provider.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "ProviderV1.__eq__",
        "api_description": "Equality comparison.\n\nBy default, it is assumed that two `Providers` from the same class are\nequal. Subclassed providers can override this behavior.",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/provider.py"
    },
    {
        "api_name": "__getitem__",
        "full_api_name": "Options.__getitem__",
        "api_description": "",
        "api_signature": "__getitem__(self, key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/options.py"
    },
    {
        "api_name": "__iter__",
        "full_api_name": "Options.__iter__",
        "api_description": "",
        "api_signature": "__iter__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/options.py"
    },
    {
        "api_name": "__len__",
        "full_api_name": "Options.__len__",
        "api_description": "",
        "api_signature": "__len__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/options.py"
    },
    {
        "api_name": "__setitem__",
        "full_api_name": "Options.__setitem__",
        "api_description": "",
        "api_signature": "__setitem__(self, key, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/options.py"
    },
    {
        "api_name": "__dict__",
        "full_api_name": "Options.__dict__",
        "api_description": "",
        "api_signature": "__dict__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/options.py"
    },
    {
        "api_name": "__getattr__",
        "full_api_name": "Options.__getattr__",
        "api_description": "",
        "api_signature": "__getattr__(self, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/options.py"
    },
    {
        "api_name": "__setattr__",
        "full_api_name": "Options.__setattr__",
        "api_description": "",
        "api_signature": "__setattr__(self, key, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/options.py"
    },
    {
        "api_name": "__getstate__",
        "full_api_name": "Options.__getstate__",
        "api_description": "",
        "api_signature": "__getstate__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/options.py"
    },
    {
        "api_name": "__setstate__",
        "full_api_name": "Options.__setstate__",
        "api_description": "",
        "api_signature": "__setstate__(self, state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/options.py"
    },
    {
        "api_name": "__copy__",
        "full_api_name": "Options.__copy__",
        "api_description": "Return a copy of the Options.\n\nThe returned option and validator values are shallow copies of the originals.",
        "api_signature": "__copy__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/options.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Options.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/options.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "Options.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/options.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "Options.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/options.py"
    },
    {
        "api_name": "set_validator",
        "full_api_name": "Options.set_validator",
        "api_description": "Set an optional validator for a field in the options\n\nSetting a validator enables changes to an options values to be\nvalidated for correctness when :meth:`~qiskit.providers.Options.update_options`\nis called. For example if you have a numeric field like\n``shots`` you can specify a bounds tuple that set an upper and lower\nbound on the value such as::\n\n    options.set_validator(\"shots\", (1, 4096))\n\nIn this case whenever the ``\"shots\"`` option is updated by the user\nit will enforce that the value is >=1 and <=4096. A ``ValueError`` will\nbe raised if it's outside those bounds. If a validator is already present\nfor the specified field it will be silently overridden.\n\nArgs:\n    field (str): The field name to set the validator on\n    validator_value (list or tuple or type): The value to use for the\n        validator depending on the type indicates on how the value for\n        a field is enforced. If a tuple is passed in it must have a\n        length of two and will enforce the min and max value\n        (inclusive) for an integer or float value option. If it's a\n        list it will list the valid values for a field. If it's a\n        ``type`` the validator will just enforce the value is of a\n        certain type.\nRaises:\n    KeyError: If field is not present in the options object\n    ValueError: If the ``validator_value`` has an invalid value for a\n        given type\n    TypeError: If ``validator_value`` is not a valid type",
        "api_signature": "set_validator(self, field, validator_value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/options.py"
    },
    {
        "api_name": "update_options",
        "full_api_name": "Options.update_options",
        "api_description": "Update options with kwargs",
        "api_signature": "update_options(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/options.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "Options.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/options.py"
    },
    {
        "api_name": "convert_to_target",
        "full_api_name": "convert_to_target",
        "api_description": "Decode transpiler target from backend data set.\n\nThis function generates :class:`.Target`` instance from intermediate\nlegacy objects such as :class:`.BackendProperties` and :class:`.PulseDefaults`.\nThese objects are usually components of the legacy :class:`.BackendV1` model.\n\nArgs:\n    configuration: Backend configuration as ``BackendConfiguration``\n    properties: Backend property dictionary or ``BackendProperties``\n    defaults: Backend pulse defaults dictionary or ``PulseDefaults``\n    custom_name_mapping: A name mapping must be supplied for the operation\n        not included in Qiskit Standard Gate name mapping, otherwise the operation\n        will be dropped in the resulting ``Target`` object.\n    add_delay: If True, adds delay to the instruction set.\n    filter_faulty: If True, this filters the non-operational qubits.\n\nReturns:\n    A ``Target`` instance.",
        "api_signature": "convert_to_target(configuration, properties, defaults, custom_name_mapping, add_delay, filter_faulty)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend_compat.py"
    },
    {
        "api_name": "_get_value",
        "full_api_name": "_get_value",
        "api_description": "",
        "api_signature": "_get_value(prop_dict, prop_name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend_compat.py"
    },
    {
        "api_name": "qubit_props_list_from_props",
        "full_api_name": "qubit_props_list_from_props",
        "api_description": "Uses BackendProperties to construct\nand return a list of QubitProperties.",
        "api_signature": "qubit_props_list_from_props(properties)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend_compat.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BackendV2Converter.__init__",
        "api_description": "Initialize a BackendV2 converter instance based on a BackendV1 instance.\n\nArgs:\n    backend: The input :class:`~.BackendV1` based backend to wrap in a\n        :class:`~.BackendV2` interface\n    name_mapping: An optional dictionary that maps custom gate/operation names in\n        ``backend`` to an :class:`~.Operation` object representing that\n        gate/operation. By default most standard gates names are mapped to the\n        standard gate object from :mod:`qiskit.circuit.library` this only needs\n        to be specified if the input ``backend`` defines gates in names outside\n        that set.\n    add_delay: If set to true a :class:`~qiskit.circuit.Delay` operation\n        will be added to the target as a supported operation for all\n        qubits\n    filter_faulty: If the :class:`~.BackendProperties` object (if present) for\n        ``backend`` has any qubits or gates flagged as non-operational filter\n        those from the output target.",
        "api_signature": "__init__(self, backend, name_mapping, add_delay, filter_faulty)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend_compat.py"
    },
    {
        "api_name": "target",
        "full_api_name": "BackendV2Converter.target",
        "api_description": "A :class:`qiskit.transpiler.Target` object for the backend.\n\n:rtype: Target",
        "api_signature": "target(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend_compat.py"
    },
    {
        "api_name": "max_circuits",
        "full_api_name": "BackendV2Converter.max_circuits",
        "api_description": "",
        "api_signature": "max_circuits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend_compat.py"
    },
    {
        "api_name": "_default_options",
        "full_api_name": "BackendV2Converter._default_options",
        "api_description": "",
        "api_signature": "_default_options(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend_compat.py"
    },
    {
        "api_name": "dtm",
        "full_api_name": "BackendV2Converter.dtm",
        "api_description": "",
        "api_signature": "dtm(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend_compat.py"
    },
    {
        "api_name": "meas_map",
        "full_api_name": "BackendV2Converter.meas_map",
        "api_description": "",
        "api_signature": "meas_map(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend_compat.py"
    },
    {
        "api_name": "drive_channel",
        "full_api_name": "BackendV2Converter.drive_channel",
        "api_description": "",
        "api_signature": "drive_channel(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend_compat.py"
    },
    {
        "api_name": "measure_channel",
        "full_api_name": "BackendV2Converter.measure_channel",
        "api_description": "",
        "api_signature": "measure_channel(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend_compat.py"
    },
    {
        "api_name": "acquire_channel",
        "full_api_name": "BackendV2Converter.acquire_channel",
        "api_description": "",
        "api_signature": "acquire_channel(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend_compat.py"
    },
    {
        "api_name": "control_channel",
        "full_api_name": "BackendV2Converter.control_channel",
        "api_description": "",
        "api_signature": "control_channel(self, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend_compat.py"
    },
    {
        "api_name": "run",
        "full_api_name": "BackendV2Converter.run",
        "api_description": "",
        "api_signature": "run(self, run_input)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/backend_compat.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "FakeOpenPulse3Q.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_openpulse_3q.py"
    },
    {
        "api_name": "defaults",
        "full_api_name": "FakeOpenPulse3Q.defaults",
        "api_description": "",
        "api_signature": "defaults(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_openpulse_3q.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PulseDefaults.__init__",
        "api_description": "Validate and reformat transport layer inputs to initialize.\nArgs:\n    qubit_freq_est: Estimated qubit frequencies in GHz.\n    meas_freq_est: Estimated measurement cavity frequencies in GHz.\n    buffer: Default buffer time (in units of dt) between pulses.\n    pulse_library: Pulse name and sample definitions.\n    cmd_def: Operation name and definition in terms of Commands.\n    meas_kernel: The measurement kernels\n    discriminator: The discriminators\n    **kwargs: Other attributes for the super class.",
        "api_signature": "__init__(self, qubit_freq_est, meas_freq_est, buffer, pulse_library, cmd_def, meas_kernel, discriminator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/generic_backend_v2.py"
    },
    {
        "api_name": "__getattr__",
        "full_api_name": "PulseDefaults.__getattr__",
        "api_description": "",
        "api_signature": "__getattr__(self, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/generic_backend_v2.py"
    },
    {
        "api_name": "to_dict",
        "full_api_name": "PulseDefaults.to_dict",
        "api_description": "Return a dictionary format representation of the PulseDefaults.\nReturns:\n    dict: The dictionary form of the PulseDefaults.",
        "api_signature": "to_dict(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/generic_backend_v2.py"
    },
    {
        "api_name": "from_dict",
        "full_api_name": "PulseDefaults.from_dict",
        "api_description": "Create a new PulseDefaults object from a dictionary.\n\nArgs:\n    data (dict): A dictionary representing the PulseDefaults\n                 to create. It will be in the same format as output by\n                 :meth:`to_dict`.\nReturns:\n    PulseDefaults: The PulseDefaults from the input dictionary.",
        "api_signature": "from_dict(cls, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/generic_backend_v2.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "PulseDefaults.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/generic_backend_v2.py"
    },
    {
        "api_name": "_to_complex",
        "full_api_name": "_to_complex",
        "api_description": "Convert the input value to type ``complex``.\nArgs:\n    value: Value to be converted.\nReturns:\n    Input value in ``complex``.\nRaises:\n    TypeError: If the input value is not in the expected format.",
        "api_signature": "_to_complex(value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/generic_backend_v2.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PulseLibraryItem.__init__",
        "api_description": "Instantiate a pulse library item.\n\nArgs:\n    name (str): A name for the pulse.\n    samples (list[complex]): A list of complex values defining pulse\n        shape.",
        "api_signature": "__init__(self, name, samples)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/generic_backend_v2.py"
    },
    {
        "api_name": "to_dict",
        "full_api_name": "PulseLibraryItem.to_dict",
        "api_description": "Return a dictionary format representation of the pulse library item.\n\nReturns:\n    dict: The dictionary form of the PulseLibraryItem.",
        "api_signature": "to_dict(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/generic_backend_v2.py"
    },
    {
        "api_name": "from_dict",
        "full_api_name": "PulseLibraryItem.from_dict",
        "api_description": "Create a new PulseLibraryItem object from a dictionary.\n\nArgs:\n    data (dict): A dictionary for the experiment config\n\nReturns:\n    PulseLibraryItem: The object from the input dictionary.",
        "api_signature": "from_dict(cls, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/generic_backend_v2.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "PulseLibraryItem.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/generic_backend_v2.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "PulseLibraryItem.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/generic_backend_v2.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "PulseLibraryItem.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/generic_backend_v2.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PulseQobjInstruction.__init__",
        "api_description": "Instantiate a new PulseQobjInstruction object.\n\nArgs:\n    name (str): The name of the instruction\n    t0 (int): Pulse start time in integer **dt** units.\n    ch (str): The channel to apply the pulse instruction.\n    conditional (int): The register to use for a conditional for this\n        instruction\n    val (complex): Complex value to apply, bounded by an absolute value\n        of 1.\n    phase (float): if a ``fc`` instruction, the frame change phase in\n        radians.\n    frequency (float): if a ``sf`` instruction, the frequency in Hz.\n    duration (int): The duration of the pulse in **dt** units.\n    qubits (list): A list of ``int`` representing the qubits the\n        instruction operates on\n    memory_slot (list): If a ``measure`` instruction this is a list\n        of ``int`` containing the list of memory slots to store the\n        measurement results in (must be the same length as qubits).\n        If a ``bfunc`` instruction this is a single ``int`` of the\n        memory slot to store the boolean function result in.\n    register_slot (list): If a ``measure`` instruction this is a list\n        of ``int`` containing the list of register slots in which to\n        store the measurement results (must be the same length as\n        qubits). If a ``bfunc`` instruction this is a single ``int``\n        of the register slot in which to store the result.\n    kernels (list): List of :class:`QobjMeasurementOption` objects\n        defining the measurement kernels and set of parameters if the\n        measurement level is 1 or 2. Only used for ``acquire``\n        instructions.\n    discriminators (list): A list of :class:`QobjMeasurementOption`\n        used to set the discriminators to be used if the measurement\n        level is 2. Only used for ``acquire`` instructions.\n    label (str): Label of instruction\n    type (str): Type of instruction\n    pulse_shape (str): The shape of the parametric pulse\n    parameters (dict): The parameters for a parametric pulse",
        "api_signature": "__init__(self, name, t0, ch, conditional, val, phase, duration, qubits, memory_slot, register_slot, kernels, discriminators, label, type, pulse_shape, parameters, frequency)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/generic_backend_v2.py"
    },
    {
        "api_name": "to_dict",
        "full_api_name": "PulseQobjInstruction.to_dict",
        "api_description": "Return a dictionary format representation of the Instruction.\n\nReturns:\n    dict: The dictionary form of the PulseQobjInstruction.",
        "api_signature": "to_dict(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/generic_backend_v2.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "PulseQobjInstruction.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/generic_backend_v2.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "PulseQobjInstruction.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/generic_backend_v2.py"
    },
    {
        "api_name": "from_dict",
        "full_api_name": "PulseQobjInstruction.from_dict",
        "api_description": "Create a new PulseQobjExperimentConfig object from a dictionary.\n\nArgs:\n    data (dict): A dictionary for the experiment config\n\nReturns:\n    PulseQobjInstruction: The object from the input dictionary.",
        "api_signature": "from_dict(cls, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/generic_backend_v2.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "PulseQobjInstruction.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/generic_backend_v2.py"
    },
    {
        "api_name": "_pulse_library",
        "full_api_name": "_pulse_library",
        "api_description": "",
        "api_signature": "_pulse_library()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/generic_backend_v2.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "GenericBackendV2.__init__",
        "api_description": "Args:\n    num_qubits: Number of qubits that will be used to construct the backend's target.\n        Note that, while there is no limit in the size of the target that can be\n        constructed, this backend runs on local noisy simulators, and these might\n        present limitations in the number of qubits that can be simulated.\n\n    basis_gates: List of basis gate names to be supported by\n        the target. These must be part of the standard qiskit circuit library.\n        The default set of basis gates is ``[\"id\", \"rz\", \"sx\", \"x\", \"cx\"]``\n        The ``\"reset\"``,  ``\"delay\"``, and ``\"measure\"`` instructions are\n        always supported by default, even if not specified via ``basis_gates``.\n\n    coupling_map: Optional coupling map\n        for the backend. Multiple formats are supported:\n\n        #. :class:`~.CouplingMap` instance\n        #. List, must be given as an edge list representing the two qubit interactions\n           supported by the backend, for example:\n           ``[[0, 1], [0, 3], [1, 2], [1, 5], [2, 5], [4, 1], [5, 3]]``\n\n        If ``coupling_map`` is specified, it must match the number of qubits\n        specified in ``num_qubits``. If ``coupling_map`` is not specified,\n        a fully connected coupling map will be generated with ``num_qubits``\n        qubits.\n\n    control_flow: Flag to enable control flow directives on the target\n        (defaults to False).\n\n    calibrate_instructions: Instruction calibration settings, this argument\n        supports both boolean and :class:`.InstructionScheduleMap` as\n        input types, and is ``None`` by default:\n\n        #. If ``calibrate_instructions==None``, no calibrations will be added to the target.\n        #. If ``calibrate_instructions==True``, all gates will be calibrated for all\n            qubits using the default pulse schedules generated internally.\n        #. If ``calibrate_instructions==False``, all gates will be \"calibrated\" for\n            all qubits with an empty pulse schedule.\n        #. If an :class:`.InstructionScheduleMap` instance is given, the calibrations\n            in this instruction schedule map will be appended to the target\n            instead of the default pulse schedules (this allows for custom calibrations).\n\n    dtm: System time resolution of output signals in nanoseconds.\n        None by default.\n\n    seed: Optional seed for generation of default values.\n\n    pulse_channels: If true, sets default pulse channel information on the backend.\n\n    noise_info: If true, associates gates and qubits with default noise information.",
        "api_signature": "__init__(self, num_qubits, basis_gates)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/generic_backend_v2.py"
    },
    {
        "api_name": "target",
        "full_api_name": "GenericBackendV2.target",
        "api_description": "",
        "api_signature": "target(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/generic_backend_v2.py"
    },
    {
        "api_name": "max_circuits",
        "full_api_name": "GenericBackendV2.max_circuits",
        "api_description": "",
        "api_signature": "max_circuits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/generic_backend_v2.py"
    },
    {
        "api_name": "dtm",
        "full_api_name": "GenericBackendV2.dtm",
        "api_description": "Return the system time resolution of output signals",
        "api_signature": "dtm(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/generic_backend_v2.py"
    },
    {
        "api_name": "meas_map",
        "full_api_name": "GenericBackendV2.meas_map",
        "api_description": "",
        "api_signature": "meas_map(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/generic_backend_v2.py"
    },
    {
        "api_name": "_build_default_channels",
        "full_api_name": "GenericBackendV2._build_default_channels",
        "api_description": "",
        "api_signature": "_build_default_channels(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/generic_backend_v2.py"
    },
    {
        "api_name": "_get_noise_defaults",
        "full_api_name": "GenericBackendV2._get_noise_defaults",
        "api_description": "Return noise default values/ranges for duration and error of supported\ninstructions. There are two possible formats:\n    - (min_duration, max_duration, min_error, max_error),\n      if the defaults are ranges.\n    - (duration, error), if the defaults are fixed values.",
        "api_signature": "_get_noise_defaults(self, name, num_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/generic_backend_v2.py"
    },
    {
        "api_name": "_get_calibration_sequence",
        "full_api_name": "GenericBackendV2._get_calibration_sequence",
        "api_description": "Return calibration pulse sequence for given instruction (defined by name and num_qubits)\nacting on qargs.",
        "api_signature": "_get_calibration_sequence(self, inst, num_qubits, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/generic_backend_v2.py"
    },
    {
        "api_name": "_generate_calibration_defaults",
        "full_api_name": "GenericBackendV2._generate_calibration_defaults",
        "api_description": "Generate pulse calibration defaults as specified with `self._calibrate_instructions`.\nIf `self._calibrate_instructions` is True, the pulse schedules will be generated from\na series of default calibration sequences. If `self._calibrate_instructions` is False,\nthe pulse schedules will contain empty calibration sequences, but still be generated and\nadded to the target.",
        "api_signature": "_generate_calibration_defaults(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/generic_backend_v2.py"
    },
    {
        "api_name": "_build_generic_target",
        "full_api_name": "GenericBackendV2._build_generic_target",
        "api_description": "This method generates a :class:`~.Target` instance with\ndefault qubit, instruction and calibration properties.",
        "api_signature": "_build_generic_target(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/generic_backend_v2.py"
    },
    {
        "api_name": "_add_noisy_instruction_to_target",
        "full_api_name": "GenericBackendV2._add_noisy_instruction_to_target",
        "api_description": "Add instruction properties to target for specified instruction.\n\nArgs:\n    instruction: Instance of instruction to be added to the target\n    noise_params: Error and duration noise values/ranges to\n        include in instruction properties.\n    calibration_inst_map: Instruction schedule map with calibration defaults",
        "api_signature": "_add_noisy_instruction_to_target(self, instruction, noise_params, calibration_inst_map)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/generic_backend_v2.py"
    },
    {
        "api_name": "run",
        "full_api_name": "GenericBackendV2.run",
        "api_description": "Run on the backend using a simulator.\n\nThis method runs circuit jobs (an individual or a list of :class:`~.QuantumCircuit`\n) and pulse jobs (an individual or a list of :class:`~.Schedule` or\n:class:`~.ScheduleBlock`) using :class:`~.BasicSimulator` or Aer simulator and returns a\n:class:`~qiskit.providers.Job` object.\n\nIf qiskit-aer is installed, jobs will be run using the ``AerSimulator`` with\nnoise model of the backend. Otherwise, jobs will be run using the\n``BasicSimulator`` simulator without noise.\n\nNoisy simulations of pulse jobs are not yet supported in :class:`~.GenericBackendV2`.\n\nArgs:\n    run_input (QuantumCircuit or Schedule or ScheduleBlock or list): An\n        individual or a list of\n        :class:`~qiskit.circuit.QuantumCircuit`,\n        :class:`~qiskit.pulse.ScheduleBlock`, or\n        :class:`~qiskit.pulse.Schedule` objects to run on the backend.\n    options: Any kwarg options to pass to the backend for running the\n        config. If a key is also present in the options\n        attribute/object, then the expectation is that the value\n        specified will be used instead of what's set in the options\n        object.\n\nReturns:\n    Job: The job object for the run\n\nRaises:\n    QiskitError: If a pulse job is supplied and qiskit_aer is not installed.",
        "api_signature": "run(self, run_input)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/generic_backend_v2.py"
    },
    {
        "api_name": "_setup_sim",
        "full_api_name": "GenericBackendV2._setup_sim",
        "api_description": "",
        "api_signature": "_setup_sim(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/generic_backend_v2.py"
    },
    {
        "api_name": "_default_options",
        "full_api_name": "GenericBackendV2._default_options",
        "api_description": "",
        "api_signature": "_default_options(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/generic_backend_v2.py"
    },
    {
        "api_name": "drive_channel",
        "full_api_name": "GenericBackendV2.drive_channel",
        "api_description": "",
        "api_signature": "drive_channel(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/generic_backend_v2.py"
    },
    {
        "api_name": "measure_channel",
        "full_api_name": "GenericBackendV2.measure_channel",
        "api_description": "",
        "api_signature": "measure_channel(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/generic_backend_v2.py"
    },
    {
        "api_name": "acquire_channel",
        "full_api_name": "GenericBackendV2.acquire_channel",
        "api_description": "",
        "api_signature": "acquire_channel(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/generic_backend_v2.py"
    },
    {
        "api_name": "control_channel",
        "full_api_name": "GenericBackendV2.control_channel",
        "api_description": "",
        "api_signature": "control_channel(self, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/generic_backend_v2.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "FakeOpenPulse2Q.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_openpulse_2q.py"
    },
    {
        "api_name": "defaults",
        "full_api_name": "FakeOpenPulse2Q.defaults",
        "api_description": "Return the default pulse-related settings provided by the backend (such as gate\nto Schedule mappings).",
        "api_signature": "defaults(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_openpulse_2q.py"
    },
    {
        "api_name": "properties",
        "full_api_name": "FakeOpenPulse2Q.properties",
        "api_description": "Return the measured characteristics of the backend.",
        "api_signature": "properties(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_openpulse_2q.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "FakeQasmBackend.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_qasm_backend.py"
    },
    {
        "api_name": "properties",
        "full_api_name": "FakeQasmBackend.properties",
        "api_description": "Returns a snapshot of device properties",
        "api_signature": "properties(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_qasm_backend.py"
    },
    {
        "api_name": "_get_conf_from_json",
        "full_api_name": "FakeQasmBackend._get_conf_from_json",
        "api_description": "",
        "api_signature": "_get_conf_from_json(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_qasm_backend.py"
    },
    {
        "api_name": "_set_props_from_json",
        "full_api_name": "FakeQasmBackend._set_props_from_json",
        "api_description": "",
        "api_signature": "_set_props_from_json(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_qasm_backend.py"
    },
    {
        "api_name": "_load_json",
        "full_api_name": "FakeQasmBackend._load_json",
        "api_description": "",
        "api_signature": "_load_json(self, filename)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_qasm_backend.py"
    },
    {
        "api_name": "_get_config_from_dict",
        "full_api_name": "FakeQasmBackend._get_config_from_dict",
        "api_description": "",
        "api_signature": "_get_config_from_dict(self, conf)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_qasm_backend.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Fake1Q.__init__",
        "api_description": "0",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_1q.py"
    },
    {
        "api_name": "defaults",
        "full_api_name": "FakePulseBackend.defaults",
        "api_description": "Returns a snapshot of device defaults",
        "api_signature": "defaults(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_pulse_backend.py"
    },
    {
        "api_name": "_set_defaults_from_json",
        "full_api_name": "FakePulseBackend._set_defaults_from_json",
        "api_description": "",
        "api_signature": "_set_defaults_from_json(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_pulse_backend.py"
    },
    {
        "api_name": "_get_config_from_dict",
        "full_api_name": "FakePulseBackend._get_config_from_dict",
        "api_description": "",
        "api_signature": "_get_config_from_dict(self, conf)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_pulse_backend.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "_Credentials.__init__",
        "api_description": "",
        "api_signature": "__init__(self, token, url)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_backend.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "FakeBackend.__init__",
        "api_description": "FakeBackend initializer.\n\nArgs:\n    configuration (BackendConfiguration): backend configuration\n    time_alive (int): time to wait before returning result",
        "api_signature": "__init__(self, configuration, time_alive)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_backend.py"
    },
    {
        "api_name": "_setup_sim",
        "full_api_name": "FakeBackend._setup_sim",
        "api_description": "",
        "api_signature": "_setup_sim(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_backend.py"
    },
    {
        "api_name": "properties",
        "full_api_name": "FakeBackend.properties",
        "api_description": "Return backend properties",
        "api_signature": "properties(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_backend.py"
    },
    {
        "api_name": "_default_options",
        "full_api_name": "FakeBackend._default_options",
        "api_description": "",
        "api_signature": "_default_options(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_backend.py"
    },
    {
        "api_name": "run",
        "full_api_name": "FakeBackend.run",
        "api_description": "Main job in simulator",
        "api_signature": "run(self, run_input)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/fake_backend.py"
    },
    {
        "api_name": "convert_to_target",
        "full_api_name": "convert_to_target",
        "api_description": "Uses configuration, properties and pulse defaults dicts\nto construct and return Target class.",
        "api_signature": "convert_to_target(conf_dict, props_dict, defs_dict)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/utils/backend_converter.py"
    },
    {
        "api_name": "qubit_props_from_props",
        "full_api_name": "qubit_props_from_props",
        "api_description": "Returns a dictionary of `qiskit.providers.backend.QubitProperties` using\na backend properties dictionary created by loading props.json payload.",
        "api_signature": "qubit_props_from_props(properties)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/utils/backend_converter.py"
    },
    {
        "api_name": "decode_pulse_defaults",
        "full_api_name": "decode_pulse_defaults",
        "api_description": "Decode pulse defaults data.\n\nArgs:\n    defaults: A ``PulseDefaults`` in dictionary format.",
        "api_signature": "decode_pulse_defaults(defaults)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/utils/json_decoder.py"
    },
    {
        "api_name": "decode_backend_properties",
        "full_api_name": "decode_backend_properties",
        "api_description": "Decode backend properties.\n\nArgs:\n    properties: A ``BackendProperties`` in dictionary format.",
        "api_signature": "decode_backend_properties(properties)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/utils/json_decoder.py"
    },
    {
        "api_name": "decode_backend_configuration",
        "full_api_name": "decode_backend_configuration",
        "api_description": "Decode backend configuration.\n\nArgs:\n    config: A ``QasmBackendConfiguration`` or ``PulseBackendConfiguration``\n        in dictionary format.",
        "api_signature": "decode_backend_configuration(config)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/utils/json_decoder.py"
    },
    {
        "api_name": "_to_complex",
        "full_api_name": "_to_complex",
        "api_description": "Convert the input value to type ``complex``.\n\nArgs:\n    value: Value to be converted.\n\nReturns:\n    Input value in ``complex``.\n\nRaises:\n    TypeError: If the input value is not in the expected format.",
        "api_signature": "_to_complex(value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/utils/json_decoder.py"
    },
    {
        "api_name": "_decode_pulse_library_item",
        "full_api_name": "_decode_pulse_library_item",
        "api_description": "Decode a pulse library item.\n\nArgs:\n    pulse_library_item: A ``PulseLibraryItem`` in dictionary format.",
        "api_signature": "_decode_pulse_library_item(pulse_library_item)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/utils/json_decoder.py"
    },
    {
        "api_name": "_decode_pulse_qobj_instr",
        "full_api_name": "_decode_pulse_qobj_instr",
        "api_description": "Decode a pulse Qobj instruction.\n\nArgs:\n    pulse_qobj_instr: A ``PulseQobjInstruction`` in dictionary format.",
        "api_signature": "_decode_pulse_qobj_instr(pulse_qobj_instr)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/fake_provider/utils/json_decoder.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BasicProviderJob.__init__",
        "api_description": "",
        "api_signature": "__init__(self, backend, job_id, result)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basic_provider/basic_provider_job.py"
    },
    {
        "api_name": "submit",
        "full_api_name": "BasicProviderJob.submit",
        "api_description": "Submit the job to the backend for execution.\n\nRaises:\n    JobError: if trying to re-submit the job.",
        "api_signature": "submit(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basic_provider/basic_provider_job.py"
    },
    {
        "api_name": "result",
        "full_api_name": "BasicProviderJob.result",
        "api_description": "Get job result .\n\nReturns:\n    qiskit.result.Result: Result object",
        "api_signature": "result(self, timeout)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basic_provider/basic_provider_job.py"
    },
    {
        "api_name": "status",
        "full_api_name": "BasicProviderJob.status",
        "api_description": "Gets the status of the job by querying the Python's future\n\nReturns:\n    qiskit.providers.JobStatus: The current JobStatus",
        "api_signature": "status(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basic_provider/basic_provider_job.py"
    },
    {
        "api_name": "backend",
        "full_api_name": "BasicProviderJob.backend",
        "api_description": "Return the instance of the backend used for this job.",
        "api_signature": "backend(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basic_provider/basic_provider_job.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BasicProviderError.__init__",
        "api_description": "Set the error message.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basic_provider/exceptions.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "BasicProviderError.__str__",
        "api_description": "Return the message.",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basic_provider/exceptions.py"
    },
    {
        "api_name": "single_gate_matrix",
        "full_api_name": "single_gate_matrix",
        "api_description": "Get the matrix for a single qubit.\n\nArgs:\n    gate: the single qubit gate name\n    params: the operation parameters op['params']\nReturns:\n    array: A numpy array representing the matrix\nRaises:\n    QiskitError: If a gate outside the supported set is passed in for the\n        ``Gate`` argument.",
        "api_signature": "single_gate_matrix(gate, params)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basic_provider/basic_provider_tools.py"
    },
    {
        "api_name": "einsum_matmul_index",
        "full_api_name": "einsum_matmul_index",
        "api_description": "Return the index string for Numpy.einsum matrix-matrix multiplication.\n\nThe returned indices are to perform a matrix multiplication A.B where\nthe matrix A is an M-qubit matrix, matrix B is an N-qubit matrix, and\nM <= N, and identity matrices are implied on the subsystems where A has no\nsupport on B.\n\nArgs:\n    gate_indices (list[int]): the indices of the right matrix subsystems\n                               to contract with the left matrix.\n    number_of_qubits (int): the total number of qubits for the right matrix.\n\nReturns:\n    str: An indices string for the Numpy.einsum function.",
        "api_signature": "einsum_matmul_index(gate_indices, number_of_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basic_provider/basic_provider_tools.py"
    },
    {
        "api_name": "einsum_vecmul_index",
        "full_api_name": "einsum_vecmul_index",
        "api_description": "Return the index string for Numpy.einsum matrix-vector multiplication.\n\nThe returned indices are to perform a matrix multiplication A.v where\nthe matrix A is an M-qubit matrix, vector v is an N-qubit vector, and\nM <= N, and identity matrices are implied on the subsystems where A has no\nsupport on v.\n\nArgs:\n    gate_indices (list[int]): the indices of the right matrix subsystems\n                              to contract with the left matrix.\n    number_of_qubits (int): the total number of qubits for the right matrix.\n\nReturns:\n    str: An indices string for the Numpy.einsum function.",
        "api_signature": "einsum_vecmul_index(gate_indices, number_of_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basic_provider/basic_provider_tools.py"
    },
    {
        "api_name": "_einsum_matmul_index_helper",
        "full_api_name": "_einsum_matmul_index_helper",
        "api_description": "Return the index string for Numpy.einsum matrix multiplication.\n\nThe returned indices are to perform a matrix multiplication A.v where\nthe matrix A is an M-qubit matrix, matrix v is an N-qubit vector, and\nM <= N, and identity matrices are implied on the subsystems where A has no\nsupport on v.\n\nArgs:\n    gate_indices (list[int]): the indices of the right matrix subsystems\n                               to contract with the left matrix.\n    number_of_qubits (int): the total number of qubits for the right matrix.\n\nReturns:\n    tuple: (mat_left, mat_right, tens_in, tens_out) of index strings for\n    that may be combined into a Numpy.einsum function string.\n\nRaises:\n    QiskitError: if the total number of qubits plus the number of\n    contracted indices is greater than 26.",
        "api_signature": "_einsum_matmul_index_helper(gate_indices, number_of_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basic_provider/basic_provider_tools.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BasicProvider.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basic_provider/basic_provider.py"
    },
    {
        "api_name": "get_backend",
        "full_api_name": "BasicProvider.get_backend",
        "api_description": "",
        "api_signature": "get_backend(self, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basic_provider/basic_provider.py"
    },
    {
        "api_name": "backends",
        "full_api_name": "BasicProvider.backends",
        "api_description": "",
        "api_signature": "backends(self, name, filters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basic_provider/basic_provider.py"
    },
    {
        "api_name": "_verify_backends",
        "full_api_name": "BasicProvider._verify_backends",
        "api_description": "Return the test backends in `BACKENDS` that are\neffectively available (as some of them might depend on the presence\nof an optional dependency or on the existence of a binary).\n\nReturns:\n    dict[str:Backend]: a dict of test backend instances for\n        the backends that could be instantiated, keyed by backend name.",
        "api_signature": "_verify_backends(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basic_provider/basic_provider.py"
    },
    {
        "api_name": "_get_backend_instance",
        "full_api_name": "BasicProvider._get_backend_instance",
        "api_description": "Return an instance of a backend from its class.\n\nArgs:\n    backend_cls (class): backend class.\nReturns:\n    Backend: a backend instance.\nRaises:\n    QiskitError: if the backend could not be instantiated.",
        "api_signature": "_get_backend_instance(self, backend_cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basic_provider/basic_provider.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "BasicProvider.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basic_provider/basic_provider.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BasicSimulator.__init__",
        "api_description": "Args:\n    provider: An optional backwards reference to the\n        :class:`~qiskit.providers.Provider` object that the backend\n        is from.\n    target: An optional target to configure the simulator.\n    fields: kwargs for the values to use to override the default\n        options.\n\nRaises:\n    AttributeError: If a field is specified that's outside the backend's\n        options.",
        "api_signature": "__init__(self, provider, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basic_provider/basic_simulator.py"
    },
    {
        "api_name": "max_circuits",
        "full_api_name": "BasicSimulator.max_circuits",
        "api_description": "",
        "api_signature": "max_circuits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basic_provider/basic_simulator.py"
    },
    {
        "api_name": "target",
        "full_api_name": "BasicSimulator.target",
        "api_description": "",
        "api_signature": "target(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basic_provider/basic_simulator.py"
    },
    {
        "api_name": "_build_basic_target",
        "full_api_name": "BasicSimulator._build_basic_target",
        "api_description": "Helper method that returns a minimal target with a basis gate set but\nno coupling map, instruction properties or calibrations.\n\nReturns:\n    The configured target.",
        "api_signature": "_build_basic_target(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basic_provider/basic_simulator.py"
    },
    {
        "api_name": "configuration",
        "full_api_name": "BasicSimulator.configuration",
        "api_description": "Return the simulator backend configuration.\n\nReturns:\n    The configuration for the backend.",
        "api_signature": "configuration(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basic_provider/basic_simulator.py"
    },
    {
        "api_name": "_default_options",
        "full_api_name": "BasicSimulator._default_options",
        "api_description": "",
        "api_signature": "_default_options(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basic_provider/basic_simulator.py"
    },
    {
        "api_name": "_add_unitary",
        "full_api_name": "BasicSimulator._add_unitary",
        "api_description": "Apply an N-qubit unitary matrix.\n\nArgs:\n    gate (matrix_like): an N-qubit unitary matrix\n    qubits (list): the list of N-qubits.",
        "api_signature": "_add_unitary(self, gate, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basic_provider/basic_simulator.py"
    },
    {
        "api_name": "_get_measure_outcome",
        "full_api_name": "BasicSimulator._get_measure_outcome",
        "api_description": "Simulate the outcome of measurement of a qubit.\n\nArgs:\n    qubit: the qubit to measure\n\nReturn:\n    pair (outcome, probability) where outcome is '0' or '1' and\n    probability is the probability of the returned outcome.",
        "api_signature": "_get_measure_outcome(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basic_provider/basic_simulator.py"
    },
    {
        "api_name": "_add_sample_measure",
        "full_api_name": "BasicSimulator._add_sample_measure",
        "api_description": "Generate memory samples from current statevector.\n\nArgs:\n    measure_params: List of (qubit, cmembit) values for\n                           measure instructions to sample.\n    num_samples: The number of memory samples to generate.\n\nReturns:\n    A list of memory values in hex format.",
        "api_signature": "_add_sample_measure(self, measure_params, num_samples)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basic_provider/basic_simulator.py"
    },
    {
        "api_name": "_add_measure",
        "full_api_name": "BasicSimulator._add_measure",
        "api_description": "Apply a measure instruction to a qubit.\n\nArgs:\n    qubit: qubit is the qubit measured.\n    cmembit: is the classical memory bit to store outcome in.\n    cregbit: is the classical register bit to store outcome in.",
        "api_signature": "_add_measure(self, qubit, cmembit, cregbit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basic_provider/basic_simulator.py"
    },
    {
        "api_name": "_add_reset",
        "full_api_name": "BasicSimulator._add_reset",
        "api_description": "Apply a reset instruction to a qubit.\n\nArgs:\n    qubit: the qubit being rest\n\nThis is done by doing a simulating a measurement\noutcome and projecting onto the outcome state while\nrenormalizing.",
        "api_signature": "_add_reset(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basic_provider/basic_simulator.py"
    },
    {
        "api_name": "_validate_initial_statevector",
        "full_api_name": "BasicSimulator._validate_initial_statevector",
        "api_description": "Validate an initial statevector",
        "api_signature": "_validate_initial_statevector(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basic_provider/basic_simulator.py"
    },
    {
        "api_name": "_set_options",
        "full_api_name": "BasicSimulator._set_options",
        "api_description": "Set the backend options for all experiments in a qobj",
        "api_signature": "_set_options(self, qobj_config, backend_options)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basic_provider/basic_simulator.py"
    },
    {
        "api_name": "_initialize_statevector",
        "full_api_name": "BasicSimulator._initialize_statevector",
        "api_description": "Set the initial statevector for simulation",
        "api_signature": "_initialize_statevector(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basic_provider/basic_simulator.py"
    },
    {
        "api_name": "_validate_measure_sampling",
        "full_api_name": "BasicSimulator._validate_measure_sampling",
        "api_description": "Determine if measure sampling is allowed for an experiment\n\nArgs:\n    experiment: a qobj experiment.",
        "api_signature": "_validate_measure_sampling(self, experiment)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basic_provider/basic_simulator.py"
    },
    {
        "api_name": "run",
        "full_api_name": "BasicSimulator.run",
        "api_description": "Run on the backend.\n\nArgs:\n    run_input: payload of the experiment\n    backend_options: backend options\n\nReturns:\n    BasicProviderJob: derived from BaseJob\n\nAdditional Information:\n    backend_options: Is a dict of options for the backend. It may contain\n        * \"initial_statevector\": vector_like\n\n    The \"initial_statevector\" option specifies a custom initial\n    initial statevector for the simulator to be used instead of the all\n    zero state. This size of this vector must be correct for the number\n    of qubits in ``run_input`` parameter.\n\n    Example::\n\n        backend_options = {\n            \"initial_statevector\": np.array([1, 0, 0, 1j]) / math.sqrt(2),\n        }",
        "api_signature": "run(self, run_input)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basic_provider/basic_simulator.py"
    },
    {
        "api_name": "_run_job",
        "full_api_name": "BasicSimulator._run_job",
        "api_description": "Run experiments in qobj\n\nArgs:\n    job_id: unique id for the job.\n    qobj: job description\n\nReturns:\n    Result object",
        "api_signature": "_run_job(self, job_id, qobj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basic_provider/basic_simulator.py"
    },
    {
        "api_name": "run_experiment",
        "full_api_name": "BasicSimulator.run_experiment",
        "api_description": "Run an experiment (circuit) and return a single experiment result.\n\nArgs:\n    experiment: experiment from qobj experiments list\n\nReturns:\n     A result dictionary which looks something like::\n\n        {\n        \"name\": name of this experiment (obtained from qobj.experiment header)\n        \"seed\": random seed used for simulation\n        \"shots\": number of shots used in the simulation\n        \"data\":\n            {\n            \"counts\": {'0x9: 5, ...},\n            \"memory\": ['0x9', '0xF', '0x1D', ..., '0x9']\n            },\n        \"status\": status string for the simulation\n        \"success\": boolean\n        \"time_taken\": simulation time of this single experiment\n        }\nRaises:\n    BasicProviderError: if an error occurred.",
        "api_signature": "run_experiment(self, experiment)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basic_provider/basic_simulator.py"
    },
    {
        "api_name": "_validate",
        "full_api_name": "BasicSimulator._validate",
        "api_description": "Semantic validations of the qobj which cannot be done via schemas.",
        "api_signature": "_validate(self, qobj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/basic_provider/basic_simulator.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "GateConfig.__init__",
        "api_description": "Initialize a GateConfig object\n\nArgs:\n    name (str): the gate name as it will be referred to in OpenQASM.\n    parameters (list): variable names for the gate parameters (if any)\n                       as a list of strings.\n    qasm_def (str): definition of this gate in terms of OpenQASM 2 primitives U and CX.\n    coupling_map (list): An optional coupling map for the gate. In\n        the form of a list of lists of integers representing the qubit\n        groupings which are coupled by this gate.\n    latency_map (list): An optional map of latency for the gate. In the\n        the form of a list of lists of integers of either 0 or 1\n        representing an array of dimension\n        len(coupling_map) X n_registers that specifies the register\n        latency (1: fast, 0: slow) conditional operations on the gate\n    conditional (bool): Optionally specify whether this gate supports\n        conditional operations (true/false). If this is not specified,\n        then the gate inherits the conditional property of the backend.\n    description (str): Description of the gate operation",
        "api_signature": "__init__(self, name, parameters, qasm_def, coupling_map, latency_map, conditional, description)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendconfiguration.py"
    },
    {
        "api_name": "from_dict",
        "full_api_name": "GateConfig.from_dict",
        "api_description": "Create a new GateConfig object from a dictionary.\n\nArgs:\n    data (dict): A dictionary representing the GateConfig to create.\n                 It will be in the same format as output by\n                 :func:`to_dict`.\n\nReturns:\n    GateConfig: The GateConfig from the input dictionary.",
        "api_signature": "from_dict(cls, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendconfiguration.py"
    },
    {
        "api_name": "to_dict",
        "full_api_name": "GateConfig.to_dict",
        "api_description": "Return a dictionary format representation of the GateConfig.\n\nReturns:\n    dict: The dictionary form of the GateConfig.",
        "api_signature": "to_dict(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendconfiguration.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "GateConfig.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendconfiguration.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "GateConfig.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendconfiguration.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "UchannelLO.__init__",
        "api_description": "Initialize a UchannelLOSchema object\n\nArgs:\n    q (int): Qubit that scale corresponds too. Must be >= 0.\n    scale (complex): Scale factor for qubit frequency.\n\nRaises:\n    QiskitError: If q is < 0",
        "api_signature": "__init__(self, q, scale)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendconfiguration.py"
    },
    {
        "api_name": "from_dict",
        "full_api_name": "UchannelLO.from_dict",
        "api_description": "Create a new UchannelLO object from a dictionary.\n\nArgs:\n    data (dict): A dictionary representing the UChannelLO to\n        create. It will be in the same format as output by\n        :func:`to_dict`.\n\nReturns:\n    UchannelLO: The UchannelLO from the input dictionary.",
        "api_signature": "from_dict(cls, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendconfiguration.py"
    },
    {
        "api_name": "to_dict",
        "full_api_name": "UchannelLO.to_dict",
        "api_description": "Return a dictionary format representation of the UChannelLO.\n\nReturns:\n    dict: The dictionary form of the UChannelLO.",
        "api_signature": "to_dict(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendconfiguration.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "UchannelLO.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendconfiguration.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "UchannelLO.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendconfiguration.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QasmBackendConfiguration.__init__",
        "api_description": "Initialize a QasmBackendConfiguration Object\n\nArgs:\n    backend_name (str): The backend name\n    backend_version (str): The backend version in the form X.Y.Z\n    n_qubits (int): the number of qubits for the backend\n    basis_gates (list): The list of strings for the basis gates of the\n        backends\n    gates (list): The list of GateConfig objects for the basis gates of\n        the backend\n    local (bool): True if the backend is local or False if remote\n    simulator (bool): True if the backend is a simulator\n    conditional (bool): True if the backend supports conditional\n        operations\n    open_pulse (bool): True if the backend supports OpenPulse\n    memory (bool): True if the backend supports memory\n    max_shots (int): The maximum number of shots allowed on the backend\n    coupling_map (list): The coupling map for the device\n    supported_instructions (List[str]): Instructions supported by the backend.\n    dynamic_reprate_enabled (bool): whether delay between programs can be set dynamically\n        (ie via ``rep_delay``). Defaults to False.\n    rep_delay_range (List[float]): 2d list defining supported range of repetition\n        delays for backend in \u03bcs. First entry is lower end of the range, second entry is\n        higher end of the range. Optional, but will be specified when\n        ``dynamic_reprate_enabled=True``.\n    default_rep_delay (float): Value of ``rep_delay`` if not specified by user and\n        ``dynamic_reprate_enabled=True``.\n    max_experiments (int): The maximum number of experiments per job\n    sample_name (str): Sample name for the backend\n    n_registers (int): Number of register slots available for feedback\n        (if conditional is True)\n    register_map (list): An array of dimension n_qubits X\n        n_registers that specifies whether a qubit can store a\n        measurement in a certain register slot.\n    configurable (bool): True if the backend is configurable, if the\n        backend is a simulator\n    credits_required (bool): True if backend requires credits to run a\n        job.\n    online_date (datetime.datetime): The date that the device went online\n    display_name (str): Alternate name field for the backend\n    description (str): A description for the backend\n    tags (list): A list of string tags to describe the backend\n    dt (float): Qubit drive channel timestep in nanoseconds.\n    dtm (float): Measurement drive channel timestep in nanoseconds.\n    processor_type (dict): Processor type for this backend. A dictionary of the\n        form ``{\"family\": <str>, \"revision\": <str>, segment: <str>}`` such as\n        ``{\"family\": \"Canary\", \"revision\": \"1.0\", segment: \"A\"}``.\n\n        - family: Processor family of this backend.\n        - revision: Revision version of this processor.\n        - segment: Segment this processor belongs to within a larger chip.\n    parametric_pulses (list): A list of pulse shapes which are supported on the backend.\n        For example: ``['gaussian', 'constant']``\n\n    **kwargs: optional fields",
        "api_signature": "__init__(self, backend_name, backend_version, n_qubits, basis_gates, gates, local, simulator, conditional, open_pulse, memory, max_shots, coupling_map, supported_instructions, dynamic_reprate_enabled, rep_delay_range, default_rep_delay, max_experiments, sample_name, n_registers, register_map, configurable, credits_required, online_date, display_name, description, tags, dt, dtm, processor_type, parametric_pulses)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendconfiguration.py"
    },
    {
        "api_name": "__getattr__",
        "full_api_name": "QasmBackendConfiguration.__getattr__",
        "api_description": "",
        "api_signature": "__getattr__(self, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendconfiguration.py"
    },
    {
        "api_name": "from_dict",
        "full_api_name": "QasmBackendConfiguration.from_dict",
        "api_description": "Create a new GateConfig object from a dictionary.\n\nArgs:\n    data (dict): A dictionary representing the GateConfig to create.\n                 It will be in the same format as output by\n                 :func:`to_dict`.\nReturns:\n    GateConfig: The GateConfig from the input dictionary.",
        "api_signature": "from_dict(cls, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendconfiguration.py"
    },
    {
        "api_name": "to_dict",
        "full_api_name": "QasmBackendConfiguration.to_dict",
        "api_description": "Return a dictionary format representation of the GateConfig.\n\nReturns:\n    dict: The dictionary form of the GateConfig.",
        "api_signature": "to_dict(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendconfiguration.py"
    },
    {
        "api_name": "num_qubits",
        "full_api_name": "QasmBackendConfiguration.num_qubits",
        "api_description": "Returns the number of qubits.\n\nIn future, `n_qubits` should be replaced in favor of `num_qubits` for consistent use\nthroughout Qiskit. Until this is properly refactored, this property serves as intermediate\nsolution.",
        "api_signature": "num_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendconfiguration.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "QasmBackendConfiguration.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendconfiguration.py"
    },
    {
        "api_name": "__contains__",
        "full_api_name": "QasmBackendConfiguration.__contains__",
        "api_description": "",
        "api_signature": "__contains__(self, item)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendconfiguration.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BackendConfiguration.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendconfiguration.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PulseBackendConfiguration.__init__",
        "api_description": "Initialize a backend configuration that contains all the extra configuration that is made\navailable for OpenPulse backends.\n\nArgs:\n    backend_name: backend name.\n    backend_version: backend version in the form X.Y.Z.\n    n_qubits: number of qubits.\n    basis_gates: list of basis gates names on the backend.\n    gates: list of basis gates on the backend.\n    local: backend is local or remote.\n    simulator: backend is a simulator.\n    conditional: backend supports conditional operations.\n    open_pulse: backend supports open pulse.\n    memory: backend supports memory.\n    max_shots: maximum number of shots supported.\n    coupling_map (list): The coupling map for the device\n    n_uchannels: Number of u-channels.\n    u_channel_lo: U-channel relationship on device los.\n    meas_levels: Supported measurement levels.\n    qubit_lo_range: Qubit lo ranges for each qubit with form (min, max) in GHz.\n    meas_lo_range: Measurement lo ranges for each qubit with form (min, max) in GHz.\n    dt: Qubit drive channel timestep in nanoseconds.\n    dtm: Measurement drive channel timestep in nanoseconds.\n    rep_times: Supported repetition times (program execution time) for backend in \u03bcs.\n    meas_kernels: Supported measurement kernels.\n    discriminators: Supported discriminators.\n    hamiltonian: An optional dictionary with fields characterizing the system hamiltonian.\n    channel_bandwidth (list): Bandwidth of all channels\n        (qubit, measurement, and U)\n    acquisition_latency (list): Array of dimension\n        n_qubits x n_registers. Latency (in units of dt) to write a\n        measurement result from qubit n into register slot m.\n    conditional_latency (list): Array of dimension n_channels\n        [d->u->m] x n_registers. Latency (in units of dt) to do a\n        conditional operation on channel n from register slot m\n    meas_map (list): Grouping of measurement which are multiplexed\n    max_experiments (int): The maximum number of experiments per job\n    sample_name (str): Sample name for the backend\n    n_registers (int): Number of register slots available for feedback\n        (if conditional is True)\n    register_map (list): An array of dimension n_qubits X\n        n_registers that specifies whether a qubit can store a\n        measurement in a certain register slot.\n    configurable (bool): True if the backend is configurable, if the\n        backend is a simulator\n    credits_required (bool): True if backend requires credits to run a\n        job.\n    online_date (datetime.datetime): The date that the device went online\n    display_name (str): Alternate name field for the backend\n    description (str): A description for the backend\n    tags (list): A list of string tags to describe the backend\n    channels: An optional dictionary containing information of each channel -- their\n        purpose, type, and qubits operated on.\n    **kwargs: Optional fields.",
        "api_signature": "__init__(self, backend_name, backend_version, n_qubits, basis_gates, gates, local, simulator, conditional, open_pulse, memory, max_shots, coupling_map, n_uchannels, u_channel_lo, meas_levels, qubit_lo_range, meas_lo_range, dt, dtm, rep_times, meas_kernels, discriminators, hamiltonian, channel_bandwidth, acquisition_latency, conditional_latency, meas_map, max_experiments, sample_name, n_registers, register_map, configurable, credits_required, online_date, display_name, description, tags, channels)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendconfiguration.py"
    },
    {
        "api_name": "from_dict",
        "full_api_name": "PulseBackendConfiguration.from_dict",
        "api_description": "Create a new GateConfig object from a dictionary.\n\nArgs:\n    data (dict): A dictionary representing the GateConfig to create.\n        It will be in the same format as output by :func:`to_dict`.\n\nReturns:\n    GateConfig: The GateConfig from the input dictionary.",
        "api_signature": "from_dict(cls, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendconfiguration.py"
    },
    {
        "api_name": "to_dict",
        "full_api_name": "PulseBackendConfiguration.to_dict",
        "api_description": "Return a dictionary format representation of the GateConfig.\n\nReturns:\n    dict: The dictionary form of the GateConfig.",
        "api_signature": "to_dict(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendconfiguration.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "PulseBackendConfiguration.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendconfiguration.py"
    },
    {
        "api_name": "sample_rate",
        "full_api_name": "PulseBackendConfiguration.sample_rate",
        "api_description": "Sample rate of the signal channels in Hz (1/dt).",
        "api_signature": "sample_rate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendconfiguration.py"
    },
    {
        "api_name": "control_channels",
        "full_api_name": "PulseBackendConfiguration.control_channels",
        "api_description": "Return the control channels",
        "api_signature": "control_channels(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendconfiguration.py"
    },
    {
        "api_name": "drive",
        "full_api_name": "PulseBackendConfiguration.drive",
        "api_description": "Return the drive channel for the given qubit.\n\nRaises:\n    BackendConfigurationError: If the qubit is not a part of the system.\n\nReturns:\n    Qubit drive channel.",
        "api_signature": "drive(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendconfiguration.py"
    },
    {
        "api_name": "measure",
        "full_api_name": "PulseBackendConfiguration.measure",
        "api_description": "Return the measure stimulus channel for the given qubit.\n\nRaises:\n    BackendConfigurationError: If the qubit is not a part of the system.\nReturns:\n    Qubit measurement stimulus line.",
        "api_signature": "measure(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendconfiguration.py"
    },
    {
        "api_name": "acquire",
        "full_api_name": "PulseBackendConfiguration.acquire",
        "api_description": "Return the acquisition channel for the given qubit.\n\nRaises:\n    BackendConfigurationError: If the qubit is not a part of the system.\nReturns:\n    Qubit measurement acquisition line.",
        "api_signature": "acquire(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendconfiguration.py"
    },
    {
        "api_name": "control",
        "full_api_name": "PulseBackendConfiguration.control",
        "api_description": "Return the secondary drive channel for the given qubit -- typically utilized for\ncontrolling multiqubit interactions. This channel is derived from other channels.\n\nArgs:\n    qubits: Tuple or list of qubits of the form `(control_qubit, target_qubit)`.\n\nRaises:\n    BackendConfigurationError: If the ``qubits`` is not a part of the system or if\n        the backend does not provide `channels` information in its configuration.\n\nReturns:\n    List of control channels.",
        "api_signature": "control(self, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendconfiguration.py"
    },
    {
        "api_name": "get_channel_qubits",
        "full_api_name": "PulseBackendConfiguration.get_channel_qubits",
        "api_description": "Return a list of indices for qubits which are operated on directly by the given ``channel``.\n\nRaises:\n    BackendConfigurationError: If ``channel`` is not a found or if\n        the backend does not provide `channels` information in its configuration.\n\nReturns:\n    List of qubits operated on my the given ``channel``.",
        "api_signature": "get_channel_qubits(self, channel)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendconfiguration.py"
    },
    {
        "api_name": "get_qubit_channels",
        "full_api_name": "PulseBackendConfiguration.get_qubit_channels",
        "api_description": "Return a list of channels which operate on the given ``qubit``.\n\nRaises:\n    BackendConfigurationError: If ``qubit`` is not a found or if\n        the backend does not provide `channels` information in its configuration.\n\nReturns:\n    List of ``Channel``\\s operated on my the given ``qubit``.",
        "api_signature": "get_qubit_channels(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendconfiguration.py"
    },
    {
        "api_name": "describe",
        "full_api_name": "PulseBackendConfiguration.describe",
        "api_description": "Return a basic description of the channel dependency. Derived channels are given weights\nwhich describe how their frames are linked to other frames.\nFor instance, the backend could be configured with this setting::\n\n    u_channel_lo = [\n        [UchannelLO(q=0, scale=1. + 0.j)],\n        [UchannelLO(q=0, scale=-1. + 0.j), UchannelLO(q=1, scale=1. + 0.j)]\n    ]\n\nThen, this method can be used as follows::\n\n    backend.configuration().describe(ControlChannel(1))\n    >>> {DriveChannel(0): -1, DriveChannel(1): 1}\n\nArgs:\n    channel: The derived channel to describe.\nRaises:\n    BackendConfigurationError: If channel is not a ControlChannel.\nReturns:\n    Control channel derivations.",
        "api_signature": "describe(self, channel)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendconfiguration.py"
    },
    {
        "api_name": "_parse_channels",
        "full_api_name": "PulseBackendConfiguration._parse_channels",
        "api_description": "Generates a dictionaries of ``Channel``\\s, and tuple of qubit(s) they operate on.\n\nArgs:\n    channels: An optional dictionary containing information of each channel -- their\n        purpose, type, and qubits operated on.\n\nReturns:\n    qubit_channel_map: Dictionary mapping tuple of qubit(s) to list of ``Channel``\\s.\n    channel_qubit_map: Dictionary mapping ``Channel`` to list of qubit(s).\n    control_channels: Dictionary mapping tuple of qubit(s), to list of\n        ``ControlChannel``\\s.",
        "api_signature": "_parse_channels(self, channels)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendconfiguration.py"
    },
    {
        "api_name": "_get_channel_prefix_index",
        "full_api_name": "PulseBackendConfiguration._get_channel_prefix_index",
        "api_description": "Return channel prefix and index from the given ``channel``.\n\nArgs:\n    channel: Name of channel.\n\nRaises:\n    BackendConfigurationError: If invalid channel name is found.\n\nReturn:\n    Channel name and index. For example, if ``channel=acquire0``, this method\n    returns ``acquire`` and ``0``.",
        "api_signature": "_get_channel_prefix_index(self, channel)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendconfiguration.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "JobStatus.__init__",
        "api_description": "",
        "api_signature": "__init__(self, job_id, status, status_msg)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/jobstatus.py"
    },
    {
        "api_name": "from_dict",
        "full_api_name": "JobStatus.from_dict",
        "api_description": "Create a new JobStatus object from a dictionary.\n\nArgs:\n    data (dict): A dictionary representing the JobStatus to create.\n                 It will be in the same format as output by\n                 :meth:`to_dict`.\n\nReturns:\n    JobStatus: The ``JobStatus`` from the input dictionary.",
        "api_signature": "from_dict(cls, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/jobstatus.py"
    },
    {
        "api_name": "to_dict",
        "full_api_name": "JobStatus.to_dict",
        "api_description": "Return a dictionary format representation of the JobStatus.\n\nReturns:\n    dict: The dictionary form of the JobStatus.",
        "api_signature": "to_dict(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/jobstatus.py"
    },
    {
        "api_name": "__getattr__",
        "full_api_name": "JobStatus.__getattr__",
        "api_description": "",
        "api_signature": "__getattr__(self, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/jobstatus.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Nduv.__init__",
        "api_description": "Initialize a new name-date-unit-value object\n\nArgs:\n    date (datetime.datetime): Date field\n    name (str): Name field\n    unit (str): Nduv unit\n    value (float): The value of the Nduv",
        "api_signature": "__init__(self, date, name, unit, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendproperties.py"
    },
    {
        "api_name": "from_dict",
        "full_api_name": "Nduv.from_dict",
        "api_description": "Create a new Nduv object from a dictionary.\n\nArgs:\n    data (dict): A dictionary representing the Nduv to create.\n                 It will be in the same format as output by\n                 :func:`to_dict`.\n\nReturns:\n    Nduv: The Nduv from the input dictionary.",
        "api_signature": "from_dict(cls, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendproperties.py"
    },
    {
        "api_name": "to_dict",
        "full_api_name": "Nduv.to_dict",
        "api_description": "Return a dictionary format representation of the object.\n\nReturns:\n    dict: The dictionary form of the Nduv.",
        "api_signature": "to_dict(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendproperties.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "Nduv.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendproperties.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "Nduv.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendproperties.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "GateProperties.__init__",
        "api_description": "Initialize a new :class:`GateProperties` object\n\nArgs:\n    qubits (list): A list of integers representing qubits\n    gate (str): The gates name\n    parameters (list): List of :class:`Nduv` objects for the\n        name-date-unit-value for the gate\n    kwargs: Optional additional fields",
        "api_signature": "__init__(self, qubits, gate, parameters)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendproperties.py"
    },
    {
        "api_name": "__getattr__",
        "full_api_name": "GateProperties.__getattr__",
        "api_description": "",
        "api_signature": "__getattr__(self, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendproperties.py"
    },
    {
        "api_name": "from_dict",
        "full_api_name": "GateProperties.from_dict",
        "api_description": "Create a new Gate object from a dictionary.\n\nArgs:\n    data (dict): A dictionary representing the Gate to create.\n                 It will be in the same format as output by\n                 :func:`to_dict`.\n\nReturns:\n    GateProperties: The Nduv from the input dictionary.",
        "api_signature": "from_dict(cls, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendproperties.py"
    },
    {
        "api_name": "to_dict",
        "full_api_name": "GateProperties.to_dict",
        "api_description": "Return a dictionary format representation of the BackendStatus.\n\nReturns:\n    dict: The dictionary form of the Gate.",
        "api_signature": "to_dict(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendproperties.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "GateProperties.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendproperties.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BackendProperties.__init__",
        "api_description": "Initialize a BackendProperties instance.\n\nArgs:\n    backend_name (str): Backend name.\n    backend_version (str): Backend version in the form X.Y.Z.\n    last_update_date (datetime.datetime or str): Last date/time that a property was\n        updated. If specified as a ``str``, it must be in ISO format.\n    qubits (list): System qubit parameters as a list of lists of\n                   :class:`Nduv` objects\n    gates (list): System gate parameters as a list of :class:`GateProperties`\n                  objects\n    general (list): General parameters as a list of :class:`Nduv`\n                    objects\n    kwargs: optional additional fields",
        "api_signature": "__init__(self, backend_name, backend_version, last_update_date, qubits, gates, general)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendproperties.py"
    },
    {
        "api_name": "__getattr__",
        "full_api_name": "BackendProperties.__getattr__",
        "api_description": "",
        "api_signature": "__getattr__(self, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendproperties.py"
    },
    {
        "api_name": "from_dict",
        "full_api_name": "BackendProperties.from_dict",
        "api_description": "Create a new BackendProperties object from a dictionary.\n\nArgs:\n    data (dict): A dictionary representing the BackendProperties to create.  It will be in\n        the same format as output by :meth:`to_dict`.\n\nReturns:\n    BackendProperties: The BackendProperties from the input dictionary.",
        "api_signature": "from_dict(cls, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendproperties.py"
    },
    {
        "api_name": "to_dict",
        "full_api_name": "BackendProperties.to_dict",
        "api_description": "Return a dictionary format representation of the BackendProperties.\n\nReturns:\n    dict: The dictionary form of the BackendProperties.",
        "api_signature": "to_dict(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendproperties.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "BackendProperties.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendproperties.py"
    },
    {
        "api_name": "gate_property",
        "full_api_name": "BackendProperties.gate_property",
        "api_description": "Return the property of the given gate.\n\nArgs:\n    gate: Name of the gate.\n    qubits: The qubit to find the property for.\n    name: Optionally used to specify which gate property to return.\n\nReturns:\n    Gate property as a tuple of the value and the time it was measured.\n\nRaises:\n    BackendPropertyError: If the property is not found or name is\n                          specified but qubit is not.",
        "api_signature": "gate_property(self, gate, qubits, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendproperties.py"
    },
    {
        "api_name": "faulty_qubits",
        "full_api_name": "BackendProperties.faulty_qubits",
        "api_description": "Return a list of faulty qubits.",
        "api_signature": "faulty_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendproperties.py"
    },
    {
        "api_name": "faulty_gates",
        "full_api_name": "BackendProperties.faulty_gates",
        "api_description": "Return a list of faulty gates.",
        "api_signature": "faulty_gates(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendproperties.py"
    },
    {
        "api_name": "is_gate_operational",
        "full_api_name": "BackendProperties.is_gate_operational",
        "api_description": "Return the operational status of the given gate.\n\nArgs:\n    gate: Name of the gate.\n    qubits: The qubit to find the operational status for.\n\nReturns:\n    bool: Operational status of the given gate. True if the gate is operational,\n    False otherwise.",
        "api_signature": "is_gate_operational(self, gate, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendproperties.py"
    },
    {
        "api_name": "gate_error",
        "full_api_name": "BackendProperties.gate_error",
        "api_description": "Return gate error estimates from backend properties.\n\nArgs:\n    gate: The gate for which to get the error.\n    qubits: The specific qubits for the gate.\n\nReturns:\n    Gate error of the given gate and qubit(s).",
        "api_signature": "gate_error(self, gate, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendproperties.py"
    },
    {
        "api_name": "gate_length",
        "full_api_name": "BackendProperties.gate_length",
        "api_description": "Return the duration of the gate in units of seconds.\n\nArgs:\n    gate: The gate for which to get the duration.\n    qubits: The specific qubits for the gate.\n\nReturns:\n    Gate length of the given gate and qubit(s).",
        "api_signature": "gate_length(self, gate, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendproperties.py"
    },
    {
        "api_name": "qubit_property",
        "full_api_name": "BackendProperties.qubit_property",
        "api_description": "Return the property of the given qubit.\n\nArgs:\n    qubit: The property to look for.\n    name: Optionally used to specify within the hierarchy which property to return.\n\nReturns:\n    Qubit property as a tuple of the value and the time it was measured.\n\nRaises:\n    BackendPropertyError: If the property is not found.",
        "api_signature": "qubit_property(self, qubit, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendproperties.py"
    },
    {
        "api_name": "t1",
        "full_api_name": "BackendProperties.t1",
        "api_description": "Return the T1 time of the given qubit.\n\nArgs:\n    qubit: Qubit for which to return the T1 time of.\n\nReturns:\n    T1 time of the given qubit.",
        "api_signature": "t1(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendproperties.py"
    },
    {
        "api_name": "t2",
        "full_api_name": "BackendProperties.t2",
        "api_description": "Return the T2 time of the given qubit.\n\nArgs:\n    qubit: Qubit for which to return the T2 time of.\n\nReturns:\n    T2 time of the given qubit.",
        "api_signature": "t2(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendproperties.py"
    },
    {
        "api_name": "frequency",
        "full_api_name": "BackendProperties.frequency",
        "api_description": "Return the frequency of the given qubit.\n\nArgs:\n    qubit: Qubit for which to return frequency of.\n\nReturns:\n    Frequency of the given qubit.",
        "api_signature": "frequency(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendproperties.py"
    },
    {
        "api_name": "readout_error",
        "full_api_name": "BackendProperties.readout_error",
        "api_description": "Return the readout error of the given qubit.\n\nArgs:\n    qubit: Qubit for which to return the readout error of.\n\nReturn:\n    Readout error of the given qubit.",
        "api_signature": "readout_error(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendproperties.py"
    },
    {
        "api_name": "readout_length",
        "full_api_name": "BackendProperties.readout_length",
        "api_description": "Return the readout length [sec] of the given qubit.\n\nArgs:\n    qubit: Qubit for which to return the readout length of.\n\nReturn:\n    Readout length of the given qubit.",
        "api_signature": "readout_length(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendproperties.py"
    },
    {
        "api_name": "is_qubit_operational",
        "full_api_name": "BackendProperties.is_qubit_operational",
        "api_description": "Return the operational status of the given qubit.\n\nArgs:\n    qubit: Qubit for which to return operational status of.\n\nReturns:\n    Operational status of the given qubit.",
        "api_signature": "is_qubit_operational(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendproperties.py"
    },
    {
        "api_name": "_apply_prefix",
        "full_api_name": "BackendProperties._apply_prefix",
        "api_description": "Given a SI unit prefix and value, apply the prefix to convert to\nstandard SI unit.\n\nArgs:\n    value: The number to apply prefix to.\n    unit: String prefix.\n\nReturns:\n    Converted value.\n\nRaises:\n    BackendPropertyError: If the units aren't recognized.",
        "api_signature": "_apply_prefix(self, value, unit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendproperties.py"
    },
    {
        "api_name": "__getattr__",
        "full_api_name": "__getattr__",
        "api_description": "",
        "api_signature": "__getattr__(name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/__init__.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "MeasurementKernel.__init__",
        "api_description": "Initialize a MeasurementKernel object\n\nArgs:\n    name (str): The name of the measurement kernel\n    params: The parameters of the measurement kernel",
        "api_signature": "__init__(self, name, params)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/pulsedefaults.py"
    },
    {
        "api_name": "to_dict",
        "full_api_name": "MeasurementKernel.to_dict",
        "api_description": "Return a dictionary format representation of the MeasurementKernel.\n\nReturns:\n    dict: The dictionary form of the MeasurementKernel.",
        "api_signature": "to_dict(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/pulsedefaults.py"
    },
    {
        "api_name": "from_dict",
        "full_api_name": "MeasurementKernel.from_dict",
        "api_description": "Create a new MeasurementKernel object from a dictionary.\n\nArgs:\n    data (dict): A dictionary representing the MeasurementKernel\n                 to create. It will be in the same format as output by\n                 :meth:`to_dict`.\n\nReturns:\n    MeasurementKernel: The MeasurementKernel from the input dictionary.",
        "api_signature": "from_dict(cls, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/pulsedefaults.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Discriminator.__init__",
        "api_description": "Initialize a Discriminator object\n\nArgs:\n    name (str): The name of the discriminator\n    params: The parameters of the discriminator",
        "api_signature": "__init__(self, name, params)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/pulsedefaults.py"
    },
    {
        "api_name": "to_dict",
        "full_api_name": "Discriminator.to_dict",
        "api_description": "Return a dictionary format representation of the Discriminator.\n\nReturns:\n    dict: The dictionary form of the Discriminator.",
        "api_signature": "to_dict(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/pulsedefaults.py"
    },
    {
        "api_name": "from_dict",
        "full_api_name": "Discriminator.from_dict",
        "api_description": "Create a new Discriminator object from a dictionary.\n\nArgs:\n    data (dict): A dictionary representing the Discriminator\n                 to create. It will be in the same format as output by\n                 :meth:`to_dict`.\n\nReturns:\n    Discriminator: The Discriminator from the input dictionary.",
        "api_signature": "from_dict(cls, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/pulsedefaults.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Command.__init__",
        "api_description": "Initialize a Command object\n\nArgs:\n    name (str): The name of the command\n    qubits: The qubits for the command\n    sequence (PulseQobjInstruction): The sequence for the Command\n    kwargs: Optional additional fields",
        "api_signature": "__init__(self, name, qubits, sequence)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/pulsedefaults.py"
    },
    {
        "api_name": "__getattr__",
        "full_api_name": "Command.__getattr__",
        "api_description": "",
        "api_signature": "__getattr__(self, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/pulsedefaults.py"
    },
    {
        "api_name": "to_dict",
        "full_api_name": "Command.to_dict",
        "api_description": "Return a dictionary format representation of the Command.\n\nReturns:\n    dict: The dictionary form of the Command.",
        "api_signature": "to_dict(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/pulsedefaults.py"
    },
    {
        "api_name": "from_dict",
        "full_api_name": "Command.from_dict",
        "api_description": "Create a new Command object from a dictionary.\n\nArgs:\n    data (dict): A dictionary representing the ``Command``\n                 to create. It will be in the same format as output by\n                 :meth:`to_dict`.\n\nReturns:\n    Command: The ``Command`` from the input dictionary.",
        "api_signature": "from_dict(cls, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/pulsedefaults.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PulseDefaults.__init__",
        "api_description": "Validate and reformat transport layer inputs to initialize.\nArgs:\n    qubit_freq_est: Estimated qubit frequencies in GHz.\n    meas_freq_est: Estimated measurement cavity frequencies in GHz.\n    buffer: Default buffer time (in units of dt) between pulses.\n    pulse_library: Pulse name and sample definitions.\n    cmd_def: Operation name and definition in terms of Commands.\n    meas_kernel: The measurement kernels\n    discriminator: The discriminators\n    **kwargs: Other attributes for the super class.",
        "api_signature": "__init__(self, qubit_freq_est, meas_freq_est, buffer, pulse_library, cmd_def, meas_kernel, discriminator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/pulsedefaults.py"
    },
    {
        "api_name": "__getattr__",
        "full_api_name": "PulseDefaults.__getattr__",
        "api_description": "",
        "api_signature": "__getattr__(self, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/pulsedefaults.py"
    },
    {
        "api_name": "to_dict",
        "full_api_name": "PulseDefaults.to_dict",
        "api_description": "Return a dictionary format representation of the PulseDefaults.\nReturns:\n    dict: The dictionary form of the PulseDefaults.",
        "api_signature": "to_dict(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/pulsedefaults.py"
    },
    {
        "api_name": "from_dict",
        "full_api_name": "PulseDefaults.from_dict",
        "api_description": "Create a new PulseDefaults object from a dictionary.\n\nArgs:\n    data (dict): A dictionary representing the PulseDefaults\n                 to create. It will be in the same format as output by\n                 :meth:`to_dict`.\nReturns:\n    PulseDefaults: The PulseDefaults from the input dictionary.",
        "api_signature": "from_dict(cls, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/pulsedefaults.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "PulseDefaults.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/pulsedefaults.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BackendStatus.__init__",
        "api_description": "Initialize a BackendStatus object\n\nArgs:\n    backend_name: The backend's name\n    backend_version: The backend's version of the form X.Y.Z\n    operational: True if the backend is operational\n    pending_jobs: The number of pending jobs on the backend\n    status_msg: The status msg for the backend\n\nRaises:\n    QiskitError: If the backend version is in an invalid format",
        "api_signature": "__init__(self, backend_name, backend_version, operational, pending_jobs, status_msg)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendstatus.py"
    },
    {
        "api_name": "from_dict",
        "full_api_name": "BackendStatus.from_dict",
        "api_description": "Create a new BackendStatus object from a dictionary.\n\nArgs:\n    data (dict): A dictionary representing the BaseBakend to create.\n                 It will be in the same format as output by\n                 :func:`to_dict`.\n\nReturns:\n    BackendStatus: The BackendStatus from the input dictionary.",
        "api_signature": "from_dict(cls, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendstatus.py"
    },
    {
        "api_name": "to_dict",
        "full_api_name": "BackendStatus.to_dict",
        "api_description": "Return a dictionary format representation of the BackendStatus.\n\nReturns:\n    dict: The dictionary form of the QobjHeader.",
        "api_signature": "to_dict(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendstatus.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "BackendStatus.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendstatus.py"
    },
    {
        "api_name": "_repr_html_",
        "full_api_name": "BackendStatus._repr_html_",
        "api_description": "Return html representation of the object\n\nReturns:\n    Representation used in Jupyter notebook and other IDE's that call the method",
        "api_signature": "_repr_html_(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/providers/models/backendstatus.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "DAGCircuit.__init__",
        "api_description": "Create an empty circuit.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "wires",
        "full_api_name": "DAGCircuit.wires",
        "api_description": "Return a list of the wires in order.",
        "api_signature": "wires(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "node_counter",
        "full_api_name": "DAGCircuit.node_counter",
        "api_description": "Returns the number of nodes in the dag.",
        "api_signature": "node_counter(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "global_phase",
        "full_api_name": "DAGCircuit.global_phase",
        "api_description": "Return the global phase of the circuit.",
        "api_signature": "global_phase(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "global_phase",
        "full_api_name": "DAGCircuit.global_phase",
        "api_description": "Set the global phase of the circuit.\n\nArgs:\n    angle (float, ParameterExpression)",
        "api_signature": "global_phase(self, angle)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "calibrations",
        "full_api_name": "DAGCircuit.calibrations",
        "api_description": "Return calibration dictionary.\n\nThe custom pulse definition of a given gate is of the form\n    {'gate_name': {(qubits, params): schedule}}",
        "api_signature": "calibrations(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "calibrations",
        "full_api_name": "DAGCircuit.calibrations",
        "api_description": "Set the circuit calibration data from a dictionary of calibration definition.\n\nArgs:\n    calibrations (dict): A dictionary of input in the format\n        {'gate_name': {(qubits, gate_params): schedule}}",
        "api_signature": "calibrations(self, calibrations)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "add_calibration",
        "full_api_name": "DAGCircuit.add_calibration",
        "api_description": "Register a low-level, custom pulse definition for the given gate.\n\nArgs:\n    gate (Union[Gate, str]): Gate information.\n    qubits (Union[int, Tuple[int]]): List of qubits to be measured.\n    schedule (Schedule): Schedule information.\n    params (Optional[List[Union[float, Parameter]]]): A list of parameters.\n\nRaises:\n    Exception: if the gate is of type string and params is None.",
        "api_signature": "add_calibration(self, gate, qubits, schedule, params)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "_format",
        "full_api_name": "DAGCircuit._format",
        "api_description": "",
        "api_signature": "_format(operand)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "has_calibration_for",
        "full_api_name": "DAGCircuit.has_calibration_for",
        "api_description": "Return True if the dag has a calibration defined for the node operation. In this\ncase, the operation does not need to be translated to the device basis.",
        "api_signature": "has_calibration_for(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "remove_all_ops_named",
        "full_api_name": "DAGCircuit.remove_all_ops_named",
        "api_description": "Remove all operation nodes with the given name.",
        "api_signature": "remove_all_ops_named(self, opname)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "add_qubits",
        "full_api_name": "DAGCircuit.add_qubits",
        "api_description": "Add individual qubit wires.",
        "api_signature": "add_qubits(self, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "add_clbits",
        "full_api_name": "DAGCircuit.add_clbits",
        "api_description": "Add individual clbit wires.",
        "api_signature": "add_clbits(self, clbits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "add_qreg",
        "full_api_name": "DAGCircuit.add_qreg",
        "api_description": "Add all wires in a quantum register.",
        "api_signature": "add_qreg(self, qreg)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "add_creg",
        "full_api_name": "DAGCircuit.add_creg",
        "api_description": "Add all wires in a classical register.",
        "api_signature": "add_creg(self, creg)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "add_input_var",
        "full_api_name": "DAGCircuit.add_input_var",
        "api_description": "Add an input variable to the circuit.\n\nArgs:\n    var: the variable to add.",
        "api_signature": "add_input_var(self, var)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "add_captured_var",
        "full_api_name": "DAGCircuit.add_captured_var",
        "api_description": "Add a captured variable to the circuit.\n\nArgs:\n    var: the variable to add.",
        "api_signature": "add_captured_var(self, var)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "add_declared_var",
        "full_api_name": "DAGCircuit.add_declared_var",
        "api_description": "Add a declared local variable to the circuit.\n\nArgs:\n    var: the variable to add.",
        "api_signature": "add_declared_var(self, var)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "_add_var",
        "full_api_name": "DAGCircuit._add_var",
        "api_description": "Inner function to add any variable to the DAG.  ``location`` should be a reference one of\nthe ``self._vars_*`` tracking dictionaries.",
        "api_signature": "_add_var(self, var, type_)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "_add_wire",
        "full_api_name": "DAGCircuit._add_wire",
        "api_description": "Add a qubit or bit to the circuit.\n\nArgs:\n    wire (Bit): the wire to be added\n\n    This adds a pair of in and out nodes connected by an edge.\n\nRaises:\n    DAGCircuitError: if trying to add duplicate wire",
        "api_signature": "_add_wire(self, wire)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "find_bit",
        "full_api_name": "DAGCircuit.find_bit",
        "api_description": "Finds locations in the circuit, by mapping the Qubit and Clbit to positional index\nBitLocations is defined as: BitLocations = namedtuple(\"BitLocations\", (\"index\", \"registers\"))\n\nArgs:\n    bit (Bit): The bit to locate.\n\nReturns:\n    namedtuple(int, List[Tuple(Register, int)]): A 2-tuple. The first element (``index``)\n        contains the index at which the ``Bit`` can be found (in either\n        :obj:`~DAGCircuit.qubits`, :obj:`~DAGCircuit.clbits`, depending on its\n        type). The second element (``registers``) is a list of ``(register, index)``\n        pairs with an entry for each :obj:`~Register` in the circuit which contains the\n        :obj:`~Bit` (and the index in the :obj:`~Register` at which it can be found).\n\n  Raises:\n    DAGCircuitError: If the supplied :obj:`~Bit` was of an unknown type.\n    DAGCircuitError: If the supplied :obj:`~Bit` could not be found on the circuit.",
        "api_signature": "find_bit(self, bit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "remove_clbits",
        "full_api_name": "DAGCircuit.remove_clbits",
        "api_description": "Remove classical bits from the circuit. All bits MUST be idle.\nAny registers with references to at least one of the specified bits will\nalso be removed.\n\nArgs:\n    clbits (List[Clbit]): The bits to remove.\n\nRaises:\n    DAGCircuitError: a clbit is not a :obj:`.Clbit`, is not in the circuit,\n        or is not idle.",
        "api_signature": "remove_clbits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "remove_cregs",
        "full_api_name": "DAGCircuit.remove_cregs",
        "api_description": "Remove classical registers from the circuit, leaving underlying bits\nin place.\n\nRaises:\n    DAGCircuitError: a creg is not a ClassicalRegister, or is not in\n    the circuit.",
        "api_signature": "remove_cregs(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "remove_qubits",
        "full_api_name": "DAGCircuit.remove_qubits",
        "api_description": "Remove quantum bits from the circuit. All bits MUST be idle.\nAny registers with references to at least one of the specified bits will\nalso be removed.\n\nArgs:\n    qubits (List[~qiskit.circuit.Qubit]): The bits to remove.\n\nRaises:\n    DAGCircuitError: a qubit is not a :obj:`~.circuit.Qubit`, is not in the circuit,\n        or is not idle.",
        "api_signature": "remove_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "remove_qregs",
        "full_api_name": "DAGCircuit.remove_qregs",
        "api_description": "Remove quantum registers from the circuit, leaving underlying bits\nin place.\n\nRaises:\n    DAGCircuitError: a qreg is not a QuantumRegister, or is not in\n    the circuit.",
        "api_signature": "remove_qregs(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "_is_wire_idle",
        "full_api_name": "DAGCircuit._is_wire_idle",
        "api_description": "Check if a wire is idle.\n\nArgs:\n    wire (Bit): a wire in the circuit.\n\nReturns:\n    bool: true if the wire is idle, false otherwise.\n\nRaises:\n    DAGCircuitError: the wire is not in the circuit.",
        "api_signature": "_is_wire_idle(self, wire)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "_remove_idle_wire",
        "full_api_name": "DAGCircuit._remove_idle_wire",
        "api_description": "Remove an idle qubit or bit from the circuit.\n\nArgs:\n    wire (Bit): the wire to be removed, which MUST be idle.",
        "api_signature": "_remove_idle_wire(self, wire)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "_check_condition",
        "full_api_name": "DAGCircuit._check_condition",
        "api_description": "Verify that the condition is valid.\n\nArgs:\n    name (string): used for error reporting\n    condition (tuple or None): a condition tuple (ClassicalRegister, int) or (Clbit, bool)\n\nRaises:\n    DAGCircuitError: if conditioning on an invalid register",
        "api_signature": "_check_condition(self, name, condition)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "_check_wires",
        "full_api_name": "DAGCircuit._check_wires",
        "api_description": "Check the values of a list of wire arguments.\n\nFor each element of args, check that amap contains it.\n\nArgs:\n    args: the elements to be checked\n    amap: a dictionary keyed on Qubits/Clbits\n\nRaises:\n    DAGCircuitError: if a qubit is not contained in amap",
        "api_signature": "_check_wires(self, args, amap)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "_increment_op",
        "full_api_name": "DAGCircuit._increment_op",
        "api_description": "",
        "api_signature": "_increment_op(self, op_name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "_decrement_op",
        "full_api_name": "DAGCircuit._decrement_op",
        "api_description": "",
        "api_signature": "_decrement_op(self, op_name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "copy_empty_like",
        "full_api_name": "DAGCircuit.copy_empty_like",
        "api_description": "Return a copy of self with the same structure but empty.\n\nThat structure includes:\n    * name and other metadata\n    * global phase\n    * duration\n    * all the qubits and clbits, including the registers\n    * all the classical variables, with a mode defined by ``vars_mode``.\n\nArgs:\n    vars_mode: The mode to handle realtime variables in.\n\n        alike\n            The variables in the output DAG will have the same declaration semantics as\n            in the original circuit.  For example, ``input`` variables in the source will be\n            ``input`` variables in the output DAG.\n\n        captures\n            All variables will be converted to captured variables.  This is useful when you\n            are building a new layer for an existing DAG that you will want to\n            :meth:`compose` onto the base, since :meth:`compose` can inline captures onto\n            the base circuit (but not other variables).\n\n        drop\n            The output DAG will have no variables defined.\n\nReturns:\n    DAGCircuit: An empty copy of self.",
        "api_signature": "copy_empty_like(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "_apply_op_node_back",
        "full_api_name": "DAGCircuit._apply_op_node_back",
        "api_description": "",
        "api_signature": "_apply_op_node_back(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "apply_operation_back",
        "full_api_name": "DAGCircuit.apply_operation_back",
        "api_description": "Apply an operation to the output of the circuit.\n\nArgs:\n    op (qiskit.circuit.Operation): the operation associated with the DAG node\n    qargs (tuple[~qiskit.circuit.Qubit]): qubits that op will be applied to\n    cargs (tuple[Clbit]): cbits that op will be applied to\n    check (bool): If ``True`` (default), this function will enforce that the\n        :class:`.DAGCircuit` data-structure invariants are maintained (all ``qargs`` are\n        :class:`~.circuit.Qubit`\\ s, all are in the DAG, etc).  If ``False``, the caller *must*\n        uphold these invariants itself, but the cost of several checks will be skipped.\n        This is most useful when building a new DAG from a source of known-good nodes.\nReturns:\n    DAGOpNode: the node for the op that was added to the dag\n\nRaises:\n    DAGCircuitError: if a leaf node is connected to multiple outputs",
        "api_signature": "apply_operation_back(self, op, qargs, cargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "apply_operation_front",
        "full_api_name": "DAGCircuit.apply_operation_front",
        "api_description": "Apply an operation to the input of the circuit.\n\nArgs:\n    op (qiskit.circuit.Operation): the operation associated with the DAG node\n    qargs (tuple[~qiskit.circuit.Qubit]): qubits that op will be applied to\n    cargs (tuple[Clbit]): cbits that op will be applied to\n    check (bool): If ``True`` (default), this function will enforce that the\n        :class:`.DAGCircuit` data-structure invariants are maintained (all ``qargs`` are\n        :class:`~.circuit.Qubit`\\ s, all are in the DAG, etc).  If ``False``, the caller *must*\n        uphold these invariants itself, but the cost of several checks will be skipped.\n        This is most useful when building a new DAG from a source of known-good nodes.\nReturns:\n    DAGOpNode: the node for the op that was added to the dag\n\nRaises:\n    DAGCircuitError: if initial nodes connected to multiple out edges",
        "api_signature": "apply_operation_front(self, op, qargs, cargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "compose",
        "full_api_name": "DAGCircuit.compose",
        "api_description": "Compose the ``other`` circuit onto the output of this circuit.\n\nA subset of input wires of ``other`` are mapped\nto a subset of output wires of this circuit.\n\n``other`` can be narrower or of equal width to ``self``.\n\nArgs:\n    other (DAGCircuit): circuit to compose with self\n    qubits (list[~qiskit.circuit.Qubit|int]): qubits of self to compose onto.\n    clbits (list[Clbit|int]): clbits of self to compose onto.\n    front (bool): If True, front composition will be performed (not implemented yet)\n    inplace (bool): If True, modify the object. Otherwise return composed circuit.\n    inline_captures (bool): If ``True``, variables marked as \"captures\" in the ``other`` DAG\n        will inlined onto existing uses of those same variables in ``self``.  If ``False``,\n        all variables in ``other`` are required to be distinct from ``self``, and they will\n        be added to ``self``.\n\n..\n    Note: unlike `QuantumCircuit.compose`, there's no `var_remap` argument here.  That's\n    because the `DAGCircuit` inner-block structure isn't set up well to allow the recursion,\n    and `DAGCircuit.compose` is generally only used to rebuild a DAG from layers within\n    itself than to join unrelated circuits.  While there's no strong motivating use-case\n    (unlike the `QuantumCircuit` equivalent), it's safer and more performant to not provide\n    the option.\n\nReturns:\n    DAGCircuit: the composed dag (returns None if inplace==True).\n\nRaises:\n    DAGCircuitError: if ``other`` is wider or there are duplicate edge mappings.",
        "api_signature": "compose(self, other, qubits, clbits, front, inplace)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "_reject_new_register",
        "full_api_name": "DAGCircuit._reject_new_register",
        "api_description": "",
        "api_signature": "_reject_new_register(reg)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "reverse_ops",
        "full_api_name": "DAGCircuit.reverse_ops",
        "api_description": "Reverse the operations in the ``self`` circuit.\n\nReturns:\n    DAGCircuit: the reversed dag.",
        "api_signature": "reverse_ops(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "idle_wires",
        "full_api_name": "DAGCircuit.idle_wires",
        "api_description": "Return idle wires.\n\nArgs:\n    ignore (list(str)): List of node names to ignore. Default: []\n\nYields:\n    Bit: Bit in idle wire.\n\nRaises:\n    DAGCircuitError: If the DAG is invalid",
        "api_signature": "idle_wires(self, ignore)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "size",
        "full_api_name": "DAGCircuit.size",
        "api_description": "Return the number of operations.  If there is control flow present, this count may only\nbe an estimate, as the complete control-flow path cannot be statically known.\n\nArgs:\n    recurse: if ``True``, then recurse into control-flow operations.  For loops with\n        known-length iterators are counted unrolled.  If-else blocks sum both of the two\n        branches.  While loops are counted as if the loop body runs once only.  Defaults to\n        ``False`` and raises :class:`.DAGCircuitError` if any control flow is present, to\n        avoid silently returning a mostly meaningless number.\n\nReturns:\n    int: the circuit size\n\nRaises:\n    DAGCircuitError: if an unknown :class:`.ControlFlowOp` is present in a call with\n        ``recurse=True``, or any control flow is present in a non-recursive call.",
        "api_signature": "size(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "depth",
        "full_api_name": "DAGCircuit.depth",
        "api_description": "Return the circuit depth.  If there is control flow present, this count may only be an\nestimate, as the complete control-flow path cannot be statically known.\n\nArgs:\n    recurse: if ``True``, then recurse into control-flow operations.  For loops\n        with known-length iterators are counted as if the loop had been manually unrolled\n        (*i.e.* with each iteration of the loop body written out explicitly).\n        If-else blocks take the longer case of the two branches.  While loops are counted as\n        if the loop body runs once only.  Defaults to ``False`` and raises\n        :class:`.DAGCircuitError` if any control flow is present, to avoid silently\n        returning a nonsensical number.\n\nReturns:\n    int: the circuit depth\n\nRaises:\n    DAGCircuitError: if not a directed acyclic graph\n    DAGCircuitError: if unknown control flow is present in a recursive call, or any control\n        flow is present in a non-recursive call.",
        "api_signature": "depth(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "weight_fn",
        "full_api_name": "DAGCircuit.weight_fn",
        "api_description": "",
        "api_signature": "weight_fn(_source, target, _edge)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "width",
        "full_api_name": "DAGCircuit.width",
        "api_description": "Return the total number of qubits + clbits used by the circuit.\nThis function formerly returned the number of qubits by the calculation\nreturn len(self._wires) - self.num_clbits()\nbut was changed by issue #2564 to return number of qubits + clbits\nwith the new function DAGCircuit.num_qubits replacing the former\nsemantic of DAGCircuit.width().",
        "api_signature": "width(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "num_qubits",
        "full_api_name": "DAGCircuit.num_qubits",
        "api_description": "Return the total number of qubits used by the circuit.\nnum_qubits() replaces former use of width().\nDAGCircuit.width() now returns qubits + clbits for\nconsistency with Circuit.width() [qiskit-terra #2564].",
        "api_signature": "num_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "num_clbits",
        "full_api_name": "DAGCircuit.num_clbits",
        "api_description": "Return the total number of classical bits used by the circuit.",
        "api_signature": "num_clbits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "num_tensor_factors",
        "full_api_name": "DAGCircuit.num_tensor_factors",
        "api_description": "Compute how many components the circuit can decompose into.",
        "api_signature": "num_tensor_factors(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "num_vars",
        "full_api_name": "DAGCircuit.num_vars",
        "api_description": "Total number of classical variables tracked by the circuit.",
        "api_signature": "num_vars(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "num_input_vars",
        "full_api_name": "DAGCircuit.num_input_vars",
        "api_description": "Number of input classical variables tracked by the circuit.",
        "api_signature": "num_input_vars(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "num_captured_vars",
        "full_api_name": "DAGCircuit.num_captured_vars",
        "api_description": "Number of captured classical variables tracked by the circuit.",
        "api_signature": "num_captured_vars(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "num_declared_vars",
        "full_api_name": "DAGCircuit.num_declared_vars",
        "api_description": "Number of declared local classical variables tracked by the circuit.",
        "api_signature": "num_declared_vars(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "iter_vars",
        "full_api_name": "DAGCircuit.iter_vars",
        "api_description": "Iterable over all the classical variables tracked by the circuit.",
        "api_signature": "iter_vars(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "iter_input_vars",
        "full_api_name": "DAGCircuit.iter_input_vars",
        "api_description": "Iterable over the input classical variables tracked by the circuit.",
        "api_signature": "iter_input_vars(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "iter_captured_vars",
        "full_api_name": "DAGCircuit.iter_captured_vars",
        "api_description": "Iterable over the captured classical variables tracked by the circuit.",
        "api_signature": "iter_captured_vars(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "iter_declared_vars",
        "full_api_name": "DAGCircuit.iter_declared_vars",
        "api_description": "Iterable over the declared local classical variables tracked by the circuit.",
        "api_signature": "iter_declared_vars(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "has_var",
        "full_api_name": "DAGCircuit.has_var",
        "api_description": "Is this realtime variable in the DAG?\n\nArgs:\n    var: the variable or name to check.",
        "api_signature": "has_var(self, var)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "DAGCircuit.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "node_eq",
        "full_api_name": "DAGCircuit.node_eq",
        "api_description": "",
        "api_signature": "node_eq(node_self, node_other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "topological_nodes",
        "full_api_name": "DAGCircuit.topological_nodes",
        "api_description": "Yield nodes in topological order.\n\nArgs:\n    key (Callable): A callable which will take a DAGNode object and\n        return a string sort key. If not specified the\n        :attr:`~qiskit.dagcircuit.DAGNode.sort_key` attribute will be\n        used as the sort key for each node.\n\nReturns:\n    generator(DAGOpNode, DAGInNode, or DAGOutNode): node in topological order",
        "api_signature": "topological_nodes(self, key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "_key",
        "full_api_name": "DAGCircuit._key",
        "api_description": "",
        "api_signature": "_key(x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "topological_op_nodes",
        "full_api_name": "DAGCircuit.topological_op_nodes",
        "api_description": "Yield op nodes in topological order.\n\nAllowed to pass in specific key to break ties in top order\n\nArgs:\n    key (Callable): A callable which will take a DAGNode object and\n        return a string sort key. If not specified the\n        :attr:`~qiskit.dagcircuit.DAGNode.sort_key` attribute will be\n        used as the sort key for each node.\n\nReturns:\n    generator(DAGOpNode): op node in topological order",
        "api_signature": "topological_op_nodes(self, key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "replace_block_with_op",
        "full_api_name": "DAGCircuit.replace_block_with_op",
        "api_description": "Replace a block of nodes with a single node.\n\nThis is used to consolidate a block of DAGOpNodes into a single\noperation. A typical example is a block of gates being consolidated\ninto a single ``UnitaryGate`` representing the unitary matrix of the\nblock.\n\nArgs:\n    node_block (List[DAGNode]): A list of dag nodes that represents the\n        node block to be replaced\n    op (qiskit.circuit.Operation): The operation to replace the\n        block with\n    wire_pos_map (Dict[Bit, int]): The dictionary mapping the bits to their positions in the\n        output ``qargs`` or ``cargs``. This is necessary to reconstruct the arg order over\n        multiple gates in the combined single op node.  If a :class:`.Bit` is not in the\n        dictionary, it will not be added to the args; this can be useful when dealing with\n        control-flow operations that have inherent bits in their ``condition`` or ``target``\n        fields.  :class:`.expr.Var` wires similarly do not need to be in this map, since\n        they will never be in ``qargs`` or ``cargs``.\n    cycle_check (bool): When set to True this method will check that\n        replacing the provided ``node_block`` with a single node\n        would introduce a cycle (which would invalidate the\n        ``DAGCircuit``) and will raise a ``DAGCircuitError`` if a cycle\n        would be introduced. This checking comes with a run time\n        penalty. If you can guarantee that your input ``node_block`` is\n        a contiguous block and won't introduce a cycle when it's\n        contracted to a single node, this can be set to ``False`` to\n        improve the runtime performance of this method.\n\nRaises:\n    DAGCircuitError: if ``cycle_check`` is set to ``True`` and replacing\n        the specified block introduces a cycle or if ``node_block`` is\n        empty.\n\nReturns:\n    DAGOpNode: The op node that replaces the block.",
        "api_signature": "replace_block_with_op(self, node_block, op, wire_pos_map, cycle_check)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "substitute_node_with_dag",
        "full_api_name": "DAGCircuit.substitute_node_with_dag",
        "api_description": "Replace one node with dag.\n\nArgs:\n    node (DAGOpNode): node to substitute\n    input_dag (DAGCircuit): circuit that will substitute the node.\n    wires (list[Bit] | Dict[Bit, Bit]): gives an order for (qu)bits\n        in the input circuit. If a list, then the bits refer to those in the ``input_dag``,\n        and the order gets matched to the node wires by qargs first, then cargs, then\n        conditions.  If a dictionary, then a mapping of bits in the ``input_dag`` to those\n        that the ``node`` acts on.\n\n        Standalone :class:`~.expr.Var` nodes cannot currently be remapped as part of the\n        substitution; the ``input_dag`` should be defined over the correct set of variables\n        already.\n\n        ..\n            The rule about not remapping `Var`s is to avoid performance pitfalls and reduce\n            complexity; the creator of the input DAG should easily be able to arrange for\n            the correct `Var`s to be used, and doing so avoids us needing to recurse through\n            control-flow operations to do deep remappings.\n    propagate_condition (bool): If ``True`` (default), then any ``condition`` attribute on\n        the operation within ``node`` is propagated to each node in the ``input_dag``.  If\n        ``False``, then the ``input_dag`` is assumed to faithfully implement suitable\n        conditional logic already.  This is ignored for :class:`.ControlFlowOp`\\ s (i.e.\n        treated as if it is ``False``); replacements of those must already fulfill the same\n        conditional logic or this function would be close to useless for them.\n\nReturns:\n    dict: maps node IDs from `input_dag` to their new node incarnations in `self`.\n\nRaises:\n    DAGCircuitError: if met with unexpected predecessor/successors",
        "api_signature": "substitute_node_with_dag(self, node, input_dag, wires, propagate_condition)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "filter_fn",
        "full_api_name": "DAGCircuit.filter_fn",
        "api_description": "",
        "api_signature": "filter_fn(node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "edge_map_fn",
        "full_api_name": "DAGCircuit.edge_map_fn",
        "api_description": "",
        "api_signature": "edge_map_fn(source, _target, self_wire)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "edge_weight_map",
        "full_api_name": "DAGCircuit.edge_weight_map",
        "api_description": "",
        "api_signature": "edge_weight_map(wire)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "substitute_node",
        "full_api_name": "DAGCircuit.substitute_node",
        "api_description": "Replace an DAGOpNode with a single operation. qargs, cargs and\nconditions for the new operation will be inferred from the node to be\nreplaced. The new operation will be checked to match the shape of the\nreplaced operation.\n\nArgs:\n    node (DAGOpNode): Node to be replaced\n    op (qiskit.circuit.Operation): The :class:`qiskit.circuit.Operation`\n        instance to be added to the DAG\n    inplace (bool): Optional, default False. If True, existing DAG node\n        will be modified to include op. Otherwise, a new DAG node will\n        be used.\n    propagate_condition (bool): Optional, default True.  If True, a condition on the\n        ``node`` to be replaced will be applied to the new ``op``.  This is the legacy\n        behavior.  If either node is a control-flow operation, this will be ignored.  If\n        the ``op`` already has a condition, :exc:`.DAGCircuitError` is raised.\n\nReturns:\n    DAGOpNode: the new node containing the added operation.\n\nRaises:\n    DAGCircuitError: If replacement operation was incompatible with\n    location of target node.",
        "api_signature": "substitute_node(self, node, op, inplace, propagate_condition)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "separable_circuits",
        "full_api_name": "DAGCircuit.separable_circuits",
        "api_description": "Decompose the circuit into sets of qubits with no gates connecting them.\n\nArgs:\n    remove_idle_qubits (bool): Flag denoting whether to remove idle qubits from\n        the separated circuits. If ``False``, each output circuit will contain the\n        same number of qubits as ``self``.\n    vars_mode: how any realtime :class:`~.expr.Var` nodes should be handled in the output\n        DAGs.  See :meth:`copy_empty_like` for details on the modes.\n\nReturns:\n    List[DAGCircuit]: The circuits resulting from separating ``self`` into sets\n        of disconnected qubits\n\nEach :class:`~.DAGCircuit` instance returned by this method will contain the same number of\nclbits as ``self``. The global phase information in ``self`` will not be maintained\nin the subcircuits returned by this method.",
        "api_signature": "separable_circuits(self, remove_idle_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "_key",
        "full_api_name": "DAGCircuit._key",
        "api_description": "",
        "api_signature": "_key(x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "swap_nodes",
        "full_api_name": "DAGCircuit.swap_nodes",
        "api_description": "Swap connected nodes e.g. due to commutation.\n\nArgs:\n    node1 (OpNode): predecessor node\n    node2 (OpNode): successor node\n\nRaises:\n    DAGCircuitError: if either node is not an OpNode or nodes are not connected",
        "api_signature": "swap_nodes(self, node1, node2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "node",
        "full_api_name": "DAGCircuit.node",
        "api_description": "Get the node in the dag.\n\nArgs:\n    node_id(int): Node identifier.\n\nReturns:\n    node: the node.",
        "api_signature": "node(self, node_id)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "nodes",
        "full_api_name": "DAGCircuit.nodes",
        "api_description": "Iterator for node values.\n\nYield:\n    node: the node.",
        "api_signature": "nodes(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "edges",
        "full_api_name": "DAGCircuit.edges",
        "api_description": "Iterator for edge values and source and dest node\n\nThis works by returning the output edges from the specified nodes. If\nno nodes are specified all edges from the graph are returned.\n\nArgs:\n    nodes(DAGOpNode, DAGInNode, or DAGOutNode|list(DAGOpNode, DAGInNode, or DAGOutNode):\n        Either a list of nodes or a single input node. If none is specified,\n        all edges are returned from the graph.\n\nYield:\n    edge: the edge in the same format as out_edges the tuple\n        (source node, destination node, edge data)",
        "api_signature": "edges(self, nodes)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "op_nodes",
        "full_api_name": "DAGCircuit.op_nodes",
        "api_description": "Get the list of \"op\" nodes in the dag.\n\nArgs:\n    op (Type): :class:`qiskit.circuit.Operation` subclass op nodes to\n        return. If None, return all op nodes.\n    include_directives (bool): include `barrier`, `snapshot` etc.\n\nReturns:\n    list[DAGOpNode]: the list of node ids containing the given op.",
        "api_signature": "op_nodes(self, op, include_directives)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "gate_nodes",
        "full_api_name": "DAGCircuit.gate_nodes",
        "api_description": "Get the list of gate nodes in the dag.\n\nReturns:\n    list[DAGOpNode]: the list of DAGOpNodes that represent gates.",
        "api_signature": "gate_nodes(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "named_nodes",
        "full_api_name": "DAGCircuit.named_nodes",
        "api_description": "Get the set of \"op\" nodes with the given name.",
        "api_signature": "named_nodes(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "two_qubit_ops",
        "full_api_name": "DAGCircuit.two_qubit_ops",
        "api_description": "Get list of 2 qubit operations. Ignore directives like snapshot and barrier.",
        "api_signature": "two_qubit_ops(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "multi_qubit_ops",
        "full_api_name": "DAGCircuit.multi_qubit_ops",
        "api_description": "Get list of 3+ qubit operations. Ignore directives like snapshot and barrier.",
        "api_signature": "multi_qubit_ops(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "longest_path",
        "full_api_name": "DAGCircuit.longest_path",
        "api_description": "Returns the longest path in the dag as a list of DAGOpNodes, DAGInNodes, and DAGOutNodes.",
        "api_signature": "longest_path(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "successors",
        "full_api_name": "DAGCircuit.successors",
        "api_description": "Returns iterator of the successors of a node as DAGOpNodes and DAGOutNodes.",
        "api_signature": "successors(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "predecessors",
        "full_api_name": "DAGCircuit.predecessors",
        "api_description": "Returns iterator of the predecessors of a node as DAGOpNodes and DAGInNodes.",
        "api_signature": "predecessors(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "op_successors",
        "full_api_name": "DAGCircuit.op_successors",
        "api_description": "Returns iterator of \"op\" successors of a node in the dag.",
        "api_signature": "op_successors(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "op_predecessors",
        "full_api_name": "DAGCircuit.op_predecessors",
        "api_description": "Returns the iterator of \"op\" predecessors of a node in the dag.",
        "api_signature": "op_predecessors(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "is_successor",
        "full_api_name": "DAGCircuit.is_successor",
        "api_description": "Checks if a second node is in the successors of node.",
        "api_signature": "is_successor(self, node, node_succ)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "is_predecessor",
        "full_api_name": "DAGCircuit.is_predecessor",
        "api_description": "Checks if a second node is in the predecessors of node.",
        "api_signature": "is_predecessor(self, node, node_pred)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "quantum_predecessors",
        "full_api_name": "DAGCircuit.quantum_predecessors",
        "api_description": "Returns iterator of the predecessors of a node that are\nconnected by a quantum edge as DAGOpNodes and DAGInNodes.",
        "api_signature": "quantum_predecessors(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "classical_predecessors",
        "full_api_name": "DAGCircuit.classical_predecessors",
        "api_description": "Returns iterator of the predecessors of a node that are\nconnected by a classical edge as DAGOpNodes and DAGInNodes.",
        "api_signature": "classical_predecessors(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "ancestors",
        "full_api_name": "DAGCircuit.ancestors",
        "api_description": "Returns set of the ancestors of a node as DAGOpNodes and DAGInNodes.",
        "api_signature": "ancestors(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "descendants",
        "full_api_name": "DAGCircuit.descendants",
        "api_description": "Returns set of the descendants of a node as DAGOpNodes and DAGOutNodes.",
        "api_signature": "descendants(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "bfs_successors",
        "full_api_name": "DAGCircuit.bfs_successors",
        "api_description": "Returns an iterator of tuples of (DAGNode, [DAGNodes]) where the DAGNode is the current node\nand [DAGNode] is its successors in  BFS order.",
        "api_signature": "bfs_successors(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "quantum_successors",
        "full_api_name": "DAGCircuit.quantum_successors",
        "api_description": "Returns iterator of the successors of a node that are\nconnected by a quantum edge as Opnodes and DAGOutNodes.",
        "api_signature": "quantum_successors(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "classical_successors",
        "full_api_name": "DAGCircuit.classical_successors",
        "api_description": "Returns iterator of the successors of a node that are\nconnected by a classical edge as DAGOpNodes and DAGInNodes.",
        "api_signature": "classical_successors(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "remove_op_node",
        "full_api_name": "DAGCircuit.remove_op_node",
        "api_description": "Remove an operation node n.\n\nAdd edges from predecessors to successors.",
        "api_signature": "remove_op_node(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "remove_ancestors_of",
        "full_api_name": "DAGCircuit.remove_ancestors_of",
        "api_description": "Remove all of the ancestor operation nodes of node.",
        "api_signature": "remove_ancestors_of(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "remove_descendants_of",
        "full_api_name": "DAGCircuit.remove_descendants_of",
        "api_description": "Remove all of the descendant operation nodes of node.",
        "api_signature": "remove_descendants_of(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "remove_nonancestors_of",
        "full_api_name": "DAGCircuit.remove_nonancestors_of",
        "api_description": "Remove all of the non-ancestors operation nodes of node.",
        "api_signature": "remove_nonancestors_of(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "remove_nondescendants_of",
        "full_api_name": "DAGCircuit.remove_nondescendants_of",
        "api_description": "Remove all of the non-descendants operation nodes of node.",
        "api_signature": "remove_nondescendants_of(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "front_layer",
        "full_api_name": "DAGCircuit.front_layer",
        "api_description": "Return a list of op nodes in the first layer of this dag.",
        "api_signature": "front_layer(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "layers",
        "full_api_name": "DAGCircuit.layers",
        "api_description": "Yield a shallow view on a layer of this DAGCircuit for all d layers of this circuit.\n\nA layer is a circuit whose gates act on disjoint qubits, i.e.,\na layer has depth 1. The total number of layers equals the\ncircuit depth d. The layers are indexed from 0 to d-1 with the\nearliest layer at index 0. The layers are constructed using a\ngreedy algorithm. Each returned layer is a dict containing\n{\"graph\": circuit graph, \"partition\": list of qubit lists}.\n\nThe returned layer contains new (but semantically equivalent) DAGOpNodes, DAGInNodes,\nand DAGOutNodes. These are not the same as nodes of the original dag, but are equivalent\nvia DAGNode.semantic_eq(node1, node2).\n\nTODO: Gates that use the same cbits will end up in different\nlayers as this is currently implemented. This may not be\nthe desired behavior.\n\nArgs:\n    vars_mode: how any realtime :class:`~.expr.Var` nodes should be handled in the output\n        DAGs.  See :meth:`copy_empty_like` for details on the modes.",
        "api_signature": "layers(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "serial_layers",
        "full_api_name": "DAGCircuit.serial_layers",
        "api_description": "Yield a layer for all gates of this circuit.\n\nA serial layer is a circuit with one gate. The layers have the\nsame structure as in layers().\n\nArgs:\n    vars_mode: how any realtime :class:`~.expr.Var` nodes should be handled in the output\n        DAGs.  See :meth:`copy_empty_like` for details on the modes.",
        "api_signature": "serial_layers(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "multigraph_layers",
        "full_api_name": "DAGCircuit.multigraph_layers",
        "api_description": "Yield layers of the multigraph.",
        "api_signature": "multigraph_layers(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "collect_runs",
        "full_api_name": "DAGCircuit.collect_runs",
        "api_description": "Return a set of non-conditional runs of \"op\" nodes with the given names.\n\nFor example, \"... h q[0]; cx q[0],q[1]; cx q[0],q[1]; h q[1]; ..\"\nwould produce the tuple of cx nodes as an element of the set returned\nfrom a call to collect_runs([\"cx\"]). If instead the cx nodes were\n\"cx q[0],q[1]; cx q[1],q[0];\", the method would still return the\npair in a tuple. The namelist can contain names that are not\nin the circuit's basis.\n\nNodes must have only one successor to continue the run.",
        "api_signature": "collect_runs(self, namelist)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "filter_fn",
        "full_api_name": "DAGCircuit.filter_fn",
        "api_description": "",
        "api_signature": "filter_fn(node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "collect_1q_runs",
        "full_api_name": "DAGCircuit.collect_1q_runs",
        "api_description": "Return a set of non-conditional runs of 1q \"op\" nodes.",
        "api_signature": "collect_1q_runs(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "collect_2q_runs",
        "full_api_name": "DAGCircuit.collect_2q_runs",
        "api_description": "Return a set of non-conditional runs of 2q \"op\" nodes.",
        "api_signature": "collect_2q_runs(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "color_fn",
        "full_api_name": "DAGCircuit.color_fn",
        "api_description": "",
        "api_signature": "color_fn(edge)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "nodes_on_wire",
        "full_api_name": "DAGCircuit.nodes_on_wire",
        "api_description": "Iterator for nodes that affect a given wire.\n\nArgs:\n    wire (Bit): the wire to be looked at.\n    only_ops (bool): True if only the ops nodes are wanted;\n                otherwise, all nodes are returned.\nYield:\n     Iterator: the successive nodes on the given wire\n\nRaises:\n    DAGCircuitError: if the given wire doesn't exist in the DAG",
        "api_signature": "nodes_on_wire(self, wire, only_ops)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "count_ops",
        "full_api_name": "DAGCircuit.count_ops",
        "api_description": "Count the occurrences of operation names.\n\nArgs:\n    recurse: if ``True`` (default), then recurse into control-flow operations.  In all\n        cases, this counts only the number of times the operation appears in any possible\n        block; both branches of if-elses are counted, and for- and while-loop blocks are\n        only counted once.\n\nReturns:\n    Mapping[str, int]: a mapping of operation names to the number of times it appears.",
        "api_signature": "count_ops(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "inner",
        "full_api_name": "DAGCircuit.inner",
        "api_description": "",
        "api_signature": "inner(dag, counts)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "count_ops_longest_path",
        "full_api_name": "DAGCircuit.count_ops_longest_path",
        "api_description": "Count the occurrences of operation names on the longest path.\n\nReturns a dictionary of counts keyed on the operation name.",
        "api_signature": "count_ops_longest_path(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "quantum_causal_cone",
        "full_api_name": "DAGCircuit.quantum_causal_cone",
        "api_description": "Returns causal cone of a qubit.\n\nA qubit's causal cone is the set of qubits that can influence the output of that\nqubit through interactions, whether through multi-qubit gates or operations. Knowing\nthe causal cone of a qubit can be useful when debugging faulty circuits, as it can\nhelp identify which wire(s) may be causing the problem.\n\nThis method does not consider any classical data dependency in the ``DAGCircuit``,\nclassical bit wires are ignored for the purposes of building the causal cone.\n\nArgs:\n    qubit (~qiskit.circuit.Qubit): The output qubit for which we want to find the causal cone.\n\nReturns:\n    Set[~qiskit.circuit.Qubit]: The set of qubits whose interactions affect ``qubit``.",
        "api_signature": "quantum_causal_cone(self, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "properties",
        "full_api_name": "DAGCircuit.properties",
        "api_description": "Return a dictionary of circuit properties.",
        "api_signature": "properties(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "draw",
        "full_api_name": "DAGCircuit.draw",
        "api_description": "Draws the dag circuit.\n\nThis function needs `Graphviz <https://www.graphviz.org/>`_ to be\ninstalled. Graphviz is not a python package and can't be pip installed\n(the ``graphviz`` package on PyPI is a Python interface library for\nGraphviz and does not actually install Graphviz). You can refer to\n`the Graphviz documentation <https://www.graphviz.org/download/>`__ on\nhow to install it.\n\nArgs:\n    scale (float): scaling factor\n    filename (str): file path to save image to (format inferred from name)\n    style (str):\n        'plain': B&W graph;\n        'color' (default): color input/output/op nodes\n\nReturns:\n    Ipython.display.Image: if in Jupyter notebook and not saving to file,\n    otherwise None.",
        "api_signature": "draw(self, scale, filename, style)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "_DAGVarInfo.__init__",
        "api_description": "",
        "api_signature": "__init__(self, var, type_, in_node, out_node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "_may_have_additional_wires",
        "full_api_name": "_may_have_additional_wires",
        "api_description": "Return whether a given :class:`.DAGOpNode` may contain references to additional wires\nlocations within its :class:`.Operation`.  If this is ``True``, it doesn't necessarily mean\nthat the operation _will_ access memory inherently, but a ``False`` return guarantees that it\nwon't.\n\nThe memory might be classical bits or classical variables, such as a control-flow operation or a\nstore.\n\nArgs:\n    operation (qiskit.dagcircuit.DAGOpNode): the operation to check.",
        "api_signature": "_may_have_additional_wires(node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "_additional_wires",
        "full_api_name": "_additional_wires",
        "api_description": "Return an iterable over the additional tracked memory usage in this operation.  These\nadditional wires include (for example, non-exhaustive) bits referred to by a ``condition`` or\nthe classical variables involved in control-flow operations.\n\nArgs:\n    operation: the :class:`~.circuit.Operation` instance for a node.\n\nReturns:\n    Iterable: the additional wires inherent to this operation.",
        "api_signature": "_additional_wires(operation)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "_wires_from_expr",
        "full_api_name": "_wires_from_expr",
        "api_description": "",
        "api_signature": "_wires_from_expr(node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagcircuit.py"
    },
    {
        "api_name": "_legacy_condition_eq",
        "full_api_name": "_legacy_condition_eq",
        "api_description": "",
        "api_signature": "_legacy_condition_eq(cond1, cond2, bit_indices1, bit_indices2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagnode.py"
    },
    {
        "api_name": "_circuit_to_dag",
        "full_api_name": "_circuit_to_dag",
        "api_description": "Get a :class:`.DAGCircuit` of the given :class:`.QuantumCircuit`.  The bits in the output\nwill be ordered in a canonical order based on their indices in the outer DAG, as defined by the\n``bit_indices`` mapping and the ``node_{q,c}args`` arguments.",
        "api_signature": "_circuit_to_dag(circuit, node_qargs, node_cargs, bit_indices)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagnode.py"
    },
    {
        "api_name": "sort_key",
        "full_api_name": "sort_key",
        "api_description": "",
        "api_signature": "sort_key(bits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagnode.py"
    },
    {
        "api_name": "_make_expr_key",
        "full_api_name": "_make_expr_key",
        "api_description": "",
        "api_signature": "_make_expr_key(bit_indices)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagnode.py"
    },
    {
        "api_name": "key",
        "full_api_name": "key",
        "api_description": "",
        "api_signature": "key(var)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagnode.py"
    },
    {
        "api_name": "_condition_op_eq",
        "full_api_name": "_condition_op_eq",
        "api_description": "",
        "api_signature": "_condition_op_eq(node1, node2, bit_indices1, bit_indices2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagnode.py"
    },
    {
        "api_name": "_switch_case_eq",
        "full_api_name": "_switch_case_eq",
        "api_description": "",
        "api_signature": "_switch_case_eq(node1, node2, bit_indices1, bit_indices2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagnode.py"
    },
    {
        "api_name": "_for_loop_eq",
        "full_api_name": "_for_loop_eq",
        "api_description": "",
        "api_signature": "_for_loop_eq(node1, node2, bit_indices1, bit_indices2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagnode.py"
    },
    {
        "api_name": "_semantic_eq",
        "full_api_name": "_semantic_eq",
        "api_description": "Check if DAG nodes are considered equivalent, e.g., as a node_match for\n:func:`rustworkx.is_isomorphic_node_match`.\n\nArgs:\n    node1 (DAGOpNode, DAGInNode, DAGOutNode): A node to compare.\n    node2 (DAGOpNode, DAGInNode, DAGOutNode): The other node to compare.\n    bit_indices1 (dict): Dictionary mapping Bit instances to their index\n        within the circuit containing node1\n    bit_indices2 (dict): Dictionary mapping Bit instances to their index\n        within the circuit containing node2\n\nReturn:\n    Bool: If node1 == node2",
        "api_signature": "_semantic_eq(node1, node2, bit_indices1, bit_indices2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagnode.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "DAGDependency.__init__",
        "api_description": "Create an empty DAGDependency.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency.py"
    },
    {
        "api_name": "global_phase",
        "full_api_name": "DAGDependency.global_phase",
        "api_description": "Return the global phase of the circuit.",
        "api_signature": "global_phase(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency.py"
    },
    {
        "api_name": "global_phase",
        "full_api_name": "DAGDependency.global_phase",
        "api_description": "Set the global phase of the circuit.\n\nArgs:\n    angle (float, ParameterExpression)",
        "api_signature": "global_phase(self, angle)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency.py"
    },
    {
        "api_name": "calibrations",
        "full_api_name": "DAGDependency.calibrations",
        "api_description": "Return calibration dictionary.\n\nThe custom pulse definition of a given gate is of the form\n``{'gate_name': {(qubits, params): schedule}}``.",
        "api_signature": "calibrations(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency.py"
    },
    {
        "api_name": "calibrations",
        "full_api_name": "DAGDependency.calibrations",
        "api_description": "Set the circuit calibration data from a dictionary of calibration definition.\n\nArgs:\n    calibrations (dict): A dictionary of input in the format\n        {'gate_name': {(qubits, gate_params): schedule}}",
        "api_signature": "calibrations(self, calibrations)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency.py"
    },
    {
        "api_name": "to_retworkx",
        "full_api_name": "DAGDependency.to_retworkx",
        "api_description": "Returns the DAGDependency in retworkx format.",
        "api_signature": "to_retworkx(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency.py"
    },
    {
        "api_name": "size",
        "full_api_name": "DAGDependency.size",
        "api_description": "Returns the number of gates in the circuit",
        "api_signature": "size(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency.py"
    },
    {
        "api_name": "depth",
        "full_api_name": "DAGDependency.depth",
        "api_description": "Return the circuit depth.\nReturns:\n    int: the circuit depth",
        "api_signature": "depth(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency.py"
    },
    {
        "api_name": "add_qubits",
        "full_api_name": "DAGDependency.add_qubits",
        "api_description": "Add individual qubit wires.",
        "api_signature": "add_qubits(self, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency.py"
    },
    {
        "api_name": "add_clbits",
        "full_api_name": "DAGDependency.add_clbits",
        "api_description": "Add individual clbit wires.",
        "api_signature": "add_clbits(self, clbits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency.py"
    },
    {
        "api_name": "add_qreg",
        "full_api_name": "DAGDependency.add_qreg",
        "api_description": "Add qubits in a quantum register.",
        "api_signature": "add_qreg(self, qreg)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency.py"
    },
    {
        "api_name": "add_creg",
        "full_api_name": "DAGDependency.add_creg",
        "api_description": "Add clbits in a classical register.",
        "api_signature": "add_creg(self, creg)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency.py"
    },
    {
        "api_name": "_add_multi_graph_node",
        "full_api_name": "DAGDependency._add_multi_graph_node",
        "api_description": "Args:\n    node (DAGDepNode): considered node.\n\nReturns:\n    node_id(int): corresponding label to the added node.",
        "api_signature": "_add_multi_graph_node(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency.py"
    },
    {
        "api_name": "get_nodes",
        "full_api_name": "DAGDependency.get_nodes",
        "api_description": "Returns:\n    generator(dict): iterator over all the nodes.",
        "api_signature": "get_nodes(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency.py"
    },
    {
        "api_name": "get_node",
        "full_api_name": "DAGDependency.get_node",
        "api_description": "Args:\n    node_id (int): label of considered node.\n\nReturns:\n    node: corresponding to the label.",
        "api_signature": "get_node(self, node_id)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency.py"
    },
    {
        "api_name": "_add_multi_graph_edge",
        "full_api_name": "DAGDependency._add_multi_graph_edge",
        "api_description": "Function to add an edge from given data (dict) between two nodes.\n\nArgs:\n    src_id (int): label of the first node.\n    dest_id (int): label of the second node.\n    data (dict): data contained on the edge.",
        "api_signature": "_add_multi_graph_edge(self, src_id, dest_id, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency.py"
    },
    {
        "api_name": "get_edges",
        "full_api_name": "DAGDependency.get_edges",
        "api_description": "Edge enumeration between two nodes through method get_all_edge_data.\n\nArgs:\n    src_id (int): label of the first node.\n    dest_id (int): label of the second node.\n\nReturns:\n    List: corresponding to all edges between the two nodes.",
        "api_signature": "get_edges(self, src_id, dest_id)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency.py"
    },
    {
        "api_name": "get_all_edges",
        "full_api_name": "DAGDependency.get_all_edges",
        "api_description": "Enumeration of all edges.\n\nReturns:\n    List: corresponding to the label.",
        "api_signature": "get_all_edges(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency.py"
    },
    {
        "api_name": "get_in_edges",
        "full_api_name": "DAGDependency.get_in_edges",
        "api_description": "Enumeration of all incoming edges for a given node.\n\nArgs:\n    node_id (int): label of considered node.\n\nReturns:\n    List: corresponding incoming edges data.",
        "api_signature": "get_in_edges(self, node_id)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency.py"
    },
    {
        "api_name": "get_out_edges",
        "full_api_name": "DAGDependency.get_out_edges",
        "api_description": "Enumeration of all outgoing edges for a given node.\n\nArgs:\n    node_id (int): label of considered node.\n\nReturns:\n    List: corresponding outgoing edges data.",
        "api_signature": "get_out_edges(self, node_id)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency.py"
    },
    {
        "api_name": "direct_successors",
        "full_api_name": "DAGDependency.direct_successors",
        "api_description": "Direct successors id of a given node as sorted list.\n\nArgs:\n    node_id (int): label of considered node.\n\nReturns:\n    List: direct successors id as a sorted list",
        "api_signature": "direct_successors(self, node_id)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency.py"
    },
    {
        "api_name": "direct_predecessors",
        "full_api_name": "DAGDependency.direct_predecessors",
        "api_description": "Direct predecessors id of a given node as sorted list.\n\nArgs:\n    node_id (int): label of considered node.\n\nReturns:\n    List: direct predecessors id as a sorted list",
        "api_signature": "direct_predecessors(self, node_id)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency.py"
    },
    {
        "api_name": "successors",
        "full_api_name": "DAGDependency.successors",
        "api_description": "Successors id of a given node as sorted list.\n\nArgs:\n    node_id (int): label of considered node.\n\nReturns:\n    List: all successors id as a sorted list",
        "api_signature": "successors(self, node_id)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency.py"
    },
    {
        "api_name": "predecessors",
        "full_api_name": "DAGDependency.predecessors",
        "api_description": "Predecessors id of a given node as sorted list.\n\nArgs:\n    node_id (int): label of considered node.\n\nReturns:\n    List: all predecessors id as a sorted list",
        "api_signature": "predecessors(self, node_id)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency.py"
    },
    {
        "api_name": "topological_nodes",
        "full_api_name": "DAGDependency.topological_nodes",
        "api_description": "Yield nodes in topological order.\n\nReturns:\n    generator(DAGNode): node in topological order.",
        "api_signature": "topological_nodes(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency.py"
    },
    {
        "api_name": "_key",
        "full_api_name": "DAGDependency._key",
        "api_description": "",
        "api_signature": "_key(x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency.py"
    },
    {
        "api_name": "_create_op_node",
        "full_api_name": "DAGDependency._create_op_node",
        "api_description": "Creates a DAGDepNode to the graph and update the edges.\n\nArgs:\n    operation (qiskit.circuit.Operation): operation\n    qargs (list[~qiskit.circuit.Qubit]): list of qubits on which the operation acts\n    cargs (list[Clbit]): list of classical wires to attach to\n\nReturns:\n    DAGDepNode: the newly added node.",
        "api_signature": "_create_op_node(self, operation, qargs, cargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency.py"
    },
    {
        "api_name": "add_op_node",
        "full_api_name": "DAGDependency.add_op_node",
        "api_description": "Add a DAGDepNode to the graph and update the edges.\n\nArgs:\n    operation (qiskit.circuit.Operation): operation as a quantum gate\n    qargs (list[~qiskit.circuit.Qubit]): list of qubits on which the operation acts\n    cargs (list[Clbit]): list of classical wires to attach to",
        "api_signature": "add_op_node(self, operation, qargs, cargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency.py"
    },
    {
        "api_name": "_update_edges",
        "full_api_name": "DAGDependency._update_edges",
        "api_description": "Updates DagDependency by adding edges to the newly added node (max_node)\nfrom the previously added nodes.\nFor each previously added node (prev_node), an edge from prev_node to max_node\nis added if max_node is \"reachable\" from prev_node (this means that the two\nnodes can be made adjacent by commuting them with other nodes), but the two nodes\nthemselves do not commute.\n\nCurrently. this function is only used when creating a new DAGDependency from another\nrepresentation of a circuit, and hence there are no removed nodes (this is why\niterating over all nodes is fine).",
        "api_signature": "_update_edges(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency.py"
    },
    {
        "api_name": "_add_successors",
        "full_api_name": "DAGDependency._add_successors",
        "api_description": "Create the list of successors. Update DAGDependency 'successors' attribute. It has to\nbe used when the DAGDependency() object is complete (i.e. converters).",
        "api_signature": "_add_successors(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency.py"
    },
    {
        "api_name": "_add_predecessors",
        "full_api_name": "DAGDependency._add_predecessors",
        "api_description": "Create the list of predecessors for each node. Update DAGDependency\n'predecessors' attribute. It has to be used when the DAGDependency() object\nis complete (i.e. converters).",
        "api_signature": "_add_predecessors(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency.py"
    },
    {
        "api_name": "copy",
        "full_api_name": "DAGDependency.copy",
        "api_description": "Function to copy a DAGDependency object.\nReturns:\n    DAGDependency: a copy of a DAGDependency object.",
        "api_signature": "copy(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency.py"
    },
    {
        "api_name": "draw",
        "full_api_name": "DAGDependency.draw",
        "api_description": "Draws the DAGDependency graph.\n\nThis function needs `pydot <https://github.com/erocarrera/pydot>`, which in turn needs\nGraphviz <https://www.graphviz.org/>` to be installed.\n\nArgs:\n    scale (float): scaling factor\n    filename (str): file path to save image to (format inferred from name)\n    style (str): 'plain': B&W graph\n                 'color' (default): color input/output/op nodes\n\nReturns:\n    Ipython.display.Image: if in Jupyter notebook and not saving to file, otherwise None.",
        "api_signature": "draw(self, scale, filename, style)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency.py"
    },
    {
        "api_name": "replace_block_with_op",
        "full_api_name": "DAGDependency.replace_block_with_op",
        "api_description": "Replace a block of nodes with a single node.\n\nThis is used to consolidate a block of DAGDepNodes into a single\noperation. A typical example is a block of CX and SWAP gates consolidated\ninto a LinearFunction. This function is an adaptation of a similar\nfunction from DAGCircuit.\n\nIt is important that such consolidation preserves commutativity assumptions\npresent in DAGDependency. As an example, suppose that every node in a\nblock [A, B, C, D] commutes with another node E. Let F be the consolidated\nnode, F = A o B o C o D. Then F also commutes with E, and thus the result of\nreplacing [A, B, C, D] by F results in a valid DAGDependency. That is, any\ndeduction about commutativity in consolidated DAGDependency is correct.\nOn the other hand, suppose that at least one of the nodes, say B, does not commute\nwith E. Then the consolidated DAGDependency would imply that F does not commute\nwith E. Even though F and E may actually commute, it is still safe to assume that\nthey do not. That is, the current implementation of consolidation may lead to\nsuboptimal but not to incorrect results.\n\nArgs:\n    node_block (List[DAGDepNode]): A list of dag nodes that represents the\n        node block to be replaced\n    op (qiskit.circuit.Operation): The operation to replace the\n        block with\n    wire_pos_map (Dict[~qiskit.circuit.Qubit, int]): The dictionary mapping the qarg to\n        the position. This is necessary to reconstruct the qarg order\n        over multiple gates in the combined single op node.\n    cycle_check (bool): When set to True this method will check that\n        replacing the provided ``node_block`` with a single node\n        would introduce a cycle (which would invalidate the\n        ``DAGDependency``) and will raise a ``DAGDependencyError`` if a cycle\n        would be introduced. This checking comes with a run time\n        penalty. If you can guarantee that your input ``node_block`` is\n        a contiguous block and won't introduce a cycle when it's\n        contracted to a single node, this can be set to ``False`` to\n        improve the runtime performance of this method.\nRaises:\n    DAGDependencyError: if ``cycle_check`` is set to ``True`` and replacing\n        the specified block introduces a cycle or if ``node_block`` is\n        empty.",
        "api_signature": "replace_block_with_op(self, node_block, op, wire_pos_map, cycle_check)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency.py"
    },
    {
        "api_name": "merge_no_duplicates",
        "full_api_name": "merge_no_duplicates",
        "api_description": "Merge K list without duplicate using python heapq ordered merging\n\nArgs:\n    *iterables: A list of k sorted lists\n\nYields:\n    Iterator: List from the merging of the k ones (without duplicates",
        "api_signature": "merge_no_duplicates()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "DAGCircuitError.__init__",
        "api_description": "Set the error message.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/exceptions.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "DAGCircuitError.__str__",
        "api_description": "Return the message.",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/exceptions.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "DAGDependencyError.__init__",
        "api_description": "Set the error message.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/exceptions.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "DAGDependencyError.__str__",
        "api_description": "Return the message.",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/exceptions.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BlockCollector.__init__",
        "api_description": "Args:\n    dag (Union[DAGCircuit, DAGDependency]): The input DAG.\n\nRaises:\n    DAGCircuitError: the input object is not a DAG.",
        "api_signature": "__init__(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/collect_blocks.py"
    },
    {
        "api_name": "_setup_in_degrees",
        "full_api_name": "BlockCollector._setup_in_degrees",
        "api_description": "For an efficient implementation, for every node we keep the number of its\nunprocessed immediate predecessors (called ``_in_degree``). This ``_in_degree``\nis set up at the start and updated throughout the algorithm.\nA node is leaf (or input) node iff its ``_in_degree`` is 0.\nWhen a node is (marked as) collected, the ``_in_degree`` of each of its immediate\nsuccessor is updated by subtracting 1.\nAdditionally, ``_pending_nodes`` explicitly keeps the list of nodes whose\n``_in_degree`` is 0.",
        "api_signature": "_setup_in_degrees(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/collect_blocks.py"
    },
    {
        "api_name": "_op_nodes",
        "full_api_name": "BlockCollector._op_nodes",
        "api_description": "Returns DAG nodes.",
        "api_signature": "_op_nodes(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/collect_blocks.py"
    },
    {
        "api_name": "_direct_preds",
        "full_api_name": "BlockCollector._direct_preds",
        "api_description": "Returns direct predecessors of a node. This function takes into account the\ndirection of collecting blocks, that is node's predecessors when collecting\nbackwards are the direct successors of a node in the DAG.",
        "api_signature": "_direct_preds(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/collect_blocks.py"
    },
    {
        "api_name": "_direct_succs",
        "full_api_name": "BlockCollector._direct_succs",
        "api_description": "Returns direct successors of a node. This function takes into account the\ndirection of collecting blocks, that is node's successors when collecting\nbackwards are the direct predecessors of a node in the DAG.",
        "api_signature": "_direct_succs(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/collect_blocks.py"
    },
    {
        "api_name": "_have_uncollected_nodes",
        "full_api_name": "BlockCollector._have_uncollected_nodes",
        "api_description": "Returns whether there are uncollected (pending) nodes",
        "api_signature": "_have_uncollected_nodes(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/collect_blocks.py"
    },
    {
        "api_name": "collect_matching_block",
        "full_api_name": "BlockCollector.collect_matching_block",
        "api_description": "Iteratively collects the largest block of input nodes (that is, nodes with\n``_in_degree`` equal to 0) that match a given filtering function.\nExamples of this include collecting blocks of swap gates,\nblocks of linear gates (CXs and SWAPs), blocks of Clifford gates, blocks of single-qubit gates,\nblocks of two-qubit gates, etc.  Here 'iteratively' means that once a node is collected,\nthe ``_in_degree`` of each of its immediate successor is decreased by 1, allowing more nodes\nto become input and to be eligible for collecting into the current block.\nReturns the block of collected nodes.",
        "api_signature": "collect_matching_block(self, filter_fn)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/collect_blocks.py"
    },
    {
        "api_name": "collect_all_matching_blocks",
        "full_api_name": "BlockCollector.collect_all_matching_blocks",
        "api_description": "Collects all blocks that match a given filtering function filter_fn.\nThis iteratively finds the largest block that does not match filter_fn,\nthen the largest block that matches filter_fn, and so on, until no more uncollected\nnodes remain. Intuitively, finding larger blocks of non-matching nodes helps to\nfind larger blocks of matching nodes later on.\n\nAfter the blocks are collected, they can be optionally refined. The option\n``split_blocks`` allows to split collected blocks into sub-blocks over disjoint\nqubit subsets. The option ``split_layers`` allows to split collected blocks\ninto layers of non-overlapping instructions. The option ``min_block_size``\nspecifies the minimum number of gates in the block for the block to be collected.\n\nBy default, blocks are collected in the direction from the inputs towards the outputs\nof the circuit. The option ``collect_from_back`` allows to change this direction,\nthat is collect blocks from the outputs towards the inputs of the circuit.\n\nReturns the list of matching blocks only.",
        "api_signature": "collect_all_matching_blocks(self, filter_fn, split_blocks, min_block_size, split_layers, collect_from_back)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/collect_blocks.py"
    },
    {
        "api_name": "not_filter_fn",
        "full_api_name": "BlockCollector.not_filter_fn",
        "api_description": "Returns the opposite of filter_fn.",
        "api_signature": "not_filter_fn(node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/collect_blocks.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BlockSplitter.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/collect_blocks.py"
    },
    {
        "api_name": "find_leader",
        "full_api_name": "BlockSplitter.find_leader",
        "api_description": "Find in DSU.",
        "api_signature": "find_leader(self, index)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/collect_blocks.py"
    },
    {
        "api_name": "union_leaders",
        "full_api_name": "BlockSplitter.union_leaders",
        "api_description": "Union in DSU.",
        "api_signature": "union_leaders(self, index1, index2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/collect_blocks.py"
    },
    {
        "api_name": "run",
        "full_api_name": "BlockSplitter.run",
        "api_description": "Splits block of nodes into sub-blocks over disjoint qubits.",
        "api_signature": "run(self, block)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/collect_blocks.py"
    },
    {
        "api_name": "split_block_into_layers",
        "full_api_name": "split_block_into_layers",
        "api_description": "Splits a block of nodes into sub-blocks of non-overlapping instructions\n(or, in other words, into depth-1 sub-blocks).",
        "api_signature": "split_block_into_layers(block)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/collect_blocks.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BlockCollapser.__init__",
        "api_description": "Args:\n    dag (Union[DAGCircuit, DAGDependency]): The input DAG.",
        "api_signature": "__init__(self, dag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/collect_blocks.py"
    },
    {
        "api_name": "collapse_to_operation",
        "full_api_name": "BlockCollapser.collapse_to_operation",
        "api_description": "For each block, constructs a quantum circuit containing instructions in the block,\nthen uses collapse_fn to collapse this circuit into a single operation.",
        "api_signature": "collapse_to_operation(self, blocks, collapse_fn)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/collect_blocks.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "DAGDepNode.__init__",
        "api_description": "",
        "api_signature": "__init__(self, type, op, name, qargs, cargs, successors, predecessors, reachable, matchedwith, successorstovisit, isblocked, qindices, cindices, nid)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdepnode.py"
    },
    {
        "api_name": "op",
        "full_api_name": "DAGDepNode.op",
        "api_description": "Returns the Instruction object corresponding to the op for the node, else None",
        "api_signature": "op(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdepnode.py"
    },
    {
        "api_name": "op",
        "full_api_name": "DAGDepNode.op",
        "api_description": "",
        "api_signature": "op(self, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdepnode.py"
    },
    {
        "api_name": "qargs",
        "full_api_name": "DAGDepNode.qargs",
        "api_description": "Returns list of Qubit, else an empty list.",
        "api_signature": "qargs(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdepnode.py"
    },
    {
        "api_name": "qargs",
        "full_api_name": "DAGDepNode.qargs",
        "api_description": "Sets the qargs to be the given list of qargs.",
        "api_signature": "qargs(self, new_qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdepnode.py"
    },
    {
        "api_name": "semantic_eq",
        "full_api_name": "DAGDepNode.semantic_eq",
        "api_description": "Check if DAG nodes are considered equivalent, e.g., as a node_match for nx.is_isomorphic.\n\nArgs:\n    node1 (DAGDepNode): A node to compare.\n    node2 (DAGDepNode): The other node to compare.\n\nReturn:\n    Bool: If node1 == node2",
        "api_signature": "semantic_eq(node1, node2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdepnode.py"
    },
    {
        "api_name": "copy",
        "full_api_name": "DAGDepNode.copy",
        "api_description": "Function to copy a DAGDepNode object.\nReturns:\n    DAGDepNode: a copy of a DAGDepNode object.",
        "api_signature": "copy(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdepnode.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "_DAGDependencyV2.__init__",
        "api_description": "Create an empty _DAGDependencyV2.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency_v2.py"
    },
    {
        "api_name": "global_phase",
        "full_api_name": "_DAGDependencyV2.global_phase",
        "api_description": "Return the global phase of the circuit.",
        "api_signature": "global_phase(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency_v2.py"
    },
    {
        "api_name": "global_phase",
        "full_api_name": "_DAGDependencyV2.global_phase",
        "api_description": "Set the global phase of the circuit.\n\nArgs:\n    angle (float, ParameterExpression)",
        "api_signature": "global_phase(self, angle)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency_v2.py"
    },
    {
        "api_name": "calibrations",
        "full_api_name": "_DAGDependencyV2.calibrations",
        "api_description": "Return calibration dictionary.\n\nThe custom pulse definition of a given gate is of the form\n``{'gate_name': {(qubits, params): schedule}}``.",
        "api_signature": "calibrations(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency_v2.py"
    },
    {
        "api_name": "calibrations",
        "full_api_name": "_DAGDependencyV2.calibrations",
        "api_description": "Set the circuit calibration data from a dictionary of calibration definition.\n\nArgs:\n    calibrations (dict): A dictionary of input in the format\n        {'gate_name': {(qubits, gate_params): schedule}}",
        "api_signature": "calibrations(self, calibrations)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency_v2.py"
    },
    {
        "api_name": "add_calibration",
        "full_api_name": "_DAGDependencyV2.add_calibration",
        "api_description": "Register a low-level, custom pulse definition for the given gate.\n\nArgs:\n    gate (Union[Gate, str]): Gate information.\n    qubits (Union[int, Tuple[int]]): List of qubits to be measured.\n    schedule (Schedule): Schedule information.\n    params (Optional[List[Union[float, Parameter]]]): A list of parameters.\n\nRaises:\n    Exception: if the gate is of type string and params is None.",
        "api_signature": "add_calibration(self, gate, qubits, schedule, params)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency_v2.py"
    },
    {
        "api_name": "_format",
        "full_api_name": "_DAGDependencyV2._format",
        "api_description": "",
        "api_signature": "_format(operand)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency_v2.py"
    },
    {
        "api_name": "has_calibration_for",
        "full_api_name": "_DAGDependencyV2.has_calibration_for",
        "api_description": "Return True if the dag has a calibration defined for the node operation. In this\ncase, the operation does not need to be translated to the device basis.",
        "api_signature": "has_calibration_for(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency_v2.py"
    },
    {
        "api_name": "size",
        "full_api_name": "_DAGDependencyV2.size",
        "api_description": "Returns the number of gates in the circuit",
        "api_signature": "size(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency_v2.py"
    },
    {
        "api_name": "depth",
        "full_api_name": "_DAGDependencyV2.depth",
        "api_description": "Return the circuit depth.\nReturns:\n    int: the circuit depth",
        "api_signature": "depth(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency_v2.py"
    },
    {
        "api_name": "width",
        "full_api_name": "_DAGDependencyV2.width",
        "api_description": "Return the total number of qubits + clbits used by the circuit.",
        "api_signature": "width(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency_v2.py"
    },
    {
        "api_name": "num_qubits",
        "full_api_name": "_DAGDependencyV2.num_qubits",
        "api_description": "Return the total number of qubits used by the circuit.",
        "api_signature": "num_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency_v2.py"
    },
    {
        "api_name": "num_clbits",
        "full_api_name": "_DAGDependencyV2.num_clbits",
        "api_description": "Return the total number of classical bits used by the circuit.",
        "api_signature": "num_clbits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency_v2.py"
    },
    {
        "api_name": "add_qubits",
        "full_api_name": "_DAGDependencyV2.add_qubits",
        "api_description": "Add individual qubit wires.",
        "api_signature": "add_qubits(self, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency_v2.py"
    },
    {
        "api_name": "add_clbits",
        "full_api_name": "_DAGDependencyV2.add_clbits",
        "api_description": "Add individual clbit wires.",
        "api_signature": "add_clbits(self, clbits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency_v2.py"
    },
    {
        "api_name": "add_qreg",
        "full_api_name": "_DAGDependencyV2.add_qreg",
        "api_description": "Add qubits in a quantum register.",
        "api_signature": "add_qreg(self, qreg)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency_v2.py"
    },
    {
        "api_name": "add_creg",
        "full_api_name": "_DAGDependencyV2.add_creg",
        "api_description": "Add clbits in a classical register.",
        "api_signature": "add_creg(self, creg)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency_v2.py"
    },
    {
        "api_name": "find_bit",
        "full_api_name": "_DAGDependencyV2.find_bit",
        "api_description": "Finds locations in the _DAGDependencyV2, by mapping the Qubit and Clbit to positional index\nBitLocations is defined as: BitLocations = namedtuple(\"BitLocations\", (\"index\", \"registers\"))\n\nArgs:\n    bit (Bit): The bit to locate.\n\nReturns:\n    namedtuple(int, List[Tuple(Register, int)]): A 2-tuple. The first element (``index``)\n        contains the index at which the ``Bit`` can be found (in either\n        :obj:`~_DAGDependencyV2.qubits`, :obj:`~_DAGDependencyV2.clbits`, depending on its\n        type). The second element (``registers``) is a list of ``(register, index)``\n        pairs with an entry for each :obj:`~Register` in the circuit which contains the\n        :obj:`~Bit` (and the index in the :obj:`~Register` at which it can be found).\n\n  Raises:\n    DAGDependencyError: If the supplied :obj:`~Bit` was of an unknown type.\n    DAGDependencyError: If the supplied :obj:`~Bit` could not be found on the circuit.",
        "api_signature": "find_bit(self, bit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency_v2.py"
    },
    {
        "api_name": "apply_operation_back",
        "full_api_name": "_DAGDependencyV2.apply_operation_back",
        "api_description": "Add a DAGOpNode to the graph and update the edges.\n\nArgs:\n    operation (qiskit.circuit.Operation): operation as a quantum gate\n    qargs (list[~qiskit.circuit.Qubit]): list of qubits on which the operation acts\n    cargs (list[Clbit]): list of classical wires to attach to",
        "api_signature": "apply_operation_back(self, operation, qargs, cargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency_v2.py"
    },
    {
        "api_name": "_update_edges",
        "full_api_name": "_DAGDependencyV2._update_edges",
        "api_description": "Updates DagDependencyV2 by adding edges to the newly added node (max_node)\nfrom the previously added nodes.\nFor each previously added node (prev_node), an edge from prev_node to max_node\nis added if max_node is \"reachable\" from prev_node (this means that the two\nnodes can be made adjacent by commuting them with other nodes), but the two nodes\nthemselves do not commute.\n\nCurrently. this function is only used when creating a new _DAGDependencyV2 from another\nrepresentation of a circuit, and hence there are no removed nodes (this is why\niterating over all nodes is fine).",
        "api_signature": "_update_edges(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency_v2.py"
    },
    {
        "api_name": "_get_node",
        "full_api_name": "_DAGDependencyV2._get_node",
        "api_description": "Args:\n    node_id (int): label of considered node.\n\nReturns:\n    node: corresponding to the label.",
        "api_signature": "_get_node(self, node_id)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency_v2.py"
    },
    {
        "api_name": "named_nodes",
        "full_api_name": "_DAGDependencyV2.named_nodes",
        "api_description": "Get the set of \"op\" nodes with the given name.",
        "api_signature": "named_nodes(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency_v2.py"
    },
    {
        "api_name": "_increment_op",
        "full_api_name": "_DAGDependencyV2._increment_op",
        "api_description": "",
        "api_signature": "_increment_op(self, op)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency_v2.py"
    },
    {
        "api_name": "_decrement_op",
        "full_api_name": "_DAGDependencyV2._decrement_op",
        "api_description": "",
        "api_signature": "_decrement_op(self, op)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency_v2.py"
    },
    {
        "api_name": "count_ops",
        "full_api_name": "_DAGDependencyV2.count_ops",
        "api_description": "Count the occurrences of operation names.",
        "api_signature": "count_ops(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency_v2.py"
    },
    {
        "api_name": "op_nodes",
        "full_api_name": "_DAGDependencyV2.op_nodes",
        "api_description": "Returns:\n    generator(dict): iterator over all the nodes.",
        "api_signature": "op_nodes(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency_v2.py"
    },
    {
        "api_name": "topological_nodes",
        "full_api_name": "_DAGDependencyV2.topological_nodes",
        "api_description": "Yield nodes in topological order.\n\nArgs:\n    key (Callable): A callable which will take a DAGNode object and\n        return a string sort key. If not specified the\n        :attr:`~qiskit.dagcircuit.DAGNode.sort_key` attribute will be\n        used as the sort key for each node.\n\nReturns:\n    generator(DAGOpNode): node in topological order",
        "api_signature": "topological_nodes(self, key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency_v2.py"
    },
    {
        "api_name": "_key",
        "full_api_name": "_DAGDependencyV2._key",
        "api_description": "",
        "api_signature": "_key(x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency_v2.py"
    },
    {
        "api_name": "topological_op_nodes",
        "full_api_name": "_DAGDependencyV2.topological_op_nodes",
        "api_description": "Yield nodes in topological order. This is a wrapper for topological_nodes since\nall nodes are op nodes. It's here so that calls to dag.topological_op_nodes can\nuse either DAGCircuit or _DAGDependencyV2.\n\nReturns:\n    generator(DAGOpNode): nodes in topological order.",
        "api_signature": "topological_op_nodes(self, key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency_v2.py"
    },
    {
        "api_name": "successors",
        "full_api_name": "_DAGDependencyV2.successors",
        "api_description": "Returns iterator of the successors of a node as DAGOpNodes.",
        "api_signature": "successors(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency_v2.py"
    },
    {
        "api_name": "predecessors",
        "full_api_name": "_DAGDependencyV2.predecessors",
        "api_description": "Returns iterator of the predecessors of a node as DAGOpNodes.",
        "api_signature": "predecessors(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency_v2.py"
    },
    {
        "api_name": "is_successor",
        "full_api_name": "_DAGDependencyV2.is_successor",
        "api_description": "Checks if a second node is in the successors of node.",
        "api_signature": "is_successor(self, node, node_succ)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency_v2.py"
    },
    {
        "api_name": "is_predecessor",
        "full_api_name": "_DAGDependencyV2.is_predecessor",
        "api_description": "Checks if a second node is in the predecessors of node.",
        "api_signature": "is_predecessor(self, node, node_pred)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency_v2.py"
    },
    {
        "api_name": "ancestors",
        "full_api_name": "_DAGDependencyV2.ancestors",
        "api_description": "Returns set of the ancestors of a node as DAGOpNodes.",
        "api_signature": "ancestors(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency_v2.py"
    },
    {
        "api_name": "descendants",
        "full_api_name": "_DAGDependencyV2.descendants",
        "api_description": "Returns set of the descendants of a node as DAGOpNodes.",
        "api_signature": "descendants(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency_v2.py"
    },
    {
        "api_name": "bfs_successors",
        "full_api_name": "_DAGDependencyV2.bfs_successors",
        "api_description": "Returns an iterator of tuples of (DAGOpNode, [DAGOpNodes]) where the DAGOpNode is the\ncurrent node and [DAGOpNode] is its successors in  BFS order.",
        "api_signature": "bfs_successors(self, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency_v2.py"
    },
    {
        "api_name": "copy_empty_like",
        "full_api_name": "_DAGDependencyV2.copy_empty_like",
        "api_description": "Return a copy of self with the same structure but empty.\n\nThat structure includes:\n    * name and other metadata\n    * global phase\n    * duration\n    * all the qubits and clbits, including the registers.\n\nReturns:\n    _DAGDependencyV2: An empty copy of self.",
        "api_signature": "copy_empty_like(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency_v2.py"
    },
    {
        "api_name": "draw",
        "full_api_name": "_DAGDependencyV2.draw",
        "api_description": "Draws the _DAGDependencyV2 graph.\n\nThis function needs `pydot <https://github.com/erocarrera/pydot>`, which in turn needs\nGraphviz <https://www.graphviz.org/>` to be installed.\n\nArgs:\n    scale (float): scaling factor\n    filename (str): file path to save image to (format inferred from name)\n    style (str): 'plain': B&W graph\n                 'color' (default): color input/output/op nodes\n\nReturns:\n    Ipython.display.Image: if in Jupyter notebook and not saving to file, otherwise None.",
        "api_signature": "draw(self, scale, filename, style)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency_v2.py"
    },
    {
        "api_name": "replace_block_with_op",
        "full_api_name": "_DAGDependencyV2.replace_block_with_op",
        "api_description": "Replace a block of nodes with a single node.\n\nThis is used to consolidate a block of DAGOpNodes into a single\noperation. A typical example is a block of CX and SWAP gates consolidated\ninto a LinearFunction. This function is an adaptation of a similar\nfunction from DAGCircuit.\n\nIt is important that such consolidation preserves commutativity assumptions\npresent in _DAGDependencyV2. As an example, suppose that every node in a\nblock [A, B, C, D] commutes with another node E. Let F be the consolidated\nnode, F = A o B o C o D. Then F also commutes with E, and thus the result of\nreplacing [A, B, C, D] by F results in a valid _DAGDependencyV2. That is, any\ndeduction about commutativity in consolidated _DAGDependencyV2 is correct.\nOn the other hand, suppose that at least one of the nodes, say B, does not commute\nwith E. Then the consolidated _DAGDependencyV2 would imply that F does not commute\nwith E. Even though F and E may actually commute, it is still safe to assume that\nthey do not. That is, the current implementation of consolidation may lead to\nsuboptimal but not to incorrect results.\n\nArgs:\n    node_block (List[DAGOpNode]): A list of dag nodes that represents the\n        node block to be replaced\n    op (qiskit.circuit.Operation): The operation to replace the\n        block with\n    wire_pos_map (Dict[~qiskit.circuit.Qubit, int]): The dictionary mapping the qarg to\n        the position. This is necessary to reconstruct the qarg order\n        over multiple gates in the combined single op node.\n    cycle_check (bool): When set to True this method will check that\n        replacing the provided ``node_block`` with a single node\n        would introduce a cycle (which would invalidate the\n        ``_DAGDependencyV2``) and will raise a ``DAGDependencyError`` if a cycle\n        would be introduced. This checking comes with a run time\n        penalty. If you can guarantee that your input ``node_block`` is\n        a contiguous block and won't introduce a cycle when it's\n        contracted to a single node, this can be set to ``False`` to\n        improve the runtime performance of this method.\nRaises:\n    DAGDependencyError: if ``cycle_check`` is set to ``True`` and replacing\n        the specified block introduces a cycle or if ``node_block`` is\n        empty.",
        "api_signature": "replace_block_with_op(self, node_block, op, wire_pos_map, cycle_check)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/dagcircuit/dagdependency_v2.py"
    },
    {
        "api_name": "plot_state_hinton",
        "full_api_name": "plot_state_hinton",
        "api_description": "Plot a hinton diagram for the density matrix of a quantum state.\n\nThe hinton diagram represents the values of a matrix using\nsquares, whose size indicate the magnitude of their corresponding value\nand their color, its sign. A white square means the value is positive and\na black one means negative.\n\nArgs:\n    state (Statevector or DensityMatrix or ndarray): An N-qubit quantum state.\n    title (str): a string that represents the plot title\n    figsize (tuple): Figure size in inches.\n    filename (str): file path to save image to.\n    ax_real (matplotlib.axes.Axes): An optional Axes object to be used for\n        the visualization output. If none is specified a new matplotlib\n        Figure will be created and used. If this is specified without an\n        ax_imag only the real component plot will be generated.\n        Additionally, if specified there will be no returned Figure since\n        it is redundant.\n    ax_imag (matplotlib.axes.Axes): An optional Axes object to be used for\n        the visualization output. If none is specified a new matplotlib\n        Figure will be created and used. If this is specified without an\n        ax_imag only the real component plot will be generated.\n        Additionally, if specified there will be no returned Figure since\n        it is redundant.\n\nReturns:\n    :class:`matplotlib:matplotlib.figure.Figure` :\n        The matplotlib.Figure of the visualization if\n        neither ax_real or ax_imag is set.\n\nRaises:\n    MissingOptionalLibraryError: Requires matplotlib.\n    VisualizationError: if input is not a valid N-qubit state.\n\nExamples:\n    .. plot::\n       :include-source:\n\n        import numpy as np\n        from qiskit import QuantumCircuit\n        from qiskit.quantum_info import DensityMatrix\n        from qiskit.visualization import plot_state_hinton\n\n        qc = QuantumCircuit(2)\n        qc.h([0, 1])\n        qc.cz(0,1)\n        qc.ry(np.pi/3 , 0)\n        qc.rx(np.pi/5, 1)\n\n        state = DensityMatrix(qc)\n        plot_state_hinton(state, title=\"New Hinton Plot\")",
        "api_signature": "plot_state_hinton(state, title, figsize, ax_real, ax_imag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/state_visualization.py"
    },
    {
        "api_name": "plot_bloch_vector",
        "full_api_name": "plot_bloch_vector",
        "api_description": "Plot the Bloch sphere.\n\nPlot a Bloch sphere with the specified coordinates, that can be given in both\ncartesian and spherical systems.\n\nArgs:\n    bloch (list[double]): array of three elements where [<x>, <y>, <z>] (Cartesian)\n        or [<r>, <theta>, <phi>] (spherical in radians)\n        <theta> is inclination angle from +z direction\n        <phi> is azimuth from +x direction\n    title (str): a string that represents the plot title\n    ax (matplotlib.axes.Axes): An Axes to use for rendering the bloch\n        sphere\n    figsize (tuple): Figure size in inches. Has no effect is passing ``ax``.\n    coord_type (str): a string that specifies coordinate type for bloch\n        (Cartesian or spherical), default is Cartesian\n    font_size (float): Font size.\n\nReturns:\n    :class:`matplotlib:matplotlib.figure.Figure` : A matplotlib figure instance if ``ax = None``.\n\nRaises:\n    MissingOptionalLibraryError: Requires matplotlib.\n\nExamples:\n    .. plot::\n       :include-source:\n\n       from qiskit.visualization import plot_bloch_vector\n\n       plot_bloch_vector([0,1,0], title=\"New Bloch Sphere\")\n\n    .. plot::\n       :include-source:\n\n       import numpy as np\n       from qiskit.visualization import plot_bloch_vector\n\n       # You can use spherical coordinates instead of cartesian.\n\n       plot_bloch_vector([1, np.pi/2, np.pi/3], coord_type='spherical')",
        "api_signature": "plot_bloch_vector(bloch, title, ax, figsize, coord_type, font_size)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/state_visualization.py"
    },
    {
        "api_name": "plot_bloch_multivector",
        "full_api_name": "plot_bloch_multivector",
        "api_description": "Plot a Bloch sphere for each qubit.\n\nEach component :math:`(x,y,z)` of the Bloch sphere labeled as 'qubit i' represents the expected\nvalue of the corresponding Pauli operator acting only on that qubit, that is, the expected value\nof :math:`I_{N-1} \\otimes\\dotsb\\otimes I_{i+1}\\otimes P_i \\otimes I_{i-1}\\otimes\\dotsb\\otimes\nI_0`, where :math:`N` is the number of qubits, :math:`P\\in \\{X,Y,Z\\}` and :math:`I` is the\nidentity operator.\n\nArgs:\n    state (Statevector or DensityMatrix or ndarray): an N-qubit quantum state.\n    title (str): a string that represents the plot title\n    figsize (tuple): size of each individual Bloch sphere figure, in inches.\n    reverse_bits (bool): If True, plots qubits following Qiskit's convention [Default:False].\n    font_size (float): Font size for the Bloch ball figures.\n    title_font_size (float): Font size for the title.\n    title_pad (float): Padding for the title (suptitle `y` position is `y=1+title_pad/100`).\n\nReturns:\n    :class:`matplotlib:matplotlib.figure.Figure` :\n        A matplotlib figure instance.\n\nRaises:\n    MissingOptionalLibraryError: Requires matplotlib.\n    VisualizationError: if input is not a valid N-qubit state.\n\nExamples:\n    .. plot::\n       :include-source:\n\n        from qiskit import QuantumCircuit\n        from qiskit.quantum_info import Statevector\n        from qiskit.visualization import plot_bloch_multivector\n\n        qc = QuantumCircuit(2)\n        qc.h(0)\n        qc.x(1)\n\n        state = Statevector(qc)\n        plot_bloch_multivector(state)\n\n    .. plot::\n       :include-source:\n\n       from qiskit import QuantumCircuit\n       from qiskit.quantum_info import Statevector\n       from qiskit.visualization import plot_bloch_multivector\n\n       qc = QuantumCircuit(2)\n       qc.h(0)\n       qc.x(1)\n\n       # You can reverse the order of the qubits.\n\n       from qiskit.quantum_info import DensityMatrix\n\n       qc = QuantumCircuit(2)\n       qc.h([0, 1])\n       qc.t(1)\n       qc.s(0)\n       qc.cx(0,1)\n\n       matrix = DensityMatrix(qc)\n       plot_bloch_multivector(matrix, title='My Bloch Spheres', reverse_bits=True)",
        "api_signature": "plot_bloch_multivector(state, title, figsize)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/state_visualization.py"
    },
    {
        "api_name": "plot_state_city",
        "full_api_name": "plot_state_city",
        "api_description": "Plot the cityscape of quantum state.\n\nPlot two 3d bar graphs (two dimensional) of the real and imaginary\npart of the density matrix rho.\n\nArgs:\n    state (Statevector or DensityMatrix or ndarray): an N-qubit quantum state.\n    title (str): a string that represents the plot title\n    figsize (tuple): Figure size in inches.\n    color (list): A list of len=2 giving colors for real and\n        imaginary components of matrix elements.\n    alpha (float): Transparency value for bars\n    ax_real (matplotlib.axes.Axes): An optional Axes object to be used for\n        the visualization output. If none is specified a new matplotlib\n        Figure will be created and used. If this is specified without an\n        ax_imag only the real component plot will be generated.\n        Additionally, if specified there will be no returned Figure since\n        it is redundant.\n    ax_imag (matplotlib.axes.Axes): An optional Axes object to be used for\n        the visualization output. If none is specified a new matplotlib\n        Figure will be created and used. If this is specified without an\n        ax_real only the imaginary component plot will be generated.\n        Additionally, if specified there will be no returned Figure since\n        it is redundant.\n\nReturns:\n    :class:`matplotlib:matplotlib.figure.Figure` :\n        The matplotlib.Figure of the visualization if the\n        ``ax_real`` and ``ax_imag`` kwargs are not set\n\nRaises:\n    MissingOptionalLibraryError: Requires matplotlib.\n    ValueError: When 'color' is not a list of len=2.\n    VisualizationError: if input is not a valid N-qubit state.\n\nExamples:\n    .. plot::\n       :include-source:\n\n       # You can choose different colors for the real and imaginary parts of the density matrix.\n\n       from qiskit import QuantumCircuit\n       from qiskit.quantum_info import DensityMatrix\n       from qiskit.visualization import plot_state_city\n\n       qc = QuantumCircuit(2)\n       qc.h(0)\n       qc.cx(0, 1)\n\n       state = DensityMatrix(qc)\n       plot_state_city(state, color=['midnightblue', 'crimson'], title=\"New State City\")\n\n    .. plot::\n       :include-source:\n\n       # You can make the bars more transparent to better see the ones that are behind\n       # if they overlap.\n\n       import numpy as np\n       from qiskit.quantum_info import Statevector\n       from qiskit.visualization import plot_state_city\n       from qiskit import QuantumCircuit\n\n       qc = QuantumCircuit(2)\n       qc.h(0)\n       qc.cx(0, 1)\n\n\n       qc = QuantumCircuit(2)\n       qc.h([0, 1])\n       qc.cz(0,1)\n       qc.ry(np.pi/3, 0)\n       qc.rx(np.pi/5, 1)\n\n       state = Statevector(qc)\n       plot_state_city(state, alpha=0.6)",
        "api_signature": "plot_state_city(state, title, figsize, color, alpha, ax_real, ax_imag)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/state_visualization.py"
    },
    {
        "api_name": "plot_state_paulivec",
        "full_api_name": "plot_state_paulivec",
        "api_description": "Plot the Pauli-vector representation of a quantum state as bar graph.\n\nThe Pauli-vector of a density matrix :math:`\\rho` is defined by the expectation of each\npossible tensor product of single-qubit Pauli operators (including the identity), that is\n\n.. math ::\n\n    \\rho = \\frac{1}{2^n} \\sum_{\\sigma \\in \\{I, X, Y, Z\\}^{\\otimes n}}\n           \\mathrm{Tr}(\\sigma \\rho) \\sigma.\n\nThis function plots the coefficients :math:`\\mathrm{Tr}(\\sigma\\rho)` as bar graph.\n\nArgs:\n    state (Statevector or DensityMatrix or ndarray): an N-qubit quantum state.\n    title (str): a string that represents the plot title\n    figsize (tuple): Figure size in inches.\n    color (list or str): Color of the coefficient value bars.\n    ax (matplotlib.axes.Axes): An optional Axes object to be used for\n        the visualization output. If none is specified a new matplotlib\n        Figure will be created and used. Additionally, if specified there\n        will be no returned Figure since it is redundant.\n\nReturns:\n     :class:`matplotlib:matplotlib.figure.Figure` :\n        The matplotlib.Figure of the visualization if the\n        ``ax`` kwarg is not set\n\nRaises:\n    MissingOptionalLibraryError: Requires matplotlib.\n    VisualizationError: if input is not a valid N-qubit state.\n\nExamples:\n    .. plot::\n       :include-source:\n\n       # You can set a color for all the bars.\n\n       from qiskit import QuantumCircuit\n       from qiskit.quantum_info import Statevector\n       from qiskit.visualization import plot_state_paulivec\n\n       qc = QuantumCircuit(2)\n       qc.h(0)\n       qc.cx(0, 1)\n\n       state = Statevector(qc)\n       plot_state_paulivec(state, color='midnightblue', title=\"New PauliVec plot\")\n\n    .. plot::\n       :include-source:\n\n       # If you introduce a list with less colors than bars, the color of the bars will\n       # alternate following the sequence from the list.\n\n       import numpy as np\n       from qiskit.quantum_info import DensityMatrix\n       from qiskit import QuantumCircuit\n       from qiskit.visualization import plot_state_paulivec\n\n       qc = QuantumCircuit(2)\n       qc.h(0)\n       qc.cx(0, 1)\n\n       qc = QuantumCircuit(2)\n       qc.h([0, 1])\n       qc.cz(0, 1)\n       qc.ry(np.pi/3, 0)\n       qc.rx(np.pi/5, 1)\n\n       matrix = DensityMatrix(qc)\n       plot_state_paulivec(matrix, color=['crimson', 'midnightblue', 'seagreen'])",
        "api_signature": "plot_state_paulivec(state, title, figsize, color, ax)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/state_visualization.py"
    },
    {
        "api_name": "n_choose_k",
        "full_api_name": "n_choose_k",
        "api_description": "Return the number of combinations for n choose k.\n\nArgs:\n    n (int): the total number of options .\n    k (int): The number of elements.\n\nReturns:\n    int: returns the binomial coefficient",
        "api_signature": "n_choose_k(n, k)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/state_visualization.py"
    },
    {
        "api_name": "lex_index",
        "full_api_name": "lex_index",
        "api_description": "Return  the lex index of a combination..\n\nArgs:\n    n (int): the total number of options .\n    k (int): The number of elements.\n    lst (list): list\n\nReturns:\n    int: returns int index for lex order\n\nRaises:\n    VisualizationError: if length of list is not equal to k",
        "api_signature": "lex_index(n, k, lst)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/state_visualization.py"
    },
    {
        "api_name": "bit_string_index",
        "full_api_name": "bit_string_index",
        "api_description": "Return the index of a string of 0s and 1s.",
        "api_signature": "bit_string_index(s)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/state_visualization.py"
    },
    {
        "api_name": "phase_to_rgb",
        "full_api_name": "phase_to_rgb",
        "api_description": "Map a phase of a complexnumber to a color in (r,g,b).\n\ncomplex_number is phase is first mapped to angle in the range\n[0, 2pi] and then to the HSL color wheel",
        "api_signature": "phase_to_rgb(complex_number)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/state_visualization.py"
    },
    {
        "api_name": "plot_state_qsphere",
        "full_api_name": "plot_state_qsphere",
        "api_description": "Plot the qsphere representation of a quantum state.\nHere, the size of the points is proportional to the probability\nof the corresponding term in the state and the color represents\nthe phase.\n\nArgs:\n    state (Statevector or DensityMatrix or ndarray): an N-qubit quantum state.\n    figsize (tuple): Figure size in inches.\n    ax (matplotlib.axes.Axes): An optional Axes object to be used for\n        the visualization output. If none is specified a new matplotlib\n        Figure will be created and used. Additionally, if specified there\n        will be no returned Figure since it is redundant.\n    show_state_labels (bool): An optional boolean indicating whether to\n        show labels for each basis state.\n    show_state_phases (bool): An optional boolean indicating whether to\n        show the phase for each basis state.\n    use_degrees (bool): An optional boolean indicating whether to use\n        radians or degrees for the phase values in the plot.\n\nReturns:\n    :class:`matplotlib:matplotlib.figure.Figure` :\n        A matplotlib figure instance if the ``ax`` kwarg is not set\n\nRaises:\n    MissingOptionalLibraryError: Requires matplotlib.\n    VisualizationError: if input is not a valid N-qubit state.\n\n    QiskitError: Input statevector does not have valid dimensions.\n\nExamples:\n    .. plot::\n       :include-source:\n\n       from qiskit import QuantumCircuit\n       from qiskit.quantum_info import Statevector\n       from qiskit.visualization import plot_state_qsphere\n\n       qc = QuantumCircuit(2)\n       qc.h(0)\n       qc.cx(0, 1)\n\n       state = Statevector(qc)\n       plot_state_qsphere(state)\n\n    .. plot::\n       :include-source:\n\n       # You can show the phase of each state and use\n       # degrees instead of radians\n\n       from qiskit.quantum_info import DensityMatrix\n       import numpy as np\n       from qiskit import QuantumCircuit\n       from qiskit.visualization import plot_state_qsphere\n\n       qc = QuantumCircuit(2)\n       qc.h([0, 1])\n       qc.cz(0,1)\n       qc.ry(np.pi/3, 0)\n       qc.rx(np.pi/5, 1)\n       qc.z(1)\n\n       matrix = DensityMatrix(qc)\n       plot_state_qsphere(matrix,\n            show_state_phases = True, use_degrees = True)",
        "api_signature": "plot_state_qsphere(state, figsize, ax, show_state_labels, show_state_phases, use_degrees)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/state_visualization.py"
    },
    {
        "api_name": "generate_facecolors",
        "full_api_name": "generate_facecolors",
        "api_description": "Generates shaded facecolors for shaded bars.\n\nThis is here to work around a Matplotlib bug\nwhere alpha does not work in Bar3D.\n\nArgs:\n    x (array_like): The x- coordinates of the anchor point of the bars.\n    y (array_like): The y- coordinates of the anchor point of the bars.\n    z (array_like): The z- coordinates of the anchor point of the bars.\n    dx (array_like): Width of bars.\n    dy (array_like): Depth of bars.\n    dz (array_like): Height of bars.\n    color (array_like): sequence of valid color specifications, optional\nReturns:\n    list: Shaded colors for bars.\nRaises:\n    MissingOptionalLibraryError: If matplotlib is not installed",
        "api_signature": "generate_facecolors(x, y, z, dx, dy, dz, color)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/state_visualization.py"
    },
    {
        "api_name": "_generate_normals",
        "full_api_name": "_generate_normals",
        "api_description": "Takes a list of polygons and return an array of their normals.\n\nNormals point towards the viewer for a face with its vertices in\ncounterclockwise order, following the right hand rule.\nUses three points equally spaced around the polygon.\nThis normal of course might not make sense for polygons with more than\nthree points not lying in a plane, but it's a plausible and fast\napproximation.\n\nArgs:\n    polygons (list): list of (M_i, 3) array_like, or (..., M, 3) array_like\n        A sequence of polygons to compute normals for, which can have\n        varying numbers of vertices. If the polygons all have the same\n        number of vertices and array is passed, then the operation will\n        be vectorized.\nReturns:\n    normals: (..., 3) array_like\n        A normal vector estimated for the polygon.",
        "api_signature": "_generate_normals(polygons)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/state_visualization.py"
    },
    {
        "api_name": "_shade_colors",
        "full_api_name": "_shade_colors",
        "api_description": "Shade *color* using normal vectors given by *normals*.\n*color* can also be an array of the same length as *normals*.",
        "api_signature": "_shade_colors(color, normals, lightsource)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/state_visualization.py"
    },
    {
        "api_name": "mod",
        "full_api_name": "mod",
        "api_description": "",
        "api_signature": "mod(v)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/state_visualization.py"
    },
    {
        "api_name": "state_to_latex",
        "full_api_name": "state_to_latex",
        "api_description": "Return a Latex representation of a state. Wrapper function\nfor `qiskit.visualization.array_to_latex` for convention 'vector'.\nAdds dims if necessary.\nIntended for use within `state_drawer`.\n\nArgs:\n    state: State to be drawn\n    dims (bool): Whether to display the state's `dims`\n    convention (str): Either 'vector' or 'ket'. For 'ket' plot the state in the ket-notation.\n            Otherwise plot as a vector\n    **args: Arguments to be passed directly to `array_to_latex` for convention 'ket'\n\nReturns:\n    Latex representation of the state",
        "api_signature": "state_to_latex(state, dims, convention)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/state_visualization.py"
    },
    {
        "api_name": "_numbers_to_latex_terms",
        "full_api_name": "_numbers_to_latex_terms",
        "api_description": "Convert a list of numbers to latex formatted terms\n\nThe first non-zero term is treated differently. For this term a leading + is suppressed.\n\nArgs:\n    numbers: List of numbers to format\n    decimals: Number of decimal places to round to (default: 10).\nReturns:\n    List of formatted terms",
        "api_signature": "_numbers_to_latex_terms(numbers, decimals)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/state_visualization.py"
    },
    {
        "api_name": "_state_to_latex_ket",
        "full_api_name": "_state_to_latex_ket",
        "api_description": "Convert state vector to latex representation\n\nArgs:\n    data: State vector\n    max_size: Maximum number of non-zero terms in the expression. If the number of\n             non-zero terms is larger than the max_size, then the representation is truncated.\n    prefix: Latex string to be prepended to the latex, intended for labels.\n    decimals: Number of decimal places to round to (default: 10).\n\nReturns:\n    String with LaTeX representation of the state vector",
        "api_signature": "_state_to_latex_ket(data, max_size, prefix, decimals)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/state_visualization.py"
    },
    {
        "api_name": "ket_name",
        "full_api_name": "ket_name",
        "api_description": "",
        "api_signature": "ket_name(i)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/state_visualization.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "TextMatrix.__init__",
        "api_description": "",
        "api_signature": "__init__(self, state, max_size, dims, prefix, suffix)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/state_visualization.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "TextMatrix.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/state_visualization.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "TextMatrix.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/state_visualization.py"
    },
    {
        "api_name": "state_drawer",
        "full_api_name": "state_drawer",
        "api_description": "Returns a visualization of the state.\n\n**repr**: ASCII TextMatrix of the state's ``_repr_``.\n\n**text**: ASCII TextMatrix that can be printed in the console.\n\n**latex**: An IPython Latex object for displaying in Jupyter Notebooks.\n\n**latex_source**: Raw, uncompiled ASCII source to generate array using LaTeX.\n\n**qsphere**: Matplotlib figure, rendering of statevector using `plot_state_qsphere()`.\n\n**hinton**: Matplotlib figure, rendering of statevector using `plot_state_hinton()`.\n\n**bloch**: Matplotlib figure, rendering of statevector using `plot_bloch_multivector()`.\n\n**city**: Matplotlib figure, rendering of statevector using `plot_state_city()`.\n\n**paulivec**: Matplotlib figure, rendering of statevector using `plot_state_paulivec()`.\n\nArgs:\n    output (str): Select the output method to use for drawing the\n        circuit. Valid choices are ``text``, ``latex``, ``latex_source``,\n        ``qsphere``, ``hinton``, ``bloch``, ``city`` or ``paulivec``.\n        Default is `'text`'.\n    drawer_args: Arguments to be passed to the relevant drawer. For\n        'latex' and 'latex_source' see ``array_to_latex``\n\nReturns:\n    :class:`matplotlib.figure` or :class:`str` or\n    :class:`TextMatrix` or :class:`IPython.display.Latex`:\n    Drawing of the state.\n\nRaises:\n    MissingOptionalLibraryError: when `output` is `latex` and IPython is not installed.\n    ValueError: when `output` is not a valid selection.",
        "api_signature": "state_drawer(state, output)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/state_visualization.py"
    },
    {
        "api_name": "_bloch_multivector_data",
        "full_api_name": "_bloch_multivector_data",
        "api_description": "Return list of Bloch vectors for each qubit\n\nArgs:\n    state (DensityMatrix or Statevector): an N-qubit state.\n\nReturns:\n    list: list of Bloch vectors (x, y, z) for each qubit.\n\nRaises:\n    VisualizationError: if input is not an N-qubit state.",
        "api_signature": "_bloch_multivector_data(state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/state_visualization.py"
    },
    {
        "api_name": "_paulivec_data",
        "full_api_name": "_paulivec_data",
        "api_description": "Return paulivec data for plotting.\n\nArgs:\n    state (DensityMatrix or Statevector): an N-qubit state.\n\nReturns:\n    tuple: (labels, values) for Pauli vector.\n\nRaises:\n    VisualizationError: if input is not an N-qubit state.",
        "api_signature": "_paulivec_data(state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/state_visualization.py"
    },
    {
        "api_name": "_normalize",
        "full_api_name": "_normalize",
        "api_description": "Makes sure magnitude of the vector is 1 with given tolerance",
        "api_signature": "_normalize(v, tolerance)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/transition_visualization.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "_Quaternion.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/transition_visualization.py"
    },
    {
        "api_name": "from_axisangle",
        "full_api_name": "_Quaternion.from_axisangle",
        "api_description": "Create quaternion from axis",
        "api_signature": "from_axisangle(theta, v)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/transition_visualization.py"
    },
    {
        "api_name": "from_value",
        "full_api_name": "_Quaternion.from_value",
        "api_description": "Create quaternion from vector",
        "api_signature": "from_value(value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/transition_visualization.py"
    },
    {
        "api_name": "_axisangle_to_q",
        "full_api_name": "_Quaternion._axisangle_to_q",
        "api_description": "Convert axis and angle to quaternion",
        "api_signature": "_axisangle_to_q(self, theta, v)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/transition_visualization.py"
    },
    {
        "api_name": "__mul__",
        "full_api_name": "_Quaternion.__mul__",
        "api_description": "Multiplication of quaternion with quaternion or vector",
        "api_signature": "__mul__(self, b)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/transition_visualization.py"
    },
    {
        "api_name": "_multiply_with_quaternion",
        "full_api_name": "_Quaternion._multiply_with_quaternion",
        "api_description": "Multiplication of quaternion with quaternion",
        "api_signature": "_multiply_with_quaternion(self, q_2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/transition_visualization.py"
    },
    {
        "api_name": "_multiply_with_vector",
        "full_api_name": "_Quaternion._multiply_with_vector",
        "api_description": "Multiplication of quaternion with vector",
        "api_signature": "_multiply_with_vector(self, v)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/transition_visualization.py"
    },
    {
        "api_name": "get_conjugate",
        "full_api_name": "_Quaternion.get_conjugate",
        "api_description": "Conjugation of quaternion",
        "api_signature": "get_conjugate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/transition_visualization.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "_Quaternion.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/transition_visualization.py"
    },
    {
        "api_name": "get_axisangle",
        "full_api_name": "_Quaternion.get_axisangle",
        "api_description": "Returns angle and vector of quaternion",
        "api_signature": "get_axisangle(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/transition_visualization.py"
    },
    {
        "api_name": "tolist",
        "full_api_name": "_Quaternion.tolist",
        "api_description": "Converts quaternion to a list",
        "api_signature": "tolist(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/transition_visualization.py"
    },
    {
        "api_name": "vector_norm",
        "full_api_name": "_Quaternion.vector_norm",
        "api_description": "Calculates norm of quaternion",
        "api_signature": "vector_norm(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/transition_visualization.py"
    },
    {
        "api_name": "visualize_transition",
        "full_api_name": "visualize_transition",
        "api_description": "Creates animation showing transitions between states of a single\nqubit by applying quantum gates.\n\nArgs:\n    circuit (QuantumCircuit): Qiskit single-qubit QuantumCircuit. Gates supported are\n        h,x, y, z, rx, ry, rz, s, sdg, t, tdg and u1.\n    trace (bool): Controls whether to display tracing vectors - history of 10 past vectors\n        at each step of the animation.\n    saveas (str): User can choose to save the animation as a video to their filesystem.\n        This argument is a string of path with filename and extension (e.g. \"movie.mp4\" to\n        save the video in current working directory).\n    fpg (int): Frames per gate. Finer control over animation smoothness and computational\n        needs to render the animation. Works well for tkinter GUI as it is, for jupyter GUI\n        it might be preferable to choose fpg between 5-30.\n    spg (int): Seconds per gate. How many seconds should animation of individual gate\n        transitions take.\n\nReturns:\n    IPython.core.display.HTML:\n        If arg jupyter is set to True. Otherwise opens tkinter GUI and returns\n        after the GUI is closed.\n\nRaises:\n    MissingOptionalLibraryError: Must have Matplotlib (and/or IPython) installed.\n    VisualizationError: Given gate(s) are not supported.",
        "api_signature": "visualize_transition(circuit, trace, saveas, fpg, spg)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/transition_visualization.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Namespace.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/transition_visualization.py"
    },
    {
        "api_name": "animate",
        "full_api_name": "animate",
        "api_description": "",
        "api_signature": "animate(i)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/transition_visualization.py"
    },
    {
        "api_name": "init",
        "full_api_name": "init",
        "api_description": "",
        "api_signature": "init()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/transition_visualization.py"
    },
    {
        "api_name": "_trim",
        "full_api_name": "_trim",
        "api_description": "Trim a PIL image and remove white space.",
        "api_signature": "_trim(image)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/utils.py"
    },
    {
        "api_name": "matplotlib_close_if_inline",
        "full_api_name": "matplotlib_close_if_inline",
        "api_description": "Close the given matplotlib figure if the backend in use draws figures inline.\n\nIf the backend does not draw figures inline, this does nothing.  This function is to prevent\nduplicate images appearing; the inline backends will capture the figure in preparation and\ndisplay it as well, whereas the drawers want to return the figure to be displayed.",
        "api_signature": "matplotlib_close_if_inline(figure)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/utils.py"
    },
    {
        "api_name": "_generate_circuit_library_visualization",
        "full_api_name": "_generate_circuit_library_visualization",
        "api_description": "",
        "api_signature": "_generate_circuit_library_visualization(circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/library.py"
    },
    {
        "api_name": "hamming_distance",
        "full_api_name": "hamming_distance",
        "api_description": "Calculate the Hamming distance between two bit strings\n\nArgs:\n    str1 (str): First string.\n    str2 (str): Second string.\nReturns:\n    int: Distance between strings.\nRaises:\n    VisualizationError: Strings not same length",
        "api_signature": "hamming_distance(str1, str2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/counts_visualization.py"
    },
    {
        "api_name": "_is_deprecated_data_format",
        "full_api_name": "_is_deprecated_data_format",
        "api_description": "",
        "api_signature": "_is_deprecated_data_format(data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/counts_visualization.py"
    },
    {
        "api_name": "plot_histogram",
        "full_api_name": "plot_histogram",
        "api_description": "Plot a histogram of input counts data.\n\nArgs:\n    data (list or dict): This is either a list of dictionaries or a single\n        dict containing the values to represent (ex ``{'001': 130}``)\n\n    figsize (tuple): Figure size in inches.\n    color (list or str): String or list of strings for histogram bar colors.\n    number_to_keep (int): The number of terms to plot per dataset.  The rest is made into a\n        single bar called 'rest'.  If multiple datasets are given, the ``number_to_keep``\n        applies to each dataset individually, which may result in more bars than\n        ``number_to_keep + 1``.  The ``number_to_keep`` applies to the total values, rather than\n        the x-axis sort.\n    sort (string): Could be `'asc'`, `'desc'`, `'hamming'`, `'value'`, or\n        `'value_desc'`. If set to `'value'` or `'value_desc'` the x axis\n        will be sorted by the number of counts for each bitstring.\n        Defaults to `'asc'`.\n    target_string (str): Target string if 'sort' is a distance measure.\n    legend(list): A list of strings to use for labels of the data.\n        The number of entries must match the length of data (if data is a\n        list or 1 if it's a dict)\n    bar_labels (bool): Label each bar in histogram with counts value.\n    title (str): A string to use for the plot title\n    ax (matplotlib.axes.Axes): An optional Axes object to be used for\n        the visualization output. If none is specified a new matplotlib\n        Figure will be created and used. Additionally, if specified there\n        will be no returned Figure since it is redundant.\n    filename (str): file path to save image to.\n\nReturns:\n    matplotlib.Figure:\n        A figure for the rendered histogram, if the ``ax``\n        kwarg is not set.\n\nRaises:\n    MissingOptionalLibraryError: Matplotlib not available.\n    VisualizationError: When legend is provided and the length doesn't\n        match the input data.\n    VisualizationError: Input must be Counts or a dict\n\nExamples:\n    .. plot::\n       :include-source:\n\n        # Plot two counts in the same figure with legends and colors specified.\n\n        from qiskit.visualization import plot_histogram\n\n        counts1 = {'00': 525, '11': 499}\n        counts2 = {'00': 511, '11': 514}\n\n        legend = ['First execution', 'Second execution']\n\n        plot_histogram([counts1, counts2], legend=legend, color=['crimson','midnightblue'],\n                        title=\"New Histogram\")\n\n        # You can sort the bitstrings using different methods.\n\n        counts = {'001': 596, '011': 211, '010': 50, '000': 117, '101': 33, '111': 8,\n                '100': 6, '110': 3}\n\n        # Sort by the counts in descending order\n        hist1 = plot_histogram(counts, sort='value_desc')\n\n        # Sort by the hamming distance (the number of bit flips to change from\n        # one bitstring to the other) from a target string.\n        hist2 = plot_histogram(counts, sort='hamming', target_string='001')",
        "api_signature": "plot_histogram(data, figsize, color, number_to_keep, sort, target_string, legend, bar_labels, title, ax, filename)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/counts_visualization.py"
    },
    {
        "api_name": "plot_distribution",
        "full_api_name": "plot_distribution",
        "api_description": "Plot a distribution from input sampled data.\n\nArgs:\n    data (list or dict): This is either a list of dictionaries or a single\n        dict containing the values to represent (ex {'001': 130})\n    figsize (tuple): Figure size in inches.\n    color (list or str): String or list of strings for distribution bar colors.\n    number_to_keep (int): The number of terms to plot per dataset.  The rest is made into a\n        single bar called 'rest'.  If multiple datasets are given, the ``number_to_keep``\n        applies to each dataset individually, which may result in more bars than\n        ``number_to_keep + 1``.  The ``number_to_keep`` applies to the total values, rather than\n        the x-axis sort.\n    sort (string): Could be `'asc'`, `'desc'`, `'hamming'`, `'value'`, or\n        `'value_desc'`. If set to `'value'` or `'value_desc'` the x axis\n        will be sorted by the maximum probability for each bitstring.\n        Defaults to `'asc'`.\n    target_string (str): Target string if 'sort' is a distance measure.\n    legend(list): A list of strings to use for labels of the data.\n        The number of entries must match the length of data (if data is a\n        list or 1 if it's a dict)\n    bar_labels (bool): Label each bar in histogram with probability value.\n    title (str): A string to use for the plot title\n    ax (matplotlib.axes.Axes): An optional Axes object to be used for\n        the visualization output. If none is specified a new matplotlib\n        Figure will be created and used. Additionally, if specified there\n        will be no returned Figure since it is redundant.\n    filename (str): file path to save image to.\n\nReturns:\n    matplotlib.Figure:\n        A figure for the rendered distribution, if the ``ax``\n        kwarg is not set.\n\nRaises:\n    MissingOptionalLibraryError: Matplotlib not available.\n    VisualizationError: When legend is provided and the length doesn't\n        match the input data.\n\nExamples:\n    .. plot::\n       :include-source:\n\n        # Plot two counts in the same figure with legends and colors specified.\n\n        from qiskit.visualization import plot_distribution\n\n        counts1 = {'00': 525, '11': 499}\n        counts2 = {'00': 511, '11': 514}\n\n        legend = ['First execution', 'Second execution']\n\n        plot_distribution([counts1, counts2], legend=legend, color=['crimson','midnightblue'],\n                        title=\"New Distribution\")\n\n        # You can sort the bitstrings using different methods.\n\n        counts = {'001': 596, '011': 211, '010': 50, '000': 117, '101': 33, '111': 8,\n                '100': 6, '110': 3}\n\n        # Sort by the counts in descending order\n        dist1 = plot_distribution(counts, sort='value_desc')\n\n        # Sort by the hamming distance (the number of bit flips to change from\n        # one bitstring to the other) from a target string.\n        dist2 = plot_distribution(counts, sort='hamming', target_string='001')",
        "api_signature": "plot_distribution(data, figsize, color, number_to_keep, sort, target_string, legend, bar_labels, title, ax, filename)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/counts_visualization.py"
    },
    {
        "api_name": "_plotting_core",
        "full_api_name": "_plotting_core",
        "api_description": "",
        "api_signature": "_plotting_core(data, figsize, color, number_to_keep, sort, target_string, legend, bar_labels, title, ax, filename, kind)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/counts_visualization.py"
    },
    {
        "api_name": "_keep_largest_items",
        "full_api_name": "_keep_largest_items",
        "api_description": "Keep only the largest values in a dictionary, and sum the rest into a new key 'rest'.",
        "api_signature": "_keep_largest_items(execution, number_to_keep)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/counts_visualization.py"
    },
    {
        "api_name": "_unify_labels",
        "full_api_name": "_unify_labels",
        "api_description": "Make all dictionaries in data have the same set of keys, using 0 for missing values.",
        "api_signature": "_unify_labels(data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/counts_visualization.py"
    },
    {
        "api_name": "_plot_data",
        "full_api_name": "_plot_data",
        "api_description": "Generate the data needed for plotting counts.\n\nParameters:\n    data (list or dict): This is either a list of dictionaries or a single\n        dict containing the values to represent (ex {'001': 130})\n    labels (list): The list of bitstring labels for the plot.\n    number_to_keep (int): The number of terms to plot and rest\n        is made into a single bar called 'rest'.\n    kind (str): One of 'counts' or 'distribution`\n\nReturns:\n    tuple: tuple containing:\n        (dict): The labels actually used in the plotting.\n        (list): List of ndarrays for the bars in each experiment.\n        (list): Indices for the locations of the bars for each\n                experiment.",
        "api_signature": "_plot_data(data, labels, number_to_keep, kind)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/counts_visualization.py"
    },
    {
        "api_name": "dag_drawer",
        "full_api_name": "dag_drawer",
        "api_description": "Plot the directed acyclic graph (dag) to represent operation dependencies\nin a quantum circuit.\n\nThis function calls the :func:`~rustworkx.visualization.graphviz_draw` function from the\n``rustworkx`` package to draw the DAG.\n\nArgs:\n    dag (DAGCircuit): The dag to draw.\n    scale (float): scaling factor\n    filename (str): file path to save image to (format inferred from name)\n    style (str): 'plain': B&W graph\n                 'color' (default): color input/output/op nodes\n\nReturns:\n    PIL.Image: if in Jupyter notebook and not saving to file,\n        otherwise None.\n\nRaises:\n    VisualizationError: when style is not recognized.\n    InvalidFileError: when filename provided is not valid\n\nExample:\n    .. plot::\n       :include-source:\n\n        from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit\n        from qiskit.dagcircuit import DAGCircuit\n        from qiskit.converters import circuit_to_dag\n        from qiskit.visualization import dag_drawer\n\n        q = QuantumRegister(3, 'q')\n        c = ClassicalRegister(3, 'c')\n        circ = QuantumCircuit(q, c)\n        circ.h(q[0])\n        circ.cx(q[0], q[1])\n        circ.measure(q[0], c[0])\n        circ.rz(0.5, q[1]).c_if(c, 2)\n\n        dag = circuit_to_dag(circ)\n        dag_drawer(dag)",
        "api_signature": "dag_drawer(dag, scale, filename, style)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/dag_visualization.py"
    },
    {
        "api_name": "node_attr_func",
        "full_api_name": "node_attr_func",
        "api_description": "",
        "api_signature": "node_attr_func(node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/dag_visualization.py"
    },
    {
        "api_name": "node_attr_func",
        "full_api_name": "node_attr_func",
        "api_description": "",
        "api_signature": "node_attr_func(node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/dag_visualization.py"
    },
    {
        "api_name": "edge_attr_func",
        "full_api_name": "edge_attr_func",
        "api_description": "",
        "api_signature": "edge_attr_func(edge)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/dag_visualization.py"
    },
    {
        "api_name": "_num_to_latex",
        "full_api_name": "_num_to_latex",
        "api_description": "Convert a complex number to latex code suitable for a ket expression\n\nArgs:\n    raw_value (complex): Value to convert.\n    decimals (int): Number of decimal places to round to (default 15).\n    coefficient (bool): Whether the number is to be used as a coefficient\n                        of a ket.\n    first_term (bool): If a coefficient, whether this number is the first\n                       coefficient in the expression.\nReturns:\n    str: latex code",
        "api_signature": "_num_to_latex(raw_value, decimals, first_term, coefficient)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/array.py"
    },
    {
        "api_name": "_matrix_to_latex",
        "full_api_name": "_matrix_to_latex",
        "api_description": "Latex representation of a complex numpy array (with maximum dimension 2)\n\nArgs:\n    matrix (ndarray): The matrix to be converted to latex, must have dimension 2.\n    decimals (int): For numbers not close to integers, the number of decimal places\n                     to round to.\n    prefix (str): Latex string to be prepended to the latex, intended for labels.\n    max_size (list(```int```)): Indexable containing two integers: Maximum width and maximum\n                      height of output Latex matrix (including dots characters). If the\n                      width and/or height of matrix exceeds the maximum, the centre values\n                      will be replaced with dots. Maximum width or height must be greater\n                      than 3.\n\nReturns:\n    str: Latex representation of the matrix\n\nRaises:\n    ValueError: If minimum value in max_size < 3",
        "api_signature": "_matrix_to_latex(matrix, decimals, prefix, max_size)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/array.py"
    },
    {
        "api_name": "_elements_to_latex",
        "full_api_name": "_elements_to_latex",
        "api_description": "",
        "api_signature": "_elements_to_latex(elements)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/array.py"
    },
    {
        "api_name": "_rows_to_latex",
        "full_api_name": "_rows_to_latex",
        "api_description": "",
        "api_signature": "_rows_to_latex(rows, max_width)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/array.py"
    },
    {
        "api_name": "array_to_latex",
        "full_api_name": "array_to_latex",
        "api_description": "Latex representation of a complex numpy array (with dimension 1 or 2)\n\nArgs:\n    array (ndarray): The array to be converted to latex, must have dimension 1 or 2 and\n                     contain only numerical data.\n    precision (int): For numbers not close to integers or common terms, the number of\n                     decimal places to round to.\n    prefix (str): Latex string to be prepended to the latex, intended for labels.\n    source (bool): If ``False``, will return IPython.display.Latex object. If display is\n                   ``True``, will instead return the LaTeX source string.\n    max_size (list(int) or int): The maximum size of the output Latex array.\n\n        * If list(``int``), then the 0th element of the list specifies the maximum\n          width (including dots characters) and the 1st specifies the maximum height\n          (also inc. dots characters).\n        * If a single ``int`` then this value sets the maximum width _and_ maximum\n          height.\n\nReturns:\n    str or IPython.display.Latex: If ``source`` is ``True``, a ``str`` of the LaTeX\n        representation of the array, else an ``IPython.display.Latex`` representation of\n        the array.\n\nRaises:\n    TypeError: If array can not be interpreted as a numerical numpy array.\n    ValueError: If the dimension of array is not 1 or 2.\n    MissingOptionalLibraryError: If ``source`` is ``False`` and ``IPython.display.Latex`` cannot be\n                 imported.",
        "api_signature": "array_to_latex(array, precision, prefix, source, max_size)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/array.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Arrow3D.__init__",
        "api_description": "",
        "api_signature": "__init__(self, xs, ys, zs, zdir)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/bloch.py"
    },
    {
        "api_name": "draw",
        "full_api_name": "Arrow3D.draw",
        "api_description": "",
        "api_signature": "draw(self, renderer)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/bloch.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Bloch.__init__",
        "api_description": "",
        "api_signature": "__init__(self, fig, axes, view, figsize, background, font_size)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/bloch.py"
    },
    {
        "api_name": "set_label_convention",
        "full_api_name": "Bloch.set_label_convention",
        "api_description": "Set x, y and z labels according to one of conventions.\n\nArgs:\n    convention (str):\n        One of the following:\n            - \"original\"\n            - \"xyz\"\n            - \"sx sy sz\"\n            - \"01\"\n            - \"polarization jones\"\n            - \"polarization jones letters\"\n            see also: http://en.wikipedia.org/wiki/Jones_calculus\n            - \"polarization stokes\"\n            see also: http://en.wikipedia.org/wiki/Stokes_parameters\nRaises:\n    Exception: If convention is not valid.",
        "api_signature": "set_label_convention(self, convention)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/bloch.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "Bloch.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/bloch.py"
    },
    {
        "api_name": "clear",
        "full_api_name": "Bloch.clear",
        "api_description": "Resets Bloch sphere data sets to empty.",
        "api_signature": "clear(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/bloch.py"
    },
    {
        "api_name": "add_points",
        "full_api_name": "Bloch.add_points",
        "api_description": "Add a list of data points to Bloch sphere.\n\nArgs:\n    points (array_like):\n        Collection of data points.\n    meth (str):\n        Type of points to plot, use 'm' for multicolored, 'l' for points\n        connected with a line.",
        "api_signature": "add_points(self, points, meth)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/bloch.py"
    },
    {
        "api_name": "add_vectors",
        "full_api_name": "Bloch.add_vectors",
        "api_description": "Add a list of vectors to Bloch sphere.\n\nArgs:\n    vectors (array_like):\n        Array with vectors of unit length or smaller.",
        "api_signature": "add_vectors(self, vectors)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/bloch.py"
    },
    {
        "api_name": "add_annotation",
        "full_api_name": "Bloch.add_annotation",
        "api_description": "Add a text or LaTeX annotation to Bloch sphere,\nparameterized by a qubit state or a vector.\n\nArgs:\n    state_or_vector (array_like):\n        Position for the annotation.\n        Qobj of a qubit or a vector of 3 elements.\n    text (str):\n        Annotation text.\n        You can use LaTeX, but remember to use raw string\n        e.g. r\"$\\langle x \\rangle$\"\n        or escape backslashes\n        e.g. \"$\\\\langle x \\\\rangle$\".\n    **kwargs:\n        Options as for mplot3d.axes3d.text, including:\n        fontsize, color, horizontalalignment, verticalalignment.\nRaises:\n    Exception: If input not array_like or tuple.",
        "api_signature": "add_annotation(self, state_or_vector, text)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/bloch.py"
    },
    {
        "api_name": "make_sphere",
        "full_api_name": "Bloch.make_sphere",
        "api_description": "Plots Bloch sphere and data sets.",
        "api_signature": "make_sphere(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/bloch.py"
    },
    {
        "api_name": "render",
        "full_api_name": "Bloch.render",
        "api_description": "Render the Bloch sphere and its data sets in on given figure and axes.",
        "api_signature": "render(self, title)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/bloch.py"
    },
    {
        "api_name": "plot_back",
        "full_api_name": "Bloch.plot_back",
        "api_description": "back half of sphere",
        "api_signature": "plot_back(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/bloch.py"
    },
    {
        "api_name": "plot_front",
        "full_api_name": "Bloch.plot_front",
        "api_description": "front half of sphere",
        "api_signature": "plot_front(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/bloch.py"
    },
    {
        "api_name": "plot_axes",
        "full_api_name": "Bloch.plot_axes",
        "api_description": "axes",
        "api_signature": "plot_axes(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/bloch.py"
    },
    {
        "api_name": "plot_axes_labels",
        "full_api_name": "Bloch.plot_axes_labels",
        "api_description": "axes labels",
        "api_signature": "plot_axes_labels(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/bloch.py"
    },
    {
        "api_name": "plot_vectors",
        "full_api_name": "Bloch.plot_vectors",
        "api_description": "Plot vector",
        "api_signature": "plot_vectors(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/bloch.py"
    },
    {
        "api_name": "plot_points",
        "full_api_name": "Bloch.plot_points",
        "api_description": "Plot points",
        "api_signature": "plot_points(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/bloch.py"
    },
    {
        "api_name": "plot_annotations",
        "full_api_name": "Bloch.plot_annotations",
        "api_description": "Plot annotations",
        "api_signature": "plot_annotations(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/bloch.py"
    },
    {
        "api_name": "show",
        "full_api_name": "Bloch.show",
        "api_description": "Display Bloch sphere and corresponding data sets.",
        "api_signature": "show(self, title)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/bloch.py"
    },
    {
        "api_name": "save",
        "full_api_name": "Bloch.save",
        "api_description": "Saves Bloch sphere to file of type ``format`` in directory ``dirc``.\n\nArgs:\n    name (str):\n        Name of saved image. Must include path and format as well.\n        i.e. '/Users/Paul/Desktop/bloch.png'\n        This overrides the 'format' and 'dirc' arguments.\n    output (str):\n        Format of output image.\n    dirc (str):\n        Directory for output images. Defaults to current working directory.",
        "api_signature": "save(self, name, output, dirc)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/bloch.py"
    },
    {
        "api_name": "_hide_tick_lines_and_labels",
        "full_api_name": "_hide_tick_lines_and_labels",
        "api_description": "Set visible property of ticklines and ticklabels of an axis to False",
        "api_signature": "_hide_tick_lines_and_labels(axis)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/bloch.py"
    },
    {
        "api_name": "pass_manager_drawer",
        "full_api_name": "pass_manager_drawer",
        "api_description": "Draws the pass manager.\n\nThis function needs `pydot <https://github.com/pydot/pydot>`__, which in turn needs\n`Graphviz <https://www.graphviz.org/>`__ to be installed.\n\nArgs:\n    pass_manager (PassManager): the pass manager to be drawn\n    filename (str): file path to save image to\n    style (dict or OrderedDict): keys are the pass classes and the values are\n        the colors to make them. An example can be seen in the DEFAULT_STYLE. An ordered\n        dict can be used to ensure a priority coloring when pass falls into multiple\n        categories. Any values not included in the provided dict will be filled in from\n        the default dict\n    raw (Bool) : True if you want to save the raw Dot output not an image. The\n        default is False.\nReturns:\n    PIL.Image or None: an in-memory representation of the pass manager. Or None if\n    no image was generated or PIL is not installed.\nRaises:\n    MissingOptionalLibraryError: when nxpd or pydot not installed.\n    VisualizationError: If raw=True and filename=None.\n\nExample:\n    .. code-block::\n\n         %matplotlib inline\n        from qiskit import QuantumCircuit\n        from qiskit.compiler import transpile\n        from qiskit.transpiler import PassManager\n        from qiskit.visualization import pass_manager_drawer\n        from qiskit.transpiler.passes import Unroller\n\n        circ = QuantumCircuit(3)\n        circ.ccx(0, 1, 2)\n        circ.draw()\n\n        pass_ = Unroller(['u1', 'u2', 'u3', 'cx'])\n        pm = PassManager(pass_)\n        new_circ = pm.run(circ)\n        new_circ.draw(output='mpl')\n\n        pass_manager_drawer(pm, \"passmanager.jpg\")",
        "api_signature": "pass_manager_drawer(pass_manager, filename, style, raw)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pass_manager_visualization.py"
    },
    {
        "api_name": "_get_node_color",
        "full_api_name": "_get_node_color",
        "api_description": "",
        "api_signature": "_get_node_color(pss, style)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pass_manager_visualization.py"
    },
    {
        "api_name": "staged_pass_manager_drawer",
        "full_api_name": "staged_pass_manager_drawer",
        "api_description": "Draws the staged pass manager.\n\n    This function needs `pydot <https://github.com/erocarrera/pydot>`__, which in turn needs\n`Graphviz <https://www.graphviz.org/>`__ to be installed.\n\nArgs:\n    pass_manager (StagedPassManager): the staged pass manager to be drawn\n    filename (str): file path to save image to\n    style (dict or OrderedDict): keys are the pass classes and the values are\n        the colors to make them. An example can be seen in the DEFAULT_STYLE. An ordered\n        dict can be used to ensure a priority coloring when pass falls into multiple\n        categories. Any values not included in the provided dict will be filled in from\n        the default dict\n    raw (Bool) : True if you want to save the raw Dot output not an image. The\n        default is False.\nReturns:\n    PIL.Image or None: an in-memory representation of the pass manager. Or None if\n    no image was generated or PIL is not installed.\nRaises:\n    MissingOptionalLibraryError: when nxpd or pydot not installed.\n    VisualizationError: If raw=True and filename=None.\n\nExample:\n    .. code-block::\n\n        %matplotlib inline\n        from qiskit.providers.fake_provider import GenericBackendV2\n        from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager\n\n        pass_manager = generate_preset_pass_manager(3, GenericBackendV2(num_qubits=5))\n        pass_manager.draw()",
        "api_signature": "staged_pass_manager_drawer(pass_manager, filename, style, raw)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pass_manager_visualization.py"
    },
    {
        "api_name": "draw_subgraph",
        "full_api_name": "draw_subgraph",
        "api_description": "Draw subgraph.",
        "api_signature": "draw_subgraph(controller_group, component_id, style, prev_node, idx)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pass_manager_visualization.py"
    },
    {
        "api_name": "make_output",
        "full_api_name": "make_output",
        "api_description": "Produce output for pass_manager.",
        "api_signature": "make_output(graph, raw, filename)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pass_manager_visualization.py"
    },
    {
        "api_name": "_get_backend_interface_version",
        "full_api_name": "_get_backend_interface_version",
        "api_description": "",
        "api_signature": "_get_backend_interface_version(backend)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/gate_map.py"
    },
    {
        "api_name": "plot_gate_map",
        "full_api_name": "plot_gate_map",
        "api_description": "Plots the gate map of a device.\n\nArgs:\n    backend (Backend): The backend instance that will be used to plot the device\n        gate map.\n    figsize (tuple): Output figure size (wxh) in inches.\n    plot_directed (bool): Plot directed coupling map.\n    label_qubits (bool): Label the qubits.\n    qubit_size (float): Size of qubit marker.\n    line_width (float): Width of lines.\n    font_size (int): Font size of qubit labels.\n    qubit_color (list): A list of colors for the qubits\n    qubit_labels (list): A list of qubit labels\n    line_color (list): A list of colors for each line from coupling_map.\n    font_color (str): The font color for the qubit labels.\n    ax (Axes): A Matplotlib axes instance.\n    filename (str): file path to save image to.\n    qubit_coordinates (Sequence): An optional sequence input (list or array being the\n        most common) of 2d coordinates for each qubit. The length of the\n        sequence much match the number of qubits on the backend. The sequence\n        should be the planar coordinates in a 0-based square grid where each\n        qubit is located.\n\nReturns:\n    Figure: A Matplotlib figure instance.\n\nRaises:\n    QiskitError: if tried to pass a simulator, or if the backend is None,\n        but one of num_qubits, mpl_data, or cmap is None.\n    MissingOptionalLibraryError: if matplotlib not installed.\n\nExample:\n\n    .. plot::\n       :include-source:\n\n       from qiskit.providers.fake_provider import GenericBackendV2\n       from qiskit.visualization import plot_gate_map\n\n       backend = GenericBackendV2(num_qubits=5)\n\n       plot_gate_map(backend)",
        "api_signature": "plot_gate_map(backend, figsize, plot_directed, label_qubits, qubit_size, line_width, font_size, qubit_color, qubit_labels, line_color, font_color, ax, filename, qubit_coordinates)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/gate_map.py"
    },
    {
        "api_name": "plot_coupling_map",
        "full_api_name": "plot_coupling_map",
        "api_description": "Plots an arbitrary coupling map of qubits (embedded in a plane).\n\nArgs:\n    num_qubits (int): The number of qubits defined and plotted.\n    qubit_coordinates (List[List[int]]): A list of two-element lists, with entries of each nested\n        list being the planar coordinates in a 0-based square grid where each qubit is located.\n    coupling_map (List[List[int]]): A list of two-element lists, with entries of each nested\n        list being the qubit numbers of the bonds to be plotted.\n    figsize (tuple): Output figure size (wxh) in inches.\n    plot_directed (bool): Plot directed coupling map.\n    label_qubits (bool): Label the qubits.\n    qubit_size (float): Size of qubit marker.\n    line_width (float): Width of lines.\n    font_size (int): Font size of qubit labels.\n    qubit_color (list): A list of colors for the qubits\n    qubit_labels (list): A list of qubit labels\n    line_color (list): A list of colors for each line from coupling_map.\n    font_color (str): The font color for the qubit labels.\n    ax (Axes): A Matplotlib axes instance.\n    filename (str): file path to save image to.\n\nReturns:\n    Figure: A Matplotlib figure instance.\n\nRaises:\n    MissingOptionalLibraryError: If matplotlib or graphviz is not installed.\n    QiskitError: If length of qubit labels does not match number of qubits.\n\nExample:\n\n    .. plot::\n       :include-source:\n\n        from qiskit.visualization import plot_coupling_map\n\n        num_qubits = 8\n        qubit_coordinates = [[0, 1], [1, 1], [1, 0], [1, 2], [2, 0], [2, 2], [2, 1], [3, 1]]\n        coupling_map = [[0, 1], [1, 2], [2, 3], [3, 5], [4, 5], [5, 6], [2, 4], [6, 7]]\n        plot_coupling_map(num_qubits, qubit_coordinates, coupling_map)",
        "api_signature": "plot_coupling_map(num_qubits, qubit_coordinates, coupling_map, figsize, plot_directed, label_qubits, qubit_size, line_width, font_size, qubit_color, qubit_labels, line_color, font_color, ax, filename)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/gate_map.py"
    },
    {
        "api_name": "color_node",
        "full_api_name": "color_node",
        "api_description": "",
        "api_signature": "color_node(node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/gate_map.py"
    },
    {
        "api_name": "color_edge",
        "full_api_name": "color_edge",
        "api_description": "",
        "api_signature": "color_edge(edge)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/gate_map.py"
    },
    {
        "api_name": "plot_circuit_layout",
        "full_api_name": "plot_circuit_layout",
        "api_description": "Plot the layout of a circuit transpiled for a given\ntarget backend.\n\nArgs:\n    circuit (QuantumCircuit): Input quantum circuit.\n    backend (Backend): Target backend.\n    view (str): How to label qubits in the layout. Options:\n\n      - ``\"virtual\"``: Label each qubit with the index of the virtual qubit that\n        mapped to it.\n      - ``\"physical\"``: Label each qubit with the index of the physical qubit that it\n        corresponds to on the device.\n\n    qubit_coordinates (Sequence): An optional sequence input (list or array being the\n        most common) of 2d coordinates for each qubit. The length of the\n        sequence must match the number of qubits on the backend. The sequence\n        should be the planar coordinates in a 0-based square grid where each\n        qubit is located.\n\nReturns:\n    Figure: A matplotlib figure showing layout.\n\nRaises:\n    QiskitError: Invalid view type given.\n    VisualizationError: Circuit has no layout attribute.\n\nExample:\n    .. plot::\n       :include-source:\n\n        from qiskit import QuantumCircuit, transpile\n        from qiskit.providers.fake_provider import GenericBackendV2\n        from qiskit.visualization import plot_circuit_layout\n\n        ghz = QuantumCircuit(3, 3)\n        ghz.h(0)\n        for idx in range(1,3):\n            ghz.cx(0,idx)\n        ghz.measure(range(3), range(3))\n\n        backend = GenericBackendV2(num_qubits=5)\n        new_circ_lv3 = transpile(ghz, backend=backend, optimization_level=3)\n        plot_circuit_layout(new_circ_lv3, backend)",
        "api_signature": "plot_circuit_layout(circuit, backend, view, qubit_coordinates)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/gate_map.py"
    },
    {
        "api_name": "plot_error_map",
        "full_api_name": "plot_error_map",
        "api_description": "Plots the error map of a given backend.\n\nArgs:\n    backend (Backend): Given backend.\n    figsize (tuple): Figure size in inches.\n    show_title (bool): Show the title or not.\n    qubit_coordinates (Sequence): An optional sequence input (list or array being the\n        most common) of 2d coordinates for each qubit. The length of the\n        sequence much mast the number of qubits on the backend. The sequence\n        should be the planar coordinates in a 0-based square grid where each\n        qubit is located.\n\nReturns:\n    Figure: A matplotlib figure showing error map.\n\nRaises:\n    VisualizationError: The backend does not provide gate errors for the 'sx' gate.\n    MissingOptionalLibraryError: If matplotlib or seaborn is not installed.\n\nExample:\n    .. plot::\n       :include-source:\n\n        from qiskit.visualization import plot_error_map\n        from qiskit.providers.fake_provider import GenericBackendV2\n\n        backend = GenericBackendV2(num_qubits=5)\n        plot_error_map(backend)",
        "api_signature": "plot_error_map(backend, figsize, show_title, qubit_coordinates)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/gate_map.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "WaveformChannel.__init__",
        "api_description": "Create new waveform channel.",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/types.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ChannelEvents.__init__",
        "api_description": "Create new event manager.\n\nArgs:\n    waveforms: List of waveforms shown in this channel.\n    frames: List of frame change type instructions shown in this channel.\n    channel: Channel object associated with this manager.",
        "api_signature": "__init__(self, waveforms, frames, channel)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/events.py"
    },
    {
        "api_name": "load_program",
        "full_api_name": "ChannelEvents.load_program",
        "api_description": "Load a pulse program represented by ``Schedule``.\n\nArgs:\n    program: Target ``Schedule`` to visualize.\n    channel: The channel managed by this instance.\n\nReturns:\n    ChannelEvents: The channel event manager for the specified channel.",
        "api_signature": "load_program(cls, program, channel)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/events.py"
    },
    {
        "api_name": "set_config",
        "full_api_name": "ChannelEvents.set_config",
        "api_description": "Setup system status.\n\nArgs:\n    dt: Time resolution in sec.\n    init_frequency: Modulation frequency in Hz.\n    init_phase: Initial phase in rad.",
        "api_signature": "set_config(self, dt, init_frequency, init_phase)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/events.py"
    },
    {
        "api_name": "get_waveforms",
        "full_api_name": "ChannelEvents.get_waveforms",
        "api_description": "Return waveform type instructions with frame.",
        "api_signature": "get_waveforms(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/events.py"
    },
    {
        "api_name": "get_frame_changes",
        "full_api_name": "ChannelEvents.get_frame_changes",
        "api_description": "Return frame change type instructions with total frame change amount.",
        "api_signature": "get_frame_changes(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/events.py"
    },
    {
        "api_name": "_calculate_current_frame",
        "full_api_name": "ChannelEvents._calculate_current_frame",
        "api_description": "Calculate the current frame from the previous frame.\n\nIf parameter is unbound phase or frequency accumulation with this instruction is skipped.\n\nArgs:\n    frame_changes: List of frame change instructions at a specific time.\n    phase: Phase of previous frame.\n    frequency: Frequency of previous frame.\n\nReturns:\n    Phase and frequency of new frame.",
        "api_signature": "_calculate_current_frame(cls, frame_changes, phase, frequency)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/events.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QiskitPulseStyle.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/stylesheet.py"
    },
    {
        "api_name": "update",
        "full_api_name": "QiskitPulseStyle.update",
        "api_description": "",
        "api_signature": "update(self, __m)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/stylesheet.py"
    },
    {
        "api_name": "formatter",
        "full_api_name": "QiskitPulseStyle.formatter",
        "api_description": "Return formatter field of style dictionary.",
        "api_signature": "formatter(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/stylesheet.py"
    },
    {
        "api_name": "generator",
        "full_api_name": "QiskitPulseStyle.generator",
        "api_description": "Return generator field of style dictionary.",
        "api_signature": "generator(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/stylesheet.py"
    },
    {
        "api_name": "layout",
        "full_api_name": "QiskitPulseStyle.layout",
        "api_description": "Return layout field of style dictionary.",
        "api_signature": "layout(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/stylesheet.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "IQXStandard.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/stylesheet.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "IQXStandard.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/stylesheet.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "IQXSimple.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/stylesheet.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "IQXSimple.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/stylesheet.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "IQXDebugging.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/stylesheet.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "IQXDebugging.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/stylesheet.py"
    },
    {
        "api_name": "default_style",
        "full_api_name": "default_style",
        "api_description": "Define default values of the pulse stylesheet.",
        "api_signature": "default_style()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/stylesheet.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "DrawerBackendInfo.__init__",
        "api_description": "Create new backend information.\n\nArgs:\n    name: Name of the backend.\n    dt: System cycle time.\n    channel_frequency_map: Mapping of channel and associated frequency.\n    qubit_channel_map: Mapping of qubit and associated channels.",
        "api_signature": "__init__(self, name, dt, channel_frequency_map, qubit_channel_map)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/device_info.py"
    },
    {
        "api_name": "create_from_backend",
        "full_api_name": "DrawerBackendInfo.create_from_backend",
        "api_description": "Initialize a class with backend information provided by provider.\n\nArgs:\n    backend: Backend object.",
        "api_signature": "create_from_backend(cls, backend)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/device_info.py"
    },
    {
        "api_name": "dt",
        "full_api_name": "DrawerBackendInfo.dt",
        "api_description": "Return cycle time.",
        "api_signature": "dt(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/device_info.py"
    },
    {
        "api_name": "get_qubit_index",
        "full_api_name": "DrawerBackendInfo.get_qubit_index",
        "api_description": "Get associated qubit index of given channel object.",
        "api_signature": "get_qubit_index(self, chan)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/device_info.py"
    },
    {
        "api_name": "get_channel_frequency",
        "full_api_name": "DrawerBackendInfo.get_channel_frequency",
        "api_description": "Get frequency of given channel object.",
        "api_signature": "get_channel_frequency(self, chan)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/device_info.py"
    },
    {
        "api_name": "create_from_backend",
        "full_api_name": "OpenPulseBackendInfo.create_from_backend",
        "api_description": "Initialize a class with backend information provided by provider.\n\nArgs:\n    backend: Backend object.\n\nReturns:\n    OpenPulseBackendInfo: New configured instance.",
        "api_signature": "create_from_backend(cls, backend)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/device_info.py"
    },
    {
        "api_name": "draw",
        "full_api_name": "draw",
        "api_description": "Generate visualization data for pulse programs.\n\nArgs:\n    program: Program to visualize. This program can be arbitrary Qiskit Pulse program,\n        such as :py:class:`~qiskit.pulse.Waveform`, :py:class:`~qiskit.pulse.SymbolicPulse`,\n        :py:class:`~qiskit.pulse.Schedule` and :py:class:`~qiskit.pulse.ScheduleBlock`.\n    style: Stylesheet options. This can be dictionary or preset stylesheet classes. See\n        :py:class:`~qiskit.visualization.pulse_v2.stylesheets.IQXStandard`,\n        :py:class:`~qiskit.visualization.pulse_v2.stylesheets.IQXSimple`, and\n        :py:class:`~qiskit.visualization.pulse_v2.stylesheets.IQXDebugging` for details of\n        preset stylesheets. See also the stylesheet section for details of configuration keys.\n    backend: Backend object to play the input pulse program. If provided, the plotter\n        may use to make the visualization hardware aware.\n    time_range: Set horizontal axis limit. Tuple ``(tmin, tmax)``.\n    time_unit: The unit of specified time range either ``dt`` or ``ns``.\n        The unit of ``ns`` is available only when ``backend`` object is provided.\n    disable_channels: A control property to show specific pulse channel.\n        Pulse channel instances provided as a list is not shown in the output image.\n    show_snapshot: Show snapshot instructions.\n    show_framechange: Show frame change instructions. The frame change represents\n        instructions that modulate phase or frequency of pulse channels.\n    show_waveform_info: Show waveform annotations, i.e. name, of waveforms.\n        Set ``True`` to show additional information about waveforms.\n    plot_barrier: Show barrier lines.\n    plotter: Name of plotter API to generate an output image.\n        One of following APIs should be specified::\n\n            mpl2d: Matplotlib API for 2D image generation.\n                Matplotlib API to generate 2D image. Charts are placed along y axis with\n                vertical offset. This API takes matplotlib.axes.Axes as `axis` input.\n\n        `axis` and `style` kwargs may depend on the plotter.\n    axis: Arbitrary object passed to the plotter. If this object is provided,\n        the plotters use a given ``axis`` instead of internally initializing\n        a figure object. This object format depends on the plotter.\n        See plotter argument for details.\n    show_barrier: DEPRECATED. Show barrier lines.\n\nReturns:\n    Visualization output data.\n    The returned data type depends on the `plotter`.\n    If matplotlib family is specified, this will be a `matplotlib.pyplot.Figure` data.\n    The returned data is generated by the :meth:`get_image` method of the specified plotter API.\n\n.. _style-dict-doc:\n\n**Style Dict Details**\n\nThe stylesheet kwarg contains numerous options that define the style of the\noutput pulse visualization.\nThe stylesheet options can be classified into `formatter`, `generator` and `layout`.\nThose options available in the stylesheet are defined below:\n\nArgs:\n    formatter.general.fig_width: Width of output image (default `13`).\n    formatter.general.fig_chart_height: Height of output image per chart.\n        The height of each chart is multiplied with this factor and the\n        sum of all chart heights becomes the height of output image (default `1.5`).\n    formatter.general.vertical_resolution: Vertical resolution of the pulse envelope.\n        The change of data points below this limit is ignored (default `1e-6`).\n    formatter.general.max_scale: Maximum scaling factor of each chart. This factor is\n        considered when chart auto-scaling is enabled (default `100`).\n    formatter.color.waveforms: A dictionary of the waveform colors to use for\n        each element type in the output visualization. The default values are::\n\n            {\n                'W': `['#648fff', '#002999']`,\n                'D': `['#648fff', '#002999']`,\n                'U': `['#ffb000', '#994A00']`,\n                'M': `['#dc267f', '#760019']`,\n                'A': `['#dc267f', '#760019']`\n            }\n\n    formatter.color.baseline: Color code of lines of zero line of each chart\n        (default `'#000000'`).\n    formatter.color.barrier: Color code of lines of barrier (default `'#222222'`).\n    formatter.color.background: Color code of the face color of canvas\n        (default `'#f2f3f4'`).\n    formatter.color.fig_title: Color code of the figure title text\n        (default `'#000000'`).\n    formatter.color.annotate: Color code of annotation texts in the canvas\n        (default `'#222222'`).\n    formatter.color.frame_change: Color code of the symbol for frame changes\n        (default `'#000000'`).\n    formatter.color.snapshot: Color code of the symbol for snapshot\n        (default `'#000000'`)\n    formatter.color.opaque_shape: Color code of the face and edge of opaque shape box\n        (default `['#fffacd', '#000000']`)\n    formatter.color.axis_label: Color code of axis labels (default `'#000000'`).\n    formatter.alpha.fill_waveform: Transparency of waveforms. A value in the range from\n        `0` to `1`. The value `0` gives completely transparent waveforms (default `0.3`).\n    formatter.alpha.baseline: Transparency of base lines. A value in the range from\n        `0` to `1`. The value `0` gives completely transparent base lines (default `1.0`).\n    formatter.alpha.barrier: Transparency of barrier lines. A value in the range from\n        `0` to `1`. The value `0` gives completely transparent barrier lines (default `0.7`).\n    formatter.alpha.opaque_shape: Transparency of opaque shape box. A value in the range from\n        `0` to `1`. The value `0` gives completely transparent barrier lines (default `0.7`).\n    formatter.layer.fill_waveform: Layer index of waveforms. Larger number comes\n        in the front of the output image (default `2`).\n    formatter.layer.baseline: Layer index of baselines. Larger number comes\n        in the front of the output image (default `1`).\n    formatter.layer.barrier: Layer index of barrier lines. Larger number comes\n        in the front of the output image (default `1`).\n    formatter.layer.annotate: Layer index of annotations. Larger number comes\n        in the front of the output image (default `5`).\n    formatter.layer.axis_label: Layer index of axis labels. Larger number comes\n        in the front of the output image (default `5`).\n    formatter.layer.frame_change: Layer index of frame change symbols. Larger number comes\n        in the front of the output image (default `4`).\n    formatter.layer.snapshot: Layer index of snapshot symbols. Larger number comes\n        in the front of the output image (default `3`).\n    formatter.layer.fig_title: Layer index of the figure title. Larger number comes\n        in the front of the output image (default `6`).\n    formatter.margin.top: Margin from the top boundary of the figure canvas to\n        the surface of the first chart (default `0.5`).\n    formatter.margin.bottom: Margin from the bottom boundary of the figure canvas to\n        the surface of the last chart (default `0.5`).\n    formatter.margin.left_percent: Margin from the left boundary of the figure canvas to\n        the zero point of the horizontal axis. The value is in units of percentage of\n        the whole program duration. If the duration is 100 and the value of 0.5 is set,\n        this keeps left margin of 5 (default `0.05`).\n    formatter.margin.right_percent: Margin from the right boundary of the figure canvas to\n        the left limit of the horizontal axis. The value is in units of percentage of\n        the whole program duration. If the duration is 100 and the value of 0.5 is set,\n        this keeps right margin of 5 (default `0.05`).\n    formatter.margin.between_channel: Vertical margin between charts (default `0.2`).\n    formatter.label_offset.pulse_name: Offset of pulse name annotations from the\n        chart baseline (default `0.3`).\n    formatter.label_offset.chart_info: Offset of chart info annotations from the\n        chart baseline (default `0.3`).\n    formatter.label_offset.frame_change: Offset of frame change annotations from the\n        chart baseline (default `0.3`).\n    formatter.label_offset.snapshot: Offset of snapshot annotations from the\n        chart baseline (default `0.3`).\n    formatter.text_size.axis_label: Text size of axis labels (default `15`).\n    formatter.text_size.annotate: Text size of annotations (default `12`).\n    formatter.text_size.frame_change: Text size of frame change symbols (default `20`).\n    formatter.text_size.snapshot: Text size of snapshot symbols (default `20`).\n    formatter.text_size.fig_title: Text size of the figure title (default `15`).\n    formatter.text_size.axis_break_symbol: Text size of axis break symbols (default `15`).\n    formatter.line_width.fill_waveform: Line width of the fringe of filled waveforms\n        (default `0`).\n    formatter.line_width.axis_break: Line width of axis breaks.\n        The axis break line paints over other drawings with the background\n        face color (default `6`).\n    formatter.line_width.baseline: Line width of base lines (default `1`)\n    formatter.line_width.barrier: Line width of barrier lines (default `1`).\n    formatter.line_width.opaque_shape: Line width of opaque shape box (default `1`).\n    formatter.line_style.fill_waveform: Line style of the fringe of filled waveforms. This\n        conforms to the line style spec of matplotlib (default `'-'`).\n    formatter.line_style.baseline: Line style of base lines. This\n        conforms to the line style spec of matplotlib (default `'-'`).\n    formatter.line_style.barrier: Line style of barrier lines. This\n        conforms to the line style spec of matplotlib (default `':'`).\n    formatter.line_style.opaque_shape: Line style of opaque shape box. This\n        conforms to the line style spec of matplotlib (default `'--'`).\n    formatter.channel_scaling.drive: Default scaling value of drive channel\n        waveforms (default `1.0`).\n    formatter.channel_scaling.control: Default scaling value of control channel\n        waveforms (default `1.0`).\n    formatter.channel_scaling.measure: Default scaling value of measure channel\n        waveforms (default `1.0`).\n    formatter.channel_scaling.acquire: Default scaling value of acquire channel\n        waveforms (default `1.0`).\n    formatter.channel_scaling.pos_spacing: Minimum height of chart above the baseline.\n        Chart top is determined based on the maximum height of waveforms associated\n        with the chart. If the maximum height is below this value, this value is set\n        as the chart top (default 0.1).\n    formatter.channel_scaling.neg_spacing: Minimum height of chart below the baseline.\n        Chart bottom is determined based on the minimum height of waveforms associated\n        with the chart. If the minimum height is above this value, this value is set\n        as the chart bottom (default -0.1).\n    formatter.box_width.opaque_shape: Default box length of the waveform representation\n        when the instruction is parameterized and duration is not bound or not defined.\n        Value is units in dt (default: 150).\n    formatter.box_height.opaque_shape: Default box height of the waveform representation\n        when the instruction is parameterized (default: 0.4).\n    formatter.axis_break.length: Waveform or idle time duration that axis break is\n        applied. Intervals longer than this value are truncated.\n        The value is in units of data points (default `3000`).\n    formatter.axis_break.max_length: Length of new waveform or idle time duration\n        after axis break is applied. Longer intervals are truncated to this length\n        (default `1000`).\n    formatter.control.fill_waveform: Set `True` to fill waveforms with face color\n        (default `True`). When you disable this option, you should set finite line width\n        to `formatter.line_width.fill_waveform`, otherwise nothing will appear in the graph.\n    formatter.control.apply_phase_modulation: Set `True` to apply phase modulation\n        to the waveforms (default `True`).\n    formatter.control.show_snapshot_channel: Set `True` to show snapshot instructions\n        (default `True`).\n    formatter.control.show_acquire_channel: Set `True` to show acquire channels\n        (default `True`).\n    formatter.control.show_empty_channel: Set `True` to show charts without any waveforms\n        (default `True`).\n    formatter.control.auto_chart_scaling: Set `True` to apply auto-scaling to charts\n        (default `True`).\n    formatter.control.axis_break: Set `True` to apply axis break for long intervals\n        (default `True`).\n    formatter.unicode_symbol.frame_change: Text that represents the symbol of\n        frame change. This text is used when the plotter doesn't support latex\n        (default u'\u21ba').\n    formatter.unicode_symbol.snapshot: Text that represents the symbol of\n        snapshot. This text is used when the plotter doesn't support latex\n        (default u'\u21af').\n    formatter.unicode_symbol.phase_parameter: Text that represents the symbol of\n        parameterized phase value. This text is used when the plotter doesn't support latex\n        (default u'\u03b8').\n    formatter.unicode_symbol.freq_parameter: Text that represents the symbol of\n        parameterized frequency value. This text is used when the plotter doesn't support latex\n        (default 'f').\n    formatter.latex_symbol.frame_change: Latex text that represents the symbol of\n        frame change (default r'\\circlearrowleft').\n    formatter.latex_symbol.snapshot: Latex text that represents the symbol of\n        snapshot (default '').\n    formatter.latex_symbol.phase_parameter: Latex text that represents the symbol of\n        parameterized phase value (default r'       heta').\n    formatter.latex_symbol.freq_parameter: Latex text that represents the symbol of\n        parameterized frequency value (default 'f').\n    generator.waveform: List of callback functions that generates drawing\n        for waveforms. Arbitrary callback functions satisfying the generator format\n        can be set here. There are some default generators in the pulse drawer.\n        See :py:mod:`~qiskit.visualization.pulse_v2.generators.waveform` for more details.\n        No default generator is set.\n    generator.frame: List of callback functions that generates drawing\n        for frame changes. Arbitrary callback functions satisfying the generator format\n        can be set here. There are some default generators in the pulse drawer.\n        See :py:mod:`~qiskit.visualization.pulse_v2.generators.frame` for more details.\n        No default generator is set.\n    generator.chart: List of callback functions that generates drawing\n        for charts. Arbitrary callback functions satisfying the generator format\n        can be set here. There are some default generators in the pulse drawer.\n        See :py:mod:`~qiskit.visualization.pulse_v2.generators.chart` for more details.\n        No default generator is set.\n    generator.snapshot: List of callback functions that generates drawing\n        for snapshots. Arbitrary callback functions satisfying the generator format\n        can be set here. There are some default generators in the pulse drawer.\n        See :py:mod:`~qiskit.visualization.pulse_v2.generators.snapshot` for more details.\n        No default generator is set.\n    generator.barrier: List of callback functions that generates drawing\n        for barriers. Arbitrary callback functions satisfying the generator format\n        can be set here. There are some default generators in the pulse drawer.\n        See :py:mod:`~qiskit.visualization.pulse_v2.generators.barrier` for more details.\n        No default generator is set.\n    layout.chart_channel_map: Callback function that determines the relationship\n        between pulse channels and charts.\n        See :py:mod:`~qiskit.visualization.pulse_v2.layout` for more details.\n        No default layout is set.\n    layout.time_axis_map: Callback function that determines the layout of\n        horizontal axis labels.\n        See :py:mod:`~qiskit.visualization.pulse_v2.layout` for more details.\n        No default layout is set.\n    layout.figure_title: Callback function that generates a string for\n        the figure title.\n        See :py:mod:`~qiskit.visualization.pulse_v2.layout` for more details.\n        No default layout is set.\n\nExamples:\n    To visualize a pulse program, you can call this function with set of\n    control arguments. Most of appearance of the output image can be controlled by the\n    stylesheet.\n\n    Drawing with the default stylesheet.\n\n    .. plot::\n       :include-source:\n\n        from qiskit import QuantumCircuit, transpile, schedule\n        from qiskit.visualization.pulse_v2 import draw\n        from qiskit.providers.fake_provider import GenericBackendV2\n\n        qc = QuantumCircuit(2)\n        qc.h(0)\n        qc.cx(0, 1)\n        qc.measure_all()\n        qc = transpile(qc, GenericBackendV2(5), layout_method='trivial')\n        sched = schedule(qc, GenericBackendV2(5))\n\n        draw(sched, backend=GenericBackendV2(5))\n\n    Drawing with the stylesheet suited for publication.\n\n    .. plot::\n       :include-source:\n\n        from qiskit import QuantumCircuit, transpile, schedule\n        from qiskit.visualization.pulse_v2 import draw, IQXSimple\n        from qiskit.providers.fake_provider import GenericBackendV2\n\n        qc = QuantumCircuit(2)\n        qc.h(0)\n        qc.cx(0, 1)\n        qc.measure_all()\n        qc = transpile(qc, GenericBackendV2(5), layout_method='trivial')\n        sched = schedule(qc, GenericBackendV2(5))\n\n        draw(sched, style=IQXSimple(), backend=GenericBackendV2(5))\n\n    Drawing with the stylesheet suited for program debugging.\n\n    .. plot::\n       :include-source:\n\n        from qiskit import QuantumCircuit, transpile, schedule\n        from qiskit.visualization.pulse_v2 import draw, IQXDebugging\n        from qiskit.providers.fake_provider import GenericBackendV2\n\n        qc = QuantumCircuit(2)\n        qc.h(0)\n        qc.cx(0, 1)\n        qc.measure_all()\n        qc = transpile(qc, GenericBackendV2(5), layout_method='trivial')\n        sched = schedule(qc, GenericBackendV2(5))\n\n        draw(sched, style=IQXDebugging(), backend=GenericBackendV2(5))\n\n    You can partially customize a preset stylesheet when initializing it.\n\n    .. code-block:: python\n\n        my_style = {\n            'formatter.channel_scaling.drive': 5,\n            'formatter.channel_scaling.control': 1,\n            'formatter.channel_scaling.measure': 5\n        }\n        style = IQXStandard(**my_style)\n        # draw\n        draw(sched, style=style, backend=GenericBackendV2(5))\n\n    In the same way as above, you can create custom generator or layout functions\n    and update the existing stylesheet with custom functions.\n    This feature enables you to customize most of the appearance of the output image\n    without modifying the codebase.\n\nRaises:\n    MissingOptionalLibraryError: When required visualization package is not installed.\n    VisualizationError: When invalid plotter API or invalid time range is specified.",
        "api_signature": "draw(program, style, backend, time_range, time_unit, disable_channels, show_snapshot, show_framechange, show_waveform_info, plot_barrier, plotter, axis, show_barrier)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/interface.py"
    },
    {
        "api_name": "channel_type_grouped_sort",
        "full_api_name": "channel_type_grouped_sort",
        "api_description": "Layout function for the channel assignment to the chart instance.\n\nAssign single channel per chart. Channels are grouped by type and\nsorted by index in ascending order.\n\nStylesheet key:\n    `chart_channel_map`\n\nFor example:\n    [D0, D2, C0, C2, M0, M2, A0, A2] -> [D0, D2, C0, C2, M0, M2, A0, A2]\n\nArgs:\n    channels: Channels to show.\n    formatter: Dictionary of stylesheet settings.\n    device: Backend configuration.\n\nYields:\n    Tuple of chart name and associated channels.",
        "api_signature": "channel_type_grouped_sort(channels, formatter, device)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/layouts.py"
    },
    {
        "api_name": "channel_index_grouped_sort",
        "full_api_name": "channel_index_grouped_sort",
        "api_description": "Layout function for the channel assignment to the chart instance.\n\nAssign single channel per chart. Channels are grouped by the same index and\nsorted by type.\n\nStylesheet key:\n    `chart_channel_map`\n\nFor example:\n    [D0, D2, C0, C2, M0, M2, A0, A2] -> [D0, D2, C0, C2, M0, M2, A0, A2]\n\nArgs:\n    channels: Channels to show.\n    formatter: Dictionary of stylesheet settings.\n    device: Backend configuration.\n\nYields:\n    Tuple of chart name and associated channels.",
        "api_signature": "channel_index_grouped_sort(channels, formatter, device)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/layouts.py"
    },
    {
        "api_name": "channel_index_grouped_sort_u",
        "full_api_name": "channel_index_grouped_sort_u",
        "api_description": "Layout function for the channel assignment to the chart instance.\n\nAssign single channel per chart. Channels are grouped by the same index and\nsorted by type except for control channels. Control channels are added to the\nend of other channels.\n\nStylesheet key:\n    `chart_channel_map`\n\nFor example:\n    [D0, D2, C0, C2, M0, M2, A0, A2] -> [D0, D2, C0, C2, M0, M2, A0, A2]\n\nArgs:\n    channels: Channels to show.\n    formatter: Dictionary of stylesheet settings.\n    device: Backend configuration.\n\nYields:\n    Tuple of chart name and associated channels.",
        "api_signature": "channel_index_grouped_sort_u(channels, formatter, device)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/layouts.py"
    },
    {
        "api_name": "qubit_index_sort",
        "full_api_name": "qubit_index_sort",
        "api_description": "Layout function for the channel assignment to the chart instance.\n\nAssign multiple channels per chart. Channels associated with the same qubit\nare grouped in the same chart and sorted by qubit index in ascending order.\n\nAcquire channels are not shown.\n\nStylesheet key:\n    `chart_channel_map`\n\nFor example:\n    [D0, D2, C0, C2, M0, M2, A0, A2] -> [Q0, Q1, Q2]\n\nArgs:\n    channels: Channels to show.\n    formatter: Dictionary of stylesheet settings.\n    device: Backend configuration.\n\nYields:\n    Tuple of chart name and associated channels.",
        "api_signature": "qubit_index_sort(channels, formatter, device)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/layouts.py"
    },
    {
        "api_name": "time_map_in_ns",
        "full_api_name": "time_map_in_ns",
        "api_description": "Layout function for the horizontal axis formatting.\n\nCalculate axis break and map true time to axis labels. Generate equispaced\n6 horizontal axis ticks. Convert into seconds if ``dt`` is provided.\n\nArgs:\n    time_window: Left and right edge of this graph.\n    axis_breaks: List of axis break period.\n    dt: Time resolution of system.\n\nReturns:\n    Axis formatter object.",
        "api_signature": "time_map_in_ns(time_window, axis_breaks, dt)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/layouts.py"
    },
    {
        "api_name": "detail_title",
        "full_api_name": "detail_title",
        "api_description": "Layout function for generating figure title.\n\nThis layout writes program name, program duration, and backend name in the title.",
        "api_signature": "detail_title(program, device)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/layouts.py"
    },
    {
        "api_name": "empty_title",
        "full_api_name": "empty_title",
        "api_description": "Layout function for generating an empty figure title.",
        "api_signature": "empty_title(program, device)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/layouts.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "DrawerCanvas.__init__",
        "api_description": "Create new data container with backend system information.\n\nArgs:\n    stylesheet: Stylesheet to decide appearance of output image.\n    device: Backend information to run the program.",
        "api_signature": "__init__(self, stylesheet, device)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/core.py"
    },
    {
        "api_name": "time_range",
        "full_api_name": "DrawerCanvas.time_range",
        "api_description": "Return current time range to draw.\n\nCalculate net duration and add side margin to edge location.\n\nReturns:\n    Time window considering side margin.",
        "api_signature": "time_range(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/core.py"
    },
    {
        "api_name": "time_range",
        "full_api_name": "DrawerCanvas.time_range",
        "api_description": "Update time range to draw.",
        "api_signature": "time_range(self, new_range)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/core.py"
    },
    {
        "api_name": "time_breaks",
        "full_api_name": "DrawerCanvas.time_breaks",
        "api_description": "Return time breaks with time range.\n\nIf an edge of time range is in the axis break period,\nthe axis break period is recalculated.\n\nRaises:\n    VisualizationError: When axis break is greater than time window.\n\nReturns:\n    List of axis break periods considering the time window edges.",
        "api_signature": "time_breaks(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/core.py"
    },
    {
        "api_name": "time_breaks",
        "full_api_name": "DrawerCanvas.time_breaks",
        "api_description": "Set new time breaks.",
        "api_signature": "time_breaks(self, new_breaks)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/core.py"
    },
    {
        "api_name": "load_program",
        "full_api_name": "DrawerCanvas.load_program",
        "api_description": "Load a program to draw.\n\nArgs:\n    program: Pulse program or waveform to draw.\n\nRaises:\n    VisualizationError: When input program is invalid data format.",
        "api_signature": "load_program(self, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/core.py"
    },
    {
        "api_name": "_waveform_loader",
        "full_api_name": "DrawerCanvas._waveform_loader",
        "api_description": "Load Waveform instance.\n\nThis function is sub-routine of py:method:`load_program`.\n\nArgs:\n    program: `Waveform` to draw.",
        "api_signature": "_waveform_loader(self, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/core.py"
    },
    {
        "api_name": "_schedule_loader",
        "full_api_name": "DrawerCanvas._schedule_loader",
        "api_description": "Load Schedule instance.\n\nThis function is sub-routine of py:method:`load_program`.\n\nArgs:\n    program: `Schedule` to draw.",
        "api_signature": "_schedule_loader(self, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/core.py"
    },
    {
        "api_name": "_calculate_axis_break",
        "full_api_name": "DrawerCanvas._calculate_axis_break",
        "api_description": "A helper function to calculate axis break of long pulse sequence.\n\nArgs:\n    program: A schedule to calculate axis break.\n\nReturns:\n    List of axis break periods.",
        "api_signature": "_calculate_axis_break(self, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/core.py"
    },
    {
        "api_name": "set_time_range",
        "full_api_name": "DrawerCanvas.set_time_range",
        "api_description": "Set time range to draw.\n\nAll child chart instances are updated when time range is updated.\n\nArgs:\n    t_start: Left boundary of drawing in units of cycle time or real time.\n    t_end: Right boundary of drawing in units of cycle time or real time.\n    seconds: Set `True` if times are given in SI unit rather than dt.\n\nRaises:\n    VisualizationError: When times are given in float without specifying dt.",
        "api_signature": "set_time_range(self, t_start, t_end, seconds)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/core.py"
    },
    {
        "api_name": "set_disable_channel",
        "full_api_name": "DrawerCanvas.set_disable_channel",
        "api_description": "Interface method to control visibility of pulse channels.\n\nSpecified object in the blocked list will not be shown.\n\nArgs:\n    channel: A pulse channel object to disable.\n    remove: Set `True` to disable, set `False` to enable.",
        "api_signature": "set_disable_channel(self, channel, remove)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/core.py"
    },
    {
        "api_name": "set_disable_type",
        "full_api_name": "DrawerCanvas.set_disable_type",
        "api_description": "Interface method to control visibility of data types.\n\nSpecified object in the blocked list will not be shown.\n\nArgs:\n    data_type: A drawing data type to disable.\n    remove: Set `True` to disable, set `False` to enable.",
        "api_signature": "set_disable_type(self, data_type, remove)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/core.py"
    },
    {
        "api_name": "update",
        "full_api_name": "DrawerCanvas.update",
        "api_description": "Update all associated charts and generate actual drawing data from template object.\n\nThis method should be called before the canvas is passed to the plotter.",
        "api_signature": "update(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/core.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Chart.__init__",
        "api_description": "Create new chart.\n\nArgs:\n    parent: `DrawerCanvas` that this `Chart` instance belongs to.\n    name: Name of this `Chart` instance.",
        "api_signature": "__init__(self, parent, name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/core.py"
    },
    {
        "api_name": "add_data",
        "full_api_name": "Chart.add_data",
        "api_description": "Add drawing to collections.\n\nIf the given object already exists in the collections,\nthis interface replaces the old object instead of adding new entry.\n\nArgs:\n    data: New drawing to add.",
        "api_signature": "add_data(self, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/core.py"
    },
    {
        "api_name": "load_program",
        "full_api_name": "Chart.load_program",
        "api_description": "Load pulse schedule.\n\nThis method internally generates `ChannelEvents` to parse the program\nfor the specified pulse channel. This method is called once\n\nArgs:\n    program: Pulse schedule to load.\n    chan: A pulse channels associated with this instance.",
        "api_signature": "load_program(self, program, chan)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/core.py"
    },
    {
        "api_name": "update",
        "full_api_name": "Chart.update",
        "api_description": "Update vertical data range and scaling factor of this chart.\n\nThose parameters are updated based on current time range in the parent canvas.",
        "api_signature": "update(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/core.py"
    },
    {
        "api_name": "is_active",
        "full_api_name": "Chart.is_active",
        "api_description": "Check if there is any active waveform data in this entry.\n\nReturns:\n    Return `True` if there is any visible waveform in this chart.",
        "api_signature": "is_active(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/core.py"
    },
    {
        "api_name": "collections",
        "full_api_name": "Chart.collections",
        "api_description": "Return currently active entries from drawing data collection.\n\nThe object is returned with unique name as a key of an object handler.\nWhen the horizontal coordinate contains `AbstractCoordinate`,\nthe value is substituted by current time range preference.",
        "api_signature": "collections(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/core.py"
    },
    {
        "api_name": "channels",
        "full_api_name": "Chart.channels",
        "api_description": "Return a list of channels associated with this chart.\n\nReturns:\n    List of channels associated with this chart.",
        "api_signature": "channels(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/core.py"
    },
    {
        "api_name": "_truncate_data",
        "full_api_name": "Chart._truncate_data",
        "api_description": "A helper function to truncate drawings according to time breaks.\n\n# TODO: move this function to common module to support axis break for timeline.\n\nArgs:\n    data: Drawing object to truncate.\n\nReturns:\n    Set of truncated numpy arrays for x and y coordinate.",
        "api_signature": "_truncate_data(self, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/core.py"
    },
    {
        "api_name": "_truncate_pulse_labels",
        "full_api_name": "Chart._truncate_pulse_labels",
        "api_description": "A helper function to remove text according to time breaks.\n\nArgs:\n    xvals: Time points.\n    yvals: Data points.\n\nReturns:\n    Set of truncated numpy arrays for x and y coordinate.",
        "api_signature": "_truncate_pulse_labels(self, xvals, yvals)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/core.py"
    },
    {
        "api_name": "_truncate_boxes",
        "full_api_name": "Chart._truncate_boxes",
        "api_description": "A helper function to clip box object according to time breaks.\n\nArgs:\n    xvals: Time points.\n    yvals: Data points.\n\nReturns:\n    Set of truncated numpy arrays for x and y coordinate.",
        "api_signature": "_truncate_boxes(self, xvals, yvals)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/core.py"
    },
    {
        "api_name": "_truncate_vectors",
        "full_api_name": "Chart._truncate_vectors",
        "api_description": "A helper function to remove sequential data points according to time breaks.\n\nArgs:\n    xvals: Time points.\n    yvals: Data points.\n\nReturns:\n    Set of truncated numpy arrays for x and y coordinate.",
        "api_signature": "_truncate_vectors(self, xvals, yvals)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/core.py"
    },
    {
        "api_name": "_bind_coordinate",
        "full_api_name": "Chart._bind_coordinate",
        "api_description": "A helper function to bind actual coordinates to an `AbstractCoordinate`.\n\nArgs:\n    vals: Sequence of coordinate objects associated with a drawing.\n\nReturns:\n    Numpy data array with substituted values.",
        "api_signature": "_bind_coordinate(self, vals)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/core.py"
    },
    {
        "api_name": "substitute",
        "full_api_name": "Chart.substitute",
        "api_description": "",
        "api_signature": "substitute(val)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/core.py"
    },
    {
        "api_name": "_check_visible",
        "full_api_name": "Chart._check_visible",
        "api_description": "A helper function to check if the data is visible.\n\nArgs:\n    data: Drawing object to test.\n\nReturns:\n    Return `True` if the data is visible.",
        "api_signature": "_check_visible(self, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/core.py"
    },
    {
        "api_name": "_increment_cls_index",
        "full_api_name": "Chart._increment_cls_index",
        "api_description": "Increment counter of the chart.",
        "api_signature": "_increment_cls_index(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/core.py"
    },
    {
        "api_name": "_cls_index",
        "full_api_name": "Chart._cls_index",
        "api_description": "Return counter index of the chart.",
        "api_signature": "_cls_index(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/core.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ElementaryData.__init__",
        "api_description": "Create new drawing.\n\nArgs:\n    data_type: String representation of this drawing.\n    xvals: Series of horizontal coordinate that the object is drawn.\n    yvals: Series of vertical coordinate that the object is drawn.\n    channels: Pulse channel object bound to this drawing.\n    meta: Meta data dictionary of the object.\n    ignore_scaling: Set ``True`` to disable scaling.\n    styles: Style keyword args of the object. This conforms to `matplotlib`.",
        "api_signature": "__init__(self, data_type, xvals, yvals, channels, meta, ignore_scaling, styles)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/drawings.py"
    },
    {
        "api_name": "data_key",
        "full_api_name": "ElementaryData.data_key",
        "api_description": "Return unique hash of this object.",
        "api_signature": "data_key(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/drawings.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "ElementaryData.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/drawings.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "ElementaryData.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/drawings.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "LineData.__init__",
        "api_description": "Create new drawing.\n\nArgs:\n    data_type: String representation of this drawing.\n    channels: Pulse channel object bound to this drawing.\n    xvals: Series of horizontal coordinate that the object is drawn.\n    yvals: Series of vertical coordinate that the object is drawn.\n    fill: Set ``True`` to fill the area under curve.\n    meta: Meta data dictionary of the object.\n    ignore_scaling: Set ``True`` to disable scaling.\n    styles: Style keyword args of the object. This conforms to `matplotlib`.",
        "api_signature": "__init__(self, data_type, xvals, yvals, fill, channels, meta, ignore_scaling, styles)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/drawings.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "TextData.__init__",
        "api_description": "Create new drawing.\n\nArgs:\n    data_type: String representation of this drawing.\n    channels: Pulse channel object bound to this drawing.\n    xvals: Series of horizontal coordinate that the object is drawn.\n    yvals: Series of vertical coordinate that the object is drawn.\n    text: String to show in the canvas.\n    latex: Latex representation of the text (if backend supports latex drawing).\n    meta: Meta data dictionary of the object.\n    ignore_scaling: Set ``True`` to disable scaling.\n    styles: Style keyword args of the object. This conforms to `matplotlib`.",
        "api_signature": "__init__(self, data_type, xvals, yvals, text, latex, channels, meta, ignore_scaling, styles)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/drawings.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BoxData.__init__",
        "api_description": "Create new box.\n\nArgs:\n    data_type: String representation of this drawing.\n    xvals: Left and right coordinate that the object is drawn.\n    yvals: Top and bottom coordinate that the object is drawn.\n    channels: Pulse channel object bound to this drawing.\n    meta: Meta data dictionary of the object.\n    ignore_scaling: Set ``True`` to disable scaling.\n    styles: Style keyword args of the object. This conforms to `matplotlib`.\n\nRaises:\n    VisualizationError: When number of data points are not equals to 2.",
        "api_signature": "__init__(self, data_type, xvals, yvals, channels, meta, ignore_scaling, styles)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/drawings.py"
    },
    {
        "api_name": "gen_barrier",
        "full_api_name": "gen_barrier",
        "api_description": "Generate the barrier from provided relative barrier instruction.\n\nStylesheets:\n    - The `barrier` style is applied.\n\nArgs:\n    data: Barrier instruction data to draw.\n    formatter: Dictionary of stylesheet settings.\n    device: Backend configuration.\nReturns:\n    List of `LineData` drawings.",
        "api_signature": "gen_barrier(data, formatter, device)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/generators/barrier.py"
    },
    {
        "api_name": "gen_snapshot_name",
        "full_api_name": "gen_snapshot_name",
        "api_description": "Generate the name of snapshot.\n\nStylesheets:\n    - The `snapshot` style is applied for snapshot symbol.\n    - The `annotate` style is applied for label font size.\n\nArgs:\n    data: Snapshot instruction data to draw.\n    formatter: Dictionary of stylesheet settings.\n    device: Backend configuration.\n\nReturns:\n    List of `TextData` drawings.",
        "api_signature": "gen_snapshot_name(data, formatter, device)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/generators/snapshot.py"
    },
    {
        "api_name": "gen_snapshot_symbol",
        "full_api_name": "gen_snapshot_symbol",
        "api_description": "Generate a snapshot symbol with instruction meta data from provided snapshot instruction.\n\nStylesheets:\n    - The `snapshot` style is applied for snapshot symbol.\n    - The symbol type in unicode is specified in `formatter.unicode_symbol.snapshot`.\n    - The symbol type in latex is specified in `formatter.latex_symbol.snapshot`.\n\nArgs:\n    data: Snapshot instruction data to draw.\n    formatter: Dictionary of stylesheet settings.\n    device: Backend configuration.\n\nReturns:\n    List of `TextData` drawings.",
        "api_signature": "gen_snapshot_symbol(data, formatter, device)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/generators/snapshot.py"
    },
    {
        "api_name": "gen_formatted_phase",
        "full_api_name": "gen_formatted_phase",
        "api_description": "Generate the formatted virtual Z rotation label from provided frame instruction.\n\nRotation angle is expressed in units of pi.\nIf the denominator of fraction is larger than 10, the angle is expressed in units of radian.\n\nFor example:\n    - A value -3.14 is converted into `VZ(\\pi)`\n    - A value 1.57 is converted into `VZ(-\\frac{\\pi}{2})`\n    - A value 0.123 is converted into `VZ(-0.123 rad.)`\n\nStylesheets:\n    - The `frame_change` style is applied.\n    - The `annotate` style is applied for font size.\n\nNotes:\n    The phase operand of `PhaseShift` instruction has opposite sign to the Z gate definition.\n    Thus the sign of rotation angle is inverted.\n\nArgs:\n    data: Frame change instruction data to draw.\n    formatter: Dictionary of stylesheet settings.\n    device: Backend configuration.\n\nReturns:\n    List of `TextData` drawings.",
        "api_signature": "gen_formatted_phase(data, formatter, device)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/generators/frame.py"
    },
    {
        "api_name": "gen_formatted_freq_mhz",
        "full_api_name": "gen_formatted_freq_mhz",
        "api_description": "Generate the formatted frequency change label from provided frame instruction.\n\nFrequency change is expressed in units of MHz.\n\nFor example:\n    - A value 1,234,567 is converted into `\\Delta f = 1.23 MHz`\n\nStylesheets:\n    - The `frame_change` style is applied.\n    - The `annotate` style is applied for font size.\n\nArgs:\n    data: Frame change instruction data to draw.\n    formatter: Dictionary of stylesheet settings.\n    device: Backend configuration.\n\nReturns:\n    List of `TextData` drawings.",
        "api_signature": "gen_formatted_freq_mhz(data, formatter, device)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/generators/frame.py"
    },
    {
        "api_name": "gen_formatted_frame_values",
        "full_api_name": "gen_formatted_frame_values",
        "api_description": "Generate the formatted virtual Z rotation label and the frequency change label\nfrom provided frame instruction.\n\nPhase value is placed on top of the symbol, and frequency value is placed below the symbol.\nSee :py:func:`gen_formatted_phase` and :py:func:`gen_formatted_freq_mhz` for details.\n\nStylesheets:\n    - The `frame_change` style is applied.\n    - The `annotate` style is applied for font size.\n\nArgs:\n    data: Frame change instruction data to draw.\n    formatter: Dictionary of stylesheet settings.\n    device: Backend configuration.\n\nReturns:\n    List of `TextData` drawings.",
        "api_signature": "gen_formatted_frame_values(data, formatter, device)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/generators/frame.py"
    },
    {
        "api_name": "gen_raw_operand_values_compact",
        "full_api_name": "gen_raw_operand_values_compact",
        "api_description": "Generate the formatted virtual Z rotation label and the frequency change label\nfrom provided frame instruction.\n\nRaw operand values are shown in compact form. Frequency change is expressed\nin scientific notation. Values are shown in two lines.\n\nFor example:\n    - A phase change 1.57 and frequency change 1,234,567 are written by `1.57\\n1.2e+06`\n\nStylesheets:\n    - The `frame_change` style is applied.\n    - The `annotate` style is applied for font size.\n\nArgs:\n    data: Frame change instruction data to draw.\n    formatter: Dictionary of stylesheet settings.\n    device: Backend configuration.\n\nReturns:\n    List of `TextData` drawings.",
        "api_signature": "gen_raw_operand_values_compact(data, formatter, device)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/generators/frame.py"
    },
    {
        "api_name": "gen_frame_symbol",
        "full_api_name": "gen_frame_symbol",
        "api_description": "Generate a frame change symbol with instruction meta data from provided frame instruction.\n\nStylesheets:\n    - The `frame_change` style is applied.\n    - The symbol type in unicode is specified in `formatter.unicode_symbol.frame_change`.\n    - The symbol type in latex is specified in `formatter.latex_symbol.frame_change`.\n\nArgs:\n    data: Frame change instruction data to draw.\n    formatter: Dictionary of stylesheet settings.\n    device: Backend configuration.\n\nReturns:\n    List of `TextData` drawings.",
        "api_signature": "gen_frame_symbol(data, formatter, device)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/generators/frame.py"
    },
    {
        "api_name": "_phase_to_text",
        "full_api_name": "_phase_to_text",
        "api_description": "A helper function to convert a float value to text with pi.\n\nArgs:\n    formatter: Dictionary of stylesheet settings.\n    phase: A phase value in units of rad.\n    max_denom: Maximum denominator. Return raw value if exceed.\n    flip: Set `True` to flip the sign.\n\nReturns:\n    Standard text and latex text of phase value.",
        "api_signature": "_phase_to_text(formatter, phase, max_denom, flip)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/generators/frame.py"
    },
    {
        "api_name": "_freq_to_text",
        "full_api_name": "_freq_to_text",
        "api_description": "A helper function to convert a freq value to text with supplementary unit.\n\nArgs:\n    formatter: Dictionary of stylesheet settings.\n    freq: A frequency value in units of Hz.\n    unit: Supplementary unit. THz, GHz, MHz, kHz, Hz are supported.\n\nReturns:\n    Standard text and latex text of phase value.\n\nRaises:\n    VisualizationError: When unsupported unit is specified.",
        "api_signature": "_freq_to_text(formatter, freq, unit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/generators/frame.py"
    },
    {
        "api_name": "gen_baseline",
        "full_api_name": "gen_baseline",
        "api_description": "Generate the baseline associated with the chart.\n\nStylesheets:\n    - The `baseline` style is applied.\n\nArgs:\n    data: Chart axis data to draw.\n    formatter: Dictionary of stylesheet settings.\n    device: Backend configuration.\n\nReturns:\n    List of `LineData` drawings.",
        "api_signature": "gen_baseline(data, formatter, device)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/generators/chart.py"
    },
    {
        "api_name": "gen_chart_name",
        "full_api_name": "gen_chart_name",
        "api_description": "Generate the name of chart.\n\nStylesheets:\n    - The `axis_label` style is applied.\n\nArgs:\n    data: Chart axis data to draw.\n    formatter: Dictionary of stylesheet settings.\n    device: Backend configuration.\n\nReturns:\n    List of `TextData` drawings.",
        "api_signature": "gen_chart_name(data, formatter, device)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/generators/chart.py"
    },
    {
        "api_name": "gen_chart_scale",
        "full_api_name": "gen_chart_scale",
        "api_description": "Generate the current scaling value of the chart.\n\nStylesheets:\n    - The `axis_label` style is applied.\n    - The `annotate` style is partially applied for the font size.\n\nArgs:\n    data: Chart axis data to draw.\n    formatter: Dictionary of stylesheet settings.\n    device: Backend configuration.\n\nReturns:\n    List of `TextData` drawings.",
        "api_signature": "gen_chart_scale(data, formatter, device)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/generators/chart.py"
    },
    {
        "api_name": "gen_channel_freqs",
        "full_api_name": "gen_channel_freqs",
        "api_description": "Generate the frequency values of associated channels.\n\nStylesheets:\n    - The `axis_label` style is applied.\n    - The `annotate` style is partially applied for the font size.\n\nArgs:\n    data: Chart axis data to draw.\n    formatter: Dictionary of stylesheet settings.\n    device: Backend configuration.\n\nReturns:\n    List of `TextData` drawings.",
        "api_signature": "gen_channel_freqs(data, formatter, device)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/generators/chart.py"
    },
    {
        "api_name": "gen_filled_waveform_stepwise",
        "full_api_name": "gen_filled_waveform_stepwise",
        "api_description": "Generate filled area objects of the real and the imaginary part of waveform envelope.\n\nThe curve of envelope is not interpolated nor smoothed and presented\nas stepwise function at each data point.\n\nStylesheets:\n    - The `fill_waveform` style is applied.\n\nArgs:\n    data: Waveform instruction data to draw.\n    formatter: Dictionary of stylesheet settings.\n    device: Backend configuration.\n\nReturns:\n    List of `LineData`, `BoxData`, or `TextData` drawings.\n\nRaises:\n    VisualizationError: When the instruction parser returns invalid data format.",
        "api_signature": "gen_filled_waveform_stepwise(data, formatter, device)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/generators/waveform.py"
    },
    {
        "api_name": "gen_ibmq_latex_waveform_name",
        "full_api_name": "gen_ibmq_latex_waveform_name",
        "api_description": "Generate the formatted instruction name associated with the waveform.\n\nChannel name and ID string are removed and the rotation angle is expressed in units of pi.\nThe controlled rotation angle associated with the CR pulse name is divided by 2.\n\nNote that in many scientific articles the controlled rotation angle implies\nthe actual rotation angle, but in IQX backend the rotation angle represents\nthe difference between rotation angles with different control qubit states.\n\nFor example:\n    - 'X90p_d0_abcdefg' is converted into 'X(\\frac{\\pi}{2})'\n    - 'CR90p_u0_abcdefg` is converted into 'CR(\\frac{\\pi}{4})'\n\nStylesheets:\n    - The `annotate` style is applied.\n\nNotes:\n    This generator can convert pulse names used in the IQX backends.\n    If pulses are provided by the third party providers or the user defined,\n    the generator output may be the as-is pulse name.\n\nArgs:\n    data: Waveform instruction data to draw.\n    formatter: Dictionary of stylesheet settings.\n    device: Backend configuration.\n\nReturns:\n    List of `TextData` drawings.",
        "api_signature": "gen_ibmq_latex_waveform_name(data, formatter, device)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/generators/waveform.py"
    },
    {
        "api_name": "gen_waveform_max_value",
        "full_api_name": "gen_waveform_max_value",
        "api_description": "Generate the annotation for the maximum waveform height for\nthe real and the imaginary part of the waveform envelope.\n\nMaximum values smaller than the vertical resolution limit is ignored.\n\nStylesheets:\n    - The `annotate` style is applied.\n\nArgs:\n    data: Waveform instruction data to draw.\n    formatter: Dictionary of stylesheet settings.\n    device: Backend configuration.\n\nReturns:\n    List of `TextData` drawings.",
        "api_signature": "gen_waveform_max_value(data, formatter, device)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/generators/waveform.py"
    },
    {
        "api_name": "_draw_shaped_waveform",
        "full_api_name": "_draw_shaped_waveform",
        "api_description": "A private function that generates drawings of stepwise pulse lines.\n\nArgs:\n    xdata: Array of horizontal coordinate of waveform envelope.\n    ydata: Array of vertical coordinate of waveform envelope.\n    meta: Metadata dictionary of the waveform.\n    channel: Channel associated with the waveform to draw.\n    formatter: Dictionary of stylesheet settings.\n\nReturns:\n    List of drawings.\n\nRaises:\n    VisualizationError: When the waveform color for channel is not defined.",
        "api_signature": "_draw_shaped_waveform(xdata, ydata, meta, channel, formatter)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/generators/waveform.py"
    },
    {
        "api_name": "_draw_opaque_waveform",
        "full_api_name": "_draw_opaque_waveform",
        "api_description": "A private function that generates drawings of stepwise pulse lines.\n\nArgs:\n    init_time: Time when the opaque waveform starts.\n    duration: Duration of opaque waveform. This can be None or ParameterExpression.\n    pulse_shape: String that represents pulse shape.\n    pnames: List of parameter names.\n    meta: Metadata dictionary of the waveform.\n    channel: Channel associated with the waveform to draw.\n    formatter: Dictionary of stylesheet settings.\n\nReturns:\n    List of drawings.",
        "api_signature": "_draw_opaque_waveform(init_time, duration, pulse_shape, pnames, meta, channel, formatter)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/generators/waveform.py"
    },
    {
        "api_name": "_find_consecutive_index",
        "full_api_name": "_find_consecutive_index",
        "api_description": "A helper function to return non-consecutive index from the given list.\n\nThis drastically reduces memory footprint to represent a drawing,\nespecially for samples of very long flat-topped Gaussian pulses.\nTiny value fluctuation smaller than `resolution` threshold is removed.\n\nArgs:\n    data_array: The array of numbers.\n    resolution: Minimum resolution of sample values.\n\nReturns:\n    The compressed data array.",
        "api_signature": "_find_consecutive_index(data_array, resolution)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/generators/waveform.py"
    },
    {
        "api_name": "_parse_waveform",
        "full_api_name": "_parse_waveform",
        "api_description": "A helper function that generates an array for the waveform with\ninstruction metadata.\n\nArgs:\n    data: Instruction data set\n\nRaises:\n    VisualizationError: When invalid instruction type is loaded.\n\nReturns:\n    A data source to generate a drawing.",
        "api_signature": "_parse_waveform(data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/generators/waveform.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Mpl2DPlotter.__init__",
        "api_description": "Create new plotter.\n\nArgs:\n    canvas: Configured drawer canvas object. Canvas object should be updated\n        with `.update` method before set to the plotter API.\n    axis: Matplotlib axis object. When `axis` is provided, the plotter updates\n        given axis instead of creating and returning new matplotlib figure.",
        "api_signature": "__init__(self, canvas, axis)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/plotters/matplotlib.py"
    },
    {
        "api_name": "initialize_canvas",
        "full_api_name": "Mpl2DPlotter.initialize_canvas",
        "api_description": "Format appearance of matplotlib canvas.",
        "api_signature": "initialize_canvas(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/plotters/matplotlib.py"
    },
    {
        "api_name": "draw",
        "full_api_name": "Mpl2DPlotter.draw",
        "api_description": "Output drawings stored in canvas object.",
        "api_signature": "draw(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/plotters/matplotlib.py"
    },
    {
        "api_name": "get_image",
        "full_api_name": "Mpl2DPlotter.get_image",
        "api_description": "Get image data to return.\n\nArgs:\n    interactive: When set `True` show the circuit in a new window.\n        This depends on the matplotlib backend being used supporting this.\n\nReturns:\n    Matplotlib figure data.",
        "api_signature": "get_image(self, interactive)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/plotters/matplotlib.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BasePlotter.__init__",
        "api_description": "Create new plotter.\n\nArgs:\n    canvas: Configured drawer canvas object.",
        "api_signature": "__init__(self, canvas)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/plotters/base_plotter.py"
    },
    {
        "api_name": "initialize_canvas",
        "full_api_name": "BasePlotter.initialize_canvas",
        "api_description": "Format appearance of the canvas.",
        "api_signature": "initialize_canvas(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/plotters/base_plotter.py"
    },
    {
        "api_name": "draw",
        "full_api_name": "BasePlotter.draw",
        "api_description": "Output drawing objects stored in canvas object.",
        "api_signature": "draw(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/plotters/base_plotter.py"
    },
    {
        "api_name": "get_image",
        "full_api_name": "BasePlotter.get_image",
        "api_description": "Get image data to return.\n\nArgs:\n    interactive: When set `True` show the circuit in a new window.\n        This depends on the matplotlib backend being used supporting this.\n\nReturns:\n    Image data. This depends on the plotter API.",
        "api_signature": "get_image(self, interactive)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/pulse_v2/plotters/base_plotter.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QiskitTimelineStyle.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/stylesheet.py"
    },
    {
        "api_name": "update",
        "full_api_name": "QiskitTimelineStyle.update",
        "api_description": "",
        "api_signature": "update(self, __m)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/stylesheet.py"
    },
    {
        "api_name": "formatter",
        "full_api_name": "QiskitTimelineStyle.formatter",
        "api_description": "Return formatter field of style dictionary.",
        "api_signature": "formatter(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/stylesheet.py"
    },
    {
        "api_name": "generator",
        "full_api_name": "QiskitTimelineStyle.generator",
        "api_description": "Return generator field of style dictionary.",
        "api_signature": "generator(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/stylesheet.py"
    },
    {
        "api_name": "layout",
        "full_api_name": "QiskitTimelineStyle.layout",
        "api_description": "Return layout field of style dictionary.",
        "api_signature": "layout(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/stylesheet.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "IQXStandard.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/stylesheet.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "IQXStandard.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/stylesheet.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "IQXSimple.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/stylesheet.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "IQXSimple.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/stylesheet.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "IQXDebugging.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/stylesheet.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "IQXDebugging.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/stylesheet.py"
    },
    {
        "api_name": "default_style",
        "full_api_name": "default_style",
        "api_description": "Define default values of the timeline stylesheet.",
        "api_signature": "default_style()",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/stylesheet.py"
    },
    {
        "api_name": "draw",
        "full_api_name": "draw",
        "api_description": "Generate visualization data for scheduled circuit programs.\n\nArgs:\n    program: Program to visualize. This program should be a `QuantumCircuit` which is\n        transpiled with a scheduling_method, thus containing gate time information.\n    style: Stylesheet options. This can be dictionary or preset stylesheet classes. See\n        :py:class:`~qiskit.visualization.timeline.stylesheets.IQXStandard`,\n        :py:class:`~qiskit.visualization.timeline.stylesheets.IQXSimple`, and\n        :py:class:`~qiskit.visualization.timeline.stylesheets.IQXDebugging` for details of\n        preset stylesheets. See also the stylesheet section for details of configuration keys.\n    time_range: Set horizontal axis limit.\n    disable_bits: List of qubits of classical bits not shown in the output image.\n    show_clbits: A control property to show classical bits.\n        Set `True` to show classical bits.\n    idle_wires: A control property to show idle timeline.\n        Set `True` to show timeline without gates.\n    plot_barriers: A control property to show barrier instructions.\n        Set `True` to show barrier instructions.\n    show_delays: A control property to show delay instructions.\n        Set `True` to show delay instructions.\n    show_labels: A control property to show annotations, i.e. name, of gates.\n        Set `True` to show annotations.\n    plotter: Name of plotter API to generate an output image.\n        One of following APIs should be specified::\n\n            mpl: Matplotlib API\n                Matplotlib API to generate 2D image. Timelines are placed along y axis with\n                vertical offset. This API takes matplotlib.axes.Axes as `axis` input.\n\n        `axis` and `style` kwargs may depend on the plotter.\n    axis: Arbitrary object passed to the plotter. If this object is provided,\n        the plotters uses given `axis` instead of internally initializing a figure object.\n        This object format depends on the plotter. See plotters section for details.\n    filename: If provided the output image is dumped into a file under the filename.\n    show_idle: DEPRECATED.\n    show_barriers: DEPRECATED.\n\nReturns:\n    Visualization output data.\n\n    The returned data type depends on the `plotter`.\n    If matplotlib family is specified, this will be a `matplotlib.pyplot.Figure` data.\n    The returned data is generated by the `.get_image` method of the specified plotter API.\n\nRaises:\n    MissingOptionalLibraryError: When required visualization package is not installed.\n    VisualizationError: When invalid plotter API is specified.\n\n.. _style-dict-doc:\n\n**Style Dict Details**\n\nThe stylesheet kwarg contains numerous options that define the style of the\noutput timeline visualization.\nThe stylesheet options can be classified into `formatter`, `generator` and `layout`.\nThose options available in the stylesheet are defined below:\n\nArgs:\n    formatter.general.fig_width: Width of output image (default `14`).\n    formatter.general.fig_unit_height: Height of output image per timeline.\n        The sum of all timeline becomes the height of the output image (default `0.8`).\n    formatter.general.dpi: Dot per inch of image if `filename` is set (default `150`).\n    formatter.margin.top: Margin from the top boundary of the figure canvas to\n        the zero line of the first time slot (default `0.5`).\n    formatter.margin.bottom: Margin from the bottom boundary of the figure canvas to\n        the zero lien of the last time slot (default `0.5`).\n    formatter.margin.left_percent:  Margin from the left boundary of the figure canvas to\n        the left limit of the horizontal axis. The value is in units of percentage of\n        the whole program duration. If the duration is 100 and the value of 0.5 is set,\n        this keeps left margin of 5 (default `0.02`).\n    formatter.margin.right_percent: Margin from the right boundary of the figure canvas to\n        the right limit of the horizontal axis. The value is in units of percentage of\n        the whole program duration. If the duration is 100 and the value of 0.5 is set,\n        this keeps right margin of 5 (default `0.02`).\n    formatter.margin.link_interval_percent: Allowed overlap of gate links.\n        If multiple gate links are drawing within this range, links are horizontally\n        shifted not to overlap with each other. The value is in units of percentage of\n        the whole program duration (default `0.01`).\n    formatter.time_bucket.edge_dt: The length of round edge of gate boxes. Gate boxes are\n        smoothly faded in and out from the zero line. This value is in units of\n        the system cycle time dt (default `10`).\n    formatter.margin.minimum_duration: Minimum scheduled circuit duration.\n        If the duration of input circuit is below this value, horizontal limit is\n        set based on this value. This value is in units of\n        the system cycle time dt (default `50`).\n    formatter.color.background: Color code of the face color of canvas (default `#FFFFFF`).\n    formatter.color.timeslot: Face color of the time slot box (default `#DDDDDD`).\n    formatter.color.gate_name: Text color of the gate name annotations (default `#000000`).\n    formatter.color.bit_name: Text color of the bit label annotations (default `#000000`).\n    formatter.color.barrier: Line color of barriers (default `#222222`).\n    formatter.color.gates: A dictionary of the gate box or gate symbol colors\n        to use for each element type in the output visualization. The default\n        values are::\n\n            {\n                'u0': '#FA74A6',\n                'u1': '#000000',\n                'u2': '#FA74A6',\n                'u3': '#FA74A6',\n                'id': '#05BAB6',\n                'sx': '#FA74A6',\n                'sxdg': '#FA74A6',\n                'x': '#05BAB6',\n                'y': '#05BAB6',\n                'z': '#05BAB6',\n                'h': '#6FA4FF',\n                'cx': '#6FA4FF',\n                'cy': '#6FA4FF',\n                'cz': '#6FA4FF',\n                'swap': '#6FA4FF',\n                's': '#6FA4FF',\n                'sdg': '#6FA4FF',\n                'dcx': '#6FA4FF',\n                'iswap': '#6FA4FF',\n                't': '#BB8BFF',\n                'tdg': '#BB8BFF',\n                'r': '#BB8BFF',\n                'rx': '#BB8BFF',\n                'ry': '#BB8BFF',\n                'rz': '#000000',\n                'reset': '#808080',\n                'measure': '#808080'\n            }\n\n        You must specify all the necessary values if using this. If a gate name is not\n        specified, the color in `formatter.color.default_gate` is applied.\n    formatter.color.default_gate: Default gate color. This color is applied when\n        a gate name to visualize is not contained in the dictionary of\n        `formatter.color.gates` (default `#BB8BFF`).\n    formatter.latex_symbol.gates: A dictionary of latex representation of gate names\n        to use for each element type in the output visualization. The default\n        values are::\n\n            {\n                'u0': r'{\\rm U}_0',\n                'u1': r'{\\rm U}_1',\n                'u2': r'{\\rm U}_2',\n                'u3': r'{\\rm U}_3',\n                'id': r'{\\rm Id}',\n                'x': r'{\\rm X}',\n                'y': r'{\\rm Y}',\n                'z': r'{\\rm Z}',\n                'h': r'{\\rm H}',\n                'cx': r'{\\rm CX}',\n                'cy': r'{\\rm CY}',\n                'cz': r'{\\rm CZ}',\n                'swap': r'{\\rm SWAP}',\n                's': r'{\\rm S}',\n                'sdg': r'{\\rm S}^\\dagger',\n                'sx': r'{\\rm \u221aX}',\n                'sxdg': r'{\\rm \u221aX}^\\dagger',\n                'dcx': r'{\\rm DCX}',\n                'iswap': r'{\\rm iSWAP}',\n                't': r'{\\rm T}',\n                'tdg': r'{\\rm T}^\\dagger',\n                'r': r'{\\rm R}',\n                'rx': r'{\\rm R}_x',\n                'ry': r'{\\rm R}_y',\n                'rz': r'{\\rm R}_z',\n                'reset': r'|0\\rangle',\n                'measure': r'{\\rm Measure}'\n            }\n\n        You must specify all the necessary values if using this. There is\n        no provision for passing an incomplete dict in.\n    formatter.latex_symbol.frame_change: Latex representation of\n        the frame change symbol (default r`\\circlearrowleft`).\n    formatter.unicode_symbol.frame_change: Unicode representation of\n        the frame change symbol (default u'\\u21BA').\n    formatter.box_height.gate: Height of gate box (default `0.5`).\n    formatter.box_height.timeslot: Height of time slot (default `0.6`).\n    formatter.layer.gate: Layer index of gate boxes. Larger number comes\n        in the front of the output image (default `3`).\n    formatter.layer.timeslot: Layer index of time slots. Larger number comes\n        in the front of the output image (default `0`).\n    formatter.layer.gate_name: Layer index of gate name annotations. Larger number comes\n        in the front of the output image (default `5`).\n    formatter.layer.bit_name: Layer index of bit labels. Larger number comes\n        in the front of the output image (default `5`).\n    formatter.layer.frame_change: Layer index of frame change symbols. Larger number comes\n        in the front of the output image (default `4`).\n    formatter.layer.barrier: Layer index of barrier lines. Larger number comes\n        in the front of the output image (default `1`).\n    formatter.layer.gate_link: Layer index of gate link lines. Larger number comes\n        in the front of the output image (default `2`).\n    formatter.alpha.gate: Transparency of gate boxes. A value in the range from\n        `0` to `1`. The value `0` gives completely transparent boxes (default `1.0`).\n    formatter.alpha.timeslot: Transparency of time slots. A value in the range from\n        `0` to `1`. The value `0` gives completely transparent boxes (default `0.7`).\n    formatter.alpha.barrier: Transparency of barrier lines. A value in the range from\n        `0` to `1`. The value `0` gives completely transparent lines (default `0.5`).\n    formatter.alpha.gate_link: Transparency of gate link lines. A value in the range from\n        `0` to `1`. The value `0` gives completely transparent lines (default `0.8`).\n    formatter.line_width.gate: Line width of the fringe of gate boxes (default `0`).\n    formatter.line_width.timeslot: Line width of the fringe of time slots (default `0`).\n    formatter.line_width.barrier: Line width of barrier lines (default `3`).\n    formatter.line_width.gate_link: Line width of gate links (default `3`).\n    formatter.line_style.barrier: Line style of barrier lines. This\n        conforms to the line style spec of matplotlib (default `'-'`).\n    formatter.line_style.gate_link: Line style of gate link lines. This\n        conforms to the line style spec of matplotlib (default `'-'`).\n    formatter.text_size.gate_name: Text size of gate name annotations (default `12`).\n    formatter.text_size.bit_name: Text size of bit labels (default `15`).\n    formatter.text_size.frame_change: Text size of frame change symbols (default `18`).\n    formatter.text_size.axis_label: Text size of axis labels (default `13`).\n    formatter.label_offset.frame_change: Offset of zero duration gate name annotations\n        from the zero line of time slot (default `0.25`).\n    formatter.control.show_idle: Set `True` to show time slots without gate (default `True`).\n    formatter.control.show_clbits: Set `True` to show time slots of\n        classical bits (default `True`).\n    formatter.control.show_barriers: Set `True` to show barriers (default `True`).\n    formatter.control.show_delays: Set `True` to show delay boxes (default `True`).\n    generator.gates: List of callback functions that generates drawings\n        for gates. Arbitrary callback functions satisfying the generator format\n        can be set here. There are some default generators in the timeline drawer. See\n        :py:mod:`~qiskit.visualization.timeline.generators` for more details.\n        No default generator is set (default `[]`).\n    generator.bits: List of callback functions that generates drawings for bit labels\n        and time slots. Arbitrary callback functions satisfying the generator format\n        can be set here. There are some default generators in the timeline drawer. See\n        :py:mod:`~qiskit.visualization.timeline.generators` for more details.\n        No default generator is set (default `[]`).\n    generator.barriers: List of callback functions that generates drawings\n        for barriers. Arbitrary callback functions satisfying the generator format\n        can be set here. There are some default generators in the timeline drawer. See\n        :py:mod:`~qiskit.visualization.timeline.generators` for more details.\n        No default generator is set (default `[]`).\n    generator.gate_links: List of callback functions that generates drawings\n        for gate links. Arbitrary callback functions satisfying the generator format\n        can be set here. There are some default generators in the timeline drawer. See\n        :py:mod:`~qiskit.visualization.timeline.generators` for more details.\n        No default generator is set (default `[]`).\n    layout.bit_arrange: Callback function that sorts bits. See\n        :py:mod:`~qiskit.visualization.timeline.layouts` for more details.\n        No default layout is set. (default `None`).\n    layout.time_axis_map: Callback function that determines the layout of\n        horizontal axis labels. See :py:mod:`~qiskit.visualization.timeline.layouts`\n        for more details. No default layout is set. (default `None`).\n\nExamples:\n    To visualize a scheduled circuit program, you can call this function with set of\n    control arguments. Most of appearance of the output image can be controlled by the\n    stylesheet.\n\n    Drawing with the default stylesheet.\n\n    .. plot::\n       :include-source:\n\n        from qiskit import QuantumCircuit, transpile, schedule\n        from qiskit.visualization.timeline import draw\n        from qiskit.providers.fake_provider import GenericBackendV2\n\n        qc = QuantumCircuit(2)\n        qc.h(0)\n        qc.cx(0,1)\n\n        qc = transpile(qc, GenericBackendV2(5), scheduling_method='alap', layout_method='trivial')\n        draw(qc)\n\n    Drawing with the simple stylesheet.\n\n    .. plot::\n       :include-source:\n\n        from qiskit import QuantumCircuit, transpile, schedule\n        from qiskit.visualization.timeline import draw, IQXSimple\n        from qiskit.providers.fake_provider import GenericBackendV2\n\n        qc = QuantumCircuit(2)\n        qc.h(0)\n        qc.cx(0,1)\n\n        qc = transpile(qc, GenericBackendV2(5), scheduling_method='alap', layout_method='trivial')\n        draw(qc, style=IQXSimple())\n\n    Drawing with the stylesheet suited for program debugging.\n\n    .. plot::\n       :include-source:\n\n        from qiskit import QuantumCircuit, transpile, schedule\n        from qiskit.visualization.timeline import draw, IQXDebugging\n        from qiskit.providers.fake_provider import GenericBackendV2\n\n        qc = QuantumCircuit(2)\n        qc.h(0)\n        qc.cx(0,1)\n\n        qc = transpile(qc, GenericBackendV2(5), scheduling_method='alap', layout_method='trivial')\n        draw(qc, style=IQXDebugging())\n\n    You can partially customize a preset stylesheet when call it::\n\n        my_style = {\n            'formatter.general.fig_width': 16,\n            'formatter.general.fig_unit_height': 1\n        }\n        style = IQXStandard(**my_style)\n\n        # draw\n        draw(qc, style=style)\n\n    In the same way as above, you can create custom generator or layout functions\n    and update existing stylesheet with custom functions.\n    This feature enables you to control the most of appearance of the output image\n    without modifying the codebase of the scheduled circuit drawer.",
        "api_signature": "draw(program, style, time_range, disable_bits, show_clbits, idle_wires, plot_barriers, show_delays, show_labels, plotter, axis, filename)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/interface.py"
    },
    {
        "api_name": "qreg_creg_ascending",
        "full_api_name": "qreg_creg_ascending",
        "api_description": "Sort bits by ascending order.\n\nBit order becomes Q0, Q1, ..., Cl0, Cl1, ...\n\nArgs:\n    bits: List of bits to sort.\n\nReturns:\n    Sorted bits.",
        "api_signature": "qreg_creg_ascending(bits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/layouts.py"
    },
    {
        "api_name": "qreg_creg_descending",
        "full_api_name": "qreg_creg_descending",
        "api_description": "Sort bits by descending order.\n\nBit order becomes Q_N, Q_N-1, ..., Cl_N, Cl_N-1, ...\n\nArgs:\n    bits: List of bits to sort.\n\nReturns:\n    Sorted bits.",
        "api_signature": "qreg_creg_descending(bits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/layouts.py"
    },
    {
        "api_name": "time_map_in_dt",
        "full_api_name": "time_map_in_dt",
        "api_description": "Layout function for the horizontal axis formatting.\n\nGenerate equispaced 6 horizontal axis ticks.\n\nArgs:\n    time_window: Left and right edge of this graph.\n\nReturns:\n    Axis formatter object.",
        "api_signature": "time_map_in_dt(time_window)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/layouts.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "DrawerCanvas.__init__",
        "api_description": "Create new data container.",
        "api_signature": "__init__(self, stylesheet)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/core.py"
    },
    {
        "api_name": "time_range",
        "full_api_name": "DrawerCanvas.time_range",
        "api_description": "Return current time range to draw.\n\nCalculate net duration and add side margin to edge location.\n\nReturns:\n    Time window considering side margin.",
        "api_signature": "time_range(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/core.py"
    },
    {
        "api_name": "time_range",
        "full_api_name": "DrawerCanvas.time_range",
        "api_description": "Update time range to draw.",
        "api_signature": "time_range(self, new_range)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/core.py"
    },
    {
        "api_name": "collections",
        "full_api_name": "DrawerCanvas.collections",
        "api_description": "Return currently active entries from drawing data collection.\n\nThe object is returned with unique name as a key of an object handler.\nWhen the horizontal coordinate contains `AbstractCoordinate`,\nthe value is substituted by current time range preference.",
        "api_signature": "collections(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/core.py"
    },
    {
        "api_name": "add_data",
        "full_api_name": "DrawerCanvas.add_data",
        "api_description": "Add drawing to collections.\n\nIf the given object already exists in the collections,\nthis interface replaces the old object instead of adding new entry.\n\nArgs:\n    data: New drawing to add.",
        "api_signature": "add_data(self, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/core.py"
    },
    {
        "api_name": "load_program",
        "full_api_name": "DrawerCanvas.load_program",
        "api_description": "Load quantum circuit and create drawing..\n\nArgs:\n    program: Scheduled circuit object to draw.\n\nRaises:\n   VisualizationError: When circuit is not scheduled.",
        "api_signature": "load_program(self, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/core.py"
    },
    {
        "api_name": "set_time_range",
        "full_api_name": "DrawerCanvas.set_time_range",
        "api_description": "Set time range to draw.\n\nArgs:\n    t_start: Left boundary of drawing in units of cycle time.\n    t_end: Right boundary of drawing in units of cycle time.",
        "api_signature": "set_time_range(self, t_start, t_end)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/core.py"
    },
    {
        "api_name": "set_disable_bits",
        "full_api_name": "DrawerCanvas.set_disable_bits",
        "api_description": "Interface method to control visibility of bits.\n\nSpecified object in the blocked list will not be shown.\n\nArgs:\n    bit: A qubit or classical bit object to disable.\n    remove: Set `True` to disable, set `False` to enable.",
        "api_signature": "set_disable_bits(self, bit, remove)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/core.py"
    },
    {
        "api_name": "set_disable_type",
        "full_api_name": "DrawerCanvas.set_disable_type",
        "api_description": "Interface method to control visibility of data types.\n\nSpecified object in the blocked list will not be shown.\n\nArgs:\n    data_type: A drawing data type to disable.\n    remove: Set `True` to disable, set `False` to enable.",
        "api_signature": "set_disable_type(self, data_type, remove)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/core.py"
    },
    {
        "api_name": "update",
        "full_api_name": "DrawerCanvas.update",
        "api_description": "Update all collections.\n\nThis method should be called before the canvas is passed to the plotter.",
        "api_signature": "update(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/core.py"
    },
    {
        "api_name": "_check_data_visible",
        "full_api_name": "DrawerCanvas._check_data_visible",
        "api_description": "A helper function to check if the data is visible.\n\nArgs:\n    data: Drawing object to test.\n\nReturns:\n    Return `True` if the data is visible.",
        "api_signature": "_check_data_visible(self, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/core.py"
    },
    {
        "api_name": "_time_range_check",
        "full_api_name": "DrawerCanvas._time_range_check",
        "api_description": "If data is located outside the current time range.",
        "api_signature": "_time_range_check(_data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/core.py"
    },
    {
        "api_name": "_associated_bit_check",
        "full_api_name": "DrawerCanvas._associated_bit_check",
        "api_description": "If any associated bit is not shown.",
        "api_signature": "_associated_bit_check(_data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/core.py"
    },
    {
        "api_name": "_data_check",
        "full_api_name": "DrawerCanvas._data_check",
        "api_description": "If data is valid.",
        "api_signature": "_data_check(_data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/core.py"
    },
    {
        "api_name": "_check_bit_visible",
        "full_api_name": "DrawerCanvas._check_bit_visible",
        "api_description": "A helper function to check if the bit is visible.\n\nArgs:\n    bit: Bit object to test.\n\nReturns:\n    Return `True` if the bit is visible.",
        "api_signature": "_check_bit_visible(self, bit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/core.py"
    },
    {
        "api_name": "_bind_coordinate",
        "full_api_name": "DrawerCanvas._bind_coordinate",
        "api_description": "A helper function to bind actual coordinates to an `AbstractCoordinate`.\n\nArgs:\n    vals: Sequence of coordinate objects associated with a drawing.\n\nReturns:\n    Numpy data array with substituted values.",
        "api_signature": "_bind_coordinate(self, vals)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/core.py"
    },
    {
        "api_name": "substitute",
        "full_api_name": "DrawerCanvas.substitute",
        "api_description": "",
        "api_signature": "substitute(val)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/core.py"
    },
    {
        "api_name": "_check_link_overlap",
        "full_api_name": "DrawerCanvas._check_link_overlap",
        "api_description": "Helper method to check overlap of bit links.\n\nThis method dynamically shifts horizontal position of links if they are overlapped.",
        "api_signature": "_check_link_overlap(self, links)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/core.py"
    },
    {
        "api_name": "y_coords",
        "full_api_name": "DrawerCanvas.y_coords",
        "api_description": "",
        "api_signature": "y_coords(link)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/core.py"
    },
    {
        "api_name": "gen_sched_gate",
        "full_api_name": "gen_sched_gate",
        "api_description": "Generate time bucket or symbol of scheduled gate.\n\nIf gate duration is zero or frame change a symbol is generated instead of time box.\nThe face color of gates depends on the operand type.\n\nStylesheet:\n    - The `gate` style is applied for finite duration gate.\n    - The `frame_change` style is applied for zero duration gate.\n    - The `gate_face_color` style is applied for face color.\n\nArgs:\n    gate: Gate information source.\n    formatter: Dictionary of stylesheet settings.\n\nReturns:\n    List of `TextData` or `BoxData` drawings.",
        "api_signature": "gen_sched_gate(gate, formatter)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/generators.py"
    },
    {
        "api_name": "gen_full_gate_name",
        "full_api_name": "gen_full_gate_name",
        "api_description": "Generate gate name.\n\nParameters and associated bits are also shown.\n\nStylesheet:\n    - `gate_name` style is applied.\n    - `gate_latex_repr` key is used to find the latex representation of the gate name.\n\nArgs:\n    gate: Gate information source.\n    formatter: Dictionary of stylesheet settings.\n    program: Optional program that the bits are a part of.\n\nReturns:\n    List of `TextData` drawings.",
        "api_signature": "gen_full_gate_name(gate, formatter, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/generators.py"
    },
    {
        "api_name": "gen_short_gate_name",
        "full_api_name": "gen_short_gate_name",
        "api_description": "Generate gate name.\n\nOnly operand name is shown.\n\nStylesheet:\n    - `gate_name` style is applied.\n    - `gate_latex_repr` key is used to find the latex representation of the gate name.\n\nArgs:\n    gate: Gate information source.\n    formatter: Dictionary of stylesheet settings.\n\nReturns:\n    List of `TextData` drawings.",
        "api_signature": "gen_short_gate_name(gate, formatter)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/generators.py"
    },
    {
        "api_name": "gen_timeslot",
        "full_api_name": "gen_timeslot",
        "api_description": "Generate time slot of associated bit.\n\nStylesheet:\n    - `timeslot` style is applied.\n\nArgs:\n    bit: Bit object associated to this drawing.\n    formatter: Dictionary of stylesheet settings.\n\nReturns:\n    List of `BoxData` drawings.",
        "api_signature": "gen_timeslot(bit, formatter)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/generators.py"
    },
    {
        "api_name": "gen_bit_name",
        "full_api_name": "gen_bit_name",
        "api_description": "Generate bit label.\n\nStylesheet:\n    - `bit_name` style is applied.\n\nArgs:\n    bit: Bit object associated to this drawing.\n    formatter: Dictionary of stylesheet settings.\n    program: Optional program that the bits are a part of.\n\nReturns:\n    List of `TextData` drawings.",
        "api_signature": "gen_bit_name(bit, formatter, program)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/generators.py"
    },
    {
        "api_name": "gen_barrier",
        "full_api_name": "gen_barrier",
        "api_description": "Generate barrier line.\n\nStylesheet:\n    - `barrier` style is applied.\n\nArgs:\n    barrier: Barrier instruction.\n    formatter: Dictionary of stylesheet settings.\n\nReturns:\n    List of `LineData` drawings.",
        "api_signature": "gen_barrier(barrier, formatter)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/generators.py"
    },
    {
        "api_name": "gen_gate_link",
        "full_api_name": "gen_gate_link",
        "api_description": "Generate gate link line.\n\nLine color depends on the operand type.\n\nStylesheet:\n    - `gate_link` style is applied.\n    - The `gate_face_color` style is applied for line color.\n\nArgs:\n    link: Gate link object.\n    formatter: Dictionary of stylesheet settings.\n\nReturns:\n    List of `GateLinkData` drawings.",
        "api_signature": "gen_gate_link(link, formatter)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/generators.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ElementaryData.__init__",
        "api_description": "Create new drawing.\n\nArgs:\n    data_type: String representation of this drawing.\n    xvals: Series of horizontal coordinate that the object is drawn.\n    yvals: Series of vertical coordinate that the object is drawn.\n    bits: Qubit or Clbit object bound to this drawing.\n    meta: Meta data dictionary of the object.\n    styles: Style keyword args of the object. This conforms to `matplotlib`.",
        "api_signature": "__init__(self, data_type, xvals, yvals, bits, meta, styles)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/drawings.py"
    },
    {
        "api_name": "data_key",
        "full_api_name": "ElementaryData.data_key",
        "api_description": "Return unique hash of this object.",
        "api_signature": "data_key(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/drawings.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "ElementaryData.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/drawings.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "ElementaryData.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/drawings.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "LineData.__init__",
        "api_description": "Create new line.\n\nArgs:\n    data_type: String representation of this drawing.\n    xvals: Series of horizontal coordinate that the object is drawn.\n    yvals: Series of vertical coordinate that the object is drawn.\n    bit: Bit associated to this object.\n    meta: Meta data dictionary of the object.\n    styles: Style keyword args of the object. This conforms to `matplotlib`.",
        "api_signature": "__init__(self, data_type, xvals, yvals, bit, meta, styles)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/drawings.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BoxData.__init__",
        "api_description": "Create new box.\n\nArgs:\n    data_type: String representation of this drawing.\n    xvals: Left and right coordinate that the object is drawn.\n    yvals: Top and bottom coordinate that the object is drawn.\n    bit: Bit associated to this object.\n    meta: Meta data dictionary of the object.\n    styles: Style keyword args of the object. This conforms to `matplotlib`.\n\nRaises:\n    VisualizationError: When number of data points are not equals to 2.",
        "api_signature": "__init__(self, data_type, xvals, yvals, bit, meta, styles)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/drawings.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "TextData.__init__",
        "api_description": "Create new text.\n\nArgs:\n    data_type: String representation of this drawing.\n    xval: Horizontal coordinate that the object is drawn.\n    yval: Vertical coordinate that the object is drawn.\n    bit: Bit associated to this object.\n    text: A string to draw on the canvas.\n    latex: If set this string is used instead of `text`.\n    meta: Meta data dictionary of the object.\n    styles: Style keyword args of the object. This conforms to `matplotlib`.",
        "api_signature": "__init__(self, data_type, xval, yval, bit, text, latex, meta, styles)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/drawings.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "GateLinkData.__init__",
        "api_description": "Create new bit link.\n\nArgs:\n    xval: Horizontal coordinate that the object is drawn.\n    bits: Bit associated to this object.\n    styles: Style keyword args of the object. This conforms to `matplotlib`.",
        "api_signature": "__init__(self, xval, bits, styles)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/drawings.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "MplPlotter.__init__",
        "api_description": "Create new plotter.\n\nArgs:\n    canvas: Configured drawer canvas object. Canvas object should be updated\n        with `.update` method before initializing the plotter.\n    axis: Matplotlib axis object. When `axis` is provided, the plotter updates\n        given axis instead of creating and returning new matplotlib figure.",
        "api_signature": "__init__(self, canvas, axis)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/plotters/matplotlib.py"
    },
    {
        "api_name": "initialize_canvas",
        "full_api_name": "MplPlotter.initialize_canvas",
        "api_description": "Format appearance of matplotlib canvas.",
        "api_signature": "initialize_canvas(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/plotters/matplotlib.py"
    },
    {
        "api_name": "draw",
        "full_api_name": "MplPlotter.draw",
        "api_description": "Output drawings stored in canvas object.",
        "api_signature": "draw(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/plotters/matplotlib.py"
    },
    {
        "api_name": "_time_bucket_outline",
        "full_api_name": "MplPlotter._time_bucket_outline",
        "api_description": "Generate outline of time bucket. Edges are smoothly faded.\n\nArgs:\n    xvals: Left and right point coordinates.\n    yvals: Bottom and top point coordinates.\n\nReturns:\n    Coordinate vectors of time bucket fringe.",
        "api_signature": "_time_bucket_outline(self, xvals, yvals)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/plotters/matplotlib.py"
    },
    {
        "api_name": "save_file",
        "full_api_name": "MplPlotter.save_file",
        "api_description": "Save image to file.\nArgs:\n    filename: File path to output image data.",
        "api_signature": "save_file(self, filename)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/plotters/matplotlib.py"
    },
    {
        "api_name": "get_image",
        "full_api_name": "MplPlotter.get_image",
        "api_description": "Get image data to return.\nArgs:\n    interactive: When set `True` show the circuit in a new window.\n        This depends on the matplotlib backend being used supporting this.\nReturns:\n    Matplotlib figure data.",
        "api_signature": "get_image(self, interactive)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/plotters/matplotlib.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BasePlotter.__init__",
        "api_description": "Create new plotter.\nArgs:\n    canvas: Configured drawer canvas object.",
        "api_signature": "__init__(self, canvas)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/plotters/base_plotter.py"
    },
    {
        "api_name": "initialize_canvas",
        "full_api_name": "BasePlotter.initialize_canvas",
        "api_description": "Format appearance of the canvas.",
        "api_signature": "initialize_canvas(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/plotters/base_plotter.py"
    },
    {
        "api_name": "draw",
        "full_api_name": "BasePlotter.draw",
        "api_description": "Output drawings stored in canvas object.",
        "api_signature": "draw(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/plotters/base_plotter.py"
    },
    {
        "api_name": "save_file",
        "full_api_name": "BasePlotter.save_file",
        "api_description": "Save image to file.\nArgs:\n    filename: File path to output image data.",
        "api_signature": "save_file(self, filename)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/plotters/base_plotter.py"
    },
    {
        "api_name": "get_image",
        "full_api_name": "BasePlotter.get_image",
        "api_description": "Get image data to return.\nArgs:\n    interactive: When set `True` show the circuit in a new window.\n        This depends on the matplotlib backend being used supporting this.\nReturns:\n    Image data. This depends on the plotter API.",
        "api_signature": "get_image(self, interactive)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/timeline/plotters/base_plotter.py"
    },
    {
        "api_name": "circuit_drawer",
        "full_api_name": "circuit_drawer",
        "api_description": "Draw the quantum circuit. Use the output parameter to choose the drawing format:\n\n**text**: ASCII art TextDrawing that can be printed in the console.\n\n**mpl**: images with color rendered purely in Python using matplotlib.\n\n**latex**: high-quality images compiled via latex.\n\n**latex_source**: raw uncompiled latex output.\n\n.. warning::\n\n    Support for :class:`~.expr.Expr` nodes in conditions and :attr:`.SwitchCaseOp.target`\n    fields is preliminary and incomplete.  The ``text`` and ``mpl`` drawers will make a\n    best-effort attempt to show data dependencies, but the LaTeX-based drawers will skip\n    these completely.\n\nArgs:\n    circuit: The circuit to visualize.\n    scale: Scale of image to draw (shrink if ``< 1.0``). Only used by\n        the ``mpl``, ``latex`` and ``latex_source`` outputs. Defaults to ``1.0``.\n    filename: File path to save image to. Defaults to ``None`` (result not saved in a file).\n    style: Style name, file name of style JSON file, or a dictionary specifying the style.\n\n        * The supported style names are ``\"iqp\"`` (default), ``\"iqp-dark\"``, ``\"clifford\"``,\n            ``\"textbook\"`` and ``\"bw\"``.\n        * If given a JSON file, e.g. ``my_style.json`` or ``my_style`` (the ``.json``\n            extension may be omitted), this function attempts to load the style dictionary\n            from that location. Note, that the JSON file must completely specify the\n            visualization specifications. The file is searched for in\n            ``qiskit/visualization/circuit/styles``, the current working directory, and\n            the location specified in ``~/.qiskit/settings.conf``.\n        * If a dictionary, every entry overrides the default configuration. If the\n            ``\"name\"`` key is given, the default configuration is given by that style.\n            For example, ``{\"name\": \"textbook\", \"subfontsize\": 5}`` loads the ``\"texbook\"``\n            style and sets the subfontsize (e.g. the gate angles) to ``5``.\n        * If ``None`` the default style ``\"iqp\"`` is used or, if given, the default style\n            specified in ``~/.qiskit/settings.conf``.\n\n    output: Select the output method to use for drawing the circuit.\n        Valid choices are ``text``, ``mpl``, ``latex``, ``latex_source``.\n        By default, the ``text`` drawer is used unless the user config file\n        (usually ``~/.qiskit/settings.conf``) has an alternative backend set\n        as the default. For example, ``circuit_drawer = latex``. If the output\n        kwarg is set, that backend will always be used over the default in\n        the user config file.\n    interactive: When set to ``True``, show the circuit in a new window\n        (for ``mpl`` this depends on the matplotlib backend being used\n        supporting this). Note when used with either the `text` or the\n        ``latex_source`` output type this has no effect and will be silently\n        ignored. Defaults to ``False``.\n    reverse_bits: When set to ``True``, reverse the bit order inside\n        registers for the output visualization. Defaults to ``False`` unless the\n        user config file (usually ``~/.qiskit/settings.conf``) has an\n        alternative value set. For example, ``circuit_reverse_bits = True``.\n    plot_barriers: Enable/disable drawing barriers in the output\n        circuit. Defaults to ``True``.\n    justify: Options are ``\"left\"``, ``\"right\"`` or ``\"none\"`` (str).\n        If anything else is supplied, left justified will be used instead.\n        It refers to where gates should be placed in the output circuit if\n        there is an option. ``none`` results in each gate being placed in\n        its own column. Defaults to ``left``.\n    vertical_compression: ``high``, ``medium`` or ``low``. It\n        merges the lines generated by the `text` output so the drawing\n        will take less vertical room.  Default is ``medium``. Only used by\n        the ``text`` output, will be silently ignored otherwise.\n    idle_wires: Include idle wires (wires with no circuit elements)\n        in output visualization. Default is ``True`` unless the\n        user config file (usually ``~/.qiskit/settings.conf``) has an\n        alternative value set. For example, ``circuit_idle_wires = False``.\n    with_layout: Include layout information, with labels on the\n        physical layout. Default is ``True``.\n    fold: Sets pagination. It can be disabled using -1. In ``text``,\n        sets the length of the lines. This is useful when the drawing does\n        not fit in the console. If None (default), it will try to guess the\n        console width using ``shutil.get_terminal_size()``. However, if\n        running in jupyter, the default line length is set to 80 characters.\n        In ``mpl``, it is the number of (visual) layers before folding.\n        Default is 25.\n    ax: Only used by the `mpl` backend. An optional ``matplotlib.axes.Axes``\n        object to be used for the visualization output. If none is\n        specified, a new matplotlib Figure will be created and used.\n        Additionally, if specified there will be no returned Figure since\n        it is redundant.\n    initial_state: Adds :math:`|0\\rangle` in the beginning of the qubit wires and\n        :math:`0` to classical wires. Default is ``False``.\n    cregbundle: If set to ``True``, bundle classical registers.\n        Default is ``True``, except for when ``output`` is set to  ``\"text\"``.\n    wire_order: A list of integers used to reorder the display\n        of the bits. The list must have an entry for every bit with the bits\n        in the range 0 to (``num_qubits`` + ``num_clbits``).\n    expr_len: The number of characters to display if an :class:`~.expr.Expr`\n        is used for the condition in a :class:`.ControlFlowOp`. If this number is exceeded,\n        the string will be truncated at that number and '...' added to the end.\n\nReturns:\n    :class:`.TextDrawing` or :class:`matplotlib.figure` or :class:`PIL.Image` or\n    :class:`str`:\n\n    * ``TextDrawing`` (if ``output='text'``)\n        A drawing that can be printed as ascii art.\n    * ``matplotlib.figure.Figure`` (if ``output='mpl'``)\n        A matplotlib figure object for the circuit diagram.\n    * ``PIL.Image`` (if ``output='latex``')\n        An in-memory representation of the image of the circuit diagram.\n    * ``str`` (if ``output='latex_source'``)\n        The LaTeX source code for visualizing the circuit diagram.\n\nRaises:\n    VisualizationError: when an invalid output method is selected\n    ImportError: when the output methods requires non-installed libraries.\n\nExample:\n    .. plot::\n        :include-source:\n\n        from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit\n        qc = QuantumCircuit(1, 1)\n        qc.h(0)\n        qc.measure(0, 0)\n        qc.draw(output='mpl', style={'backgroundcolor': '#EEEEEE'})",
        "api_signature": "circuit_drawer(circuit, scale, filename, style, output, interactive, plot_barriers, reverse_bits, justify, vertical_compression, idle_wires, with_layout, fold, ax, initial_state, cregbundle, wire_order, expr_len)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/circuit_visualization.py"
    },
    {
        "api_name": "check_clbit_in_inst",
        "full_api_name": "check_clbit_in_inst",
        "api_description": "",
        "api_signature": "check_clbit_in_inst(circuit, cregbundle)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/circuit_visualization.py"
    },
    {
        "api_name": "_text_circuit_drawer",
        "full_api_name": "_text_circuit_drawer",
        "api_description": "Draws a circuit using ascii art.\n\nArgs:\n    circuit (QuantumCircuit): Input circuit\n    filename (str): Optional filename to write the result\n    reverse_bits (bool): Rearrange the bits in reverse order.\n    plot_barriers (bool): Draws the barriers when they are there.\n    justify (str) : `left`, `right` or `none`. Defaults to `left`. Says how\n        the circuit should be justified.\n    vertical_compression (string): `high`, `medium`, or `low`. It merges the\n        lines so the drawing will take less vertical room. Default is `high`.\n    idle_wires (bool): Include idle wires. Default is True.\n    with_layout (bool): Include layout information with labels on the physical\n        layout. Default: True\n    fold (int): Optional. Breaks the circuit drawing to this length. This\n        is useful when the drawing does not fit in the console. If\n        None (default), it will try to guess the console width using\n        `shutil.get_terminal_size()`. If you don't want pagination\n        at all, set `fold=-1`.\n    initial_state (bool): Optional. Adds |0> in the beginning of the line.\n        Default: `False`.\n    cregbundle (bool): Optional. If set True, bundle classical registers.\n        Default: ``True``.\n    encoding (str): Optional. Sets the encoding preference of the output.\n        Default: ``sys.stdout.encoding``.\n    wire_order (list): Optional. A list of integers used to reorder the display\n        of the bits. The list must have an entry for every bit with the bits\n        in the range 0 to (num_qubits + num_clbits).\n    expr_len (int): Optional. The number of characters to display if an :class:`~.expr.Expr`\n        is used for the condition in a :class:`.ControlFlowOp`. If this number is exceeded,\n        the string will be truncated at that number and '...' added to the end.\n\nReturns:\n    TextDrawing: An instance that, when printed, draws the circuit in ascii art.\n\nRaises:\n    VisualizationError: When the filename extension is not .txt.",
        "api_signature": "_text_circuit_drawer(circuit, filename, reverse_bits, plot_barriers, justify, vertical_compression, idle_wires, with_layout, fold, initial_state, cregbundle, encoding, wire_order, expr_len)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/circuit_visualization.py"
    },
    {
        "api_name": "_latex_circuit_drawer",
        "full_api_name": "_latex_circuit_drawer",
        "api_description": "Draw a quantum circuit based on latex (Qcircuit package)\n\nRequires version >=2.6.0 of the qcircuit LaTeX package.\n\nArgs:\n    circuit (QuantumCircuit): a quantum circuit\n    scale (float): scaling factor\n    style (dict or str): dictionary of style or file name of style file\n    filename (str): file path to save image to\n    reverse_bits (bool): When set to True reverse the bit order inside\n        registers for the output visualization.\n    plot_barriers (bool): Enable/disable drawing barriers in the output\n        circuit. Defaults to True.\n    justify (str) : `left`, `right` or `none`. Defaults to `left`. Says how\n        the circuit should be justified.\n    idle_wires (bool): Include idle wires. Default is True.\n    with_layout (bool): Include layout information, with labels on the physical\n        layout. Default: True\n    initial_state (bool): Optional. Adds |0> in the beginning of the line.\n        Default: `False`.\n    cregbundle (bool): Optional. If set True, bundle classical registers.  On by default, if\n        this is possible for the given circuit, otherwise off.\n    wire_order (list): Optional. A list of integers used to reorder the display\n        of the bits. The list must have an entry for every bit with the bits\n        in the range 0 to (num_qubits + num_clbits).\n\nReturns:\n    PIL.Image: an in-memory representation of the circuit diagram\n\nRaises:\n    MissingOptionalLibraryError: if pillow, pdflatex, or poppler are not installed\n    VisualizationError: if one of the conversion utilities failed for some internal or\n        file-access reason.",
        "api_signature": "_latex_circuit_drawer(circuit, scale, style, filename, plot_barriers, reverse_bits, justify, idle_wires, with_layout, initial_state, cregbundle, wire_order)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/circuit_visualization.py"
    },
    {
        "api_name": "_generate_latex_source",
        "full_api_name": "_generate_latex_source",
        "api_description": "Convert QuantumCircuit to LaTeX string.\n\nArgs:\n    circuit (QuantumCircuit): a quantum circuit\n    scale (float): scaling factor\n    style (dict or str): dictionary of style or file name of style file\n    filename (str): optional filename to write latex\n    reverse_bits (bool): When set to True reverse the bit order inside\n        registers for the output visualization.\n    plot_barriers (bool): Enable/disable drawing barriers in the output\n        circuit. Defaults to True.\n    justify (str) : `left`, `right` or `none`. Defaults to `left`. Says how\n        the circuit should be justified.\n    idle_wires (bool): Include idle wires. Default is True.\n    with_layout (bool): Include layout information, with labels on the physical\n        layout. Default: True\n    initial_state (bool): Optional. Adds |0> in the beginning of the line.\n        Default: `False`.\n    cregbundle (bool): Optional. If set True, bundle classical registers.\n    wire_order (list): Optional. A list of integers used to reorder the display\n        of the bits. The list must have an entry for every bit with the bits\n        in the range 0 to (num_qubits + num_clbits).\n\nReturns:\n    str: Latex string appropriate for writing to file.",
        "api_signature": "_generate_latex_source(circuit, filename, scale, style, reverse_bits, plot_barriers, justify, idle_wires, with_layout, initial_state, cregbundle, wire_order)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/circuit_visualization.py"
    },
    {
        "api_name": "_matplotlib_circuit_drawer",
        "full_api_name": "_matplotlib_circuit_drawer",
        "api_description": "Draw a quantum circuit based on matplotlib.\nIf `%matplotlib inline` is invoked in a Jupyter notebook, it visualizes a circuit inline.\nWe recommend `%config InlineBackend.figure_format = 'svg'` for the inline visualization.\n\nArgs:\n    circuit (QuantumCircuit): a quantum circuit\n    scale (float): scaling factor\n    filename (str): file path to save image to\n    style (dict or str): dictionary of style or file name of style file\n    reverse_bits (bool): When set to True, reverse the bit order inside\n        registers for the output visualization.\n    plot_barriers (bool): Enable/disable drawing barriers in the output\n        circuit. Defaults to True.\n    justify (str): `left`, `right` or `none`. Defaults to `left`. Says how\n        the circuit should be justified.\n    idle_wires (bool): Include idle wires. Default is True.\n    with_layout (bool): Include layout information, with labels on the physical\n        layout. Default: True.\n    fold (int): Number of vertical layers allowed before folding. Default is 25.\n    ax (matplotlib.axes.Axes): An optional Axes object to be used for\n        the visualization output. If none is specified, a new matplotlib\n        Figure will be created and used. Additionally, if specified there\n        will be no returned Figure since it is redundant.\n    initial_state (bool): Optional. Adds |0> in the beginning of the line.\n        Default: `False`.\n    cregbundle (bool): Optional. If set True bundle classical registers.\n        Default: ``True``.\n    wire_order (list): Optional. A list of integers used to reorder the display\n        of the bits. The list must have an entry for every bit with the bits\n        in the range 0 to (num_qubits + num_clbits).\n    expr_len (int): Optional. The number of characters to display if an :class:`~.expr.Expr`\n        is used for the condition in a :class:`.ControlFlowOp`. If this number is exceeded,\n        the string will be truncated at that number and '...' added to the end.\n\nReturns:\n    matplotlib.figure: a matplotlib figure object for the circuit diagram\n        if the ``ax`` kwarg is not set.",
        "api_signature": "_matplotlib_circuit_drawer(circuit, scale, filename, style, plot_barriers, reverse_bits, justify, idle_wires, with_layout, fold, ax, initial_state, cregbundle, wire_order, expr_len)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/circuit_visualization.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "MatplotlibDrawer.__init__",
        "api_description": "",
        "api_signature": "__init__(self, qubits, clbits, nodes, circuit, scale, style, reverse_bits, plot_barriers, fold, ax, initial_state, cregbundle, with_layout, expr_len)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/matplotlib.py"
    },
    {
        "api_name": "draw",
        "full_api_name": "MatplotlibDrawer.draw",
        "api_description": "Main entry point to 'matplotlib' ('mpl') drawer. Called from\n``visualization.circuit_drawer`` and from ``QuantumCircuit.draw`` through circuit_drawer.",
        "api_signature": "draw(self, filename, verbose)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/matplotlib.py"
    },
    {
        "api_name": "_get_layer_widths",
        "full_api_name": "MatplotlibDrawer._get_layer_widths",
        "api_description": "Compute the layer_widths for the layers",
        "api_signature": "_get_layer_widths(self, node_data, wire_map, outer_circuit, glob_data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/matplotlib.py"
    },
    {
        "api_name": "lookup_var",
        "full_api_name": "MatplotlibDrawer.lookup_var",
        "api_description": "Look up a classical-expression variable or register/bit in our\ninternal symbol table, and return an OQ3-like identifier.",
        "api_signature": "lookup_var(var)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/matplotlib.py"
    },
    {
        "api_name": "_set_bit_reg_info",
        "full_api_name": "MatplotlibDrawer._set_bit_reg_info",
        "api_description": "Get all the info for drawing bit/reg names and numbers",
        "api_signature": "_set_bit_reg_info(self, wire_map, qubits_dict, clbits_dict, glob_data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/matplotlib.py"
    },
    {
        "api_name": "_get_coords",
        "full_api_name": "MatplotlibDrawer._get_coords",
        "api_description": "Load all the coordinate info needed to place the gates on the drawing.",
        "api_signature": "_get_coords(self, node_data, wire_map, outer_circuit, layer_widths, qubits_dict, clbits_dict, glob_data, flow_parent)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/matplotlib.py"
    },
    {
        "api_name": "_get_text_width",
        "full_api_name": "MatplotlibDrawer._get_text_width",
        "api_description": "Compute the width of a string in the default font",
        "api_signature": "_get_text_width(self, text, glob_data, fontsize, param, reg_remove_under)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/matplotlib.py"
    },
    {
        "api_name": "_draw_regs_wires",
        "full_api_name": "MatplotlibDrawer._draw_regs_wires",
        "api_description": "Draw the register names and numbers, wires, and vertical lines at the ends",
        "api_signature": "_draw_regs_wires(self, num_folds, xmax, max_x_index, qubits_dict, clbits_dict, glob_data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/matplotlib.py"
    },
    {
        "api_name": "_add_nodes_and_coords",
        "full_api_name": "MatplotlibDrawer._add_nodes_and_coords",
        "api_description": "Add the nodes from ControlFlowOps and their coordinates to the main circuit",
        "api_signature": "_add_nodes_and_coords(self, nodes, node_data, wire_map, outer_circuit, layer_widths, qubits_dict, clbits_dict, glob_data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/matplotlib.py"
    },
    {
        "api_name": "_draw_ops",
        "full_api_name": "MatplotlibDrawer._draw_ops",
        "api_description": "Draw the gates in the circuit",
        "api_signature": "_draw_ops(self, nodes, node_data, wire_map, outer_circuit, layer_widths, qubits_dict, clbits_dict, glob_data, verbose)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/matplotlib.py"
    },
    {
        "api_name": "_get_colors",
        "full_api_name": "MatplotlibDrawer._get_colors",
        "api_description": "Get all the colors needed for drawing the circuit",
        "api_signature": "_get_colors(self, node, node_data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/matplotlib.py"
    },
    {
        "api_name": "_condition",
        "full_api_name": "MatplotlibDrawer._condition",
        "api_description": "Add a conditional to a gate",
        "api_signature": "_condition(self, node, node_data, wire_map, outer_circuit, cond_xy, glob_data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/matplotlib.py"
    },
    {
        "api_name": "_measure",
        "full_api_name": "MatplotlibDrawer._measure",
        "api_description": "Draw the measure symbol and the line to the clbit",
        "api_signature": "_measure(self, node, node_data, outer_circuit, glob_data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/matplotlib.py"
    },
    {
        "api_name": "_barrier",
        "full_api_name": "MatplotlibDrawer._barrier",
        "api_description": "Draw a barrier",
        "api_signature": "_barrier(self, node, node_data, glob_data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/matplotlib.py"
    },
    {
        "api_name": "_gate",
        "full_api_name": "MatplotlibDrawer._gate",
        "api_description": "Draw a 1-qubit gate",
        "api_signature": "_gate(self, node, node_data, glob_data, xy)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/matplotlib.py"
    },
    {
        "api_name": "_multiqubit_gate",
        "full_api_name": "MatplotlibDrawer._multiqubit_gate",
        "api_description": "Draw a gate covering more than one qubit",
        "api_signature": "_multiqubit_gate(self, node, node_data, glob_data, xy)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/matplotlib.py"
    },
    {
        "api_name": "_flow_op_gate",
        "full_api_name": "MatplotlibDrawer._flow_op_gate",
        "api_description": "Draw the box for a flow op circuit",
        "api_signature": "_flow_op_gate(self, node, node_data, glob_data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/matplotlib.py"
    },
    {
        "api_name": "_control_gate",
        "full_api_name": "MatplotlibDrawer._control_gate",
        "api_description": "Draw a controlled gate",
        "api_signature": "_control_gate(self, node, node_data, glob_data, mod_control)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/matplotlib.py"
    },
    {
        "api_name": "_set_ctrl_bits",
        "full_api_name": "MatplotlibDrawer._set_ctrl_bits",
        "api_description": "Determine which qubits are controls and whether they are open or closed",
        "api_signature": "_set_ctrl_bits(self, ctrl_state, num_ctrl_qubits, qbit, glob_data, ec, tc, text, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/matplotlib.py"
    },
    {
        "api_name": "_ctrl_qubit",
        "full_api_name": "MatplotlibDrawer._ctrl_qubit",
        "api_description": "Draw a control circle and if top or bottom control, draw control label",
        "api_signature": "_ctrl_qubit(self, xy, glob_data, fc, ec, tc, text, text_top)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/matplotlib.py"
    },
    {
        "api_name": "_x_tgt_qubit",
        "full_api_name": "MatplotlibDrawer._x_tgt_qubit",
        "api_description": "Draw the cnot target symbol",
        "api_signature": "_x_tgt_qubit(self, xy, glob_data, ec, ac)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/matplotlib.py"
    },
    {
        "api_name": "_symmetric_gate",
        "full_api_name": "MatplotlibDrawer._symmetric_gate",
        "api_description": "Draw symmetric gates for cz, cu1, cp, and rzz",
        "api_signature": "_symmetric_gate(self, node, node_data, base_type, glob_data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/matplotlib.py"
    },
    {
        "api_name": "_swap",
        "full_api_name": "MatplotlibDrawer._swap",
        "api_description": "Draw a Swap gate",
        "api_signature": "_swap(self, xy, node, node_data, color)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/matplotlib.py"
    },
    {
        "api_name": "_swap_cross",
        "full_api_name": "MatplotlibDrawer._swap_cross",
        "api_description": "Draw the Swap cross symbol",
        "api_signature": "_swap_cross(self, xy, color)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/matplotlib.py"
    },
    {
        "api_name": "_sidetext",
        "full_api_name": "MatplotlibDrawer._sidetext",
        "api_description": "Draw the sidetext for symmetric gates",
        "api_signature": "_sidetext(self, node, node_data, xy, tc, text)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/matplotlib.py"
    },
    {
        "api_name": "_line",
        "full_api_name": "MatplotlibDrawer._line",
        "api_description": "Draw a line from xy0 to xy1",
        "api_signature": "_line(self, xy0, xy1, lc, ls, zorder)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/matplotlib.py"
    },
    {
        "api_name": "_plot_coord",
        "full_api_name": "MatplotlibDrawer._plot_coord",
        "api_description": "Get the coord positions for an index",
        "api_signature": "_plot_coord(self, x_index, y_index, gate_width, glob_data, flow_op)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/matplotlib.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "NodeData.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/matplotlib.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QCircuitImage.__init__",
        "api_description": "QCircuitImage initializer.\n\nArgs:\n    qubits (list[Qubit]): list of qubits\n    clbits (list[Clbit]): list of clbits\n    nodes (list[list[DAGNode]]): list of circuit instructions, grouped by layer\n    scale (float): image scaling\n    style (dict or str): dictionary of style or file name of style file\n    reverse_bits (bool): when True, reverse the bit ordering of the registers\n    plot_barriers (bool): Enable/disable drawing barriers in the output\n       circuit. Defaults to True.\n    initial_state (bool): Optional. Adds |0> in the beginning of the line. Default: `False`.\n    cregbundle (bool): Optional. If set True bundle classical registers.\n    circuit (QuantumCircuit): the circuit that's being displayed\nRaises:\n    ImportError: If pylatexenc is not installed",
        "api_signature": "__init__(self, qubits, clbits, nodes, scale, style, reverse_bits, plot_barriers, initial_state, cregbundle, with_layout, circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/latex.py"
    },
    {
        "api_name": "latex",
        "full_api_name": "QCircuitImage.latex",
        "api_description": "Return LaTeX string representation of circuit.",
        "api_signature": "latex(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/latex.py"
    },
    {
        "api_name": "_initialize_latex_array",
        "full_api_name": "QCircuitImage._initialize_latex_array",
        "api_description": "Initialize qubit and clbit labels and set wire separation",
        "api_signature": "_initialize_latex_array(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/latex.py"
    },
    {
        "api_name": "_get_image_depth",
        "full_api_name": "QCircuitImage._get_image_depth",
        "api_description": "Get depth information for the circuit.",
        "api_signature": "_get_image_depth(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/latex.py"
    },
    {
        "api_name": "_get_beamer_page",
        "full_api_name": "QCircuitImage._get_beamer_page",
        "api_description": "Get height, width & scale attributes for the beamer page.",
        "api_signature": "_get_beamer_page(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/latex.py"
    },
    {
        "api_name": "_build_latex_array",
        "full_api_name": "QCircuitImage._build_latex_array",
        "api_description": "Returns an array of strings containing \\LaTeX for this circuit.",
        "api_signature": "_build_latex_array(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/latex.py"
    },
    {
        "api_name": "_build_multi_gate",
        "full_api_name": "QCircuitImage._build_multi_gate",
        "api_description": "Add a multiple wire gate to the _latex list",
        "api_signature": "_build_multi_gate(self, op, gate_text, wire_list, cwire_list, col)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/latex.py"
    },
    {
        "api_name": "_build_ctrl_gate",
        "full_api_name": "QCircuitImage._build_ctrl_gate",
        "api_description": "Add a gate with multiple controls to the _latex list",
        "api_signature": "_build_ctrl_gate(self, op, gate_text, wire_list, col)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/latex.py"
    },
    {
        "api_name": "_build_symmetric_gate",
        "full_api_name": "QCircuitImage._build_symmetric_gate",
        "api_description": "Add symmetric gates for cu1, cp, swap, and rzz",
        "api_signature": "_build_symmetric_gate(self, op, gate_text, wire_list, col)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/latex.py"
    },
    {
        "api_name": "_build_measure",
        "full_api_name": "QCircuitImage._build_measure",
        "api_description": "Build a meter and the lines to the creg",
        "api_signature": "_build_measure(self, node, col)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/latex.py"
    },
    {
        "api_name": "_build_barrier",
        "full_api_name": "QCircuitImage._build_barrier",
        "api_description": "Build a partial or full barrier if plot_barriers set",
        "api_signature": "_build_barrier(self, node, col)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/latex.py"
    },
    {
        "api_name": "_add_controls",
        "full_api_name": "QCircuitImage._add_controls",
        "api_description": "Add one or more controls to a gate",
        "api_signature": "_add_controls(self, wire_list, ctrlqargs, ctrl_state, col)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/latex.py"
    },
    {
        "api_name": "_add_condition",
        "full_api_name": "QCircuitImage._add_condition",
        "api_description": "Add a condition to the _latex list",
        "api_signature": "_add_condition(self, op, wire_list, col)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/latex.py"
    },
    {
        "api_name": "_truncate_float",
        "full_api_name": "QCircuitImage._truncate_float",
        "api_description": "Truncate long floats.",
        "api_signature": "_truncate_float(self, matchobj, ndigits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/latex.py"
    },
    {
        "api_name": "__setitem__",
        "full_api_name": "StyleDict.__setitem__",
        "api_description": "",
        "api_signature": "__setitem__(self, key, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/qcstyle.py"
    },
    {
        "api_name": "__getitem__",
        "full_api_name": "StyleDict.__getitem__",
        "api_description": "",
        "api_signature": "__getitem__(self, key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/qcstyle.py"
    },
    {
        "api_name": "update",
        "full_api_name": "StyleDict.update",
        "api_description": "",
        "api_signature": "update(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/qcstyle.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "DefaultStyle.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/qcstyle.py"
    },
    {
        "api_name": "load_style",
        "full_api_name": "load_style",
        "api_description": "Utility function to load style from json files.\n\nArgs:\n    style: Depending on the type, this acts differently:\n\n        * If a string, it can specify a supported style name (such\n          as \"iqp\" or \"clifford\"). It can also specify the name of\n          a custom color scheme stored as JSON file. This JSON file\n          _must_ specify a complete set of colors.\n        * If a dictionary, it may specify the style name via a\n          ``{\"name\": \"<desired style>\"}`` entry. If this is not given,\n          the default style will be used. The remaining entries in the\n          dictionary can be used to override certain specs.\n          E.g. ``{\"name\": \"iqp\", \"ec\": \"#FF0000\"}`` will use the ``\"iqp\"``\n          color scheme but set the edgecolor to red.\n\nReturns:\n    A tuple containing the style as dictionary and the default font ratio.",
        "api_signature": "load_style(style)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/qcstyle.py"
    },
    {
        "api_name": "_is_boolean_expression",
        "full_api_name": "_is_boolean_expression",
        "api_description": "",
        "api_signature": "_is_boolean_expression(gate_text, op)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/_utils.py"
    },
    {
        "api_name": "get_gate_ctrl_text",
        "full_api_name": "get_gate_ctrl_text",
        "api_description": "Load the gate_text and ctrl_text strings based on names and labels",
        "api_signature": "get_gate_ctrl_text(op, drawer, style, calibrations)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/_utils.py"
    },
    {
        "api_name": "get_param_str",
        "full_api_name": "get_param_str",
        "api_description": "Get the params as a string to add to the gate text display",
        "api_signature": "get_param_str(op, drawer, ndigits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/_utils.py"
    },
    {
        "api_name": "get_wire_map",
        "full_api_name": "get_wire_map",
        "api_description": "Map the bits and registers to the index from the top of the drawing.\nThe key to the dict is either the (Qubit, Clbit) or if cregbundle True,\nthe register that is being bundled.\n\nArgs:\n    circuit (QuantumCircuit): the circuit being drawn\n    bits (list(Qubit, Clbit)): the Qubit's and Clbit's in the circuit\n    cregbundle (bool): if True bundle classical registers. Default: ``True``.\n\nReturns:\n    dict((Qubit, Clbit, ClassicalRegister): index): map of bits/registers\n        to index",
        "api_signature": "get_wire_map(circuit, bits, cregbundle)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/_utils.py"
    },
    {
        "api_name": "get_bit_register",
        "full_api_name": "get_bit_register",
        "api_description": "Get the register for a bit if there is one\n\nArgs:\n    circuit (QuantumCircuit): the circuit being drawn\n    bit (Qubit, Clbit): the bit to use to find the register and indexes\n\nReturns:\n    ClassicalRegister: register associated with the bit",
        "api_signature": "get_bit_register(circuit, bit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/_utils.py"
    },
    {
        "api_name": "get_bit_reg_index",
        "full_api_name": "get_bit_reg_index",
        "api_description": "Get the register for a bit if there is one, and the index of the bit\nfrom the top of the circuit, or the index of the bit within a register.\n\nArgs:\n    circuit (QuantumCircuit): the circuit being drawn\n    bit (Qubit, Clbit): the bit to use to find the register and indexes\n\nReturns:\n    (ClassicalRegister, None): register associated with the bit\n    int: index of the bit from the top of the circuit\n    int: index of the bit within the register, if there is a register",
        "api_signature": "get_bit_reg_index(circuit, bit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/_utils.py"
    },
    {
        "api_name": "get_wire_label",
        "full_api_name": "get_wire_label",
        "api_description": "Get the bit labels to display to the left of the wires.\n\nArgs:\n    drawer (str): which drawer is calling (\"text\", \"mpl\", or \"latex\")\n    register (QuantumRegister or ClassicalRegister): get wire_label for this register\n    index (int): index of bit in register\n    layout (Layout): Optional. mapping of virtual to physical bits\n    cregbundle (bool): Optional. if set True bundle classical registers.\n        Default: ``True``.\n\nReturns:\n    str: label to display for the register/index",
        "api_signature": "get_wire_label(drawer, register, index, layout, cregbundle)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/_utils.py"
    },
    {
        "api_name": "get_condition_label_val",
        "full_api_name": "get_condition_label_val",
        "api_description": "Get the label and value list to display a condition\n\nArgs:\n    condition (Union[Clbit, ClassicalRegister], int): classical condition\n    circuit (QuantumCircuit): the circuit that is being drawn\n    cregbundle (bool): if set True bundle classical registers\n\nReturns:\n    str: label to display for the condition\n    list(str): list of 1's and 0's indicating values of condition",
        "api_signature": "get_condition_label_val(condition, circuit, cregbundle)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/_utils.py"
    },
    {
        "api_name": "fix_special_characters",
        "full_api_name": "fix_special_characters",
        "api_description": "Convert any special characters for mpl and latex drawers.\nCurrently only checks for multiple underscores in register names\nand uses wider space for mpl and latex drawers.\n\nArgs:\n    label (str): the label to fix\n\nReturns:\n    str: label to display",
        "api_signature": "fix_special_characters(label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/_utils.py"
    },
    {
        "api_name": "generate_latex_label",
        "full_api_name": "generate_latex_label",
        "api_description": "Convert a label to a valid latex string.",
        "api_signature": "generate_latex_label(label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/_utils.py"
    },
    {
        "api_name": "_get_valid_justify_arg",
        "full_api_name": "_get_valid_justify_arg",
        "api_description": "Returns a valid `justify` argument, warning if necessary.",
        "api_signature": "_get_valid_justify_arg(justify)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/_utils.py"
    },
    {
        "api_name": "_get_layered_instructions",
        "full_api_name": "_get_layered_instructions",
        "api_description": "Given a circuit, return a tuple (qubits, clbits, nodes) where\nqubits and clbits are the quantum and classical registers\nin order (based on reverse_bits or wire_order) and nodes\nis a list of DAGOpNodes.\n\nArgs:\n    circuit (QuantumCircuit): From where the information is extracted.\n    reverse_bits (bool): If true the order of the bits in the registers is\n        reversed.\n    justify (str) : `left`, `right` or `none`. Defaults to `left`. Says how\n        the circuit should be justified. If an invalid value is provided,\n        default `left` will be used.\n    idle_wires (bool): Include idle wires. Default is True.\n    wire_order (list): A list of ints that modifies the order of the bits.\n\nReturns:\n    Tuple(list,list,list): To be consumed by the visualizer directly.\n\nRaises:\n    VisualizationError: if both reverse_bits and wire_order are entered.",
        "api_signature": "_get_layered_instructions(circuit, reverse_bits, justify, idle_wires, wire_order, wire_map)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/_utils.py"
    },
    {
        "api_name": "_sorted_nodes",
        "full_api_name": "_sorted_nodes",
        "api_description": "Convert DAG layer into list of nodes sorted by node_id\nqiskit-terra #2802",
        "api_signature": "_sorted_nodes(dag_layer)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/_utils.py"
    },
    {
        "api_name": "_get_gate_span",
        "full_api_name": "_get_gate_span",
        "api_description": "Get the list of qubits drawing this gate would cover\nqiskit-terra #2802",
        "api_signature": "_get_gate_span(qubits, node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/_utils.py"
    },
    {
        "api_name": "_any_crossover",
        "full_api_name": "_any_crossover",
        "api_description": "Return True .IFF. 'node' crosses over any 'nodes'.",
        "api_signature": "_any_crossover(qubits, node, nodes)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/_utils.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "_LayerSpooler.__init__",
        "api_description": "Create spool",
        "api_signature": "__init__(self, dag, justification, measure_map)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/_utils.py"
    },
    {
        "api_name": "is_found_in",
        "full_api_name": "_LayerSpooler.is_found_in",
        "api_description": "Is any qreq in node found in any of nodes?",
        "api_signature": "is_found_in(self, node, nodes)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/_utils.py"
    },
    {
        "api_name": "insertable",
        "full_api_name": "_LayerSpooler.insertable",
        "api_description": "True .IFF. we can add 'node' to layer 'nodes'",
        "api_signature": "insertable(self, node, nodes)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/_utils.py"
    },
    {
        "api_name": "slide_from_left",
        "full_api_name": "_LayerSpooler.slide_from_left",
        "api_description": "Insert node into first layer where there is no conflict going l > r",
        "api_signature": "slide_from_left(self, node, index)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/_utils.py"
    },
    {
        "api_name": "slide_from_right",
        "full_api_name": "_LayerSpooler.slide_from_right",
        "api_description": "Insert node into rightmost layer as long there is no conflict.",
        "api_signature": "slide_from_right(self, node, index)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/_utils.py"
    },
    {
        "api_name": "add",
        "full_api_name": "_LayerSpooler.add",
        "api_description": "Add 'node' where it belongs, starting the try at 'index'.",
        "api_signature": "add(self, node, index)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/_utils.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "DrawElement.__init__",
        "api_description": "",
        "api_signature": "__init__(self, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "top",
        "full_api_name": "DrawElement.top",
        "api_description": "Constructs the top line of the element",
        "api_signature": "top(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "mid",
        "full_api_name": "DrawElement.mid",
        "api_description": "Constructs the middle line of the element",
        "api_signature": "mid(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "bot",
        "full_api_name": "DrawElement.bot",
        "api_description": "Constructs the bottom line of the element",
        "api_signature": "bot(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "length",
        "full_api_name": "DrawElement.length",
        "api_description": "Returns the length of the element, including the box around.",
        "api_signature": "length(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "width",
        "full_api_name": "DrawElement.width",
        "api_description": "Returns the width of the label, including padding",
        "api_signature": "width(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "width",
        "full_api_name": "DrawElement.width",
        "api_description": "",
        "api_signature": "width(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "connect",
        "full_api_name": "DrawElement.connect",
        "api_description": "Connects boxes and elements using wire_char and setting proper connectors.\n\nArgs:\n    wire_char (char): For example '\u2551' or '\u2502'.\n    where (list[\"top\", \"bot\"]): Where the connector should be set.\n    label (string): Some connectors have a label (see cu1, for example).",
        "api_signature": "connect(self, wire_char, where, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BoxOnClWire.__init__",
        "api_description": "",
        "api_signature": "__init__(self, label, top_connect, bot_connect)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BoxOnQuWire.__init__",
        "api_description": "",
        "api_signature": "__init__(self, label, top_connect, conditional)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "MeasureTo.__init__",
        "api_description": "",
        "api_signature": "__init__(self, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "MeasureFrom.__init__",
        "api_description": "",
        "api_signature": "__init__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "center_label",
        "full_api_name": "MultiBox.center_label",
        "api_description": "In multi-bit elements, the label is centered vertically.\n\nArgs:\n    input_length (int): Rhe amount of wires affected.\n    order (int): Which middle element is this one?",
        "api_signature": "center_label(self, input_length, order)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "width",
        "full_api_name": "MultiBox.width",
        "api_description": "Returns the width of the label, including padding",
        "api_signature": "width(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BoxOnQuWireTop.__init__",
        "api_description": "",
        "api_signature": "__init__(self, label, top_connect, wire_label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BoxOnWireMid.__init__",
        "api_description": "",
        "api_signature": "__init__(self, label, input_length, order, wire_label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BoxOnQuWireMid.__init__",
        "api_description": "",
        "api_signature": "__init__(self, label, input_length, order, wire_label, control_label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BoxOnQuWireBot.__init__",
        "api_description": "",
        "api_signature": "__init__(self, label, input_length, bot_connect, wire_label, conditional)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "FlowOnQuWire.__init__",
        "api_description": "",
        "api_signature": "__init__(self, section, label, top_connect, conditional)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "FlowOnQuWireTop.__init__",
        "api_description": "",
        "api_signature": "__init__(self, section, label, top_connect, wire_label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "FlowOnQuWireMid.__init__",
        "api_description": "",
        "api_signature": "__init__(self, section, label, input_length, order, wire_label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "FlowOnQuWireBot.__init__",
        "api_description": "",
        "api_signature": "__init__(self, section, label, input_length, bot_connect, wire_label, conditional)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BoxOnClWireTop.__init__",
        "api_description": "",
        "api_signature": "__init__(self, label, top_connect, wire_label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BoxOnClWireMid.__init__",
        "api_description": "",
        "api_signature": "__init__(self, label, input_length, order, wire_label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BoxOnClWireBot.__init__",
        "api_description": "",
        "api_signature": "__init__(self, label, input_length, bot_connect, wire_label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "DirectOnQuWire.__init__",
        "api_description": "",
        "api_signature": "__init__(self, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Barrier.__init__",
        "api_description": "",
        "api_signature": "__init__(self, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Ex.__init__",
        "api_description": "",
        "api_signature": "__init__(self, bot_connect, top_connect, conditional)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ResetDisplay.__init__",
        "api_description": "",
        "api_signature": "__init__(self, conditional)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Bullet.__init__",
        "api_description": "",
        "api_signature": "__init__(self, top_connect, bot_connect, conditional, label, bottom)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "OpenBullet.__init__",
        "api_description": "",
        "api_signature": "__init__(self, top_connect, bot_connect, conditional, label, bottom)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "DirectOnClWire.__init__",
        "api_description": "",
        "api_signature": "__init__(self, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ClBullet.__init__",
        "api_description": "",
        "api_signature": "__init__(self, top_connect, bot_connect, conditional, label, bottom)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ClOpenBullet.__init__",
        "api_description": "",
        "api_signature": "__init__(self, top_connect, bot_connect, conditional, label, bottom)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "EmptyWire.__init__",
        "api_description": "",
        "api_signature": "__init__(self, wire)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "fillup_layer",
        "full_api_name": "EmptyWire.fillup_layer",
        "api_description": "Given a layer, replace the Nones in it with EmptyWire elements.\n\nArgs:\n    layer (list): The layer that contains Nones.\n    first_clbit (int): The first wire that is classic.\n\nReturns:\n    list: The new layer, with no Nones.",
        "api_signature": "fillup_layer(layer, first_clbit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BreakWire.__init__",
        "api_description": "",
        "api_signature": "__init__(self, arrow_char)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "fillup_layer",
        "full_api_name": "BreakWire.fillup_layer",
        "api_description": "Creates a layer with BreakWire elements.\n\nArgs:\n    layer_length (int): The length of the layer to create\n    arrow_char (char): The char used to create the BreakWire element.\n\nReturns:\n    list: The new layer.",
        "api_signature": "fillup_layer(layer_length, arrow_char)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "InputWire.__init__",
        "api_description": "",
        "api_signature": "__init__(self, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "fillup_layer",
        "full_api_name": "InputWire.fillup_layer",
        "api_description": "Creates a layer with InputWire elements.\n\nArgs:\n    names (list): List of names for the wires.\n\nReturns:\n    list: The new layer",
        "api_signature": "fillup_layer(names)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "TextDrawing.__init__",
        "api_description": "",
        "api_signature": "__init__(self, qubits, clbits, nodes, circuit, reverse_bits, plotbarriers, line_length, vertical_compression, initial_state, cregbundle, encoding, with_layout, expr_len)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "TextDrawing.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "_repr_html_",
        "full_api_name": "TextDrawing._repr_html_",
        "api_description": "",
        "api_signature": "_repr_html_(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "TextDrawing.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "single_string",
        "full_api_name": "TextDrawing.single_string",
        "api_description": "Creates a long string with the ascii art.\nReturns:\n    str: The lines joined by a newline (``\\n``)",
        "api_signature": "single_string(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "dump",
        "full_api_name": "TextDrawing.dump",
        "api_description": "Dumps the ascii art in the file.\n\nArgs:\n    filename (str): File to dump the ascii art.\n    encoding (str): Optional. Force encoding, instead of self.encoding.",
        "api_signature": "dump(self, filename, encoding)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "lines",
        "full_api_name": "TextDrawing.lines",
        "api_description": "Generates a list with lines. These lines form the text drawing.\n\nArgs:\n    line_length (int): Optional. Breaks the circuit drawing to this length. This is\n                       useful when the drawing does not fit in the console. If\n                       None (default), it will try to guess the console width using\n                       shutil.get_terminal_size(). If you don't want pagination\n                       at all, set line_length=-1.\n\nReturns:\n    list: A list of lines with the text drawing.",
        "api_signature": "lines(self, line_length)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "wire_names",
        "full_api_name": "TextDrawing.wire_names",
        "api_description": "Returns a list of names for each wire.\n\nArgs:\n    with_initial_state (bool): Optional (Default: False). If true, adds\n        the initial value to the name.\n\nReturns:\n    List: The list of wire names.",
        "api_signature": "wire_names(self, with_initial_state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "should_compress",
        "full_api_name": "TextDrawing.should_compress",
        "api_description": "Decides if the top_line and bot_line should be merged,\nbased on `self.vertical_compression`.",
        "api_signature": "should_compress(self, top_line, bot_line)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "draw_wires",
        "full_api_name": "TextDrawing.draw_wires",
        "api_description": "Given a list of wires, creates a list of lines with the text drawing.\n\nArgs:\n    wires (list): A list of wires with nodes.\nReturns:\n    list: A list of lines with the text drawing.",
        "api_signature": "draw_wires(self, wires)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "special_label",
        "full_api_name": "TextDrawing.special_label",
        "api_description": "Some instructions have special labels",
        "api_signature": "special_label(node)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "merge_lines",
        "full_api_name": "TextDrawing.merge_lines",
        "api_description": "Merges two lines (top and bot) in a way that the overlapping makes sense.\n\nArgs:\n    top (str): the top line\n    bot (str): the bottom line\n    icod (top or bot): in case of doubt, which line should have priority? Default: \"top\".\nReturns:\n    str: The merge of both lines.",
        "api_signature": "merge_lines(top, bot, icod)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "normalize_width",
        "full_api_name": "TextDrawing.normalize_width",
        "api_description": "When the elements of the layer have different widths, sets the width to the max elements.\n\nArgs:\n    layer (list): A list of elements.",
        "api_signature": "normalize_width(layer)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "controlled_wires",
        "full_api_name": "TextDrawing.controlled_wires",
        "api_description": "Analyzes the node in the layer and checks if the controlled arguments are in\nthe box or out of the box.\n\nArgs:\n    node (DAGNode): node to analyse\n    wire_map (dict): map of qubits/clbits to position\n    ctrl_text (str): text for a control label\n    conditional (bool): is this a node with a condition\n    mod_control (ControlModifier): an instance of a modifier for an\n        AnnotatedOperation\n\nReturns:\n    Tuple(list, list, list):\n      - tuple: controlled arguments on top of the \"node box\", and its status\n      - tuple: controlled arguments on bottom of the \"node box\", and its status\n      - tuple: controlled arguments in the \"node box\", and its status\n      - the rest of the arguments",
        "api_signature": "controlled_wires(node, wire_map, ctrl_text, conditional, mod_control)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "_node_to_gate",
        "full_api_name": "TextDrawing._node_to_gate",
        "api_description": "Convert a dag op node into its corresponding Gate object, and establish\nany connections it introduces between qubits. gate_wire_map is the flow_wire_map\nif gate is inside a ControlFlowOp, else it's self._wire_map",
        "api_signature": "_node_to_gate(self, node, layer, gate_wire_map)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "add_connected_gate",
        "full_api_name": "TextDrawing.add_connected_gate",
        "api_description": "",
        "api_signature": "add_connected_gate(node, gates, layer, current_cons, gate_wire_map)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "build_layers",
        "full_api_name": "TextDrawing.build_layers",
        "api_description": "Constructs layers.\nReturns:\n    list: List of DrawElements.\nRaises:\n    VisualizationError: When the drawing is, for some reason, impossible to be drawn.",
        "api_signature": "build_layers(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "add_control_flow",
        "full_api_name": "TextDrawing.add_control_flow",
        "api_description": "Add control flow ops to the circuit drawing.",
        "api_signature": "add_control_flow(self, node, layers, wire_map)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "lookup_var",
        "full_api_name": "TextDrawing.lookup_var",
        "api_description": "Look up a classical-expression variable or register/bit in our internal symbol\ntable, and return an OQ3-like identifier.",
        "api_signature": "lookup_var(var)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "draw_flow_box",
        "full_api_name": "TextDrawing.draw_flow_box",
        "api_description": "Draw the left, middle, or right of a control flow box",
        "api_signature": "draw_flow_box(self, node, flow_wire_map, section, circ_num, conditional)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Layer.__init__",
        "api_description": "",
        "api_signature": "__init__(self, qubits, clbits, cregbundle, circuit, wire_map)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "full_layer",
        "full_api_name": "Layer.full_layer",
        "api_description": "Returns the composition of qubits and classic wires.\nReturns:\n    String: self.qubit_layer + self.clbit_layer",
        "api_signature": "full_layer(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "set_qubit",
        "full_api_name": "Layer.set_qubit",
        "api_description": "Sets the qubit to the element.\n\nArgs:\n    qubit (qbit): Element of self.qubits.\n    element (DrawElement): Element to set in the qubit",
        "api_signature": "set_qubit(self, qubit, element)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "set_clbit",
        "full_api_name": "Layer.set_clbit",
        "api_description": "Sets the clbit to the element.\n\nArgs:\n    clbit (cbit): Element of self.clbits.\n    element (DrawElement): Element to set in the clbit",
        "api_signature": "set_clbit(self, clbit, element)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "_set_multibox",
        "full_api_name": "Layer._set_multibox",
        "api_description": "",
        "api_signature": "_set_multibox(self, label, qargs, cargs, top_connect, bot_connect, conditional, controlled_edge)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "set_cl_multibox",
        "full_api_name": "Layer.set_cl_multibox",
        "api_description": "Sets the multi clbit box.\n\nArgs:\n    condition (list[Union(Clbit, ClassicalRegister), int]): The condition\n    wire_map (dict): Map of bits to indices\n    top_connect (char): The char to connect the box on the top.\n\nReturns:\n    List: list of tuples of connections between clbits for multi-bit conditions",
        "api_signature": "set_cl_multibox(self, condition, wire_map, top_connect)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "set_cond_bullets",
        "full_api_name": "Layer.set_cond_bullets",
        "api_description": "Sets bullets for classical conditioning when cregbundle=False.\n\nArgs:\n    label (str): String to display below the condition\n    val_bits (list(int)): A list of bit values\n    clbits (list[Clbit]): The list of classical bits on\n        which the instruction is conditioned.\n    wire_map (dict): Map of bits to indices\n\nReturns:\n    List: list of tuples of open or closed bullets for condition bits",
        "api_signature": "set_cond_bullets(self, label, val_bits, clbits, wire_map)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "set_qu_multibox",
        "full_api_name": "Layer.set_qu_multibox",
        "api_description": "Sets the multi qubit box.\n\nArgs:\n    bits (list[int]): A list of affected bits.\n    label (string): The label for the multi qubit box.\n    top_connect (char): None or a char connector on the top\n    bot_connect (char): None or a char connector on the bottom\n    conditional (bool): If the box has a conditional\n    controlled_edge (list): A list of bit that are controlled (to draw them at the edge)\nReturn:\n    List: A list of indexes of the box.",
        "api_signature": "set_qu_multibox(self, bits, label, top_connect, bot_connect, conditional, controlled_edge)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "connect_with",
        "full_api_name": "Layer.connect_with",
        "api_description": "Connects the elements in the layer using wire_char.\n\nArgs:\n    wire_char (char): For example '\u2551' or '\u2502'.",
        "api_signature": "connect_with(self, wire_char)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/visualization/circuit/text.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Quaternion.__init__",
        "api_description": "",
        "api_signature": "__init__(self, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/quaternion.py"
    },
    {
        "api_name": "__call__",
        "full_api_name": "Quaternion.__call__",
        "api_description": "",
        "api_signature": "__call__(self, idx)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/quaternion.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "Quaternion.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/quaternion.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "Quaternion.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/quaternion.py"
    },
    {
        "api_name": "__mul__",
        "full_api_name": "Quaternion.__mul__",
        "api_description": "",
        "api_signature": "__mul__(self, r)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/quaternion.py"
    },
    {
        "api_name": "norm",
        "full_api_name": "Quaternion.norm",
        "api_description": "Norm of quaternion.",
        "api_signature": "norm(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/quaternion.py"
    },
    {
        "api_name": "normalize",
        "full_api_name": "Quaternion.normalize",
        "api_description": "Normalizes a Quaternion to unit length\nso that it represents a valid rotation.\n\nArgs:\n    inplace (bool): Do an inplace normalization.\n\nReturns:\n    Quaternion: Normalized quaternion.",
        "api_signature": "normalize(self, inplace)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/quaternion.py"
    },
    {
        "api_name": "to_matrix",
        "full_api_name": "Quaternion.to_matrix",
        "api_description": "Converts a unit-length quaternion to a rotation matrix.\n\nReturns:\n    ndarray: Rotation matrix.",
        "api_signature": "to_matrix(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/quaternion.py"
    },
    {
        "api_name": "to_zyz",
        "full_api_name": "Quaternion.to_zyz",
        "api_description": "Converts a unit-length quaternion to a sequence\nof ZYZ Euler angles.\n\nReturns:\n    ndarray: Array of Euler angles.",
        "api_signature": "to_zyz(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/quaternion.py"
    },
    {
        "api_name": "from_axis_rotation",
        "full_api_name": "Quaternion.from_axis_rotation",
        "api_description": "Return quaternion for rotation about given axis.\n\nArgs:\n    angle (float): Angle in radians.\n    axis (str): Axis for rotation\n\nReturns:\n    Quaternion: Quaternion for axis rotation.\n\nRaises:\n    ValueError: Invalid input axis.",
        "api_signature": "from_axis_rotation(cls, angle, axis)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/quaternion.py"
    },
    {
        "api_name": "from_euler",
        "full_api_name": "Quaternion.from_euler",
        "api_description": "Generate a quaternion from a set of Euler angles.\n\nArgs:\n    angles (array_like): Array of Euler angles.\n    order (str): Order of Euler rotations.  'yzy' is default.\n\nReturns:\n    Quaternion: Quaternion representation of Euler rotation.",
        "api_signature": "from_euler(cls, angles, order)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/quaternion.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "StabilizerState.__init__",
        "api_description": "Initialize a StabilizerState object.\n\nArgs:\n    data (StabilizerState or Clifford or Pauli or QuantumCircuit or\n          qiskit.circuit.Instruction):\n        Data from which the stabilizer state can be constructed.\n    validate (boolean): validate that the stabilizer state data is\n        a valid Clifford.",
        "api_signature": "__init__(self, data, validate)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/stabilizerstate.py"
    },
    {
        "api_name": "from_stabilizer_list",
        "full_api_name": "StabilizerState.from_stabilizer_list",
        "api_description": "Create a stabilizer state from the collection of stabilizers.\n\nArgs:\n    stabilizers (Collection[str]): list of stabilizer strings\n    allow_redundant (bool): allow redundant stabilizers (i.e., some stabilizers\n        can be products of the others)\n    allow_underconstrained (bool): allow underconstrained set of stabilizers (i.e.,\n        the stabilizers do not specify a unique state)\n\nReturn:\n    StabilizerState: a state stabilized by stabilizers.",
        "api_signature": "from_stabilizer_list(cls, stabilizers, allow_redundant, allow_underconstrained)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/stabilizerstate.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "StabilizerState.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/stabilizerstate.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "StabilizerState.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/stabilizerstate.py"
    },
    {
        "api_name": "clifford",
        "full_api_name": "StabilizerState.clifford",
        "api_description": "Return StabilizerState Clifford data",
        "api_signature": "clifford(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/stabilizerstate.py"
    },
    {
        "api_name": "is_valid",
        "full_api_name": "StabilizerState.is_valid",
        "api_description": "Return True if a valid StabilizerState.",
        "api_signature": "is_valid(self, atol, rtol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/stabilizerstate.py"
    },
    {
        "api_name": "_add",
        "full_api_name": "StabilizerState._add",
        "api_description": "",
        "api_signature": "_add(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/stabilizerstate.py"
    },
    {
        "api_name": "_multiply",
        "full_api_name": "StabilizerState._multiply",
        "api_description": "",
        "api_signature": "_multiply(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/stabilizerstate.py"
    },
    {
        "api_name": "trace",
        "full_api_name": "StabilizerState.trace",
        "api_description": "Return the trace of the stabilizer state as a density matrix,\nwhich equals to 1, since it is always a pure state.\n\nReturns:\n    float: the trace (should equal 1).\n\nRaises:\n    QiskitError: if input is not a StabilizerState.",
        "api_signature": "trace(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/stabilizerstate.py"
    },
    {
        "api_name": "purity",
        "full_api_name": "StabilizerState.purity",
        "api_description": "Return the purity of the quantum state,\nwhich equals to 1, since it is always a pure state.\n\nReturns:\n    float: the purity (should equal 1).\n\nRaises:\n    QiskitError: if input is not a StabilizerState.",
        "api_signature": "purity(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/stabilizerstate.py"
    },
    {
        "api_name": "to_operator",
        "full_api_name": "StabilizerState.to_operator",
        "api_description": "Convert state to matrix operator class",
        "api_signature": "to_operator(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/stabilizerstate.py"
    },
    {
        "api_name": "conjugate",
        "full_api_name": "StabilizerState.conjugate",
        "api_description": "Return the conjugate of the operator.",
        "api_signature": "conjugate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/stabilizerstate.py"
    },
    {
        "api_name": "tensor",
        "full_api_name": "StabilizerState.tensor",
        "api_description": "Return the tensor product stabilizer state self \u2297 other.\n\nArgs:\n    other (StabilizerState): a stabilizer state object.\n\nReturns:\n    StabilizerState: the tensor product operator self \u2297 other.\n\nRaises:\n    QiskitError: if other is not a StabilizerState.",
        "api_signature": "tensor(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/stabilizerstate.py"
    },
    {
        "api_name": "expand",
        "full_api_name": "StabilizerState.expand",
        "api_description": "Return the tensor product stabilizer state other \u2297 self.\n\nArgs:\n    other (StabilizerState): a stabilizer state object.\n\nReturns:\n    StabilizerState: the tensor product operator other \u2297 self.\n\nRaises:\n    QiskitError: if other is not a StabilizerState.",
        "api_signature": "expand(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/stabilizerstate.py"
    },
    {
        "api_name": "evolve",
        "full_api_name": "StabilizerState.evolve",
        "api_description": "Evolve a stabilizer state by a Clifford operator.\n\nArgs:\n    other (Clifford or QuantumCircuit or qiskit.circuit.Instruction):\n        The Clifford operator to evolve by.\n    qargs (list): a list of stabilizer subsystem positions to apply the operator on.\n\nReturns:\n    StabilizerState: the output stabilizer state.\n\nRaises:\n    QiskitError: if other is not a StabilizerState.\n    QiskitError: if the operator dimension does not match the\n                 specified StabilizerState subsystem dimensions.",
        "api_signature": "evolve(self, other, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/stabilizerstate.py"
    },
    {
        "api_name": "expectation_value",
        "full_api_name": "StabilizerState.expectation_value",
        "api_description": "Compute the expectation value of a Pauli operator.\n\nArgs:\n    oper (Pauli): a Pauli operator to evaluate expval.\n    qargs (None or list): subsystems to apply the operator on.\n\nReturns:\n    complex: the expectation value (only 0 or 1 or -1 or i or -i).\n\nRaises:\n    QiskitError: if oper is not a Pauli operator.",
        "api_signature": "expectation_value(self, oper, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/stabilizerstate.py"
    },
    {
        "api_name": "equiv",
        "full_api_name": "StabilizerState.equiv",
        "api_description": "Return True if the two generating sets generate the same stabilizer group.\n\nArgs:\n    other (StabilizerState): another StabilizerState.\n\nReturns:\n    bool: True if other has a generating set that generates the same StabilizerState.",
        "api_signature": "equiv(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/stabilizerstate.py"
    },
    {
        "api_name": "probabilities",
        "full_api_name": "StabilizerState.probabilities",
        "api_description": "Return the subsystem measurement probability vector.\n\nMeasurement probabilities are with respect to measurement in the\ncomputation (diagonal) basis.\n\nArgs:\n    qargs (None or list): subsystems to return probabilities for,\n        if None return for all subsystems (Default: None).\n    decimals (None or int): the number of decimal places to round\n        values. If None no rounding is done (Default: None).\n\nReturns:\n    np.array: The Numpy vector array of probabilities.",
        "api_signature": "probabilities(self, qargs, decimals)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/stabilizerstate.py"
    },
    {
        "api_name": "probabilities_dict_from_bitstring",
        "full_api_name": "StabilizerState.probabilities_dict_from_bitstring",
        "api_description": "Return the subsystem measurement probability dictionary utilizing\na targeted outcome_bitstring to perform the measurement for. This\nwill calculate a probability for only a single targeted\noutcome_bitstring value, giving a performance boost over calculating\nall possible outcomes.\n\nMeasurement probabilities are with respect to measurement in the\ncomputation (diagonal) basis.\n\nThis dictionary representation uses a Ket-like notation where the\ndictionary keys are qudit strings for the subsystem basis vectors.\nIf any subsystem has a dimension greater than 10 comma delimiters are\ninserted between integers so that subsystems can be distinguished.\n\nArgs:\n    outcome_bitstring (None or str): targeted outcome bitstring\n        to perform a measurement calculation for, this will significantly\n        reduce the number of calculation performed (Default: None)\n    qargs (None or list): subsystems to return probabilities for,\n            if None return for all subsystems (Default: None).\n    decimals (None or int): the number of decimal places to round\n            values. If None no rounding is done (Default: None)\n\nReturns:\n    dict[str, float]: The measurement probabilities in dict (ket) form.",
        "api_signature": "probabilities_dict_from_bitstring(self, outcome_bitstring, qargs, decimals)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/stabilizerstate.py"
    },
    {
        "api_name": "probabilities_dict",
        "full_api_name": "StabilizerState.probabilities_dict",
        "api_description": "Return the subsystem measurement probability dictionary.\n\nMeasurement probabilities are with respect to measurement in the\ncomputation (diagonal) basis.\n\nThis dictionary representation uses a Ket-like notation where the\ndictionary keys are qudit strings for the subsystem basis vectors.\nIf any subsystem has a dimension greater than 10 comma delimiters are\ninserted between integers so that subsystems can be distinguished.\n\nArgs:\n    qargs (None or list): subsystems to return probabilities for,\n        if None return for all subsystems (Default: None).\n    decimals (None or int): the number of decimal places to round\n        values. If None no rounding is done (Default: None).\n\nReturns:\n    dict: The measurement probabilities in dict (key) form.",
        "api_signature": "probabilities_dict(self, qargs, decimals)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/stabilizerstate.py"
    },
    {
        "api_name": "reset",
        "full_api_name": "StabilizerState.reset",
        "api_description": "Reset state or subsystems to the 0-state.\n\nArgs:\n    qargs (list or None): subsystems to reset, if None all\n                          subsystems will be reset to their 0-state\n                          (Default: None).\n\nReturns:\n    StabilizerState: the reset state.\n\nAdditional Information:\n    If all subsystems are reset this will return the ground state\n    on all subsystems. If only some subsystems are reset this\n    function will perform a measurement on those subsystems and\n    evolve the subsystems so that the collapsed post-measurement\n    states are rotated to the 0-state. The RNG seed for this\n    sampling can be set using the :meth:`seed` method.",
        "api_signature": "reset(self, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/stabilizerstate.py"
    },
    {
        "api_name": "measure",
        "full_api_name": "StabilizerState.measure",
        "api_description": "Measure subsystems and return outcome and post-measure state.\n\nNote that this function uses the QuantumStates internal random\nnumber generator for sampling the measurement outcome. The RNG\nseed can be set using the :meth:`seed` method.\n\nArgs:\n    qargs (list or None): subsystems to sample measurements for,\n                          if None sample measurement of all\n                          subsystems (Default: None).\n\nReturns:\n    tuple: the pair ``(outcome, state)`` where ``outcome`` is the\n           measurement outcome string label, and ``state`` is the\n           collapsed post-measurement stabilizer state for the\n           corresponding outcome.",
        "api_signature": "measure(self, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/stabilizerstate.py"
    },
    {
        "api_name": "sample_memory",
        "full_api_name": "StabilizerState.sample_memory",
        "api_description": "Sample a list of qubit measurement outcomes in the computational basis.\n\nArgs:\n    shots (int): number of samples to generate.\n    qargs (None or list): subsystems to sample measurements for,\n                        if None sample measurement of all\n                        subsystems (Default: None).\n\nReturns:\n    np.array: list of sampled counts if the order sampled.\n\nAdditional Information:\n\n    This function implements the measurement :meth:`measure` method.\n\n    The seed for random number generator used for sampling can be\n    set to a fixed value by using the stats :meth:`seed` method.",
        "api_signature": "sample_memory(self, shots, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/stabilizerstate.py"
    },
    {
        "api_name": "_measure_and_update",
        "full_api_name": "StabilizerState._measure_and_update",
        "api_description": "Measure a single qubit and return outcome and post-measure state.\n\nNote that this function uses the QuantumStates internal random\nnumber generator for sampling the measurement outcome. The RNG\nseed can be set using the :meth:`seed` method.\n\nNote that stabilizer state measurements only have three probabilities:\n(p0, p1) = (0.5, 0.5), (1, 0), or (0, 1)\nThe random case happens if there is a row anti-commuting with Z[qubit]",
        "api_signature": "_measure_and_update(self, qubit, randbit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/stabilizerstate.py"
    },
    {
        "api_name": "_phase_exponent",
        "full_api_name": "StabilizerState._phase_exponent",
        "api_description": "Exponent g of i such that Pauli(x1,z1) * Pauli(x2,z2) = i^g Pauli(x1+x2,z1+z2)",
        "api_signature": "_phase_exponent(x1, z1, x2, z2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/stabilizerstate.py"
    },
    {
        "api_name": "_rowsum",
        "full_api_name": "StabilizerState._rowsum",
        "api_description": "Aaronson-Gottesman rowsum helper function",
        "api_signature": "_rowsum(accum_pauli, accum_phase, row_pauli, row_phase)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/stabilizerstate.py"
    },
    {
        "api_name": "_rowsum_nondeterministic",
        "full_api_name": "StabilizerState._rowsum_nondeterministic",
        "api_description": "Updating StabilizerState Clifford in the\nnon-deterministic rowsum calculation.\nrow and accum are rows in the StabilizerState Clifford.",
        "api_signature": "_rowsum_nondeterministic(clifford, accum, row)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/stabilizerstate.py"
    },
    {
        "api_name": "_rowsum_deterministic",
        "full_api_name": "StabilizerState._rowsum_deterministic",
        "api_description": "Updating an auxiliary Pauli aux_pauli in the\ndeterministic rowsum calculation.\nThe StabilizerState itself is not updated.",
        "api_signature": "_rowsum_deterministic(clifford, aux_pauli, row)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/stabilizerstate.py"
    },
    {
        "api_name": "_get_probabilities",
        "full_api_name": "StabilizerState._get_probabilities",
        "api_description": "Recursive helper function for calculating the probabilities\n\nArgs:\n    qubits (range): range of qubits\n    outcome (list[str]): outcome being built\n    outcome_prob (float): probability of the outcome\n    probs (dict[str, float]): holds the outcomes and probability results\n    outcome_bitstring (str): target outcome to measure which reduces measurements, None\n        if not targeting a specific target",
        "api_signature": "_get_probabilities(self, qubits, outcome, outcome_prob, probs, outcome_bitstring)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/stabilizerstate.py"
    },
    {
        "api_name": "_get_probabilities_dict",
        "full_api_name": "StabilizerState._get_probabilities_dict",
        "api_description": "Helper Function for calculating the subsystem measurement probability dictionary.\nWhen the targeted outcome_bitstring value is set, then only the single outcome_bitstring\nprobability will be calculated.\n\nArgs:\n    outcome_bitstring (None or str): targeted outcome bitstring\n        to perform a measurement calculation for, this will significantly\n        reduce the number of calculation performed (Default: None)\n    qargs (None or list): subsystems to return probabilities for,\n        if None return for all subsystems (Default: None).\n    decimals (None or int): the number of decimal places to round\n        values. If None no rounding is done (Default: None).\n\nReturns:\n    dict: The measurement probabilities in dict (key) form.",
        "api_signature": "_get_probabilities_dict(self, outcome_bitstring, qargs, decimals)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/stabilizerstate.py"
    },
    {
        "api_name": "partial_trace",
        "full_api_name": "partial_trace",
        "api_description": "Return reduced density matrix by tracing out part of quantum state.\n\nIf all subsystems are traced over this returns the\n:meth:`~qiskit.quantum_info.DensityMatrix.trace` of the\ninput state.\n\nArgs:\n    state (Statevector or DensityMatrix): the input state.\n    qargs (list): The subsystems to trace over.\n\nReturns:\n    DensityMatrix: The reduced density matrix.\n\nRaises:\n    QiskitError: if input state is invalid.",
        "api_signature": "partial_trace(state, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/utils.py"
    },
    {
        "api_name": "shannon_entropy",
        "full_api_name": "shannon_entropy",
        "api_description": "Compute the Shannon entropy of a probability vector.\n\nThe shannon entropy of a probability vector\n:math:`\\vec{p} = [p_0, ..., p_{n-1}]` is defined as\n\n.. math::\n\n    H(\\vec{p}) = \\sum_{i=0}^{n-1} p_i \\log_b(p_i)\n\nwhere :math:`b` is the log base and (default 2), and\n:math:`0 \\log_b(0) \\equiv 0`.\n\nArgs:\n    pvec (array_like): a probability vector.\n    base (int): the base of the logarithm [Default: 2].\n\nReturns:\n    float: The Shannon entropy H(pvec).",
        "api_signature": "shannon_entropy(pvec, base)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/utils.py"
    },
    {
        "api_name": "logfn",
        "full_api_name": "logfn",
        "api_description": "",
        "api_signature": "logfn(x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/utils.py"
    },
    {
        "api_name": "logfn",
        "full_api_name": "logfn",
        "api_description": "",
        "api_signature": "logfn(x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/utils.py"
    },
    {
        "api_name": "logfn",
        "full_api_name": "logfn",
        "api_description": "",
        "api_signature": "logfn(x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/utils.py"
    },
    {
        "api_name": "schmidt_decomposition",
        "full_api_name": "schmidt_decomposition",
        "api_description": "Return the Schmidt Decomposition of a pure quantum state.\n\nFor an arbitrary bipartite state:\n\n.. math::\n     |\\psi\\rangle_{AB} = \\sum_{i,j} c_{ij}\n                         |x_i\\rangle_A \\otimes |y_j\\rangle_B,\n\nits Schmidt Decomposition is given by the single-index sum over k:\n\n.. math::\n    |\\psi\\rangle_{AB} = \\sum_{k} \\lambda_{k}\n                        |u_k\\rangle_A \\otimes |v_k\\rangle_B\n\nwhere :math:`|u_k\\rangle_A` and :math:`|v_k\\rangle_B` are an\northonormal set of vectors in their respective spaces :math:`A` and :math:`B`,\nand the Schmidt coefficients :math:`\\lambda_k` are positive real values.\n\nArgs:\n    state (Statevector or DensityMatrix): the input state.\n    qargs (list): the list of Input state positions corresponding to subsystem :math:`B`.\n\nReturns:\n    list: list of tuples ``(s, u, v)``, where ``s`` (float) are the Schmidt coefficients\n    :math:`\\lambda_k`, and ``u`` (Statevector), ``v`` (Statevector) are the Schmidt vectors\n    :math:`|u_k\\rangle_A`, :math:`|u_k\\rangle_B`, respectively.\n\nRaises:\n    QiskitError: if Input qargs is not a list of positions of the Input state.\n    QiskitError: if Input qargs is not a proper subset of Input state.\n\n.. note::\n    In Qiskit, qubits are ordered using little-endian notation, with the least significant\n    qubits having smaller indices. For example, a four-qubit system is represented as\n    :math:`|q_3q_2q_1q_0\\rangle`. Using this convention, setting ``qargs=[0]`` will partition the\n    state as :math:`|q_3q_2q_1\\rangle_A\\otimes|q_0\\rangle_B`. Furthermore, qubits will be organized\n    in this notation regardless of the order they are passed. For instance, passing either\n    ``qargs=[1,2]`` or ``qargs=[2,1]`` will result in partitioning the state as\n    :math:`|q_3q_0\\rangle_A\\otimes|q_2q_1\\rangle_B`.",
        "api_signature": "schmidt_decomposition(state, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/utils.py"
    },
    {
        "api_name": "_format_state",
        "full_api_name": "_format_state",
        "api_description": "Format input state into class object",
        "api_signature": "_format_state(state, validate)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/utils.py"
    },
    {
        "api_name": "_funm_svd",
        "full_api_name": "_funm_svd",
        "api_description": "Apply real scalar function to singular values of a matrix.\n\nArgs:\n    matrix (array_like): (N, N) Matrix at which to evaluate the function.\n    func (callable): Callable object that evaluates a scalar function f.\n\nReturns:\n    ndarray: funm (N, N) Value of the matrix function specified by func\n             evaluated at `A`.",
        "api_signature": "_funm_svd(matrix, func)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/utils.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QuantumState.__init__",
        "api_description": "Initialize a QuantumState object.\n\nArgs:\n    op_shape (OpShape): Optional, an OpShape object for state dimensions.\n\n.. note::\n\n    If `op_shape`` is specified it will take precedence over other\n    kwargs.",
        "api_signature": "__init__(self, op_shape)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/quantum_state.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "QuantumState.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/quantum_state.py"
    },
    {
        "api_name": "dim",
        "full_api_name": "QuantumState.dim",
        "api_description": "Return total state dimension.",
        "api_signature": "dim(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/quantum_state.py"
    },
    {
        "api_name": "num_qubits",
        "full_api_name": "QuantumState.num_qubits",
        "api_description": "Return the number of qubits if a N-qubit state or None otherwise.",
        "api_signature": "num_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/quantum_state.py"
    },
    {
        "api_name": "_rng",
        "full_api_name": "QuantumState._rng",
        "api_description": "",
        "api_signature": "_rng(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/quantum_state.py"
    },
    {
        "api_name": "dims",
        "full_api_name": "QuantumState.dims",
        "api_description": "Return tuple of input dimension for specified subsystems.",
        "api_signature": "dims(self, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/quantum_state.py"
    },
    {
        "api_name": "copy",
        "full_api_name": "QuantumState.copy",
        "api_description": "Make a copy of current operator.",
        "api_signature": "copy(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/quantum_state.py"
    },
    {
        "api_name": "seed",
        "full_api_name": "QuantumState.seed",
        "api_description": "Set the seed for the quantum state RNG.",
        "api_signature": "seed(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/quantum_state.py"
    },
    {
        "api_name": "is_valid",
        "full_api_name": "QuantumState.is_valid",
        "api_description": "Return True if a valid quantum state.",
        "api_signature": "is_valid(self, atol, rtol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/quantum_state.py"
    },
    {
        "api_name": "to_operator",
        "full_api_name": "QuantumState.to_operator",
        "api_description": "Convert state to matrix operator class",
        "api_signature": "to_operator(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/quantum_state.py"
    },
    {
        "api_name": "conjugate",
        "full_api_name": "QuantumState.conjugate",
        "api_description": "Return the conjugate of the operator.",
        "api_signature": "conjugate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/quantum_state.py"
    },
    {
        "api_name": "trace",
        "full_api_name": "QuantumState.trace",
        "api_description": "Return the trace of the quantum state as a density matrix.",
        "api_signature": "trace(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/quantum_state.py"
    },
    {
        "api_name": "purity",
        "full_api_name": "QuantumState.purity",
        "api_description": "Return the purity of the quantum state.",
        "api_signature": "purity(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/quantum_state.py"
    },
    {
        "api_name": "tensor",
        "full_api_name": "QuantumState.tensor",
        "api_description": "Return the tensor product state self \u2297 other.\n\nArgs:\n    other (QuantumState): a quantum state object.\n\nReturns:\n    QuantumState: the tensor product operator self \u2297 other.\n\nRaises:\n    QiskitError: if other is not a quantum state.",
        "api_signature": "tensor(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/quantum_state.py"
    },
    {
        "api_name": "expand",
        "full_api_name": "QuantumState.expand",
        "api_description": "Return the tensor product state other \u2297 self.\n\nArgs:\n    other (QuantumState): a quantum state object.\n\nReturns:\n    QuantumState: the tensor product state other \u2297 self.\n\nRaises:\n    QiskitError: if other is not a quantum state.",
        "api_signature": "expand(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/quantum_state.py"
    },
    {
        "api_name": "_add",
        "full_api_name": "QuantumState._add",
        "api_description": "Return the linear combination self + other.\n\nArgs:\n    other (QuantumState): a state object.\n\nReturns:\n    QuantumState: the linear combination self + other.\n\nRaises:\n    NotImplementedError: if subclass does not support addition.",
        "api_signature": "_add(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/quantum_state.py"
    },
    {
        "api_name": "_multiply",
        "full_api_name": "QuantumState._multiply",
        "api_description": "Return the scalar multipled state other * self.\n\nArgs:\n    other (complex): a complex number.\n\nReturns:\n    QuantumState: the scalar multipled state other * self.\n\nRaises:\n    NotImplementedError: if subclass does not support scala\n                         multiplication.",
        "api_signature": "_multiply(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/quantum_state.py"
    },
    {
        "api_name": "evolve",
        "full_api_name": "QuantumState.evolve",
        "api_description": "Evolve a quantum state by the operator.\n\nArgs:\n    other (Operator or QuantumChannel): The operator to evolve by.\n    qargs (list): a list of QuantumState subsystem positions to apply\n                   the operator on.\n\nReturns:\n    QuantumState: the output quantum state.\n\nRaises:\n    QiskitError: if the operator dimension does not match the\n                 specified QuantumState subsystem dimensions.",
        "api_signature": "evolve(self, other, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/quantum_state.py"
    },
    {
        "api_name": "expectation_value",
        "full_api_name": "QuantumState.expectation_value",
        "api_description": "Compute the expectation value of an operator.\n\nArgs:\n    oper (BaseOperator): an operator to evaluate expval.\n    qargs (None or list): subsystems to apply the operator on.\n\nReturns:\n    complex: the expectation value.",
        "api_signature": "expectation_value(self, oper, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/quantum_state.py"
    },
    {
        "api_name": "probabilities",
        "full_api_name": "QuantumState.probabilities",
        "api_description": "Return the subsystem measurement probability vector.\n\nMeasurement probabilities are with respect to measurement in the\ncomputation (diagonal) basis.\n\nArgs:\n    qargs (None or list): subsystems to return probabilities for,\n        if None return for all subsystems (Default: None).\n    decimals (None or int): the number of decimal places to round\n        values. If None no rounding is done (Default: None).\n\nReturns:\n    np.array: The Numpy vector array of probabilities.",
        "api_signature": "probabilities(self, qargs, decimals)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/quantum_state.py"
    },
    {
        "api_name": "probabilities_dict",
        "full_api_name": "QuantumState.probabilities_dict",
        "api_description": "Return the subsystem measurement probability dictionary.\n\nMeasurement probabilities are with respect to measurement in the\ncomputation (diagonal) basis.\n\nThis dictionary representation uses a Ket-like notation where the\ndictionary keys are qudit strings for the subsystem basis vectors.\nIf any subsystem has a dimension greater than 10 comma delimiters are\ninserted between integers so that subsystems can be distinguished.\n\nArgs:\n    qargs (None or list): subsystems to return probabilities for,\n        if None return for all subsystems (Default: None).\n    decimals (None or int): the number of decimal places to round\n        values. If None no rounding is done (Default: None).\n\nReturns:\n    dict: The measurement probabilities in dict (ket) form.",
        "api_signature": "probabilities_dict(self, qargs, decimals)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/quantum_state.py"
    },
    {
        "api_name": "sample_memory",
        "full_api_name": "QuantumState.sample_memory",
        "api_description": "Sample a list of qubit measurement outcomes in the computational basis.\n\nArgs:\n    shots (int): number of samples to generate.\n    qargs (None or list): subsystems to sample measurements for,\n                        if None sample measurement of all\n                        subsystems (Default: None).\n\nReturns:\n    np.array: list of sampled counts if the order sampled.\n\nAdditional Information:\n\n    This function *samples* measurement outcomes using the measure\n    :meth:`probabilities` for the current state and `qargs`. It does\n    not actually implement the measurement so the current state is\n    not modified.\n\n    The seed for random number generator used for sampling can be\n    set to a fixed value by using the stats :meth:`seed` method.",
        "api_signature": "sample_memory(self, shots, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/quantum_state.py"
    },
    {
        "api_name": "sample_counts",
        "full_api_name": "QuantumState.sample_counts",
        "api_description": "Sample a dict of qubit measurement outcomes in the computational basis.\n\nArgs:\n    shots (int): number of samples to generate.\n    qargs (None or list): subsystems to sample measurements for,\n                        if None sample measurement of all\n                        subsystems (Default: None).\n\nReturns:\n    Counts: sampled counts dictionary.\n\nAdditional Information:\n\n    This function *samples* measurement outcomes using the measure\n    :meth:`probabilities` for the current state and `qargs`. It does\n    not actually implement the measurement so the current state is\n    not modified.\n\n    The seed for random number generator used for sampling can be\n    set to a fixed value by using the stats :meth:`seed` method.",
        "api_signature": "sample_counts(self, shots, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/quantum_state.py"
    },
    {
        "api_name": "measure",
        "full_api_name": "QuantumState.measure",
        "api_description": "Measure subsystems and return outcome and post-measure state.\n\nNote that this function uses the QuantumStates internal random\nnumber generator for sampling the measurement outcome. The RNG\nseed can be set using the :meth:`seed` method.\n\nArgs:\n    qargs (list or None): subsystems to sample measurements for,\n                          if None sample measurement of all\n                          subsystems (Default: None).\n\nReturns:\n    tuple: the pair ``(outcome, state)`` where ``outcome`` is the\n           measurement outcome string label, and ``state`` is the\n           collapsed post-measurement state for the corresponding\n           outcome.",
        "api_signature": "measure(self, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/quantum_state.py"
    },
    {
        "api_name": "_index_to_ket_array",
        "full_api_name": "QuantumState._index_to_ket_array",
        "api_description": "Convert an index array into a ket array.\n\nArgs:\n    inds (np.array): an integer index array.\n    dims (tuple): a list of subsystem dimensions.\n    string_labels (bool): return ket as string if True, otherwise\n                          return as index array (Default: False).\n\nReturns:\n    np.array: an array of ket strings if string_label=True, otherwise\n              an array of ket lists.",
        "api_signature": "_index_to_ket_array(inds, dims, string_labels)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/quantum_state.py"
    },
    {
        "api_name": "_vector_to_dict",
        "full_api_name": "QuantumState._vector_to_dict",
        "api_description": "Convert a vector to a ket dictionary.\n\nThis representation will not show zero values in the output dict.\n\nArgs:\n    vec (array): a Numpy vector array.\n    dims (tuple): subsystem dimensions.\n    decimals (None or int): number of decimal places to round to.\n                            (See Numpy.round), if None no rounding\n                            is done (Default: None).\n    string_labels (bool): return ket as string if True, otherwise\n                          return as index array (Default: False).\n\nReturns:\n    dict: the vector in dictionary `ket` form.",
        "api_signature": "_vector_to_dict(vec, dims, decimals, string_labels)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/quantum_state.py"
    },
    {
        "api_name": "_matrix_to_dict",
        "full_api_name": "QuantumState._matrix_to_dict",
        "api_description": "Convert a matrix to a ket dictionary.\n\nThis representation will not show zero values in the output dict.\n\nArgs:\n    mat (array): a Numpy matrix array.\n    dims (tuple): subsystem dimensions.\n    decimals (None or int): number of decimal places to round to.\n                            (See Numpy.round), if None no rounding\n                            is done (Default: None).\n    string_labels (bool): return ket as string if True, otherwise\n                          return as index array (Default: False).\n\nReturns:\n    dict: the matrix in dictionary `ket` form.",
        "api_signature": "_matrix_to_dict(mat, dims, decimals, string_labels)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/quantum_state.py"
    },
    {
        "api_name": "_subsystem_probabilities",
        "full_api_name": "QuantumState._subsystem_probabilities",
        "api_description": "Marginalize a probability vector according to subsystems.\n\nArgs:\n    probs (np.array): a probability vector Numpy array.\n    dims (tuple): subsystem dimensions.\n    qargs (None or list): a list of subsystems to return\n        marginalized probabilities for. If None return all\n        probabilities (Default: None).\n\nReturns:\n    np.array: the marginalized probability vector flattened\n              for the specified qargs.",
        "api_signature": "_subsystem_probabilities(probs, dims, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/quantum_state.py"
    },
    {
        "api_name": "__and__",
        "full_api_name": "QuantumState.__and__",
        "api_description": "",
        "api_signature": "__and__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/quantum_state.py"
    },
    {
        "api_name": "__xor__",
        "full_api_name": "QuantumState.__xor__",
        "api_description": "",
        "api_signature": "__xor__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/quantum_state.py"
    },
    {
        "api_name": "__mul__",
        "full_api_name": "QuantumState.__mul__",
        "api_description": "",
        "api_signature": "__mul__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/quantum_state.py"
    },
    {
        "api_name": "__truediv__",
        "full_api_name": "QuantumState.__truediv__",
        "api_description": "",
        "api_signature": "__truediv__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/quantum_state.py"
    },
    {
        "api_name": "__rmul__",
        "full_api_name": "QuantumState.__rmul__",
        "api_description": "",
        "api_signature": "__rmul__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/quantum_state.py"
    },
    {
        "api_name": "__add__",
        "full_api_name": "QuantumState.__add__",
        "api_description": "",
        "api_signature": "__add__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/quantum_state.py"
    },
    {
        "api_name": "__sub__",
        "full_api_name": "QuantumState.__sub__",
        "api_description": "",
        "api_signature": "__sub__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/quantum_state.py"
    },
    {
        "api_name": "__neg__",
        "full_api_name": "QuantumState.__neg__",
        "api_description": "",
        "api_signature": "__neg__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/quantum_state.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "DensityMatrix.__init__",
        "api_description": "Initialize a density matrix object.\n\nArgs:\n    data (np.ndarray or list or matrix_like or QuantumCircuit or\n          qiskit.circuit.Instruction):\n        A statevector, quantum instruction or an object with a ``to_operator`` or\n        ``to_matrix`` method from which the density matrix can be constructed.\n        If a vector the density matrix is constructed as the projector of that vector.\n        If a quantum instruction, the density matrix is constructed by assuming all\n        qubits are initialized in the zero state.\n    dims (int or tuple or list): Optional. The subsystem dimension\n            of the state (See additional information).\n\nRaises:\n    QiskitError: if input data is not valid.\n\nAdditional Information:\n    The ``dims`` kwarg can be None, an integer, or an iterable of\n    integers.\n\n    * ``Iterable`` -- the subsystem dimensions are the values in the list\n      with the total number of subsystems given by the length of the list.\n\n    * ``Int`` or ``None`` -- the leading dimension of the input matrix\n      specifies the total dimension of the density matrix. If it is a\n      power of two the state will be initialized as an N-qubit state.\n      If it is not a power of two the state will have a single\n      d-dimensional subsystem.",
        "api_signature": "__init__(self, data, dims)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/densitymatrix.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "DensityMatrix.__array__",
        "api_description": "",
        "api_signature": "__array__(self, dtype, copy)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/densitymatrix.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "DensityMatrix.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/densitymatrix.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "DensityMatrix.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/densitymatrix.py"
    },
    {
        "api_name": "settings",
        "full_api_name": "DensityMatrix.settings",
        "api_description": "Return settings.",
        "api_signature": "settings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/densitymatrix.py"
    },
    {
        "api_name": "draw",
        "full_api_name": "DensityMatrix.draw",
        "api_description": "Return a visualization of the Statevector.\n\n**repr**: ASCII TextMatrix of the state's ``__repr__``.\n\n**text**: ASCII TextMatrix that can be printed in the console.\n\n**latex**: An IPython Latex object for displaying in Jupyter Notebooks.\n\n**latex_source**: Raw, uncompiled ASCII source to generate array using LaTeX.\n\n**qsphere**: Matplotlib figure, rendering of density matrix using `plot_state_qsphere()`.\n\n**hinton**: Matplotlib figure, rendering of density matrix using `plot_state_hinton()`.\n\n**bloch**: Matplotlib figure, rendering of density matrix using `plot_bloch_multivector()`.\n\nArgs:\n    output (str): Select the output method to use for drawing the\n        state. Valid choices are `repr`, `text`, `latex`, `latex_source`,\n        `qsphere`, `hinton`, or `bloch`. Default is `repr`. Default can\n        be changed by adding the line ``state_drawer = <default>`` to\n        ``~/.qiskit/settings.conf`` under ``[default]``.\n    drawer_args: Arguments to be passed directly to the relevant drawing\n        function or constructor (`TextMatrix()`, `array_to_latex()`,\n        `plot_state_qsphere()`, `plot_state_hinton()` or `plot_bloch_multivector()`).\n        See the relevant function under `qiskit.visualization` for that function's\n        documentation.\n\nReturns:\n    :class:`matplotlib.Figure` or :class:`str` or\n    :class:`TextMatrix` or :class:`IPython.display.Latex`:\n    Drawing of the Statevector.\n\nRaises:\n    ValueError: when an invalid output method is selected.",
        "api_signature": "draw(self, output)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/densitymatrix.py"
    },
    {
        "api_name": "_ipython_display_",
        "full_api_name": "DensityMatrix._ipython_display_",
        "api_description": "",
        "api_signature": "_ipython_display_(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/densitymatrix.py"
    },
    {
        "api_name": "data",
        "full_api_name": "DensityMatrix.data",
        "api_description": "Return data.",
        "api_signature": "data(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/densitymatrix.py"
    },
    {
        "api_name": "is_valid",
        "full_api_name": "DensityMatrix.is_valid",
        "api_description": "Return True if trace 1 and positive semidefinite.",
        "api_signature": "is_valid(self, atol, rtol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/densitymatrix.py"
    },
    {
        "api_name": "to_operator",
        "full_api_name": "DensityMatrix.to_operator",
        "api_description": "Convert to Operator",
        "api_signature": "to_operator(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/densitymatrix.py"
    },
    {
        "api_name": "conjugate",
        "full_api_name": "DensityMatrix.conjugate",
        "api_description": "Return the conjugate of the density matrix.",
        "api_signature": "conjugate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/densitymatrix.py"
    },
    {
        "api_name": "trace",
        "full_api_name": "DensityMatrix.trace",
        "api_description": "Return the trace of the density matrix.",
        "api_signature": "trace(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/densitymatrix.py"
    },
    {
        "api_name": "purity",
        "full_api_name": "DensityMatrix.purity",
        "api_description": "Return the purity of the quantum state.",
        "api_signature": "purity(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/densitymatrix.py"
    },
    {
        "api_name": "tensor",
        "full_api_name": "DensityMatrix.tensor",
        "api_description": "Return the tensor product state self \u2297 other.\n\nArgs:\n    other (DensityMatrix): a quantum state object.\n\nReturns:\n    DensityMatrix: the tensor product operator self \u2297 other.\n\nRaises:\n    QiskitError: if other is not a quantum state.",
        "api_signature": "tensor(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/densitymatrix.py"
    },
    {
        "api_name": "expand",
        "full_api_name": "DensityMatrix.expand",
        "api_description": "Return the tensor product state other \u2297 self.\n\nArgs:\n    other (DensityMatrix): a quantum state object.\n\nReturns:\n    DensityMatrix: the tensor product state other \u2297 self.\n\nRaises:\n    QiskitError: if other is not a quantum state.",
        "api_signature": "expand(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/densitymatrix.py"
    },
    {
        "api_name": "_add",
        "full_api_name": "DensityMatrix._add",
        "api_description": "Return the linear combination self + other.\n\nArgs:\n    other (DensityMatrix): a quantum state object.\n\nReturns:\n    DensityMatrix: the linear combination self + other.\n\nRaises:\n    QiskitError: if other is not a quantum state, or has\n                 incompatible dimensions.",
        "api_signature": "_add(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/densitymatrix.py"
    },
    {
        "api_name": "_multiply",
        "full_api_name": "DensityMatrix._multiply",
        "api_description": "Return the scalar multiplied state other * self.\n\nArgs:\n    other (complex): a complex number.\n\nReturns:\n    DensityMatrix: the scalar multiplied state other * self.\n\nRaises:\n    QiskitError: if other is not a valid complex number.",
        "api_signature": "_multiply(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/densitymatrix.py"
    },
    {
        "api_name": "evolve",
        "full_api_name": "DensityMatrix.evolve",
        "api_description": "Evolve a quantum state by an operator.\n\nArgs:\n    other (Operator or QuantumChannel\n           or Instruction or Circuit): The operator to evolve by.\n    qargs (list): a list of QuantumState subsystem positions to apply\n                   the operator on.\n\nReturns:\n    DensityMatrix: the output density matrix.\n\nRaises:\n    QiskitError: if the operator dimension does not match the\n                 specified QuantumState subsystem dimensions.",
        "api_signature": "evolve(self, other, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/densitymatrix.py"
    },
    {
        "api_name": "reverse_qargs",
        "full_api_name": "DensityMatrix.reverse_qargs",
        "api_description": "Return a DensityMatrix with reversed subsystem ordering.\n\nFor a tensor product state this is equivalent to reversing the order\nof tensor product subsystems. For a density matrix\n:math:`\\rho = \\rho_{n-1} \\otimes ... \\otimes \\rho_0`\nthe returned state will be\n:math:`\\rho_0 \\otimes ... \\otimes \\rho_{n-1}`.\n\nReturns:\n    DensityMatrix: the state with reversed subsystem order.",
        "api_signature": "reverse_qargs(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/densitymatrix.py"
    },
    {
        "api_name": "_expectation_value_pauli",
        "full_api_name": "DensityMatrix._expectation_value_pauli",
        "api_description": "Compute the expectation value of a Pauli.\n\nArgs:\n    pauli (Pauli): a Pauli operator to evaluate expval of.\n    qargs (None or list): subsystems to apply operator on.\n\nReturns:\n    complex: the expectation value.",
        "api_signature": "_expectation_value_pauli(self, pauli, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/densitymatrix.py"
    },
    {
        "api_name": "expectation_value",
        "full_api_name": "DensityMatrix.expectation_value",
        "api_description": "Compute the expectation value of an operator.\n\nArgs:\n    oper (Operator): an operator to evaluate expval.\n    qargs (None or list): subsystems to apply the operator on.\n\nReturns:\n    complex: the expectation value.",
        "api_signature": "expectation_value(self, oper, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/densitymatrix.py"
    },
    {
        "api_name": "probabilities",
        "full_api_name": "DensityMatrix.probabilities",
        "api_description": "Return the subsystem measurement probability vector.\n\nMeasurement probabilities are with respect to measurement in the\ncomputation (diagonal) basis.\n\nArgs:\n    qargs (None or list): subsystems to return probabilities for,\n        if None return for all subsystems (Default: None).\n    decimals (None or int): the number of decimal places to round\n        values. If None no rounding is done (Default: None).\n\nReturns:\n    np.array: The Numpy vector array of probabilities.\n\nExamples:\n\n    Consider a 2-qubit product state :math:`\\rho=\\rho_1\\otimes\\rho_0`\n    with :math:`\\rho_1=|+\\rangle\\!\\langle+|`,\n    :math:`\\rho_0=|0\\rangle\\!\\langle0|`.\n\n    .. code-block::\n\n        from qiskit.quantum_info import DensityMatrix\n\n        rho = DensityMatrix.from_label('+0')\n\n        # Probabilities for measuring both qubits\n        probs = rho.probabilities()\n        print('probs: {}'.format(probs))\n\n        # Probabilities for measuring only qubit-0\n        probs_qubit_0 = rho.probabilities([0])\n        print('Qubit-0 probs: {}'.format(probs_qubit_0))\n\n        # Probabilities for measuring only qubit-1\n        probs_qubit_1 = rho.probabilities([1])\n        print('Qubit-1 probs: {}'.format(probs_qubit_1))\n\n    .. parsed-literal::\n\n        probs: [0.5 0.  0.5 0. ]\n        Qubit-0 probs: [1. 0.]\n        Qubit-1 probs: [0.5 0.5]\n\n    We can also permute the order of qubits in the ``qargs`` list\n    to change the qubit position in the probabilities output\n\n    .. code-block::\n\n        from qiskit.quantum_info import DensityMatrix\n\n        rho = DensityMatrix.from_label('+0')\n\n        # Probabilities for measuring both qubits\n        probs = rho.probabilities([0, 1])\n        print('probs: {}'.format(probs))\n\n        # Probabilities for measuring both qubits\n        # but swapping qubits 0 and 1 in output\n        probs_swapped = rho.probabilities([1, 0])\n        print('Swapped probs: {}'.format(probs_swapped))\n\n    .. parsed-literal::\n\n        probs: [0.5 0.  0.5 0. ]\n        Swapped probs: [0.5 0.5 0.  0. ]",
        "api_signature": "probabilities(self, qargs, decimals)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/densitymatrix.py"
    },
    {
        "api_name": "reset",
        "full_api_name": "DensityMatrix.reset",
        "api_description": "Reset state or subsystems to the 0-state.\n\nArgs:\n    qargs (list or None): subsystems to reset, if None all\n                          subsystems will be reset to their 0-state\n                          (Default: None).\n\nReturns:\n    DensityMatrix: the reset state.\n\nAdditional Information:\n    If all subsystems are reset this will return the ground state\n    on all subsystems. If only a some subsystems are reset this\n    function will perform evolution by the reset\n    :class:`~qiskit.quantum_info.SuperOp` of the reset subsystems.",
        "api_signature": "reset(self, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/densitymatrix.py"
    },
    {
        "api_name": "from_label",
        "full_api_name": "DensityMatrix.from_label",
        "api_description": "Return a tensor product of Pauli X,Y,Z eigenstates.\n\n.. list-table:: Single-qubit state labels\n   :header-rows: 1\n\n   * - Label\n     - Statevector\n   * - ``\"0\"``\n     - :math:`\\begin{pmatrix} 1 & 0 \\\\ 0 & 0 \\end{pmatrix}`\n   * - ``\"1\"``\n     - :math:`\\begin{pmatrix} 0 & 0 \\\\ 0 & 1 \\end{pmatrix}`\n   * - ``\"+\"``\n     - :math:`\\frac{1}{2}\\begin{pmatrix} 1 & 1 \\\\ 1 & 1 \\end{pmatrix}`\n   * - ``\"-\"``\n     - :math:`\\frac{1}{2}\\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix}`\n   * - ``\"r\"``\n     - :math:`\\frac{1}{2}\\begin{pmatrix} 1 & -i \\\\ i & 1 \\end{pmatrix}`\n   * - ``\"l\"``\n     - :math:`\\frac{1}{2}\\begin{pmatrix} 1 & i \\\\ -i & 1 \\end{pmatrix}`\n\nArgs:\n    label (string): a eigenstate string ket label (see table for\n                    allowed values).\n\nReturns:\n    DensityMatrix: The N-qubit basis state density matrix.\n\nRaises:\n    QiskitError: if the label contains invalid characters, or the length\n                 of the label is larger than an explicitly specified num_qubits.",
        "api_signature": "from_label(cls, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/densitymatrix.py"
    },
    {
        "api_name": "from_int",
        "full_api_name": "DensityMatrix.from_int",
        "api_description": "Return a computational basis state density matrix.\n\nArgs:\n    i (int): the basis state element.\n    dims (int or tuple or list): The subsystem dimensions of the statevector\n                                 (See additional information).\n\nReturns:\n    DensityMatrix: The computational basis state :math:`|i\\rangle\\!\\langle i|`.\n\nAdditional Information:\n    The ``dims`` kwarg can be an integer or an iterable of integers.\n\n    * ``Iterable`` -- the subsystem dimensions are the values in the list\n      with the total number of subsystems given by the length of the list.\n\n    * ``Int`` -- the integer specifies the total dimension of the\n      state. If it is a power of two the state will be initialized\n      as an N-qubit state. If it is not a power of  two the state\n      will have a single d-dimensional subsystem.",
        "api_signature": "from_int(i, dims)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/densitymatrix.py"
    },
    {
        "api_name": "from_instruction",
        "full_api_name": "DensityMatrix.from_instruction",
        "api_description": "Return the output density matrix of an instruction.\n\nThe statevector is initialized in the state :math:`|{0,\\ldots,0}\\rangle` of\nthe same number of qubits as the input instruction or circuit, evolved\nby the input instruction, and the output statevector returned.\n\nArgs:\n    instruction (qiskit.circuit.Instruction or QuantumCircuit): instruction or circuit\n\nReturns:\n    DensityMatrix: the final density matrix.\n\nRaises:\n    QiskitError: if the instruction contains invalid instructions for\n                 density matrix simulation.",
        "api_signature": "from_instruction(cls, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/densitymatrix.py"
    },
    {
        "api_name": "to_dict",
        "full_api_name": "DensityMatrix.to_dict",
        "api_description": "Convert the density matrix to dictionary form.\n\nThis dictionary representation uses a Ket-like notation where the\ndictionary keys are qudit strings for the subsystem basis vectors.\nIf any subsystem has a dimension greater than 10 comma delimiters are\ninserted between integers so that subsystems can be distinguished.\n\nArgs:\n    decimals (None or int): the number of decimal places to round\n                            values. If None no rounding is done\n                            (Default: None).\n\nReturns:\n    dict: the dictionary form of the DensityMatrix.\n\nExamples:\n\n    The ket-form of a 2-qubit density matrix\n    :math:`rho = |-\\rangle\\!\\langle -|\\otimes |0\\rangle\\!\\langle 0|`\n\n    .. code-block::\n\n        from qiskit.quantum_info import DensityMatrix\n\n        rho = DensityMatrix.from_label('-0')\n        print(rho.to_dict())\n\n    .. parsed-literal::\n\n       {\n           '00|00': (0.4999999999999999+0j),\n           '10|00': (-0.4999999999999999-0j),\n           '00|10': (-0.4999999999999999+0j),\n           '10|10': (0.4999999999999999+0j)\n       }\n\n    For non-qubit subsystems the integer range can go from 0 to 9. For\n    example in a qutrit system\n\n    .. code-block::\n\n        import numpy as np\n        from qiskit.quantum_info import DensityMatrix\n\n        mat = np.zeros((9, 9))\n        mat[0, 0] = 0.25\n        mat[3, 3] = 0.25\n        mat[6, 6] = 0.25\n        mat[-1, -1] = 0.25\n        rho = DensityMatrix(mat, dims=(3, 3))\n        print(rho.to_dict())\n\n    .. parsed-literal::\n\n        {'00|00': (0.25+0j), '10|10': (0.25+0j), '20|20': (0.25+0j), '22|22': (0.25+0j)}\n\n    For large subsystem dimensions delimiters are required. The\n    following example is for a 20-dimensional system consisting of\n    a qubit and 10-dimensional qudit.\n\n    .. code-block::\n\n        import numpy as np\n        from qiskit.quantum_info import DensityMatrix\n\n        mat = np.zeros((2 * 10, 2 * 10))\n        mat[0, 0] = 0.5\n        mat[-1, -1] = 0.5\n        rho = DensityMatrix(mat, dims=(2, 10))\n        print(rho.to_dict())\n\n    .. parsed-literal::\n\n        {'00|00': (0.5+0j), '91|91': (0.5+0j)}",
        "api_signature": "to_dict(self, decimals)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/densitymatrix.py"
    },
    {
        "api_name": "_evolve_operator",
        "full_api_name": "DensityMatrix._evolve_operator",
        "api_description": "Evolve density matrix by an operator",
        "api_signature": "_evolve_operator(self, other, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/densitymatrix.py"
    },
    {
        "api_name": "_append_instruction",
        "full_api_name": "DensityMatrix._append_instruction",
        "api_description": "Update the current Statevector by applying an instruction.",
        "api_signature": "_append_instruction(self, other, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/densitymatrix.py"
    },
    {
        "api_name": "_evolve_instruction",
        "full_api_name": "DensityMatrix._evolve_instruction",
        "api_description": "Return a new statevector by applying an instruction.",
        "api_signature": "_evolve_instruction(self, obj, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/densitymatrix.py"
    },
    {
        "api_name": "to_statevector",
        "full_api_name": "DensityMatrix.to_statevector",
        "api_description": "Return a statevector from a pure density matrix.\n\nArgs:\n    atol (float): Absolute tolerance for checking operation validity.\n    rtol (float): Relative tolerance for checking operation validity.\n\nReturns:\n    Statevector: The pure density matrix's corresponding statevector.\n        Corresponds to the eigenvector of the only non-zero eigenvalue.\n\nRaises:\n    QiskitError: if the state is not pure.",
        "api_signature": "to_statevector(self, atol, rtol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/densitymatrix.py"
    },
    {
        "api_name": "partial_transpose",
        "full_api_name": "DensityMatrix.partial_transpose",
        "api_description": "Return partially transposed density matrix.\n\nArgs:\n    qargs (list): The subsystems to be transposed.\n\nReturns:\n    DensityMatrix: The partially transposed density matrix.",
        "api_signature": "partial_transpose(self, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/densitymatrix.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Statevector.__init__",
        "api_description": "Initialize a statevector object.\n\nArgs:\n    data (np.array or list or Statevector or Operator or QuantumCircuit or\n          qiskit.circuit.Instruction):\n        Data from which the statevector can be constructed. This can be either a complex\n        vector, another statevector, a ``Operator`` with only one column or a\n        ``QuantumCircuit`` or ``Instruction``.  If the data is a circuit or instruction,\n        the statevector is constructed by assuming that all qubits are initialized to the\n        zero state.\n    dims (int or tuple or list): Optional. The subsystem dimension of\n                                 the state (See additional information).\n\nRaises:\n    QiskitError: if input data is not valid.\n\nAdditional Information:\n    The ``dims`` kwarg can be None, an integer, or an iterable of\n    integers.\n\n    * ``Iterable`` -- the subsystem dimensions are the values in the list\n      with the total number of subsystems given by the length of the list.\n\n    * ``Int`` or ``None`` -- the length of the input vector\n      specifies the total dimension of the density matrix. If it is a\n      power of two the state will be initialized as an N-qubit state.\n      If it is not a power of two the state will have a single\n      d-dimensional subsystem.",
        "api_signature": "__init__(self, data, dims)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/statevector.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "Statevector.__array__",
        "api_description": "",
        "api_signature": "__array__(self, dtype, copy)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/statevector.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "Statevector.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/statevector.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "Statevector.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/statevector.py"
    },
    {
        "api_name": "settings",
        "full_api_name": "Statevector.settings",
        "api_description": "Return settings.",
        "api_signature": "settings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/statevector.py"
    },
    {
        "api_name": "draw",
        "full_api_name": "Statevector.draw",
        "api_description": "Return a visualization of the Statevector.\n\n**repr**: ASCII TextMatrix of the state's ``__repr__``.\n\n**text**: ASCII TextMatrix that can be printed in the console.\n\n**latex**: An IPython Latex object for displaying in Jupyter Notebooks.\n\n**latex_source**: Raw, uncompiled ASCII source to generate array using LaTeX.\n\n**qsphere**: Matplotlib figure, rendering of statevector using `plot_state_qsphere()`.\n\n**hinton**: Matplotlib figure, rendering of statevector using `plot_state_hinton()`.\n\n**bloch**: Matplotlib figure, rendering of statevector using `plot_bloch_multivector()`.\n\n**city**: Matplotlib figure, rendering of statevector using `plot_state_city()`.\n\n**paulivec**: Matplotlib figure, rendering of statevector using `plot_state_paulivec()`.\n\nArgs:\n    output (str): Select the output method to use for drawing the\n        state. Valid choices are `repr`, `text`, `latex`, `latex_source`,\n        `qsphere`, `hinton`, `bloch`, `city`, or `paulivec`. Default is `repr`.\n        Default can be changed by adding the line ``state_drawer = <default>`` to\n        ``~/.qiskit/settings.conf`` under ``[default]``.\n    drawer_args: Arguments to be passed directly to the relevant drawing\n        function or constructor (`TextMatrix()`, `array_to_latex()`,\n        `plot_state_qsphere()`, `plot_state_hinton()` or `plot_bloch_multivector()`).\n        See the relevant function under `qiskit.visualization` for that function's\n        documentation.\n\nReturns:\n    :class:`matplotlib.Figure` or :class:`str` or\n    :class:`TextMatrix` or :class:`IPython.display.Latex`:\n    Drawing of the Statevector.\n\nRaises:\n    ValueError: when an invalid output method is selected.\n\nExamples:\n\n    Plot one of the Bell states\n\n    .. plot::\n       :include-source:\n\n        from numpy import sqrt\n        from qiskit.quantum_info import Statevector\n        sv=Statevector([1/sqrt(2), 0, 0, -1/sqrt(2)])\n        sv.draw(output='hinton')",
        "api_signature": "draw(self, output)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/statevector.py"
    },
    {
        "api_name": "_ipython_display_",
        "full_api_name": "Statevector._ipython_display_",
        "api_description": "",
        "api_signature": "_ipython_display_(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/statevector.py"
    },
    {
        "api_name": "__getitem__",
        "full_api_name": "Statevector.__getitem__",
        "api_description": "Return Statevector item either by index or binary label\nArgs:\n    key (int or str): index or corresponding binary label, e.g. '01' = 1.\n\nReturns:\n    numpy.complex128: Statevector item.\n\nRaises:\n    QiskitError: if key is not valid.",
        "api_signature": "__getitem__(self, key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/statevector.py"
    },
    {
        "api_name": "__iter__",
        "full_api_name": "Statevector.__iter__",
        "api_description": "",
        "api_signature": "__iter__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/statevector.py"
    },
    {
        "api_name": "__len__",
        "full_api_name": "Statevector.__len__",
        "api_description": "",
        "api_signature": "__len__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/statevector.py"
    },
    {
        "api_name": "data",
        "full_api_name": "Statevector.data",
        "api_description": "Return data.",
        "api_signature": "data(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/statevector.py"
    },
    {
        "api_name": "is_valid",
        "full_api_name": "Statevector.is_valid",
        "api_description": "Return True if a Statevector has norm 1.",
        "api_signature": "is_valid(self, atol, rtol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/statevector.py"
    },
    {
        "api_name": "to_operator",
        "full_api_name": "Statevector.to_operator",
        "api_description": "Convert state to a rank-1 projector operator",
        "api_signature": "to_operator(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/statevector.py"
    },
    {
        "api_name": "conjugate",
        "full_api_name": "Statevector.conjugate",
        "api_description": "Return the conjugate of the operator.",
        "api_signature": "conjugate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/statevector.py"
    },
    {
        "api_name": "trace",
        "full_api_name": "Statevector.trace",
        "api_description": "Return the trace of the quantum state as a density matrix.",
        "api_signature": "trace(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/statevector.py"
    },
    {
        "api_name": "purity",
        "full_api_name": "Statevector.purity",
        "api_description": "Return the purity of the quantum state.",
        "api_signature": "purity(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/statevector.py"
    },
    {
        "api_name": "tensor",
        "full_api_name": "Statevector.tensor",
        "api_description": "Return the tensor product state self \u2297 other.\n\nArgs:\n    other (Statevector): a quantum state object.\n\nReturns:\n    Statevector: the tensor product operator self \u2297 other.\n\nRaises:\n    QiskitError: if other is not a quantum state.",
        "api_signature": "tensor(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/statevector.py"
    },
    {
        "api_name": "inner",
        "full_api_name": "Statevector.inner",
        "api_description": "Return the inner product of self and other as\n:math:`\\langle self| other \\rangle`.\n\nArgs:\n    other (Statevector): a quantum state object.\n\nReturns:\n    np.complex128: the inner product of self and other, :math:`\\langle self| other \\rangle`.\n\nRaises:\n    QiskitError: if other is not a quantum state or has different dimension.",
        "api_signature": "inner(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/statevector.py"
    },
    {
        "api_name": "expand",
        "full_api_name": "Statevector.expand",
        "api_description": "Return the tensor product state other \u2297 self.\n\nArgs:\n    other (Statevector): a quantum state object.\n\nReturns:\n    Statevector: the tensor product state other \u2297 self.\n\nRaises:\n    QiskitError: if other is not a quantum state.",
        "api_signature": "expand(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/statevector.py"
    },
    {
        "api_name": "_add",
        "full_api_name": "Statevector._add",
        "api_description": "Return the linear combination self + other.\n\nArgs:\n    other (Statevector): a quantum state object.\n\nReturns:\n    Statevector: the linear combination self + other.\n\nRaises:\n    QiskitError: if other is not a quantum state, or has\n                 incompatible dimensions.",
        "api_signature": "_add(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/statevector.py"
    },
    {
        "api_name": "_multiply",
        "full_api_name": "Statevector._multiply",
        "api_description": "Return the scalar multiplied state self * other.\n\nArgs:\n    other (complex): a complex number.\n\nReturns:\n    Statevector: the scalar multiplied state other * self.\n\nRaises:\n    QiskitError: if other is not a valid complex number.",
        "api_signature": "_multiply(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/statevector.py"
    },
    {
        "api_name": "evolve",
        "full_api_name": "Statevector.evolve",
        "api_description": "Evolve a quantum state by the operator.\n\nArgs:\n    other (Operator | QuantumCircuit | circuit.Instruction): The operator to evolve by.\n    qargs (list): a list of Statevector subsystem positions to apply\n                   the operator on.\n\nReturns:\n    Statevector: the output quantum state.\n\nRaises:\n    QiskitError: if the operator dimension does not match the\n                 specified Statevector subsystem dimensions.",
        "api_signature": "evolve(self, other, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/statevector.py"
    },
    {
        "api_name": "equiv",
        "full_api_name": "Statevector.equiv",
        "api_description": "Return True if other is equivalent as a statevector up to global phase.\n\n.. note::\n\n    If other is not a Statevector, but can be used to initialize a statevector object,\n    this will check that Statevector(other) is equivalent to the current statevector up\n    to global phase.\n\nArgs:\n    other (Statevector): an object from which a ``Statevector`` can be constructed.\n    rtol (float): relative tolerance value for comparison.\n    atol (float): absolute tolerance value for comparison.\n\nReturns:\n    bool: True if statevectors are equivalent up to global phase.",
        "api_signature": "equiv(self, other, rtol, atol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/statevector.py"
    },
    {
        "api_name": "reverse_qargs",
        "full_api_name": "Statevector.reverse_qargs",
        "api_description": "Return a Statevector with reversed subsystem ordering.\n\nFor a tensor product state this is equivalent to reversing the order\nof tensor product subsystems. For a statevector\n:math:`|\\psi \\rangle = |\\psi_{n-1} \\rangle \\otimes ... \\otimes |\\psi_0 \\rangle`\nthe returned statevector will be\n:math:`|\\psi_{0} \\rangle \\otimes ... \\otimes |\\psi_{n-1} \\rangle`.\n\nReturns:\n    Statevector: the Statevector with reversed subsystem order.",
        "api_signature": "reverse_qargs(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/statevector.py"
    },
    {
        "api_name": "_expectation_value_pauli",
        "full_api_name": "Statevector._expectation_value_pauli",
        "api_description": "Compute the expectation value of a Pauli.\n\nArgs:\n    pauli (Pauli): a Pauli operator to evaluate expval of.\n    qargs (None or list): subsystems to apply operator on.\n\nReturns:\n    complex: the expectation value.",
        "api_signature": "_expectation_value_pauli(self, pauli, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/statevector.py"
    },
    {
        "api_name": "expectation_value",
        "full_api_name": "Statevector.expectation_value",
        "api_description": "Compute the expectation value of an operator.\n\nArgs:\n    oper (Operator): an operator to evaluate expval of.\n    qargs (None or list): subsystems to apply operator on.\n\nReturns:\n    complex: the expectation value.",
        "api_signature": "expectation_value(self, oper, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/statevector.py"
    },
    {
        "api_name": "probabilities",
        "full_api_name": "Statevector.probabilities",
        "api_description": "Return the subsystem measurement probability vector.\n\nMeasurement probabilities are with respect to measurement in the\ncomputation (diagonal) basis.\n\nArgs:\n    qargs (None or list): subsystems to return probabilities for,\n        if None return for all subsystems (Default: None).\n    decimals (None or int): the number of decimal places to round\n        values. If None no rounding is done (Default: None).\n\nReturns:\n    np.array: The Numpy vector array of probabilities.\n\nExamples:\n\n    Consider a 2-qubit product state\n    :math:`|\\psi\\rangle=|+\\rangle\\otimes|0\\rangle`.\n\n    .. code-block::\n\n        from qiskit.quantum_info import Statevector\n\n        psi = Statevector.from_label('+0')\n\n        # Probabilities for measuring both qubits\n        probs = psi.probabilities()\n        print('probs: {}'.format(probs))\n\n        # Probabilities for measuring only qubit-0\n        probs_qubit_0 = psi.probabilities([0])\n        print('Qubit-0 probs: {}'.format(probs_qubit_0))\n\n        # Probabilities for measuring only qubit-1\n        probs_qubit_1 = psi.probabilities([1])\n        print('Qubit-1 probs: {}'.format(probs_qubit_1))\n\n    .. parsed-literal::\n\n        probs: [0.5 0.  0.5 0. ]\n        Qubit-0 probs: [1. 0.]\n        Qubit-1 probs: [0.5 0.5]\n\n    We can also permute the order of qubits in the ``qargs`` list\n    to change the qubit position in the probabilities output\n\n    .. code-block::\n\n        from qiskit.quantum_info import Statevector\n\n        psi = Statevector.from_label('+0')\n\n        # Probabilities for measuring both qubits\n        probs = psi.probabilities([0, 1])\n        print('probs: {}'.format(probs))\n\n        # Probabilities for measuring both qubits\n        # but swapping qubits 0 and 1 in output\n        probs_swapped = psi.probabilities([1, 0])\n        print('Swapped probs: {}'.format(probs_swapped))\n\n    .. parsed-literal::\n\n        probs: [0.5 0.  0.5 0. ]\n        Swapped probs: [0.5 0.5 0.  0. ]",
        "api_signature": "probabilities(self, qargs, decimals)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/statevector.py"
    },
    {
        "api_name": "reset",
        "full_api_name": "Statevector.reset",
        "api_description": "Reset state or subsystems to the 0-state.\n\nArgs:\n    qargs (list or None): subsystems to reset, if None all\n                          subsystems will be reset to their 0-state\n                          (Default: None).\n\nReturns:\n    Statevector: the reset state.\n\nAdditional Information:\n    If all subsystems are reset this will return the ground state\n    on all subsystems. If only a some subsystems are reset this\n    function will perform a measurement on those subsystems and\n    evolve the subsystems so that the collapsed post-measurement\n    states are rotated to the 0-state. The RNG seed for this\n    sampling can be set using the :meth:`seed` method.",
        "api_signature": "reset(self, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/statevector.py"
    },
    {
        "api_name": "from_label",
        "full_api_name": "Statevector.from_label",
        "api_description": "Return a tensor product of Pauli X,Y,Z eigenstates.\n\n.. list-table:: Single-qubit state labels\n   :header-rows: 1\n\n   * - Label\n     - Statevector\n   * - ``\"0\"``\n     - :math:`[1, 0]`\n   * - ``\"1\"``\n     - :math:`[0, 1]`\n   * - ``\"+\"``\n     - :math:`[1 / \\sqrt{2},  1 / \\sqrt{2}]`\n   * - ``\"-\"``\n     - :math:`[1 / \\sqrt{2},  -1 / \\sqrt{2}]`\n   * - ``\"r\"``\n     - :math:`[1 / \\sqrt{2},  i / \\sqrt{2}]`\n   * - ``\"l\"``\n     - :math:`[1 / \\sqrt{2},  -i / \\sqrt{2}]`\n\nArgs:\n    label (string): a eigenstate string ket label (see table for\n                    allowed values).\n\nReturns:\n    Statevector: The N-qubit basis state density matrix.\n\nRaises:\n    QiskitError: if the label contains invalid characters, or the\n                 length of the label is larger than an explicitly\n                 specified num_qubits.",
        "api_signature": "from_label(cls, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/statevector.py"
    },
    {
        "api_name": "from_int",
        "full_api_name": "Statevector.from_int",
        "api_description": "Return a computational basis statevector.\n\nArgs:\n    i (int): the basis state element.\n    dims (int or tuple or list): The subsystem dimensions of the statevector\n                                 (See additional information).\n\nReturns:\n    Statevector: The computational basis state :math:`|i\\rangle`.\n\nAdditional Information:\n    The ``dims`` kwarg can be an integer or an iterable of integers.\n\n    * ``Iterable`` -- the subsystem dimensions are the values in the list\n      with the total number of subsystems given by the length of the list.\n\n    * ``Int`` -- the integer specifies the total dimension of the\n      state. If it is a power of two the state will be initialized\n      as an N-qubit state. If it is not a power of  two the state\n      will have a single d-dimensional subsystem.",
        "api_signature": "from_int(i, dims)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/statevector.py"
    },
    {
        "api_name": "from_instruction",
        "full_api_name": "Statevector.from_instruction",
        "api_description": "Return the output statevector of an instruction.\n\nThe statevector is initialized in the state :math:`|{0,\\ldots,0}\\rangle` of the\nsame number of qubits as the input instruction or circuit, evolved\nby the input instruction, and the output statevector returned.\n\nArgs:\n    instruction (qiskit.circuit.Instruction or QuantumCircuit): instruction or circuit\n\nReturns:\n    Statevector: The final statevector.\n\nRaises:\n    QiskitError: if the instruction contains invalid instructions for\n                 the statevector simulation.",
        "api_signature": "from_instruction(cls, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/statevector.py"
    },
    {
        "api_name": "to_dict",
        "full_api_name": "Statevector.to_dict",
        "api_description": "Convert the statevector to dictionary form.\n\nThis dictionary representation uses a Ket-like notation where the\ndictionary keys are qudit strings for the subsystem basis vectors.\nIf any subsystem has a dimension greater than 10 comma delimiters are\ninserted between integers so that subsystems can be distinguished.\n\nArgs:\n    decimals (None or int): the number of decimal places to round\n                            values. If None no rounding is done\n                            (Default: None).\n\nReturns:\n    dict: the dictionary form of the Statevector.\n\nExample:\n\n    The ket-form of a 2-qubit statevector\n    :math:`|\\psi\\rangle = |-\\rangle\\otimes |0\\rangle`\n\n    .. code-block::\n\n        from qiskit.quantum_info import Statevector\n\n        psi = Statevector.from_label('-0')\n        print(psi.to_dict())\n\n    .. parsed-literal::\n\n        {'00': (0.7071067811865475+0j), '10': (-0.7071067811865475+0j)}\n\n    For non-qubit subsystems the integer range can go from 0 to 9. For\n    example in a qutrit system\n\n    .. code-block::\n\n        import numpy as np\n        from qiskit.quantum_info import Statevector\n\n        vec = np.zeros(9)\n        vec[0] = 1 / np.sqrt(2)\n        vec[-1] = 1 / np.sqrt(2)\n        psi = Statevector(vec, dims=(3, 3))\n        print(psi.to_dict())\n\n    .. parsed-literal::\n\n        {'00': (0.7071067811865475+0j), '22': (0.7071067811865475+0j)}\n\n    For large subsystem dimensions delimiters are required. The\n    following example is for a 20-dimensional system consisting of\n    a qubit and 10-dimensional qudit.\n\n    .. code-block::\n\n        import numpy as np\n        from qiskit.quantum_info import Statevector\n\n        vec = np.zeros(2 * 10)\n        vec[0] = 1 / np.sqrt(2)\n        vec[-1] = 1 / np.sqrt(2)\n        psi = Statevector(vec, dims=(2, 10))\n        print(psi.to_dict())\n\n    .. parsed-literal::\n\n        {'00': (0.7071067811865475+0j), '91': (0.7071067811865475+0j)}",
        "api_signature": "to_dict(self, decimals)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/statevector.py"
    },
    {
        "api_name": "_evolve_operator",
        "full_api_name": "Statevector._evolve_operator",
        "api_description": "Evolve a qudit statevector",
        "api_signature": "_evolve_operator(statevec, oper, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/statevector.py"
    },
    {
        "api_name": "_evolve_instruction",
        "full_api_name": "Statevector._evolve_instruction",
        "api_description": "Update the current Statevector by applying an instruction.",
        "api_signature": "_evolve_instruction(statevec, obj, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/statevector.py"
    },
    {
        "api_name": "random_statevector",
        "full_api_name": "random_statevector",
        "api_description": "Generator a random Statevector.\n\nThe statevector is sampled from the uniform distribution. This is the measure\ninduced by the Haar measure on unitary matrices.\n\nArgs:\n    dims (int or tuple): the dimensions of the state.\n    seed (int or np.random.Generator): Optional. Set a fixed seed or\n                                       generator for RNG.\n\nReturns:\n    Statevector: the random statevector.\n\nReference:\n    K. Zyczkowski and H. Sommers (2001), \"Induced measures in the space of mixed quantum states\",\n    `J. Phys. A: Math. Gen. 34 7111 <https://arxiv.org/abs/quant-ph/0012101>`__.",
        "api_signature": "random_statevector(dims, seed)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/random.py"
    },
    {
        "api_name": "random_density_matrix",
        "full_api_name": "random_density_matrix",
        "api_description": "Generator a random DensityMatrix.\n\nArgs:\n    dims (int or tuple): the dimensions of the DensityMatrix.\n    rank (int or None): Optional, the rank of the density matrix.\n                        The default value is full-rank.\n    method (string): Optional. The method to use.\n        'Hilbert-Schmidt': (Default) sample from the Hilbert-Schmidt metric.\n        'Bures': sample from the Bures metric.\n    seed (int or np.random.Generator): Optional. Set a fixed seed or\n                                       generator for RNG.\n\nReturns:\n    DensityMatrix: the random density matrix.\n\nRaises:\n    QiskitError: if the method is not valid.",
        "api_signature": "random_density_matrix(dims, rank, method, seed)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/random.py"
    },
    {
        "api_name": "_ginibre_matrix",
        "full_api_name": "_ginibre_matrix",
        "api_description": "Return a normally distributed complex random matrix.\n\nArgs:\n    nrow (int): number of rows in output matrix.\n    ncol (int): number of columns in output matrix.\n    seed(int or np.random.Generator): default rng.\n\nReturns:\n    ndarray: A complex rectangular matrix where each real and imaginary\n        entry is sampled from the normal distribution.",
        "api_signature": "_ginibre_matrix(nrow, ncol, seed)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/random.py"
    },
    {
        "api_name": "_random_density_hs",
        "full_api_name": "_random_density_hs",
        "api_description": "Generate a random density matrix from the Hilbert-Schmidt metric.\n\nArgs:\n    dim (int): the dimensions of the density matrix.\n    rank (int or None): the rank of the density matrix. The default\n        value is full-rank.\n    seed (int or np.random.Generator): default rng.\n\nReturns:\n    ndarray: rho (N,N)  a density matrix.",
        "api_signature": "_random_density_hs(dim, rank, seed)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/random.py"
    },
    {
        "api_name": "_random_density_bures",
        "full_api_name": "_random_density_bures",
        "api_description": "Generate a random density matrix from the Bures metric.\n\nArgs:\n    dim (int): the length of the density matrix.\n    rank (int or None): the rank of the density matrix. The default\n        value is full-rank.\n    seed (int or np.random.Generator): default rng.\n\nReturns:\n    ndarray: rho (N,N) a density matrix.",
        "api_signature": "_random_density_bures(dim, rank, seed)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/random.py"
    },
    {
        "api_name": "state_fidelity",
        "full_api_name": "state_fidelity",
        "api_description": "Return the state fidelity between two quantum states.\n\nThe state fidelity :math:`F` for density matrix input states\n:math:`\\rho_1, \\rho_2` is given by\n\n.. math::\n    F(\\rho_1, \\rho_2) = Tr[\\sqrt{\\sqrt{\\rho_1}\\rho_2\\sqrt{\\rho_1}}]^2.\n\nIf one of the states is a pure state this simplifies to\n:math:`F(\\rho_1, \\rho_2) = \\langle\\psi_1|\\rho_2|\\psi_1\\rangle`, where\n:math:`\\rho_1 = |\\psi_1\\rangle\\!\\langle\\psi_1|`.\n\nArgs:\n    state1 (Statevector or DensityMatrix): the first quantum state.\n    state2 (Statevector or DensityMatrix): the second quantum state.\n    validate (bool): check if the inputs are valid quantum states\n                     [Default: True]\n\nReturns:\n    float: The state fidelity :math:`F(\\rho_1, \\rho_2)`.\n\nRaises:\n    QiskitError: if ``validate=True`` and the inputs are invalid quantum states.",
        "api_signature": "state_fidelity(state1, state2, validate)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/measures.py"
    },
    {
        "api_name": "purity",
        "full_api_name": "purity",
        "api_description": "Calculate the purity of a quantum state.\n\nThe purity of a density matrix :math:`\\rho` is\n\n.. math::\n\n    \\text{Purity}(\\rho) = Tr[\\rho^2]\n\nArgs:\n    state (Statevector or DensityMatrix): a quantum state.\n    validate (bool): check if input state is valid [Default: True]\n\nReturns:\n    float: the purity :math:`Tr[\\rho^2]`.\n\nRaises:\n    QiskitError: if the input isn't a valid quantum state.",
        "api_signature": "purity(state, validate)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/measures.py"
    },
    {
        "api_name": "entropy",
        "full_api_name": "entropy",
        "api_description": "Calculate the von-Neumann entropy of a quantum state.\n\nThe entropy :math:`S` is given by\n\n.. math::\n\n    S(\\rho) = - Tr[\\rho \\log(\\rho)]\n\nArgs:\n    state (Statevector or DensityMatrix): a quantum state.\n    base (int): the base of the logarithm [Default: 2].\n\nReturns:\n    float: The von-Neumann entropy S(rho).\n\nRaises:\n    QiskitError: if the input state is not a valid QuantumState.",
        "api_signature": "entropy(state, base)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/measures.py"
    },
    {
        "api_name": "mutual_information",
        "full_api_name": "mutual_information",
        "api_description": "Calculate the mutual information of a bipartite state.\n\nThe mutual information :math:`I` is given by:\n\n.. math::\n\n    I(\\rho_{AB}) = S(\\rho_A) + S(\\rho_B) - S(\\rho_{AB})\n\nwhere :math:`\\rho_A=Tr_B[\\rho_{AB}], \\rho_B=Tr_A[\\rho_{AB}]`, are the\nreduced density matrices of the bipartite state :math:`\\rho_{AB}`.\n\nArgs:\n    state (Statevector or DensityMatrix): a bipartite state.\n    base (int): the base of the logarithm [Default: 2].\n\nReturns:\n    float: The mutual information :math:`I(\\rho_{AB})`.\n\nRaises:\n    QiskitError: if the input state is not a valid QuantumState.\n    QiskitError: if input is not a bipartite QuantumState.",
        "api_signature": "mutual_information(state, base)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/measures.py"
    },
    {
        "api_name": "concurrence",
        "full_api_name": "concurrence",
        "api_description": "Calculate the concurrence of a quantum state.\n\nThe concurrence of a bipartite\n:class:`~qiskit.quantum_info.Statevector` :math:`|\\psi\\rangle` is\ngiven by\n\n.. math::\n\n    C(|\\psi\\rangle) = \\sqrt{2(1 - Tr[\\rho_0^2])}\n\nwhere :math:`\\rho_0 = Tr_1[|\\psi\\rangle\\!\\langle\\psi|]` is the\nreduced state from by taking the\n:func:`~qiskit.quantum_info.partial_trace` of the input state.\n\nFor density matrices the concurrence is only defined for\n2-qubit states, it is given by:\n\n.. math::\n\n    C(\\rho) = \\max(0, \\lambda_1 - \\lambda_2 - \\lambda_3 - \\lambda_4)\n\nwhere  :math:`\\lambda _1 \\ge \\lambda _2 \\ge \\lambda _3 \\ge \\lambda _4`\nare the ordered eigenvalues of the matrix\n:math:`R=\\sqrt{\\sqrt{\\rho }(Y\\otimes Y)\\overline{\\rho}(Y\\otimes Y)\\sqrt{\\rho}}`.\n\nArgs:\n    state (Statevector or DensityMatrix): a 2-qubit quantum state.\n\nReturns:\n    float: The concurrence.\n\nRaises:\n    QiskitError: if the input state is not a valid QuantumState.\n    QiskitError: if input is not a bipartite QuantumState.\n    QiskitError: if density matrix input is not a 2-qubit state.",
        "api_signature": "concurrence(state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/measures.py"
    },
    {
        "api_name": "entanglement_of_formation",
        "full_api_name": "entanglement_of_formation",
        "api_description": "Calculate the entanglement of formation of quantum state.\n\nThe input quantum state must be either a bipartite state vector, or a\n2-qubit density matrix.\n\nArgs:\n    state (Statevector or DensityMatrix): a 2-qubit quantum state.\n\nReturns:\n    float: The entanglement of formation.\n\nRaises:\n    QiskitError: if the input state is not a valid QuantumState.\n    QiskitError: if input is not a bipartite QuantumState.\n    QiskitError: if density matrix input is not a 2-qubit state.",
        "api_signature": "entanglement_of_formation(state)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/measures.py"
    },
    {
        "api_name": "negativity",
        "full_api_name": "negativity",
        "api_description": "Calculates the negativity\n\nThe mathematical expression for negativity is given by:\n.. math::\n    {\\cal{N}}(\\rho) = \\frac{|| \\rho^{T_A}|| - 1 }{2}\n\nArgs:\n    state (Statevector or DensityMatrix): a quantum state.\n    qargs (list): The subsystems to be transposed.\n\nReturns:\n    negv (float): Negativity value of the quantum state\n\nRaises:\n    QiskitError: if the input state is not a valid QuantumState.",
        "api_signature": "negativity(state, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/states/measures.py"
    },
    {
        "api_name": "make_dict_observable",
        "full_api_name": "make_dict_observable",
        "api_description": "Convert an observable in matrix form to dictionary form.\n\nTakes in a diagonal observable as a matrix and converts it to a dictionary\nform. Can also handle a list sorted of the diagonal elements.\n\nArgs:\n    matrix_observable (list): The observable to be converted to dictionary\n    form. Can be a matrix or just an ordered list of observed values\n\nReturns:\n    Dict: A dictionary with all observable states as keys, and corresponding\n    values being the observed value for that state",
        "api_signature": "make_dict_observable(matrix_observable)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/analysis/make_observable.py"
    },
    {
        "api_name": "hellinger_distance",
        "full_api_name": "hellinger_distance",
        "api_description": "Computes the Hellinger distance between\ntwo counts distributions.\n\nParameters:\n    dist_p (dict): First dict of counts.\n    dist_q (dict): Second dict of counts.\n\nReturns:\n    float: Distance\n\nReferences:\n    `Hellinger Distance @ wikipedia <https://en.wikipedia.org/wiki/Hellinger_distance>`_",
        "api_signature": "hellinger_distance(dist_p, dist_q)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/analysis/distance.py"
    },
    {
        "api_name": "hellinger_fidelity",
        "full_api_name": "hellinger_fidelity",
        "api_description": "Computes the Hellinger fidelity between\ntwo counts distributions.\n\nThe fidelity is defined as :math:`\\left(1-H^{2}\\right)^{2}` where H is the\nHellinger distance.  This value is bounded in the range [0, 1].\n\nThis is equivalent to the standard classical fidelity\n:math:`F(Q,P)=\\left(\\sum_{i}\\sqrt{p_{i}q_{i}}\\right)^{2}` that in turn\nis equal to the quantum state fidelity for diagonal density matrices.\n\nParameters:\n    dist_p (dict): First dict of counts.\n    dist_q (dict): Second dict of counts.\n\nReturns:\n    float: Fidelity\n\nExample:\n\n    .. code-block::\n\n        from qiskit import QuantumCircuit\n        from qiskit.quantum_info.analysis import hellinger_fidelity\n        from qiskit.providers.basic_provider import BasicSimulator\n\n        qc = QuantumCircuit(5, 5)\n        qc.h(2)\n        qc.cx(2, 1)\n        qc.cx(2, 3)\n        qc.cx(3, 4)\n        qc.cx(1, 0)\n        qc.measure(range(5), range(5))\n\n        sim = BasicSimulator()\n        res1 = sim.run(qc).result()\n        res2 = sim.run(qc).result()\n\n        hellinger_fidelity(res1.get_counts(), res2.get_counts())\n\nReferences:\n    `Quantum Fidelity @ wikipedia <https://en.wikipedia.org/wiki/Fidelity_of_quantum_states>`_\n    `Hellinger Distance @ wikipedia <https://en.wikipedia.org/wiki/Hellinger_distance>`_",
        "api_signature": "hellinger_fidelity(dist_p, dist_q)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/analysis/distance.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Z2Symmetries.__init__",
        "api_description": "Args:\n    symmetries: Object representing the list of $Z_2$ symmetries. These correspond to\n        the generators of the symmetry group $\\langle \\tau_1, \\tau_2\\dots \\rangle>$.\n    sq_paulis: Object representing the list of single-qubit Pauli $\\sigma^x_{q(i)}$\n        anti-commuting with the symmetry $\\tau_i$ and commuting with all the other symmetries\n        $\\tau_{j\\neq i}$. These operators are used to construct the unitary Clifford operators.\n    sq_list: The list of indices $q(i)$ of the single-qubit Pauli operators used to build the\n        Clifford operators.\n    tapering_values: List of eigenvalues determining the symmetry sector for each symmetry.\n    tol: Tolerance threshold for ignoring real and complex parts of a coefficient.\n\nRaises:\n    QiskitError: Invalid paulis. The lists of symmetries, single-qubit paulis support paulis\n        and tapering values must be of equal length. This length is the number of applied\n        symmetries and translates directly to the number of eliminated qubits.",
        "api_signature": "__init__(self, symmetries, sq_paulis, sq_list, tapering_values)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/analysis/z2_symmetries.py"
    },
    {
        "api_name": "symmetries",
        "full_api_name": "Z2Symmetries.symmetries",
        "api_description": "Return symmetries.",
        "api_signature": "symmetries(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/analysis/z2_symmetries.py"
    },
    {
        "api_name": "sq_paulis",
        "full_api_name": "Z2Symmetries.sq_paulis",
        "api_description": "Return sq paulis.",
        "api_signature": "sq_paulis(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/analysis/z2_symmetries.py"
    },
    {
        "api_name": "cliffords",
        "full_api_name": "Z2Symmetries.cliffords",
        "api_description": "Get clifford operators, built based on symmetries and single-qubit X.\n\nReturns:\n    A list of unitaries used to diagonalize the Hamiltonian.",
        "api_signature": "cliffords(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/analysis/z2_symmetries.py"
    },
    {
        "api_name": "sq_list",
        "full_api_name": "Z2Symmetries.sq_list",
        "api_description": "Return sq list.",
        "api_signature": "sq_list(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/analysis/z2_symmetries.py"
    },
    {
        "api_name": "settings",
        "full_api_name": "Z2Symmetries.settings",
        "api_description": "Return operator settings.",
        "api_signature": "settings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/analysis/z2_symmetries.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "Z2Symmetries.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/analysis/z2_symmetries.py"
    },
    {
        "api_name": "is_empty",
        "full_api_name": "Z2Symmetries.is_empty",
        "api_description": "Check the z2_symmetries is empty or not.\n\nReturns:\n    Empty or not.",
        "api_signature": "is_empty(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/analysis/z2_symmetries.py"
    },
    {
        "api_name": "find_z2_symmetries",
        "full_api_name": "Z2Symmetries.find_z2_symmetries",
        "api_description": "Finds Z2 Pauli-type symmetries of a :class:`.SparsePauliOp`.\n\nReturns:\n    A ``Z2Symmetries`` instance.",
        "api_signature": "find_z2_symmetries(cls, operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/analysis/z2_symmetries.py"
    },
    {
        "api_name": "_test_symmetry_row_col",
        "full_api_name": "Z2Symmetries._test_symmetry_row_col",
        "api_description": "Utility method that determines how to build the list of single-qubit Pauli X operators and\nthe list of corresponding qubit indices from the stacked symmetries.\nThis method is successively applied to Z type, X type and Y type symmetries (in this order)\nto build the letter at position (col) of the Pauli word corresponding to the symmetry at\nposition (row).\n\nArgs:\n    row (int): Index of the symmetry for which the single-qubit Pauli X operator is being\n        built.\n    col (int): Index of the letter in the Pauli word corresponding to the single-qubit Pauli\n        X operator.\n    idx_test (list): List of possibilities for the stacked symmetries at all other rows\n        than row.\n    row_test (list): List of possibilities for the stacked symmetries at row.\n\nReturns:\n    Whether or not this symmetry type should be used to build this letter of this\n    single-qubit Pauli X operator.",
        "api_signature": "_test_symmetry_row_col(row, col, idx_test, row_test)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/analysis/z2_symmetries.py"
    },
    {
        "api_name": "convert_clifford",
        "full_api_name": "Z2Symmetries.convert_clifford",
        "api_description": "This method operates the first part of the tapering.\nIt converts the operator by composing it with the clifford unitaries defined in the current\nsymmetry.\n\nArgs:\n    operator: The to-be-tapered operator.\n\nReturns:\n    ``SparsePauliOp`` corresponding to the converted operator.",
        "api_signature": "convert_clifford(self, operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/analysis/z2_symmetries.py"
    },
    {
        "api_name": "taper_clifford",
        "full_api_name": "Z2Symmetries.taper_clifford",
        "api_description": "Operate the second part of the tapering.\nThis function assumes that the input operators have already been transformed using\n:meth:`convert_clifford`. The redundant qubits due to the symmetries are dropped and\nreplaced by their two possible eigenvalues.\n\nArgs:\n    operator: Partially tapered operator resulting from a call to :meth:`convert_clifford`.\n\nReturns:\n    If tapering_values is None: [:class:`SparsePauliOp`]; otherwise, :class:`SparsePauliOp`.",
        "api_signature": "taper_clifford(self, operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/analysis/z2_symmetries.py"
    },
    {
        "api_name": "taper",
        "full_api_name": "Z2Symmetries.taper",
        "api_description": "Taper an operator based on the z2_symmetries info and sector defined by `tapering_values`.\nReturns operator if the symmetry object is empty.\n\nThe tapering is a two-step algorithm which first converts the operator into a\n:class:`SparsePauliOp` with same eigenvalues but where some qubits are only acted upon\nwith the Pauli operators I or X.\nThe number M of these redundant qubits is equal to the number M of identified symmetries.\n\nThe second step of the reduction consists in replacing these qubits with the possible\neigenvalues of the corresponding Pauli X, giving 2^M new operators with M less qubits.\nIf an eigenvalue sector was previously identified for the solution, then this reduces to\n1 new operator with M less qubits.\n\nArgs:\n    operator: The to-be-tapered operator.\n\nReturns:\n    If tapering_values is None: [:class:`SparsePauliOp`]; otherwise, :class:`SparsePauliOp`.",
        "api_signature": "taper(self, operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/analysis/z2_symmetries.py"
    },
    {
        "api_name": "_taper",
        "full_api_name": "Z2Symmetries._taper",
        "api_description": "",
        "api_signature": "_taper(self, op, curr_tapering_values)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/analysis/z2_symmetries.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "Z2Symmetries.__eq__",
        "api_description": "Overload `==` operation to evaluate equality between Z2Symmetries.\n\nArgs:\n    other: The `Z2Symmetries` to compare to self.\n\nReturns:\n    A bool equal to the equality of self and other.",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/analysis/z2_symmetries.py"
    },
    {
        "api_name": "_kernel_f2",
        "full_api_name": "_kernel_f2",
        "api_description": "Compute the kernel of a binary matrix on the binary finite field.\n\nArgs:\n    matrix_in (numpy.ndarray): Binary matrix.\n\nReturns:\n    The list of kernel vectors.",
        "api_signature": "_kernel_f2(matrix_in)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/analysis/z2_symmetries.py"
    },
    {
        "api_name": "_row_echelon_f2",
        "full_api_name": "_row_echelon_f2",
        "api_description": "Compute the row Echelon form of a binary matrix on the binary finite field.\n\nArgs:\n    matrix_in (numpy.ndarray): Binary matrix.\n\nReturns:\n    Matrix_in in Echelon row form.",
        "api_signature": "_row_echelon_f2(matrix_in)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/analysis/z2_symmetries.py"
    },
    {
        "api_name": "_sparse_pauli_op_is_zero",
        "full_api_name": "_sparse_pauli_op_is_zero",
        "api_description": "Returns whether or not this operator represents a zero operation.",
        "api_signature": "_sparse_pauli_op_is_zero(op)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/analysis/z2_symmetries.py"
    },
    {
        "api_name": "average_data",
        "full_api_name": "average_data",
        "api_description": "Compute the mean value of an diagonal observable.\n\nTakes in a diagonal observable in dictionary, list or matrix format and then\ncalculates the sum_i value(i) P(i) where value(i) is the value of the\nobservable for state i.\n\nArgs:\n    counts (dict): a dict of outcomes from an experiment\n    observable (dict or matrix or list): The observable to be averaged over.\n    As an example, ZZ on qubits can be given as:\n    * dict: {\"00\": 1, \"11\": 1, \"01\": -1, \"10\": -1}\n    * matrix: [[1, 0, 0, 0], [0, -1, 0, 0, ], [0, 0, -1, 0], [0, 0, 0, 1]]\n    * matrix diagonal (list): [1, -1, -1, 1]\n\nReturns:\n    Double: Average of the observable",
        "api_signature": "average_data(counts, observable)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/analysis/average.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "ScalarOp.__init__",
        "api_description": "Initialize an operator object.\n\nArgs:\n    dims (int or tuple): subsystem dimensions.\n    coeff (Number): scalar coefficient for the identity\n                    operator (Default: 1).\n\nRaises:\n    QiskitError: If the optional coefficient is invalid.",
        "api_signature": "__init__(self, dims, coeff)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/scalar_op.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "ScalarOp.__array__",
        "api_description": "",
        "api_signature": "__array__(self, dtype, copy)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/scalar_op.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "ScalarOp.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/scalar_op.py"
    },
    {
        "api_name": "coeff",
        "full_api_name": "ScalarOp.coeff",
        "api_description": "Return the coefficient",
        "api_signature": "coeff(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/scalar_op.py"
    },
    {
        "api_name": "conjugate",
        "full_api_name": "ScalarOp.conjugate",
        "api_description": "",
        "api_signature": "conjugate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/scalar_op.py"
    },
    {
        "api_name": "transpose",
        "full_api_name": "ScalarOp.transpose",
        "api_description": "",
        "api_signature": "transpose(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/scalar_op.py"
    },
    {
        "api_name": "is_unitary",
        "full_api_name": "ScalarOp.is_unitary",
        "api_description": "Return True if operator is a unitary matrix.",
        "api_signature": "is_unitary(self, atol, rtol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/scalar_op.py"
    },
    {
        "api_name": "to_matrix",
        "full_api_name": "ScalarOp.to_matrix",
        "api_description": "Convert to a Numpy matrix.",
        "api_signature": "to_matrix(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/scalar_op.py"
    },
    {
        "api_name": "to_operator",
        "full_api_name": "ScalarOp.to_operator",
        "api_description": "Convert to an Operator object.",
        "api_signature": "to_operator(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/scalar_op.py"
    },
    {
        "api_name": "compose",
        "full_api_name": "ScalarOp.compose",
        "api_description": "",
        "api_signature": "compose(self, other, qargs, front)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/scalar_op.py"
    },
    {
        "api_name": "power",
        "full_api_name": "ScalarOp.power",
        "api_description": "Return the power of the ScalarOp.\n\nArgs:\n    n (float): the exponent for the scalar op.\n\nReturns:\n    ScalarOp: the ``coeff ** n`` ScalarOp.",
        "api_signature": "power(self, n)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/scalar_op.py"
    },
    {
        "api_name": "tensor",
        "full_api_name": "ScalarOp.tensor",
        "api_description": "",
        "api_signature": "tensor(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/scalar_op.py"
    },
    {
        "api_name": "expand",
        "full_api_name": "ScalarOp.expand",
        "api_description": "",
        "api_signature": "expand(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/scalar_op.py"
    },
    {
        "api_name": "_add",
        "full_api_name": "ScalarOp._add",
        "api_description": "Return the operator self + other.\n\nIf ``qargs`` are specified the other operator will be added\nassuming it is identity on all other subsystems.\n\nArgs:\n    other (BaseOperator): an operator object.\n    qargs (None or list): optional subsystems to subtract on\n                          (Default: None)\n\nReturns:\n    ScalarOp: if other is an ScalarOp.\n    BaseOperator: if other is not an ScalarOp.\n\nRaises:\n    QiskitError: if other has incompatible dimensions.",
        "api_signature": "_add(self, other, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/scalar_op.py"
    },
    {
        "api_name": "_multiply",
        "full_api_name": "ScalarOp._multiply",
        "api_description": "Return the ScalarOp other * self.\n\nArgs:\n    other (Number): a complex number.\n\nReturns:\n    ScalarOp: the scaled identity operator other * self.\n\nRaises:\n    QiskitError: if other is not a valid complex number.",
        "api_signature": "_multiply(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/scalar_op.py"
    },
    {
        "api_name": "_pad_with_identity",
        "full_api_name": "ScalarOp._pad_with_identity",
        "api_description": "Pad another operator with identities.\n\nArgs:\n    current (BaseOperator): current operator.\n    other (BaseOperator): other operator.\n    qargs (None or list): qargs\n\nReturns:\n    BaseOperator: the padded operator.",
        "api_signature": "_pad_with_identity(current, other, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/scalar_op.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Operator.__init__",
        "api_description": "Initialize an operator object.\n\nArgs:\n    data (QuantumCircuit or Operation or BaseOperator or matrix):\n                        data to initialize operator.\n    input_dims (tuple): the input subsystem dimensions.\n                        [Default: None]\n    output_dims (tuple): the output subsystem dimensions.\n                         [Default: None]\n\nRaises:\n    QiskitError: if input data cannot be initialized as an operator.\n\nAdditional Information:\n    If the input or output dimensions are None, they will be\n    automatically determined from the input data. If the input data is\n    a Numpy array of shape (2**N, 2**N) qubit systems will be used. If\n    the input operator is not an N-qubit operator, it will assign a\n    single subsystem with dimension specified by the shape of the input.\n    Note that two operators initialized via this method are only considered equivalent if they\n    match up to their canonical qubit order (or: permutation). See :meth:`.Operator.from_circuit`\n    to specify a different qubit permutation.",
        "api_signature": "__init__(self, data, input_dims, output_dims)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/operator.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "Operator.__array__",
        "api_description": "",
        "api_signature": "__array__(self, dtype, copy)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/operator.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "Operator.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/operator.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "Operator.__eq__",
        "api_description": "Test if two Operators are equal.",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/operator.py"
    },
    {
        "api_name": "data",
        "full_api_name": "Operator.data",
        "api_description": "The underlying Numpy array.",
        "api_signature": "data(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/operator.py"
    },
    {
        "api_name": "settings",
        "full_api_name": "Operator.settings",
        "api_description": "Return operator settings.",
        "api_signature": "settings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/operator.py"
    },
    {
        "api_name": "draw",
        "full_api_name": "Operator.draw",
        "api_description": "Return a visualization of the Operator.\n\n**repr**: String of the state's ``__repr__``.\n\n**text**: ASCII TextMatrix that can be printed in the console.\n\n**latex**: An IPython Latex object for displaying in Jupyter Notebooks.\n\n**latex_source**: Raw, uncompiled ASCII source to generate array using LaTeX.\n\nArgs:\n    output (str): Select the output method to use for drawing the\n        state. Valid choices are `repr`, `text`, `latex`, `latex_source`,\n        Default is `repr`.\n    drawer_args: Arguments to be passed directly to the relevant drawing\n        function or constructor (`TextMatrix()`, `array_to_latex()`).\n        See the relevant function under `qiskit.visualization` for that function's\n        documentation.\n\nReturns:\n    :class:`str` or :class:`TextMatrix` or :class:`IPython.display.Latex`:\n    Drawing of the Operator.\n\nRaises:\n    ValueError: when an invalid output method is selected.",
        "api_signature": "draw(self, output)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/operator.py"
    },
    {
        "api_name": "_ipython_display_",
        "full_api_name": "Operator._ipython_display_",
        "api_description": "",
        "api_signature": "_ipython_display_(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/operator.py"
    },
    {
        "api_name": "from_label",
        "full_api_name": "Operator.from_label",
        "api_description": "Return a tensor product of single-qubit operators.\n\nArgs:\n    label (string): single-qubit operator string.\n\nReturns:\n    Operator: The N-qubit operator.\n\nRaises:\n    QiskitError: if the label contains invalid characters, or the\n                 length of the label is larger than an explicitly\n                 specified num_qubits.\n\nAdditional Information:\n    The labels correspond to the single-qubit matrices:\n    'I': [[1, 0], [0, 1]]\n    'X': [[0, 1], [1, 0]]\n    'Y': [[0, -1j], [1j, 0]]\n    'Z': [[1, 0], [0, -1]]\n    'H': [[1, 1], [1, -1]] / sqrt(2)\n    'S': [[1, 0], [0 , 1j]]\n    'T': [[1, 0], [0, (1+1j) / sqrt(2)]]\n    '0': [[1, 0], [0, 0]]\n    '1': [[0, 0], [0, 1]]\n    '+': [[0.5, 0.5], [0.5 , 0.5]]\n    '-': [[0.5, -0.5], [-0.5 , 0.5]]\n    'r': [[0.5, -0.5j], [0.5j , 0.5]]\n    'l': [[0.5, 0.5j], [-0.5j , 0.5]]",
        "api_signature": "from_label(cls, label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/operator.py"
    },
    {
        "api_name": "apply_permutation",
        "full_api_name": "Operator.apply_permutation",
        "api_description": "Modifies operator's data by composing it with a permutation.\n\nArgs:\n    perm (list): permutation pattern, describing which qubits\n        occupy the positions 0, 1, 2, etc. after applying the permutation.\n    front (bool): When set to ``True`` the permutation is applied before the\n        operator, when set to ``False`` the permutation is applied after the\n        operator.\nReturns:\n    Operator: The modified operator.\n\nRaises:\n    QiskitError: if the size of the permutation pattern does not match the\n        dimensions of the operator.",
        "api_signature": "apply_permutation(self, perm, front)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/operator.py"
    },
    {
        "api_name": "from_circuit",
        "full_api_name": "Operator.from_circuit",
        "api_description": "Create a new Operator object from a :class:`.QuantumCircuit`\n\nWhile a :class:`~.QuantumCircuit` object can passed directly as ``data``\nto the class constructor this provides no options on how the circuit\nis used to create an :class:`.Operator`. This constructor method lets\nyou control how the :class:`.Operator` is created so it can be adjusted\nfor a particular use case.\n\nBy default this constructor method will permute the qubits based on a\nconfigured initial layout (i.e. after it was transpiled). It also\nprovides an option to manually provide a :class:`.Layout` object\ndirectly.\n\nArgs:\n    circuit (QuantumCircuit): The :class:`.QuantumCircuit` to create an Operator\n        object from.\n    ignore_set_layout (bool): When set to ``True`` if the input ``circuit``\n        has a layout set it will be ignored\n    layout (Layout): If specified this kwarg can be used to specify a\n        particular layout to use to permute the qubits in the created\n        :class:`.Operator`. If this is specified it will be used instead\n        of a layout contained in the ``circuit`` input. If specified\n        the virtual bits in the :class:`~.Layout` must be present in the\n        ``circuit`` input.\n    final_layout (Layout): If specified this kwarg can be used to represent the\n        output permutation caused by swap insertions during the routing stage\n        of the transpiler.\nReturns:\n    Operator: An operator representing the input circuit",
        "api_signature": "from_circuit(cls, circuit, ignore_set_layout, layout, final_layout)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/operator.py"
    },
    {
        "api_name": "is_unitary",
        "full_api_name": "Operator.is_unitary",
        "api_description": "Return True if operator is a unitary matrix.",
        "api_signature": "is_unitary(self, atol, rtol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/operator.py"
    },
    {
        "api_name": "to_operator",
        "full_api_name": "Operator.to_operator",
        "api_description": "Convert operator to matrix operator class",
        "api_signature": "to_operator(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/operator.py"
    },
    {
        "api_name": "to_instruction",
        "full_api_name": "Operator.to_instruction",
        "api_description": "Convert to a UnitaryGate instruction.",
        "api_signature": "to_instruction(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/operator.py"
    },
    {
        "api_name": "conjugate",
        "full_api_name": "Operator.conjugate",
        "api_description": "",
        "api_signature": "conjugate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/operator.py"
    },
    {
        "api_name": "transpose",
        "full_api_name": "Operator.transpose",
        "api_description": "",
        "api_signature": "transpose(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/operator.py"
    },
    {
        "api_name": "compose",
        "full_api_name": "Operator.compose",
        "api_description": "",
        "api_signature": "compose(self, other, qargs, front)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/operator.py"
    },
    {
        "api_name": "power",
        "full_api_name": "Operator.power",
        "api_description": "Return the matrix power of the operator.\n\nArgs:\n    n (float): the power to raise the matrix to.\n\nReturns:\n    Operator: the resulting operator ``O ** n``.\n\nRaises:\n    QiskitError: if the input and output dimensions of the operator\n                 are not equal.",
        "api_signature": "power(self, n)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/operator.py"
    },
    {
        "api_name": "tensor",
        "full_api_name": "Operator.tensor",
        "api_description": "",
        "api_signature": "tensor(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/operator.py"
    },
    {
        "api_name": "expand",
        "full_api_name": "Operator.expand",
        "api_description": "",
        "api_signature": "expand(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/operator.py"
    },
    {
        "api_name": "_tensor",
        "full_api_name": "Operator._tensor",
        "api_description": "",
        "api_signature": "_tensor(cls, a, b)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/operator.py"
    },
    {
        "api_name": "_add",
        "full_api_name": "Operator._add",
        "api_description": "Return the operator self + other.\n\nIf ``qargs`` are specified the other operator will be added\nassuming it is identity on all other subsystems.\n\nArgs:\n    other (Operator): an operator object.\n    qargs (None or list): optional subsystems to add on\n                          (Default: None)\n\nReturns:\n    Operator: the operator self + other.\n\nRaises:\n    QiskitError: if other is not an operator, or has incompatible\n                 dimensions.",
        "api_signature": "_add(self, other, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/operator.py"
    },
    {
        "api_name": "_multiply",
        "full_api_name": "Operator._multiply",
        "api_description": "Return the operator self * other.\n\nArgs:\n    other (complex): a complex number.\n\nReturns:\n    Operator: the operator other * self.\n\nRaises:\n    QiskitError: if other is not a valid complex number.",
        "api_signature": "_multiply(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/operator.py"
    },
    {
        "api_name": "equiv",
        "full_api_name": "Operator.equiv",
        "api_description": "Return True if operators are equivalent up to global phase.\n\nArgs:\n    other (Operator): an operator object.\n    rtol (float): relative tolerance value for comparison.\n    atol (float): absolute tolerance value for comparison.\n\nReturns:\n    bool: True if operators are equivalent up to global phase.",
        "api_signature": "equiv(self, other, rtol, atol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/operator.py"
    },
    {
        "api_name": "reverse_qargs",
        "full_api_name": "Operator.reverse_qargs",
        "api_description": "Return an Operator with reversed subsystem ordering.\n\nFor a tensor product operator this is equivalent to reversing\nthe order of tensor product subsystems. For an operator\n:math:`A = A_{n-1} \\otimes ... \\otimes A_0`\nthe returned operator will be\n:math:`A_0 \\otimes ... \\otimes A_{n-1}`.\n\nReturns:\n    Operator: the operator with reversed subsystem order.",
        "api_signature": "reverse_qargs(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/operator.py"
    },
    {
        "api_name": "to_matrix",
        "full_api_name": "Operator.to_matrix",
        "api_description": "Convert operator to NumPy matrix.",
        "api_signature": "to_matrix(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/operator.py"
    },
    {
        "api_name": "_einsum_matmul",
        "full_api_name": "Operator._einsum_matmul",
        "api_description": "Perform a contraction using Numpy.einsum\n\nArgs:\n    tensor (np.array): a vector or matrix reshaped to a rank-N tensor.\n    mat (np.array): a matrix reshaped to a rank-2M tensor.\n    indices (list): tensor indices to contract with mat.\n    shift (int): shift for indices of tensor to contract [Default: 0].\n    right_mul (bool): if True right multiply tensor by mat\n                      (else left multiply) [Default: False].\n\nReturns:\n    Numpy.ndarray: the matrix multiplied rank-N tensor.\n\nRaises:\n    QiskitError: if mat is not an even rank tensor.",
        "api_signature": "_einsum_matmul(cls, tensor, mat, indices, shift, right_mul)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/operator.py"
    },
    {
        "api_name": "_init_instruction",
        "full_api_name": "Operator._init_instruction",
        "api_description": "Convert a QuantumCircuit or Operation to an Operator.",
        "api_signature": "_init_instruction(cls, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/operator.py"
    },
    {
        "api_name": "_instruction_to_matrix",
        "full_api_name": "Operator._instruction_to_matrix",
        "api_description": "Return Operator for instruction if defined or None otherwise.",
        "api_signature": "_instruction_to_matrix(cls, obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/operator.py"
    },
    {
        "api_name": "_append_instruction",
        "full_api_name": "Operator._append_instruction",
        "api_description": "Update the current Operator by apply an instruction.",
        "api_signature": "_append_instruction(self, obj, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/operator.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BaseOperator.__init__",
        "api_description": "Initialize a BaseOperator shape\n\nArgs:\n    input_dims (tuple or int or None): Optional, input dimensions.\n    output_dims (tuple or int or None): Optional, output dimensions.\n    num_qubits (int): Optional, the number of qubits of the operator.\n    shape (tuple): Optional, matrix shape for automatically determining\n                   qubit dimensions.\n    op_shape (OpShape): Optional, an OpShape object for operator dimensions.\n\n.. note::\n\n    If `op_shape`` is specified it will take precedence over other\n    kwargs.",
        "api_signature": "__init__(self, input_dims, output_dims, num_qubits, shape, op_shape)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/base_operator.py"
    },
    {
        "api_name": "__call__",
        "full_api_name": "BaseOperator.__call__",
        "api_description": "Return a shallow copy with qargs attribute set",
        "api_signature": "__call__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/base_operator.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "BaseOperator.__eq__",
        "api_description": "",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/base_operator.py"
    },
    {
        "api_name": "qargs",
        "full_api_name": "BaseOperator.qargs",
        "api_description": "Return the qargs for the operator.",
        "api_signature": "qargs(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/base_operator.py"
    },
    {
        "api_name": "dim",
        "full_api_name": "BaseOperator.dim",
        "api_description": "Return tuple (input_shape, output_shape).",
        "api_signature": "dim(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/base_operator.py"
    },
    {
        "api_name": "num_qubits",
        "full_api_name": "BaseOperator.num_qubits",
        "api_description": "Return the number of qubits if a N-qubit operator or None otherwise.",
        "api_signature": "num_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/base_operator.py"
    },
    {
        "api_name": "_input_dim",
        "full_api_name": "BaseOperator._input_dim",
        "api_description": "Return the total input dimension.",
        "api_signature": "_input_dim(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/base_operator.py"
    },
    {
        "api_name": "_output_dim",
        "full_api_name": "BaseOperator._output_dim",
        "api_description": "Return the total input dimension.",
        "api_signature": "_output_dim(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/base_operator.py"
    },
    {
        "api_name": "reshape",
        "full_api_name": "BaseOperator.reshape",
        "api_description": "Return a shallow copy with reshaped input and output subsystem dimensions.\n\nArgs:\n    input_dims (None or tuple): new subsystem input dimensions.\n        If None the original input dims will be preserved [Default: None].\n    output_dims (None or tuple): new subsystem output dimensions.\n        If None the original output dims will be preserved [Default: None].\n    num_qubits (None or int): reshape to an N-qubit operator [Default: None].\n\nReturns:\n    BaseOperator: returns self with reshaped input and output dimensions.\n\nRaises:\n    QiskitError: if combined size of all subsystem input dimension or\n                 subsystem output dimensions is not constant.",
        "api_signature": "reshape(self, input_dims, output_dims, num_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/base_operator.py"
    },
    {
        "api_name": "input_dims",
        "full_api_name": "BaseOperator.input_dims",
        "api_description": "Return tuple of input dimension for specified subsystems.",
        "api_signature": "input_dims(self, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/base_operator.py"
    },
    {
        "api_name": "output_dims",
        "full_api_name": "BaseOperator.output_dims",
        "api_description": "Return tuple of output dimension for specified subsystems.",
        "api_signature": "output_dims(self, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/base_operator.py"
    },
    {
        "api_name": "copy",
        "full_api_name": "BaseOperator.copy",
        "api_description": "Make a deep copy of current operator.",
        "api_signature": "copy(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/base_operator.py"
    },
    {
        "api_name": "matrix_equal",
        "full_api_name": "matrix_equal",
        "api_description": "",
        "api_signature": "matrix_equal(mat1, mat2, ignore_phase, rtol, atol, props)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/predicates.py"
    },
    {
        "api_name": "is_square_matrix",
        "full_api_name": "is_square_matrix",
        "api_description": "Test if an array is a square matrix.",
        "api_signature": "is_square_matrix(mat)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/predicates.py"
    },
    {
        "api_name": "is_diagonal_matrix",
        "full_api_name": "is_diagonal_matrix",
        "api_description": "Test if an array is a diagonal matrix",
        "api_signature": "is_diagonal_matrix(mat, rtol, atol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/predicates.py"
    },
    {
        "api_name": "is_symmetric_matrix",
        "full_api_name": "is_symmetric_matrix",
        "api_description": "Test if an array is a symmetric matrix",
        "api_signature": "is_symmetric_matrix(op, rtol, atol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/predicates.py"
    },
    {
        "api_name": "is_hermitian_matrix",
        "full_api_name": "is_hermitian_matrix",
        "api_description": "Test if an array is a Hermitian matrix",
        "api_signature": "is_hermitian_matrix(mat, rtol, atol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/predicates.py"
    },
    {
        "api_name": "is_positive_semidefinite_matrix",
        "full_api_name": "is_positive_semidefinite_matrix",
        "api_description": "Test if a matrix is positive semidefinite",
        "api_signature": "is_positive_semidefinite_matrix(mat, rtol, atol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/predicates.py"
    },
    {
        "api_name": "is_identity_matrix",
        "full_api_name": "is_identity_matrix",
        "api_description": "Test if an array is an identity matrix.",
        "api_signature": "is_identity_matrix(mat, ignore_phase, rtol, atol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/predicates.py"
    },
    {
        "api_name": "is_unitary_matrix",
        "full_api_name": "is_unitary_matrix",
        "api_description": "Test if an array is a unitary matrix.",
        "api_signature": "is_unitary_matrix(mat, rtol, atol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/predicates.py"
    },
    {
        "api_name": "is_isometry",
        "full_api_name": "is_isometry",
        "api_description": "Test if an array is an isometry.",
        "api_signature": "is_isometry(mat, rtol, atol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/predicates.py"
    },
    {
        "api_name": "random_unitary",
        "full_api_name": "random_unitary",
        "api_description": "Return a random unitary Operator.\n\nThe operator is sampled from the unitary Haar measure.\n\nArgs:\n    dims (int or tuple): the input dimensions of the Operator.\n    seed (int or np.random.Generator): Optional. Set a fixed seed or\n                                       generator for RNG.\n\nReturns:\n    Operator: a unitary operator.",
        "api_signature": "random_unitary(dims, seed)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/random.py"
    },
    {
        "api_name": "random_hermitian",
        "full_api_name": "random_hermitian",
        "api_description": "Return a random hermitian Operator.\n\nThe operator is sampled from Gaussian Unitary Ensemble.\n\nArgs:\n    dims (int or tuple): the input dimension of the Operator.\n    traceless (bool): Optional. If True subtract diagonal entries to\n                      return a traceless hermitian operator\n                      (Default: False).\n    seed (int or np.random.Generator): Optional. Set a fixed seed or\n                                       generator for RNG.\n\nReturns:\n    Operator: a Hermitian operator.",
        "api_signature": "random_hermitian(dims, traceless, seed)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/random.py"
    },
    {
        "api_name": "random_quantum_channel",
        "full_api_name": "random_quantum_channel",
        "api_description": "Return a random CPTP quantum channel.\n\nThis constructs the Stinespring operator for the quantum channel by\nsampling a random isometry from the unitary Haar measure.\n\nArgs:\n    input_dims (int or tuple): the input dimension of the channel.\n    output_dims (int or tuple): the input dimension of the channel.\n    rank (int): Optional. The rank of the quantum channel Choi-matrix.\n    seed (int or np.random.Generator): Optional. Set a fixed seed or\n                                       generator for RNG.\n\nReturns:\n    Stinespring: a quantum channel operator.\n\nRaises:\n    QiskitError: if rank or dimensions are invalid.",
        "api_signature": "random_quantum_channel(input_dims, output_dims, rank, seed)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/random.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "OpShape.__init__",
        "api_description": "Initialize an operator object.",
        "api_signature": "__init__(self, dims_l, dims_r, num_qargs_l, num_qargs_r)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/op_shape.py"
    },
    {
        "api_name": "settings",
        "full_api_name": "OpShape.settings",
        "api_description": "Return the settings of the ``OpShape`` as dictionary.",
        "api_signature": "settings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/op_shape.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "OpShape.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/op_shape.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "OpShape.__eq__",
        "api_description": "Check types and subsystem dimensions are equal",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/op_shape.py"
    },
    {
        "api_name": "copy",
        "full_api_name": "OpShape.copy",
        "api_description": "Make a deep copy of current operator.",
        "api_signature": "copy(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/op_shape.py"
    },
    {
        "api_name": "size",
        "full_api_name": "OpShape.size",
        "api_description": "Return the combined dimensions of the object",
        "api_signature": "size(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/op_shape.py"
    },
    {
        "api_name": "num_qubits",
        "full_api_name": "OpShape.num_qubits",
        "api_description": "Return number of qubits if shape is N-qubit.\n\nIf Shape is not N-qubit return None",
        "api_signature": "num_qubits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/op_shape.py"
    },
    {
        "api_name": "num_qargs",
        "full_api_name": "OpShape.num_qargs",
        "api_description": "Return a tuple of the number of left and right wires",
        "api_signature": "num_qargs(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/op_shape.py"
    },
    {
        "api_name": "shape",
        "full_api_name": "OpShape.shape",
        "api_description": "Return a tuple of the matrix shape",
        "api_signature": "shape(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/op_shape.py"
    },
    {
        "api_name": "tensor_shape",
        "full_api_name": "OpShape.tensor_shape",
        "api_description": "Return a tuple of the tensor shape",
        "api_signature": "tensor_shape(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/op_shape.py"
    },
    {
        "api_name": "is_square",
        "full_api_name": "OpShape.is_square",
        "api_description": "Return True if the left and right dimensions are equal.",
        "api_signature": "is_square(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/op_shape.py"
    },
    {
        "api_name": "dims_r",
        "full_api_name": "OpShape.dims_r",
        "api_description": "Return tuple of input dimension for specified subsystems.",
        "api_signature": "dims_r(self, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/op_shape.py"
    },
    {
        "api_name": "dims_l",
        "full_api_name": "OpShape.dims_l",
        "api_description": "Return tuple of output dimension for specified subsystems.",
        "api_signature": "dims_l(self, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/op_shape.py"
    },
    {
        "api_name": "_dim_r",
        "full_api_name": "OpShape._dim_r",
        "api_description": "Return the total input dimension.",
        "api_signature": "_dim_r(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/op_shape.py"
    },
    {
        "api_name": "_dim_l",
        "full_api_name": "OpShape._dim_l",
        "api_description": "Return the total input dimension.",
        "api_signature": "_dim_l(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/op_shape.py"
    },
    {
        "api_name": "validate_shape",
        "full_api_name": "OpShape.validate_shape",
        "api_description": "Raise an exception if shape is not valid for the OpShape",
        "api_signature": "validate_shape(self, shape)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/op_shape.py"
    },
    {
        "api_name": "_validate",
        "full_api_name": "OpShape._validate",
        "api_description": "Validate OpShape against a matrix or vector shape.",
        "api_signature": "_validate(self, shape, raise_exception)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/op_shape.py"
    },
    {
        "api_name": "auto",
        "full_api_name": "OpShape.auto",
        "api_description": "Construct TensorShape with automatic checking of qubit dimensions",
        "api_signature": "auto(cls, shape, dims_l, dims_r, dims, num_qubits_l, num_qubits_r, num_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/op_shape.py"
    },
    {
        "api_name": "subset",
        "full_api_name": "OpShape.subset",
        "api_description": "Return the reduced OpShape of the specified qargs",
        "api_signature": "subset(self, qargs, qargs_l, qargs_r)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/op_shape.py"
    },
    {
        "api_name": "remove",
        "full_api_name": "OpShape.remove",
        "api_description": "Return a new :class:`OpShape` with the specified qargs removed",
        "api_signature": "remove(self, qargs, qargs_l, qargs_r)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/op_shape.py"
    },
    {
        "api_name": "reverse",
        "full_api_name": "OpShape.reverse",
        "api_description": "Reverse order of left and right qargs",
        "api_signature": "reverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/op_shape.py"
    },
    {
        "api_name": "transpose",
        "full_api_name": "OpShape.transpose",
        "api_description": "Return the transposed OpShape.",
        "api_signature": "transpose(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/op_shape.py"
    },
    {
        "api_name": "tensor",
        "full_api_name": "OpShape.tensor",
        "api_description": "Return the tensor product OpShape",
        "api_signature": "tensor(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/op_shape.py"
    },
    {
        "api_name": "expand",
        "full_api_name": "OpShape.expand",
        "api_description": "Return the expand product OpShape",
        "api_signature": "expand(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/op_shape.py"
    },
    {
        "api_name": "_tensor",
        "full_api_name": "OpShape._tensor",
        "api_description": "Return the tensor product OpShape",
        "api_signature": "_tensor(cls, a, b)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/op_shape.py"
    },
    {
        "api_name": "compose",
        "full_api_name": "OpShape.compose",
        "api_description": "Return composed OpShape.",
        "api_signature": "compose(self, other, qargs, front)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/op_shape.py"
    },
    {
        "api_name": "dot",
        "full_api_name": "OpShape.dot",
        "api_description": "Return the dot product operator OpShape",
        "api_signature": "dot(self, other, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/op_shape.py"
    },
    {
        "api_name": "_validate_add",
        "full_api_name": "OpShape._validate_add",
        "api_description": "",
        "api_signature": "_validate_add(self, other, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/op_shape.py"
    },
    {
        "api_name": "process_fidelity",
        "full_api_name": "process_fidelity",
        "api_description": "Return the process fidelity of a noisy quantum channel.\n\n\nThe process fidelity :math:`F_{\\text{pro}}(\\mathcal{E}, \\mathcal{F})`\nbetween two quantum channels :math:`\\mathcal{E}, \\mathcal{F}` is given by\n\n.. math::\n    F_{\\text{pro}}(\\mathcal{E}, \\mathcal{F})\n        = F(\\rho_{\\mathcal{E}}, \\rho_{\\mathcal{F}})\n\nwhere :math:`F` is the :func:`~qiskit.quantum_info.state_fidelity`,\n:math:`\\rho_{\\mathcal{E}} = \\Lambda_{\\mathcal{E}} / d` is the\nnormalized :class:`~qiskit.quantum_info.Choi` matrix for the channel\n:math:`\\mathcal{E}`, and :math:`d` is the input dimension of\n:math:`\\mathcal{E}`.\n\nWhen the target channel is unitary this is equivalent to\n\n.. math::\n    F_{\\text{pro}}(\\mathcal{E}, U)\n        = \\frac{Tr[S_U^\\dagger S_{\\mathcal{E}}]}{d^2}\n\nwhere :math:`S_{\\mathcal{E}}, S_{U}` are the\n:class:`~qiskit.quantum_info.SuperOp` matrices for the *input* quantum\nchannel :math:`\\mathcal{E}` and *target* unitary :math:`U` respectively,\nand :math:`d` is the input dimension of the channel.\n\nArgs:\n    channel (Operator or QuantumChannel): input quantum channel.\n    target (Operator or QuantumChannel or None): target quantum channel.\n        If `None` target is the identity operator [Default: None].\n    require_cp (bool): check if input and target channels are\n                       completely-positive and if non-CP log warning\n                       containing negative eigenvalues of Choi-matrix\n                       [Default: True].\n    require_tp (bool): check if input and target channels are\n                       trace-preserving and if non-TP log warning\n                       containing negative eigenvalues of partial\n                       Choi-matrix :math:`Tr_{\\text{out}}[\\mathcal{E}] - I`\n                       [Default: True].\n\nReturns:\n    float: The process fidelity :math:`F_{\\text{pro}}`.\n\nRaises:\n    QiskitError: if the channel and target do not have the same dimensions.",
        "api_signature": "process_fidelity(channel, target, require_cp, require_tp)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/measures.py"
    },
    {
        "api_name": "average_gate_fidelity",
        "full_api_name": "average_gate_fidelity",
        "api_description": "Return the average gate fidelity of a noisy quantum channel.\n\nThe average gate fidelity :math:`F_{\\text{ave}}` is given by\n\n.. math::\n    \\begin{aligned}\n    F_{\\text{ave}}(\\mathcal{E}, U)\n        &= \\int d\\psi \\langle\\psi|U^\\dagger\n            \\mathcal{E}(|\\psi\\rangle\\!\\langle\\psi|)U|\\psi\\rangle \\\\\n        &= \\frac{d F_{\\text{pro}}(\\mathcal{E}, U) + 1}{d + 1}\n    \\end{aligned}\n\nwhere :math:`F_{\\text{pro}}(\\mathcal{E}, U)` is the\n:meth:`~qiskit.quantum_info.process_fidelity` of the input quantum\n*channel* :math:`\\mathcal{E}` with a *target* unitary :math:`U`, and\n:math:`d` is the dimension of the *channel*.\n\nArgs:\n    channel (QuantumChannel or Operator): noisy quantum channel.\n    target (Operator or None): target unitary operator.\n        If `None` target is the identity operator [Default: None].\n    require_cp (bool): check if input and target channels are\n                       completely-positive and if non-CP log warning\n                       containing negative eigenvalues of Choi-matrix\n                       [Default: True].\n    require_tp (bool): check if input and target channels are\n                       trace-preserving and if non-TP log warning\n                       containing negative eigenvalues of partial\n                       Choi-matrix :math:`Tr_{\\text{out}}[\\mathcal{E}] - I`\n                       [Default: True].\n\nReturns:\n    float: The average gate fidelity :math:`F_{\\text{ave}}`.\n\nRaises:\n    QiskitError: if the channel and target do not have the same dimensions,\n                 or have different input and output dimensions.",
        "api_signature": "average_gate_fidelity(channel, target, require_cp, require_tp)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/measures.py"
    },
    {
        "api_name": "gate_error",
        "full_api_name": "gate_error",
        "api_description": "Return the gate error of a noisy quantum channel.\n\nThe gate error :math:`E` is given by the average gate infidelity\n\n.. math::\n    E(\\mathcal{E}, U) = 1 - F_{\\text{ave}}(\\mathcal{E}, U)\n\nwhere :math:`F_{\\text{ave}}(\\mathcal{E}, U)` is the\n:meth:`~qiskit.quantum_info.average_gate_fidelity` of the input\nquantum *channel* :math:`\\mathcal{E}` with a *target* unitary\n:math:`U`.\n\nArgs:\n    channel (QuantumChannel): noisy quantum channel.\n    target (Operator or None): target unitary operator.\n        If `None` target is the identity operator [Default: None].\n    require_cp (bool): check if input and target channels are\n                       completely-positive and if non-CP log warning\n                       containing negative eigenvalues of Choi-matrix\n                       [Default: True].\n    require_tp (bool): check if input and target channels are\n                       trace-preserving and if non-TP log warning\n                       containing negative eigenvalues of partial\n                       Choi-matrix :math:`Tr_{\\text{out}}[\\mathcal{E}] - I`\n                       [Default: True].\n\nReturns:\n    float: The average gate error :math:`E`.\n\nRaises:\n    QiskitError: if the channel and target do not have the same dimensions,\n                 or have different input and output dimensions.",
        "api_signature": "gate_error(channel, target, require_cp, require_tp)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/measures.py"
    },
    {
        "api_name": "diamond_norm",
        "full_api_name": "diamond_norm",
        "api_description": "Return the diamond norm of the input quantum channel object.\n\nThis function computes the completely-bounded trace-norm (often\nreferred to as the diamond-norm) of the input quantum channel object\nusing the semidefinite-program from reference [1].\n\nArgs:\n    choi(Choi or QuantumChannel): a quantum channel object or\n                                  Choi-matrix array.\n    solver (str): The solver to use.\n    kwargs: optional arguments to pass to CVXPY solver.\n\nReturns:\n    float: The completely-bounded trace norm :math:`\\|\\mathcal{E}\\|_{\\diamond}`.\n\nRaises:\n    QiskitError: if CVXPY package cannot be found.\n\nAdditional Information:\n    The input to this function is typically *not* a CPTP quantum\n    channel, but rather the *difference* between two quantum channels\n    :math:`\\|\\Delta\\mathcal{E}\\|_\\diamond` where\n    :math:`\\Delta\\mathcal{E} = \\mathcal{E}_1 - \\mathcal{E}_2`.\n\nReference:\n    J. Watrous. \"Simpler semidefinite programs for completely bounded\n    norms\", arXiv:1207.5726 [quant-ph] (2012).\n\n.. note::\n\n    This function requires the optional CVXPY package to be installed.\n    Any additional kwargs will be passed to the ``cvxpy.solve``\n    function. See the CVXPY documentation for information on available\n    SDP solvers.",
        "api_signature": "diamond_norm(choi, solver)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/measures.py"
    },
    {
        "api_name": "cvx_bmat",
        "full_api_name": "cvx_bmat",
        "api_description": "Block matrix for embedding complex matrix in reals",
        "api_signature": "cvx_bmat(mat_r, mat_i)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/measures.py"
    },
    {
        "api_name": "_cvxpy_check",
        "full_api_name": "_cvxpy_check",
        "api_description": "Check that a supported CVXPY version is installed",
        "api_signature": "_cvxpy_check(name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/measures.py"
    },
    {
        "api_name": "_input_formatter",
        "full_api_name": "_input_formatter",
        "api_description": "Formatting function for input conversion",
        "api_signature": "_input_formatter(obj, fallback_class, func_name, arg_name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/measures.py"
    },
    {
        "api_name": "_cp_condition",
        "full_api_name": "_cp_condition",
        "api_description": "Return Choi-matrix eigenvalues for checking if channel is CP",
        "api_signature": "_cp_condition(channel)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/measures.py"
    },
    {
        "api_name": "_tp_condition",
        "full_api_name": "_tp_condition",
        "api_description": "Return partial tr Choi-matrix eigenvalues for checking if channel is TP",
        "api_signature": "_tp_condition(channel)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/measures.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CustomIterator.__init__",
        "api_description": "",
        "api_signature": "__init__(self, obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/custom_iterator.py"
    },
    {
        "api_name": "__getitem__",
        "full_api_name": "CustomIterator.__getitem__",
        "api_description": "Get next item",
        "api_signature": "__getitem__(self, key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/custom_iterator.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "CustomIterator.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/custom_iterator.py"
    },
    {
        "api_name": "__len__",
        "full_api_name": "CustomIterator.__len__",
        "api_description": "",
        "api_signature": "__len__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/custom_iterator.py"
    },
    {
        "api_name": "__iter__",
        "full_api_name": "CustomIterator.__iter__",
        "api_description": "",
        "api_signature": "__iter__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/custom_iterator.py"
    },
    {
        "api_name": "__next__",
        "full_api_name": "CustomIterator.__next__",
        "api_description": "",
        "api_signature": "__next__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/custom_iterator.py"
    },
    {
        "api_name": "double_commutator",
        "full_api_name": "double_commutator",
        "api_description": "Compute symmetric double commutator of a, b and c.\n\nSee also Equation (13.6.18) in [1].\n\nIf `commutator` is `True`, it returns\n\n.. math::\n\n     [[A, B], C]/2 + [A, [B, C]]/2\n     = (2ABC + 2CBA - BAC - CAB - ACB - BCA)/2.\n\nIf `commutator` is `False`, it returns\n\n.. math::\n     \\lbrace[A, B], C\\rbrace/2 + \\lbrace A, [B, C]\\rbrace/2\n     = (2ABC - 2CBA - BAC + CAB - ACB + BCA)/2.\n\nArgs:\n    a: Operator a.\n    b: Operator b.\n    c: Operator c.\n    commutator: If ``True`` compute the double commutator,\n        if ``False`` the double anti-commutator.\n\nReturns:\n    The double commutator\n\nReferences:\n\n    [1]: R. McWeeny.\n        Methods of Molecular Quantum Mechanics.\n        2nd Edition, Academic Press, 1992.\n        ISBN 0-12-486552-6.",
        "api_signature": "double_commutator(a, b, c)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/utils/double_commutator.py"
    },
    {
        "api_name": "anti_commutator",
        "full_api_name": "anti_commutator",
        "api_description": "Compute anti-commutator of a and b.\n\n.. math::\n\n    ab + ba.\n\nArgs:\n    a: Operator a.\n    b: Operator b.\nReturns:\n    The anti-commutator",
        "api_signature": "anti_commutator(a, b)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/utils/anti_commutator.py"
    },
    {
        "api_name": "commutator",
        "full_api_name": "commutator",
        "api_description": "Compute commutator of a and b.\n\n.. math::\n\n    ab - ba.\n\nArgs:\n    a: Operator a.\n    b: Operator b.\nReturns:\n    The commutator",
        "api_signature": "commutator(a, b)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/utils/commutator.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "QuantumChannel.__init__",
        "api_description": "Initialize a quantum channel Superoperator operator.\n\nArgs:\n    data (array or list): quantum channel data array.\n    op_shape (OpShape): the operator shape of the channel.\n    num_qubits (int): the number of qubits if the channel is N-qubit.\n\nRaises:\n    QiskitError: if arguments are invalid.",
        "api_signature": "__init__(self, data, num_qubits, op_shape)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/quantum_channel.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "QuantumChannel.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/quantum_channel.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "QuantumChannel.__eq__",
        "api_description": "Test if two QuantumChannels are equal.",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/quantum_channel.py"
    },
    {
        "api_name": "data",
        "full_api_name": "QuantumChannel.data",
        "api_description": "Return data.",
        "api_signature": "data(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/quantum_channel.py"
    },
    {
        "api_name": "_channel_rep",
        "full_api_name": "QuantumChannel._channel_rep",
        "api_description": "Return channel representation string",
        "api_signature": "_channel_rep(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/quantum_channel.py"
    },
    {
        "api_name": "settings",
        "full_api_name": "QuantumChannel.settings",
        "api_description": "Return settings.",
        "api_signature": "settings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/quantum_channel.py"
    },
    {
        "api_name": "conjugate",
        "full_api_name": "QuantumChannel.conjugate",
        "api_description": "Return the conjugate quantum channel.\n\n.. note::\n    This is equivalent to the matrix complex conjugate in the\n    :class:`~qiskit.quantum_info.SuperOp` representation\n    ie. for a channel :math:`\\mathcal{E}`, the SuperOp of\n    the conjugate channel :math:`\\overline{{\\mathcal{{E}}}}` is\n    :math:`S_{\\overline{\\mathcal{E}^\\dagger}} = \\overline{S_{\\mathcal{E}}}`.",
        "api_signature": "conjugate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/quantum_channel.py"
    },
    {
        "api_name": "transpose",
        "full_api_name": "QuantumChannel.transpose",
        "api_description": "Return the transpose quantum channel.\n\n.. note::\n    This is equivalent to the matrix transpose in the\n    :class:`~qiskit.quantum_info.SuperOp` representation,\n    ie. for a channel :math:`\\mathcal{E}`, the SuperOp of\n    the transpose channel :math:`\\mathcal{{E}}^T` is\n    :math:`S_{mathcal{E}^T} = S_{\\mathcal{E}}^T`.",
        "api_signature": "transpose(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/quantum_channel.py"
    },
    {
        "api_name": "adjoint",
        "full_api_name": "QuantumChannel.adjoint",
        "api_description": "Return the adjoint quantum channel.\n\n.. note::\n    This is equivalent to the matrix Hermitian conjugate in the\n    :class:`~qiskit.quantum_info.SuperOp` representation\n    ie. for a channel :math:`\\mathcal{E}`, the SuperOp of\n    the adjoint channel :math:`\\mathcal{{E}}^\\dagger` is\n    :math:`S_{\\mathcal{E}^\\dagger} = S_{\\mathcal{E}}^\\dagger`.",
        "api_signature": "adjoint(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/quantum_channel.py"
    },
    {
        "api_name": "power",
        "full_api_name": "QuantumChannel.power",
        "api_description": "Return the power of the quantum channel.\n\nArgs:\n    n (float): the power exponent.\n\nReturns:\n    CLASS: the channel :math:`\\mathcal{{E}} ^n`.\n\nRaises:\n    QiskitError: if the input and output dimensions of the\n                 CLASS are not equal.\n\n.. note::\n    For non-positive or non-integer exponents the power is\n    defined as the matrix power of the\n    :class:`~qiskit.quantum_info.SuperOp` representation\n    ie. for a channel :math:`\\mathcal{{E}}`, the SuperOp of\n    the powered channel :math:`\\mathcal{{E}}^\\n` is\n    :math:`S_{{\\mathcal{{E}}^n}} = S_{{\\mathcal{{E}}}}^n`.",
        "api_signature": "power(self, n)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/quantum_channel.py"
    },
    {
        "api_name": "__sub__",
        "full_api_name": "QuantumChannel.__sub__",
        "api_description": "",
        "api_signature": "__sub__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/quantum_channel.py"
    },
    {
        "api_name": "_add",
        "full_api_name": "QuantumChannel._add",
        "api_description": "",
        "api_signature": "_add(self, other, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/quantum_channel.py"
    },
    {
        "api_name": "_multiply",
        "full_api_name": "QuantumChannel._multiply",
        "api_description": "",
        "api_signature": "_multiply(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/quantum_channel.py"
    },
    {
        "api_name": "is_cptp",
        "full_api_name": "QuantumChannel.is_cptp",
        "api_description": "Return True if completely-positive trace-preserving (CPTP).",
        "api_signature": "is_cptp(self, atol, rtol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/quantum_channel.py"
    },
    {
        "api_name": "is_tp",
        "full_api_name": "QuantumChannel.is_tp",
        "api_description": "Test if a channel is trace-preserving (TP)",
        "api_signature": "is_tp(self, atol, rtol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/quantum_channel.py"
    },
    {
        "api_name": "is_cp",
        "full_api_name": "QuantumChannel.is_cp",
        "api_description": "Test if Choi-matrix is completely-positive (CP)",
        "api_signature": "is_cp(self, atol, rtol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/quantum_channel.py"
    },
    {
        "api_name": "is_unitary",
        "full_api_name": "QuantumChannel.is_unitary",
        "api_description": "Return True if QuantumChannel is a unitary channel.",
        "api_signature": "is_unitary(self, atol, rtol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/quantum_channel.py"
    },
    {
        "api_name": "to_operator",
        "full_api_name": "QuantumChannel.to_operator",
        "api_description": "Try to convert channel to a unitary representation Operator.",
        "api_signature": "to_operator(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/quantum_channel.py"
    },
    {
        "api_name": "to_instruction",
        "full_api_name": "QuantumChannel.to_instruction",
        "api_description": "Convert to a Kraus or UnitaryGate circuit instruction.\n\nIf the channel is unitary it will be added as a unitary gate,\notherwise it will be added as a kraus simulator instruction.\n\nReturns:\n    qiskit.circuit.Instruction: A kraus instruction for the channel.\n\nRaises:\n    QiskitError: if input data is not an N-qubit CPTP quantum channel.",
        "api_signature": "to_instruction(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/quantum_channel.py"
    },
    {
        "api_name": "_is_cp_helper",
        "full_api_name": "QuantumChannel._is_cp_helper",
        "api_description": "Test if a channel is completely-positive (CP)",
        "api_signature": "_is_cp_helper(self, choi, atol, rtol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/quantum_channel.py"
    },
    {
        "api_name": "_is_tp_helper",
        "full_api_name": "QuantumChannel._is_tp_helper",
        "api_description": "Test if Choi-matrix is trace-preserving (TP)",
        "api_signature": "_is_tp_helper(self, choi, atol, rtol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/quantum_channel.py"
    },
    {
        "api_name": "_format_state",
        "full_api_name": "QuantumChannel._format_state",
        "api_description": "Format input state so it is statevector or density matrix",
        "api_signature": "_format_state(self, state, density_matrix)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/quantum_channel.py"
    },
    {
        "api_name": "_evolve",
        "full_api_name": "QuantumChannel._evolve",
        "api_description": "Evolve a quantum state by the quantum channel.\n\nArgs:\n    state (DensityMatrix or Statevector): The input state.\n    qargs (list): a list of quantum state subsystem positions to apply\n                   the quantum channel on.\n\nReturns:\n    DensityMatrix: the output quantum state as a density matrix.\n\nRaises:\n    QiskitError: if the quantum channel dimension does not match the\n                 specified quantum state subsystem dimensions.",
        "api_signature": "_evolve(self, state, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/quantum_channel.py"
    },
    {
        "api_name": "_init_transformer",
        "full_api_name": "QuantumChannel._init_transformer",
        "api_description": "Convert input into a QuantumChannel subclass object or Operator object",
        "api_signature": "_init_transformer(cls, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/quantum_channel.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Choi.__init__",
        "api_description": "Initialize a quantum channel Choi matrix operator.\n\nArgs:\n    data (QuantumCircuit or\n          Instruction or\n          BaseOperator or\n          matrix): data to initialize superoperator.\n    input_dims (tuple): the input subsystem dimensions.\n                        [Default: None]\n    output_dims (tuple): the output subsystem dimensions.\n                         [Default: None]\n\nRaises:\n    QiskitError: if input data cannot be initialized as a\n                 Choi matrix.\n\nAdditional Information:\n    If the input or output dimensions are None, they will be\n    automatically determined from the input data. If the input data is\n    a Numpy array of shape (4**N, 4**N) qubit systems will be used. If\n    the input operator is not an N-qubit operator, it will assign a\n    single subsystem with dimension specified by the shape of the input.",
        "api_signature": "__init__(self, data, input_dims, output_dims)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/choi.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "Choi.__array__",
        "api_description": "",
        "api_signature": "__array__(self, dtype, copy)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/choi.py"
    },
    {
        "api_name": "_bipartite_shape",
        "full_api_name": "Choi._bipartite_shape",
        "api_description": "Return the shape for bipartite matrix",
        "api_signature": "_bipartite_shape(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/choi.py"
    },
    {
        "api_name": "_evolve",
        "full_api_name": "Choi._evolve",
        "api_description": "",
        "api_signature": "_evolve(self, state, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/choi.py"
    },
    {
        "api_name": "conjugate",
        "full_api_name": "Choi.conjugate",
        "api_description": "",
        "api_signature": "conjugate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/choi.py"
    },
    {
        "api_name": "transpose",
        "full_api_name": "Choi.transpose",
        "api_description": "",
        "api_signature": "transpose(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/choi.py"
    },
    {
        "api_name": "compose",
        "full_api_name": "Choi.compose",
        "api_description": "",
        "api_signature": "compose(self, other, qargs, front)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/choi.py"
    },
    {
        "api_name": "tensor",
        "full_api_name": "Choi.tensor",
        "api_description": "",
        "api_signature": "tensor(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/choi.py"
    },
    {
        "api_name": "expand",
        "full_api_name": "Choi.expand",
        "api_description": "",
        "api_signature": "expand(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/choi.py"
    },
    {
        "api_name": "_tensor",
        "full_api_name": "Choi._tensor",
        "api_description": "",
        "api_signature": "_tensor(cls, a, b)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/choi.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Chi.__init__",
        "api_description": "Initialize a quantum channel Chi-matrix operator.\n\nArgs:\n    data (QuantumCircuit or\n          Instruction or\n          BaseOperator or\n          matrix): data to initialize superoperator.\n    input_dims (tuple): the input subsystem dimensions.\n                        [Default: None]\n    output_dims (tuple): the output subsystem dimensions.\n                         [Default: None]\n\nRaises:\n    QiskitError: if input data is not an N-qubit channel or\n                 cannot be initialized as a Chi-matrix.\n\nAdditional Information:\n    If the input or output dimensions are None, they will be\n    automatically determined from the input data. The Chi matrix\n    representation is only valid for N-qubit channels.",
        "api_signature": "__init__(self, data, input_dims, output_dims)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/chi.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "Chi.__array__",
        "api_description": "",
        "api_signature": "__array__(self, dtype, copy)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/chi.py"
    },
    {
        "api_name": "_bipartite_shape",
        "full_api_name": "Chi._bipartite_shape",
        "api_description": "Return the shape for bipartite matrix",
        "api_signature": "_bipartite_shape(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/chi.py"
    },
    {
        "api_name": "_evolve",
        "full_api_name": "Chi._evolve",
        "api_description": "",
        "api_signature": "_evolve(self, state, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/chi.py"
    },
    {
        "api_name": "conjugate",
        "full_api_name": "Chi.conjugate",
        "api_description": "",
        "api_signature": "conjugate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/chi.py"
    },
    {
        "api_name": "transpose",
        "full_api_name": "Chi.transpose",
        "api_description": "",
        "api_signature": "transpose(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/chi.py"
    },
    {
        "api_name": "adjoint",
        "full_api_name": "Chi.adjoint",
        "api_description": "",
        "api_signature": "adjoint(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/chi.py"
    },
    {
        "api_name": "compose",
        "full_api_name": "Chi.compose",
        "api_description": "",
        "api_signature": "compose(self, other, qargs, front)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/chi.py"
    },
    {
        "api_name": "tensor",
        "full_api_name": "Chi.tensor",
        "api_description": "",
        "api_signature": "tensor(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/chi.py"
    },
    {
        "api_name": "expand",
        "full_api_name": "Chi.expand",
        "api_description": "",
        "api_signature": "expand(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/chi.py"
    },
    {
        "api_name": "_tensor",
        "full_api_name": "Chi._tensor",
        "api_description": "",
        "api_signature": "_tensor(cls, a, b)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/chi.py"
    },
    {
        "api_name": "_transform_rep",
        "full_api_name": "_transform_rep",
        "api_description": "Transform a QuantumChannel between representation.",
        "api_signature": "_transform_rep(input_rep, output_rep, data, input_dim, output_dim)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/transformations.py"
    },
    {
        "api_name": "_to_choi",
        "full_api_name": "_to_choi",
        "api_description": "Transform a QuantumChannel to the Choi representation.",
        "api_signature": "_to_choi(rep, data, input_dim, output_dim)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/transformations.py"
    },
    {
        "api_name": "_to_superop",
        "full_api_name": "_to_superop",
        "api_description": "Transform a QuantumChannel to the SuperOp representation.",
        "api_signature": "_to_superop(rep, data, input_dim, output_dim)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/transformations.py"
    },
    {
        "api_name": "_to_kraus",
        "full_api_name": "_to_kraus",
        "api_description": "Transform a QuantumChannel to the Kraus representation.",
        "api_signature": "_to_kraus(rep, data, input_dim, output_dim)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/transformations.py"
    },
    {
        "api_name": "_to_chi",
        "full_api_name": "_to_chi",
        "api_description": "Transform a QuantumChannel to the Chi representation.",
        "api_signature": "_to_chi(rep, data, input_dim, output_dim)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/transformations.py"
    },
    {
        "api_name": "_to_ptm",
        "full_api_name": "_to_ptm",
        "api_description": "Transform a QuantumChannel to the PTM representation.",
        "api_signature": "_to_ptm(rep, data, input_dim, output_dim)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/transformations.py"
    },
    {
        "api_name": "_to_stinespring",
        "full_api_name": "_to_stinespring",
        "api_description": "Transform a QuantumChannel to the Stinespring representation.",
        "api_signature": "_to_stinespring(rep, data, input_dim, output_dim)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/transformations.py"
    },
    {
        "api_name": "_to_operator",
        "full_api_name": "_to_operator",
        "api_description": "Transform a QuantumChannel to the Operator representation.",
        "api_signature": "_to_operator(rep, data, input_dim, output_dim)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/transformations.py"
    },
    {
        "api_name": "_from_operator",
        "full_api_name": "_from_operator",
        "api_description": "Transform Operator representation to other representation.",
        "api_signature": "_from_operator(rep, data, input_dim, output_dim)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/transformations.py"
    },
    {
        "api_name": "_kraus_to_operator",
        "full_api_name": "_kraus_to_operator",
        "api_description": "Transform Kraus representation to Operator representation.",
        "api_signature": "_kraus_to_operator(data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/transformations.py"
    },
    {
        "api_name": "_stinespring_to_operator",
        "full_api_name": "_stinespring_to_operator",
        "api_description": "Transform Stinespring representation to Operator representation.",
        "api_signature": "_stinespring_to_operator(data, output_dim)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/transformations.py"
    },
    {
        "api_name": "_superop_to_choi",
        "full_api_name": "_superop_to_choi",
        "api_description": "Transform SuperOp representation to Choi representation.",
        "api_signature": "_superop_to_choi(data, input_dim, output_dim)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/transformations.py"
    },
    {
        "api_name": "_choi_to_superop",
        "full_api_name": "_choi_to_superop",
        "api_description": "Transform Choi to SuperOp representation.",
        "api_signature": "_choi_to_superop(data, input_dim, output_dim)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/transformations.py"
    },
    {
        "api_name": "_kraus_to_choi",
        "full_api_name": "_kraus_to_choi",
        "api_description": "Transform Kraus representation to Choi representation.",
        "api_signature": "_kraus_to_choi(data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/transformations.py"
    },
    {
        "api_name": "_choi_to_kraus",
        "full_api_name": "_choi_to_kraus",
        "api_description": "Transform Choi representation to Kraus representation.",
        "api_signature": "_choi_to_kraus(data, input_dim, output_dim, atol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/transformations.py"
    },
    {
        "api_name": "_stinespring_to_kraus",
        "full_api_name": "_stinespring_to_kraus",
        "api_description": "Transform Stinespring representation to Kraus representation.",
        "api_signature": "_stinespring_to_kraus(data, output_dim)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/transformations.py"
    },
    {
        "api_name": "_stinespring_to_choi",
        "full_api_name": "_stinespring_to_choi",
        "api_description": "Transform Stinespring representation to Choi representation.",
        "api_signature": "_stinespring_to_choi(data, input_dim, output_dim)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/transformations.py"
    },
    {
        "api_name": "_stinespring_to_superop",
        "full_api_name": "_stinespring_to_superop",
        "api_description": "Transform Stinespring representation to SuperOp representation.",
        "api_signature": "_stinespring_to_superop(data, input_dim, output_dim)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/transformations.py"
    },
    {
        "api_name": "_kraus_to_stinespring",
        "full_api_name": "_kraus_to_stinespring",
        "api_description": "Transform Kraus representation to Stinespring representation.",
        "api_signature": "_kraus_to_stinespring(data, input_dim, output_dim)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/transformations.py"
    },
    {
        "api_name": "_kraus_to_superop",
        "full_api_name": "_kraus_to_superop",
        "api_description": "Transform Kraus representation to SuperOp representation.",
        "api_signature": "_kraus_to_superop(data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/transformations.py"
    },
    {
        "api_name": "_chi_to_choi",
        "full_api_name": "_chi_to_choi",
        "api_description": "Transform Chi representation to a Choi representation.",
        "api_signature": "_chi_to_choi(data, input_dim)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/transformations.py"
    },
    {
        "api_name": "_choi_to_chi",
        "full_api_name": "_choi_to_chi",
        "api_description": "Transform Choi representation to the Chi representation.",
        "api_signature": "_choi_to_chi(data, input_dim)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/transformations.py"
    },
    {
        "api_name": "_ptm_to_superop",
        "full_api_name": "_ptm_to_superop",
        "api_description": "Transform PTM representation to SuperOp representation.",
        "api_signature": "_ptm_to_superop(data, input_dim)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/transformations.py"
    },
    {
        "api_name": "_superop_to_ptm",
        "full_api_name": "_superop_to_ptm",
        "api_description": "Transform SuperOp representation to PTM representation.",
        "api_signature": "_superop_to_ptm(data, input_dim)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/transformations.py"
    },
    {
        "api_name": "_bipartite_tensor",
        "full_api_name": "_bipartite_tensor",
        "api_description": "Tensor product (A \u2297 B) to bipartite matrices and reravel indices.\n\nThis is used for tensor product of superoperators and Choi matrices.\n\nArgs:\n    mat1 (matrix_like): a bipartite matrix A\n    mat2 (matrix_like): a bipartite matrix B\n    shape1 (tuple): bipartite-shape for matrix A (a0, a1, a2, a3)\n    shape2 (tuple): bipartite-shape for matrix B (b0, b1, b2, b3)\n\nReturns:\n    np.array: a bipartite matrix for reravel(A \u2297 B).\n\nRaises:\n    QiskitError: if input matrices are wrong shape.",
        "api_signature": "_bipartite_tensor(mat1, mat2, shape1, shape2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/transformations.py"
    },
    {
        "api_name": "_reravel",
        "full_api_name": "_reravel",
        "api_description": "Reravel two bipartite matrices.",
        "api_signature": "_reravel(mat1, mat2, shape1, shape2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/transformations.py"
    },
    {
        "api_name": "_transform_to_pauli",
        "full_api_name": "_transform_to_pauli",
        "api_description": "Change of basis of bipartite matrix representation.",
        "api_signature": "_transform_to_pauli(data, num_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/transformations.py"
    },
    {
        "api_name": "_transform_from_pauli",
        "full_api_name": "_transform_from_pauli",
        "api_description": "Change of basis of bipartite matrix representation.",
        "api_signature": "_transform_from_pauli(data, num_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/transformations.py"
    },
    {
        "api_name": "_reshuffle",
        "full_api_name": "_reshuffle",
        "api_description": "Reshuffle the indices of a bipartite matrix A[ij,kl] -> A[lj,ki].",
        "api_signature": "_reshuffle(mat, shape)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/transformations.py"
    },
    {
        "api_name": "_check_nqubit_dim",
        "full_api_name": "_check_nqubit_dim",
        "api_description": "Return true if dims correspond to an n-qubit channel.",
        "api_signature": "_check_nqubit_dim(input_dim, output_dim)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/transformations.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Stinespring.__init__",
        "api_description": "Initialize a quantum channel Stinespring operator.\n\nArgs:\n    data (QuantumCircuit or\n          Instruction or\n          BaseOperator or\n          matrix): data to initialize superoperator.\n    input_dims (tuple): the input subsystem dimensions.\n                        [Default: None]\n    output_dims (tuple): the output subsystem dimensions.\n                         [Default: None]\n\nRaises:\n    QiskitError: if input data cannot be initialized as a\n                 a list of Kraus matrices.\n\nAdditional Information:\n    If the input or output dimensions are None, they will be\n    automatically determined from the input data. This can fail for the\n    Stinespring operator if the output dimension cannot be automatically\n    determined.",
        "api_signature": "__init__(self, data, input_dims, output_dims)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/stinespring.py"
    },
    {
        "api_name": "data",
        "full_api_name": "Stinespring.data",
        "api_description": "",
        "api_signature": "data(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/stinespring.py"
    },
    {
        "api_name": "is_cptp",
        "full_api_name": "Stinespring.is_cptp",
        "api_description": "Return True if completely-positive trace-preserving.",
        "api_signature": "is_cptp(self, atol, rtol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/stinespring.py"
    },
    {
        "api_name": "_evolve",
        "full_api_name": "Stinespring._evolve",
        "api_description": "",
        "api_signature": "_evolve(self, state, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/stinespring.py"
    },
    {
        "api_name": "conjugate",
        "full_api_name": "Stinespring.conjugate",
        "api_description": "",
        "api_signature": "conjugate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/stinespring.py"
    },
    {
        "api_name": "transpose",
        "full_api_name": "Stinespring.transpose",
        "api_description": "",
        "api_signature": "transpose(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/stinespring.py"
    },
    {
        "api_name": "compose",
        "full_api_name": "Stinespring.compose",
        "api_description": "",
        "api_signature": "compose(self, other, qargs, front)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/stinespring.py"
    },
    {
        "api_name": "tensor",
        "full_api_name": "Stinespring.tensor",
        "api_description": "",
        "api_signature": "tensor(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/stinespring.py"
    },
    {
        "api_name": "expand",
        "full_api_name": "Stinespring.expand",
        "api_description": "",
        "api_signature": "expand(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/stinespring.py"
    },
    {
        "api_name": "_tensor",
        "full_api_name": "Stinespring._tensor",
        "api_description": "",
        "api_signature": "_tensor(cls, a, b)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/stinespring.py"
    },
    {
        "api_name": "__add__",
        "full_api_name": "Stinespring.__add__",
        "api_description": "",
        "api_signature": "__add__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/stinespring.py"
    },
    {
        "api_name": "__sub__",
        "full_api_name": "Stinespring.__sub__",
        "api_description": "",
        "api_signature": "__sub__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/stinespring.py"
    },
    {
        "api_name": "_add",
        "full_api_name": "Stinespring._add",
        "api_description": "",
        "api_signature": "_add(self, other, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/stinespring.py"
    },
    {
        "api_name": "_multiply",
        "full_api_name": "Stinespring._multiply",
        "api_description": "",
        "api_signature": "_multiply(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/stinespring.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PTM.__init__",
        "api_description": "Initialize a PTM quantum channel operator.\n\nArgs:\n    data (QuantumCircuit or\n          Instruction or\n          BaseOperator or\n          matrix): data to initialize superoperator.\n    input_dims (tuple): the input subsystem dimensions.\n                        [Default: None]\n    output_dims (tuple): the output subsystem dimensions.\n                         [Default: None]\n\nRaises:\n    QiskitError: if input data is not an N-qubit channel or\n                 cannot be initialized as a PTM.\n\nAdditional Information:\n    If the input or output dimensions are None, they will be\n    automatically determined from the input data. The PTM\n    representation is only valid for N-qubit channels.",
        "api_signature": "__init__(self, data, input_dims, output_dims)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/ptm.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "PTM.__array__",
        "api_description": "",
        "api_signature": "__array__(self, dtype, copy)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/ptm.py"
    },
    {
        "api_name": "_bipartite_shape",
        "full_api_name": "PTM._bipartite_shape",
        "api_description": "Return the shape for bipartite matrix",
        "api_signature": "_bipartite_shape(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/ptm.py"
    },
    {
        "api_name": "_evolve",
        "full_api_name": "PTM._evolve",
        "api_description": "",
        "api_signature": "_evolve(self, state, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/ptm.py"
    },
    {
        "api_name": "conjugate",
        "full_api_name": "PTM.conjugate",
        "api_description": "",
        "api_signature": "conjugate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/ptm.py"
    },
    {
        "api_name": "transpose",
        "full_api_name": "PTM.transpose",
        "api_description": "",
        "api_signature": "transpose(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/ptm.py"
    },
    {
        "api_name": "adjoint",
        "full_api_name": "PTM.adjoint",
        "api_description": "",
        "api_signature": "adjoint(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/ptm.py"
    },
    {
        "api_name": "compose",
        "full_api_name": "PTM.compose",
        "api_description": "",
        "api_signature": "compose(self, other, qargs, front)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/ptm.py"
    },
    {
        "api_name": "tensor",
        "full_api_name": "PTM.tensor",
        "api_description": "",
        "api_signature": "tensor(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/ptm.py"
    },
    {
        "api_name": "expand",
        "full_api_name": "PTM.expand",
        "api_description": "",
        "api_signature": "expand(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/ptm.py"
    },
    {
        "api_name": "_tensor",
        "full_api_name": "PTM._tensor",
        "api_description": "",
        "api_signature": "_tensor(cls, a, b)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/ptm.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Kraus.__init__",
        "api_description": "Initialize a quantum channel Kraus operator.\n\nArgs:\n    data: data to initialize superoperator.\n    input_dims: the input subsystem dimensions.\n    output_dims: the output subsystem dimensions.\n\nRaises:\n    QiskitError: if input data cannot be initialized as a list of Kraus matrices.\n\nAdditional Information:\n    If the input or output dimensions are None, they will be\n    automatically determined from the input data. If the input data is\n    a list of Numpy arrays of shape :math:`(2^N,\\,2^N)` qubit systems will be\n    used. If the input does not correspond to an N-qubit channel, it\n    will assign a single subsystem with dimension specified by the\n    shape of the input.",
        "api_signature": "__init__(self, data, input_dims, output_dims)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/kraus.py"
    },
    {
        "api_name": "data",
        "full_api_name": "Kraus.data",
        "api_description": "Return list of Kraus matrices for channel.",
        "api_signature": "data(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/kraus.py"
    },
    {
        "api_name": "is_cptp",
        "full_api_name": "Kraus.is_cptp",
        "api_description": "Return True if completely-positive trace-preserving.",
        "api_signature": "is_cptp(self, atol, rtol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/kraus.py"
    },
    {
        "api_name": "_evolve",
        "full_api_name": "Kraus._evolve",
        "api_description": "",
        "api_signature": "_evolve(self, state, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/kraus.py"
    },
    {
        "api_name": "conjugate",
        "full_api_name": "Kraus.conjugate",
        "api_description": "",
        "api_signature": "conjugate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/kraus.py"
    },
    {
        "api_name": "transpose",
        "full_api_name": "Kraus.transpose",
        "api_description": "",
        "api_signature": "transpose(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/kraus.py"
    },
    {
        "api_name": "adjoint",
        "full_api_name": "Kraus.adjoint",
        "api_description": "",
        "api_signature": "adjoint(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/kraus.py"
    },
    {
        "api_name": "compose",
        "full_api_name": "Kraus.compose",
        "api_description": "",
        "api_signature": "compose(self, other, qargs, front)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/kraus.py"
    },
    {
        "api_name": "tensor",
        "full_api_name": "Kraus.tensor",
        "api_description": "",
        "api_signature": "tensor(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/kraus.py"
    },
    {
        "api_name": "expand",
        "full_api_name": "Kraus.expand",
        "api_description": "",
        "api_signature": "expand(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/kraus.py"
    },
    {
        "api_name": "_tensor",
        "full_api_name": "Kraus._tensor",
        "api_description": "",
        "api_signature": "_tensor(cls, a, b)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/kraus.py"
    },
    {
        "api_name": "__add__",
        "full_api_name": "Kraus.__add__",
        "api_description": "",
        "api_signature": "__add__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/kraus.py"
    },
    {
        "api_name": "__sub__",
        "full_api_name": "Kraus.__sub__",
        "api_description": "",
        "api_signature": "__sub__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/kraus.py"
    },
    {
        "api_name": "_add",
        "full_api_name": "Kraus._add",
        "api_description": "",
        "api_signature": "_add(self, other, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/kraus.py"
    },
    {
        "api_name": "_multiply",
        "full_api_name": "Kraus._multiply",
        "api_description": "",
        "api_signature": "_multiply(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/kraus.py"
    },
    {
        "api_name": "_is_matrix",
        "full_api_name": "_is_matrix",
        "api_description": "",
        "api_signature": "_is_matrix(data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/kraus.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SuperOp.__init__",
        "api_description": "Initialize a quantum channel Superoperator operator.\n\nArgs:\n    data (QuantumCircuit or\n          Instruction or\n          BaseOperator or\n          matrix): data to initialize superoperator.\n    input_dims (tuple): the input subsystem dimensions.\n                        [Default: None]\n    output_dims (tuple): the output subsystem dimensions.\n                         [Default: None]\n\nRaises:\n    QiskitError: if input data cannot be initialized as a\n                 superoperator.\n\nAdditional Information:\n    If the input or output dimensions are None, they will be\n    automatically determined from the input data. If the input data is\n    a Numpy array of shape (4**N, 4**N) qubit systems will be used. If\n    the input operator is not an N-qubit operator, it will assign a\n    single subsystem with dimension specified by the shape of the input.",
        "api_signature": "__init__(self, data, input_dims, output_dims)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/superop.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "SuperOp.__array__",
        "api_description": "",
        "api_signature": "__array__(self, dtype, copy)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/superop.py"
    },
    {
        "api_name": "_tensor_shape",
        "full_api_name": "SuperOp._tensor_shape",
        "api_description": "Return the tensor shape of the superoperator matrix",
        "api_signature": "_tensor_shape(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/superop.py"
    },
    {
        "api_name": "_bipartite_shape",
        "full_api_name": "SuperOp._bipartite_shape",
        "api_description": "Return the shape for bipartite matrix",
        "api_signature": "_bipartite_shape(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/superop.py"
    },
    {
        "api_name": "conjugate",
        "full_api_name": "SuperOp.conjugate",
        "api_description": "",
        "api_signature": "conjugate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/superop.py"
    },
    {
        "api_name": "transpose",
        "full_api_name": "SuperOp.transpose",
        "api_description": "",
        "api_signature": "transpose(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/superop.py"
    },
    {
        "api_name": "adjoint",
        "full_api_name": "SuperOp.adjoint",
        "api_description": "",
        "api_signature": "adjoint(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/superop.py"
    },
    {
        "api_name": "tensor",
        "full_api_name": "SuperOp.tensor",
        "api_description": "",
        "api_signature": "tensor(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/superop.py"
    },
    {
        "api_name": "expand",
        "full_api_name": "SuperOp.expand",
        "api_description": "",
        "api_signature": "expand(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/superop.py"
    },
    {
        "api_name": "_tensor",
        "full_api_name": "SuperOp._tensor",
        "api_description": "",
        "api_signature": "_tensor(cls, a, b)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/superop.py"
    },
    {
        "api_name": "compose",
        "full_api_name": "SuperOp.compose",
        "api_description": "",
        "api_signature": "compose(self, other, qargs, front)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/superop.py"
    },
    {
        "api_name": "_evolve",
        "full_api_name": "SuperOp._evolve",
        "api_description": "Evolve a quantum state by the quantum channel.\n\nArgs:\n    state (DensityMatrix or Statevector): The input state.\n    qargs (list): a list of quantum state subsystem positions to apply\n                   the quantum channel on.\n\nReturns:\n    DensityMatrix: the output quantum state as a density matrix.\n\nRaises:\n    QiskitError: if the quantum channel dimension does not match the\n                 specified quantum state subsystem dimensions.",
        "api_signature": "_evolve(self, state, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/superop.py"
    },
    {
        "api_name": "_init_instruction",
        "full_api_name": "SuperOp._init_instruction",
        "api_description": "Convert a QuantumCircuit or Instruction to a SuperOp.",
        "api_signature": "_init_instruction(cls, instruction)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/superop.py"
    },
    {
        "api_name": "_instruction_to_superop",
        "full_api_name": "SuperOp._instruction_to_superop",
        "api_description": "Return superop for instruction if defined or None otherwise.",
        "api_signature": "_instruction_to_superop(cls, obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/superop.py"
    },
    {
        "api_name": "_append_instruction",
        "full_api_name": "SuperOp._append_instruction",
        "api_description": "Update the current Operator by apply an instruction.",
        "api_signature": "_append_instruction(self, obj, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/channel/superop.py"
    },
    {
        "api_name": "_append_circuit",
        "full_api_name": "_append_circuit",
        "api_description": "Update a CNOTDihedral element inplace by applying a CNOTDihedral circuit.\n\nArgs:\n    elem (CNOTDihedral): the CNOTDihedral element to update.\n    circuit (QuantumCircuit or Instruction): the gate or composite gate to apply.\n    qargs (list or None): The qubits to apply gates to.\nReturns:\n    CNOTDihedral: the updated CNOTDihedral.\nRaises:\n    QiskitError: if input gates cannot be decomposed into CNOTDihedral gates.",
        "api_signature": "_append_circuit(elem, circuit, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/dihedral_circuits.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "CNOTDihedral.__init__",
        "api_description": "Initialize a CNOTDihedral operator object.\n\nArgs:\n    data (CNOTDihedral or QuantumCircuit or ~qiskit.circuit.Instruction):\n        Optional, operator to initialize.\n    num_qubits (int): Optional, initialize an empty CNOTDihedral operator.\n    validate (bool): if True, validates the CNOTDihedral element.\n\nRaises:\n    QiskitError: if the type is invalid.\n    QiskitError: if validate=True and the CNOTDihedral element is invalid.",
        "api_signature": "__init__(self, data, num_qubits, validate)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/dihedral.py"
    },
    {
        "api_name": "name",
        "full_api_name": "CNOTDihedral.name",
        "api_description": "Unique string identifier for operation type.",
        "api_signature": "name(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/dihedral.py"
    },
    {
        "api_name": "num_clbits",
        "full_api_name": "CNOTDihedral.num_clbits",
        "api_description": "Number of classical bits.",
        "api_signature": "num_clbits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/dihedral.py"
    },
    {
        "api_name": "_z2matmul",
        "full_api_name": "CNOTDihedral._z2matmul",
        "api_description": "Compute product of two n x n z2 matrices.",
        "api_signature": "_z2matmul(self, left, right)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/dihedral.py"
    },
    {
        "api_name": "_z2matvecmul",
        "full_api_name": "CNOTDihedral._z2matvecmul",
        "api_description": "Compute mat*vec of n x n z2 matrix and vector.",
        "api_signature": "_z2matvecmul(self, mat, vec)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/dihedral.py"
    },
    {
        "api_name": "_dot",
        "full_api_name": "CNOTDihedral._dot",
        "api_description": "Left multiplication self * other.",
        "api_signature": "_dot(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/dihedral.py"
    },
    {
        "api_name": "_compose",
        "full_api_name": "CNOTDihedral._compose",
        "api_description": "Right multiplication other * self.",
        "api_signature": "_compose(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/dihedral.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "CNOTDihedral.__eq__",
        "api_description": "Test equality.",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/dihedral.py"
    },
    {
        "api_name": "_append_cx",
        "full_api_name": "CNOTDihedral._append_cx",
        "api_description": "Apply a CX gate to this element.\nLeft multiply the element by CX(i, j).",
        "api_signature": "_append_cx(self, i, j)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/dihedral.py"
    },
    {
        "api_name": "_append_phase",
        "full_api_name": "CNOTDihedral._append_phase",
        "api_description": "Apply an k-th power of T to this element.\nLeft multiply the element by T_i^k.",
        "api_signature": "_append_phase(self, k, i)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/dihedral.py"
    },
    {
        "api_name": "_append_x",
        "full_api_name": "CNOTDihedral._append_x",
        "api_description": "Apply X to this element.\nLeft multiply the element by X(i).",
        "api_signature": "_append_x(self, i)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/dihedral.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "CNOTDihedral.__str__",
        "api_description": "Return formatted string representation.",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/dihedral.py"
    },
    {
        "api_name": "to_circuit",
        "full_api_name": "CNOTDihedral.to_circuit",
        "api_description": "Return a QuantumCircuit implementing the CNOT-Dihedral element.\n\nReturn:\n    QuantumCircuit: a circuit implementation of the CNOTDihedral object.\n\nReferences:\n    1. Shelly Garion and Andrew W. Cross, *Synthesis of CNOT-Dihedral circuits\n       with optimal number of two qubit gates*, `Quantum 4(369), 2020\n       <https://quantum-journal.org/papers/q-2020-12-07-369/>`_\n    2. Andrew W. Cross, Easwar Magesan, Lev S. Bishop, John A. Smolin and Jay M. Gambetta,\n       *Scalable randomized benchmarking of non-Clifford gates*,\n       npj Quantum Inf 2, 16012 (2016).",
        "api_signature": "to_circuit(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/dihedral.py"
    },
    {
        "api_name": "to_instruction",
        "full_api_name": "CNOTDihedral.to_instruction",
        "api_description": "Return a Gate instruction implementing the CNOTDihedral object.",
        "api_signature": "to_instruction(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/dihedral.py"
    },
    {
        "api_name": "_from_circuit",
        "full_api_name": "CNOTDihedral._from_circuit",
        "api_description": "Initialize from a QuantumCircuit or Instruction.\n\nArgs:\n    circuit (QuantumCircuit or ~qiskit.circuit.Instruction):\n        instruction to initialize.\nReturns:\n    CNOTDihedral: the CNOTDihedral object for the circuit.\nRaises:\n    QiskitError: if the input instruction is not CNOTDihedral or contains\n                 classical register instruction.",
        "api_signature": "_from_circuit(self, circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/dihedral.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "CNOTDihedral.__array__",
        "api_description": "",
        "api_signature": "__array__(self, dtype, copy)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/dihedral.py"
    },
    {
        "api_name": "to_matrix",
        "full_api_name": "CNOTDihedral.to_matrix",
        "api_description": "Convert operator to Numpy matrix.",
        "api_signature": "to_matrix(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/dihedral.py"
    },
    {
        "api_name": "to_operator",
        "full_api_name": "CNOTDihedral.to_operator",
        "api_description": "Convert to an Operator object.",
        "api_signature": "to_operator(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/dihedral.py"
    },
    {
        "api_name": "compose",
        "full_api_name": "CNOTDihedral.compose",
        "api_description": "",
        "api_signature": "compose(self, other, qargs, front)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/dihedral.py"
    },
    {
        "api_name": "_tensor",
        "full_api_name": "CNOTDihedral._tensor",
        "api_description": "Returns the tensor product operator.",
        "api_signature": "_tensor(self, other, reverse)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/dihedral.py"
    },
    {
        "api_name": "tensor",
        "full_api_name": "CNOTDihedral.tensor",
        "api_description": "",
        "api_signature": "tensor(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/dihedral.py"
    },
    {
        "api_name": "expand",
        "full_api_name": "CNOTDihedral.expand",
        "api_description": "",
        "api_signature": "expand(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/dihedral.py"
    },
    {
        "api_name": "adjoint",
        "full_api_name": "CNOTDihedral.adjoint",
        "api_description": "",
        "api_signature": "adjoint(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/dihedral.py"
    },
    {
        "api_name": "conjugate",
        "full_api_name": "CNOTDihedral.conjugate",
        "api_description": "",
        "api_signature": "conjugate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/dihedral.py"
    },
    {
        "api_name": "transpose",
        "full_api_name": "CNOTDihedral.transpose",
        "api_description": "",
        "api_signature": "transpose(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/dihedral.py"
    },
    {
        "api_name": "_is_valid",
        "full_api_name": "CNOTDihedral._is_valid",
        "api_description": "Return True if input is a CNOTDihedral element.",
        "api_signature": "_is_valid(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/dihedral.py"
    },
    {
        "api_name": "random_cnotdihedral",
        "full_api_name": "random_cnotdihedral",
        "api_description": "Return a random CNOTDihedral element.\n\nArgs:\n    num_qubits (int): the number of qubits for the CNOTDihedral object.\n    seed (int or RandomState): Optional. Set a fixed seed or\n                               generator for RNG.\nReturns:\n    CNOTDihedral: a random CNOTDihedral element.",
        "api_signature": "random_cnotdihedral(num_qubits, seed)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/random.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SpecialPolynomial.__init__",
        "api_description": "Construct the zero polynomial on n_vars variables.",
        "api_signature": "__init__(self, n_vars)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/polynomial.py"
    },
    {
        "api_name": "mul_monomial",
        "full_api_name": "SpecialPolynomial.mul_monomial",
        "api_description": "Multiply by a monomial given by indices.\n\nReturns the product.",
        "api_signature": "mul_monomial(self, indices)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/polynomial.py"
    },
    {
        "api_name": "__mul__",
        "full_api_name": "SpecialPolynomial.__mul__",
        "api_description": "Multiply two polynomials.",
        "api_signature": "__mul__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/polynomial.py"
    },
    {
        "api_name": "__rmul__",
        "full_api_name": "SpecialPolynomial.__rmul__",
        "api_description": "Right multiplication.\n\nThis operation is commutative.",
        "api_signature": "__rmul__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/polynomial.py"
    },
    {
        "api_name": "__add__",
        "full_api_name": "SpecialPolynomial.__add__",
        "api_description": "Add two polynomials.",
        "api_signature": "__add__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/polynomial.py"
    },
    {
        "api_name": "evaluate",
        "full_api_name": "SpecialPolynomial.evaluate",
        "api_description": "Evaluate the multinomial at xval.\n\nif xval is a length n z2 vector, return element of Z8.\nif xval is a length n vector of multinomials, return\na multinomial. The multinomials must all be on n vars.",
        "api_signature": "evaluate(self, xval)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/polynomial.py"
    },
    {
        "api_name": "set_pj",
        "full_api_name": "SpecialPolynomial.set_pj",
        "api_description": "Set to special form polynomial on subset of variables.\n\np_J(x) := sum_{a subseteq J,|a| neq 0} (-2)^{|a|-1}x^a",
        "api_signature": "set_pj(self, indices)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/polynomial.py"
    },
    {
        "api_name": "get_term",
        "full_api_name": "SpecialPolynomial.get_term",
        "api_description": "Get the value of a term given the list of variables.\n\nExample: indices = [] returns the constant\n         indices = [0] returns the coefficient of x_0\n         indices = [0,3] returns the coefficient of x_0x_3\n         indices = [0,1,3] returns the coefficient of x_0x_1x_3\n\nIf len(indices) > 3 the method fails.\nIf the indices are out of bounds the method fails.\nIf the indices are not increasing the method fails.",
        "api_signature": "get_term(self, indices)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/polynomial.py"
    },
    {
        "api_name": "set_term",
        "full_api_name": "SpecialPolynomial.set_term",
        "api_description": "Set the value of a term given the list of variables.\n\nExample: indices = [] returns the constant\n         indices = [0] returns the coefficient of x_0\n         indices = [0,3] returns the coefficient of x_0x_3\n         indices = [0,1,3] returns the coefficient of x_0x_1x_3\n\nIf len(indices) > 3 the method fails.\nIf the indices are out of bounds the method fails.\nIf the indices are not increasing the method fails.\nThe value is reduced modulo 8.",
        "api_signature": "set_term(self, indices, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/polynomial.py"
    },
    {
        "api_name": "key",
        "full_api_name": "SpecialPolynomial.key",
        "api_description": "Return a string representation.",
        "api_signature": "key(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/polynomial.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "SpecialPolynomial.__eq__",
        "api_description": "Test equality.",
        "api_signature": "__eq__(self, x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/polynomial.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "SpecialPolynomial.__str__",
        "api_description": "Return formatted string representation.",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/dihedral/polynomial.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "SparsePauliOp.__init__",
        "api_description": "Initialize an operator object.\n\nArgs:\n    data (PauliList or SparsePauliOp or Pauli or list or str): Pauli list of\n        terms.  A list of Pauli strings or a Pauli string is also allowed.\n    coeffs (np.ndarray): complex coefficients for Pauli terms.\n\n        .. note::\n\n            If ``data`` is a :obj:`~SparsePauliOp` and ``coeffs`` is not ``None``, the value\n            of the ``SparsePauliOp.coeffs`` will be ignored, and only the passed keyword\n            argument ``coeffs`` will be used.\n\n    ignore_pauli_phase (bool): if true, any ``phase`` component of a given :obj:`~PauliList`\n        will be assumed to be zero.  This is more efficient in cases where a\n        :obj:`~PauliList` has been constructed purely for this object, and it is already\n        known that the phases in the ZX-convention are zero.  It only makes sense to pass\n        this option when giving :obj:`~PauliList` data.  (Default: False)\n    copy (bool): copy the input data if True, otherwise assign it directly, if possible.\n        (Default: True)\n\nRaises:\n    QiskitError: If the input data or coeffs are invalid.",
        "api_signature": "__init__(self, data, coeffs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "SparsePauliOp.__array__",
        "api_description": "",
        "api_signature": "__array__(self, dtype, copy)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "SparsePauliOp.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "SparsePauliOp.__eq__",
        "api_description": "Entrywise comparison of two SparsePauliOp operators",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "equiv",
        "full_api_name": "SparsePauliOp.equiv",
        "api_description": "Check if two SparsePauliOp operators are equivalent.\n\nArgs:\n    other (SparsePauliOp): an operator object.\n    atol: Absolute numerical tolerance for checking equivalence.\n\nReturns:\n    bool: True if the operator is equivalent to ``self``.",
        "api_signature": "equiv(self, other, atol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "settings",
        "full_api_name": "SparsePauliOp.settings",
        "api_description": "Return settings.",
        "api_signature": "settings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "size",
        "full_api_name": "SparsePauliOp.size",
        "api_description": "The number of Pauli of Pauli terms in the operator.",
        "api_signature": "size(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "__len__",
        "full_api_name": "SparsePauliOp.__len__",
        "api_description": "Return the size.",
        "api_signature": "__len__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "paulis",
        "full_api_name": "SparsePauliOp.paulis",
        "api_description": "Return the PauliList.",
        "api_signature": "paulis(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "paulis",
        "full_api_name": "SparsePauliOp.paulis",
        "api_description": "",
        "api_signature": "paulis(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "coeffs",
        "full_api_name": "SparsePauliOp.coeffs",
        "api_description": "Return the Pauli coefficients.",
        "api_signature": "coeffs(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "coeffs",
        "full_api_name": "SparsePauliOp.coeffs",
        "api_description": "Set Pauli coefficients.",
        "api_signature": "coeffs(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "__getitem__",
        "full_api_name": "SparsePauliOp.__getitem__",
        "api_description": "Return a view of the SparsePauliOp.",
        "api_signature": "__getitem__(self, key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "__setitem__",
        "full_api_name": "SparsePauliOp.__setitem__",
        "api_description": "Update SparsePauliOp.",
        "api_signature": "__setitem__(self, key, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "conjugate",
        "full_api_name": "SparsePauliOp.conjugate",
        "api_description": "",
        "api_signature": "conjugate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "transpose",
        "full_api_name": "SparsePauliOp.transpose",
        "api_description": "",
        "api_signature": "transpose(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "adjoint",
        "full_api_name": "SparsePauliOp.adjoint",
        "api_description": "",
        "api_signature": "adjoint(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "compose",
        "full_api_name": "SparsePauliOp.compose",
        "api_description": "",
        "api_signature": "compose(self, other, qargs, front)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "tensor",
        "full_api_name": "SparsePauliOp.tensor",
        "api_description": "",
        "api_signature": "tensor(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "expand",
        "full_api_name": "SparsePauliOp.expand",
        "api_description": "",
        "api_signature": "expand(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "_tensor",
        "full_api_name": "SparsePauliOp._tensor",
        "api_description": "",
        "api_signature": "_tensor(cls, a, b)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "_add",
        "full_api_name": "SparsePauliOp._add",
        "api_description": "",
        "api_signature": "_add(self, other, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "_multiply",
        "full_api_name": "SparsePauliOp._multiply",
        "api_description": "",
        "api_signature": "_multiply(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "is_unitary",
        "full_api_name": "SparsePauliOp.is_unitary",
        "api_description": "Return True if operator is a unitary matrix.\n\nArgs:\n    atol (float): Optional. Absolute tolerance for checking if\n                  coefficients are zero (Default: 1e-8).\n    rtol (float): Optional. relative tolerance for checking if\n                  coefficients are zero (Default: 1e-5).\n\nReturns:\n    bool: True if the operator is unitary, False otherwise.",
        "api_signature": "is_unitary(self, atol, rtol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "simplify",
        "full_api_name": "SparsePauliOp.simplify",
        "api_description": "Simplify PauliList by combining duplicates and removing zeros.\n\nArgs:\n    atol (float): Optional. Absolute tolerance for checking if\n                  coefficients are zero (Default: 1e-8).\n    rtol (float): Optional. relative tolerance for checking if\n                  coefficients are zero (Default: 1e-5).\n\nReturns:\n    SparsePauliOp: the simplified SparsePauliOp operator.",
        "api_signature": "simplify(self, atol, rtol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "to_complex",
        "full_api_name": "SparsePauliOp.to_complex",
        "api_description": "",
        "api_signature": "to_complex(coeff)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "argsort",
        "full_api_name": "SparsePauliOp.argsort",
        "api_description": "Return indices for sorting the rows of the table.\n\nReturns the composition of permutations in the order of sorting\nby coefficient and sorting by Pauli.\nBy using the `weight` kwarg the output can additionally be sorted\nby the number of non-identity terms in the Pauli, where the set of\nall Pauli's of a given weight are still ordered lexicographically.\n\n**Example**\n\nHere is an example of how to use SparsePauliOp argsort.\n\n.. code-block::\n\n    import numpy as np\n    from qiskit.quantum_info import SparsePauliOp\n\n    # 2-qubit labels\n    labels = [\"XX\", \"XX\", \"XX\", \"YI\", \"II\", \"XZ\", \"XY\", \"XI\"]\n    # coeffs\n    coeffs = [2.+1.j, 2.+2.j, 3.+0.j, 3.+0.j, 4.+0.j, 5.+0.j, 6.+0.j, 7.+0.j]\n\n    # init\n    spo = SparsePauliOp(labels, coeffs)\n    print('Initial Ordering')\n    print(spo)\n\n    # Lexicographic Ordering\n    srt = spo.argsort()\n    print('Lexicographically sorted')\n    print(srt)\n\n    # Lexicographic Ordering\n    srt = spo.argsort(weight=False)\n    print('Lexicographically sorted')\n    print(srt)\n\n    # Weight Ordering\n    srt = spo.argsort(weight=True)\n    print('Weight sorted')\n    print(srt)\n\n.. parsed-literal::\n\n    Initial Ordering\n    SparsePauliOp(['XX', 'XX', 'XX', 'YI', 'II', 'XZ', 'XY', 'XI'],\n                  coeffs=[2.+1.j, 2.+2.j, 3.+0.j, 3.+0.j, 4.+0.j, 5.+0.j, 6.+0.j, 7.+0.j])\n    Lexicographically sorted\n    [4 7 0 1 2 6 5 3]\n    Lexicographically sorted\n    [4 7 0 1 2 6 5 3]\n    Weight sorted\n    [4 7 3 0 1 2 6 5]\n\nArgs:\n    weight (bool): optionally sort by weight if True (Default: False).\n    By using the weight kwarg the output can additionally be sorted\n    by the number of non-identity terms in the Pauli.\n\nReturns:\n    array: the indices for sorting the table.",
        "api_signature": "argsort(self, weight)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "sort",
        "full_api_name": "SparsePauliOp.sort",
        "api_description": "Sort the rows of the table.\n\nAfter sorting the coefficients using numpy's argsort, sort by Pauli.\nPauli sort takes precedence.\nIf Pauli is the same, it will be sorted by coefficient.\nBy using the `weight` kwarg the output can additionally be sorted\nby the number of non-identity terms in the Pauli, where the set of\nall Pauli's of a given weight are still ordered lexicographically.\n\n**Example**\n\nHere is an example of how to use SparsePauliOp sort.\n\n.. code-block::\n\n    import numpy as np\n    from qiskit.quantum_info import SparsePauliOp\n\n    # 2-qubit labels\n    labels = [\"XX\", \"XX\", \"XX\", \"YI\", \"II\", \"XZ\", \"XY\", \"XI\"]\n    # coeffs\n    coeffs = [2.+1.j, 2.+2.j, 3.+0.j, 3.+0.j, 4.+0.j, 5.+0.j, 6.+0.j, 7.+0.j]\n\n    # init\n    spo = SparsePauliOp(labels, coeffs)\n    print('Initial Ordering')\n    print(spo)\n\n    # Lexicographic Ordering\n    srt = spo.sort()\n    print('Lexicographically sorted')\n    print(srt)\n\n    # Lexicographic Ordering\n    srt = spo.sort(weight=False)\n    print('Lexicographically sorted')\n    print(srt)\n\n    # Weight Ordering\n    srt = spo.sort(weight=True)\n    print('Weight sorted')\n    print(srt)\n\n.. parsed-literal::\n\n    Initial Ordering\n    SparsePauliOp(['XX', 'XX', 'XX', 'YI', 'II', 'XZ', 'XY', 'XI'],\n                  coeffs=[2.+1.j, 2.+2.j, 3.+0.j, 3.+0.j, 4.+0.j, 5.+0.j, 6.+0.j, 7.+0.j])\n    Lexicographically sorted\n    SparsePauliOp(['II', 'XI', 'XX', 'XX', 'XX', 'XY', 'XZ', 'YI'],\n                  coeffs=[4.+0.j, 7.+0.j, 2.+1.j, 2.+2.j, 3.+0.j, 6.+0.j, 5.+0.j, 3.+0.j])\n    Lexicographically sorted\n    SparsePauliOp(['II', 'XI', 'XX', 'XX', 'XX', 'XY', 'XZ', 'YI'],\n                  coeffs=[4.+0.j, 7.+0.j, 2.+1.j, 2.+2.j, 3.+0.j, 6.+0.j, 5.+0.j, 3.+0.j])\n    Weight sorted\n    SparsePauliOp(['II', 'XI', 'YI', 'XX', 'XX', 'XX', 'XY', 'XZ'],\n                  coeffs=[4.+0.j, 7.+0.j, 3.+0.j, 2.+1.j, 2.+2.j, 3.+0.j, 6.+0.j, 5.+0.j])\n\nArgs:\n    weight (bool): optionally sort by weight if True (Default: False).\n    By using the weight kwarg the output can additionally be sorted\n    by the number of non-identity terms in the Pauli.\n\nReturns:\n    SparsePauliOp: a sorted copy of the original table.",
        "api_signature": "sort(self, weight)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "chop",
        "full_api_name": "SparsePauliOp.chop",
        "api_description": "Set real and imaginary parts of the coefficients to 0 if ``< tol`` in magnitude.\n\nFor example, the operator representing ``1+1e-17j X + 1e-17 Y`` with a tolerance larger\nthan ``1e-17`` will be reduced to ``1 X`` whereas :meth:`.SparsePauliOp.simplify` would\nreturn ``1+1e-17j X``.\n\nIf a both the real and imaginary part of a coefficient is 0 after chopping, the\ncorresponding Pauli is removed from the operator.\n\nArgs:\n    tol (float): The absolute tolerance to check whether a real or imaginary part should\n        be set to 0.\n\nReturns:\n    SparsePauliOp: This operator with chopped coefficients.",
        "api_signature": "chop(self, tol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "sum",
        "full_api_name": "SparsePauliOp.sum",
        "api_description": "Sum of SparsePauliOps.\n\nThis is a specialized version of the builtin ``sum`` function for SparsePauliOp\nwith smaller overhead.\n\nArgs:\n    ops (list[SparsePauliOp]): a list of SparsePauliOps.\n\nReturns:\n    SparsePauliOp: the SparsePauliOp representing the sum of the input list.\n\nRaises:\n    QiskitError: if the input list is empty.\n    QiskitError: if the input list includes an object that is not SparsePauliOp.\n    QiskitError: if the numbers of qubits of the objects in the input list do not match.",
        "api_signature": "sum(ops)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "from_operator",
        "full_api_name": "SparsePauliOp.from_operator",
        "api_description": "Construct from an Operator objector.\n\nNote that the cost of this construction is exponential in general because the number of\npossible Pauli terms in the decomposition is exponential in the number of qubits.\n\nInternally this uses an implementation of the \"tensorized Pauli decomposition\" presented in\n`Hantzko, Binkowski and Gupta (2023) <https://arxiv.org/abs/2310.13421>`__.\n\nArgs:\n    obj (Operator): an N-qubit operator.\n    atol (float): Optional. Absolute tolerance for checking if coefficients are zero\n        (Default: 1e-8).  Since the comparison is to zero, in effect the tolerance used is\n        the maximum of ``atol`` and ``rtol``.\n    rtol (float): Optional. relative tolerance for checking if coefficients are zero\n        (Default: 1e-5).  Since the comparison is to zero, in effect the tolerance used is\n        the maximum of ``atol`` and ``rtol``.\n\nReturns:\n    SparsePauliOp: the SparsePauliOp representation of the operator.\n\nRaises:\n    QiskitError: if the input operator is not an N-qubit operator.",
        "api_signature": "from_operator(obj, atol, rtol)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "from_list",
        "full_api_name": "SparsePauliOp.from_list",
        "api_description": "Construct from a list of Pauli strings and coefficients.\n\nFor example, the 5-qubit Hamiltonian\n\n.. math::\n\n    H = Z_1 X_4 + 2 Y_0 Y_3\n\ncan be constructed as\n\n.. code-block:: python\n\n    # via tuples and the full Pauli string\n    op = SparsePauliOp.from_list([(\"XIIZI\", 1), (\"IYIIY\", 2)])\n\nArgs:\n    obj (Iterable[Tuple[str, complex]]): The list of 2-tuples specifying the Pauli terms.\n    dtype (type): The dtype of coeffs (Default: complex).\n    num_qubits (int): The number of qubits of the operator (Default: None).\n\nReturns:\n    SparsePauliOp: The SparsePauliOp representation of the Pauli terms.\n\nRaises:\n    QiskitError: If an empty list is passed and num_qubits is None.\n    QiskitError: If num_qubits and the objects in the input list do not match.",
        "api_signature": "from_list(obj, dtype)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "from_sparse_list",
        "full_api_name": "SparsePauliOp.from_sparse_list",
        "api_description": "Construct from a list of local Pauli strings and coefficients.\n\nEach list element is a 3-tuple of a local Pauli string, indices where to apply it,\nand a coefficient.\n\nFor example, the 5-qubit Hamiltonian\n\n.. math::\n\n    H = Z_1 X_4 + 2 Y_0 Y_3\n\ncan be constructed as\n\n.. code-block:: python\n\n    # via triples and local Paulis with indices\n    op = SparsePauliOp.from_sparse_list([(\"ZX\", [1, 4], 1), (\"YY\", [0, 3], 2)], num_qubits=5)\n\n    # equals the following construction from \"dense\" Paulis\n    op = SparsePauliOp.from_list([(\"XIIZI\", 1), (\"IYIIY\", 2)])\n\nArgs:\n    obj (Iterable[tuple[str, list[int], complex]]): The list 3-tuples specifying the Paulis.\n    num_qubits (int): The number of qubits of the operator.\n    do_checks (bool): The flag of checking if the input indices are not duplicated\n    (Default: True).\n    dtype (type): The dtype of coeffs (Default: complex).\n\nReturns:\n    SparsePauliOp: The SparsePauliOp representation of the Pauli terms.\n\nRaises:\n    QiskitError: If the number of qubits is incompatible with the indices of the Pauli terms.\n    QiskitError: If the designated qubit is already assigned.",
        "api_signature": "from_sparse_list(obj, num_qubits, do_checks, dtype)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "to_list",
        "full_api_name": "SparsePauliOp.to_list",
        "api_description": "Convert to a list Pauli string labels and coefficients.\n\nFor operators with a lot of terms converting using the ``array=True``\nkwarg will be more efficient since it allocates memory for\nthe full Numpy array of labels in advance.\n\nArgs:\n    array (bool): return a Numpy array if True, otherwise\n                  return a list (Default: False).\n\nReturns:\n    list or array: List of pairs (label, coeff) for rows of the PauliList.",
        "api_signature": "to_list(self, array)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "to_matrix",
        "full_api_name": "SparsePauliOp.to_matrix",
        "api_description": "Convert to a dense or sparse matrix.\n\nArgs:\n    sparse: if ``True`` return a sparse CSR matrix, otherwise return dense Numpy\n        array (the default).\n    force_serial: if ``True``, use an unthreaded implementation, regardless of the state of\n        the `Qiskit threading-control environment variables\n        <https://docs.quantum.ibm.com/guides/configure-qiskit-local#environment-variables>`__.\n        By default, this will use threaded parallelism over the available CPUs.\n\nReturns:\n    array: A dense matrix if `sparse=False`.\n    csr_matrix: A sparse matrix in CSR format if `sparse=True`.",
        "api_signature": "to_matrix(self, sparse, force_serial)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "to_operator",
        "full_api_name": "SparsePauliOp.to_operator",
        "api_description": "Convert to a matrix Operator object",
        "api_signature": "to_operator(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "label_iter",
        "full_api_name": "SparsePauliOp.label_iter",
        "api_description": "Return a label representation iterator.\n\nThis is a lazy iterator that converts each term in the SparsePauliOp\ninto a tuple (label, coeff). To convert the entire table to labels\nuse the :meth:`to_labels` method.\n\nReturns:\n    LabelIterator: label iterator object for the SparsePauliOp.",
        "api_signature": "label_iter(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "LabelIterator.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "__getitem__",
        "full_api_name": "LabelIterator.__getitem__",
        "api_description": "",
        "api_signature": "__getitem__(self, key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "matrix_iter",
        "full_api_name": "matrix_iter",
        "api_description": "Return a matrix representation iterator.\n\nThis is a lazy iterator that converts each term in the SparsePauliOp\ninto a matrix as it is used. To convert to a single matrix use the\n:meth:`to_matrix` method.\n\nArgs:\n    sparse (bool): optionally return sparse CSR matrices if True,\n                   otherwise return Numpy array matrices\n                   (Default: False)\n\nReturns:\n    MatrixIterator: matrix iterator object for the PauliList.",
        "api_signature": "matrix_iter(self, sparse)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "MatrixIterator.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "__getitem__",
        "full_api_name": "MatrixIterator.__getitem__",
        "api_description": "",
        "api_signature": "__getitem__(self, key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "noncommutation_graph",
        "full_api_name": "noncommutation_graph",
        "api_description": "Create the non-commutation graph of this SparsePauliOp.\n\nThis transforms the measurement operator grouping problem into graph coloring problem. The\nconstructed graph contains one node for each Pauli. The nodes will be connecting for any two\nPauli terms that do _not_ commute.\n\nArgs:\n    qubit_wise (bool): whether the commutation rule is applied to the whole operator,\n        or on a per-qubit basis.\n\nReturns:\n    rustworkx.PyGraph: the non-commutation graph with nodes for each Pauli and edges\n        indicating a non-commutation relation. Each node will hold the index of the Pauli\n        term it corresponds to in its data. The edges of the graph hold no data.",
        "api_signature": "noncommutation_graph(self, qubit_wise)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "group_commuting",
        "full_api_name": "group_commuting",
        "api_description": "Partition a SparsePauliOp into sets of commuting Pauli strings.\n\nArgs:\n    qubit_wise (bool): whether the commutation rule is applied to the whole operator,\n        or on a per-qubit basis.  For example:\n\n        .. code-block:: python\n\n            >>> op = SparsePauliOp.from_list([(\"XX\", 2), (\"YY\", 1), (\"IZ\",2j), (\"ZZ\",1j)])\n            >>> op.group_commuting()\n            [SparsePauliOp([\"IZ\", \"ZZ\"], coeffs=[0.+2.j, 0.+1j]),\n             SparsePauliOp([\"XX\", \"YY\"], coeffs=[2.+0.j, 1.+0.j])]\n            >>> op.group_commuting(qubit_wise=True)\n            [SparsePauliOp(['XX'], coeffs=[2.+0.j]),\n             SparsePauliOp(['YY'], coeffs=[1.+0.j]),\n             SparsePauliOp(['IZ', 'ZZ'], coeffs=[0.+2.j, 0.+1.j])]\n\nReturns:\n    list[SparsePauliOp]: List of SparsePauliOp where each SparsePauliOp contains\n        commuting Pauli operators.",
        "api_signature": "group_commuting(self, qubit_wise)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "parameters",
        "full_api_name": "parameters",
        "api_description": "Return the free ``Parameter``\\s in the coefficients.",
        "api_signature": "parameters(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "assign_parameters",
        "full_api_name": "assign_parameters",
        "api_description": "Bind the free ``Parameter``\\s in the coefficients to provided values.\n\nArgs:\n    parameters: The values to bind the parameters to.\n    inplace: If ``False``, a copy of the operator with the bound parameters is returned.\n        If ``True`` the operator itself is modified.\n\nReturns:\n    A copy of the operator with bound parameters, if ``inplace`` is ``False``, otherwise\n    ``None``.",
        "api_signature": "assign_parameters(self, parameters, inplace)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "apply_layout",
        "full_api_name": "apply_layout",
        "api_description": "Apply a transpiler layout to this :class:`~.SparsePauliOp`\n\nArgs:\n    layout: Either a :class:`~.TranspileLayout`, a list of integers or None.\n            If both layout and num_qubits are none, a copy of the operator is\n            returned.\n    num_qubits: The number of qubits to expand the operator to. If not\n        provided then if ``layout`` is a :class:`~.TranspileLayout` the\n        number of the transpiler output circuit qubits will be used by\n        default. If ``layout`` is a list of integers the permutation\n        specified will be applied without any expansion. If layout is\n        None, the operator will be expanded to the given number of qubits.\n\nReturns:\n    A new :class:`.SparsePauliOp` with the provided layout applied",
        "api_signature": "apply_layout(self, layout, num_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/sparse_pauli_op.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "PauliList.__init__",
        "api_description": "Initialize the PauliList.\n\nArgs:\n    data (Pauli or list): input data for Paulis. If input is a list each item in the list\n                          must be a Pauli object or Pauli str.\n\nRaises:\n    QiskitError: if input array is invalid shape.\n\nAdditional Information:\n    The input array is not copied so multiple Pauli tables\n    can share the same underlying array.",
        "api_signature": "__init__(self, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "settings",
        "full_api_name": "PauliList.settings",
        "api_description": "Return settings.",
        "api_signature": "settings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "PauliList.__array__",
        "api_description": "Convert to numpy array",
        "api_signature": "__array__(self, dtype, copy)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "_from_paulis",
        "full_api_name": "PauliList._from_paulis",
        "api_description": "Construct a PauliList from a list of Pauli data.\n\nArgs:\n    data (iterable): list of Pauli data.\n\nReturns:\n    PauliList: the constructed PauliList.\n\nRaises:\n    QiskitError: If the input list is empty or contains invalid\n    Pauli strings.",
        "api_signature": "_from_paulis(data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "PauliList.__repr__",
        "api_description": "Display representation.",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "PauliList.__str__",
        "api_description": "Print representation.",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "_truncated_str",
        "full_api_name": "PauliList._truncated_str",
        "api_description": "",
        "api_signature": "_truncated_str(self, show_class)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "PauliList.__eq__",
        "api_description": "Entrywise comparison of Pauli equality.",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "equiv",
        "full_api_name": "PauliList.equiv",
        "api_description": "Entrywise comparison of Pauli equivalence up to global phase.\n\nArgs:\n    other (PauliList or Pauli): a comparison object.\n\nReturns:\n    np.ndarray: An array of ``True`` or ``False`` for entrywise equivalence\n                of the current table.",
        "api_signature": "equiv(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "phase",
        "full_api_name": "PauliList.phase",
        "api_description": "Return the phase exponent of the PauliList.",
        "api_signature": "phase(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "phase",
        "full_api_name": "PauliList.phase",
        "api_description": "",
        "api_signature": "phase(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "x",
        "full_api_name": "PauliList.x",
        "api_description": "The x array for the symplectic representation.",
        "api_signature": "x(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "x",
        "full_api_name": "PauliList.x",
        "api_description": "",
        "api_signature": "x(self, val)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "z",
        "full_api_name": "PauliList.z",
        "api_description": "The z array for the symplectic representation.",
        "api_signature": "z(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "z",
        "full_api_name": "PauliList.z",
        "api_description": "",
        "api_signature": "z(self, val)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "shape",
        "full_api_name": "PauliList.shape",
        "api_description": "The full shape of the :meth:`array`",
        "api_signature": "shape(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "size",
        "full_api_name": "PauliList.size",
        "api_description": "The number of Pauli rows in the table.",
        "api_signature": "size(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "__len__",
        "full_api_name": "PauliList.__len__",
        "api_description": "Return the number of Pauli rows in the table.",
        "api_signature": "__len__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "__getitem__",
        "full_api_name": "PauliList.__getitem__",
        "api_description": "Return a view of the PauliList.",
        "api_signature": "__getitem__(self, index)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "__setitem__",
        "full_api_name": "PauliList.__setitem__",
        "api_description": "Update PauliList.",
        "api_signature": "__setitem__(self, index, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "delete",
        "full_api_name": "PauliList.delete",
        "api_description": "Return a copy with Pauli rows deleted from table.\n\nWhen deleting qubits the qubit index is the same as the\ncolumn index of the underlying :attr:`X` and :attr:`Z` arrays.\n\nArgs:\n    ind (int or list): index(es) to delete.\n    qubit (bool): if ``True`` delete qubit columns, otherwise delete\n                  Pauli rows (Default: ``False``).\n\nReturns:\n    PauliList: the resulting table with the entries removed.\n\nRaises:\n    QiskitError: if ``ind`` is out of bounds for the array size or\n                 number of qubits.",
        "api_signature": "delete(self, ind, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "insert",
        "full_api_name": "PauliList.insert",
        "api_description": "Insert Paulis into the table.\n\nWhen inserting qubits the qubit index is the same as the\ncolumn index of the underlying :attr:`X` and :attr:`Z` arrays.\n\nArgs:\n    ind (int): index to insert at.\n    value (PauliList): values to insert.\n    qubit (bool): if ``True`` insert qubit columns, otherwise insert\n                  Pauli rows (Default: ``False``).\n\nReturns:\n    PauliList: the resulting table with the entries inserted.\n\nRaises:\n    QiskitError: if the insertion index is invalid.",
        "api_signature": "insert(self, ind, value, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "argsort",
        "full_api_name": "PauliList.argsort",
        "api_description": "Return indices for sorting the rows of the table.\n\nThe default sort method is lexicographic sorting by qubit number.\nBy using the `weight` kwarg the output can additionally be sorted\nby the number of non-identity terms in the Pauli, where the set of\nall Paulis of a given weight are still ordered lexicographically.\n\nArgs:\n    weight (bool): Optionally sort by weight if ``True`` (Default: ``False``).\n    phase (bool): Optionally sort by phase before weight or order\n                  (Default: ``False``).\n\nReturns:\n    array: the indices for sorting the table.",
        "api_signature": "argsort(self, weight, phase)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "sort",
        "full_api_name": "PauliList.sort",
        "api_description": "Sort the rows of the table.\n\nThe default sort method is lexicographic sorting by qubit number.\nBy using the `weight` kwarg the output can additionally be sorted\nby the number of non-identity terms in the Pauli, where the set of\nall Paulis of a given weight are still ordered lexicographically.\n\n**Example**\n\nConsider sorting all a random ordering of all 2-qubit Paulis\n\n.. code-block::\n\n    from numpy.random import shuffle\n    from qiskit.quantum_info.operators import PauliList\n\n    # 2-qubit labels\n    labels = ['II', 'IX', 'IY', 'IZ', 'XI', 'XX', 'XY', 'XZ',\n              'YI', 'YX', 'YY', 'YZ', 'ZI', 'ZX', 'ZY', 'ZZ']\n    # Shuffle Labels\n    shuffle(labels)\n    pt = PauliList(labels)\n    print('Initial Ordering')\n    print(pt)\n\n    # Lexicographic Ordering\n    srt = pt.sort()\n    print('Lexicographically sorted')\n    print(srt)\n\n    # Weight Ordering\n    srt = pt.sort(weight=True)\n    print('Weight sorted')\n    print(srt)\n\n.. parsed-literal::\n\n    Initial Ordering\n    ['YX', 'ZZ', 'XZ', 'YI', 'YZ', 'II', 'XX', 'XI', 'XY', 'YY', 'IX', 'IZ',\n     'ZY', 'ZI', 'ZX', 'IY']\n    Lexicographically sorted\n    ['II', 'IX', 'IY', 'IZ', 'XI', 'XX', 'XY', 'XZ', 'YI', 'YX', 'YY', 'YZ',\n     'ZI', 'ZX', 'ZY', 'ZZ']\n    Weight sorted\n    ['II', 'IX', 'IY', 'IZ', 'XI', 'YI', 'ZI', 'XX', 'XY', 'XZ', 'YX', 'YY',\n     'YZ', 'ZX', 'ZY', 'ZZ']\n\nArgs:\n    weight (bool): optionally sort by weight if ``True`` (Default: ``False``).\n    phase (bool): Optionally sort by phase before weight or order\n                  (Default: ``False``).\n\nReturns:\n    PauliList: a sorted copy of the original table.",
        "api_signature": "sort(self, weight, phase)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "unique",
        "full_api_name": "PauliList.unique",
        "api_description": "Return unique Paulis from the table.\n\n**Example**\n\n.. code-block::\n\n    from qiskit.quantum_info.operators import PauliList\n\n    pt = PauliList(['X', 'Y', '-X', 'I', 'I', 'Z', 'X', 'iZ'])\n    unique = pt.unique()\n    print(unique)\n\n.. parsed-literal::\n\n    ['X', 'Y', '-X', 'I', 'Z', 'iZ']\n\nArgs:\n    return_index (bool): If ``True``, also return the indices that\n                         result in the unique array.\n                         (Default: ``False``)\n    return_counts (bool): If ``True``, also return the number of times\n                          each unique item appears in the table.\n\nReturns:\n    PauliList: unique\n        the table of the unique rows.\n\n    unique_indices: np.ndarray, optional\n        The indices of the first occurrences of the unique values in\n        the original array. Only provided if ``return_index`` is ``True``.\n\n    unique_counts: np.array, optional\n        The number of times each of the unique values comes up in the\n        original array. Only provided if ``return_counts`` is ``True``.",
        "api_signature": "unique(self, return_index, return_counts)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "tensor",
        "full_api_name": "PauliList.tensor",
        "api_description": "Return the tensor product with each Pauli in the list.\n\nArgs:\n    other (PauliList): another PauliList.\n\nReturns:\n    PauliList: the list of tensor product Paulis.\n\nRaises:\n    QiskitError: if other cannot be converted to a PauliList, does\n                 not have either 1 or the same number of Paulis as\n                 the current list.",
        "api_signature": "tensor(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "expand",
        "full_api_name": "PauliList.expand",
        "api_description": "Return the expand product of each Pauli in the list.\n\nArgs:\n    other (PauliList): another PauliList.\n\nReturns:\n    PauliList: the list of tensor product Paulis.\n\nRaises:\n    QiskitError: if other cannot be converted to a PauliList, does\n                 not have either 1 or the same number of Paulis as\n                 the current list.",
        "api_signature": "expand(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "compose",
        "full_api_name": "PauliList.compose",
        "api_description": "Return the composition self\u2218other for each Pauli in the list.\n\nArgs:\n    other (PauliList): another PauliList.\n    qargs (None or list): qubits to apply dot product on (Default: ``None``).\n    front (bool): If True use `dot` composition method [default: ``False``].\n    inplace (bool): If ``True`` update in-place (default: ``False``).\n\nReturns:\n    PauliList: the list of composed Paulis.\n\nRaises:\n    QiskitError: if other cannot be converted to a PauliList, does\n                 not have either 1 or the same number of Paulis as\n                 the current list, or has the wrong number of qubits\n                 for the specified ``qargs``.",
        "api_signature": "compose(self, other, qargs, front, inplace)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "dot",
        "full_api_name": "PauliList.dot",
        "api_description": "Return the composition other\u2218self for each Pauli in the list.\n\nArgs:\n    other (PauliList): another PauliList.\n    qargs (None or list): qubits to apply dot product on (Default: ``None``).\n    inplace (bool): If True update in-place (default: ``False``).\n\nReturns:\n    PauliList: the list of composed Paulis.\n\nRaises:\n    QiskitError: if other cannot be converted to a PauliList, does\n                 not have either 1 or the same number of Paulis as\n                 the current list, or has the wrong number of qubits\n                 for the specified ``qargs``.",
        "api_signature": "dot(self, other, qargs, inplace)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "_add",
        "full_api_name": "PauliList._add",
        "api_description": "Append two PauliLists.\n\nIf ``qargs`` are specified the other operator will be added\nassuming it is identity on all other subsystems.\n\nArgs:\n    other (PauliList): another table.\n    qargs (None or list): optional subsystems to add on\n                          (Default: ``None``)\n\nReturns:\n    PauliList: the concatenated list ``self`` + ``other``.",
        "api_signature": "_add(self, other, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "_multiply",
        "full_api_name": "PauliList._multiply",
        "api_description": "Multiply each Pauli in the list by a phase.\n\nArgs:\n    other (complex or array): a complex number in [1, -1j, -1, 1j]\n\nReturns:\n    PauliList: the list of Paulis other * self.\n\nRaises:\n    QiskitError: if the phase is not in the set [1, -1j, -1, 1j].",
        "api_signature": "_multiply(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "conjugate",
        "full_api_name": "PauliList.conjugate",
        "api_description": "Return the conjugate of each Pauli in the list.",
        "api_signature": "conjugate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "transpose",
        "full_api_name": "PauliList.transpose",
        "api_description": "Return the transpose of each Pauli in the list.",
        "api_signature": "transpose(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "adjoint",
        "full_api_name": "PauliList.adjoint",
        "api_description": "Return the adjoint of each Pauli in the list.",
        "api_signature": "adjoint(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "PauliList.inverse",
        "api_description": "Return the inverse of each Pauli in the list.",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "commutes",
        "full_api_name": "PauliList.commutes",
        "api_description": "Return True for each Pauli that commutes with other.\n\nArgs:\n    other (PauliList): another PauliList operator.\n    qargs (list): qubits to apply dot product on (default: ``None``).\n\nReturns:\n    bool: ``True`` if Paulis commute, ``False`` if they anti-commute.",
        "api_signature": "commutes(self, other, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "anticommutes",
        "full_api_name": "PauliList.anticommutes",
        "api_description": "Return ``True`` if other Pauli that anticommutes with other.\n\nArgs:\n    other (PauliList): another PauliList operator.\n    qargs (list): qubits to apply dot product on (default: ``None``).\n\nReturns:\n    bool: ``True`` if Paulis anticommute, ``False`` if they commute.",
        "api_signature": "anticommutes(self, other, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "commutes_with_all",
        "full_api_name": "PauliList.commutes_with_all",
        "api_description": "Return indexes of rows that commute ``other``.\n\nIf ``other`` is a multi-row Pauli list the returned vector indexes rows\nof the current PauliList that commute with *all* Paulis in other.\nIf no rows satisfy the condition the returned array will be empty.\n\nArgs:\n    other (PauliList): a single Pauli or multi-row PauliList.\n\nReturns:\n    array: index array of the commuting rows.",
        "api_signature": "commutes_with_all(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "anticommutes_with_all",
        "full_api_name": "PauliList.anticommutes_with_all",
        "api_description": "Return indexes of rows that commute other.\n\nIf ``other`` is a multi-row Pauli list the returned vector indexes rows\nof the current PauliList that anti-commute with *all* Paulis in other.\nIf no rows satisfy the condition the returned array will be empty.\n\nArgs:\n    other (PauliList): a single Pauli or multi-row PauliList.\n\nReturns:\n    array: index array of the anti-commuting rows.",
        "api_signature": "anticommutes_with_all(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "_commutes_with_all",
        "full_api_name": "PauliList._commutes_with_all",
        "api_description": "Return row indexes that commute with all rows in another PauliList.\n\nArgs:\n    other (PauliList): a PauliList.\n    anti (bool): if ``True`` return rows that anti-commute, otherwise\n                 return rows that commute (Default: ``False``).\n\nReturns:\n    array: index array of commuting or anti-commuting row.",
        "api_signature": "_commutes_with_all(self, other, anti)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "evolve",
        "full_api_name": "PauliList.evolve",
        "api_description": "Performs either Heisenberg (default) or Schr\u00f6dinger picture\nevolution of the Pauli by a Clifford and returns the evolved Pauli.\n\nSchr\u00f6dinger picture evolution can be chosen by passing parameter ``frame='s'``.\nThis option yields a faster calculation.\n\nHeisenberg picture evolves the Pauli as :math:`P^\\prime = C^\\dagger.P.C`.\n\nSchr\u00f6dinger picture evolves the Pauli as :math:`P^\\prime = C.P.C^\\dagger`.\n\nArgs:\n    other (Pauli or Clifford or QuantumCircuit): The Clifford operator to evolve by.\n    qargs (list): a list of qubits to apply the Clifford to.\n    frame (string): ``'h'`` for Heisenberg (default) or ``'s'`` for Schr\u00f6dinger framework.\n\nReturns:\n    PauliList: the Pauli :math:`C^\\dagger.P.C` (Heisenberg picture)\n    or the Pauli :math:`C.P.C^\\dagger` (Schr\u00f6dinger picture).\n\nRaises:\n    QiskitError: if the Clifford number of qubits and qargs don't match.",
        "api_signature": "evolve(self, other, qargs, frame)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "to_labels",
        "full_api_name": "PauliList.to_labels",
        "api_description": "Convert a PauliList to a list Pauli string labels.\n\nFor large PauliLists converting using the ``array=True``\nkwarg will be more efficient since it allocates memory for\nthe full Numpy array of labels in advance.\n\n.. list-table:: Pauli Representations\n    :header-rows: 1\n\n    * - Label\n      - Symplectic\n      - Matrix\n    * - ``\"I\"``\n      - :math:`[0, 0]`\n      - :math:`\\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\end{bmatrix}`\n    * - ``\"X\"``\n      - :math:`[1, 0]`\n      - :math:`\\begin{bmatrix} 0 & 1 \\\\ 1 & 0  \\end{bmatrix}`\n    * - ``\"Y\"``\n      - :math:`[1, 1]`\n      - :math:`\\begin{bmatrix} 0 & -i \\\\ i & 0  \\end{bmatrix}`\n    * - ``\"Z\"``\n      - :math:`[0, 1]`\n      - :math:`\\begin{bmatrix} 1 & 0 \\\\ 0 & -1  \\end{bmatrix}`\n\nArgs:\n    array (bool): return a Numpy array if ``True``, otherwise\n                  return a list (Default: ``False``).\n\nReturns:\n    list or array: The rows of the PauliList in label form.",
        "api_signature": "to_labels(self, array)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "to_matrix",
        "full_api_name": "PauliList.to_matrix",
        "api_description": "Convert to a list or array of Pauli matrices.\n\nFor large PauliLists converting using the ``array=True``\nkwarg will be more efficient since it allocates memory a full\nrank-3 Numpy array of matrices in advance.\n\n.. list-table:: Pauli Representations\n    :header-rows: 1\n\n    * - Label\n      - Symplectic\n      - Matrix\n    * - ``\"I\"``\n      - :math:`[0, 0]`\n      - :math:`\\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\end{bmatrix}`\n    * - ``\"X\"``\n      - :math:`[1, 0]`\n      - :math:`\\begin{bmatrix} 0 & 1 \\\\ 1 & 0  \\end{bmatrix}`\n    * - ``\"Y\"``\n      - :math:`[1, 1]`\n      - :math:`\\begin{bmatrix} 0 & -i \\\\ i & 0  \\end{bmatrix}`\n    * - ``\"Z\"``\n      - :math:`[0, 1]`\n      - :math:`\\begin{bmatrix} 1 & 0 \\\\ 0 & -1  \\end{bmatrix}`\n\nArgs:\n    sparse (bool): if ``True`` return sparse CSR matrices, otherwise\n                   return dense Numpy arrays (Default: ``False``).\n    array (bool): return as rank-3 numpy array if ``True``, otherwise\n                  return a list of Numpy arrays (Default: ``False``).\n\nReturns:\n    list: A list of dense Pauli matrices if ``array=False` and ``sparse=False`.\n    list: A list of sparse Pauli matrices if ``array=False`` and ``sparse=True``.\n    array: A dense rank-3 array of Pauli matrices if ``array=True``.",
        "api_signature": "to_matrix(self, sparse, array)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "label_iter",
        "full_api_name": "PauliList.label_iter",
        "api_description": "Return a label representation iterator.\n\nThis is a lazy iterator that converts each row into the string\nlabel only as it is used. To convert the entire table to labels use\nthe :meth:`to_labels` method.\n\nReturns:\n    LabelIterator: label iterator object for the PauliList.",
        "api_signature": "label_iter(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "LabelIterator.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "__getitem__",
        "full_api_name": "LabelIterator.__getitem__",
        "api_description": "",
        "api_signature": "__getitem__(self, key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "matrix_iter",
        "full_api_name": "matrix_iter",
        "api_description": "Return a matrix representation iterator.\n\nThis is a lazy iterator that converts each row into the Pauli matrix\nrepresentation only as it is used. To convert the entire table to\nmatrices use the :meth:`to_matrix` method.\n\nArgs:\n    sparse (bool): optionally return sparse CSR matrices if ``True``,\n                   otherwise return Numpy array matrices\n                   (Default: ``False``)\n\nReturns:\n    MatrixIterator: matrix iterator object for the PauliList.",
        "api_signature": "matrix_iter(self, sparse)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "MatrixIterator.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "__getitem__",
        "full_api_name": "MatrixIterator.__getitem__",
        "api_description": "",
        "api_signature": "__getitem__(self, key)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "from_symplectic",
        "full_api_name": "from_symplectic",
        "api_description": "Construct a PauliList from a symplectic data.\n\nArgs:\n    z (np.ndarray): 2D boolean Numpy array.\n    x (np.ndarray): 2D boolean Numpy array.\n    phase (np.ndarray or None): Optional, 1D integer array from Z_4.\n\nReturns:\n    PauliList: the constructed PauliList.",
        "api_signature": "from_symplectic(cls, z, x, phase)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "_noncommutation_graph",
        "full_api_name": "_noncommutation_graph",
        "api_description": "Create an edge list representing the non-commutation graph (Pauli Graph).\n\nAn edge (i, j) is present if i and j are not commutable.\n\nArgs:\n    qubit_wise (bool): whether the commutation rule is applied to the whole operator,\n        or on a per-qubit basis.\n\nReturns:\n    list[tuple[int,int]]: A list of pairs of indices of the PauliList that are not commutable.",
        "api_signature": "_noncommutation_graph(self, qubit_wise)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "noncommutation_graph",
        "full_api_name": "noncommutation_graph",
        "api_description": "Create the non-commutation graph of this PauliList.\n\nThis transforms the measurement operator grouping problem into graph coloring problem. The\nconstructed graph contains one node for each Pauli. The nodes will be connecting for any two\nPauli terms that do _not_ commute.\n\nArgs:\n    qubit_wise (bool): whether the commutation rule is applied to the whole operator,\n        or on a per-qubit basis.\n\nReturns:\n    rustworkx.PyGraph: the non-commutation graph with nodes for each Pauli and edges\n        indicating a non-commutation relation. Each node will hold the index of the Pauli\n        term it corresponds to in its data. The edges of the graph hold no data.",
        "api_signature": "noncommutation_graph(self, qubit_wise)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "_commuting_groups",
        "full_api_name": "_commuting_groups",
        "api_description": "Partition a PauliList into sets of commuting Pauli strings.\n\nThis is the internal logic of the public ``PauliList.group_commuting`` method which returns\na mapping of colors to Pauli indices. The same logic is re-used by\n``SparsePauliOp.group_commuting``.\n\nArgs:\n    qubit_wise (bool): whether the commutation rule is applied to the whole operator,\n        or on a per-qubit basis.\n\nReturns:\n    dict[int, list[int]]: Dictionary of color indices mapping to a list of Pauli indices.",
        "api_signature": "_commuting_groups(self, qubit_wise)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "group_qubit_wise_commuting",
        "full_api_name": "group_qubit_wise_commuting",
        "api_description": "Partition a PauliList into sets of mutually qubit-wise commuting Pauli strings.\n\nReturns:\n    list[PauliList]: List of PauliLists where each PauliList contains commutable Pauli operators.",
        "api_signature": "group_qubit_wise_commuting(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "group_commuting",
        "full_api_name": "group_commuting",
        "api_description": "Partition a PauliList into sets of commuting Pauli strings.\n\nArgs:\n    qubit_wise (bool): whether the commutation rule is applied to the whole operator,\n        or on a per-qubit basis.  For example:\n\n        .. code-block:: python\n\n            >>> from qiskit.quantum_info import PauliList\n            >>> op = PauliList([\"XX\", \"YY\", \"IZ\", \"ZZ\"])\n            >>> op.group_commuting()\n            [PauliList(['XX', 'YY']), PauliList(['IZ', 'ZZ'])]\n            >>> op.group_commuting(qubit_wise=True)\n            [PauliList(['XX']), PauliList(['YY']), PauliList(['IZ', 'ZZ'])]\n\nReturns:\n    list[PauliList]: List of PauliLists where each PauliList contains commuting Pauli operators.",
        "api_signature": "group_commuting(self, qubit_wise)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_list.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "BasePauli.__init__",
        "api_description": "Initialize the BasePauli.\n\nThis is an array of M N-qubit Paulis defined as\nP = (-i)^phase Z^z X^x.\n\nArgs:\n    z (np.ndarray): input z matrix.\n    x (np.ndarray): input x matrix.\n    phase (np.ndarray): input phase vector.",
        "api_signature": "__init__(self, z, x, phase)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/base_pauli.py"
    },
    {
        "api_name": "copy",
        "full_api_name": "BasePauli.copy",
        "api_description": "Make a deep copy of current operator.",
        "api_signature": "copy(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/base_pauli.py"
    },
    {
        "api_name": "tensor",
        "full_api_name": "BasePauli.tensor",
        "api_description": "",
        "api_signature": "tensor(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/base_pauli.py"
    },
    {
        "api_name": "expand",
        "full_api_name": "BasePauli.expand",
        "api_description": "",
        "api_signature": "expand(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/base_pauli.py"
    },
    {
        "api_name": "_tensor",
        "full_api_name": "BasePauli._tensor",
        "api_description": "",
        "api_signature": "_tensor(cls, a, b)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/base_pauli.py"
    },
    {
        "api_name": "compose",
        "full_api_name": "BasePauli.compose",
        "api_description": "",
        "api_signature": "compose(self, other, qargs, front, inplace)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/base_pauli.py"
    },
    {
        "api_name": "_multiply",
        "full_api_name": "BasePauli._multiply",
        "api_description": "",
        "api_signature": "_multiply(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/base_pauli.py"
    },
    {
        "api_name": "conjugate",
        "full_api_name": "BasePauli.conjugate",
        "api_description": "Return the conjugate of each Pauli in the list.",
        "api_signature": "conjugate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/base_pauli.py"
    },
    {
        "api_name": "transpose",
        "full_api_name": "BasePauli.transpose",
        "api_description": "Return the transpose of each Pauli in the list.",
        "api_signature": "transpose(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/base_pauli.py"
    },
    {
        "api_name": "commutes",
        "full_api_name": "BasePauli.commutes",
        "api_description": "Return ``True`` if Pauli commutes with ``other``.\n\nArgs:\n    other (BasePauli): another BasePauli operator.\n    qargs (list): qubits to apply dot product on (default: ``None``).\n\nReturns:\n    np.array: Boolean array of ``True`` if Paulis commute, ``False`` if\n              they anti-commute.\n\nRaises:\n    QiskitError: if number of qubits of ``other`` does not match ``qargs``.",
        "api_signature": "commutes(self, other, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/base_pauli.py"
    },
    {
        "api_name": "evolve",
        "full_api_name": "BasePauli.evolve",
        "api_description": "Performs either Heisenberg (default) or Schr\u00f6dinger picture\nevolution of the Pauli by a Clifford and returns the evolved Pauli.\n\nSchr\u00f6dinger picture evolution can be chosen by passing parameter ``frame='s'``.\nThis option yields a faster calculation.\n\nHeisenberg picture evolves the Pauli as :math:`P^\\prime = C^\\dagger.P.C`.\n\nSchr\u00f6dinger picture evolves the Pauli as :math:`P^\\prime = C.P.C^\\dagger`.\n\nArgs:\n    other (BasePauli or QuantumCircuit): The Clifford circuit to evolve by.\n    qargs (list): a list of qubits to apply the Clifford to.\n    frame (string): ``'h'`` for Heisenberg or ``'s'`` for Schr\u00f6dinger framework.\n\nReturns:\n    BasePauli: the Pauli :math:`C^\\dagger.P.C` (Heisenberg picture)\n    or the Pauli :math:`C.P.C^\\dagger` (Schr\u00f6dinger picture).\n\nRaises:\n    QiskitError: if the Clifford number of qubits and ``qargs`` don't match.",
        "api_signature": "evolve(self, other, qargs, frame)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/base_pauli.py"
    },
    {
        "api_name": "_evolve_clifford",
        "full_api_name": "BasePauli._evolve_clifford",
        "api_description": "Heisenberg picture evolution of a Pauli by a Clifford.",
        "api_signature": "_evolve_clifford(self, other, qargs, frame)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/base_pauli.py"
    },
    {
        "api_name": "_eq",
        "full_api_name": "BasePauli._eq",
        "api_description": "Entrywise comparison of Pauli equality.",
        "api_signature": "_eq(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/base_pauli.py"
    },
    {
        "api_name": "__imul__",
        "full_api_name": "BasePauli.__imul__",
        "api_description": "",
        "api_signature": "__imul__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/base_pauli.py"
    },
    {
        "api_name": "__neg__",
        "full_api_name": "BasePauli.__neg__",
        "api_description": "",
        "api_signature": "__neg__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/base_pauli.py"
    },
    {
        "api_name": "_count_y",
        "full_api_name": "BasePauli._count_y",
        "api_description": "Count the number of I Paulis",
        "api_signature": "_count_y(self, dtype)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/base_pauli.py"
    },
    {
        "api_name": "_stack",
        "full_api_name": "BasePauli._stack",
        "api_description": "Stack array.",
        "api_signature": "_stack(array, size, vertical)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/base_pauli.py"
    },
    {
        "api_name": "_phase_from_complex",
        "full_api_name": "BasePauli._phase_from_complex",
        "api_description": "Return the phase from a label",
        "api_signature": "_phase_from_complex(coeff)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/base_pauli.py"
    },
    {
        "api_name": "_from_array",
        "full_api_name": "BasePauli._from_array",
        "api_description": "Convert array data to BasePauli data.",
        "api_signature": "_from_array(z, x, phase)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/base_pauli.py"
    },
    {
        "api_name": "_to_matrix",
        "full_api_name": "BasePauli._to_matrix",
        "api_description": "Return the matrix from symplectic representation.\n\nThe Pauli is defined as :math:`P = (-i)^{phase + z.x} * Z^z.x^x`\nwhere ``array = [x, z]``.\n\nArgs:\n    z (array): The symplectic representation z vector.\n    x (array): The symplectic representation x vector.\n    phase (int): Pauli phase.\n    group_phase (bool): Optional. If ``True`` use group-phase convention\n                        instead of BasePauli ZX-phase convention.\n                        (default: ``False``).\n    sparse (bool): Optional. Of ``True`` return a sparse CSR matrix,\n                   otherwise return a dense Numpy array\n                   (default: ``False``).\n\nReturns:\n    array: if ``sparse=False``.\n    csr_matrix: if ``sparse=True``.",
        "api_signature": "_to_matrix(z, x, phase, group_phase, sparse)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/base_pauli.py"
    },
    {
        "api_name": "_to_label",
        "full_api_name": "BasePauli._to_label",
        "api_description": "Return the label string for a Pauli.\n\nArgs:\n    z (array): The symplectic representation z vector.\n    x (array): The symplectic representation x vector.\n    phase (int): Pauli phase.\n    group_phase (bool): Optional. If ``True`` use group-phase convention\n                        instead of BasePauli ZX-phase convention.\n                        (default: ``False``).\n    full_group (bool): If True return the Pauli label from the full Pauli group\n        including complex coefficient from [1, -1, 1j, -1j]. If\n        ``False`` return the unsigned Pauli label with coefficient 1\n        (default: ``True``).\n    return_phase (bool): If ``True`` return the adjusted phase for the coefficient\n        of the returned Pauli label. This can be used even if\n        ``full_group=False``.\n\nReturns:\n    str: the Pauli label from the full Pauli group (if ``full_group=True``) or\n        from the unsigned Pauli group (if ``full_group=False``).\n    tuple[str, int]: if ``return_phase=True`` returns a tuple of the Pauli\n                    label (from either the full or unsigned Pauli group) and\n                    the phase ``q`` for the coefficient :math:`(-i)^(q + x.z)`\n                    for the label from the full Pauli group.",
        "api_signature": "_to_label(z, x, phase, group_phase, full_group, return_phase)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/base_pauli.py"
    },
    {
        "api_name": "_append_circuit",
        "full_api_name": "BasePauli._append_circuit",
        "api_description": "Update BasePauli inplace by applying a Clifford circuit.\n\nArgs:\n    circuit (QuantumCircuit or Instruction): the gate or composite gate to apply.\n    qargs (list or None): The qubits to apply gate to.\n\nReturns:\n    BasePauli: the updated Pauli.\n\nRaises:\n    QiskitError: if input gate cannot be decomposed into Clifford gates.",
        "api_signature": "_append_circuit(self, circuit, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/base_pauli.py"
    },
    {
        "api_name": "_evolve_h",
        "full_api_name": "_evolve_h",
        "api_description": "Update P -> H.P.H",
        "api_signature": "_evolve_h(base_pauli, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/base_pauli.py"
    },
    {
        "api_name": "_evolve_s",
        "full_api_name": "_evolve_s",
        "api_description": "Update P -> S.P.Sdg",
        "api_signature": "_evolve_s(base_pauli, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/base_pauli.py"
    },
    {
        "api_name": "_evolve_sdg",
        "full_api_name": "_evolve_sdg",
        "api_description": "Update P -> Sdg.P.S",
        "api_signature": "_evolve_sdg(base_pauli, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/base_pauli.py"
    },
    {
        "api_name": "_evolve_i",
        "full_api_name": "_evolve_i",
        "api_description": "Update P -> P",
        "api_signature": "_evolve_i(base_pauli, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/base_pauli.py"
    },
    {
        "api_name": "_evolve_x",
        "full_api_name": "_evolve_x",
        "api_description": "Update P -> X.P.X",
        "api_signature": "_evolve_x(base_pauli, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/base_pauli.py"
    },
    {
        "api_name": "_evolve_y",
        "full_api_name": "_evolve_y",
        "api_description": "Update P -> Y.P.Y",
        "api_signature": "_evolve_y(base_pauli, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/base_pauli.py"
    },
    {
        "api_name": "_evolve_z",
        "full_api_name": "_evolve_z",
        "api_description": "Update P -> Z.P.Z",
        "api_signature": "_evolve_z(base_pauli, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/base_pauli.py"
    },
    {
        "api_name": "_evolve_cx",
        "full_api_name": "_evolve_cx",
        "api_description": "Update P -> CX.P.CX",
        "api_signature": "_evolve_cx(base_pauli, qctrl, qtrgt)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/base_pauli.py"
    },
    {
        "api_name": "_evolve_cz",
        "full_api_name": "_evolve_cz",
        "api_description": "Update P -> CZ.P.CZ",
        "api_signature": "_evolve_cz(base_pauli, q1, q2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/base_pauli.py"
    },
    {
        "api_name": "_evolve_cy",
        "full_api_name": "_evolve_cy",
        "api_description": "Update P -> CY.P.CY",
        "api_signature": "_evolve_cy(base_pauli, qctrl, qtrgt)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/base_pauli.py"
    },
    {
        "api_name": "_evolve_swap",
        "full_api_name": "_evolve_swap",
        "api_description": "Update P -> SWAP.P.SWAP",
        "api_signature": "_evolve_swap(base_pauli, q1, q2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/base_pauli.py"
    },
    {
        "api_name": "_evolve_ecr",
        "full_api_name": "_evolve_ecr",
        "api_description": "Update P -> ECR.P.ECR",
        "api_signature": "_evolve_ecr(base_pauli, q1, q2)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/base_pauli.py"
    },
    {
        "api_name": "_count_y",
        "full_api_name": "_count_y",
        "api_description": "Count the number of I Paulis",
        "api_signature": "_count_y(x, z, dtype)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/base_pauli.py"
    },
    {
        "api_name": "_append_circuit",
        "full_api_name": "_append_circuit",
        "api_description": "Update Clifford inplace by applying a Clifford circuit.\n\nArgs:\n    clifford (Clifford): The Clifford to update.\n    circuit (QuantumCircuit): The circuit to apply.\n    qargs (list or None): The qubits to apply circuit to.\n\nReturns:\n    Clifford: the updated Clifford.\n\nRaises:\n    QiskitError: if input circuit cannot be decomposed into Clifford operations.",
        "api_signature": "_append_circuit(clifford, circuit, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford_circuits.py"
    },
    {
        "api_name": "_append_operation",
        "full_api_name": "_append_operation",
        "api_description": "Update Clifford inplace by applying a Clifford operation.\n\nArgs:\n    clifford (Clifford): The Clifford to update.\n    operation (Instruction or Clifford or str): The operation or composite operation to apply.\n    qargs (list or None): The qubits to apply operation to.\n\nReturns:\n    Clifford: the updated Clifford.\n\nRaises:\n    QiskitError: if input operation cannot be converted into Clifford operations.",
        "api_signature": "_append_operation(clifford, operation, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford_circuits.py"
    },
    {
        "api_name": "_n_half_pis",
        "full_api_name": "_n_half_pis",
        "api_description": "",
        "api_signature": "_n_half_pis(param)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford_circuits.py"
    },
    {
        "api_name": "_append_rz",
        "full_api_name": "_append_rz",
        "api_description": "Apply an Rz gate to a Clifford.\n\nArgs:\n    clifford (Clifford): a Clifford.\n    qubit (int): gate qubit index.\n    multiple (int): z-rotation angle in a multiple of pi/2\n\nReturns:\n    Clifford: the updated Clifford.",
        "api_signature": "_append_rz(clifford, qubit, multiple)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford_circuits.py"
    },
    {
        "api_name": "_append_i",
        "full_api_name": "_append_i",
        "api_description": "Apply an I gate to a Clifford.\n\nArgs:\n    clifford (Clifford): a Clifford.\n    qubit (int): gate qubit index.\n\nReturns:\n    Clifford: the updated Clifford.",
        "api_signature": "_append_i(clifford, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford_circuits.py"
    },
    {
        "api_name": "_append_x",
        "full_api_name": "_append_x",
        "api_description": "Apply an X gate to a Clifford.\n\nArgs:\n    clifford (Clifford): a Clifford.\n    qubit (int): gate qubit index.\n\nReturns:\n    Clifford: the updated Clifford.",
        "api_signature": "_append_x(clifford, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford_circuits.py"
    },
    {
        "api_name": "_append_y",
        "full_api_name": "_append_y",
        "api_description": "Apply a Y gate to a Clifford.\n\nArgs:\n    clifford (Clifford): a Clifford.\n    qubit (int): gate qubit index.\n\nReturns:\n    Clifford: the updated Clifford.",
        "api_signature": "_append_y(clifford, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford_circuits.py"
    },
    {
        "api_name": "_append_z",
        "full_api_name": "_append_z",
        "api_description": "Apply an Z gate to a Clifford.\n\nArgs:\n    clifford (Clifford): a Clifford.\n    qubit (int): gate qubit index.\n\nReturns:\n    Clifford: the updated Clifford.",
        "api_signature": "_append_z(clifford, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford_circuits.py"
    },
    {
        "api_name": "_append_h",
        "full_api_name": "_append_h",
        "api_description": "Apply a H gate to a Clifford.\n\nArgs:\n    clifford (Clifford): a Clifford.\n    qubit (int): gate qubit index.\n\nReturns:\n    Clifford: the updated Clifford.",
        "api_signature": "_append_h(clifford, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford_circuits.py"
    },
    {
        "api_name": "_append_s",
        "full_api_name": "_append_s",
        "api_description": "Apply an S gate to a Clifford.\n\nArgs:\n    clifford (Clifford): a Clifford.\n    qubit (int): gate qubit index.\n\nReturns:\n    Clifford: the updated Clifford.",
        "api_signature": "_append_s(clifford, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford_circuits.py"
    },
    {
        "api_name": "_append_sdg",
        "full_api_name": "_append_sdg",
        "api_description": "Apply an Sdg gate to a Clifford.\n\nArgs:\n    clifford (Clifford): a Clifford.\n    qubit (int): gate qubit index.\n\nReturns:\n    Clifford: the updated Clifford.",
        "api_signature": "_append_sdg(clifford, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford_circuits.py"
    },
    {
        "api_name": "_append_sx",
        "full_api_name": "_append_sx",
        "api_description": "Apply an SX gate to a Clifford.\n\nArgs:\n    clifford (Clifford): a Clifford.\n    qubit (int): gate qubit index.\n\nReturns:\n    Clifford: the updated Clifford.",
        "api_signature": "_append_sx(clifford, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford_circuits.py"
    },
    {
        "api_name": "_append_sxdg",
        "full_api_name": "_append_sxdg",
        "api_description": "Apply an SXdg gate to a Clifford.\n\nArgs:\n    clifford (Clifford): a Clifford.\n    qubit (int): gate qubit index.\n\nReturns:\n    Clifford: the updated Clifford.",
        "api_signature": "_append_sxdg(clifford, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford_circuits.py"
    },
    {
        "api_name": "_append_v",
        "full_api_name": "_append_v",
        "api_description": "Apply a V gate to a Clifford.\n\nThis is equivalent to an Sdg gate followed by a H gate.\n\nArgs:\n    clifford (Clifford): a Clifford.\n    qubit (int): gate qubit index.\n\nReturns:\n    Clifford: the updated Clifford.",
        "api_signature": "_append_v(clifford, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford_circuits.py"
    },
    {
        "api_name": "_append_w",
        "full_api_name": "_append_w",
        "api_description": "Apply a W gate to a Clifford.\n\nThis is equivalent to two V gates.\n\nArgs:\n    clifford (Clifford): a Clifford.\n    qubit (int): gate qubit index.\n\nReturns:\n    Clifford: the updated Clifford.",
        "api_signature": "_append_w(clifford, qubit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford_circuits.py"
    },
    {
        "api_name": "_append_cx",
        "full_api_name": "_append_cx",
        "api_description": "Apply a CX gate to a Clifford.\n\nArgs:\n    clifford (Clifford): a Clifford.\n    control (int): gate control qubit index.\n    target (int): gate target qubit index.\n\nReturns:\n    Clifford: the updated Clifford.",
        "api_signature": "_append_cx(clifford, control, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford_circuits.py"
    },
    {
        "api_name": "_append_cz",
        "full_api_name": "_append_cz",
        "api_description": "Apply a CZ gate to a Clifford.\n\nArgs:\n    clifford (Clifford): a Clifford.\n    control (int): gate control qubit index.\n    target (int): gate target qubit index.\n\nReturns:\n    Clifford: the updated Clifford.",
        "api_signature": "_append_cz(clifford, control, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford_circuits.py"
    },
    {
        "api_name": "_append_cy",
        "full_api_name": "_append_cy",
        "api_description": "Apply a CY gate to a Clifford.\n\nArgs:\n    clifford (Clifford): a Clifford.\n    control (int): gate control qubit index.\n    target (int): gate target qubit index.\n\nReturns:\n    Clifford: the updated Clifford.",
        "api_signature": "_append_cy(clifford, control, target)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford_circuits.py"
    },
    {
        "api_name": "_append_swap",
        "full_api_name": "_append_swap",
        "api_description": "Apply a Swap gate to a Clifford.\n\nArgs:\n    clifford (Clifford): a Clifford.\n    qubit0 (int): first qubit index.\n    qubit1 (int): second  qubit index.\n\nReturns:\n    Clifford: the updated Clifford.",
        "api_signature": "_append_swap(clifford, qubit0, qubit1)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford_circuits.py"
    },
    {
        "api_name": "_append_iswap",
        "full_api_name": "_append_iswap",
        "api_description": "Apply a iSwap gate to a Clifford.\n\nArgs:\n    clifford (Clifford): a Clifford.\n    qubit0 (int): first qubit index.\n    qubit1 (int): second  qubit index.\n\nReturns:\n    Clifford: the updated Clifford.",
        "api_signature": "_append_iswap(clifford, qubit0, qubit1)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford_circuits.py"
    },
    {
        "api_name": "_append_dcx",
        "full_api_name": "_append_dcx",
        "api_description": "Apply a DCX gate to a Clifford.\n\nArgs:\n    clifford (Clifford): a Clifford.\n    qubit0 (int): first qubit index.\n    qubit1 (int): second  qubit index.\n\nReturns:\n    Clifford: the updated Clifford.",
        "api_signature": "_append_dcx(clifford, qubit0, qubit1)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford_circuits.py"
    },
    {
        "api_name": "_append_ecr",
        "full_api_name": "_append_ecr",
        "api_description": "Apply an ECR gate to a Clifford.\n\nArgs:\n    clifford (Clifford): a Clifford.\n    qubit0 (int): first qubit index.\n    qubit1 (int): second  qubit index.\n\nReturns:\n    Clifford: the updated Clifford.",
        "api_signature": "_append_ecr(clifford, qubit0, qubit1)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford_circuits.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "Clifford.__array__",
        "api_description": "",
        "api_signature": "__array__(self, dtype, copy)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Clifford.__init__",
        "api_description": "Initialize an operator object.",
        "api_signature": "__init__(self, data, validate, copy)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "name",
        "full_api_name": "Clifford.name",
        "api_description": "Unique string identifier for operation type.",
        "api_signature": "name(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "num_clbits",
        "full_api_name": "Clifford.num_clbits",
        "api_description": "Number of classical bits.",
        "api_signature": "num_clbits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "Clifford.__repr__",
        "api_description": "",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "Clifford.__str__",
        "api_description": "",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "Clifford.__eq__",
        "api_description": "Check if two Clifford tables are equal",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "copy",
        "full_api_name": "Clifford.copy",
        "api_description": "",
        "api_signature": "copy(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "symplectic_matrix",
        "full_api_name": "Clifford.symplectic_matrix",
        "api_description": "Return boolean symplectic matrix.",
        "api_signature": "symplectic_matrix(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "symplectic_matrix",
        "full_api_name": "Clifford.symplectic_matrix",
        "api_description": "",
        "api_signature": "symplectic_matrix(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "phase",
        "full_api_name": "Clifford.phase",
        "api_description": "Return phase with boolean representation.",
        "api_signature": "phase(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "phase",
        "full_api_name": "Clifford.phase",
        "api_description": "",
        "api_signature": "phase(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "x",
        "full_api_name": "Clifford.x",
        "api_description": "The x array for the symplectic representation.",
        "api_signature": "x(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "x",
        "full_api_name": "Clifford.x",
        "api_description": "",
        "api_signature": "x(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "z",
        "full_api_name": "Clifford.z",
        "api_description": "The z array for the symplectic representation.",
        "api_signature": "z(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "z",
        "full_api_name": "Clifford.z",
        "api_description": "",
        "api_signature": "z(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "destab",
        "full_api_name": "Clifford.destab",
        "api_description": "The destabilizer array for the symplectic representation.",
        "api_signature": "destab(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "destab",
        "full_api_name": "Clifford.destab",
        "api_description": "",
        "api_signature": "destab(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "destab_x",
        "full_api_name": "Clifford.destab_x",
        "api_description": "The destabilizer x array for the symplectic representation.",
        "api_signature": "destab_x(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "destab_x",
        "full_api_name": "Clifford.destab_x",
        "api_description": "",
        "api_signature": "destab_x(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "destab_z",
        "full_api_name": "Clifford.destab_z",
        "api_description": "The destabilizer z array for the symplectic representation.",
        "api_signature": "destab_z(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "destab_z",
        "full_api_name": "Clifford.destab_z",
        "api_description": "",
        "api_signature": "destab_z(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "destab_phase",
        "full_api_name": "Clifford.destab_phase",
        "api_description": "Return phase of destabilizer with boolean representation.",
        "api_signature": "destab_phase(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "destab_phase",
        "full_api_name": "Clifford.destab_phase",
        "api_description": "",
        "api_signature": "destab_phase(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "stab",
        "full_api_name": "Clifford.stab",
        "api_description": "The stabilizer array for the symplectic representation.",
        "api_signature": "stab(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "stab",
        "full_api_name": "Clifford.stab",
        "api_description": "",
        "api_signature": "stab(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "stab_x",
        "full_api_name": "Clifford.stab_x",
        "api_description": "The stabilizer x array for the symplectic representation.",
        "api_signature": "stab_x(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "stab_x",
        "full_api_name": "Clifford.stab_x",
        "api_description": "",
        "api_signature": "stab_x(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "stab_z",
        "full_api_name": "Clifford.stab_z",
        "api_description": "The stabilizer array for the symplectic representation.",
        "api_signature": "stab_z(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "stab_z",
        "full_api_name": "Clifford.stab_z",
        "api_description": "",
        "api_signature": "stab_z(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "stab_phase",
        "full_api_name": "Clifford.stab_phase",
        "api_description": "Return phase of stabilizer with boolean representation.",
        "api_signature": "stab_phase(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "stab_phase",
        "full_api_name": "Clifford.stab_phase",
        "api_description": "",
        "api_signature": "stab_phase(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "is_unitary",
        "full_api_name": "Clifford.is_unitary",
        "api_description": "Return True if the Clifford table is valid.",
        "api_signature": "is_unitary(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "conjugate",
        "full_api_name": "Clifford.conjugate",
        "api_description": "",
        "api_signature": "conjugate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "adjoint",
        "full_api_name": "Clifford.adjoint",
        "api_description": "",
        "api_signature": "adjoint(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "transpose",
        "full_api_name": "Clifford.transpose",
        "api_description": "",
        "api_signature": "transpose(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "tensor",
        "full_api_name": "Clifford.tensor",
        "api_description": "",
        "api_signature": "tensor(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "expand",
        "full_api_name": "Clifford.expand",
        "api_description": "",
        "api_signature": "expand(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "_tensor",
        "full_api_name": "Clifford._tensor",
        "api_description": "",
        "api_signature": "_tensor(cls, a, b)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "compose",
        "full_api_name": "Clifford.compose",
        "api_description": "",
        "api_signature": "compose(self, other, qargs, front)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "_compose_general",
        "full_api_name": "Clifford._compose_general",
        "api_description": "",
        "api_signature": "_compose_general(cls, first, second)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "_compose_1q",
        "full_api_name": "Clifford._compose_1q",
        "api_description": "",
        "api_signature": "_compose_1q(cls, first, second)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "_compose_lookup",
        "full_api_name": "Clifford._compose_lookup",
        "api_description": "",
        "api_signature": "_compose_lookup(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "to_dict",
        "full_api_name": "Clifford.to_dict",
        "api_description": "Return dictionary representation of Clifford object.",
        "api_signature": "to_dict(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "from_dict",
        "full_api_name": "Clifford.from_dict",
        "api_description": "Load a Clifford from a dictionary",
        "api_signature": "from_dict(cls, obj)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "to_matrix",
        "full_api_name": "Clifford.to_matrix",
        "api_description": "Convert operator to Numpy matrix.",
        "api_signature": "to_matrix(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "from_matrix",
        "full_api_name": "Clifford.from_matrix",
        "api_description": "Create a Clifford from a unitary matrix.\n\nNote that this function takes exponentially long time w.r.t. the number of qubits.\n\nArgs:\n    matrix (np.array): A unitary matrix representing a Clifford to be converted.\n\nReturns:\n    Clifford: the Clifford object for the unitary matrix.\n\nRaises:\n    QiskitError: if the input is not a Clifford matrix.",
        "api_signature": "from_matrix(cls, matrix)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "from_linear_function",
        "full_api_name": "Clifford.from_linear_function",
        "api_description": "Create a Clifford from a Linear Function.\n\nIf the linear function is represented by a nxn binary invertible matrix A,\nthen the corresponding Clifford has symplectic matrix [[A^t, 0], [0, A^{-1}]].\n\nArgs:\n    linear_function (LinearFunction): A linear function to be converted.\n\nReturns:\n    Clifford: the Clifford object for this linear function.",
        "api_signature": "from_linear_function(cls, linear_function)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "from_permutation",
        "full_api_name": "Clifford.from_permutation",
        "api_description": "Create a Clifford from a PermutationGate.\n\nArgs:\n    permutation_gate (PermutationGate): A permutation to be converted.\n\nReturns:\n    Clifford: the Clifford object for this permutation.",
        "api_signature": "from_permutation(cls, permutation_gate)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "to_operator",
        "full_api_name": "Clifford.to_operator",
        "api_description": "Convert to an Operator object.",
        "api_signature": "to_operator(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "from_operator",
        "full_api_name": "Clifford.from_operator",
        "api_description": "Create a Clifford from a operator.\n\nNote that this function takes exponentially long time w.r.t. the number of qubits.\n\nArgs:\n    operator (Operator): An operator representing a Clifford to be converted.\n\nReturns:\n    Clifford: the Clifford object for the operator.\n\nRaises:\n    QiskitError: if the input is not a Clifford operator.",
        "api_signature": "from_operator(cls, operator)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "to_circuit",
        "full_api_name": "Clifford.to_circuit",
        "api_description": "Return a QuantumCircuit implementing the Clifford.\n\nFor N <= 3 qubits this is based on optimal CX cost decomposition\nfrom reference [1]. For N > 3 qubits this is done using the general\nnon-optimal compilation routine from reference [2].\n\nReturn:\n    QuantumCircuit: a circuit implementation of the Clifford.\n\nReferences:\n    1. S. Bravyi, D. Maslov, *Hadamard-free circuits expose the\n       structure of the Clifford group*,\n       `arXiv:2003.09412 [quant-ph] <https://arxiv.org/abs/2003.09412>`_\n\n    2. S. Aaronson, D. Gottesman, *Improved Simulation of Stabilizer Circuits*,\n       Phys. Rev. A 70, 052328 (2004).\n       `arXiv:quant-ph/0406196 <https://arxiv.org/abs/quant-ph/0406196>`_",
        "api_signature": "to_circuit(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "to_instruction",
        "full_api_name": "Clifford.to_instruction",
        "api_description": "Return a Gate instruction implementing the Clifford.",
        "api_signature": "to_instruction(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "from_circuit",
        "full_api_name": "Clifford.from_circuit",
        "api_description": "Initialize from a QuantumCircuit or Instruction.\n\nArgs:\n    circuit (QuantumCircuit or ~qiskit.circuit.Instruction):\n        instruction to initialize.\n\nReturns:\n    Clifford: the Clifford object for the instruction.\n\nRaises:\n    QiskitError: if the input instruction is non-Clifford or contains\n                 classical register instruction.",
        "api_signature": "from_circuit(circuit)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "from_label",
        "full_api_name": "Clifford.from_label",
        "api_description": "Return a tensor product of single-qubit Clifford gates.\n\nArgs:\n    label (string): single-qubit operator string.\n\nReturns:\n    Clifford: The N-qubit Clifford operator.\n\nRaises:\n    QiskitError: if the label contains invalid characters.\n\nAdditional Information:\n    The labels correspond to the single-qubit Cliffords are\n\n    * - Label\n      - Stabilizer\n      - Destabilizer\n    * - ``\"I\"``\n      - +Z\n      - +X\n    * - ``\"X\"``\n      - -Z\n      - +X\n    * - ``\"Y\"``\n      - -Z\n      - -X\n    * - ``\"Z\"``\n      - +Z\n      - -X\n    * - ``\"H\"``\n      - +X\n      - +Z\n    * - ``\"S\"``\n      - +Z\n      - +Y",
        "api_signature": "from_label(label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "to_labels",
        "full_api_name": "Clifford.to_labels",
        "api_description": "Convert a Clifford to a list Pauli (de)stabilizer string labels.\n\nFor large Clifford converting using the ``array=True``\nkwarg will be more efficient since it allocates memory for\nthe full Numpy array of labels in advance.\n\n.. list-table:: Stabilizer Representations\n    :header-rows: 1\n\n    * - Label\n      - Phase\n      - Symplectic\n      - Matrix\n      - Pauli\n    * - ``\"+I\"``\n      - 0\n      - :math:`[0, 0]`\n      - :math:`\\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\end{bmatrix}`\n      - :math:`I`\n    * - ``\"-I\"``\n      - 1\n      - :math:`[0, 0]`\n      - :math:`\\begin{bmatrix} -1 & 0 \\\\ 0 & -1 \\end{bmatrix}`\n      - :math:`-I`\n    * - ``\"X\"``\n      - 0\n      - :math:`[1, 0]`\n      - :math:`\\begin{bmatrix} 0 & 1 \\\\ 1 & 0  \\end{bmatrix}`\n      - :math:`X`\n    * - ``\"-X\"``\n      - 1\n      - :math:`[1, 0]`\n      - :math:`\\begin{bmatrix} 0 & -1 \\\\ -1 & 0  \\end{bmatrix}`\n      - :math:`-X`\n    * - ``\"Y\"``\n      - 0\n      - :math:`[1, 1]`\n      - :math:`\\begin{bmatrix} 0 & 1 \\\\ -1 & 0  \\end{bmatrix}`\n      - :math:`iY`\n    * - ``\"-Y\"``\n      - 1\n      - :math:`[1, 1]`\n      - :math:`\\begin{bmatrix} 0 & -1 \\\\ 1 & 0  \\end{bmatrix}`\n      - :math:`-iY`\n    * - ``\"Z\"``\n      - 0\n      - :math:`[0, 1]`\n      - :math:`\\begin{bmatrix} 1 & 0 \\\\ 0 & -1  \\end{bmatrix}`\n      - :math:`Z`\n    * - ``\"-Z\"``\n      - 1\n      - :math:`[0, 1]`\n      - :math:`\\begin{bmatrix} -1 & 0 \\\\ 0 & 1  \\end{bmatrix}`\n      - :math:`-Z`\n\nArgs:\n    array (bool): return a Numpy array if True, otherwise\n                  return a list (Default: False).\n    mode (Literal[\"S\", \"D\", \"B\"]): return both stabilizer and destabilizer if \"B\",\n        return only stabilizer if \"S\" and return only destabilizer if \"D\".\n\nReturns:\n    list or array: The rows of the StabilizerTable in label form.\nRaises:\n    QiskitError: if stabilizer and destabilizer are both False.",
        "api_signature": "to_labels(self, array, mode)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "_hash",
        "full_api_name": "Clifford._hash",
        "api_description": "Produce a hashable value that is unique for each different Clifford.  This should only be\nused internally when the classes being hashed are under our control, because classes of this\ntype are mutable.",
        "api_signature": "_hash(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "_is_symplectic",
        "full_api_name": "Clifford._is_symplectic",
        "api_description": "Return True if input is symplectic matrix.",
        "api_signature": "_is_symplectic(mat)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "_conjugate_transpose",
        "full_api_name": "Clifford._conjugate_transpose",
        "api_description": "Return the adjoint, conjugate, or transpose of the Clifford.\n\nArgs:\n    clifford (Clifford): a clifford object.\n    method (str): what function to apply 'A', 'C', or 'T'.\n\nReturns:\n    Clifford: the modified clifford.",
        "api_signature": "_conjugate_transpose(clifford, method)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "_pad_with_identity",
        "full_api_name": "Clifford._pad_with_identity",
        "api_description": "Pad Clifford with identities on other subsystems.",
        "api_signature": "_pad_with_identity(self, clifford, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "_stack_table_phase",
        "full_api_name": "Clifford._stack_table_phase",
        "api_description": "",
        "api_signature": "_stack_table_phase(table, phase)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "_from_label",
        "full_api_name": "Clifford._from_label",
        "api_description": "",
        "api_signature": "_from_label(label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "_pauli_matrix_to_row",
        "full_api_name": "Clifford._pauli_matrix_to_row",
        "api_description": "Generate a binary vector (a row of tableau representation) from a Pauli matrix.\nReturn None if the non-Pauli matrix is supplied.",
        "api_signature": "_pauli_matrix_to_row(mat, num_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "find_one_index",
        "full_api_name": "Clifford.find_one_index",
        "api_description": "",
        "api_signature": "find_one_index(x)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "bitvector",
        "full_api_name": "Clifford.bitvector",
        "api_description": "",
        "api_signature": "bitvector(n, num_bits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "_unitary_matrix_to_tableau",
        "full_api_name": "Clifford._unitary_matrix_to_tableau",
        "api_description": "",
        "api_signature": "_unitary_matrix_to_tableau(matrix)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/clifford.py"
    },
    {
        "api_name": "random_pauli",
        "full_api_name": "random_pauli",
        "api_description": "Return a random Pauli.\n\nArgs:\n    num_qubits (int): the number of qubits.\n    group_phase (bool): Optional. If True generate random phase.\n                        Otherwise the phase will be set so that the\n                        Pauli coefficient is +1 (default: False).\n    seed (int or np.random.Generator): Optional. Set a fixed seed or\n                                       generator for RNG.\n\nReturns:\n    Pauli: a random Pauli",
        "api_signature": "random_pauli(num_qubits, group_phase, seed)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/random.py"
    },
    {
        "api_name": "random_pauli_list",
        "full_api_name": "random_pauli_list",
        "api_description": "Return a random PauliList.\n\nArgs:\n    num_qubits (int): the number of qubits.\n    size (int): Optional. The length of the Pauli list (Default: 1).\n    seed (int or np.random.Generator): Optional. Set a fixed seed or generator for RNG.\n    phase (bool): If True the Pauli phases are randomized, otherwise the phases are fixed to 0.\n                 [Default: True]\n\nReturns:\n    PauliList: a random PauliList.",
        "api_signature": "random_pauli_list(num_qubits, size, seed, phase)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/random.py"
    },
    {
        "api_name": "random_clifford",
        "full_api_name": "random_clifford",
        "api_description": "Return a random Clifford operator.\n\nThe Clifford is sampled using the method of Reference [1].\n\nArgs:\n    num_qubits (int): the number of qubits for the Clifford\n    seed (int or np.random.Generator): Optional. Set a fixed seed or\n                                       generator for RNG.\n\nReturns:\n    Clifford: a random Clifford operator.\n\nReference:\n    1. S. Bravyi and D. Maslov, *Hadamard-free circuits expose the\n       structure of the Clifford group*.\n       `arXiv:2003.09412 [quant-ph] <https://arxiv.org/abs/2003.09412>`_",
        "api_signature": "random_clifford(num_qubits, seed)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/random.py"
    },
    {
        "api_name": "_sample_qmallows",
        "full_api_name": "_sample_qmallows",
        "api_description": "Sample from the quantum Mallows distribution",
        "api_signature": "_sample_qmallows(n, rng)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/random.py"
    },
    {
        "api_name": "_fill_tril",
        "full_api_name": "_fill_tril",
        "api_description": "Add symmetric random ints to off diagonals",
        "api_signature": "_fill_tril(mat, rng, symmetric)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/random.py"
    },
    {
        "api_name": "_inverse_tril",
        "full_api_name": "_inverse_tril",
        "api_description": "Invert a lower-triangular matrix with unit diagonal.",
        "api_signature": "_inverse_tril(mat, block_inverse_threshold)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/random.py"
    },
    {
        "api_name": "pauli_basis",
        "full_api_name": "pauli_basis",
        "api_description": "Return the ordered PauliList for the n-qubit Pauli basis.\n\nArgs:\n    num_qubits (int): number of qubits\n    weight (bool): if True optionally return the basis sorted by Pauli weight\n                   rather than lexicographic order (Default: False)\n\nReturns:\n    PauliList: the Paulis for the basis",
        "api_signature": "pauli_basis(num_qubits, weight)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli_utils.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "Pauli.__init__",
        "api_description": "Initialize the Pauli.\n\nWhen using the symplectic array input data both z and x arguments must\nbe provided, however the first (z) argument can be used alone for string\nlabel, Pauli operator, or :class:`.ScalarOp` input data.\n\nArgs:\n    data (str or tuple or Pauli or ScalarOp): input data for Pauli. If input is\n        a tuple it must be of the form ``(z, x)`` or ``(z, x, phase)`` where\n        ``z`` and ``x`` are boolean Numpy arrays, and phase is an integer from\n        :math:`\\mathbb{Z}_4`.\n        If input is a string, it must be a concatenation of a phase and a Pauli string\n        (e.g. ``'XYZ', '-iZIZ'``) where a phase string is a combination of at most three\n        characters from ``['+', '-', '']``, ``['1', '']``, and ``['i', 'j', '']`` in this order,\n        e.g. ``''``, ``'-1j'`` while a Pauli string is 1 or more\n        characters of ``'I'``, ``'X'``, ``'Y'``, or ``'Z'``,\n        e.g. ``'Z'``, ``'XIYY'``.\n\nRaises:\n    QiskitError: if input array is invalid shape.",
        "api_signature": "__init__(self, data)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "name",
        "full_api_name": "Pauli.name",
        "api_description": "Unique string identifier for operation type.",
        "api_signature": "name(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "num_clbits",
        "full_api_name": "Pauli.num_clbits",
        "api_description": "Number of classical bits.",
        "api_signature": "num_clbits(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "__repr__",
        "full_api_name": "Pauli.__repr__",
        "api_description": "Display representation.",
        "api_signature": "__repr__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "__str__",
        "full_api_name": "Pauli.__str__",
        "api_description": "Print representation.",
        "api_signature": "__str__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "__array__",
        "full_api_name": "Pauli.__array__",
        "api_description": "",
        "api_signature": "__array__(self, dtype, copy)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "set_truncation",
        "full_api_name": "Pauli.set_truncation",
        "api_description": "Set the max number of Pauli characters to display before truncation/\n\nArgs:\n    val (int): the number of characters.\n\n.. note::\n\n    Truncation will be disabled if the truncation value is set to 0.",
        "api_signature": "set_truncation(cls, val)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "__eq__",
        "full_api_name": "Pauli.__eq__",
        "api_description": "Test if two Paulis are equal.",
        "api_signature": "__eq__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "equiv",
        "full_api_name": "Pauli.equiv",
        "api_description": "Return True if Pauli's are equivalent up to group phase.\n\nArgs:\n    other (Pauli): an operator object.\n\nReturns:\n    bool: True if the Pauli's are equivalent up to group phase.",
        "api_signature": "equiv(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "settings",
        "full_api_name": "Pauli.settings",
        "api_description": "Return settings.",
        "api_signature": "settings(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "phase",
        "full_api_name": "Pauli.phase",
        "api_description": "Return the group phase exponent for the Pauli.",
        "api_signature": "phase(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "phase",
        "full_api_name": "Pauli.phase",
        "api_description": "",
        "api_signature": "phase(self, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "x",
        "full_api_name": "Pauli.x",
        "api_description": "The x vector for the Pauli.",
        "api_signature": "x(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "x",
        "full_api_name": "Pauli.x",
        "api_description": "",
        "api_signature": "x(self, val)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "z",
        "full_api_name": "Pauli.z",
        "api_description": "The z vector for the Pauli.",
        "api_signature": "z(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "z",
        "full_api_name": "Pauli.z",
        "api_description": "",
        "api_signature": "z(self, val)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "__len__",
        "full_api_name": "Pauli.__len__",
        "api_description": "Return the number of qubits in the Pauli.",
        "api_signature": "__len__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "__getitem__",
        "full_api_name": "Pauli.__getitem__",
        "api_description": "Return the unsigned Pauli group Pauli for subset of qubits.",
        "api_signature": "__getitem__(self, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "__setitem__",
        "full_api_name": "Pauli.__setitem__",
        "api_description": "Update the Pauli for a subset of qubits.",
        "api_signature": "__setitem__(self, qubits, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "delete",
        "full_api_name": "Pauli.delete",
        "api_description": "Return a Pauli with qubits deleted.\n\nArgs:\n    qubits (int or list): qubits to delete from Pauli.\n\nReturns:\n    Pauli: the resulting Pauli with the specified qubits removed.\n\nRaises:\n    QiskitError: if ind is out of bounds for the array size or\n                 number of qubits.",
        "api_signature": "delete(self, qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "insert",
        "full_api_name": "Pauli.insert",
        "api_description": "Insert a Pauli at specific qubit value.\n\nArgs:\n    qubits (int or list): qubits index to insert at.\n    value (Pauli): value to insert.\n\nReturns:\n    Pauli: the resulting Pauli with the entries inserted.\n\nRaises:\n    QiskitError: if the insertion qubits are invalid.",
        "api_signature": "insert(self, qubits, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "__hash__",
        "full_api_name": "Pauli.__hash__",
        "api_description": "Make hashable based on string representation.",
        "api_signature": "__hash__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "to_label",
        "full_api_name": "Pauli.to_label",
        "api_description": "Convert a Pauli to a string label.\n\n.. note::\n\n    The difference between `to_label` and :meth:`__str__` is that\n    the later will truncate the output for large numbers of qubits.\n\nReturns:\n    str: the Pauli string label.",
        "api_signature": "to_label(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "to_matrix",
        "full_api_name": "Pauli.to_matrix",
        "api_description": "Convert to a Numpy array or sparse CSR matrix.\n\nArgs:\n    sparse (bool): if True return sparse CSR matrices, otherwise\n                   return dense Numpy arrays (default: False).\n\nReturns:\n    array: The Pauli matrix.",
        "api_signature": "to_matrix(self, sparse)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "to_instruction",
        "full_api_name": "Pauli.to_instruction",
        "api_description": "Convert to Pauli circuit instruction.",
        "api_signature": "to_instruction(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "compose",
        "full_api_name": "Pauli.compose",
        "api_description": "Return the operator composition with another Pauli.\n\nArgs:\n    other (Pauli): a Pauli object.\n    qargs (list or None): Optional, qubits to apply dot product\n                          on (default: None).\n    front (bool): If True compose using right operator multiplication,\n                  instead of left multiplication [default: False].\n    inplace (bool): If True update in-place (default: False).\n\nReturns:\n    Pauli: The composed Pauli.\n\nRaises:\n    QiskitError: if other cannot be converted to an operator, or has\n                 incompatible dimensions for specified subsystems.\n\n.. note::\n    Composition (``&``) by default is defined as `left` matrix multiplication for\n    matrix operators, while :meth:`dot` is defined as `right` matrix\n    multiplication. That is that ``A & B == A.compose(B)`` is equivalent to\n    ``B.dot(A)`` when ``A`` and ``B`` are of the same type.\n\n    Setting the ``front=True`` kwarg changes this to `right` matrix\n    multiplication and is equivalent to the :meth:`dot` method\n    ``A.dot(B) == A.compose(B, front=True)``.",
        "api_signature": "compose(self, other, qargs, front, inplace)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "dot",
        "full_api_name": "Pauli.dot",
        "api_description": "Return the right multiplied operator self * other.\n\nArgs:\n    other (Pauli): an operator object.\n    qargs (list or None): Optional, qubits to apply dot product\n                          on (default: None).\n    inplace (bool): If True update in-place (default: False).\n\nReturns:\n    Pauli: The operator self * other.",
        "api_signature": "dot(self, other, qargs, inplace)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "tensor",
        "full_api_name": "Pauli.tensor",
        "api_description": "",
        "api_signature": "tensor(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "expand",
        "full_api_name": "Pauli.expand",
        "api_description": "",
        "api_signature": "expand(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "_multiply",
        "full_api_name": "Pauli._multiply",
        "api_description": "",
        "api_signature": "_multiply(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "conjugate",
        "full_api_name": "Pauli.conjugate",
        "api_description": "",
        "api_signature": "conjugate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "transpose",
        "full_api_name": "Pauli.transpose",
        "api_description": "",
        "api_signature": "transpose(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "adjoint",
        "full_api_name": "Pauli.adjoint",
        "api_description": "",
        "api_signature": "adjoint(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "inverse",
        "full_api_name": "Pauli.inverse",
        "api_description": "Return the inverse of the Pauli.",
        "api_signature": "inverse(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "commutes",
        "full_api_name": "Pauli.commutes",
        "api_description": "Return True if the Pauli commutes with other.\n\nArgs:\n    other (Pauli or PauliList): another Pauli operator.\n    qargs (list): qubits to apply dot product on (default: None).\n\nReturns:\n    bool: True if Pauli's commute, False if they anti-commute.",
        "api_signature": "commutes(self, other, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "anticommutes",
        "full_api_name": "Pauli.anticommutes",
        "api_description": "Return True if other Pauli anticommutes with self.\n\nArgs:\n    other (Pauli): another Pauli operator.\n    qargs (list): qubits to apply dot product on (default: None).\n\nReturns:\n    bool: True if Pauli's anticommute, False if they commute.",
        "api_signature": "anticommutes(self, other, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "evolve",
        "full_api_name": "Pauli.evolve",
        "api_description": "Performs either Heisenberg (default) or Schr\u00f6dinger picture\nevolution of the Pauli by a Clifford and returns the evolved Pauli.\n\nSchr\u00f6dinger picture evolution can be chosen by passing parameter ``frame='s'``.\nThis option yields a faster calculation.\n\nHeisenberg picture evolves the Pauli as :math:`P^\\prime = C^\\dagger.P.C`.\n\nSchr\u00f6dinger picture evolves the Pauli as :math:`P^\\prime = C.P.C^\\dagger`.\n\nArgs:\n    other (Pauli or Clifford or QuantumCircuit): The Clifford operator to evolve by.\n    qargs (list): a list of qubits to apply the Clifford to.\n    frame (string): ``'h'`` for Heisenberg (default) or ``'s'`` for\n    Schr\u00f6dinger framework.\n\nReturns:\n    Pauli: the Pauli :math:`C^\\dagger.P.C` (Heisenberg picture)\n    or the Pauli :math:`C.P.C^\\dagger` (Schr\u00f6dinger picture).\n\nRaises:\n    QiskitError: if the Clifford number of qubits and qargs don't match.",
        "api_signature": "evolve(self, other, qargs, frame)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "_from_label",
        "full_api_name": "Pauli._from_label",
        "api_description": "Return the symplectic representation of Pauli string.\n\nArgs:\n    label (str): the Pauli string label.\n\nReturns:\n    BasePauli: the BasePauli corresponding to the label.\n\nRaises:\n    QiskitError: if Pauli string is not valid.",
        "api_signature": "_from_label(label)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "_from_scalar_op",
        "full_api_name": "Pauli._from_scalar_op",
        "api_description": "Convert a ScalarOp to BasePauli data.",
        "api_signature": "_from_scalar_op(cls, op)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "_from_pauli_instruction",
        "full_api_name": "Pauli._from_pauli_instruction",
        "api_description": "Convert a Pauli instruction to BasePauli data.",
        "api_signature": "_from_pauli_instruction(cls, instr)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "_from_circuit",
        "full_api_name": "Pauli._from_circuit",
        "api_description": "Convert a Pauli circuit to BasePauli data.",
        "api_signature": "_from_circuit(cls, instr)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "apply_layout",
        "full_api_name": "Pauli.apply_layout",
        "api_description": "Apply a transpiler layout to this :class:`~.Pauli`\n\nArgs:\n    layout: Either a :class:`~.TranspileLayout`, a list of integers or None.\n            If both layout and num_qubits are none, a copy of the operator is\n            returned.\n    num_qubits: The number of qubits to expand the operator to. If not\n        provided then if ``layout`` is a :class:`~.TranspileLayout` the\n        number of the transpiler output circuit qubits will be used by\n        default. If ``layout`` is a list of integers the permutation\n        specified will be applied without any expansion. If layout is\n        None, the operator will be expanded to the given number of qubits.\n\nReturns:\n    A new :class:`.Pauli` with the provided layout applied",
        "api_signature": "apply_layout(self, layout, num_qubits)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/symplectic/pauli.py"
    },
    {
        "api_name": "adjoint",
        "full_api_name": "AdjointMixin.adjoint",
        "api_description": "Return the adjoint of the CLASS.",
        "api_signature": "adjoint(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/mixins/adjoint.py"
    },
    {
        "api_name": "conjugate",
        "full_api_name": "AdjointMixin.conjugate",
        "api_description": "Return the conjugate of the CLASS.",
        "api_signature": "conjugate(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/mixins/adjoint.py"
    },
    {
        "api_name": "transpose",
        "full_api_name": "AdjointMixin.transpose",
        "api_description": "Return the transpose of the CLASS.",
        "api_signature": "transpose(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/mixins/adjoint.py"
    },
    {
        "api_name": "__and__",
        "full_api_name": "GroupMixin.__and__",
        "api_description": "",
        "api_signature": "__and__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/mixins/group.py"
    },
    {
        "api_name": "__pow__",
        "full_api_name": "GroupMixin.__pow__",
        "api_description": "",
        "api_signature": "__pow__(self, n)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/mixins/group.py"
    },
    {
        "api_name": "__xor__",
        "full_api_name": "GroupMixin.__xor__",
        "api_description": "",
        "api_signature": "__xor__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/mixins/group.py"
    },
    {
        "api_name": "__matmul__",
        "full_api_name": "GroupMixin.__matmul__",
        "api_description": "",
        "api_signature": "__matmul__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/mixins/group.py"
    },
    {
        "api_name": "tensor",
        "full_api_name": "GroupMixin.tensor",
        "api_description": "Return the tensor product with another CLASS.\n\nArgs:\n    other (CLASS): a CLASS object.\n\nReturns:\n    CLASS: the tensor product :math:`a \\otimes b`, where :math:`a`\n        is the current CLASS, and :math:`b` is the other CLASS.\n\n.. note::\n    The tensor product can be obtained using the ``^`` binary operator.\n    Hence ``a.tensor(b)`` is equivalent to ``a ^ b``.\n\n.. note:\n    Tensor uses reversed operator ordering to :meth:`expand`.\n    For two operators of the same type ``a.tensor(b) = b.expand(a)``.",
        "api_signature": "tensor(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/mixins/group.py"
    },
    {
        "api_name": "expand",
        "full_api_name": "GroupMixin.expand",
        "api_description": "Return the reverse-order tensor product with another CLASS.\n\nArgs:\n    other (CLASS): a CLASS object.\n\nReturns:\n    CLASS: the tensor product :math:`b \\otimes a`, where :math:`a`\n        is the current CLASS, and :math:`b` is the other CLASS.\n\n.. note:\n    Expand is the opposite operator ordering to :meth:`tensor`.\n    For two operators of the same type ``a.expand(b) = b.tensor(a)``.",
        "api_signature": "expand(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/mixins/group.py"
    },
    {
        "api_name": "compose",
        "full_api_name": "GroupMixin.compose",
        "api_description": "Return the operator composition with another CLASS.\n\nArgs:\n    other (CLASS): a CLASS object.\n    qargs (list or None): Optional, a list of subsystem positions to\n                          apply other on. If None apply on all\n                          subsystems (default: None).\n    front (bool): If True compose using right operator multiplication,\n                  instead of left multiplication [default: False].\n\nReturns:\n    CLASS: The composed CLASS.\n\nRaises:\n    QiskitError: if other cannot be converted to an operator, or has\n                 incompatible dimensions for specified subsystems.\n\n.. note::\n    Composition (``&``) by default is defined as `left` matrix multiplication for\n    matrix operators, while ``@`` (equivalent to :meth:`dot`) is defined as `right` matrix\n    multiplication. That is that ``A & B == A.compose(B)`` is equivalent to\n    ``B @ A == B.dot(A)`` when ``A`` and ``B`` are of the same type.\n\n    Setting the ``front=True`` kwarg changes this to `right` matrix\n    multiplication and is equivalent to the :meth:`dot` method\n    ``A.dot(B) == A.compose(B, front=True)``.",
        "api_signature": "compose(self, other, qargs, front)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/mixins/group.py"
    },
    {
        "api_name": "dot",
        "full_api_name": "GroupMixin.dot",
        "api_description": "Return the right multiplied operator self * other.\n\nArgs:\n    other (CLASS): an operator object.\n    qargs (list or None): Optional, a list of subsystem positions to\n                          apply other on. If None apply on all\n                          subsystems (default: None).\n\nReturns:\n    CLASS: The right matrix multiplied CLASS.\n\n.. note::\n    The dot product can be obtained using the ``@`` binary operator.\n    Hence ``a.dot(b)`` is equivalent to ``a @ b``.",
        "api_signature": "dot(self, other, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/mixins/group.py"
    },
    {
        "api_name": "power",
        "full_api_name": "GroupMixin.power",
        "api_description": "Return the compose of a operator with itself n times.\n\nArgs:\n    n (int): the number of times to compose with self (n>0).\n\nReturns:\n    CLASS: the n-times composed operator.\n\nRaises:\n    QiskitError: if the input and output dimensions of the operator\n                 are not equal, or the power is not a positive integer.",
        "api_signature": "power(self, n)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/mixins/group.py"
    },
    {
        "api_name": "generate_apidocs",
        "full_api_name": "generate_apidocs",
        "api_description": "Decorator to format API docstrings for classes using Mixins.\n\nThis runs string replacement on the docstrings of the mixin\nmethods to replace the placeholder CLASS with the class\nname `cls.__name__`.\n\nArgs:\n    cls (type): The class to format docstrings.\n\nReturns:\n    cls: the original class with updated docstrings.",
        "api_signature": "generate_apidocs(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/mixins/__init__.py"
    },
    {
        "api_name": "_replace_name",
        "full_api_name": "_replace_name",
        "api_description": "",
        "api_signature": "_replace_name(mixin, methods)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/mixins/__init__.py"
    },
    {
        "api_name": "__rmul__",
        "full_api_name": "MultiplyMixin.__rmul__",
        "api_description": "",
        "api_signature": "__rmul__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/mixins/multiply.py"
    },
    {
        "api_name": "__mul__",
        "full_api_name": "MultiplyMixin.__mul__",
        "api_description": "",
        "api_signature": "__mul__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/mixins/multiply.py"
    },
    {
        "api_name": "__truediv__",
        "full_api_name": "MultiplyMixin.__truediv__",
        "api_description": "",
        "api_signature": "__truediv__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/mixins/multiply.py"
    },
    {
        "api_name": "__neg__",
        "full_api_name": "MultiplyMixin.__neg__",
        "api_description": "",
        "api_signature": "__neg__(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/mixins/multiply.py"
    },
    {
        "api_name": "_multiply",
        "full_api_name": "MultiplyMixin._multiply",
        "api_description": "Return the CLASS other * self.\n\nArgs:\n    other (complex): a complex number.\n\nReturns:\n    CLASS: the CLASS other * self.",
        "api_signature": "_multiply(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/mixins/multiply.py"
    },
    {
        "api_name": "__init__",
        "full_api_name": "TolerancesMeta.__init__",
        "api_description": "",
        "api_signature": "__init__(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/mixins/tolerances.py"
    },
    {
        "api_name": "_check_value",
        "full_api_name": "TolerancesMeta._check_value",
        "api_description": "Check if value is within valid ranges",
        "api_signature": "_check_value(cls, value, value_name)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/mixins/tolerances.py"
    },
    {
        "api_name": "atol",
        "full_api_name": "TolerancesMeta.atol",
        "api_description": "Default absolute tolerance parameter for float comparisons.",
        "api_signature": "atol(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/mixins/tolerances.py"
    },
    {
        "api_name": "atol",
        "full_api_name": "TolerancesMeta.atol",
        "api_description": "Set default absolute tolerance parameter for float comparisons.",
        "api_signature": "atol(cls, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/mixins/tolerances.py"
    },
    {
        "api_name": "rtol",
        "full_api_name": "TolerancesMeta.rtol",
        "api_description": "Default relative tolerance parameter for float comparisons.",
        "api_signature": "rtol(cls)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/mixins/tolerances.py"
    },
    {
        "api_name": "rtol",
        "full_api_name": "TolerancesMeta.rtol",
        "api_description": "Set default relative tolerance parameter for float comparisons.",
        "api_signature": "rtol(cls, value)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/mixins/tolerances.py"
    },
    {
        "api_name": "atol",
        "full_api_name": "TolerancesMixin.atol",
        "api_description": "Default absolute tolerance parameter for float comparisons.",
        "api_signature": "atol(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/mixins/tolerances.py"
    },
    {
        "api_name": "rtol",
        "full_api_name": "TolerancesMixin.rtol",
        "api_description": "Default relative tolerance parameter for float comparisons.",
        "api_signature": "rtol(self)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/mixins/tolerances.py"
    },
    {
        "api_name": "__add__",
        "full_api_name": "LinearMixin.__add__",
        "api_description": "",
        "api_signature": "__add__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/mixins/linear.py"
    },
    {
        "api_name": "__radd__",
        "full_api_name": "LinearMixin.__radd__",
        "api_description": "",
        "api_signature": "__radd__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/mixins/linear.py"
    },
    {
        "api_name": "__sub__",
        "full_api_name": "LinearMixin.__sub__",
        "api_description": "",
        "api_signature": "__sub__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/mixins/linear.py"
    },
    {
        "api_name": "__rsub__",
        "full_api_name": "LinearMixin.__rsub__",
        "api_description": "",
        "api_signature": "__rsub__(self, other)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/mixins/linear.py"
    },
    {
        "api_name": "_add",
        "full_api_name": "LinearMixin._add",
        "api_description": "Return the CLASS self + other.\n\nIf ``qargs`` are specified the other operator will be added\nassuming it is identity on all other subsystems.\n\nArgs:\n    other (CLASS): an operator object.\n    qargs (None or list): optional subsystems to add on\n                          (Default: None)\n\nReturns:\n    CLASS: the CLASS self + other.",
        "api_signature": "_add(self, other, qargs)",
        "file_path": "/usr/local/lib/python3.10/site-packages/qiskit/quantum_info/operators/mixins/linear.py"
    }
]