"""Script to generate quantum circuits with LLAMA 3 (via groq cloud models).

It generates valid quantum programs in a given platform (e.g. qiskit, pennylane)
when given an API to use.

--platform: str platform to test, either qiskit, pennylane, or pytket
--output_folder: str path to where to store the generated py programs. (default: program_bank)
    the new programs will be stored in a subfolder with the name the data and time
    e.g. 2024_09_30__22:50__qiskit (note the end with the title of the platform)
--prompt: str. path to the prompt template (default: mono_program_generator.jinja)
--path_api_names: str. path to the JSON file that stores all the API used in the library as a list of objects.
    Each with api_name, api_description, api_signature
--groq_token_path: str. path to the txt file containing the token (default: groq_token.txt)
--max_programs: int. maximum number of programs to generate (defualt: 100)

The output is stored in the output folder as .py files generated by the model.

# Implementation
- it uses click v8 library
- it has a simple main
- it uses temperature 0 for all (for reproducibility)
- log the LLM output (removing the prompt)
- run it on cuda GPU if available
- model name: llama-3.1-8b-instant
- token limit: 1024 (max_tokens arg)
- the prompt template gets the PLATFORM and API_INFO (as the entire object) as
    input variables
- each generated program uses a single api object, to guarantee reproducibity
    they list of api is shuffled with a fixed random seed before starting the
    generation loop
- the prompt template is in jinja, thus use render api call
- all the newly generated programs are stored in the same subfolder with the
    timestamp corresponding to the start of the generation
- it stores also all the prompt with a same name of the corresponding program
    but with ending .txt instead of .py
- exclude all the api objects that have test in the path before starting
- when running groq, make sure to catch the exeption groq.InternalServerError
    and wait 30 seconds when that occurres and then retry again, use a loop to
    do this, and after 5 failures in the look raise the exception


# Style
- it uses subfunction appropriately
- always use named arguments when calling a function
    (except for standard library functions)
- keep the style consistent to pep8 (max 80 char)
- to print the logs it uses the console from Rich library
- make sure to have docstring for each subfunction and keep it brief to the point
(also avoid comments on top of the functions)
- it uses os.path every time that it is dealing with path composition
- it uses pathlib every time that paths are checked or created.

# Reference API

```python
import os

from groq import Groq

client = Groq(
    api_key=os.environ.get("GROQ_API_KEY"),
)

chat_completion = client.chat.completions.create(
    messages=[
        {
            "role": "user",
            "content": "Explain the importance of fast language models",
        }
    ],
    model="llama3-8b-8192",
)

print(chat_completion.choices[0].message.content)
```
"""

import os
import json
import random
import time
from pathlib import Path
from datetime import datetime
import click
from rich.console import Console
from jinja2 import Environment, FileSystemLoader
from groq import Groq, InternalServerError


# Initialize rich console for logging
console = Console()


def load_api_info(path_api_names: str) -> list:
    """Load and filter API information from a JSON file."""
    with open(path_api_names, 'r') as file:
        api_info = json.load(file)
    # Exclude APIs with 'test' in their signature
    return [api for api in api_info if 'test' not in api.get('api_signature', '').lower()]


def render_prompt(prompt_path: str, platform: str, api_info: dict) -> str:
    """Render the prompt using Jinja2 template."""
    env = Environment(loader=FileSystemLoader(Path(prompt_path).parent))
    template = env.get_template(Path(prompt_path).name)
    return template.render(PLATFORM=platform, API_INFO=api_info)


def call_groq_api(client: Groq, prompt: str, model_name: str) -> str:
    """Call the Groq API to generate a quantum program with error handling."""
    retry_attempts = 5
    for attempt in range(retry_attempts):
        try:
            chat_completion = client.chat.completions.create(
                messages=[{"role": "user", "content": prompt}],
                model=model_name,
                max_tokens=1024,
                temperature=0
            )
            return chat_completion.choices[0].message.content
        except InternalServerError as e:
            if attempt < retry_attempts - 1:
                console.log(
                    f"[yellow]InternalServerError: {e}. Retrying in 30 seconds...[/yellow]")
                time.sleep(30)
            else:
                raise


def generate_programs(model_name: str, token_path: str, platform: str,
                      output_folder: str, prompt_path: str, path_api_names: str,
                      max_programs: int) -> None:
    """Generate quantum programs using the Llama model."""
    # Load and shuffle API info
    api_info = load_api_info(path_api_names)
    random.seed(42)  # Fixed seed for reproducibility
    random.shuffle(api_info)

    # Initialize Groq client
    with open(token_path, 'r') as file:
        api_key = file.read().strip()
    client = Groq(api_key=api_key)

    # Create timestamped output folder
    timestamp = datetime.now().strftime('%Y_%m_%d__%H:%M')
    output_dir = Path(output_folder) / f"{timestamp}__{platform}"
    output_dir.mkdir(parents=True, exist_ok=True)

    for i in range(max_programs):
        # Prepare the prompt with a single API object
        api_object = api_info[i % len(api_info)]
        prompt = render_prompt(prompt_path, platform, api_object)

        # Call Groq API to generate the program
        generated_code = call_groq_api(client, prompt, model_name)

        # Log and save the generated code
        console.log(f"[green]Generated program {i + 1}[/green]")

        program_path = output_dir / f"program_{i + 1}.py"
        with open(program_path, 'w') as file:
            file.write(generated_code)

        prompt_path_file = output_dir / f"program_{i + 1}.txt"
        with open(prompt_path_file, 'w') as file:
            file.write(prompt)

    console.log("[blue]All programs generated successfully![/blue]")


@click.command()
@click.option('--platform', type=str, required=True,
              help='Platform to test, either qiskit, pennylane, or pytket')
@click.option('--output_folder', type=str, default='program_bank',
              help='Path to store the generated Python programs.')
@click.option('--prompt', type=str, default='mono_program_generator.jinja',
              help='Path to the prompt template.')
@click.option('--path_api_names', type=str, required=True,
              help='Path to the JSON file with API information.')
@click.option('--groq_token_path', type=str, default='groq_token.txt',
              help='Path to the file containing the Groq API token.')
@click.option('--max_programs', type=int, default=100,
              help='Maximum number of programs to generate.')
def main(platform: str, output_folder: str, prompt: str,
         path_api_names: str, groq_token_path: str, max_programs: int) -> None:
    """Main function to generate quantum programs using Groq and Llama 3."""
    generate_programs(
        model_name="llama-3.1-8b-instant",
        token_path=groq_token_path,
        platform=platform,
        output_folder=output_folder,
        prompt_path=prompt,
        path_api_names=path_api_names,
        max_programs=max_programs
    )


if __name__ == '__main__':
    main()
