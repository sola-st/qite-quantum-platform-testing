# Section: Prologue
from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister
from qiskit_aer import AerSimulator
from qiskit_ibm_runtime import Session, Sampler
from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager

# Section: Circuit
{{QC_CIRCUIT_CODE}}

{% if PERFORM_EXECUTION %}
# Section: Execution
# Run the sampler job locally using AerSimulator.
# Session syntax is supported but ignored.
aer_sim = AerSimulator()

# Transpile
pm = generate_preset_pass_manager(backend=aer_sim, optimization_level=1)
isa_qc = pm.run(qc)

# The session is used but ignored in AerSimulator.
sampler = Sampler(mode=aer_sim)
result = sampler.run([isa_qc]).result()[0]

# Section: Results
counts = result.data.cr.get_counts()
print(f"Measurement results: {counts}")
{% endif %}


# Helper Functions
import os
import traceback
import json
import uuid
import sys
import inspect
from pathlib import Path
from typing import List, Dict, Any, Callable, Tuple, Optional


def get_functions(prefix: str) -> List[Callable]:
    """
    Finds all functions in the current module that start with the given prefix
    and returns a list of these functions without executing them.

    Args:
        prefix (str): The prefix to filter functions by.

    Returns:
        List[Callable]: A list of functions that start with the given prefix.
    """
    current_module = sys.modules[__name__]
    functions = inspect.getmembers(current_module, inspect.isfunction)
    # Filter functions that start with the given prefix
    filtered_functions = [func for name, func in functions
                          if name.startswith(prefix)]
    return filtered_functions


def log_exception_to_json(
    exception: Exception,
    stack_trace: str,
    involved_functions: List[str]
) -> None:
    """
    Logs the stack trace, current file, exception message, and involved functions to a JSON file.

    Args:
        exception (Exception): The exception to log.
        stack_trace (str): The full stack trace of the exception.
        involved_functions (List[str]): List of function names involved in the current context.
    """
    # Get current file and generate a unique log file name
    current_file = Path(__file__)
    uuid_suffix = str(uuid.uuid4())[:6]
    log_file_name = f"{current_file.stem}_{uuid_suffix}_error.json"
    log_file_path = current_file.with_name(log_file_name)

    # Create a log dictionary with all details
    log_details: Dict[str, Any] = {
        "exception_message": str(exception),
        "stack_trace": stack_trace,
        "current_file": current_file.name,
        "involved_functions": involved_functions
    }

    # Write the log details to a JSON file
    with log_file_path.open("w") as json_file:
        json.dump(log_details, json_file, indent=4)

    print(f"Log has been saved to {log_file_path}")


# Section: Oracle Functions
# <START_FUNCTIONS_EXPORT>
{{FUNCTIONS_EXPORT_TO_QASM}}
# <END_FUNCTIONS_EXPORT>
# <START_FUNCTIONS_IMPORT>
{{FUNCTION_IMPORT_FROM_QASM}}
# <END_FUNCTIONS_IMPORT>
# <START_FUNCTIONS_COMPARE>
{{FUNCTIONS_COMPARE}}
# <END_FUNCTIONS_COMPARE>

# Section: Test Oracle Calls
target_qc = {{TARGET_QC}}

# Section: Stage - QASM Exporter
export_calls = get_functions(prefix="export_to_qasm")
qasm_files_with_provenance = []
for export_call in export_calls:
    try:
        qasm_file = export_call(
            qiskit_circ=target_qc,
            var_name="{{TARGET_QC}}",
        )
        qasm_files_with_provenance.append((qasm_file, export_call.__name__))
    except Exception as e:
        stack_trace = traceback.format_exc()
        involved_functions = [export_call.__name__]
        log_exception_to_json(e, stack_trace, involved_functions)

if len(qasm_files_with_provenance) > 0:
    print(f"Exported QASM files: {qasm_files_with_provenance}")
else:
    print("No QASM files exported.")
    exit(0)

# Section: Stage - Execution
# TODO

# Section: Stage - QASM Parser
parser_calls = get_functions(prefix="import_from_qasm")
for parser_call in parser_calls:
    for qasm_file, export_call_name in qasm_files_with_provenance:
        try:
            parser_call(qasm_file)
        except Exception as e:
            stack_trace = traceback.format_exc()
            involved_functions = [parser_call.__name__, export_call_name]
            log_exception_to_json(e, stack_trace, involved_functions)

# Section: Stage - Comparison
from itertools import combinations

compare_calls = get_functions(prefix="compare_qasm_")
for pair in combinations(qasm_files_with_provenance, 2):
    a_file, a_exporter = pair[0]
    b_file, b_exporter = pair[1]
    for compare_call in compare_calls:
        try:
            compare_call(a_file, b_file)
        except Exception as e:
            stack_trace = traceback.format_exc()
            involved_functions = [compare_call.__name__, a_exporter, b_exporter]
            log_exception_to_json(e, stack_trace, involved_functions)








