from datetime import datetime
today_date = datetime.now().strftime('%d %B %Y')
"""
<|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: {today_date}.

You are a software engineer expert in quantum computing that creates novel quantum program snippets to test the quantum computing library.<|eot_id|><|start_header_id|>user<|end_header_id|>
"""
"Please generate a quantum program using the {{platform_name}} library. \n"
"Reply with only the Python code in the tags ```python ```.\n"
"Reply with the JSON only.\n"
"<|eot_id|>"
"<|start_header_id|>assistant<|end_header_id|>"
"```python\n"
new_lines = []
"from[rest_of_line]" where STOPS_AT(rest_of_line, "\n")
"# initialize a circuit of size (qubits): [n]\n" where INT(n)
"qc = [CIRCUIT_INITIALIZATION]" where STOPS_AT(CIRCUIT_INITIALIZATION, "\n")

target_lines = 3
# inject comment after n empty lines
tolerance_empty_lines = 3
empty_lines = 0
available_apis = [
    "barrier(*qargs, label=None)",
    "ccx(control_qubit1, control_qubit2, target_qubit, ctrl_state=None)",
    "ccz(control_qubit1, control_qubit2, target_qubit, label=None, ctrl_state=None)",
    "ch(control_qubit, target_qubit, label=None, ctrl_state=None)",
    "cp(theta, control_qubit, target_qubit, label=None, ctrl_state=None)",
    "crx(theta, control_qubit, target_qubit, label=None, ctrl_state=None)",
    "cry(theta, control_qubit, target_qubit, label=None, ctrl_state=None)",
    "crz(theta, control_qubit, target_qubit, label=None, ctrl_state=None)",
    "cs(control_qubit, target_qubit, label=None, ctrl_state=None)",
    "csdg(control_qubit, target_qubit, label=None, ctrl_state=None)",
    "cswap(control_qubit, target_qubit1, target_qubit2, label=None, ctrl_state=None)",
    "csx(control_qubit, target_qubit, label=None, ctrl_state=None)",
    "cu(theta, phi, lam, gamma, control_qubit, target_qubit, label=None, ctrl_state=None)",
    "cx(control_qubit, target_qubit, label=None, ctrl_state=None)",
    "cy(control_qubit, target_qubit, label=None, ctrl_state=None)",
    "cz(control_qubit, target_qubit, label=None, ctrl_state=None)",
    "dcx(qubit1, qubit2)",
    "delay(duration, qarg=None, unit='dt')",
    "ecr(qubit1, qubit2)",
    "h(qubit)",
    "id(qubit)",
    "initialize(params, qubits=None, normalize=False)",
    "iswap(qubit1, qubit2)",
    "mcp(lam, control_qubits, target_qubit, ctrl_state=None)",
    "mcrx(theta, q_controls, q_target, use_basis_gates=False)",
    "mcry(theta, q_controls, q_target, q_ancillae=None, mode=None, use_basis_gates=False)",
    "mcrz(lam, q_controls, q_target, use_basis_gates=False)",
    "mcx(control_qubits, target_qubit, ancilla_qubits=None, mode='noancilla', ctrl_state=None)",
    "measure(qubit, cbit)",
    "ms(theta, qubits)",
    "p(theta, qubit)",
    "pauli(pauli_string, qubits)",
    "prepare_state(state, qubits=None, label=None, normalize=False)",
    "r(theta, phi, qubit)",
    "rcccx(control_qubit1, control_qubit2, control_qubit3, target_qubit)",
    "rccx(control_qubit1, control_qubit2, target_qubit)",
    "reset(qubit)",
    "rv(vx, vy, vz, qubit)",
    "rx(theta, qubit, label=None)",
    "rxx(theta, qubit1, qubit2)",
    "ry(theta, qubit, label=None)",
    "ryy(theta, qubit1, qubit2)",
    "rz(phi, qubit)",
    "rzx(theta, qubit1, qubit2)",
    "rzz(theta, qubit1, qubit2)",
    "s(qubit)",
    "sdg(qubit)",
    "store(var, qubits, *, label=None)",
    "swap(qubit1, qubit2)",
    "sx(qubit)",
    "sxdg(qubit)",
    "t(qubit)",
    "tdg(qubit)",
    "u(theta, phi, lam, qubit)",
    "unitary(obj, qubits, label=None)",
    "x(qubit, label=None)",
    "y(qubit)",
    "z(qubit)"
]
for i in range(target_lines):
    "# use the follwing method of the qc object: [api_name]\n" where api_name in available_apis
    "[line]" where STOPS_AT(line, "\n") and len(TOKENS(line)) < 80

"```\n"
"<|eot_id|>"
